--- ./projects/linux/linux-2.6.15/arch/arm/mach-s3c2410/dma.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/arch/arm/mach-s3c2410/dma.c	2006-03-20 06:53:29.000000000 +0100
@@ -1155 +1155 @@
-	dma_base = ioremap(S3C2410_PA_DMA, 0x200);
+	dma_base = ioremap(S3C24XX_PA_DMA, 0x200);
--- ./projects/linux/linux-2.6.17/arch/arm/mach-s3c2410/dma.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/arm/mach-s3c2410/dma.c	2006-09-20 05:42:06.000000000 +0200
@@ -34 +33,0 @@
-#include <linux/config.h>
@@ -64 +63 @@
-s3c2410_dma_chan_t s3c2410_chans[S3C2410_DMA_CHANNELS];
+struct s3c2410_dma_chan s3c2410_chans[S3C2410_DMA_CHANNELS];
@@ -78 +77 @@
-dma_wrreg(s3c2410_dma_chan_t *chan, int reg, unsigned long val)
+dma_wrreg(struct s3c2410_dma_chan *chan, int reg, unsigned long val)
@@ -106 +105 @@
-dmadbg_capture(s3c2410_dma_chan_t *chan, struct s3c2410_dma_regstate *regs)
+dmadbg_capture(struct s3c2410_dma_chan *chan, struct s3c2410_dma_regstate *regs)
@@ -116 +115 @@
-dmadbg_showregs(const char *fname, int line, s3c2410_dma_chan_t *chan,
+dmadbg_dumpregs(const char *fname, int line, struct s3c2410_dma_chan *chan,
@@ -126 +125 @@
-dmadbg_showchan(const char *fname, int line, s3c2410_dma_chan_t *chan)
+dmadbg_showchan(const char *fname, int line, struct s3c2410_dma_chan *chan)
@@ -136 +135,10 @@
-	dmadbg_showregs(fname, line, chan, &state);
+	dmadbg_dumpregs(fname, line, chan, &state);
+}
+
+static void
+dmadbg_showregs(const char *fname, int line, struct s3c2410_dma_chan *chan)
+{
+	struct s3c2410_dma_regstate state;
+
+	dmadbg_capture(chan, &state);
+	dmadbg_dumpregs(fname, line, chan, &state);
@@ -159 +167 @@
-s3c2410_dma_stats_timeout(s3c2410_dma_stats_t *stats, int val)
+s3c2410_dma_stats_timeout(struct s3c2410_dma_stats *stats, int val)
@@ -178 +186 @@
-s3c2410_dma_waitforload(s3c2410_dma_chan_t *chan, int line)
+s3c2410_dma_waitforload(struct s3c2410_dma_chan *chan, int line)
@@ -225,2 +233,2 @@
-s3c2410_dma_loadbuffer(s3c2410_dma_chan_t *chan,
-		       s3c2410_dma_buf_t *buf)
+s3c2410_dma_loadbuffer(struct s3c2410_dma_chan *chan,
+		       struct s3c2410_dma_buf *buf)
@@ -257 +265 @@
-		pr_debug("load_state is %d => autoreload\n", chan->load_state);
+		//pr_debug("load_state is %d => autoreload\n", chan->load_state);
@@ -260,0 +269,4 @@
+	if ((buf->data & 0xf0000000) != 0x30000000) {
+		dmawarn("dmaload: buffer is %p\n", (void *)buf->data);
+	}
+
@@ -295 +307 @@
-s3c2410_dma_call_op(s3c2410_dma_chan_t *chan, s3c2410_chan_op_t op)
+s3c2410_dma_call_op(struct s3c2410_dma_chan *chan, enum s3c2410_chan_op op)
@@ -309,2 +321,2 @@
-s3c2410_dma_buffdone(s3c2410_dma_chan_t *chan, s3c2410_dma_buf_t *buf,
-		     s3c2410_dma_buffresult_t result)
+s3c2410_dma_buffdone(struct s3c2410_dma_chan *chan, struct s3c2410_dma_buf *buf,
+		     enum s3c2410_dma_buffresult result)
@@ -325 +337 @@
-static int s3c2410_dma_start(s3c2410_dma_chan_t *chan)
+static int s3c2410_dma_start(struct s3c2410_dma_chan *chan)
@@ -374 +386 @@
-	pr_debug("wrote %08lx to DMASKTRIG\n", tmp);
+	pr_debug("dma%d: %08lx to DMASKTRIG\n", chan->number, tmp);
@@ -387,0 +400,22 @@
+	/* if we've only loaded one buffer onto the channel, then chec
+	 * to see if we have another, and if so, try and load it so when
+	 * the first buffer is finished, the new one will be loaded onto
+	 * the channel */
+
+	if (chan->next != NULL) {
+		if (chan->load_state == S3C2410_DMALOAD_1LOADED) {
+
+			if (s3c2410_dma_waitforload(chan, __LINE__) == 0) {
+				pr_debug("%s: buff not yet loaded, no more todo\n",
+					 __FUNCTION__);
+			} else {
+				chan->load_state = S3C2410_DMALOAD_1RUNNING;
+				s3c2410_dma_loadbuffer(chan, chan->next);
+			}
+
+		} else if (chan->load_state == S3C2410_DMALOAD_1RUNNING) {
+			s3c2410_dma_loadbuffer(chan, chan->next);
+		}
+	}
+
+
@@ -388,0 +423 @@
+
@@ -398 +433 @@
-s3c2410_dma_canload(s3c2410_dma_chan_t *chan)
+s3c2410_dma_canload(struct s3c2410_dma_chan *chan)
@@ -428,2 +463,2 @@
-	s3c2410_dma_chan_t *chan = &s3c2410_chans[channel];
-	s3c2410_dma_buf_t *buf;
+	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_buf *buf;
@@ -440 +475 @@
-			 __FUNCTION__, sizeof(*buf));
+			 __FUNCTION__, (long)sizeof(*buf));
@@ -444,2 +479 @@
-	pr_debug("%s: new buffer %p\n", __FUNCTION__, buf);
-
+	//pr_debug("%s: new buffer %p\n", __FUNCTION__, buf);
@@ -509 +543 @@
-s3c2410_dma_freebuf(s3c2410_dma_buf_t *buf)
+s3c2410_dma_freebuf(struct s3c2410_dma_buf *buf)
@@ -529 +563 @@
-s3c2410_dma_lastxfer(s3c2410_dma_chan_t *chan)
+s3c2410_dma_lastxfer(struct s3c2410_dma_chan *chan)
@@ -541,2 +575,2 @@
-			printk(KERN_ERR "dma%d: timeout waiting for load\n",
-			       chan->number);
+			printk(KERN_ERR "dma%d: timeout waiting for load (%s)\n",
+			       chan->number, __FUNCTION__);
@@ -546,0 +581,6 @@
+	case S3C2410_DMALOAD_1LOADED_1RUNNING:
+		/* I belive in this case we do not have anything to do
+		 * until the next buffer comes along, and we turn off the
+		 * reload */
+		return;
+
@@ -548 +588 @@
-		pr_debug("dma%d: lastxfer: unhandled load_state %d with no next",
+		pr_debug("dma%d: lastxfer: unhandled load_state %d with no next\n",
@@ -564,2 +604,2 @@
-	s3c2410_dma_chan_t *chan = (s3c2410_dma_chan_t *)devpw;
-	s3c2410_dma_buf_t  *buf;
+	struct s3c2410_dma_chan *chan = (struct s3c2410_dma_chan *)devpw;
+	struct s3c2410_dma_buf  *buf;
@@ -633 +673,8 @@
-	if (chan->next != NULL) {
+	/* only reload if the channel is still running... our buffer done
+	 * routine may have altered the state by requesting the dma channel
+	 * to stop or shutdown... */
+
+	/* todo: check that when the channel is shut-down from inside this
+	 * function, we cope with unsetting reload, etc */
+
+	if (chan->next != NULL && chan->state != S3C2410_DMA_IDLE) {
@@ -648,2 +695,2 @@
-				printk(KERN_ERR "dma%d: timeout waiting for load\n",
-				       chan->number);
+				printk(KERN_ERR "dma%d: timeout waiting for load (%s)\n",
+				       chan->number, __FUNCTION__);
@@ -682,2 +728,0 @@
-
-
@@ -689 +734 @@
-int s3c2410_dma_request(unsigned int channel, s3c2410_dma_client_t *client,
+int s3c2410_dma_request(unsigned int channel, struct s3c2410_dma_client *client,
@@ -692 +737 @@
-	s3c2410_dma_chan_t *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
@@ -722 +767,4 @@
-		err = request_irq(chan->irq, s3c2410_dma_irq, SA_INTERRUPT,
+		chan->irq_claimed = 1;
+		local_irq_restore(flags);
+
+		err = request_irq(chan->irq, s3c2410_dma_irq, IRQF_DISABLED,
@@ -724,0 +773,2 @@
+		local_irq_save(flags);
+
@@ -726,0 +777 @@
+			chan->irq_claimed = 0;
@@ -734 +784,0 @@
-		chan->irq_claimed = 1;
@@ -760 +810 @@
-int s3c2410_dma_free(dmach_t channel, s3c2410_dma_client_t *client)
+int s3c2410_dma_free(dmach_t channel, struct s3c2410_dma_client *client)
@@ -762 +812 @@
-	s3c2410_dma_chan_t *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
@@ -799 +849 @@
-static int s3c2410_dma_dostop(s3c2410_dma_chan_t *chan)
+static int s3c2410_dma_dostop(struct s3c2410_dma_chan *chan)
@@ -813,0 +864 @@
+	//tmp &= ~S3C2410_DMASKTRIG_ON;
@@ -822,0 +874 @@
+	/* should stop do this, or should we wait for flush? */
@@ -830,0 +883,16 @@
+void s3c2410_dma_waitforstop(struct s3c2410_dma_chan *chan)
+{
+	unsigned long tmp;
+	unsigned int timeout = 0x10000;
+
+	while (timeout-- > 0) {
+		tmp = dma_rdreg(chan, S3C2410_DMA_DMASKTRIG);
+
+		if (!(tmp & S3C2410_DMASKTRIG_ON))
+			return;
+	}
+
+	pr_debug("dma%d: failed to stop?\n", chan->number);
+}
+
+
@@ -836 +904 @@
-static int s3c2410_dma_flush(s3c2410_dma_chan_t *chan)
+static int s3c2410_dma_flush(struct s3c2410_dma_chan *chan)
@@ -838 +906 @@
-	s3c2410_dma_buf_t *buf, *next;
+	struct s3c2410_dma_buf *buf, *next;
@@ -841 +909,3 @@
-	pr_debug("%s:\n", __FUNCTION__);
+	pr_debug("%s: chan %p (%d)\n", __FUNCTION__, chan, chan->number);
+
+	dbg_showchan(chan);
@@ -867,0 +938,17 @@
+	dbg_showregs(chan);
+
+	s3c2410_dma_waitforstop(chan);
+
+#if 0
+	/* should also clear interrupts, according to WinCE BSP */
+	{
+		unsigned long tmp;
+
+		tmp = dma_rdreg(chan, S3C2410_DMA_DCON);
+		tmp |= S3C2410_DCON_NORELOAD;
+		dma_wrreg(chan, S3C2410_DMA_DCON, tmp);
+	}
+#endif
+
+	dbg_showregs(chan);
+
@@ -872,0 +960,36 @@
+int
+s3c2410_dma_started(struct s3c2410_dma_chan *chan)
+{
+	unsigned long flags;
+
+	local_irq_save(flags);
+
+	dbg_showchan(chan);
+
+	/* if we've only loaded one buffer onto the channel, then chec
+	 * to see if we have another, and if so, try and load it so when
+	 * the first buffer is finished, the new one will be loaded onto
+	 * the channel */
+
+	if (chan->next != NULL) {
+		if (chan->load_state == S3C2410_DMALOAD_1LOADED) {
+
+			if (s3c2410_dma_waitforload(chan, __LINE__) == 0) {
+				pr_debug("%s: buff not yet loaded, no more todo\n",
+					 __FUNCTION__);
+			} else {
+				chan->load_state = S3C2410_DMALOAD_1RUNNING;
+				s3c2410_dma_loadbuffer(chan, chan->next);
+			}
+
+		} else if (chan->load_state == S3C2410_DMALOAD_1RUNNING) {
+			s3c2410_dma_loadbuffer(chan, chan->next);
+		}
+	}
+
+
+	local_irq_restore(flags);
+
+	return 0;
+
+}
@@ -875 +998 @@
-s3c2410_dma_ctrl(dmach_t channel, s3c2410_chan_op_t op)
+s3c2410_dma_ctrl(dmach_t channel, enum s3c2410_chan_op op)
@@ -877 +1000 @@
-	s3c2410_dma_chan_t *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
@@ -889,2 +1011,0 @@
-		return -ENOENT;
-
@@ -896,0 +1018,3 @@
+	case S3C2410_DMAOP_STARTED:
+		return s3c2410_dma_started(chan);
+
@@ -925 +1049 @@
-	s3c2410_dma_chan_t *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
@@ -965 +1089 @@
-	s3c2410_dma_chan_t *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
@@ -985 +1109 @@
-	s3c2410_dma_chan_t *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
@@ -1000 +1124 @@
-	s3c2410_dma_chan_t *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
@@ -1028 +1152 @@
-			  s3c2410_dmasrc_t source,
+			  enum s3c2410_dmasrc source,
@@ -1032 +1156 @@
-	s3c2410_dma_chan_t *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
@@ -1079 +1203 @@
- 	s3c2410_dma_chan_t *chan = &s3c2410_chans[channel];
+ 	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
@@ -1101 +1225 @@
-	s3c2410_dma_chan_t *cp = container_of(dev, s3c2410_dma_chan_t, dev);
+	struct s3c2410_dma_chan *cp = container_of(dev, struct s3c2410_dma_chan, dev);
@@ -1141 +1265 @@
-	memset(p, 0, sizeof(s3c2410_dma_buf_t));
+	memset(p, 0, sizeof(struct s3c2410_dma_buf));
@@ -1149 +1273 @@
-	s3c2410_dma_chan_t *cp;
+	struct s3c2410_dma_chan *cp;
@@ -1167 +1291 @@
-	dma_kmem = kmem_cache_create("dma_desc", sizeof(s3c2410_dma_buf_t), 0,
+	dma_kmem = kmem_cache_create("dma_desc", sizeof(struct s3c2410_dma_buf), 0,
@@ -1180 +1304 @@
-		memset(cp, 0, sizeof(s3c2410_dma_chan_t));
+		memset(cp, 0, sizeof(struct s3c2410_dma_chan));
--- ./projects/linux/linux-2.6.18/arch/arm/mach-s3c2410/dma.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/arm/mach-s3c2410/dma.c	2006-11-29 22:57:37.000000000 +0100
@@ -1 +1 @@
-/* linux/arch/arm/mach-bast/dma.c
+/* linux/arch/arm/mach-s3c2410/dma.c
@@ -3 +3 @@
- * (c) 2003-2005 Simtec Electronics
+ * (c) 2003-2005,2006 Simtec Electronics
@@ -8 +8 @@
- * http://www.simtec.co.uk/products/EB2410ITX/
+ * http://armlinux.simtec.co.uk/
@@ -13,20 +13 @@
- *
- * Changelog:
- *  27-Feb-2005 BJD  Added kmem cache for dma descriptors
- *  18-Nov-2004 BJD  Removed error for loading onto stopped channel
- *  10-Nov-2004 BJD  Ensure all external symbols exported for modules
- *  10-Nov-2004 BJD  Use sys_device and sysdev_class for power management
- *  08-Aug-2004 BJD  Apply rmk's suggestions
- *  21-Jul-2004 BJD  Ported to linux 2.6
- *  12-Jul-2004 BJD  Finished re-write and change of API
- *  06-Jul-2004 BJD  Rewrote dma code to try and cope with various problems
- *  23-May-2003 BJD  Created file
- *  19-Aug-2003 BJD  Cleanup, header fix, added URL
- *
- * This file is based on the Sangwook Lee/Samsung patches, re-written due
- * to various ommisions from the code (such as flexible dma configuration)
- * for use with the BAST system board.
- *
- * The re-write is pretty much complete, and should be good enough for any
- * possible DMA function
- */
+*/
@@ -57,0 +39,2 @@
+#include "dma.h"
+
@@ -61,0 +45,2 @@
+struct s3c24xx_dma_selection dma_sel;
+
@@ -82 +66,0 @@
-
@@ -154,5 +138 @@
-#define check_channel(chan) \
-  do { if ((chan) >= S3C2410_DMA_CHANNELS) { \
-    printk(KERN_ERR "%s: invalid channel %d\n", __FUNCTION__, (chan)); \
-    return -EINVAL; \
-  } } while(0)
+static struct s3c2410_dma_chan *dma_chan_map[DMACH_MAX];
@@ -159,0 +140,12 @@
+/* lookup_dma_channel
+ *
+ * change the dma channel number given into a real dma channel id
+*/
+
+static struct s3c2410_dma_chan *lookup_dma_channel(unsigned int channel)
+{
+	if (channel & DMACH_LOW_LEVEL)
+		return &s3c2410_chans[channel & ~DMACH_LOW_LEVEL];
+	else
+		return dma_chan_map[channel];
+}
@@ -323,0 +316 @@
+#if 0
@@ -325,0 +319 @@
+#endif
@@ -442 +435,0 @@
-
@@ -463 +456 @@
-	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
@@ -467 +460,2 @@
-	check_channel(channel);
+	if (chan == NULL)
+		return -EINVAL;
@@ -564,0 +559 @@
+#if 0
@@ -566,0 +562 @@
+#endif
@@ -602 +598 @@
-s3c2410_dma_irq(int irq, void *devpw, struct pt_regs *regs)
+s3c2410_dma_irq(int irq, void *devpw)
@@ -721 +717,2 @@
-			s3c2410_dma_ctrl(chan->number, S3C2410_DMAOP_STOP);
+			s3c2410_dma_ctrl(chan->number | DMACH_LOW_LEVEL,
+					 S3C2410_DMAOP_STOP);
@@ -728,0 +726,2 @@
+static struct s3c2410_dma_chan *s3c2410_dma_map_channel(int channel);
+
@@ -734 +733,2 @@
-int s3c2410_dma_request(unsigned int channel, struct s3c2410_dma_client *client,
+int s3c2410_dma_request(unsigned int channel,
+			struct s3c2410_dma_client *client,
@@ -737 +737 @@
-	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan;
@@ -744,2 +743,0 @@
-	check_channel(channel);
-
@@ -748,10 +746,4 @@
-	dbg_showchan(chan);
-
-	if (chan->in_use) {
-		if (client != chan->client) {
-			printk(KERN_ERR "dma%d: already in use\n", channel);
-			local_irq_restore(flags);
-			return -EBUSY;
-		} else {
-			printk(KERN_ERR "dma%d: client already has channel\n", channel);
-		}
+	chan = s3c2410_dma_map_channel(channel);
+	if (chan == NULL) {
+		local_irq_restore(flags);
+		return -EBUSY;
@@ -759,0 +752,2 @@
+	dbg_showchan(chan);
+
@@ -812 +806 @@
-	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
@@ -815 +809,2 @@
-	check_channel(channel);
+	if (chan == NULL)
+		return -EINVAL;
@@ -819 +813,0 @@
-
@@ -839,0 +834 @@
+
@@ -841,0 +837,3 @@
+	if (!(channel & DMACH_LOW_LEVEL))
+		dma_chan_map[channel] = NULL;
+
@@ -851 +848,0 @@
-	unsigned long tmp;
@@ -852,0 +850 @@
+	unsigned long tmp;
@@ -1000 +998 @@
-	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
@@ -1002 +1000,2 @@
-	check_channel(channel);
+	if (chan == NULL)
+		return -EINVAL;
@@ -1049 +1048 @@
-	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
@@ -1054 +1053,8 @@
-	check_channel(channel);
+	if (chan == NULL)
+		return -EINVAL;
+
+	printk("Initial dcon is %08x\n", dcon);
+
+	dcon |= chan->dcon & dma_sel.dcon_mask;
+
+	printk("New dcon is %08x\n", dcon);
@@ -1089 +1095 @@
-	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
@@ -1091 +1097,2 @@
-	check_channel(channel);
+	if (chan == NULL)
+		return -EINVAL;
@@ -1109 +1116 @@
-	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
@@ -1111 +1118,2 @@
-	check_channel(channel);
+	if (chan == NULL)
+		return -EINVAL;
@@ -1124 +1132 @@
-	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
@@ -1126 +1134,2 @@
-	check_channel(channel);
+	if (chan == NULL)
+		return -EINVAL;
@@ -1156 +1165 @@
-	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
+	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
@@ -1158 +1167,2 @@
-	check_channel(channel);
+	if (chan == NULL)
+		return -EINVAL;
@@ -1203 +1213 @@
- 	struct s3c2410_dma_chan *chan = &s3c2410_chans[channel];
+ 	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
@@ -1205 +1215,2 @@
- 	check_channel(channel);
+	if (chan == NULL)
+		return -EINVAL;
@@ -1255 +1266 @@
-static struct sysdev_class dma_sysclass = {
+struct sysdev_class dma_sysclass = {
@@ -1268 +1278,0 @@
-
@@ -1277 +1287 @@
-	printk("S3C2410 DMA Driver, (c) 2003-2004 Simtec Electronics\n");
+	printk("S3C24XX DMA Driver, (c) 2003-2004,2006 Simtec Electronics\n");
@@ -1284,0 +1295,2 @@
+	printk("Registering sysclass\n");
+
@@ -1338 +1350,92 @@
-__initcall(s3c2410_init_dma);
+core_initcall(s3c2410_init_dma);
+
+static inline int is_channel_valid(unsigned int channel)
+{
+	return (channel & DMA_CH_VALID);
+}
+
+/* s3c2410_dma_map_channel()
+ *
+ * turn the virtual channel number into a real, and un-used hardware
+ * channel.
+ *
+ * currently this code uses first-free channel from the specified harware
+ * map, not taking into account anything that the board setup code may
+ * have to say about the likely peripheral set to be in use.
+*/
+
+struct s3c2410_dma_chan *s3c2410_dma_map_channel(int channel)
+{
+	struct s3c24xx_dma_map *ch_map;
+	struct s3c2410_dma_chan *dmach;
+	int ch;
+
+	if (dma_sel.map == NULL || channel > dma_sel.map_size)
+		return NULL;
+
+	ch_map = dma_sel.map + channel;
+
+	for (ch = 0; ch < S3C2410_DMA_CHANNELS; ch++) {
+		if (!is_channel_valid(ch_map->channels[ch]))
+			continue;
+
+		if (s3c2410_chans[ch].in_use == 0) {
+			printk("mapped channel %d to %d\n", channel, ch);
+			break;
+		}
+	}
+
+	if (ch >= S3C2410_DMA_CHANNELS)
+		return NULL;
+
+	/* update our channel mapping */
+
+	dmach = &s3c2410_chans[ch];
+	dma_chan_map[channel] = dmach;
+
+	/* select the channel */
+
+	(dma_sel.select)(dmach, ch_map);
+
+	return dmach;
+}
+
+static void s3c24xx_dma_show_ch(struct s3c24xx_dma_map *map, int ch)
+{
+	/* show the channel configuration */
+
+	printk("%2d: %20s, channels %c%c%c%c\n", ch, map->name,
+	       (is_channel_valid(map->channels[0]) ? '0' : '-'),
+	       (is_channel_valid(map->channels[1]) ? '1' : '-'),
+	       (is_channel_valid(map->channels[2]) ? '2' : '-'),
+	       (is_channel_valid(map->channels[3]) ? '3' : '-'));
+}
+
+static int s3c24xx_dma_check_entry(struct s3c24xx_dma_map *map, int ch)
+{
+	if (1)
+		s3c24xx_dma_show_ch(map, ch);
+
+	return 0;
+}
+
+int __init s3c24xx_dma_init_map(struct s3c24xx_dma_selection *sel)
+{
+	struct s3c24xx_dma_map *nmap;
+	size_t map_sz = sizeof(*nmap) * sel->map_size;
+	int ptr;
+
+	nmap = kmalloc(map_sz, GFP_KERNEL);
+	if (nmap == NULL)
+		return -ENOMEM;
+
+	memcpy(nmap, sel->map, map_sz);
+	memcpy(&dma_sel, sel, sizeof(*sel));
+
+	dma_sel.map = nmap;
+
+	for (ptr = 0; ptr < sel->map_size; ptr++)
+		s3c24xx_dma_check_entry(nmap+ptr, ptr);
+
+	return 0;
+}
--- ./projects/linux/linux-2.6.19/arch/arm/mach-s3c2410/dma.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/arch/arm/mach-s3c2410/dma.c	2007-02-04 19:44:54.000000000 +0100
@@ -3 +3 @@
- * (c) 2003-2005,2006 Simtec Electronics
+ * Copyright (c) 2003-2005,2006 Simtec Electronics
@@ -43 +43 @@
-static kmem_cache_t *dma_kmem;
+static struct kmem_cache *dma_kmem;
@@ -1056 +1056 @@
-	printk("Initial dcon is %08x\n", dcon);
+	pr_debug("%s: Initial dcon is %08x\n", __FUNCTION__, dcon);
@@ -1060 +1060 @@
-	printk("New dcon is %08x\n", dcon);
+	pr_debug("%s: New dcon is %08x\n", __FUNCTION__, dcon);
@@ -1274 +1274 @@
-static void s3c2410_dma_cache_ctor(void *p, kmem_cache_t *c, unsigned long f)
+static void s3c2410_dma_cache_ctor(void *p, struct kmem_cache *c, unsigned long f)
--- ./projects/linux/linux-2.6.20/arch/arm/mach-s3c2410/dma.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/arch/arm/mach-s3c2410/dma.c	2007-04-26 05:08:32.000000000 +0200
@@ -3 +3 @@
- * Copyright (c) 2003-2005,2006 Simtec Electronics
+ * Copyright (c) 2006 Simtec Electronics
@@ -6 +6 @@
- * S3C2410 DMA core
+ * S3C2410 DMA selection
@@ -15,6 +15 @@
-
-#ifdef CONFIG_S3C2410_DMA_DEBUG
-#define DEBUG
-#endif
-
-#include <linux/module.h>
+#include <linux/kernel.h>
@@ -22,3 +16,0 @@
-#include <linux/sched.h>
-#include <linux/spinlock.h>
-#include <linux/interrupt.h>
@@ -26,3 +18 @@
-#include <linux/slab.h>
-#include <linux/errno.h>
-#include <linux/delay.h>
+#include <linux/serial_core.h>
@@ -30,4 +19,0 @@
-#include <asm/system.h>
-#include <asm/irq.h>
-#include <asm/hardware.h>
-#include <asm/io.h>
@@ -34,0 +21 @@
+#include <asm/arch/dma.h>
@@ -36,36 +23,2 @@
-#include <asm/mach/dma.h>
-#include <asm/arch/map.h>
-
-#include "dma.h"
-
-/* io map for dma */
-static void __iomem *dma_base;
-static struct kmem_cache *dma_kmem;
-
-struct s3c24xx_dma_selection dma_sel;
-
-/* dma channel state information */
-struct s3c2410_dma_chan s3c2410_chans[S3C2410_DMA_CHANNELS];
-
-/* debugging functions */
-
-#define BUF_MAGIC (0xcafebabe)
-
-#define dmawarn(fmt...) printk(KERN_DEBUG fmt)
-
-#define dma_regaddr(chan, reg) ((chan)->regs + (reg))
-
-#if 1
-#define dma_wrreg(chan, reg, val) writel((val), (chan)->regs + (reg))
-#else
-static inline void
-dma_wrreg(struct s3c2410_dma_chan *chan, int reg, unsigned long val)
-{
-	pr_debug("writing %08x to register %08x\n",(unsigned int)val,reg);
-	writel(val, dma_regaddr(chan, reg));
-}
-#endif
-
-#define dma_rdreg(chan, reg) readl((chan)->regs + (reg))
-
-/* captured register state for debug */
+#include <asm/plat-s3c24xx/cpu.h>
+#include <asm/plat-s3c24xx/dma.h>
@@ -73,6 +26,89 @@
-struct s3c2410_dma_regstate {
-	unsigned long         dcsrc;
-	unsigned long         disrc;
-	unsigned long         dstat;
-	unsigned long         dcon;
-	unsigned long         dmsktrig;
+#include <asm/arch/regs-serial.h>
+#include <asm/arch/regs-gpio.h>
+#include <asm/arch/regs-ac97.h>
+#include <asm/arch/regs-mem.h>
+#include <asm/arch/regs-lcd.h>
+#include <asm/arch/regs-sdi.h>
+#include <asm/arch/regs-iis.h>
+#include <asm/arch/regs-spi.h>
+
+static struct s3c24xx_dma_map __initdata s3c2410_dma_mappings[] = {
+	[DMACH_XD0] = {
+		.name		= "xdreq0",
+		.channels[0]	= S3C2410_DCON_CH0_XDREQ0 | DMA_CH_VALID,
+	},
+	[DMACH_XD1] = {
+		.name		= "xdreq1",
+		.channels[1]	= S3C2410_DCON_CH1_XDREQ1 | DMA_CH_VALID,
+	},
+	[DMACH_SDI] = {
+		.name		= "sdi",
+		.channels[0]	= S3C2410_DCON_CH0_SDI | DMA_CH_VALID,
+		.channels[2]	= S3C2410_DCON_CH2_SDI | DMA_CH_VALID,
+		.channels[3]	= S3C2410_DCON_CH3_SDI | DMA_CH_VALID,
+		.hw_addr.to	= S3C2410_PA_IIS + S3C2410_IISFIFO,
+		.hw_addr.from	= S3C2410_PA_IIS + S3C2410_IISFIFO,
+	},
+	[DMACH_SPI0] = {
+		.name		= "spi0",
+		.channels[1]	= S3C2410_DCON_CH1_SPI | DMA_CH_VALID,
+		.hw_addr.to	= S3C2410_PA_SPI + S3C2410_SPTDAT,
+		.hw_addr.from	= S3C2410_PA_SPI + S3C2410_SPRDAT,
+	},
+	[DMACH_SPI1] = {
+		.name		= "spi1",
+		.channels[3]	= S3C2410_DCON_CH3_SPI | DMA_CH_VALID,
+		.hw_addr.to	= S3C2410_PA_SPI + 0x20 + S3C2410_SPTDAT,
+		.hw_addr.from	= S3C2410_PA_SPI + 0x20 + S3C2410_SPRDAT,
+	},
+	[DMACH_UART0] = {
+		.name		= "uart0",
+		.channels[0]	= S3C2410_DCON_CH0_UART0 | DMA_CH_VALID,
+		.hw_addr.to	= S3C2410_PA_UART0 + S3C2410_UTXH,
+		.hw_addr.from	= S3C2410_PA_UART0 + S3C2410_URXH,
+	},
+	[DMACH_UART1] = {
+		.name		= "uart1",
+		.channels[1]	= S3C2410_DCON_CH1_UART1 | DMA_CH_VALID,
+		.hw_addr.to	= S3C2410_PA_UART1 + S3C2410_UTXH,
+		.hw_addr.from	= S3C2410_PA_UART1 + S3C2410_URXH,
+	},
+      	[DMACH_UART2] = {
+		.name		= "uart2",
+		.channels[3]	= S3C2410_DCON_CH3_UART2 | DMA_CH_VALID,
+		.hw_addr.to	= S3C2410_PA_UART2 + S3C2410_UTXH,
+		.hw_addr.from	= S3C2410_PA_UART2 + S3C2410_URXH,
+	},
+	[DMACH_TIMER] = {
+		.name		= "timer",
+		.channels[0]	= S3C2410_DCON_CH0_TIMER | DMA_CH_VALID,
+		.channels[2]	= S3C2410_DCON_CH2_TIMER | DMA_CH_VALID,
+		.channels[3]	= S3C2410_DCON_CH3_TIMER | DMA_CH_VALID,
+	},
+	[DMACH_I2S_IN] = {
+		.name		= "i2s-sdi",
+		.channels[1]	= S3C2410_DCON_CH1_I2SSDI | DMA_CH_VALID,
+		.channels[2]	= S3C2410_DCON_CH2_I2SSDI | DMA_CH_VALID,
+		.hw_addr.from	= S3C2410_PA_IIS + S3C2410_IISFIFO,
+	},
+	[DMACH_I2S_OUT] = {
+		.name		= "i2s-sdo",
+		.channels[2]	= S3C2410_DCON_CH2_I2SSDO | DMA_CH_VALID,
+		.hw_addr.to	= S3C2410_PA_IIS + S3C2410_IISFIFO,
+	},
+	[DMACH_USB_EP1] = {
+		.name		= "usb-ep1",
+		.channels[0]	= S3C2410_DCON_CH0_USBEP1 | DMA_CH_VALID,
+	},
+	[DMACH_USB_EP2] = {
+		.name		= "usb-ep2",
+		.channels[1]	= S3C2410_DCON_CH1_USBEP2 | DMA_CH_VALID,
+	},
+	[DMACH_USB_EP3] = {
+		.name		= "usb-ep3",
+		.channels[2]	= S3C2410_DCON_CH2_USBEP3 | DMA_CH_VALID,
+	},
+	[DMACH_USB_EP4] = {
+		.name		= "usb-ep4",
+		.channels[3]	=S3C2410_DCON_CH3_USBEP4 | DMA_CH_VALID,
+	},
@@ -81,518 +117,2 @@
-#ifdef CONFIG_S3C2410_DMA_DEBUG
-
-/* dmadbg_showregs
- *
- * simple debug routine to print the current state of the dma registers
-*/
-
-static void
-dmadbg_capture(struct s3c2410_dma_chan *chan, struct s3c2410_dma_regstate *regs)
-{
-	regs->dcsrc    = dma_rdreg(chan, S3C2410_DMA_DCSRC);
-	regs->disrc    = dma_rdreg(chan, S3C2410_DMA_DISRC);
-	regs->dstat    = dma_rdreg(chan, S3C2410_DMA_DSTAT);
-	regs->dcon     = dma_rdreg(chan, S3C2410_DMA_DCON);
-	regs->dmsktrig = dma_rdreg(chan, S3C2410_DMA_DMASKTRIG);
-}
-
-static void
-dmadbg_dumpregs(const char *fname, int line, struct s3c2410_dma_chan *chan,
-		 struct s3c2410_dma_regstate *regs)
-{
-	printk(KERN_DEBUG "dma%d: %s:%d: DCSRC=%08lx, DISRC=%08lx, DSTAT=%08lx DMT=%02lx, DCON=%08lx\n",
-	       chan->number, fname, line,
-	       regs->dcsrc, regs->disrc, regs->dstat, regs->dmsktrig,
-	       regs->dcon);
-}
-
-static void
-dmadbg_showchan(const char *fname, int line, struct s3c2410_dma_chan *chan)
-{
-	struct s3c2410_dma_regstate state;
-
-	dmadbg_capture(chan, &state);
-
-	printk(KERN_DEBUG "dma%d: %s:%d: ls=%d, cur=%p, %p %p\n",
-	       chan->number, fname, line, chan->load_state,
-	       chan->curr, chan->next, chan->end);
-
-	dmadbg_dumpregs(fname, line, chan, &state);
-}
-
-static void
-dmadbg_showregs(const char *fname, int line, struct s3c2410_dma_chan *chan)
-{
-	struct s3c2410_dma_regstate state;
-
-	dmadbg_capture(chan, &state);
-	dmadbg_dumpregs(fname, line, chan, &state);
-}
-
-#define dbg_showregs(chan) dmadbg_showregs(__FUNCTION__, __LINE__, (chan))
-#define dbg_showchan(chan) dmadbg_showchan(__FUNCTION__, __LINE__, (chan))
-#else
-#define dbg_showregs(chan) do { } while(0)
-#define dbg_showchan(chan) do { } while(0)
-#endif /* CONFIG_S3C2410_DMA_DEBUG */
-
-static struct s3c2410_dma_chan *dma_chan_map[DMACH_MAX];
-
-/* lookup_dma_channel
- *
- * change the dma channel number given into a real dma channel id
-*/
-
-static struct s3c2410_dma_chan *lookup_dma_channel(unsigned int channel)
-{
-	if (channel & DMACH_LOW_LEVEL)
-		return &s3c2410_chans[channel & ~DMACH_LOW_LEVEL];
-	else
-		return dma_chan_map[channel];
-}
-
-/* s3c2410_dma_stats_timeout
- *
- * Update DMA stats from timeout info
-*/
-
-static void
-s3c2410_dma_stats_timeout(struct s3c2410_dma_stats *stats, int val)
-{
-	if (stats == NULL)
-		return;
-
-	if (val > stats->timeout_longest)
-		stats->timeout_longest = val;
-	if (val < stats->timeout_shortest)
-		stats->timeout_shortest = val;
-
-	stats->timeout_avg += val;
-}
-
-/* s3c2410_dma_waitforload
- *
- * wait for the DMA engine to load a buffer, and update the state accordingly
-*/
-
-static int
-s3c2410_dma_waitforload(struct s3c2410_dma_chan *chan, int line)
-{
-	int timeout = chan->load_timeout;
-	int took;
-
-	if (chan->load_state != S3C2410_DMALOAD_1LOADED) {
-		printk(KERN_ERR "dma%d: s3c2410_dma_waitforload() called in loadstate %d from line %d\n", chan->number, chan->load_state, line);
-		return 0;
-	}
-
-	if (chan->stats != NULL)
-		chan->stats->loads++;
-
-	while (--timeout > 0) {
-		if ((dma_rdreg(chan, S3C2410_DMA_DSTAT) << (32-20)) != 0) {
-			took = chan->load_timeout - timeout;
-
-			s3c2410_dma_stats_timeout(chan->stats, took);
-
-			switch (chan->load_state) {
-			case S3C2410_DMALOAD_1LOADED:
-				chan->load_state = S3C2410_DMALOAD_1RUNNING;
-				break;
-
-			default:
-				printk(KERN_ERR "dma%d: unknown load_state in s3c2410_dma_waitforload() %d\n", chan->number, chan->load_state);
-			}
-
-			return 1;
-		}
-	}
-
-	if (chan->stats != NULL) {
-		chan->stats->timeout_failed++;
-	}
-
-	return 0;
-}
-
-
-
-/* s3c2410_dma_loadbuffer
- *
- * load a buffer, and update the channel state
-*/
-
-static inline int
-s3c2410_dma_loadbuffer(struct s3c2410_dma_chan *chan,
-		       struct s3c2410_dma_buf *buf)
-{
-	unsigned long reload;
-
-	pr_debug("s3c2410_chan_loadbuffer: loading buff %p (0x%08lx,0x%06x)\n",
-		 buf, (unsigned long)buf->data, buf->size);
-
-	if (buf == NULL) {
-		dmawarn("buffer is NULL\n");
-		return -EINVAL;
-	}
-
-	/* check the state of the channel before we do anything */
-
-	if (chan->load_state == S3C2410_DMALOAD_1LOADED) {
-		dmawarn("load_state is S3C2410_DMALOAD_1LOADED\n");
-	}
-
-	if (chan->load_state == S3C2410_DMALOAD_1LOADED_1RUNNING) {
-		dmawarn("state is S3C2410_DMALOAD_1LOADED_1RUNNING\n");
-	}
-
-	/* it would seem sensible if we are the last buffer to not bother
-	 * with the auto-reload bit, so that the DMA engine will not try
-	 * and load another transfer after this one has finished...
-	 */
-	if (chan->load_state == S3C2410_DMALOAD_NONE) {
-		pr_debug("load_state is none, checking for noreload (next=%p)\n",
-			 buf->next);
-		reload = (buf->next == NULL) ? S3C2410_DCON_NORELOAD : 0;
-	} else {
-		//pr_debug("load_state is %d => autoreload\n", chan->load_state);
-		reload = S3C2410_DCON_AUTORELOAD;
-	}
-
-	if ((buf->data & 0xf0000000) != 0x30000000) {
-		dmawarn("dmaload: buffer is %p\n", (void *)buf->data);
-	}
-
-	writel(buf->data, chan->addr_reg);
-
-	dma_wrreg(chan, S3C2410_DMA_DCON,
-		  chan->dcon | reload | (buf->size/chan->xfer_unit));
-
-	chan->next = buf->next;
-
-	/* update the state of the channel */
-
-	switch (chan->load_state) {
-	case S3C2410_DMALOAD_NONE:
-		chan->load_state = S3C2410_DMALOAD_1LOADED;
-		break;
-
-	case S3C2410_DMALOAD_1RUNNING:
-		chan->load_state = S3C2410_DMALOAD_1LOADED_1RUNNING;
-		break;
-
-	default:
-		dmawarn("dmaload: unknown state %d in loadbuffer\n",
-			chan->load_state);
-		break;
-	}
-
-	return 0;
-}
-
-/* s3c2410_dma_call_op
- *
- * small routine to call the op routine with the given op if it has been
- * registered
-*/
-
-static void
-s3c2410_dma_call_op(struct s3c2410_dma_chan *chan, enum s3c2410_chan_op op)
-{
-	if (chan->op_fn != NULL) {
-		(chan->op_fn)(chan, op);
-	}
-}
-
-/* s3c2410_dma_buffdone
- *
- * small wrapper to check if callback routine needs to be called, and
- * if so, call it
-*/
-
-static inline void
-s3c2410_dma_buffdone(struct s3c2410_dma_chan *chan, struct s3c2410_dma_buf *buf,
-		     enum s3c2410_dma_buffresult result)
-{
-#if 0
-	pr_debug("callback_fn=%p, buf=%p, id=%p, size=%d, result=%d\n",
-		 chan->callback_fn, buf, buf->id, buf->size, result);
-#endif
-
-	if (chan->callback_fn != NULL) {
-		(chan->callback_fn)(chan, buf->id, buf->size, result);
-	}
-}
-
-/* s3c2410_dma_start
- *
- * start a dma channel going
-*/
-
-static int s3c2410_dma_start(struct s3c2410_dma_chan *chan)
-{
-	unsigned long tmp;
-	unsigned long flags;
-
-	pr_debug("s3c2410_start_dma: channel=%d\n", chan->number);
-
-	local_irq_save(flags);
-
-	if (chan->state == S3C2410_DMA_RUNNING) {
-		pr_debug("s3c2410_start_dma: already running (%d)\n", chan->state);
-		local_irq_restore(flags);
-		return 0;
-	}
-
-	chan->state = S3C2410_DMA_RUNNING;
-
-	/* check wether there is anything to load, and if not, see
-	 * if we can find anything to load
-	 */
-
-	if (chan->load_state == S3C2410_DMALOAD_NONE) {
-		if (chan->next == NULL) {
-			printk(KERN_ERR "dma%d: channel has nothing loaded\n",
-			       chan->number);
-			chan->state = S3C2410_DMA_IDLE;
-			local_irq_restore(flags);
-			return -EINVAL;
-		}
-
-		s3c2410_dma_loadbuffer(chan, chan->next);
-	}
-
-	dbg_showchan(chan);
-
-	/* enable the channel */
-
-	if (!chan->irq_enabled) {
-		enable_irq(chan->irq);
-		chan->irq_enabled = 1;
-	}
-
-	/* start the channel going */
-
-	tmp = dma_rdreg(chan, S3C2410_DMA_DMASKTRIG);
-	tmp &= ~S3C2410_DMASKTRIG_STOP;
-	tmp |= S3C2410_DMASKTRIG_ON;
-	dma_wrreg(chan, S3C2410_DMA_DMASKTRIG, tmp);
-
-	pr_debug("dma%d: %08lx to DMASKTRIG\n", chan->number, tmp);
-
-#if 0
-	/* the dma buffer loads should take care of clearing the AUTO
-	 * reloading feature */
-	tmp = dma_rdreg(chan, S3C2410_DMA_DCON);
-	tmp &= ~S3C2410_DCON_NORELOAD;
-	dma_wrreg(chan, S3C2410_DMA_DCON, tmp);
-#endif
-
-	s3c2410_dma_call_op(chan, S3C2410_DMAOP_START);
-
-	dbg_showchan(chan);
-
-	/* if we've only loaded one buffer onto the channel, then chec
-	 * to see if we have another, and if so, try and load it so when
-	 * the first buffer is finished, the new one will be loaded onto
-	 * the channel */
-
-	if (chan->next != NULL) {
-		if (chan->load_state == S3C2410_DMALOAD_1LOADED) {
-
-			if (s3c2410_dma_waitforload(chan, __LINE__) == 0) {
-				pr_debug("%s: buff not yet loaded, no more todo\n",
-					 __FUNCTION__);
-			} else {
-				chan->load_state = S3C2410_DMALOAD_1RUNNING;
-				s3c2410_dma_loadbuffer(chan, chan->next);
-			}
-
-		} else if (chan->load_state == S3C2410_DMALOAD_1RUNNING) {
-			s3c2410_dma_loadbuffer(chan, chan->next);
-		}
-	}
-
-
-	local_irq_restore(flags);
-
-	return 0;
-}
-
-/* s3c2410_dma_canload
- *
- * work out if we can queue another buffer into the DMA engine
-*/
-
-static int
-s3c2410_dma_canload(struct s3c2410_dma_chan *chan)
-{
-	if (chan->load_state == S3C2410_DMALOAD_NONE ||
-	    chan->load_state == S3C2410_DMALOAD_1RUNNING)
-		return 1;
-
-	return 0;
-}
-
-/* s3c2410_dma_enqueue
- *
- * queue an given buffer for dma transfer.
- *
- * id         the device driver's id information for this buffer
- * data       the physical address of the buffer data
- * size       the size of the buffer in bytes
- *
- * If the channel is not running, then the flag S3C2410_DMAF_AUTOSTART
- * is checked, and if set, the channel is started. If this flag isn't set,
- * then an error will be returned.
- *
- * It is possible to queue more than one DMA buffer onto a channel at
- * once, and the code will deal with the re-loading of the next buffer
- * when necessary.
-*/
-
-int s3c2410_dma_enqueue(unsigned int channel, void *id,
-			dma_addr_t data, int size)
-{
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
-	struct s3c2410_dma_buf *buf;
-	unsigned long flags;
-
-	if (chan == NULL)
-		return -EINVAL;
-
-	pr_debug("%s: id=%p, data=%08x, size=%d\n",
-		 __FUNCTION__, id, (unsigned int)data, size);
-
-	buf = kmem_cache_alloc(dma_kmem, GFP_ATOMIC);
-	if (buf == NULL) {
-		pr_debug("%s: out of memory (%ld alloc)\n",
-			 __FUNCTION__, (long)sizeof(*buf));
-		return -ENOMEM;
-	}
-
-	//pr_debug("%s: new buffer %p\n", __FUNCTION__, buf);
-	//dbg_showchan(chan);
-
-	buf->next  = NULL;
-	buf->data  = buf->ptr = data;
-	buf->size  = size;
-	buf->id    = id;
-	buf->magic = BUF_MAGIC;
-
-	local_irq_save(flags);
-
-	if (chan->curr == NULL) {
-		/* we've got nothing loaded... */
-		pr_debug("%s: buffer %p queued onto empty channel\n",
-			 __FUNCTION__, buf);
-
-		chan->curr = buf;
-		chan->end  = buf;
-		chan->next = NULL;
-	} else {
-		pr_debug("dma%d: %s: buffer %p queued onto non-empty channel\n",
-			 chan->number, __FUNCTION__, buf);
-
-		if (chan->end == NULL)
-			pr_debug("dma%d: %s: %p not empty, and chan->end==NULL?\n",
-				 chan->number, __FUNCTION__, chan);
-
-		chan->end->next = buf;
-		chan->end = buf;
-	}
-
-	/* if necessary, update the next buffer field */
-	if (chan->next == NULL)
-		chan->next = buf;
-
-	/* check to see if we can load a buffer */
-	if (chan->state == S3C2410_DMA_RUNNING) {
-		if (chan->load_state == S3C2410_DMALOAD_1LOADED && 1) {
-			if (s3c2410_dma_waitforload(chan, __LINE__) == 0) {
-				printk(KERN_ERR "dma%d: loadbuffer:"
-				       "timeout loading buffer\n",
-				       chan->number);
-				dbg_showchan(chan);
-				local_irq_restore(flags);
-				return -EINVAL;
-			}
-		}
-
-		while (s3c2410_dma_canload(chan) && chan->next != NULL) {
-			s3c2410_dma_loadbuffer(chan, chan->next);
-		}
-	} else if (chan->state == S3C2410_DMA_IDLE) {
-		if (chan->flags & S3C2410_DMAF_AUTOSTART) {
-			s3c2410_dma_ctrl(chan->number, S3C2410_DMAOP_START);
-		}
-	}
-
-	local_irq_restore(flags);
-	return 0;
-}
-
-EXPORT_SYMBOL(s3c2410_dma_enqueue);
-
-static inline void
-s3c2410_dma_freebuf(struct s3c2410_dma_buf *buf)
-{
-	int magicok = (buf->magic == BUF_MAGIC);
-
-	buf->magic = -1;
-
-	if (magicok) {
-		kmem_cache_free(dma_kmem, buf);
-	} else {
-		printk("s3c2410_dma_freebuf: buff %p with bad magic\n", buf);
-	}
-}
-
-/* s3c2410_dma_lastxfer
- *
- * called when the system is out of buffers, to ensure that the channel
- * is prepared for shutdown.
-*/
-
-static inline void
-s3c2410_dma_lastxfer(struct s3c2410_dma_chan *chan)
-{
-#if 0
-	pr_debug("dma%d: s3c2410_dma_lastxfer: load_state %d\n",
-		 chan->number, chan->load_state);
-#endif
-
-	switch (chan->load_state) {
-	case S3C2410_DMALOAD_NONE:
-		break;
-
-	case S3C2410_DMALOAD_1LOADED:
-		if (s3c2410_dma_waitforload(chan, __LINE__) == 0) {
-				/* flag error? */
-			printk(KERN_ERR "dma%d: timeout waiting for load (%s)\n",
-			       chan->number, __FUNCTION__);
-			return;
-		}
-		break;
-
-	case S3C2410_DMALOAD_1LOADED_1RUNNING:
-		/* I belive in this case we do not have anything to do
-		 * until the next buffer comes along, and we turn off the
-		 * reload */
-		return;
-
-	default:
-		pr_debug("dma%d: lastxfer: unhandled load_state %d with no next\n",
-			 chan->number, chan->load_state);
-		return;
-
-	}
-
-	/* hopefully this'll shut the damned thing up after the transfer... */
-	dma_wrreg(chan, S3C2410_DMA_DCON, chan->dcon | S3C2410_DCON_NORELOAD);
-}
-
-
-#define dmadbg2(x...)
-
-static irqreturn_t
-s3c2410_dma_irq(int irq, void *devpw)
+static void s3c2410_dma_select(struct s3c2410_dma_chan *chan,
+			       struct s3c24xx_dma_map *map)
@@ -600,124 +120 @@
-	struct s3c2410_dma_chan *chan = (struct s3c2410_dma_chan *)devpw;
-	struct s3c2410_dma_buf  *buf;
-
-	buf = chan->curr;
-
-	dbg_showchan(chan);
-
-	/* modify the channel state */
-
-	switch (chan->load_state) {
-	case S3C2410_DMALOAD_1RUNNING:
-		/* TODO - if we are running only one buffer, we probably
-		 * want to reload here, and then worry about the buffer
-		 * callback */
-
-		chan->load_state = S3C2410_DMALOAD_NONE;
-		break;
-
-	case S3C2410_DMALOAD_1LOADED:
-		/* iirc, we should go back to NONE loaded here, we
-		 * had a buffer, and it was never verified as being
-		 * loaded.
-		 */
-
-		chan->load_state = S3C2410_DMALOAD_NONE;
-		break;
-
-	case S3C2410_DMALOAD_1LOADED_1RUNNING:
-		/* we'll worry about checking to see if another buffer is
-		 * ready after we've called back the owner. This should
-		 * ensure we do not wait around too long for the DMA
-		 * engine to start the next transfer
-		 */
-
-		chan->load_state = S3C2410_DMALOAD_1LOADED;
-		break;
-
-	case S3C2410_DMALOAD_NONE:
-		printk(KERN_ERR "dma%d: IRQ with no loaded buffer?\n",
-		       chan->number);
-		break;
-
-	default:
-		printk(KERN_ERR "dma%d: IRQ in invalid load_state %d\n",
-		       chan->number, chan->load_state);
-		break;
-	}
-
-	if (buf != NULL) {
-		/* update the chain to make sure that if we load any more
-		 * buffers when we call the callback function, things should
-		 * work properly */
-
-		chan->curr = buf->next;
-		buf->next  = NULL;
-
-		if (buf->magic != BUF_MAGIC) {
-			printk(KERN_ERR "dma%d: %s: buf %p incorrect magic\n",
-			       chan->number, __FUNCTION__, buf);
-			return IRQ_HANDLED;
-		}
-
-		s3c2410_dma_buffdone(chan, buf, S3C2410_RES_OK);
-
-		/* free resouces */
-		s3c2410_dma_freebuf(buf);
-	} else {
-	}
-
-	/* only reload if the channel is still running... our buffer done
-	 * routine may have altered the state by requesting the dma channel
-	 * to stop or shutdown... */
-
-	/* todo: check that when the channel is shut-down from inside this
-	 * function, we cope with unsetting reload, etc */
-
-	if (chan->next != NULL && chan->state != S3C2410_DMA_IDLE) {
-		unsigned long flags;
-
-		switch (chan->load_state) {
-		case S3C2410_DMALOAD_1RUNNING:
-			/* don't need to do anything for this state */
-			break;
-
-		case S3C2410_DMALOAD_NONE:
-			/* can load buffer immediately */
-			break;
-
-		case S3C2410_DMALOAD_1LOADED:
-			if (s3c2410_dma_waitforload(chan, __LINE__) == 0) {
-				/* flag error? */
-				printk(KERN_ERR "dma%d: timeout waiting for load (%s)\n",
-				       chan->number, __FUNCTION__);
-				return IRQ_HANDLED;
-			}
-
-			break;
-
-		case S3C2410_DMALOAD_1LOADED_1RUNNING:
-			goto no_load;
-
-		default:
-			printk(KERN_ERR "dma%d: unknown load_state in irq, %d\n",
-			       chan->number, chan->load_state);
-			return IRQ_HANDLED;
-		}
-
-		local_irq_save(flags);
-		s3c2410_dma_loadbuffer(chan, chan->next);
-		local_irq_restore(flags);
-	} else {
-		s3c2410_dma_lastxfer(chan);
-
-		/* see if we can stop this channel.. */
-		if (chan->load_state == S3C2410_DMALOAD_NONE) {
-			pr_debug("dma%d: end of transfer, stopping channel (%ld)\n",
-				 chan->number, jiffies);
-			s3c2410_dma_ctrl(chan->number | DMACH_LOW_LEVEL,
-					 S3C2410_DMAOP_STOP);
-		}
-	}
-
- no_load:
-	return IRQ_HANDLED;
+	chan->dcon = map->channels[chan->number] & ~DMA_CH_VALID;
@@ -726,66 +123,6 @@
-static struct s3c2410_dma_chan *s3c2410_dma_map_channel(int channel);
-
-/* s3c2410_request_dma
- *
- * get control of an dma channel
-*/
-
-int s3c2410_dma_request(unsigned int channel,
-			struct s3c2410_dma_client *client,
-			void *dev)
-{
-	struct s3c2410_dma_chan *chan;
-	unsigned long flags;
-	int err;
-
-	pr_debug("dma%d: s3c2410_request_dma: client=%s, dev=%p\n",
-		 channel, client->name, dev);
-
-	local_irq_save(flags);
-
-	chan = s3c2410_dma_map_channel(channel);
-	if (chan == NULL) {
-		local_irq_restore(flags);
-		return -EBUSY;
-	}
-
-	dbg_showchan(chan);
-
-	chan->client = client;
-	chan->in_use = 1;
-
-	if (!chan->irq_claimed) {
-		pr_debug("dma%d: %s : requesting irq %d\n",
-			 channel, __FUNCTION__, chan->irq);
-
-		chan->irq_claimed = 1;
-		local_irq_restore(flags);
-
-		err = request_irq(chan->irq, s3c2410_dma_irq, IRQF_DISABLED,
-				  client->name, (void *)chan);
-
-		local_irq_save(flags);
-
-		if (err) {
-			chan->in_use = 0;
-			chan->irq_claimed = 0;
-			local_irq_restore(flags);
-
-			printk(KERN_ERR "%s: cannot get IRQ %d for DMA %d\n",
-			       client->name, chan->irq, chan->number);
-			return err;
-		}
-
-		chan->irq_enabled = 1;
-	}
-
-	local_irq_restore(flags);
-
-	/* need to setup */
-
-	pr_debug("%s: channel initialised, %p\n", __FUNCTION__, chan);
-
-	return 0;
-}
-
-EXPORT_SYMBOL(s3c2410_dma_request);
+static struct s3c24xx_dma_selection __initdata s3c2410_dma_sel = {
+	.select		= s3c2410_dma_select,
+	.dcon_mask	= 7 << 24,
+	.map		= s3c2410_dma_mappings,
+	.map_size	= ARRAY_SIZE(s3c2410_dma_mappings),
+};
@@ -793,10 +130,17 @@
-/* s3c2410_dma_free
- *
- * release the given channel back to the system, will stop and flush
- * any outstanding transfers, and ensure the channel is ready for the
- * next claimant.
- *
- * Note, although a warning is currently printed if the freeing client
- * info is not the same as the registrant's client info, the free is still
- * allowed to go through.
-*/
+static struct s3c24xx_dma_order __initdata s3c2410_dma_order = {
+	.channels	= {
+		[DMACH_SDI]	= {
+			.list	= {
+				[0]	= 3 | DMA_CH_VALID,
+				[1]	= 2 | DMA_CH_VALID,
+				[2]	= 0 | DMA_CH_VALID,
+			},
+		},
+		[DMACH_I2S_IN]	= {
+			.list	= {
+				[0]	= 1 | DMA_CH_VALID,
+				[1]	= 2 | DMA_CH_VALID,
+			},
+		},
+	},
+};
@@ -804 +148 @@
-int s3c2410_dma_free(dmach_t channel, struct s3c2410_dma_client *client)
+static int s3c2410_dma_add(struct sys_device *sysdev)
@@ -806,37 +150,3 @@
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
-	unsigned long flags;
-
-	if (chan == NULL)
-		return -EINVAL;
-
-	local_irq_save(flags);
-
-	if (chan->client != client) {
-		printk(KERN_WARNING "dma%d: possible free from different client (channel %p, passed %p)\n",
-		       channel, chan->client, client);
-	}
-
-	/* sort out stopping and freeing the channel */
-
-	if (chan->state != S3C2410_DMA_IDLE) {
-		pr_debug("%s: need to stop dma channel %p\n",
-		       __FUNCTION__, chan);
-
-		/* possibly flush the channel */
-		s3c2410_dma_ctrl(channel, S3C2410_DMAOP_STOP);
-	}
-
-	chan->client = NULL;
-	chan->in_use = 0;
-
-	if (chan->irq_claimed)
-		free_irq(chan->irq, (void *)chan);
-
-	chan->irq_claimed = 0;
-
-	if (!(channel & DMACH_LOW_LEVEL))
-		dma_chan_map[channel] = NULL;
-
-	local_irq_restore(flags);
-
-	return 0;
+	s3c2410_dma_init();
+	s3c24xx_dma_order_set(&s3c2410_dma_order);
+	return s3c24xx_dma_init_map(&s3c2410_dma_sel);
@@ -845,35 +155,4 @@
-EXPORT_SYMBOL(s3c2410_dma_free);
-
-static int s3c2410_dma_dostop(struct s3c2410_dma_chan *chan)
-{
-	unsigned long flags;
-	unsigned long tmp;
-
-	pr_debug("%s:\n", __FUNCTION__);
-
-	dbg_showchan(chan);
-
-	local_irq_save(flags);
-
-	s3c2410_dma_call_op(chan,  S3C2410_DMAOP_STOP);
-
-	tmp = dma_rdreg(chan, S3C2410_DMA_DMASKTRIG);
-	tmp |= S3C2410_DMASKTRIG_STOP;
-	//tmp &= ~S3C2410_DMASKTRIG_ON;
-	dma_wrreg(chan, S3C2410_DMA_DMASKTRIG, tmp);
-
-#if 0
-	/* should also clear interrupts, according to WinCE BSP */
-	tmp = dma_rdreg(chan, S3C2410_DMA_DCON);
-	tmp |= S3C2410_DCON_NORELOAD;
-	dma_wrreg(chan, S3C2410_DMA_DCON, tmp);
-#endif
-
-	/* should stop do this, or should we wait for flush? */
-	chan->state      = S3C2410_DMA_IDLE;
-	chan->load_state = S3C2410_DMALOAD_NONE;
-
-	local_irq_restore(flags);
-
-	return 0;
-}
+#if defined(CONFIG_CPU_S3C2410)
+static struct sysdev_driver s3c2410_dma_driver = {
+	.add	= s3c2410_dma_add,
+};
@@ -881 +160 @@
-void s3c2410_dma_waitforstop(struct s3c2410_dma_chan *chan)
+static int __init s3c2410_dma_drvinit(void)
@@ -883,11 +162 @@
-	unsigned long tmp;
-	unsigned int timeout = 0x10000;
-
-	while (timeout-- > 0) {
-		tmp = dma_rdreg(chan, S3C2410_DMA_DMASKTRIG);
-
-		if (!(tmp & S3C2410_DMASKTRIG_ON))
-			return;
-	}
-
-	pr_debug("dma%d: failed to stop?\n", chan->number);
+	return sysdev_driver_register(&s3c2410_sysclass, &s3c2410_dma_driver);
@@ -896,53 +165 @@
-
-/* s3c2410_dma_flush
- *
- * stop the channel, and remove all current and pending transfers
-*/
-
-static int s3c2410_dma_flush(struct s3c2410_dma_chan *chan)
-{
-	struct s3c2410_dma_buf *buf, *next;
-	unsigned long flags;
-
-	pr_debug("%s: chan %p (%d)\n", __FUNCTION__, chan, chan->number);
-
-	dbg_showchan(chan);
-
-	local_irq_save(flags);
-
-	if (chan->state != S3C2410_DMA_IDLE) {
-		pr_debug("%s: stopping channel...\n", __FUNCTION__ );
-		s3c2410_dma_ctrl(chan->number, S3C2410_DMAOP_STOP);
-	}
-
-	buf = chan->curr;
-	if (buf == NULL)
-		buf = chan->next;
-
-	chan->curr = chan->next = chan->end = NULL;
-
-	if (buf != NULL) {
-		for ( ; buf != NULL; buf = next) {
-			next = buf->next;
-
-			pr_debug("%s: free buffer %p, next %p\n",
-			       __FUNCTION__, buf, buf->next);
-
-			s3c2410_dma_buffdone(chan, buf, S3C2410_RES_ABORT);
-			s3c2410_dma_freebuf(buf);
-		}
-	}
-
-	dbg_showregs(chan);
-
-	s3c2410_dma_waitforstop(chan);
-
-#if 0
-	/* should also clear interrupts, according to WinCE BSP */
-	{
-		unsigned long tmp;
-
-		tmp = dma_rdreg(chan, S3C2410_DMA_DCON);
-		tmp |= S3C2410_DCON_NORELOAD;
-		dma_wrreg(chan, S3C2410_DMA_DCON, tmp);
-	}
+arch_initcall(s3c2410_dma_drvinit);
@@ -951,319 +168,4 @@
-	dbg_showregs(chan);
-
-	local_irq_restore(flags);
-
-	return 0;
-}
-
-int
-s3c2410_dma_started(struct s3c2410_dma_chan *chan)
-{
-	unsigned long flags;
-
-	local_irq_save(flags);
-
-	dbg_showchan(chan);
-
-	/* if we've only loaded one buffer onto the channel, then chec
-	 * to see if we have another, and if so, try and load it so when
-	 * the first buffer is finished, the new one will be loaded onto
-	 * the channel */
-
-	if (chan->next != NULL) {
-		if (chan->load_state == S3C2410_DMALOAD_1LOADED) {
-
-			if (s3c2410_dma_waitforload(chan, __LINE__) == 0) {
-				pr_debug("%s: buff not yet loaded, no more todo\n",
-					 __FUNCTION__);
-			} else {
-				chan->load_state = S3C2410_DMALOAD_1RUNNING;
-				s3c2410_dma_loadbuffer(chan, chan->next);
-			}
-
-		} else if (chan->load_state == S3C2410_DMALOAD_1RUNNING) {
-			s3c2410_dma_loadbuffer(chan, chan->next);
-		}
-	}
-
-
-	local_irq_restore(flags);
-
-	return 0;
-
-}
-
-int
-s3c2410_dma_ctrl(dmach_t channel, enum s3c2410_chan_op op)
-{
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
-
-	if (chan == NULL)
-		return -EINVAL;
-
-	switch (op) {
-	case S3C2410_DMAOP_START:
-		return s3c2410_dma_start(chan);
-
-	case S3C2410_DMAOP_STOP:
-		return s3c2410_dma_dostop(chan);
-
-	case S3C2410_DMAOP_PAUSE:
-	case S3C2410_DMAOP_RESUME:
-		return -ENOENT;
-
-	case S3C2410_DMAOP_FLUSH:
-		return s3c2410_dma_flush(chan);
-
-	case S3C2410_DMAOP_STARTED:
-		return s3c2410_dma_started(chan);
-
-	case S3C2410_DMAOP_TIMEOUT:
-		return 0;
-
-	}
-
-	return -ENOENT;      /* unknown, don't bother */
-}
-
-EXPORT_SYMBOL(s3c2410_dma_ctrl);
-
-/* DMA configuration for each channel
- *
- * DISRCC -> source of the DMA (AHB,APB)
- * DISRC  -> source address of the DMA
- * DIDSTC -> destination of the DMA (AHB,APD)
- * DIDST  -> destination address of the DMA
-*/
-
-/* s3c2410_dma_config
- *
- * xfersize:     size of unit in bytes (1,2,4)
- * dcon:         base value of the DCONx register
-*/
-
-int s3c2410_dma_config(dmach_t channel,
-		       int xferunit,
-		       int dcon)
-{
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
-
-	pr_debug("%s: chan=%d, xfer_unit=%d, dcon=%08x\n",
-		 __FUNCTION__, channel, xferunit, dcon);
-
-	if (chan == NULL)
-		return -EINVAL;
-
-	pr_debug("%s: Initial dcon is %08x\n", __FUNCTION__, dcon);
-
-	dcon |= chan->dcon & dma_sel.dcon_mask;
-
-	pr_debug("%s: New dcon is %08x\n", __FUNCTION__, dcon);
-
-	switch (xferunit) {
-	case 1:
-		dcon |= S3C2410_DCON_BYTE;
-		break;
-
-	case 2:
-		dcon |= S3C2410_DCON_HALFWORD;
-		break;
-
-	case 4:
-		dcon |= S3C2410_DCON_WORD;
-		break;
-
-	default:
-		pr_debug("%s: bad transfer size %d\n", __FUNCTION__, xferunit);
-		return -EINVAL;
-	}
-
-	dcon |= S3C2410_DCON_HWTRIG;
-	dcon |= S3C2410_DCON_INTREQ;
-
-	pr_debug("%s: dcon now %08x\n", __FUNCTION__, dcon);
-
-	chan->dcon = dcon;
-	chan->xfer_unit = xferunit;
-
-	return 0;
-}
-
-EXPORT_SYMBOL(s3c2410_dma_config);
-
-int s3c2410_dma_setflags(dmach_t channel, unsigned int flags)
-{
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
-
-	if (chan == NULL)
-		return -EINVAL;
-
-	pr_debug("%s: chan=%p, flags=%08x\n", __FUNCTION__, chan, flags);
-
-	chan->flags = flags;
-
-	return 0;
-}
-
-EXPORT_SYMBOL(s3c2410_dma_setflags);
-
-
-/* do we need to protect the settings of the fields from
- * irq?
-*/
-
-int s3c2410_dma_set_opfn(dmach_t channel, s3c2410_dma_opfn_t rtn)
-{
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
-
-	if (chan == NULL)
-		return -EINVAL;
-
-	pr_debug("%s: chan=%p, op rtn=%p\n", __FUNCTION__, chan, rtn);
-
-	chan->op_fn = rtn;
-
-	return 0;
-}
-
-EXPORT_SYMBOL(s3c2410_dma_set_opfn);
-
-int s3c2410_dma_set_buffdone_fn(dmach_t channel, s3c2410_dma_cbfn_t rtn)
-{
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
-
-	if (chan == NULL)
-		return -EINVAL;
-
-	pr_debug("%s: chan=%p, callback rtn=%p\n", __FUNCTION__, chan, rtn);
-
-	chan->callback_fn = rtn;
-
-	return 0;
-}
-
-EXPORT_SYMBOL(s3c2410_dma_set_buffdone_fn);
-
-/* s3c2410_dma_devconfig
- *
- * configure the dma source/destination hardware type and address
- *
- * source:    S3C2410_DMASRC_HW: source is hardware
- *            S3C2410_DMASRC_MEM: source is memory
- *
- * hwcfg:     the value for xxxSTCn register,
- *            bit 0: 0=increment pointer, 1=leave pointer
- *            bit 1: 0=soucre is AHB, 1=soucre is APB
- *
- * devaddr:   physical address of the source
-*/
-
-int s3c2410_dma_devconfig(int channel,
-			  enum s3c2410_dmasrc source,
-			  int hwcfg,
-			  unsigned long devaddr)
-{
-	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
-
-	if (chan == NULL)
-		return -EINVAL;
-
-	pr_debug("%s: source=%d, hwcfg=%08x, devaddr=%08lx\n",
-		 __FUNCTION__, (int)source, hwcfg, devaddr);
-
-	chan->source = source;
-	chan->dev_addr = devaddr;
-
-	switch (source) {
-	case S3C2410_DMASRC_HW:
-		/* source is hardware */
-		pr_debug("%s: hw source, devaddr=%08lx, hwcfg=%d\n",
-			 __FUNCTION__, devaddr, hwcfg);
-		dma_wrreg(chan, S3C2410_DMA_DISRCC, hwcfg & 3);
-		dma_wrreg(chan, S3C2410_DMA_DISRC,  devaddr);
-		dma_wrreg(chan, S3C2410_DMA_DIDSTC, (0<<1) | (0<<0));
-
-		chan->addr_reg = dma_regaddr(chan, S3C2410_DMA_DIDST);
-		return 0;
-
-	case S3C2410_DMASRC_MEM:
-		/* source is memory */
-		pr_debug( "%s: mem source, devaddr=%08lx, hwcfg=%d\n",
-			  __FUNCTION__, devaddr, hwcfg);
-		dma_wrreg(chan, S3C2410_DMA_DISRCC, (0<<1) | (0<<0));
-		dma_wrreg(chan, S3C2410_DMA_DIDST,  devaddr);
-		dma_wrreg(chan, S3C2410_DMA_DIDSTC, hwcfg & 3);
-
-		chan->addr_reg = dma_regaddr(chan, S3C2410_DMA_DISRC);
-		return 0;
-	}
-
-	printk(KERN_ERR "dma%d: invalid source type (%d)\n", channel, source);
-	return -EINVAL;
-}
-
-EXPORT_SYMBOL(s3c2410_dma_devconfig);
-
-/* s3c2410_dma_getposition
- *
- * returns the current transfer points for the dma source and destination
-*/
-
-int s3c2410_dma_getposition(dmach_t channel, dma_addr_t *src, dma_addr_t *dst)
-{
- 	struct s3c2410_dma_chan *chan = lookup_dma_channel(channel);
-
-	if (chan == NULL)
-		return -EINVAL;
-
-	if (src != NULL)
- 		*src = dma_rdreg(chan, S3C2410_DMA_DCSRC);
-
- 	if (dst != NULL)
- 		*dst = dma_rdreg(chan, S3C2410_DMA_DCDST);
-
- 	return 0;
-}
-
-EXPORT_SYMBOL(s3c2410_dma_getposition);
-
-
-/* system device class */
-
-#ifdef CONFIG_PM
-
-static int s3c2410_dma_suspend(struct sys_device *dev, pm_message_t state)
-{
-	struct s3c2410_dma_chan *cp = container_of(dev, struct s3c2410_dma_chan, dev);
-
-	printk(KERN_DEBUG "suspending dma channel %d\n", cp->number);
-
-	if (dma_rdreg(cp, S3C2410_DMA_DMASKTRIG) & S3C2410_DMASKTRIG_ON) {
-		/* the dma channel is still working, which is probably
-		 * a bad thing to do over suspend/resume. We stop the
-		 * channel and assume that the client is either going to
-		 * retry after resume, or that it is broken.
-		 */
-
-		printk(KERN_INFO "dma: stopping channel %d due to suspend\n",
-		       cp->number);
-
-		s3c2410_dma_dostop(cp);
-	}
-
-	return 0;
-}
-
-static int s3c2410_dma_resume(struct sys_device *dev)
-{
-	return 0;
-}
-
-#else
-#define s3c2410_dma_suspend NULL
-#define s3c2410_dma_resume  NULL
-#endif /* CONFIG_PM */
-
-struct sysdev_class dma_sysclass = {
-	set_kset_name("s3c24xx-dma"),
-	.suspend	= s3c2410_dma_suspend,
-	.resume		= s3c2410_dma_resume,
+#if defined(CONFIG_CPU_S3C2442)
+/* S3C2442 DMA contains the same selection table as the S3C2410 */
+static struct sysdev_driver s3c2442_dma_driver = {
+	.add	= s3c2410_dma_add,
@@ -1272,96 +174 @@
-/* kmem cache implementation */
-
-static void s3c2410_dma_cache_ctor(void *p, struct kmem_cache *c, unsigned long f)
-{
-	memset(p, 0, sizeof(struct s3c2410_dma_buf));
-}
-
-/* initialisation code */
-
-static int __init s3c2410_init_dma(void)
-{
-	struct s3c2410_dma_chan *cp;
-	int channel;
-	int ret;
-
-	printk("S3C24XX DMA Driver, (c) 2003-2004,2006 Simtec Electronics\n");
-
-	dma_base = ioremap(S3C24XX_PA_DMA, 0x200);
-	if (dma_base == NULL) {
-		printk(KERN_ERR "dma failed to remap register block\n");
-		return -ENOMEM;
-	}
-
-	printk("Registering sysclass\n");
-
-	ret = sysdev_class_register(&dma_sysclass);
-	if (ret != 0) {
-		printk(KERN_ERR "dma sysclass registration failed\n");
-		goto err;
-	}
-
-	dma_kmem = kmem_cache_create("dma_desc", sizeof(struct s3c2410_dma_buf), 0,
-				     SLAB_HWCACHE_ALIGN,
-				     s3c2410_dma_cache_ctor, NULL);
-
-	if (dma_kmem == NULL) {
-		printk(KERN_ERR "dma failed to make kmem cache\n");
-		ret = -ENOMEM;
-		goto err;
-	}
-
-	for (channel = 0; channel < S3C2410_DMA_CHANNELS; channel++) {
-		cp = &s3c2410_chans[channel];
-
-		memset(cp, 0, sizeof(struct s3c2410_dma_chan));
-
-		/* dma channel irqs are in order.. */
-		cp->number = channel;
-		cp->irq    = channel + IRQ_DMA0;
-		cp->regs   = dma_base + (channel*0x40);
-
-		/* point current stats somewhere */
-		cp->stats  = &cp->stats_store;
-		cp->stats_store.timeout_shortest = LONG_MAX;
-
-		/* basic channel configuration */
-
-		cp->load_timeout = 1<<18;
-
-		/* register system device */
-
-		cp->dev.cls = &dma_sysclass;
-		cp->dev.id  = channel;
-		ret = sysdev_register(&cp->dev);
-
-		printk("DMA channel %d at %p, irq %d\n",
-		       cp->number, cp->regs, cp->irq);
-	}
-
-	return 0;
-
- err:
-	kmem_cache_destroy(dma_kmem);
-	iounmap(dma_base);
-	dma_base = NULL;
-	return ret;
-}
-
-core_initcall(s3c2410_init_dma);
-
-static inline int is_channel_valid(unsigned int channel)
-{
-	return (channel & DMA_CH_VALID);
-}
-
-/* s3c2410_dma_map_channel()
- *
- * turn the virtual channel number into a real, and un-used hardware
- * channel.
- *
- * currently this code uses first-free channel from the specified harware
- * map, not taking into account anything that the board setup code may
- * have to say about the likely peripheral set to be in use.
-*/
-
-struct s3c2410_dma_chan *s3c2410_dma_map_channel(int channel)
+static int __init s3c2442_dma_drvinit(void)
@@ -1369,32 +176 @@
-	struct s3c24xx_dma_map *ch_map;
-	struct s3c2410_dma_chan *dmach;
-	int ch;
-
-	if (dma_sel.map == NULL || channel > dma_sel.map_size)
-		return NULL;
-
-	ch_map = dma_sel.map + channel;
-
-	for (ch = 0; ch < S3C2410_DMA_CHANNELS; ch++) {
-		if (!is_channel_valid(ch_map->channels[ch]))
-			continue;
-
-		if (s3c2410_chans[ch].in_use == 0) {
-			printk("mapped channel %d to %d\n", channel, ch);
-			break;
-		}
-	}
-
-	if (ch >= S3C2410_DMA_CHANNELS)
-		return NULL;
-
-	/* update our channel mapping */
-
-	dmach = &s3c2410_chans[ch];
-	dma_chan_map[channel] = dmach;
-
-	/* select the channel */
-
-	(dma_sel.select)(dmach, ch_map);
-
-	return dmach;
+	return sysdev_driver_register(&s3c2442_sysclass, &s3c2442_dma_driver);
@@ -1403,36 +179,2 @@
-static void s3c24xx_dma_show_ch(struct s3c24xx_dma_map *map, int ch)
-{
-	/* show the channel configuration */
-
-	printk("%2d: %20s, channels %c%c%c%c\n", ch, map->name,
-	       (is_channel_valid(map->channels[0]) ? '0' : '-'),
-	       (is_channel_valid(map->channels[1]) ? '1' : '-'),
-	       (is_channel_valid(map->channels[2]) ? '2' : '-'),
-	       (is_channel_valid(map->channels[3]) ? '3' : '-'));
-}
-
-static int s3c24xx_dma_check_entry(struct s3c24xx_dma_map *map, int ch)
-{
-	if (1)
-		s3c24xx_dma_show_ch(map, ch);
-
-	return 0;
-}
-
-int __init s3c24xx_dma_init_map(struct s3c24xx_dma_selection *sel)
-{
-	struct s3c24xx_dma_map *nmap;
-	size_t map_sz = sizeof(*nmap) * sel->map_size;
-	int ptr;
-
-	nmap = kmalloc(map_sz, GFP_KERNEL);
-	if (nmap == NULL)
-		return -ENOMEM;
-
-	memcpy(nmap, sel->map, map_sz);
-	memcpy(&dma_sel, sel, sizeof(*sel));
-
-	dma_sel.map = nmap;
-
-	for (ptr = 0; ptr < sel->map_size; ptr++)
-		s3c24xx_dma_check_entry(nmap+ptr, ptr);
+arch_initcall(s3c2442_dma_drvinit);
+#endif
@@ -1440,2 +181,0 @@
-	return 0;
-}
--- ./projects/linux/linux-2.6.22/arch/arm/mach-s3c2410/dma.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/arch/arm/mach-s3c2410/dma.c	2007-10-09 22:31:38.000000000 +0200
@@ -26 +26 @@
-#include <asm/arch/regs-serial.h>
+#include <asm/plat-s3c/regs-serial.h>
@@ -28 +28 @@
-#include <asm/arch/regs-ac97.h>
+#include <asm/plat-s3c/regs-ac97.h>
@@ -32,2 +32,2 @@
-#include <asm/arch/regs-iis.h>
-#include <asm/arch/regs-spi.h>
+#include <asm/plat-s3c24xx/regs-iis.h>
+#include <asm/plat-s3c24xx/regs-spi.h>
--- ./projects/linux/linux-2.6.23/arch/arm/mach-s3c2410/dma.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/arch/arm/mach-s3c2410/dma.c	2008-01-24 23:58:37.000000000 +0100
@@ -148 +148 @@
-static int s3c2410_dma_add(struct sys_device *sysdev)
+static int __init s3c2410_dma_add(struct sys_device *sysdev)
--- ./projects/linux/linux-2.6.26/arch/arm/mach-s3c2410/dma.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/arch/arm/mach-s3c2410/dma.c	2008-10-10 00:13:53.000000000 +0200
@@ -21 +21 @@
-#include <asm/arch/dma.h>
+#include <mach/dma.h>
@@ -27 +27 @@
-#include <asm/arch/regs-gpio.h>
+#include <mach/regs-gpio.h>
@@ -29,3 +29,3 @@
-#include <asm/arch/regs-mem.h>
-#include <asm/arch/regs-lcd.h>
-#include <asm/arch/regs-sdi.h>
+#include <mach/regs-mem.h>
+#include <mach/regs-lcd.h>
+#include <mach/regs-sdi.h>
--- ./projects/linux/linux-2.6.27/arch/arm/mach-s3c2410/dma.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/arch/arm/mach-s3c2410/dma.c	2008-12-25 00:26:37.000000000 +0100
@@ -23,2 +23,2 @@
-#include <asm/plat-s3c24xx/cpu.h>
-#include <asm/plat-s3c24xx/dma.h>
+#include <plat/cpu.h>
+#include <plat/dma.h>
@@ -26 +26 @@
-#include <asm/plat-s3c/regs-serial.h>
+#include <plat/regs-serial.h>
--- ./projects/linux/linux-2.6.28/arch/arm/mach-s3c2410/dma.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/arch/arm/mach-s3c2410/dma.c	2009-03-24 00:12:14.000000000 +0100
@@ -20 +19,0 @@
-#include <asm/dma.h>
@@ -28 +27 @@
-#include <asm/plat-s3c/regs-ac97.h>
+#include <plat/regs-ac97.h>
@@ -33 +32 @@
-#include <asm/plat-s3c24xx/regs-spi.h>
+#include <plat/regs-spi.h>
--- ./projects/linux/linux-2.6.29/arch/arm/mach-s3c2410/dma.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/arch/arm/mach-s3c2410/dma.c	2009-06-27 11:32:31.000000000 +0200
@@ -31 +31 @@
-#include <asm/plat-s3c24xx/regs-iis.h>
+#include <plat/regs-iis.h>
--- ./projects/linux/linux-2.6.21/arch/arm/plat-s3c24xx/dma.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/arch/arm/plat-s3c24xx/dma.c	2007-07-09 01:32:17.000000000 +0200
@@ -47 +47 @@
-struct s3c24xx_dma_selection dma_sel;
+static struct s3c24xx_dma_selection dma_sel;
@@ -883 +883 @@
-void s3c2410_dma_waitforstop(struct s3c2410_dma_chan *chan)
+static void s3c2410_dma_waitforstop(struct s3c2410_dma_chan *chan)
@@ -960,2 +960 @@
-int
-s3c2410_dma_started(struct s3c2410_dma_chan *chan)
+static int s3c2410_dma_started(struct s3c2410_dma_chan *chan)
@@ -1157 +1156 @@
- *            bit 1: 0=soucre is AHB, 1=soucre is APB
+ *            bit 1: 0=source is AHB, 1=source is APB
@@ -1283 +1282 @@
-int __init s3c24xx_dma_sysclass_init(void)
+static int __init s3c24xx_dma_sysclass_init(void)
@@ -1295 +1294 @@
-int __init s3c24xx_dma_sysdev_register(void)
+static int __init s3c24xx_dma_sysdev_register(void)
@@ -1399 +1398 @@
-struct s3c2410_dma_chan *s3c2410_dma_map_channel(int channel)
+static struct s3c2410_dma_chan *s3c2410_dma_map_channel(int channel)
--- ./projects/linux/linux-2.6.22/arch/arm/plat-s3c24xx/dma.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/arch/arm/plat-s3c24xx/dma.c	2007-10-09 22:31:38.000000000 +0200
@@ -1336 +1336 @@
-				     s3c2410_dma_cache_ctor, NULL);
+				     s3c2410_dma_cache_ctor);
--- ./projects/linux/linux-2.6.23/arch/arm/plat-s3c24xx/dma.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/arch/arm/plat-s3c24xx/dma.c	2008-01-24 23:58:37.000000000 +0100
@@ -1275 +1275 @@
-static void s3c2410_dma_cache_ctor(void *p, struct kmem_cache *c, unsigned long f)
+static void s3c2410_dma_cache_ctor(struct kmem_cache *c, void *p)
@@ -1375 +1375 @@
-int s3c2410_dma_init(void)
+int __init s3c2410_dma_init(void)
--- ./projects/linux/linux-2.6.24/arch/arm/plat-s3c24xx/dma.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/arm/plat-s3c24xx/dma.c	2008-04-17 04:49:44.000000000 +0200
@@ -133,2 +133,2 @@
-#define dbg_showregs(chan) dmadbg_showregs(__FUNCTION__, __LINE__, (chan))
-#define dbg_showchan(chan) dmadbg_showchan(__FUNCTION__, __LINE__, (chan))
+#define dbg_showregs(chan) dmadbg_showregs(__func__, __LINE__, (chan))
+#define dbg_showchan(chan) dmadbg_showchan(__func__, __LINE__, (chan))
@@ -406 +406 @@
-					 __FUNCTION__);
+					 __func__);
@@ -466 +466 @@
-		 __FUNCTION__, id, (unsigned int)data, size);
+		 __func__, id, (unsigned int)data, size);
@@ -471 +471 @@
-			 __FUNCTION__, (long)sizeof(*buf));
+			 __func__, (long)sizeof(*buf));
@@ -475 +475 @@
-	//pr_debug("%s: new buffer %p\n", __FUNCTION__, buf);
+	//pr_debug("%s: new buffer %p\n", __func__, buf);
@@ -489 +489 @@
-			 __FUNCTION__, buf);
+			 __func__, buf);
@@ -496 +496 @@
-			 chan->number, __FUNCTION__, buf);
+			 chan->number, __func__, buf);
@@ -500 +500 @@
-				 chan->number, __FUNCTION__, chan);
+				 chan->number, __func__, chan);
@@ -528 +528,2 @@
-			s3c2410_dma_ctrl(chan->number, S3C2410_DMAOP_START);
+			s3c2410_dma_ctrl(chan->number | DMACH_LOW_LEVEL,
+					 S3C2410_DMAOP_START);
@@ -574 +575 @@
-			       chan->number, __FUNCTION__);
+			       chan->number, __func__);
@@ -660 +661 @@
-			       chan->number, __FUNCTION__, buf);
+			       chan->number, __func__, buf);
@@ -694 +695 @@
-				       chan->number, __FUNCTION__);
+				       chan->number, __func__);
@@ -761 +762 @@
-			 channel, __FUNCTION__, chan->irq);
+			 channel, __func__, chan->irq);
@@ -788 +789 @@
-	pr_debug("%s: channel initialised, %p\n", __FUNCTION__, chan);
+	pr_debug("%s: channel initialised, %p\n", __func__, chan);
@@ -790 +791 @@
-	return 0;
+	return chan->number | DMACH_LOW_LEVEL;
@@ -825 +826 @@
-		       __FUNCTION__, chan);
+		       __func__, chan);
@@ -854 +855 @@
-	pr_debug("%s:\n", __FUNCTION__);
+	pr_debug("%s:\n", __func__);
@@ -909 +910 @@
-	pr_debug("%s: chan %p (%d)\n", __FUNCTION__, chan, chan->number);
+	pr_debug("%s: chan %p (%d)\n", __func__, chan, chan->number);
@@ -916 +917 @@
-		pr_debug("%s: stopping channel...\n", __FUNCTION__ );
+		pr_debug("%s: stopping channel...\n", __func__ );
@@ -931 +932 @@
-			       __FUNCTION__, buf, buf->next);
+			       __func__, buf, buf->next);
@@ -978 +979 @@
-					 __FUNCTION__);
+					 __func__);
@@ -1052 +1053 @@
-		 __FUNCTION__, channel, xferunit, dcon);
+		 __func__, channel, xferunit, dcon);
@@ -1057 +1058 @@
-	pr_debug("%s: Initial dcon is %08x\n", __FUNCTION__, dcon);
+	pr_debug("%s: Initial dcon is %08x\n", __func__, dcon);
@@ -1061 +1062 @@
-	pr_debug("%s: New dcon is %08x\n", __FUNCTION__, dcon);
+	pr_debug("%s: New dcon is %08x\n", __func__, dcon);
@@ -1077 +1078 @@
-		pr_debug("%s: bad transfer size %d\n", __FUNCTION__, xferunit);
+		pr_debug("%s: bad transfer size %d\n", __func__, xferunit);
@@ -1084 +1085 @@
-	pr_debug("%s: dcon now %08x\n", __FUNCTION__, dcon);
+	pr_debug("%s: dcon now %08x\n", __func__, dcon);
@@ -1101 +1102 @@
-	pr_debug("%s: chan=%p, flags=%08x\n", __FUNCTION__, chan, flags);
+	pr_debug("%s: chan=%p, flags=%08x\n", __func__, chan, flags);
@@ -1122 +1123 @@
-	pr_debug("%s: chan=%p, op rtn=%p\n", __FUNCTION__, chan, rtn);
+	pr_debug("%s: chan=%p, op rtn=%p\n", __func__, chan, rtn);
@@ -1138 +1139 @@
-	pr_debug("%s: chan=%p, callback rtn=%p\n", __FUNCTION__, chan, rtn);
+	pr_debug("%s: chan=%p, callback rtn=%p\n", __func__, chan, rtn);
@@ -1172 +1173 @@
-		 __FUNCTION__, (int)source, hwcfg, devaddr);
+		 __func__, (int)source, hwcfg, devaddr);
@@ -1175,0 +1177 @@
+	chan->hw_cfg = hwcfg;
@@ -1181 +1183 @@
-			 __FUNCTION__, devaddr, hwcfg);
+			 __func__, devaddr, hwcfg);
@@ -1187 +1189 @@
-		return 0;
+		break;
@@ -1191,2 +1193,2 @@
-		pr_debug( "%s: mem source, devaddr=%08lx, hwcfg=%d\n",
-			  __FUNCTION__, devaddr, hwcfg);
+		pr_debug("%s: mem source, devaddr=%08lx, hwcfg=%d\n",
+			 __func__, devaddr, hwcfg);
@@ -1198 +1200,7 @@
-		return 0;
+		break;
+
+	default:
+		printk(KERN_ERR "dma%d: invalid source type (%d)\n",
+		       channel, source);
+
+		return -EINVAL;
@@ -1201,2 +1209,4 @@
-	printk(KERN_ERR "dma%d: invalid source type (%d)\n", channel, source);
-	return -EINVAL;
+	if (dma_sel.direction != NULL)
+		(dma_sel.direction)(chan, chan->map, source);
+
+	return 0;
@@ -1229,0 +1240,4 @@
+static struct s3c2410_dma_chan *to_dma_chan(struct sys_device *dev)
+{
+	return container_of(dev, struct s3c2410_dma_chan, dev);
+}
@@ -1237 +1251 @@
-	struct s3c2410_dma_chan *cp = container_of(dev, struct s3c2410_dma_chan, dev);
+	struct s3c2410_dma_chan *cp = to_dma_chan(dev);
@@ -1258,0 +1273,18 @@
+	struct s3c2410_dma_chan *cp = to_dma_chan(dev);
+	unsigned int no = cp->number | DMACH_LOW_LEVEL;
+
+	/* restore channel's hardware configuration */
+
+	if (!cp->in_use)
+		return 0;
+
+	printk(KERN_INFO "dma%d: restoring configuration\n", cp->number);
+
+	s3c2410_dma_config(no, cp->xfer_unit, cp->dcon);
+	s3c2410_dma_devconfig(no, cp->source, cp->hw_cfg, cp->dev_addr);
+
+	/* re-select the dma source for this channel */
+
+	if (cp->map != NULL)
+		dma_sel.select(cp, cp->map);
+
@@ -1268 +1300 @@
-	set_kset_name("s3c24xx-dma"),
+	.name		= "s3c24xx-dma",
@@ -1447,0 +1480 @@
+	dmach->map = ch_map;
--- ./projects/linux/linux-2.6.26/arch/arm/plat-s3c24xx/dma.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/arch/arm/plat-s3c24xx/dma.c	2008-10-10 00:13:53.000000000 +0200
@@ -32 +32 @@
-#include <asm/hardware.h>
+#include <mach/hardware.h>
@@ -37 +37 @@
-#include <asm/arch/map.h>
+#include <mach/map.h>
@@ -1307 +1307 @@
-static void s3c2410_dma_cache_ctor(struct kmem_cache *c, void *p)
+static void s3c2410_dma_cache_ctor(void *p)
--- ./projects/linux/linux-2.6.27/arch/arm/plat-s3c24xx/dma.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/arch/arm/plat-s3c24xx/dma.c	2008-12-25 00:26:37.000000000 +0100
@@ -28,0 +29 @@
+#include <linux/io.h>
@@ -33 +33,0 @@
-#include <asm/io.h>
@@ -39 +39 @@
-#include <asm/plat-s3c24xx/dma.h>
+#include <plat/dma.h>
--- ./projects/linux/linux-2.6.28/arch/arm/plat-s3c24xx/dma.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/arch/arm/plat-s3c24xx/dma.c	2009-03-24 00:12:14.000000000 +0100
@@ -28 +27,0 @@
-#include <linux/delay.h>
@@ -34 +33 @@
-#include <asm/dma.h>
+#include <mach/dma.h>
@@ -36 +34,0 @@
-#include <asm/mach/dma.h>
@@ -807 +805 @@
-int s3c2410_dma_free(dmach_t channel, struct s3c2410_dma_client *client)
+int s3c2410_dma_free(unsigned int channel, struct s3c2410_dma_client *client)
@@ -998 +996 @@
-s3c2410_dma_ctrl(dmach_t channel, enum s3c2410_chan_op op)
+s3c2410_dma_ctrl(unsigned int channel, enum s3c2410_chan_op op)
@@ -1046 +1044 @@
-int s3c2410_dma_config(dmach_t channel,
+int s3c2410_dma_config(unsigned int channel,
@@ -1095 +1093 @@
-int s3c2410_dma_setflags(dmach_t channel, unsigned int flags)
+int s3c2410_dma_setflags(unsigned int channel, unsigned int flags)
@@ -1116 +1114 @@
-int s3c2410_dma_set_opfn(dmach_t channel, s3c2410_dma_opfn_t rtn)
+int s3c2410_dma_set_opfn(unsigned int channel, s3c2410_dma_opfn_t rtn)
@@ -1132 +1130 @@
-int s3c2410_dma_set_buffdone_fn(dmach_t channel, s3c2410_dma_cbfn_t rtn)
+int s3c2410_dma_set_buffdone_fn(unsigned int channel, s3c2410_dma_cbfn_t rtn)
@@ -1222 +1220 @@
-int s3c2410_dma_getposition(dmach_t channel, dma_addr_t *src, dma_addr_t *dst)
+int s3c2410_dma_getposition(unsigned int channel, dma_addr_t *src, dma_addr_t *dst)
--- ./projects/linux/linux-2.6.29/arch/arm/plat-s3c24xx/dma.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/arch/arm/plat-s3c24xx/dma.c	2009-06-27 11:32:31.000000000 +0200
@@ -1238 +1238 @@
-static struct s3c2410_dma_chan *to_dma_chan(struct sys_device *dev)
+static inline struct s3c2410_dma_chan *to_dma_chan(struct sys_device *dev)
--- ./projects/linux/linux-2.6.14/arch/cris/arch-v32/drivers/axisflashmap.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/arch/cris/arch-v32/drivers/axisflashmap.c	2006-01-03 04:21:10.000000000 +0100
@@ -22,0 +23 @@
+#include <linux/slab.h>
--- ./projects/linux/linux-2.6.17/arch/cris/arch-v32/drivers/axisflashmap.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/cris/arch-v32/drivers/axisflashmap.c	2006-09-20 05:42:06.000000000 +0200
@@ -21 +20,0 @@
-#include <linux/config.h>
--- ./projects/linux/linux-2.6.19/arch/cris/arch-v32/drivers/axisflashmap.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/arch/cris/arch-v32/drivers/axisflashmap.c	2007-02-04 19:44:54.000000000 +0100
@@ -430 +430 @@
-		mtd_ram = (struct mtd_info *)kmalloc(sizeof(struct mtd_info),
+		mtd_ram = kmalloc(sizeof(struct mtd_info),
--- ./projects/linux/linux-2.6.23/arch/cris/arch-v32/drivers/axisflashmap.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/arch/cris/arch-v32/drivers/axisflashmap.c	2008-01-24 23:58:37.000000000 +0100
@@ -193,3 +192,0 @@
-#ifdef CONFIG_MTD_AMDSTD
-	mtd_cs = do_map_probe("amd_flash", map_cs);
-#endif
@@ -197 +193,0 @@
-	if (!mtd_cs) {
@@ -199 +195,4 @@
-	}
+#endif
+#ifdef CONFIG_MTD_JEDECPROBE
+	if (!mtd_cs)
+		mtd_cs = do_map_probe("jedec_probe", map_cs);
@@ -208 +207 @@
- * so that MTD partitions can cross chip boundries.
+ * so that MTD partitions can cross chip boundaries.
--- ./projects/linux/linux-2.6.24/arch/cris/arch-v32/drivers/axisflashmap.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/cris/arch-v32/drivers/axisflashmap.c	2008-04-17 04:49:44.000000000 +0200
@@ -4 +4 @@
- * Copyright (c) 2001, 2002, 2003 Axis Communications AB
+ * Copyright (c) 2001-2007 Axis Communications AB
@@ -13,3 +12,0 @@
- * Copy of os/lx25/arch/cris/arch-v10/drivers/axisflashmap.c 1.5
- * with minor changes.
- *
@@ -30 +27,2 @@
-#include <asm/arch/hwregs/config_defs.h>
+#include <linux/cramfs_fs.h>
+
@@ -39,0 +38,2 @@
+#define PAGESIZE (512)
+
@@ -45 +45 @@
-#define flash_data __u16
+#define flash_data __u32
@@ -49 +49,7 @@
-extern unsigned long romfs_start, romfs_length, romfs_in_flash;
+extern unsigned long romfs_in_flash; /* 1 when romfs_start, _length in flash */
+extern unsigned long romfs_start, romfs_length;
+extern unsigned long nand_boot; /* 1 when booted from nand flash */
+
+struct partition_name {
+	char name[6];
+};
@@ -115,3 +121,10 @@
-/* If no partition-table was found, we use this default-set. */
-#define MAX_PARTITIONS         7
-#define NUM_DEFAULT_PARTITIONS 3
+#define MAX_PARTITIONS			7
+#ifdef CONFIG_ETRAX_NANDBOOT
+#define NUM_DEFAULT_PARTITIONS		4
+#define DEFAULT_ROOTFS_PARTITION_NO	2
+#define DEFAULT_MEDIA_SIZE              0x2000000 /* 32 megs */
+#else
+#define NUM_DEFAULT_PARTITIONS		3
+#define DEFAULT_ROOTFS_PARTITION_NO	(-1)
+#define DEFAULT_MEDIA_SIZE              0x800000 /* 8 megs */
+#endif
@@ -119,22 +132,3 @@
-/*
- * Default flash size is 2MB. CONFIG_ETRAX_PTABLE_SECTOR is most likely the
- * size of one flash block and "filesystem"-partition needs 5 blocks to be able
- * to use JFFS.
- */
-static struct mtd_partition axis_default_partitions[NUM_DEFAULT_PARTITIONS] = {
-	{
-		.name = "boot firmware",
-		.size = CONFIG_ETRAX_PTABLE_SECTOR,
-		.offset = 0
-	},
-	{
-		.name = "kernel",
-		.size = 0x200000 - (6 * CONFIG_ETRAX_PTABLE_SECTOR),
-		.offset = CONFIG_ETRAX_PTABLE_SECTOR
-	},
-	{
-		.name = "filesystem",
-		.size = 5 * CONFIG_ETRAX_PTABLE_SECTOR,
-		.offset = 0x200000 - (5 * CONFIG_ETRAX_PTABLE_SECTOR)
-	}
-};
+#if (MAX_PARTITIONS < NUM_DEFAULT_PARTITIONS)
+#error MAX_PARTITIONS must be >= than NUM_DEFAULT_PARTITIONS
+#endif
@@ -180,0 +175,50 @@
+
+/* If no partition-table was found, we use this default-set.
+ * Default flash size is 8MB (NOR). CONFIG_ETRAX_PTABLE_SECTOR is most
+ * likely the size of one flash block and "filesystem"-partition needs
+ * to be >=5 blocks to be able to use JFFS.
+ */
+static struct mtd_partition axis_default_partitions[NUM_DEFAULT_PARTITIONS] = {
+	{
+		.name = "boot firmware",
+		.size = CONFIG_ETRAX_PTABLE_SECTOR,
+		.offset = 0
+	},
+	{
+		.name = "kernel",
+		.size = 10 * CONFIG_ETRAX_PTABLE_SECTOR,
+		.offset = CONFIG_ETRAX_PTABLE_SECTOR
+	},
+#define FILESYSTEM_SECTOR (11 * CONFIG_ETRAX_PTABLE_SECTOR)
+#ifdef CONFIG_ETRAX_NANDBOOT
+	{
+		.name = "rootfs",
+		.size = 10 * CONFIG_ETRAX_PTABLE_SECTOR,
+		.offset = FILESYSTEM_SECTOR
+	},
+#undef FILESYSTEM_SECTOR
+#define FILESYSTEM_SECTOR (21 * CONFIG_ETRAX_PTABLE_SECTOR)
+#endif
+	{
+		.name = "rwfs",
+		.size = DEFAULT_MEDIA_SIZE - FILESYSTEM_SECTOR,
+		.offset = FILESYSTEM_SECTOR
+	}
+};
+
+#ifdef CONFIG_ETRAX_AXISFLASHMAP_MTD0WHOLE
+/* Main flash device */
+static struct mtd_partition main_partition = {
+	.name = "main",
+	.size = 0,
+	.offset = 0
+};
+#endif
+
+/* Auxilliary partition if we find another flash */
+static struct mtd_partition aux_partition = {
+	.name = "aux",
+	.size = 0,
+	.offset = 0
+};
+
@@ -194 +238 @@
-		mtd_cs = do_map_probe("cfi_probe", map_cs);
+	mtd_cs = do_map_probe("cfi_probe", map_cs);
@@ -207 +251 @@
- * so that MTD partitions can cross chip boundaries.
+ * so that MTD partitions can cross chip boundries.
@@ -219 +262,0 @@
-	struct mtd_info *mtd_nand = NULL;
@@ -221 +264 @@
-	struct mtd_info *mtds[3];
+	struct mtd_info *mtds[2];
@@ -229,6 +272 @@
-#ifdef CONFIG_ETRAX_NANDFLASH
-	if ((mtd_nand = crisv32_nand_flash_probe()) != NULL)
-		mtds[count++] = mtd_nand;
-#endif
-
-	if (!mtd_cse0 && !mtd_cse1 && !mtd_nand) {
+	if (!mtd_cse0 && !mtd_cse1) {
@@ -248,3 +286 @@
-		mtd_total = mtd_concat_create(mtds,
-		                              count,
-		                              "cse0+cse1+nand");
+		mtd_total = mtd_concat_create(mtds, count, "cse0+cse1");
@@ -258 +294 @@
-			       map_cse0.name, map_cse1.name);
+				map_cse0.name, map_cse1.name);
@@ -261,2 +297 @@
-			 * at cse0.
-			 */
+			 * at cse0. */
@@ -266,4 +301,2 @@
-	} else {
-		mtd_total = mtd_cse0? mtd_cse0 : mtd_cse1 ? mtd_cse1 : mtd_nand;
-
-	}
+	} else
+		mtd_total = mtd_cse0 ? mtd_cse0 : mtd_cse1;
@@ -274,3 +306,0 @@
-extern unsigned long crisv32_nand_boot;
-extern unsigned long crisv32_nand_cramfs_offset;
-
@@ -283 +313,2 @@
-	struct mtd_info *mymtd;
+	struct mtd_info *main_mtd;
+	struct mtd_info *aux_mtd = NULL;
@@ -288,3 +319,2 @@
-	int use_default_ptable = 1; /* Until proven otherwise. */
-	const char *pmsg = KERN_INFO "  /dev/flash%d at 0x%08x, size 0x%08x\n";
-	static char page[512];
+	int ptable_ok = 0;
+	static char page[PAGESIZE];
@@ -291,0 +322,2 @@
+	int ram_rootfs_partition = -1; /* -1 => no RAM rootfs partition */
+	int part;
@@ -293,4 +325,24 @@
-#ifndef CONFIG_ETRAXFS_SIM
-	mymtd = flash_probe();
-	mymtd->read(mymtd, CONFIG_ETRAX_PTABLE_SECTOR, 512, &len, page);
-	ptable_head = (struct partitiontable_head *)(page + PARTITION_TABLE_OFFSET);
+	/* We need a root fs. If it resides in RAM, we need to use an
+	 * MTDRAM device, so it must be enabled in the kernel config,
+	 * but its size must be configured as 0 so as not to conflict
+	 * with our usage.
+	 */
+#if !defined(CONFIG_MTD_MTDRAM) || (CONFIG_MTDRAM_TOTAL_SIZE != 0) || (CONFIG_MTDRAM_ABS_POS != 0)
+	if (!romfs_in_flash && !nand_boot) {
+		printk(KERN_EMERG "axisflashmap: Cannot create an MTD RAM "
+		       "device; configure CONFIG_MTD_MTDRAM with size = 0!\n");
+		panic("This kernel cannot boot from RAM!\n");
+	}
+#endif
+
+#ifndef CONFIG_ETRAX_VCS_SIM
+	main_mtd = flash_probe();
+	if (main_mtd)
+		printk(KERN_INFO "%s: 0x%08x bytes of NOR flash memory.\n",
+		       main_mtd->name, main_mtd->size);
+
+#ifdef CONFIG_ETRAX_NANDFLASH
+	aux_mtd = crisv32_nand_flash_probe();
+	if (aux_mtd)
+		printk(KERN_INFO "%s: 0x%08x bytes of NAND flash memory.\n",
+			aux_mtd->name, aux_mtd->size);
@@ -298 +350,14 @@
-	if (!mymtd) {
+#ifdef CONFIG_ETRAX_NANDBOOT
+	{
+		struct mtd_info *tmp_mtd;
+
+		printk(KERN_INFO "axisflashmap: Set to boot from NAND flash, "
+		       "making NAND flash primary device.\n");
+		tmp_mtd = main_mtd;
+		main_mtd = aux_mtd;
+		aux_mtd = tmp_mtd;
+	}
+#endif /* CONFIG_ETRAX_NANDBOOT */
+#endif /* CONFIG_ETRAX_NANDFLASH */
+
+	if (!main_mtd && !aux_mtd) {
@@ -303,4 +367,0 @@
-	} else {
-		printk(KERN_INFO "%s: 0x%08x bytes of flash memory.\n",
-		       mymtd->name, mymtd->size);
-		axisflash_mtd = mymtd;
@@ -309,2 +370,79 @@
-	if (mymtd) {
-		mymtd->owner = THIS_MODULE;
+#if 0 /* Dump flash memory so we can see what is going on */
+	if (main_mtd) {
+		int sectoraddr, i;
+		for (sectoraddr = 0; sectoraddr < 2*65536+4096;
+				sectoraddr += PAGESIZE) {
+			main_mtd->read(main_mtd, sectoraddr, PAGESIZE, &len,
+				page);
+			printk(KERN_INFO
+			       "Sector at %d (length %d):\n",
+			       sectoraddr, len);
+			for (i = 0; i < PAGESIZE; i += 16) {
+				printk(KERN_INFO
+				       "%02x %02x %02x %02x "
+				       "%02x %02x %02x %02x "
+				       "%02x %02x %02x %02x "
+				       "%02x %02x %02x %02x\n",
+				       page[i] & 255, page[i+1] & 255,
+				       page[i+2] & 255, page[i+3] & 255,
+				       page[i+4] & 255, page[i+5] & 255,
+				       page[i+6] & 255, page[i+7] & 255,
+				       page[i+8] & 255, page[i+9] & 255,
+				       page[i+10] & 255, page[i+11] & 255,
+				       page[i+12] & 255, page[i+13] & 255,
+				       page[i+14] & 255, page[i+15] & 255);
+			}
+		}
+	}
+#endif
+
+	if (main_mtd) {
+		main_mtd->owner = THIS_MODULE;
+		axisflash_mtd = main_mtd;
+
+		loff_t ptable_sector = CONFIG_ETRAX_PTABLE_SECTOR;
+
+		/* First partition (rescue) is always set to the default. */
+		pidx++;
+#ifdef CONFIG_ETRAX_NANDBOOT
+		/* We know where the partition table should be located,
+		 * it will be in first good block after that.
+		 */
+		int blockstat;
+		do {
+			blockstat = main_mtd->block_isbad(main_mtd,
+				ptable_sector);
+			if (blockstat < 0)
+				ptable_sector = 0; /* read error */
+			else if (blockstat)
+				ptable_sector += main_mtd->erasesize;
+		} while (blockstat && ptable_sector);
+#endif
+		if (ptable_sector) {
+			main_mtd->read(main_mtd, ptable_sector, PAGESIZE,
+				&len, page);
+			ptable_head = &((struct partitiontable *) page)->head;
+		}
+
+#if 0 /* Dump partition table so we can see what is going on */
+		printk(KERN_INFO
+		       "axisflashmap: flash read %d bytes at 0x%08x, data: "
+		       "%02x %02x %02x %02x %02x %02x %02x %02x\n",
+		       len, CONFIG_ETRAX_PTABLE_SECTOR,
+		       page[0] & 255, page[1] & 255,
+		       page[2] & 255, page[3] & 255,
+		       page[4] & 255, page[5] & 255,
+		       page[6] & 255, page[7] & 255);
+		printk(KERN_INFO
+		       "axisflashmap: partition table offset %d, data: "
+		       "%02x %02x %02x %02x %02x %02x %02x %02x\n",
+		       PARTITION_TABLE_OFFSET,
+		       page[PARTITION_TABLE_OFFSET+0] & 255,
+		       page[PARTITION_TABLE_OFFSET+1] & 255,
+		       page[PARTITION_TABLE_OFFSET+2] & 255,
+		       page[PARTITION_TABLE_OFFSET+3] & 255,
+		       page[PARTITION_TABLE_OFFSET+4] & 255,
+		       page[PARTITION_TABLE_OFFSET+5] & 255,
+		       page[PARTITION_TABLE_OFFSET+6] & 255,
+		       page[PARTITION_TABLE_OFFSET+7] & 255);
+#endif
@@ -312 +449,0 @@
-	pidx++;  /* First partition is always set to the default. */
@@ -325 +461,0 @@
-		int ptable_ok = 0;
@@ -349 +485,2 @@
-		printk(KERN_INFO " Found a%s partition table at 0x%p-0x%p.\n",
+		printk(KERN_INFO "axisflashmap: "
+		       "Found a%s partition table at 0x%p-0x%p.\n",
@@ -354,2 +491 @@
-		 * partition table.  Scan the table.  It ends when
-		 * there is 0xffffffff, that is, empty flash.
+		 * partition table.  Scan the table.  It ends with 0xffffffff.
@@ -358 +494 @@
-		       && ptable->offset != 0xffffffff
+		       && ptable->offset != PARTITIONTABLE_END_MARKER
@@ -360 +496 @@
-		       && pidx < MAX_PARTITIONS) {
+		       && pidx < MAX_PARTITIONS - 1) {
@@ -362,5 +498,24 @@
-			axis_partitions[pidx].offset = offset + ptable->offset + (crisv32_nand_boot ? 16384 : 0);
-			axis_partitions[pidx].size = ptable->size;
-
-			printk(pmsg, pidx, axis_partitions[pidx].offset,
-			       axis_partitions[pidx].size);
+			axis_partitions[pidx].offset = offset + ptable->offset;
+#ifdef CONFIG_ETRAX_NANDFLASH
+			if (main_mtd->type == MTD_NANDFLASH) {
+				axis_partitions[pidx].size =
+					(((ptable+1)->offset ==
+					  PARTITIONTABLE_END_MARKER) ?
+					  main_mtd->size :
+					  ((ptable+1)->offset + offset)) -
+					(ptable->offset + offset);
+
+			} else
+#endif /* CONFIG_ETRAX_NANDFLASH */
+				axis_partitions[pidx].size = ptable->size;
+#ifdef CONFIG_ETRAX_NANDBOOT
+			/* Save partition number of jffs2 ro partition.
+			 * Needed if RAM booting or root file system in RAM.
+			 */
+			if (!nand_boot &&
+			    ram_rootfs_partition < 0 && /* not already set */
+			    ptable->type == PARTITION_TYPE_JFFS2 &&
+			    (ptable->flags & PARTITION_FLAGS_READONLY_MASK) ==
+				PARTITION_FLAGS_READONLY)
+				ram_rootfs_partition = pidx;
+#endif /* CONFIG_ETRAX_NANDBOOT */
@@ -370 +524,0 @@
-		use_default_ptable = !ptable_ok;
@@ -373,2 +527,2 @@
-	if (romfs_in_flash) {
-		/* Add an overlapping device for the root partition (romfs). */
+	/* Decide whether to use default partition table. */
+	/* Only use default table if we actually have a device (main_mtd) */
@@ -376,16 +530,7 @@
-		axis_partitions[pidx].name = "romfs";
-		if (crisv32_nand_boot) {
-			char* data = kmalloc(1024, GFP_KERNEL);
-			int len;
-			int offset = crisv32_nand_cramfs_offset & ~(1024-1);
-			char* tmp;
-
-			mymtd->read(mymtd, offset, 1024, &len, data);
-			tmp = &data[crisv32_nand_cramfs_offset % 512];
-			axis_partitions[pidx].size = *(unsigned*)(tmp + 4);
-			axis_partitions[pidx].offset = crisv32_nand_cramfs_offset;
-			kfree(data);
-		} else {
-			axis_partitions[pidx].size = romfs_length;
-			axis_partitions[pidx].offset = romfs_start - FLASH_CACHED_ADDR;
-		}
+	struct mtd_partition *partition = &axis_partitions[0];
+	if (main_mtd && !ptable_ok) {
+		memcpy(axis_partitions, axis_default_partitions,
+		       sizeof(axis_default_partitions));
+		pidx = NUM_DEFAULT_PARTITIONS;
+		ram_rootfs_partition = DEFAULT_ROOTFS_PARTITION_NO;
+	}
@@ -392,0 +538,9 @@
+	/* Add artificial partitions for rootfs if necessary */
+	if (romfs_in_flash) {
+		/* rootfs is in directly accessible flash memory = NOR flash.
+		   Add an overlapping device for the rootfs partition. */
+		printk(KERN_INFO "axisflashmap: Adding partition for "
+		       "overlapping root file system image\n");
+		axis_partitions[pidx].size = romfs_length;
+		axis_partitions[pidx].offset = romfs_start - FLASH_CACHED_ADDR;
+		axis_partitions[pidx].name = "romfs";
@@ -394,5 +548 @@
-
-		printk(KERN_INFO
-                       " Adding readonly flash partition for romfs image:\n");
-		printk(pmsg, pidx, axis_partitions[pidx].offset,
-		       axis_partitions[pidx].size);
+		ram_rootfs_partition = -1;
@@ -400,9 +550,7 @@
-	}
-
-        if (mymtd) {
-		if (use_default_ptable) {
-			printk(KERN_INFO " Using default partition table.\n");
-			err = add_mtd_partitions(mymtd, axis_default_partitions,
-						 NUM_DEFAULT_PARTITIONS);
-		} else {
-			err = add_mtd_partitions(mymtd, axis_partitions, pidx);
+	} else if (romfs_length && !nand_boot) {
+		/* romfs exists in memory, but not in flash, so must be in RAM.
+		 * Configure an MTDRAM partition. */
+		if (ram_rootfs_partition < 0) {
+			/* None set yet, put it at the end */
+			ram_rootfs_partition = pidx;
+			pidx++;
@@ -409,0 +558,8 @@
+		printk(KERN_INFO "axisflashmap: Adding partition for "
+		       "root file system image in RAM\n");
+		axis_partitions[ram_rootfs_partition].size = romfs_length;
+		axis_partitions[ram_rootfs_partition].offset = romfs_start;
+		axis_partitions[ram_rootfs_partition].name = "romfs";
+		axis_partitions[ram_rootfs_partition].mask_flags |=
+			MTD_WRITEABLE;
+	}
@@ -411,3 +567,7 @@
-		if (err) {
-			panic("axisflashmap could not add MTD partitions!\n");
-		}
+#ifdef CONFIG_ETRAX_AXISFLASHMAP_MTD0WHOLE
+	if (main_mtd) {
+		main_partition.size = main_mtd->size;
+		err = add_mtd_partitions(main_mtd, &main_partition, 1);
+		if (err)
+			panic("axisflashmap: Could not initialize "
+			      "partition for whole main mtd device!\n");
@@ -415 +574,0 @@
-/* CONFIG_EXTRAXFS_SIM */
@@ -418,2 +577,36 @@
-	if (!romfs_in_flash) {
-		/* Create an RAM device for the root partition (romfs). */
+	/* Now, register all partitions with mtd.
+	 * We do this one at a time so we can slip in an MTDRAM device
+	 * in the proper place if required. */
+
+	for (part = 0; part < pidx; part++) {
+		if (part == ram_rootfs_partition) {
+			/* add MTDRAM partition here */
+			struct mtd_info *mtd_ram;
+
+			mtd_ram = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
+			if (!mtd_ram)
+				panic("axisflashmap: Couldn't allocate memory "
+				      "for mtd_info!\n");
+			printk(KERN_INFO "axisflashmap: Adding RAM partition "
+			       "for rootfs image.\n");
+			err = mtdram_init_device(mtd_ram,
+						 (void *)partition[part].offset,
+						 partition[part].size,
+						 partition[part].name);
+			if (err)
+				panic("axisflashmap: Could not initialize "
+				      "MTD RAM device!\n");
+			/* JFFS2 likes to have an erasesize. Keep potential
+			 * JFFS2 rootfs happy by providing one. Since image
+			 * was most likely created for main mtd, use that
+			 * erasesize, if available. Otherwise, make a guess. */
+			mtd_ram->erasesize = (main_mtd ? main_mtd->erasesize :
+				CONFIG_ETRAX_PTABLE_SECTOR);
+		} else {
+			err = add_mtd_partitions(main_mtd, &partition[part], 1);
+			if (err)
+				panic("axisflashmap: Could not add mtd "
+					"partition %d\n", part);
+		}
+	}
+#endif /* CONFIG_EXTRAX_VCS_SIM */
@@ -421,7 +614,12 @@
-#if !defined(CONFIG_MTD_MTDRAM) || (CONFIG_MTDRAM_TOTAL_SIZE != 0) || (CONFIG_MTDRAM_ABS_POS != 0)
-		/* No use trying to boot this kernel from RAM. Panic! */
-		printk(KERN_EMERG "axisflashmap: Cannot create an MTD RAM "
-		       "device due to kernel (mis)configuration!\n");
-		panic("This kernel cannot boot from RAM!\n");
-#else
-		struct mtd_info *mtd_ram;
+#ifdef CONFIG_ETRAX_VCS_SIM
+	/* For simulator, always use a RAM partition.
+	 * The rootfs will be found after the kernel in RAM,
+	 * with romfs_start and romfs_end indicating location and size.
+	 */
+	struct mtd_info *mtd_ram;
+
+	mtd_ram = kmalloc(sizeof(struct mtd_info), GFP_KERNEL);
+	if (!mtd_ram) {
+		panic("axisflashmap: Couldn't allocate memory for "
+		      "mtd_info!\n");
+	}
@@ -429,6 +627,11 @@
-		mtd_ram = kmalloc(sizeof(struct mtd_info),
-						     GFP_KERNEL);
-		if (!mtd_ram) {
-			panic("axisflashmap couldn't allocate memory for "
-			      "mtd_info!\n");
-		}
+	printk(KERN_INFO "axisflashmap: Adding RAM partition for romfs, "
+	       "at %u, size %u\n",
+	       (unsigned) romfs_start, (unsigned) romfs_length);
+
+	err = mtdram_init_device(mtd_ram, (void *)romfs_start,
+				 romfs_length, "romfs");
+	if (err) {
+		panic("axisflashmap: Could not initialize MTD RAM "
+		      "device!\n");
+	}
+#endif /* CONFIG_EXTRAX_VCS_SIM */
@@ -436,2 +639,7 @@
-		printk(KERN_INFO " Adding RAM partition for romfs image:\n");
-		printk(pmsg, pidx, romfs_start, romfs_length);
+#ifndef CONFIG_ETRAX_VCS_SIM
+	if (aux_mtd) {
+		aux_partition.size = aux_mtd->size;
+		err = add_mtd_partitions(aux_mtd, &aux_partition, 1);
+		if (err)
+			panic("axisflashmap: Could not initialize "
+			      "aux mtd device!\n");
@@ -439,7 +646,0 @@
-		err = mtdram_init_device(mtd_ram, (void*)romfs_start,
-		                         romfs_length, "romfs");
-		if (err) {
-			panic("axisflashmap could not initialize MTD RAM "
-			      "device!\n");
-		}
-#endif
@@ -446,0 +648 @@
+#endif /* CONFIG_EXTRAX_VCS_SIM */
--- ./projects/linux/linux-2.6.13/arch/ia64/hp/sim/simserial.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/arch/ia64/hp/sim/simserial.c	2005-10-28 02:02:08.000000000 +0200
@@ -133 +133 @@
-#if SIMSERIAL_DEBUG
+#ifdef SIMSERIAL_DEBUG
--- ./projects/linux/linux-2.6.14/arch/ia64/hp/sim/simserial.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/arch/ia64/hp/sim/simserial.c	2006-01-03 04:21:10.000000000 +0100
@@ -645,4 +645,2 @@
-		if (info->close_delay) {
-			current->state = TASK_INTERRUPTIBLE;
-			schedule_timeout(info->close_delay);
-		}
+		if (info->close_delay)
+			schedule_timeout_interruptible(info->close_delay);
--- ./projects/linux/linux-2.6.15/arch/ia64/hp/sim/simserial.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/arch/ia64/hp/sim/simserial.c	2006-03-20 06:53:29.000000000 +0100
@@ -28,0 +29 @@
+#include <linux/capability.h>
@@ -110 +110,0 @@
-static DECLARE_MUTEX(tmp_buf_sem);
@@ -169 +168,0 @@
-		if (tty->flip.count >= TTY_FLIPBUF_SIZE) break;
@@ -171,7 +170,2 @@
-		*tty->flip.char_buf_ptr = ch;
-
-		*tty->flip.flag_buf_ptr = 0;
-
-		tty->flip.flag_buf_ptr++;
-		tty->flip.char_buf_ptr++;
-		tty->flip.count++;
+		if (tty_insert_flip_char(tty, ch, TTY_NORMAL) == 0)
+			break;
--- ./projects/linux/linux-2.6.16/arch/ia64/hp/sim/simserial.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/arch/ia64/hp/sim/simserial.c	2006-06-18 03:49:35.000000000 +0200
@@ -49,5 +48,0 @@
-#define SERIAL_INLINE	1
-
-#ifdef SERIAL_INLINE
-#define _INLINE_ inline
-#endif
@@ -240 +235 @@
-static _INLINE_ void transmit_chars(struct async_struct *info, int *intr_done)
+static void transmit_chars(struct async_struct *info, int *intr_done)
--- ./projects/linux/linux-2.6.17/arch/ia64/hp/sim/simserial.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/ia64/hp/sim/simserial.c	2006-09-20 05:42:06.000000000 +0200
@@ -19 +18,0 @@
-#include <linux/config.h>
@@ -50 +49 @@
-#define IRQ_T(info) ((info->flags & ASYNC_SHARE_IRQ) ? SA_SHIRQ : SA_INTERRUPT)
+#define IRQ_T(info) ((info->flags & ASYNC_SHARE_IRQ) ? IRQF_SHARED : IRQF_DISABLED)
--- ./projects/linux/linux-2.6.18/arch/ia64/hp/sim/simserial.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/ia64/hp/sim/simserial.c	2006-11-29 22:57:37.000000000 +0100
@@ -95 +95 @@
-	{ 0, 0}
+	{ NULL, 0}
@@ -133 +133 @@
-static  void receive_chars(struct tty_struct *tty, struct pt_regs *regs)
+static  void receive_chars(struct tty_struct *tty)
@@ -155 +155 @@
-					handle_sysrq(ch, regs, NULL);
+					handle_sysrq(ch, NULL);
@@ -173 +173 @@
-static irqreturn_t rs_interrupt_single(int irq, void *dev_id, struct pt_regs * regs)
+static irqreturn_t rs_interrupt_single(int irq, void *dev_id)
@@ -190 +190 @@
-	receive_chars(info->tty, regs);
+	receive_chars(info->tty);
@@ -558 +558 @@
-			info->xmit.buf = 0;
+			info->xmit.buf = NULL;
@@ -631 +631 @@
-	info->tty = 0;
+	info->tty = NULL;
@@ -671 +671 @@
-	info->tty = 0;
+	info->tty = NULL;
@@ -717 +717 @@
-	irqreturn_t (*handler)(int, void *, struct pt_regs *);
+	irq_handler_t handler;
@@ -772 +772 @@
-	info->prev_port = 0;
+	info->prev_port = NULL;
@@ -943 +943 @@
-static struct tty_operations hp_ops = {
+static const struct tty_operations hp_ops = {
--- ./projects/linux/linux-2.6.19/arch/ia64/hp/sim/simserial.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/arch/ia64/hp/sim/simserial.c	2007-02-04 19:44:54.000000000 +0100
@@ -212 +212 @@
-static void do_softint(void *private_)
+static void do_softint(struct work_struct *private_)
@@ -491 +491 @@
-static void rs_set_termios(struct tty_struct *tty, struct termios *old_termios)
+static void rs_set_termios(struct tty_struct *tty, struct ktermios *old_termios)
@@ -687 +687 @@
-	info = kmalloc(sizeof(struct async_struct), GFP_KERNEL);
+	info = kzalloc(sizeof(struct async_struct), GFP_KERNEL);
@@ -692 +691,0 @@
-	memset(info, 0, sizeof(struct async_struct));
@@ -701 +700 @@
-	INIT_WORK(&info->work, do_softint, info);
+	INIT_WORK(&info->work, do_softint);
--- ./projects/linux/linux-2.6.22/arch/ia64/hp/sim/simserial.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/arch/ia64/hp/sim/simserial.c	2007-10-09 22:31:38.000000000 +0200
@@ -39,4 +38,0 @@
-#ifdef CONFIG_KDB
-# include <linux/kdb.h>
-#endif
-
--- ./projects/linux/linux-2.6.24/arch/ia64/hp/sim/simserial.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/ia64/hp/sim/simserial.c	2008-04-17 04:49:44.000000000 +0200
@@ -1003 +1003 @@
-				      __FUNCTION__);
+				      __func__);
--- ./projects/linux/linux-2.6.25/arch/ia64/hp/sim/simserial.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/arch/ia64/hp/sim/simserial.c	2008-07-13 23:51:29.000000000 +0200
@@ -213 +213 @@
-static void rs_put_char(struct tty_struct *tty, unsigned char ch)
+static int rs_put_char(struct tty_struct *tty, unsigned char ch)
@@ -218 +218,2 @@
-	if (!tty || !info->xmit.buf) return;
+	if (!tty || !info->xmit.buf)
+		return 0;
@@ -223 +224 @@
-		return;
+		return 0;
@@ -227,0 +229 @@
+	return 1;
@@ -624 +626,2 @@
-	if (tty->driver->flush_buffer) tty->driver->flush_buffer(tty);
+	if (tty->ops->flush_buffer)
+		tty->ops->flush_buffer(tty);
--- ./projects/linux/linux-2.6.26/arch/ia64/hp/sim/simserial.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/arch/ia64/hp/sim/simserial.c	2008-10-10 00:13:53.000000000 +0200
@@ -196,12 +195,0 @@
-#if 0
-/*
- * not really used in our situation so keep them commented out for now
- */
-static DECLARE_TASK_QUEUE(tq_serial); /* used to be at the top of the file */
-static void do_serial_bh(void)
-{
-	run_task_queue(&tq_serial);
-	printk(KERN_ERR "do_serial_bh: called\n");
-}
-#endif
-
@@ -354,5 +342 @@
-	wake_up_interruptible(&tty->write_wait);
-
-	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) &&
-	    tty->ldisc.write_wakeup)
-		(tty->ldisc.write_wakeup)(tty);
+	tty_wakeup(tty);
@@ -407,6 +390,0 @@
-/*
- * rs_break() --- routine which turns the break handling on or off
- */
-static void rs_break(struct tty_struct *tty, int break_state)
-{
-}
@@ -425,8 +402,0 @@
-		case TIOCMGET:
-			printk(KERN_INFO "rs_ioctl: TIOCMGET called\n");
-			return -EINVAL;
-		case TIOCMBIS:
-		case TIOCMBIC:
-		case TIOCMSET:
-			printk(KERN_INFO "rs_ioctl: TIOCMBIS/BIC/SET called\n");
-			return -EINVAL;
@@ -491,8 +460,0 @@
-	unsigned int cflag = tty->termios->c_cflag;
-
-	if (   (cflag == old_termios->c_cflag)
-	    && (   RELEVANT_IFLAG(tty->termios->c_iflag)
-		== RELEVANT_IFLAG(old_termios->c_iflag)))
-	  return;
-
-
@@ -626,3 +588,2 @@
-	if (tty->ops->flush_buffer)
-		tty->ops->flush_buffer(tty);
-	if (tty->ldisc.flush_buffer) tty->ldisc.flush_buffer(tty);
+	rs_flush_buffer(tty);
+	tty_ldisc_flush(tty);
@@ -958 +918,0 @@
-	.break_ctl = rs_break,
--- ./projects/linux/linux-2.6.29/arch/ia64/hp/sim/simserial.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/arch/ia64/hp/sim/simserial.c	2009-06-27 11:32:31.000000000 +0200
@@ -26,0 +27 @@
+#include <linux/seq_file.h>
@@ -851 +852 @@
-static inline int line_info(char *buf, struct serial_state *state)
+static inline void line_info(struct seq_file *m, struct serial_state *state)
@@ -853 +854 @@
-	return sprintf(buf, "%d: uart:%s port:%lX irq:%d\n",
+	seq_printf(m, "%d: uart:%s port:%lX irq:%d\n",
@@ -858,2 +859 @@
-static int rs_read_proc(char *page, char **start, off_t off, int count,
-		 int *eof, void *data)
+static int rs_proc_show(struct seq_file *m, void *v)
@@ -861,2 +861 @@
-	int i, len = 0, l;
-	off_t	begin = 0;
+	int i;
@@ -864,17 +863,4 @@
-	len += sprintf(page, "simserinfo:1.0 driver:%s\n", serial_version);
-	for (i = 0; i < NR_PORTS && len < 4000; i++) {
-		l = line_info(page + len, &rs_table[i]);
-		len += l;
-		if (len+begin > off+count)
-			goto done;
-		if (len+begin < off) {
-			begin += len;
-			len = 0;
-		}
-	}
-	*eof = 1;
-done:
-	if (off >= len+begin)
-		return 0;
-	*start = page + (begin-off);
-	return ((count < begin+len-off) ? count : begin+len-off);
+	seq_printf(m, "simserinfo:1.0 driver:%s\n", serial_version);
+	for (i = 0; i < NR_PORTS; i++)
+		line_info(m, &rs_table[i]);
+	return 0;
@@ -882,0 +869,13 @@
+static int rs_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, rs_proc_show, NULL);
+}
+
+static const struct file_operations rs_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= rs_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
@@ -920 +919 @@
-	.read_proc = rs_read_proc,
+	.proc_fops = &rs_proc_fops,
--- ./projects/linux/linux-2.6.20/arch/ia64/kernel/machine_kexec.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/arch/ia64/kernel/machine_kexec.c	2007-04-26 05:08:32.000000000 +0200
@@ -16,0 +17 @@
+#include <linux/efi.h>
@@ -71,11 +71,0 @@
-void machine_shutdown(void)
-{
-	int cpu;
-
-	for_each_online_cpu(cpu) {
-		if (cpu != smp_processor_id())
-			cpu_down(cpu);
-	}
-	kexec_disable_iosapic();
-}
-
@@ -86 +75,0 @@
-extern void *efi_get_pal_addr(void);
@@ -95,0 +85 @@
+	BUG_ON(!image);
@@ -133,0 +124 @@
+	BUG_ON(!image);
--- ./projects/linux/linux-2.6.23/arch/ia64/kernel/machine_kexec.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/arch/ia64/kernel/machine_kexec.c	2008-01-24 23:58:37.000000000 +0100
@@ -17,0 +18,4 @@
+#include <linux/numa.h>
+#include <linux/mmzone.h>
+
+#include <asm/numa.h>
@@ -21,0 +26 @@
+#include <asm/processor.h>
@@ -82 +86,0 @@
-	unsigned long vector;
@@ -110,2 +114 @@
-	vector = ia64_get_ivr();
-	while (vector != IA64_SPURIOUS_INT_VECTOR) {
+	while (ia64_get_ivr() != IA64_SPURIOUS_INT_VECTOR)
@@ -113,2 +115,0 @@
-		vector = ia64_get_ivr();
-	}
@@ -127,0 +129,25 @@
+
+void arch_crash_save_vmcoreinfo(void)
+{
+#if defined(CONFIG_ARCH_DISCONTIGMEM_ENABLE) && defined(CONFIG_NUMA)
+	VMCOREINFO_SYMBOL(pgdat_list);
+	VMCOREINFO_LENGTH(pgdat_list, MAX_NUMNODES);
+
+	VMCOREINFO_SYMBOL(node_memblk);
+	VMCOREINFO_LENGTH(node_memblk, NR_NODE_MEMBLKS);
+	VMCOREINFO_SIZE(node_memblk_s);
+	VMCOREINFO_OFFSET(node_memblk_s, start_paddr);
+	VMCOREINFO_OFFSET(node_memblk_s, size);
+#endif
+#ifdef CONFIG_PGTABLE_3
+	VMCOREINFO_CONFIG(PGTABLE_3);
+#elif  CONFIG_PGTABLE_4
+	VMCOREINFO_CONFIG(PGTABLE_4);
+#endif
+}
+
+unsigned long paddr_vmcoreinfo_note(void)
+{
+	return ia64_tpa((unsigned long)(char *)&vmcoreinfo_note);
+}
+
--- ./projects/linux/linux-2.6.24/arch/ia64/kernel/machine_kexec.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/ia64/kernel/machine_kexec.c	2008-04-17 04:49:44.000000000 +0200
@@ -132 +132 @@
-#if defined(CONFIG_ARCH_DISCONTIGMEM_ENABLE) && defined(CONFIG_NUMA)
+#if defined(CONFIG_DISCONTIGMEM) || defined(CONFIG_SPARSEMEM)
@@ -135 +135,2 @@
-
+#endif
+#ifdef CONFIG_NUMA
@@ -138 +139 @@
-	VMCOREINFO_SIZE(node_memblk_s);
+	VMCOREINFO_STRUCT_SIZE(node_memblk_s);
--- ./projects/linux/linux-2.6.13/arch/ia64/mm/fault.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/arch/ia64/mm/fault.c	2005-10-28 02:02:08.000000000 +0200
@@ -11,0 +12 @@
+#include <linux/kprobes.h>
@@ -79 +80 @@
-void
+void __kprobes
@@ -232,3 +232,0 @@
-	if (ia64_done_with_exception(regs))
-		return;
-
@@ -244,0 +243,3 @@
+	if (ia64_done_with_exception(regs))
+		return;
+
--- ./projects/linux/linux-2.6.14/arch/ia64/mm/fault.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/arch/ia64/mm/fault.c	2006-01-03 04:21:10.000000000 +0100
@@ -23,26 +22,0 @@
- * This routine is analogous to expand_stack() but instead grows the
- * register backing store (which grows towards higher addresses).
- * Since the register backing store is access sequentially, we
- * disallow growing the RBS by more than a page at a time.  Note that
- * the VM_GROWSUP flag can be set on any VM area but that's fine
- * because the total process size is still limited by RLIMIT_STACK and
- * RLIMIT_AS.
- */
-static inline long
-expand_backing_store (struct vm_area_struct *vma, unsigned long address)
-{
-	unsigned long grow;
-
-	grow = PAGE_SIZE >> PAGE_SHIFT;
-	if (address - vma->vm_start > current->signal->rlim[RLIMIT_STACK].rlim_cur
-	    || (((vma->vm_mm->total_vm + grow) << PAGE_SHIFT) > current->signal->rlim[RLIMIT_AS].rlim_cur))
-		return -ENOMEM;
-	vma->vm_end += PAGE_SIZE;
-	vma->vm_mm->total_vm += grow;
-	if (vma->vm_flags & VM_LOCKED)
-		vma->vm_mm->locked_vm += grow;
-	__vm_stat_account(vma->vm_mm, vma->vm_flags, vma->vm_file, grow);
-	return 0;
-}
-
-/*
@@ -188 +162,7 @@
-		if (expand_backing_store(vma, address))
+		/*
+		 * Since the register backing store is accessed sequentially,
+		 * we disallow growing it by more than a page at a time.
+		 */
+		if (address > vma->vm_end + PAGE_SIZE - sizeof(long))
+			goto bad_area;
+		if (expand_upwards(vma, address))
--- ./projects/linux/linux-2.6.16/arch/ia64/mm/fault.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/arch/ia64/mm/fault.c	2006-06-18 03:49:35.000000000 +0200
@@ -62,0 +63,3 @@
+	/* mmap_sem is performance critical.... */
+	prefetchw(&mm->mmap_sem);
+
--- ./projects/linux/linux-2.6.17/arch/ia64/mm/fault.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/ia64/mm/fault.c	2006-09-20 05:42:06.000000000 +0200
@@ -21,0 +22,34 @@
+#ifdef CONFIG_KPROBES
+ATOMIC_NOTIFIER_HEAD(notify_page_fault_chain);
+
+/* Hook to register for page fault notifications */
+int register_page_fault_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_register(&notify_page_fault_chain, nb);
+}
+
+int unregister_page_fault_notifier(struct notifier_block *nb)
+{
+	return atomic_notifier_chain_unregister(&notify_page_fault_chain, nb);
+}
+
+static inline int notify_page_fault(enum die_val val, const char *str,
+			struct pt_regs *regs, long err, int trap, int sig)
+{
+	struct die_args args = {
+		.regs = regs,
+		.str = str,
+		.err = err,
+		.trapnr = trap,
+		.signr = sig
+	};
+	return atomic_notifier_call_chain(&notify_page_fault_chain, val, &args);
+}
+#else
+static inline int notify_page_fault(enum die_val val, const char *str,
+			struct pt_regs *regs, long err, int trap, int sig)
+{
+	return NOTIFY_DONE;
+}
+#endif
+
@@ -87 +121 @@
-	if (notify_die(DIE_PAGE_FAULT, "page fault", regs, code, TRAP_BRKPT,
+	if (notify_page_fault(DIE_PAGE_FAULT, "page fault", regs, code, TRAP_BRKPT,
--- ./projects/linux/linux-2.6.18/arch/ia64/mm/fault.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/ia64/mm/fault.c	2006-11-29 22:57:37.000000000 +0100
@@ -148,0 +149,3 @@
+	if (((isr >> IA64_ISR_R_BIT) & 1UL) && (!(vma->vm_flags & (VM_READ | VM_WRITE))))
+		goto bad_area;
+
@@ -150,2 +153 @@
-		| (((isr >> IA64_ISR_W_BIT) & 1UL) << VM_WRITE_BIT)
-		| (((isr >> IA64_ISR_R_BIT) & 1UL) << VM_READ_BIT));
+		| (((isr >> IA64_ISR_W_BIT) & 1UL) << VM_WRITE_BIT));
@@ -281 +283 @@
-	if (current->pid == 1) {
+	if (is_init(current)) {
--- ./projects/linux/linux-2.6.21/arch/ia64/mm/fault.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/arch/ia64/mm/fault.c	2007-07-09 01:32:17.000000000 +0200
@@ -10 +9,0 @@
-#include <linux/smp_lock.h>
@@ -12,0 +12 @@
+#include <linux/kdebug.h>
@@ -18 +17,0 @@
-#include <asm/kdebug.h>
@@ -23,4 +22 @@
-ATOMIC_NOTIFIER_HEAD(notify_page_fault_chain);
-
-/* Hook to register for page fault notifications */
-int register_page_fault_notifier(struct notifier_block *nb)
+static inline int notify_page_fault(struct pt_regs *regs, int trap)
@@ -28,2 +24 @@
-	return atomic_notifier_chain_register(&notify_page_fault_chain, nb);
-}
+	int ret = 0;
@@ -31,4 +26,7 @@
-int unregister_page_fault_notifier(struct notifier_block *nb)
-{
-	return atomic_notifier_chain_unregister(&notify_page_fault_chain, nb);
-}
+	if (!user_mode(regs)) {
+		/* kprobe_running() needs smp_processor_id() */
+		preempt_disable();
+		if (kprobe_running() && kprobes_fault_handler(regs, trap))
+			ret = 1;
+		preempt_enable();
+	}
@@ -36,11 +34 @@
-static inline int notify_page_fault(enum die_val val, const char *str,
-			struct pt_regs *regs, long err, int trap, int sig)
-{
-	struct die_args args = {
-		.regs = regs,
-		.str = str,
-		.err = err,
-		.trapnr = trap,
-		.signr = sig
-	};
-	return atomic_notifier_call_chain(&notify_page_fault_chain, val, &args);
+	return ret;
@@ -49,2 +37 @@
-static inline int notify_page_fault(enum die_val val, const char *str,
-			struct pt_regs *regs, long err, int trap, int sig)
+static inline int notify_page_fault(struct pt_regs *regs, int trap)
@@ -52 +39 @@
-	return NOTIFY_DONE;
+	return 0;
@@ -121,2 +108 @@
-	if (notify_page_fault(DIE_PAGE_FAULT, "page fault", regs, code, TRAP_BRKPT,
-					SIGSEGV) == NOTIFY_STOP)
+	if (notify_page_fault(regs, TRAP_BRKPT))
--- ./projects/linux/linux-2.6.22/arch/ia64/mm/fault.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/arch/ia64/mm/fault.c	2007-10-09 22:31:38.000000000 +0200
@@ -82,0 +83 @@
+	int fault;
@@ -114 +115 @@
-	if (!vma)
+	if (!vma && !prev_vma )
@@ -117,2 +118,8 @@
-	/* find_vma_prev() returns vma such that address < vma->vm_end or NULL */
-	if (address < vma->vm_start)
+        /*
+         * find_vma_prev() returns vma such that address < vma->vm_end or NULL
+         *
+         * May find no vma, but could be that the last vm area is the
+         * register backing store that needs to expand upwards, in
+         * this case vma will be null, but prev_vma will ne non-null
+         */
+        if (( !vma && prev_vma ) || (address < vma->vm_start) )
@@ -150,8 +157,2 @@
-	switch (handle_mm_fault(mm, vma, address, (mask & VM_WRITE) != 0)) {
-	      case VM_FAULT_MINOR:
-		++current->min_flt;
-		break;
-	      case VM_FAULT_MAJOR:
-		++current->maj_flt;
-		break;
-	      case VM_FAULT_SIGBUS:
+	fault = handle_mm_fault(mm, vma, address, (mask & VM_WRITE) != 0);
+	if (unlikely(fault & VM_FAULT_ERROR)) {
@@ -163,5 +164,6 @@
-		signal = SIGBUS;
-		goto bad_area;
-	      case VM_FAULT_OOM:
-		goto out_of_memory;
-	      default:
+		if (fault & VM_FAULT_OOM) {
+			goto out_of_memory;
+		} else if (fault & VM_FAULT_SIGBUS) {
+			signal = SIGBUS;
+			goto bad_area;
+		}
@@ -169,0 +172,4 @@
+	if (fault & VM_FAULT_MAJOR)
+		current->maj_flt++;
+	else
+		current->min_flt++;
@@ -174,0 +181,2 @@
+		if (!vma)
+			goto bad_area;
--- ./projects/linux/linux-2.6.23/arch/ia64/mm/fault.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/arch/ia64/mm/fault.c	2008-01-24 23:58:37.000000000 +0100
@@ -277 +277 @@
-	if (is_init(current)) {
+	if (is_global_init(current)) {
@@ -284 +284 @@
-		do_exit(SIGKILL);
+		do_group_exit(SIGKILL);
--- ./projects/linux/linux-2.6.24/arch/ia64/mm/fault.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/ia64/mm/fault.c	2008-04-17 04:49:44.000000000 +0200
@@ -19 +19 @@
-extern void die (char *, struct pt_regs *, long);
+extern int die(char *, struct pt_regs *, long);
@@ -29 +29 @@
-		if (kprobe_running() && kprobes_fault_handler(regs, trap))
+		if (kprobe_running() && kprobe_fault_handler(regs, trap))
@@ -270 +270,2 @@
-	die("Oops", regs, isr);
+	if (die("Oops", regs, isr))
+		regs = NULL;
@@ -272 +273,2 @@
-	do_exit(SIGKILL);
+	if (regs)
+		do_exit(SIGKILL);
--- ./projects/linux/linux-2.6.13/arch/ia64/sn/kernel/io_init.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/arch/ia64/sn/kernel/io_init.c	2005-10-28 02:02:08.000000000 +0200
@@ -20,0 +21 @@
+#include <asm/sn/tioce_provider.h>
@@ -46,0 +48,3 @@
+static int max_segment_number = 0; /* Default highest segment number */
+static int max_pcibus_number = 255; /* Default highest pci bus number */
+
@@ -159,0 +164,4 @@
+	/*
+	 * Get SGI Specific HUB chipset information.
+	 * Inform Prom that this kernel can support domain bus numbering.
+	 */
@@ -162,0 +171,2 @@
+		hubdev->max_segment_number = 0xffffffff;
+		hubdev->max_pcibus_number = 0xff;
@@ -166,0 +177,9 @@
+		/* Save the largest Domain and pcibus numbers found. */
+		if (hubdev->max_segment_number) {
+			/*
+			 * Dealing with a Prom that supports segments.
+			 */
+			max_segment_number = hubdev->max_segment_number;
+			max_pcibus_number = hubdev->max_pcibus_number;
+		}
+
@@ -233 +252 @@
-	int segment = 0;
+	int segment = pci_domain_nr(dev->bus);
@@ -286 +305 @@
- 	bus_no = SN_PCIDEV_INFO(dev)->pdi_slot_host_handle >> 32;
+ 	bus_no = (SN_PCIDEV_INFO(dev)->pdi_slot_host_handle >> 32) & 0xff;
@@ -288 +307 @@
- 	host_pci_bus = pci_find_bus(pci_domain_nr(dev->bus), bus_no);
+ 	host_pci_bus = pci_find_bus(segment, bus_no);
@@ -335,0 +355 @@
+	controller->segment = segment;
@@ -393 +413 @@
-		printk(KERN_WARNING "Device ASIC=%u XID=%u PBUSNUM=%lu"
+		printk(KERN_WARNING "Device ASIC=%u XID=%u PBUSNUM=%u"
@@ -414 +434 @@
-	element = kcalloc(1, sizeof(struct sysdata_el), GFP_KERNEL);
+	element = kzalloc(sizeof(struct sysdata_el), GFP_KERNEL);
@@ -447,0 +468 @@
+	int j = 0;
@@ -466,0 +488 @@
+	tioce_init_provider();
@@ -482,2 +504,3 @@
-	for (i = 0; i < PCI_BUSES_TO_SCAN; i++)
-		sn_pci_controller_fixup(0, i, NULL);
+	for (i = 0; i <= max_segment_number; i++)
+		for (j = 0; j <= max_pcibus_number; j++)
+			sn_pci_controller_fixup(i, j, NULL);
--- ./projects/linux/linux-2.6.14/arch/ia64/sn/kernel/io_init.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/arch/ia64/sn/kernel/io_init.c	2006-01-03 04:21:10.000000000 +0100
@@ -6 +6 @@
- * Copyright (C) 1992 - 1997, 2000-2004 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 1992 - 1997, 2000-2005 Silicon Graphics, Inc. All rights reserved.
@@ -25,2 +24,0 @@
-nasid_t master_nasid = INVALID_NASID;	/* Partition Master */
-
@@ -151,0 +150,18 @@
+ * sn_pcidev_info_get() - Retrieve the pcidev_info struct for the specified
+ *			  device.
+ */
+inline struct pcidev_info *
+sn_pcidev_info_get(struct pci_dev *dev)
+{
+	struct pcidev_info *pcidev;
+
+	list_for_each_entry(pcidev,
+			    &(SN_PCI_CONTROLLER(dev)->pcidev_info), pdi_list) {
+		if (pcidev->pdi_linux_pcidev == dev) {
+			return pcidev;
+		}
+	}
+	return NULL;
+}
+
+/*
@@ -168 +184 @@
-	for (i = 0; i < numionodes; i++) {
+	for (i = 0; i < num_cnodes; i++) {
@@ -233,0 +250,44 @@
+/*
+ * sn_pci_window_fixup() - Create a pci_window for each device resource.
+ *			   Until ACPI support is added, we need this code
+ *			   to setup pci_windows for use by
+ *			   pcibios_bus_to_resource(),
+ *			   pcibios_resource_to_bus(), etc.
+ */
+static void
+sn_pci_window_fixup(struct pci_dev *dev, unsigned int count,
+		    int64_t * pci_addrs)
+{
+	struct pci_controller *controller = PCI_CONTROLLER(dev->bus);
+	unsigned int i;
+	unsigned int idx;
+	unsigned int new_count;
+	struct pci_window *new_window;
+
+	if (count == 0)
+		return;
+	idx = controller->windows;
+	new_count = controller->windows + count;
+	new_window = kcalloc(new_count, sizeof(struct pci_window), GFP_KERNEL);
+	if (new_window == NULL)
+		BUG();
+	if (controller->window) {
+		memcpy(new_window, controller->window,
+		       sizeof(struct pci_window) * controller->windows);
+		kfree(controller->window);
+	}
+
+	/* Setup a pci_window for each device resource. */
+	for (i = 0; i <= PCI_ROM_RESOURCE; i++) {
+		if (pci_addrs[i] == -1)
+			continue;
+
+		new_window[idx].offset = dev->resource[i].start - pci_addrs[i];
+		new_window[idx].resource = dev->resource[i];
+		idx++;
+	}
+
+	controller->windows = new_count;
+	controller->window = new_window;
+}
+
@@ -250,0 +311 @@
+	unsigned int count = 0;
@@ -256,0 +318,2 @@
+	struct pcidev_info *pcidev_info;
+	int64_t pci_addrs[PCI_ROM_RESOURCE + 1];
@@ -262,2 +325,2 @@
-	dev->sysdata = kmalloc(sizeof(struct pcidev_info), GFP_KERNEL);
-	if (SN_PCIDEV_INFO(dev) <= 0)
+	pcidev_info = kzalloc(sizeof(struct pcidev_info), GFP_KERNEL);
+	if (pcidev_info <= 0)
@@ -265 +327,0 @@
-	memset(SN_PCIDEV_INFO(dev), 0, sizeof(struct pcidev_info));
@@ -275 +337 @@
-				     (u64) __pa(SN_PCIDEV_INFO(dev)),
+				     (u64) __pa(pcidev_info),
@@ -279,0 +342,4 @@
+	/* Add pcidev_info to list in sn_pci_controller struct */
+	list_add_tail(&pcidev_info->pdi_list,
+		      &(SN_PCI_CONTROLLER(dev->bus)->pcidev_info));
+
@@ -284 +350,2 @@
-		if (!SN_PCIDEV_INFO(dev)->pdi_pio_mapped_addr[idx])
+		if (!pcidev_info->pdi_pio_mapped_addr[idx]) {
+			pci_addrs[idx] = -1;
@@ -285,0 +353 @@
+		}
@@ -290 +358,7 @@
-		addr = SN_PCIDEV_INFO(dev)->pdi_pio_mapped_addr[idx];
+		if (size == 0) {
+			pci_addrs[idx] = -1;
+			continue;
+		}
+		pci_addrs[idx] = start;
+		count++;
+		addr = pcidev_info->pdi_pio_mapped_addr[idx];
@@ -298,0 +373,5 @@
+	/* Create a pci_window in the pci_controller struct for
+	 * each device resource.
+	 */
+	if (count > 0)
+		sn_pci_window_fixup(dev, count, pci_addrs);
@@ -305,2 +384,2 @@
- 	bus_no = (SN_PCIDEV_INFO(dev)->pdi_slot_host_handle >> 32) & 0xff;
- 	devfn = SN_PCIDEV_INFO(dev)->pdi_slot_host_handle & 0xffffffff;
+	bus_no = (pcidev_info->pdi_slot_host_handle >> 32) & 0xff;
+	devfn = pcidev_info->pdi_slot_host_handle & 0xffffffff;
@@ -310,4 +389,3 @@
-	SN_PCIDEV_INFO(dev)->host_pci_dev = host_pci_dev;
-	SN_PCIDEV_INFO(dev)->pdi_host_pcidev_info =
-	    					SN_PCIDEV_INFO(host_pci_dev);
-	SN_PCIDEV_INFO(dev)->pdi_linux_pcidev = dev;
+	pcidev_info->host_pci_dev = host_pci_dev;
+	pcidev_info->pdi_linux_pcidev = dev;
+	pcidev_info->pdi_host_pcidev_info = SN_PCIDEV_INFO(host_pci_dev);
@@ -315 +393 @@
-	SN_PCIDEV_INFO(dev)->pdi_pcibus_info = bs;
+	pcidev_info->pdi_pcibus_info = bs;
@@ -325,2 +403,2 @@
-		SN_PCIDEV_INFO(dev)->pdi_sn_irq_info = sn_irq_info;
-		dev->irq = SN_PCIDEV_INFO(dev)->pdi_sn_irq_info->irq_irq;
+		pcidev_info->pdi_sn_irq_info = sn_irq_info;
+		dev->irq = pcidev_info->pdi_sn_irq_info->irq_irq;
@@ -329 +407 @@
-		SN_PCIDEV_INFO(dev)->pdi_sn_irq_info = NULL;
+		pcidev_info->pdi_sn_irq_info = NULL;
@@ -342,0 +421 @@
+	struct sn_pci_controller *sn_controller;
@@ -354 +433,8 @@
- 	controller = kcalloc(1,sizeof(struct pci_controller), GFP_KERNEL);
+	/* Allocate a sn_pci_controller, which has a pci_controller struct
+	 * as the first member.
+	 */
+	sn_controller = kzalloc(sizeof(struct sn_pci_controller), GFP_KERNEL);
+	if (!sn_controller)
+		BUG();
+	INIT_LIST_HEAD(&sn_controller->pcidev_info);
+	controller = &sn_controller->pci_controller;
@@ -356,2 +441,0 @@
- 	if (!controller)
- 		BUG();
@@ -394,0 +479,23 @@
+	 * Setup pci_windows for legacy IO and MEM space.
+	 * (Temporary until ACPI support is in place.)
+	 */
+	controller->window = kcalloc(2, sizeof(struct pci_window), GFP_KERNEL);
+	if (controller->window == NULL)
+		BUG();
+	controller->window[0].offset = prom_bussoft_ptr->bs_legacy_io;
+	controller->window[0].resource.name = "legacy_io";
+	controller->window[0].resource.flags = IORESOURCE_IO;
+	controller->window[0].resource.start = prom_bussoft_ptr->bs_legacy_io;
+	controller->window[0].resource.end =
+	    controller->window[0].resource.start + 0xffff;
+	controller->window[0].resource.parent = &ioport_resource;
+	controller->window[1].offset = prom_bussoft_ptr->bs_legacy_mem;
+	controller->window[1].resource.name = "legacy_mem";
+	controller->window[1].resource.flags = IORESOURCE_MEM;
+	controller->window[1].resource.start = prom_bussoft_ptr->bs_legacy_mem;
+	controller->window[1].resource.end =
+	    controller->window[1].resource.start + (1024 * 1024) - 1;
+	controller->window[1].resource.parent = &iomem_resource;
+	controller->windows = 2;
+
+	/*
@@ -426 +533 @@
-	kfree(controller);
+	kfree(sn_controller);
@@ -439 +546 @@
-	element->sysdata = dev->sysdata;
+	element->sysdata = SN_PCIDEV_INFO(dev);
--- ./projects/linux/linux-2.6.15/arch/ia64/sn/kernel/io_init.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/arch/ia64/sn/kernel/io_init.c	2006-03-20 06:53:29.000000000 +0100
@@ -12,0 +13 @@
+#include <asm/sn/sn_feature_sets.h>
@@ -24,0 +26,4 @@
+
+extern void sn_init_cpei_timer(void);
+extern void register_sn_procfs(void);
+
@@ -42 +47 @@
-int sn_ioif_inited = 0;		/* SN I/O infrastructure initialized? */
+int sn_ioif_inited;		/* SN I/O infrastructure initialized? */
@@ -46,2 +51,2 @@
-static int max_segment_number = 0; /* Default highest segment number */
-static int max_pcibus_number = 255; /* Default highest pci bus number */
+static int max_segment_number;		 /* Default highest segment number */
+static int max_pcibus_number = 255;	/* Default highest pci bus number */
@@ -79,2 +84,2 @@
- * Retrieve the DMA Flush List given nasid.  This list is needed 
- * to implement the WAR - Flush DMA data on PIO Reads.
+ * Retrieve the DMA Flush List given nasid, widget, and device.
+ * This list is needed to implement the WAR - Flush DMA data on PIO Reads.
@@ -82,2 +87,3 @@
-static inline uint64_t
-sal_get_widget_dmaflush_list(u64 nasid, u64 widget_num, u64 address)
+static inline u64
+sal_get_device_dmaflush_list(u64 nasid, u64 widget_num, u64 device_num,
+			     u64 address)
@@ -85 +90,0 @@
-
@@ -91,5 +96,4 @@
-			(u64) SN_SAL_IOIF_GET_WIDGET_DMAFLUSH_LIST,
-			(u64) nasid, (u64) widget_num, (u64) address, 0, 0, 0,
-			0);
-	return ret_stuff.v0;
-
+			(u64) SN_SAL_IOIF_GET_DEVICE_DMAFLUSH_LIST,
+			(u64) nasid, (u64) widget_num,
+			(u64) device_num, (u64) address, 0, 0, 0);
+	return ret_stuff.status;
@@ -101 +105 @@
-static inline uint64_t sal_get_hubdev_info(u64 handle, u64 address)
+static inline u64 sal_get_hubdev_info(u64 handle, u64 address)
@@ -103 +106,0 @@
-
@@ -117 +120 @@
-static inline uint64_t sal_get_pcibus_info(u64 segment, u64 busnum, u64 address)
+static inline u64 sal_get_pcibus_info(u64 segment, u64 busnum, u64 address)
@@ -119 +121,0 @@
-
@@ -133,3 +135,3 @@
-static inline uint64_t
-sal_get_pcidev_info(u64 segment, u64 bus_number, u64 devfn, u64 pci_dev, 
-			u64 sn_irq_info)
+static inline u64
+sal_get_pcidev_info(u64 segment, u64 bus_number, u64 devfn, u64 pci_dev,
+		    u64 sn_irq_info)
@@ -143 +145 @@
-			(u64) segment, (u64) bus_number, (u64) devfn, 
+			(u64) segment, (u64) bus_number, (u64) devfn,
@@ -166,0 +169,38 @@
+/* Older PROM flush WAR
+ *
+ * 01/16/06 -- This war will be in place until a new official PROM is released.
+ * Additionally note that the struct sn_flush_device_war also has to be
+ * removed from arch/ia64/sn/include/xtalk/hubdev.h
+ */
+static u8 war_implemented = 0;
+
+static s64 sn_device_fixup_war(u64 nasid, u64 widget, int device,
+			       struct sn_flush_device_common *common)
+{
+	struct sn_flush_device_war *war_list;
+	struct sn_flush_device_war *dev_entry;
+	struct ia64_sal_retval isrv = {0,0,0,0};
+
+	if (!war_implemented) {
+		printk(KERN_WARNING "PROM version < 4.50 -- implementing old "
+		       "PROM flush WAR\n");
+		war_implemented = 1;
+	}
+
+	war_list = kzalloc(DEV_PER_WIDGET * sizeof(*war_list), GFP_KERNEL);
+	if (!war_list)
+		BUG();
+
+	SAL_CALL_NOLOCK(isrv, SN_SAL_IOIF_GET_WIDGET_DMAFLUSH_LIST,
+			nasid, widget, __pa(war_list), 0, 0, 0 ,0);
+	if (isrv.status)
+		panic("sn_device_fixup_war failed: %s\n",
+		      ia64_sal_strerror(isrv.status));
+
+	dev_entry = war_list + device;
+	memcpy(common,dev_entry, sizeof(*common));
+	kfree(war_list);
+
+	return isrv.status;
+}
+
@@ -168 +208 @@
- * sn_fixup_ionodes() - This routine initializes the HUB data strcuture for 
+ * sn_fixup_ionodes() - This routine initializes the HUB data strcuture for
@@ -171 +211 @@
-static void sn_fixup_ionodes(void)
+static void __init sn_fixup_ionodes(void)
@@ -173,2 +213,2 @@
-
-	struct sn_flush_device_list *sn_flush_device_list;
+	struct sn_flush_device_kernel *sn_flush_device_kernel;
+	struct sn_flush_device_kernel *dev_entry;
@@ -176,3 +216,3 @@
-	uint64_t status;
-	uint64_t nasid;
-	int i, widget;
+	u64 status;
+	u64 nasid;
+	int i, widget, device, size;
@@ -189 +229 @@
-		status = sal_get_hubdev_info(nasid, (uint64_t) __pa(hubdev));
+		status = sal_get_hubdev_info(nasid, (u64) __pa(hubdev));
@@ -213,0 +254,2 @@
+		size = (HUB_WIDGET_ID_MAX + 1) *
+			sizeof(struct sn_flush_device_kernel *);
@@ -215,6 +257,3 @@
-		    kmalloc((HUB_WIDGET_ID_MAX + 1) *
-			    sizeof(struct sn_flush_device_list *), GFP_KERNEL);
-
-		memset(hubdev->hdi_flush_nasid_list.widget_p, 0x0,
-		       (HUB_WIDGET_ID_MAX + 1) *
-		       sizeof(struct sn_flush_device_list *));
+			kzalloc(size, GFP_KERNEL);
+		if (!hubdev->hdi_flush_nasid_list.widget_p)
+			BUG();
@@ -223,17 +262,26 @@
-			sn_flush_device_list = kmalloc(DEV_PER_WIDGET *
-						       sizeof(struct
-							      sn_flush_device_list),
-						       GFP_KERNEL);
-			memset(sn_flush_device_list, 0x0,
-			       DEV_PER_WIDGET *
-			       sizeof(struct sn_flush_device_list));
-
-			status =
-			    sal_get_widget_dmaflush_list(nasid, widget,
-							 (uint64_t)
-							 __pa
-							 (sn_flush_device_list));
-			if (status) {
-				kfree(sn_flush_device_list);
-				continue;
-			}
+			size = DEV_PER_WIDGET *
+				sizeof(struct sn_flush_device_kernel);
+			sn_flush_device_kernel = kzalloc(size, GFP_KERNEL);
+			if (!sn_flush_device_kernel)
+				BUG();
+
+			dev_entry = sn_flush_device_kernel;
+			for (device = 0; device < DEV_PER_WIDGET;
+			     device++,dev_entry++) {
+				size = sizeof(struct sn_flush_device_common);
+				dev_entry->common = kzalloc(size, GFP_KERNEL);
+				if (!dev_entry->common)
+					BUG();
+
+				if (sn_prom_feature_available(
+						       PRF_DEVICE_FLUSH_LIST))
+					status = sal_get_device_dmaflush_list(
+						     nasid, widget, device,
+						     (u64)(dev_entry->common));
+				else
+					status = sn_device_fixup_war(nasid,
+						     widget, device,
+						     dev_entry->common);
+				if (status != SALRET_OK)
+					panic("SAL call failed: %s\n",
+					      ia64_sal_strerror(status));
@@ -241,4 +289,2 @@
-			spin_lock_init(&sn_flush_device_list->sfdl_flush_lock);
-			hubdev->hdi_flush_nasid_list.widget_p[widget] =
-			    sn_flush_device_list;
-		}
+				spin_lock_init(&dev_entry->sfdl_flush_lock);
+			}
@@ -245,0 +292,4 @@
+			if (sn_flush_device_kernel)
+				hubdev->hdi_flush_nasid_list.widget_p[widget] =
+						       sn_flush_device_kernel;
+	        }
@@ -247 +296,0 @@
-
@@ -259 +308 @@
-		    int64_t * pci_addrs)
+		    s64 * pci_addrs)
@@ -319 +368 @@
-	int64_t pci_addrs[PCI_ROM_RESOURCE + 1];
+	s64 pci_addrs[PCI_ROM_RESOURCE + 1];
@@ -326 +375 @@
-	if (pcidev_info <= 0)
+	if (!pcidev_info)
@@ -329,2 +378,2 @@
-	sn_irq_info = kmalloc(sizeof(struct sn_irq_info), GFP_KERNEL);
-	if (sn_irq_info <= 0)
+	sn_irq_info = kzalloc(sizeof(struct sn_irq_info), GFP_KERNEL);
+	if (!sn_irq_info)
@@ -332 +380,0 @@
-	memset(sn_irq_info, 0, sizeof(struct sn_irq_info));
@@ -409,0 +458,7 @@
+
+	/*
+	 * MSI currently not supported on altix.  Remove this when
+	 * the MSI abstraction patches are integrated into the kernel
+	 * (sometime after 2.6.16 releases)
+	 */
+	dev->no_msi = 1;
@@ -418 +473 @@
-	int status = 0;
+	int status;
@@ -424 +479 @@
-	void *provider_soft = NULL;
+	void *provider_soft;
@@ -470,0 +526,2 @@
+	else
+		provider_soft = NULL;
@@ -553 +610 @@
-	struct list_head *list;
+	struct list_head *list, *safe;
@@ -555,2 +612 @@
-sn_sysdata_free_start:
-	list_for_each(list, &sn_sysdata_list) {
+	list_for_each_safe(list, safe, &sn_sysdata_list) {
@@ -558,0 +615,2 @@
+		list_del(&(((struct pcidev_info *)
+			     (element->sysdata))->pdi_list));
@@ -561 +618,0 @@
-		goto sn_sysdata_free_start;
@@ -574,2 +631 @@
-	int i = 0;
-	int j = 0;
+	int i, j;
@@ -577,4 +632,0 @@
-	extern void sn_init_cpei_timer(void);
-#ifdef CONFIG_PROC_FS
-	extern void register_sn_procfs(void);
-#endif
@@ -636 +687,0 @@
-
@@ -637,0 +689,4 @@
+	int size;
+	pg_data_t *pg;
+
+	size = sizeof(struct hubdev_info);
@@ -640,4 +695 @@
-		hubdev_info =
-		    (struct hubdev_info *)alloc_bootmem_node(NODE_DATA(0),
-							     sizeof(struct
-								    hubdev_info));
+		pg = NODE_DATA(0);
@@ -645,5 +697,3 @@
-		hubdev_info =
-		    (struct hubdev_info *)alloc_bootmem_node(NODE_DATA(node),
-							     sizeof(struct
-								    hubdev_info));
-	npda->pdinfo = (void *)hubdev_info;
+		pg = NODE_DATA(node);
+
+	hubdev_info = (struct hubdev_info *)alloc_bootmem_node(pg, size);
@@ -650,0 +701 @@
+	npda->pdinfo = (void *)hubdev_info;
@@ -656 +706,0 @@
-
@@ -661 +710,0 @@
-
--- ./projects/linux/linux-2.6.16/arch/ia64/sn/kernel/io_init.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/arch/ia64/sn/kernel/io_init.c	2006-06-18 03:49:35.000000000 +0200
@@ -15,0 +16,2 @@
+#include <asm/sn/l1.h>
+#include <asm/sn/module.h>
@@ -712,0 +715,26 @@
+void sn_generate_path(struct pci_bus *pci_bus, char *address)
+{
+	nasid_t nasid;
+	cnodeid_t cnode;
+	geoid_t geoid;
+	moduleid_t moduleid;
+	u16 bricktype;
+
+	nasid = NASID_GET(SN_PCIBUS_BUSSOFT(pci_bus)->bs_base);
+	cnode = nasid_to_cnodeid(nasid);
+	geoid = cnodeid_get_geoid(cnode);
+	moduleid = geo_module(geoid);
+
+	sprintf(address, "module_%c%c%c%c%.2d",
+		'0'+RACK_GET_CLASS(MODULE_GET_RACK(moduleid)),
+		'0'+RACK_GET_GROUP(MODULE_GET_RACK(moduleid)),
+		'0'+RACK_GET_NUM(MODULE_GET_RACK(moduleid)),
+		MODULE_GET_BTCHAR(moduleid), MODULE_GET_BPOS(moduleid));
+
+	/* Tollhouse requires slot id to be displayed */
+	bricktype = MODULE_GET_BTYPE(moduleid);
+	if ((bricktype == L1_BRICKTYPE_191010) ||
+	    (bricktype == L1_BRICKTYPE_1932))
+			sprintf(address, "%s^%d", address, geo_slot(geoid));
+}
+
@@ -718,0 +747 @@
+EXPORT_SYMBOL(sn_generate_path);
--- ./projects/linux/linux-2.6.17/arch/ia64/sn/kernel/io_init.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/ia64/sn/kernel/io_init.c	2006-09-20 05:42:06.000000000 +0200
@@ -61 +61 @@
-sn_default_pci_map(struct pci_dev *pdev, unsigned long paddr, size_t size)
+sn_default_pci_map(struct pci_dev *pdev, unsigned long paddr, size_t size, int type)
@@ -460,7 +459,0 @@
-
-	/*
-	 * MSI currently not supported on altix.  Remove this when
-	 * the MSI abstraction patches are integrated into the kernel
-	 * (sometime after 2.6.16 releases)
-	 */
-	dev->no_msi = 1;
--- ./projects/linux/linux-2.6.19/arch/ia64/sn/kernel/io_init.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/arch/ia64/sn/kernel/io_init.c	2007-02-04 19:44:54.000000000 +0100
@@ -6 +6 @@
- * Copyright (C) 1992 - 1997, 2000-2005 Silicon Graphics, Inc. All rights reserved.
+ * Copyright (C) 1992 - 1997, 2000-2006 Silicon Graphics, Inc. All rights reserved.
@@ -9,2 +8,0 @@
-#include <linux/bootmem.h>
-#include <linux/nodemask.h>
@@ -13,2 +10,0 @@
-#include <asm/sn/sn_feature_sets.h>
-#include <asm/sn/geo.h>
@@ -16 +11,0 @@
-#include <asm/sn/l1.h>
@@ -18 +13 @@
-#include <asm/sn/pcibr_provider.h>
+#include <asm/sn/intr.h>
@@ -21 +15,0 @@
-#include <asm/sn/simulator.h>
@@ -23,2 +16,0 @@
-#include <asm/sn/tioca_provider.h>
-#include <asm/sn/tioce_provider.h>
@@ -26,29 +17,0 @@
-#include "xtalk/xwidgetdev.h"
-
-
-extern void sn_init_cpei_timer(void);
-extern void register_sn_procfs(void);
-
-static struct list_head sn_sysdata_list;
-
-/* sysdata list struct */
-struct sysdata_el {
-	struct list_head entry;
-	void *sysdata;
-};
-
-struct slab_info {
-	struct hubdev_info hubdev;
-};
-
-struct brick {
-	moduleid_t id;		/* Module ID of this module        */
-	struct slab_info slab_info[MAX_SLABS + 1];
-};
-
-int sn_ioif_inited;		/* SN I/O infrastructure initialized? */
-
-struct sn_pcibus_provider *sn_pci_provider[PCIIO_ASIC_MAX_TYPES];	/* indexed by asic type */
-
-static int max_segment_number;		 /* Default highest segment number */
-static int max_pcibus_number = 255;	/* Default highest pci bus number */
@@ -57 +20,3 @@
- * Hooks and struct for unsupported pci providers
+ * The code in this file will only be executed when running with
+ * a PROM that does _not_ have base ACPI IO support.
+ * (i.e., SN_ACPI_BASE_SUPPORT() == 0)
@@ -60,36 +25,2 @@
-static dma_addr_t
-sn_default_pci_map(struct pci_dev *pdev, unsigned long paddr, size_t size, int type)
-{
-	return 0;
-}
-
-static void
-sn_default_pci_unmap(struct pci_dev *pdev, dma_addr_t addr, int direction)
-{
-	return;
-}
-
-static void *
-sn_default_pci_bus_fixup(struct pcibus_bussoft *soft, struct pci_controller *controller)
-{
-	return NULL;
-}
-
-static struct sn_pcibus_provider sn_pci_default_provider = {
-	.dma_map = sn_default_pci_map,
-	.dma_map_consistent = sn_default_pci_map,
-	.dma_unmap = sn_default_pci_unmap,
-	.bus_fixup = sn_default_pci_bus_fixup,
-};
-
-/*
- * Retrieve the DMA Flush List given nasid, widget, and device.
- * This list is needed to implement the WAR - Flush DMA data on PIO Reads.
- */
-static inline u64
-sal_get_device_dmaflush_list(u64 nasid, u64 widget_num, u64 device_num,
-			     u64 address)
-{
-	struct ia64_sal_retval ret_stuff;
-	ret_stuff.status = 0;
-	ret_stuff.v0 = 0;
+static int max_segment_number;		 /* Default highest segment number */
+static int max_pcibus_number = 255;	/* Default highest pci bus number */
@@ -97,6 +27,0 @@
-	SAL_CALL_NOLOCK(ret_stuff,
-			(u64) SN_SAL_IOIF_GET_DEVICE_DMAFLUSH_LIST,
-			(u64) nasid, (u64) widget_num,
-			(u64) device_num, (u64) address, 0, 0, 0);
-	return ret_stuff.status;
-}
@@ -134,18 +58,0 @@
-/*
- * Retrieve the pci device information given the bus and device|function number.
- */
-static inline u64
-sal_get_pcidev_info(u64 segment, u64 bus_number, u64 devfn, u64 pci_dev,
-		    u64 sn_irq_info)
-{
-	struct ia64_sal_retval ret_stuff;
-	ret_stuff.status = 0;
-	ret_stuff.v0 = 0;
-
-	SAL_CALL_NOLOCK(ret_stuff,
-			(u64) SN_SAL_IOIF_GET_PCIDEV_INFO,
-			(u64) segment, (u64) bus_number, (u64) devfn,
-			(u64) pci_dev,
-			sn_irq_info, 0, 0);
-	return ret_stuff.v0;
-}
@@ -154,58 +61,3 @@
- * sn_pcidev_info_get() - Retrieve the pcidev_info struct for the specified
- *			  device.
- */
-inline struct pcidev_info *
-sn_pcidev_info_get(struct pci_dev *dev)
-{
-	struct pcidev_info *pcidev;
-
-	list_for_each_entry(pcidev,
-			    &(SN_PCI_CONTROLLER(dev)->pcidev_info), pdi_list) {
-		if (pcidev->pdi_linux_pcidev == dev) {
-			return pcidev;
-		}
-	}
-	return NULL;
-}
-
-/* Older PROM flush WAR
- *
- * 01/16/06 -- This war will be in place until a new official PROM is released.
- * Additionally note that the struct sn_flush_device_war also has to be
- * removed from arch/ia64/sn/include/xtalk/hubdev.h
- */
-static u8 war_implemented = 0;
-
-static s64 sn_device_fixup_war(u64 nasid, u64 widget, int device,
-			       struct sn_flush_device_common *common)
-{
-	struct sn_flush_device_war *war_list;
-	struct sn_flush_device_war *dev_entry;
-	struct ia64_sal_retval isrv = {0,0,0,0};
-
-	if (!war_implemented) {
-		printk(KERN_WARNING "PROM version < 4.50 -- implementing old "
-		       "PROM flush WAR\n");
-		war_implemented = 1;
-	}
-
-	war_list = kzalloc(DEV_PER_WIDGET * sizeof(*war_list), GFP_KERNEL);
-	if (!war_list)
-		BUG();
-
-	SAL_CALL_NOLOCK(isrv, SN_SAL_IOIF_GET_WIDGET_DMAFLUSH_LIST,
-			nasid, widget, __pa(war_list), 0, 0, 0 ,0);
-	if (isrv.status)
-		panic("sn_device_fixup_war failed: %s\n",
-		      ia64_sal_strerror(isrv.status));
-
-	dev_entry = war_list + device;
-	memcpy(common,dev_entry, sizeof(*common));
-	kfree(war_list);
-
-	return isrv.status;
-}
-
-/*
- * sn_fixup_ionodes() - This routine initializes the HUB data strcuture for
- *	each node in the system.
+ * sn_fixup_ionodes() - This routine initializes the HUB data structure for
+ *			each node in the system. This function is only
+ *			executed when running with a non-ACPI capable PROM.
@@ -215,2 +67 @@
-	struct sn_flush_device_kernel *sn_flush_device_kernel;
-	struct sn_flush_device_kernel *dev_entry;
+
@@ -220 +71,2 @@
-	int i, widget, device, size;
+	int i;
+	extern void sn_common_hubdev_init(struct hubdev_info *);
@@ -242,0 +95,3 @@
+		sn_common_hubdev_init(hubdev);
+	}
+}
@@ -244,17 +99,14 @@
-		/* Attach the error interrupt handlers */
-		if (nasid & 1)
-			ice_error_init(hubdev);
-		else
-			hub_error_init(hubdev);
-
-		for (widget = 0; widget <= HUB_WIDGET_ID_MAX; widget++)
-			hubdev->hdi_xwidget_info[widget].xwi_hubinfo = hubdev;
-
-		if (!hubdev->hdi_flush_nasid_list.widget_p)
-			continue;
-
-		size = (HUB_WIDGET_ID_MAX + 1) *
-			sizeof(struct sn_flush_device_kernel *);
-		hubdev->hdi_flush_nasid_list.widget_p =
-			kzalloc(size, GFP_KERNEL);
-		if (!hubdev->hdi_flush_nasid_list.widget_p)
+/*
+ * sn_pci_legacy_window_fixup - Create PCI controller windows for
+ *				legacy IO and MEM space. This needs to
+ *				be done here, as the PROM does not have
+ *				ACPI support defining the root buses
+ *				and their resources (_CRS),
+ */
+static void
+sn_legacy_pci_window_fixup(struct pci_controller *controller,
+			   u64 legacy_io, u64 legacy_mem)
+{
+		controller->window = kcalloc(2, sizeof(struct pci_window),
+					     GFP_KERNEL);
+		if (controller->window == NULL)
@@ -262,37 +114,15 @@
-
-		for (widget = 0; widget <= HUB_WIDGET_ID_MAX; widget++) {
-			size = DEV_PER_WIDGET *
-				sizeof(struct sn_flush_device_kernel);
-			sn_flush_device_kernel = kzalloc(size, GFP_KERNEL);
-			if (!sn_flush_device_kernel)
-				BUG();
-
-			dev_entry = sn_flush_device_kernel;
-			for (device = 0; device < DEV_PER_WIDGET;
-			     device++,dev_entry++) {
-				size = sizeof(struct sn_flush_device_common);
-				dev_entry->common = kzalloc(size, GFP_KERNEL);
-				if (!dev_entry->common)
-					BUG();
-
-				if (sn_prom_feature_available(
-						       PRF_DEVICE_FLUSH_LIST))
-					status = sal_get_device_dmaflush_list(
-						     nasid, widget, device,
-						     (u64)(dev_entry->common));
-				else
-					status = sn_device_fixup_war(nasid,
-						     widget, device,
-						     dev_entry->common);
-				if (status != SALRET_OK)
-					panic("SAL call failed: %s\n",
-					      ia64_sal_strerror(status));
-
-				spin_lock_init(&dev_entry->sfdl_flush_lock);
-			}
-
-			if (sn_flush_device_kernel)
-				hubdev->hdi_flush_nasid_list.widget_p[widget] =
-						       sn_flush_device_kernel;
-	        }
-	}
+		controller->window[0].offset = legacy_io;
+		controller->window[0].resource.name = "legacy_io";
+		controller->window[0].resource.flags = IORESOURCE_IO;
+		controller->window[0].resource.start = legacy_io;
+		controller->window[0].resource.end =
+	    			controller->window[0].resource.start + 0xffff;
+		controller->window[0].resource.parent = &ioport_resource;
+		controller->window[1].offset = legacy_mem;
+		controller->window[1].resource.name = "legacy_mem";
+		controller->window[1].resource.flags = IORESOURCE_MEM;
+		controller->window[1].resource.start = legacy_mem;
+		controller->window[1].resource.end =
+	    	       controller->window[1].resource.start + (1024 * 1024) - 1;
+		controller->window[1].resource.parent = &iomem_resource;
+		controller->windows = 2;
@@ -303,4 +133,3 @@
- *			   Until ACPI support is added, we need this code
- *			   to setup pci_windows for use by
- *			   pcibios_bus_to_resource(),
- *			   pcibios_resource_to_bus(), etc.
+ *			   It will setup pci_windows for use by
+ *			   pcibios_bus_to_resource(), pcibios_resource_to_bus(),
+ *			   etc.
@@ -345,9 +173,0 @@
-void sn_pci_unfixup_slot(struct pci_dev *dev)
-{
-	struct pci_dev *host_pci_dev = SN_PCIDEV_INFO(dev)->host_pci_dev;
-
-	sn_irq_unfixup(dev);
-	pci_dev_put(host_pci_dev);
-	pci_dev_put(dev);
-}
-
@@ -355,4 +175,4 @@
- * sn_pci_fixup_slot() - This routine sets up a slot's resources
- * consistent with the Linux PCI abstraction layer.  Resources acquired
- * from our PCI provider include PIO maps to BAR space and interrupt
- * objects.
+ * sn_more_slot_fixup() - We are not running with an ACPI capable PROM,
+ *			  and need to convert the pci_dev->resource
+ *			  'start' and 'end' addresses to mapped addresses,
+ *			  and setup the pci_controller->window array entries.
@@ -360 +180,2 @@
-void sn_pci_fixup_slot(struct pci_dev *dev)
+void
+sn_more_slot_fixup(struct pci_dev *dev, struct pcidev_info *pcidev_info)
@@ -364,6 +184,0 @@
-	int segment = pci_domain_nr(dev->bus);
-	int status = 0;
-	struct pcibus_bussoft *bs;
- 	struct pci_bus *host_pci_bus;
- 	struct pci_dev *host_pci_dev;
-	struct pcidev_info *pcidev_info;
@@ -371,24 +186 @@
- 	struct sn_irq_info *sn_irq_info;
- 	unsigned long size;
- 	unsigned int bus_no, devfn;
-
-	pci_dev_get(dev); /* for the sysdata pointer */
-	pcidev_info = kzalloc(sizeof(struct pcidev_info), GFP_KERNEL);
-	if (!pcidev_info)
-		BUG();		/* Cannot afford to run out of memory */
-
-	sn_irq_info = kzalloc(sizeof(struct sn_irq_info), GFP_KERNEL);
-	if (!sn_irq_info)
-		BUG();		/* Cannot afford to run out of memory */
-
-	/* Call to retrieve pci device information needed by kernel. */
-	status = sal_get_pcidev_info((u64) segment, (u64) dev->bus->number, 
-				     dev->devfn,
-				     (u64) __pa(pcidev_info),
-				     (u64) __pa(sn_irq_info));
-	if (status)
-		BUG(); /* Cannot get platform pci device information */
-
-	/* Add pcidev_info to list in sn_pci_controller struct */
-	list_add_tail(&pcidev_info->pdi_list,
-		      &(SN_PCI_CONTROLLER(dev->bus)->pcidev_info));
+	unsigned long addr, end, size, start;
@@ -398 +189,0 @@
-		unsigned long start, end, addr;
@@ -421,0 +213,3 @@
+		/* If ROM, mark as shadowed in PROM */
+		if (idx == PCI_ROM_RESOURCE)
+			dev->resource[idx].flags |= IORESOURCE_ROM_BIOS_COPY;
@@ -428,32 +221,0 @@
-
-	/*
-	 * Using the PROMs values for the PCI host bus, get the Linux
- 	 * PCI host_pci_dev struct and set up host bus linkages
- 	 */
-
-	bus_no = (pcidev_info->pdi_slot_host_handle >> 32) & 0xff;
-	devfn = pcidev_info->pdi_slot_host_handle & 0xffffffff;
- 	host_pci_bus = pci_find_bus(segment, bus_no);
- 	host_pci_dev = pci_get_slot(host_pci_bus, devfn);
-
-	pcidev_info->host_pci_dev = host_pci_dev;
-	pcidev_info->pdi_linux_pcidev = dev;
-	pcidev_info->pdi_host_pcidev_info = SN_PCIDEV_INFO(host_pci_dev);
-	bs = SN_PCIBUS_BUSSOFT(dev->bus);
-	pcidev_info->pdi_pcibus_info = bs;
-
-	if (bs && bs->bs_asic_type < PCIIO_ASIC_MAX_TYPES) {
-		SN_PCIDEV_BUSPROVIDER(dev) = sn_pci_provider[bs->bs_asic_type];
-	} else {
-		SN_PCIDEV_BUSPROVIDER(dev) = &sn_pci_default_provider;
-	}
-
-	/* Only set up IRQ stuff if this device has a host bus context */
-	if (bs && sn_irq_info->irq_irq) {
-		pcidev_info->pdi_sn_irq_info = sn_irq_info;
-		dev->irq = pcidev_info->pdi_sn_irq_info->irq_irq;
-		sn_irq_fixup(dev, sn_irq_info);
-	} else {
-		pcidev_info->pdi_sn_irq_info = NULL;
-		kfree(sn_irq_info);
-	}
@@ -464 +226 @@
- * consistent with the Linux PCI abstraction layer.
+ *			       consistent with the Linux PCI abstraction layer.
@@ -466 +228,2 @@
-void sn_pci_controller_fixup(int segment, int busnum, struct pci_bus *bus)
+static void
+sn_pci_controller_fixup(int segment, int busnum, struct pci_bus *bus)
@@ -468,2 +231 @@
-	int status;
-	int nasid, cnode;
+	s64 status = 0;
@@ -471 +232,0 @@
-	struct sn_pci_controller *sn_controller;
@@ -473,3 +234 @@
-	struct hubdev_info *hubdev_info;
-	void *provider_soft;
-	struct sn_pcibus_provider *provider;
+
@@ -483,5 +242,2 @@
-	/* Allocate a sn_pci_controller, which has a pci_controller struct
-	 * as the first member.
-	 */
-	sn_controller = kzalloc(sizeof(struct sn_pci_controller), GFP_KERNEL);
-	if (!sn_controller)
+	controller = kzalloc(sizeof(*controller), GFP_KERNEL);
+	if (!controller)
@@ -489,2 +244,0 @@
-	INIT_LIST_HEAD(&sn_controller->pcidev_info);
-	controller = &sn_controller->pci_controller;
@@ -493,10 +246,0 @@
-	if (bus == NULL) {
- 		bus = pci_scan_bus(busnum, &pci_root_ops, controller);
- 		if (bus == NULL)
- 			goto error_return; /* error, or bus already scanned */
- 		bus->sysdata = NULL;
-	}
-
-	if (bus->sysdata)
-		goto error_return; /* sysdata already alloc'd */
-
@@ -504,2 +248,2 @@
-	 * Per-provider fixup.  Copies the contents from prom to local
-	 * area and links SN_PCIBUS_BUSSOFT().
+	 * Temporarily save the prom_bussoft_ptr for use by sn_bus_fixup().
+	 * (platform_data will be overwritten later in sn_common_bus_fixup())
@@ -506,0 +251 @@
+	controller->platform_data = prom_bussoft_ptr;
@@ -508,9 +253,3 @@
-	if (prom_bussoft_ptr->bs_asic_type >= PCIIO_ASIC_MAX_TYPES)
-		goto error_return; /* unsupported asic type */
-
-	if (prom_bussoft_ptr->bs_asic_type == PCIIO_ASIC_TYPE_PPB)
-		goto error_return; /* no further fixup necessary */
-
-	provider = sn_pci_provider[prom_bussoft_ptr->bs_asic_type];
-	if (provider == NULL)
-		goto error_return; /* no provider registerd for this asic */
+	bus = pci_scan_bus(busnum, &pci_root_ops, controller);
+ 	if (bus == NULL)
+ 		goto error_return; /* error, or bus already scanned */
@@ -519,52 +257,0 @@
-	if (provider->bus_fixup)
-		provider_soft = (*provider->bus_fixup) (prom_bussoft_ptr, controller);
-	else
-		provider_soft = NULL;
-
-	if (provider_soft == NULL) {
-		/* fixup failed or not applicable */
-		bus->sysdata = NULL;
-		goto error_return;
-	}
-
-	/*
-	 * Setup pci_windows for legacy IO and MEM space.
-	 * (Temporary until ACPI support is in place.)
-	 */
-	controller->window = kcalloc(2, sizeof(struct pci_window), GFP_KERNEL);
-	if (controller->window == NULL)
-		BUG();
-	controller->window[0].offset = prom_bussoft_ptr->bs_legacy_io;
-	controller->window[0].resource.name = "legacy_io";
-	controller->window[0].resource.flags = IORESOURCE_IO;
-	controller->window[0].resource.start = prom_bussoft_ptr->bs_legacy_io;
-	controller->window[0].resource.end =
-	    controller->window[0].resource.start + 0xffff;
-	controller->window[0].resource.parent = &ioport_resource;
-	controller->window[1].offset = prom_bussoft_ptr->bs_legacy_mem;
-	controller->window[1].resource.name = "legacy_mem";
-	controller->window[1].resource.flags = IORESOURCE_MEM;
-	controller->window[1].resource.start = prom_bussoft_ptr->bs_legacy_mem;
-	controller->window[1].resource.end =
-	    controller->window[1].resource.start + (1024 * 1024) - 1;
-	controller->window[1].resource.parent = &iomem_resource;
-	controller->windows = 2;
-
-	/*
-	 * Generic bus fixup goes here.  Don't reference prom_bussoft_ptr
-	 * after this point.
-	 */
-
-	PCI_CONTROLLER(bus)->platform_data = provider_soft;
-	nasid = NASID_GET(SN_PCIBUS_BUSSOFT(bus)->bs_base);
-	cnode = nasid_to_cnodeid(nasid);
-	hubdev_info = (struct hubdev_info *)(NODEPDA(cnode)->pdinfo);
-	SN_PCIBUS_BUSSOFT(bus)->bs_xwidget_info =
-	    &(hubdev_info->hdi_xwidget_info[SN_PCIBUS_BUSSOFT(bus)->bs_xid]);
-
-	/*
-	 * If the node information we obtained during the fixup phase is invalid
-	 * then set controller->node to -1 (undetermined)
-	 */
-	if (controller->node >= num_online_nodes()) {
-		struct pcibus_bussoft *b = SN_PCIBUS_BUSSOFT(bus);
@@ -572,9 +258,0 @@
-		printk(KERN_WARNING "Device ASIC=%u XID=%u PBUSNUM=%u"
-				    "L_IO=%lx L_MEM=%lx BASE=%lx\n",
-			b->bs_asic_type, b->bs_xid, b->bs_persist_busnum,
-			b->bs_legacy_io, b->bs_legacy_mem, b->bs_base);
-		printk(KERN_WARNING "on node %d but only %d nodes online."
-			"Association set to undetermined.\n",
-			controller->node, num_online_nodes());
-		controller->node = -1;
-	}
@@ -585 +263 @@
-	kfree(sn_controller);
+	kfree(controller);
@@ -589 +267,5 @@
-void sn_bus_store_sysdata(struct pci_dev *dev)
+/*
+ * sn_bus_fixup
+ */
+void
+sn_bus_fixup(struct pci_bus *bus)
@@ -591 +273,4 @@
-	struct sysdata_el *element;
+	struct pci_dev *pci_dev = NULL;
+	struct pcibus_bussoft *prom_bussoft_ptr;
+	extern void sn_common_bus_fixup(struct pci_bus *,
+					struct pcibus_bussoft *);
@@ -593,8 +277,0 @@
-	element = kzalloc(sizeof(struct sysdata_el), GFP_KERNEL);
-	if (!element) {
-		dev_dbg(dev, "%s: out of memory!\n", __FUNCTION__);
-		return;
-	}
-	element->sysdata = SN_PCIDEV_INFO(dev);
-	list_add(&element->entry, &sn_sysdata_list);
-}
@@ -602,4 +279,17 @@
-void sn_bus_free_sysdata(void)
-{
-	struct sysdata_el *element;
-	struct list_head *list, *safe;
+	if (!bus->parent) {  /* If root bus */
+		prom_bussoft_ptr = PCI_CONTROLLER(bus)->platform_data;
+		if (prom_bussoft_ptr == NULL) {
+			printk(KERN_ERR
+			       "sn_bus_fixup: 0x%04x:0x%02x Unable to "
+			       "obtain prom_bussoft_ptr\n",
+			       pci_domain_nr(bus), bus->number);
+			return;
+		}
+		sn_common_bus_fixup(bus, prom_bussoft_ptr);
+		sn_legacy_pci_window_fixup(PCI_CONTROLLER(bus),
+					   prom_bussoft_ptr->bs_legacy_io,
+					   prom_bussoft_ptr->bs_legacy_mem);
+        }
+        list_for_each_entry(pci_dev, &bus->devices, bus_list) {
+                sn_pci_fixup_slot(pci_dev);
+        }
@@ -607,9 +296,0 @@
-	list_for_each_safe(list, safe, &sn_sysdata_list) {
-		element = list_entry(list, struct sysdata_el, entry);
-		list_del(&element->entry);
-		list_del(&(((struct pcidev_info *)
-			     (element->sysdata))->pdi_list));
-		kfree(element->sysdata);
-		kfree(element);
-	}
-	return;
@@ -619 +300,3 @@
- * Ugly hack to get PCI setup until we have a proper ACPI namespace.
+ * sn_io_init - PROM does not have ACPI support to define nodes or root buses,
+ *		so we need to do things the hard way, including initiating the
+ *		bus scanning ourselves.
@@ -622,3 +305 @@
-#define PCI_BUSES_TO_SCAN 256
-
-static int __init sn_pci_init(void)
+void __init sn_io_init(void)
@@ -627,12 +307,0 @@
-	struct pci_dev *pci_dev = NULL;
-
-	if (!ia64_platform_is("sn2") || IS_RUNNING_ON_FAKE_PROM())
-		return 0;
-
-	/*
-	 * prime sn_pci_provider[].  Individial provider init routines will
-	 * override their respective default entries.
-	 */
-
-	for (i = 0; i < PCIIO_ASIC_MAX_TYPES; i++)
-		sn_pci_provider[i] = &sn_pci_default_provider;
@@ -640,8 +308,0 @@
-	pcibr_init_provider();
-	tioca_init_provider();
-	tioce_init_provider();
-
-	/*
-	 * This is needed to avoid bounce limit checks in the blk layer
-	 */
-	ia64_max_iommu_merge_mask = ~PAGE_MASK;
@@ -649,7 +309,0 @@
-	sn_irq_lh_init();
-	INIT_LIST_HEAD(&sn_sysdata_list);
-	sn_init_cpei_timer();
-
-#ifdef CONFIG_PROC_FS
-	register_sn_procfs();
-#endif
@@ -661,14 +314,0 @@
-
-	/*
-	 * Generic Linux PCI Layer has created the pci_bus and pci_dev 
-	 * structures - time for us to add our SN PLatform specific 
-	 * information.
-	 */
-
-	while ((pci_dev =
-		pci_get_device(PCI_ANY_ID, PCI_ANY_ID, pci_dev)) != NULL)
-		sn_pci_fixup_slot(pci_dev);
-
-	sn_ioif_inited = 1;	/* sn I/O infrastructure now initialized */
-
-	return 0;
@@ -676,65 +315,0 @@
-
-/*
- * hubdev_init_node() - Creates the HUB data structure and link them to it's 
- *	own NODE specific data area.
- */
-void hubdev_init_node(nodepda_t * npda, cnodeid_t node)
-{
-	struct hubdev_info *hubdev_info;
-	int size;
-	pg_data_t *pg;
-
-	size = sizeof(struct hubdev_info);
-
-	if (node >= num_online_nodes())	/* Headless/memless IO nodes */
-		pg = NODE_DATA(0);
-	else
-		pg = NODE_DATA(node);
-
-	hubdev_info = (struct hubdev_info *)alloc_bootmem_node(pg, size);
-
-	npda->pdinfo = (void *)hubdev_info;
-}
-
-geoid_t
-cnodeid_get_geoid(cnodeid_t cnode)
-{
-	struct hubdev_info *hubdev;
-
-	hubdev = (struct hubdev_info *)(NODEPDA(cnode)->pdinfo);
-	return hubdev->hdi_geoid;
-}
-
-void sn_generate_path(struct pci_bus *pci_bus, char *address)
-{
-	nasid_t nasid;
-	cnodeid_t cnode;
-	geoid_t geoid;
-	moduleid_t moduleid;
-	u16 bricktype;
-
-	nasid = NASID_GET(SN_PCIBUS_BUSSOFT(pci_bus)->bs_base);
-	cnode = nasid_to_cnodeid(nasid);
-	geoid = cnodeid_get_geoid(cnode);
-	moduleid = geo_module(geoid);
-
-	sprintf(address, "module_%c%c%c%c%.2d",
-		'0'+RACK_GET_CLASS(MODULE_GET_RACK(moduleid)),
-		'0'+RACK_GET_GROUP(MODULE_GET_RACK(moduleid)),
-		'0'+RACK_GET_NUM(MODULE_GET_RACK(moduleid)),
-		MODULE_GET_BTCHAR(moduleid), MODULE_GET_BPOS(moduleid));
-
-	/* Tollhouse requires slot id to be displayed */
-	bricktype = MODULE_GET_BTYPE(moduleid);
-	if ((bricktype == L1_BRICKTYPE_191010) ||
-	    (bricktype == L1_BRICKTYPE_1932))
-			sprintf(address, "%s^%d", address, geo_slot(geoid));
-}
-
-subsys_initcall(sn_pci_init);
-EXPORT_SYMBOL(sn_pci_fixup_slot);
-EXPORT_SYMBOL(sn_pci_unfixup_slot);
-EXPORT_SYMBOL(sn_pci_controller_fixup);
-EXPORT_SYMBOL(sn_bus_store_sysdata);
-EXPORT_SYMBOL(sn_bus_free_sysdata);
-EXPORT_SYMBOL(sn_generate_path);
--- ./projects/linux/linux-2.6.20/arch/ia64/sn/kernel/io_init.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/arch/ia64/sn/kernel/io_init.c	2007-04-26 05:08:32.000000000 +0200
@@ -58,0 +59,19 @@
+/*
+ * Retrieve the pci device information given the bus and device|function number.
+ */
+static inline u64
+sal_get_pcidev_info(u64 segment, u64 bus_number, u64 devfn, u64 pci_dev,
+		    u64 sn_irq_info)
+{
+	struct ia64_sal_retval ret_stuff;
+	ret_stuff.status = 0;
+	ret_stuff.v0 = 0;
+
+	SAL_CALL_NOLOCK(ret_stuff,
+			(u64) SN_SAL_IOIF_GET_PCIDEV_INFO,
+			(u64) segment, (u64) bus_number, (u64) devfn,
+			(u64) pci_dev,
+			sn_irq_info, 0, 0);
+	return ret_stuff.v0;
+}
+
@@ -175 +194 @@
- * sn_more_slot_fixup() - We are not running with an ACPI capable PROM,
+ * sn_io_slot_fixup() -   We are not running with an ACPI capable PROM,
@@ -181 +200 @@
-sn_more_slot_fixup(struct pci_dev *dev, struct pcidev_info *pcidev_info)
+sn_io_slot_fixup(struct pci_dev *dev)
@@ -186,0 +206,22 @@
+	struct pcidev_info *pcidev_info;
+	struct sn_irq_info *sn_irq_info;
+	int status;
+
+	pcidev_info = kzalloc(sizeof(struct pcidev_info), GFP_KERNEL);
+	if (!pcidev_info)
+		panic("%s: Unable to alloc memory for pcidev_info", __FUNCTION__);
+
+	sn_irq_info = kzalloc(sizeof(struct sn_irq_info), GFP_KERNEL);
+	if (!sn_irq_info)
+		panic("%s: Unable to alloc memory for sn_irq_info", __FUNCTION__);
+
+	/* Call to retrieve pci device information needed by kernel. */
+	status = sal_get_pcidev_info((u64) pci_domain_nr(dev),
+		(u64) dev->bus->number,
+		dev->devfn,
+		(u64) __pa(pcidev_info),
+		(u64) __pa(sn_irq_info));
+
+	if (status)
+		BUG(); /* Cannot get platform pci device information */
+
@@ -208,0 +250,8 @@
+
+		/*
+		 * if it's already in the device structure, remove it before
+		 * inserting
+		 */
+		if (dev->resource[idx].parent && dev->resource[idx].parent->child)
+			release_resource(&dev->resource[idx]);
+
@@ -210 +259 @@
-			dev->resource[idx].parent = &ioport_resource;
+			insert_resource(&ioport_resource, &dev->resource[idx]);
@@ -212 +261 @@
-			dev->resource[idx].parent = &iomem_resource;
+			insert_resource(&iomem_resource, &dev->resource[idx]);
@@ -221,0 +271,2 @@
+
+	sn_pci_fixup_slot(dev, pcidev_info, sn_irq_info);
@@ -223,0 +275,2 @@
+EXPORT_SYMBOL(sn_io_slot_fixup);
+
@@ -275,3 +327,0 @@
-	extern void sn_common_bus_fixup(struct pci_bus *,
-					struct pcibus_bussoft *);
-
@@ -294 +344 @@
-                sn_pci_fixup_slot(pci_dev);
+                sn_io_slot_fixup(pci_dev);
--- ./projects/linux/linux-2.6.22/arch/ia64/sn/kernel/io_init.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/arch/ia64/sn/kernel/io_init.c	2007-10-09 22:31:38.000000000 +0200
@@ -262,3 +262,17 @@
-		/* If ROM, mark as shadowed in PROM */
-		if (idx == PCI_ROM_RESOURCE)
-			dev->resource[idx].flags |= IORESOURCE_ROM_BIOS_COPY;
+		/*
+		 * If ROM, set the actual ROM image size, and mark as
+		 * shadowed in PROM.
+		 */
+		if (idx == PCI_ROM_RESOURCE) {
+			size_t image_size;
+			void __iomem *rom;
+
+			rom = ioremap(pci_resource_start(dev, PCI_ROM_RESOURCE),
+				      size + 1);
+			image_size = pci_get_rom_size(rom, size + 1);
+			dev->resource[PCI_ROM_RESOURCE].end =
+				dev->resource[PCI_ROM_RESOURCE].start +
+				image_size - 1;
+			dev->resource[PCI_ROM_RESOURCE].flags |=
+						 IORESOURCE_ROM_BIOS_COPY;
+		}
--- ./projects/linux/linux-2.6.24/arch/ia64/sn/kernel/io_init.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/ia64/sn/kernel/io_init.c	2008-04-17 04:49:44.000000000 +0200
@@ -212 +212 @@
-		panic("%s: Unable to alloc memory for pcidev_info", __FUNCTION__);
+		panic("%s: Unable to alloc memory for pcidev_info", __func__);
@@ -216 +216 @@
-		panic("%s: Unable to alloc memory for sn_irq_info", __FUNCTION__);
+		panic("%s: Unable to alloc memory for sn_irq_info", __func__);
--- ./projects/linux/linux-2.6.27/arch/ia64/sn/kernel/io_init.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/arch/ia64/sn/kernel/io_init.c	2008-12-25 00:26:37.000000000 +0100
@@ -295 +295 @@
-static void
+static void __init
--- ./projects/linux/linux-2.6.28/arch/ia64/sn/kernel/io_init.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/arch/ia64/sn/kernel/io_init.c	2009-03-24 00:12:14.000000000 +0100
@@ -272 +272 @@
-			image_size = pci_get_rom_size(rom, size + 1);
+			image_size = pci_get_rom_size(dev, rom, size + 1);
--- ./projects/linux/linux-2.6.29/arch/ia64/sn/kernel/io_init.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/arch/ia64/sn/kernel/io_init.c	2009-06-27 11:32:31.000000000 +0200
@@ -131,2 +131 @@
-		if (controller->window == NULL)
-			BUG();
+		BUG_ON(controller->window == NULL);
@@ -171,2 +170 @@
-	if (new_window == NULL)
-		BUG();
+	BUG_ON(new_window == NULL);
@@ -225,2 +223 @@
-	if (status)
-		BUG(); /* Cannot get platform pci device information */
+	BUG_ON(status); /* Cannot get platform pci device information */
@@ -310,2 +307 @@
-	if (!controller)
-		BUG();
+	BUG_ON(!controller);
--- ./projects/linux/linux-2.6.13/arch/m32r/kernel/smp.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/arch/m32r/kernel/smp.c	2005-10-28 02:02:08.000000000 +0200
@@ -278 +278 @@
-	int cpu_id = smp_processor_id();
+	int cpu_id;
@@ -280 +280 @@
-	unsigned long *mmc = &mm->context[cpu_id];
+	unsigned long *mmc;
@@ -283,0 +284,2 @@
+	cpu_id = smp_processor_id();
+	mmc = &mm->context[cpu_id];
@@ -346 +348 @@
-	int cpu_id = smp_processor_id();
+	int cpu_id;
@@ -348 +350 @@
-	unsigned long *mmc = &mm->context[cpu_id];
+	unsigned long *mmc;
@@ -351,0 +354,2 @@
+	cpu_id = smp_processor_id();
+	mmc = &mm->context[cpu_id];
@@ -895 +898,0 @@
-	unsigned long flags = 0;
@@ -918,0 +922 @@
+	spin_lock(ipilock);
@@ -920 +924 @@
-		";; LOCK ipi_lock[i]		\n\t"
+		";; CHECK IPICRi == 0		\n\t"
@@ -923,13 +927,4 @@
-		"mvfc	%1, psw 		\n\t"
-		"clrpsw	#0x40 -> nop		\n\t"
-		DCACHE_CLEAR("r4", "r5", "%2")
-		"lock	r4, @%2			\n\t"
-		"addi	r4, #-1			\n\t"
-		"unlock	r4, @%2			\n\t"
-		"mvtc	%1, psw			\n\t"
-		"bnez	r4, 2f			\n\t"
-		LOCK_SECTION_START(".balign 4 \n\t")
-		".fillinsn			\n"
-		"2:				\n\t"
-		"ld	r4, @%2			\n\t"
-		"blez	r4, 2b			\n\t"
+		"ld	%0, @%1			\n\t"
+		"and	%0, %4			\n\t"
+		"beqz	%0, 2f			\n\t"
+		"bnez	%3, 3f			\n\t"
@@ -937,9 +931,0 @@
-		LOCK_SECTION_END
-		";; CHECK IPICRi == 0		\n\t"
-		".fillinsn			\n"
-		"3:				\n\t"
-		"ld	%0, @%3			\n\t"
-		"and	%0, %6			\n\t"
-		"beqz	%0, 4f			\n\t"
-		"bnez	%5, 5f			\n\t"
-		"bra	3b			\n\t"
@@ -948,3 +934,2 @@
-		"4:				\n\t"
-		"st	%4, @%3			\n\t"
-		";; UNLOCK ipi_lock[i]		\n\t"
+		"2:				\n\t"
+		"st	%2, @%1			\n\t"
@@ -952,3 +937 @@
-		"5:				\n\t"
-		"ldi	r4, #1			\n\t"
-		"st	r4, @%2			\n\t"
+		"3:				\n\t"
@@ -956,6 +939,2 @@
-		: "r"(flags), "r"(&ipilock->slock), "r"(ipicr_addr),
-		  "r"(mask), "r"(try), "r"(my_physid_mask)
-		: "memory", "r4"
-#ifdef CONFIG_CHIP_M32700_TS1
-		, "r5"
-#endif	/* CONFIG_CHIP_M32700_TS1 */
+		: "r"(ipicr_addr), "r"(mask), "r"(try), "r"(my_physid_mask)
+		: "memory"
@@ -962,0 +942 @@
+	spin_unlock(ipilock);
--- ./projects/linux/linux-2.6.18/arch/m32r/kernel/smp.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/m32r/kernel/smp.c	2006-11-29 22:57:37.000000000 +0100
@@ -104 +104 @@
-void smp_local_timer_interrupt(struct pt_regs *);
+void smp_local_timer_interrupt(void);
@@ -234 +234 @@
-	smp_call_function(flush_tlb_all_ipi, 0, 1, 1);
+	smp_call_function(flush_tlb_all_ipi, NULL, 1, 1);
@@ -736,0 +737,2 @@
+	struct pt_regs *old_regs;
+	old_regs = set_irq_regs(regs);
@@ -738 +740 @@
-	smp_local_timer_interrupt(regs);
+	smp_local_timer_interrupt();
@@ -739,0 +742 @@
+	set_irq_regs(old_regs);
@@ -765 +768 @@
-void smp_local_timer_interrupt(struct pt_regs *regs)
+void smp_local_timer_interrupt(void)
@@ -767 +770 @@
-	int user = user_mode(regs);
+	int user = user_mode(get_irq_regs());
@@ -777 +780 @@
-	profile_tick(CPU_PROFILING, regs);
+	profile_tick(CPU_PROFILING);
--- ./projects/linux/linux-2.6.23/arch/m32r/kernel/smp.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/arch/m32r/kernel/smp.c	2008-01-24 23:58:37.000000000 +0100
@@ -205 +205 @@
-/* TLB flush request Routins                                                 */
+/* TLB flush request Routines                                                */
@@ -381 +381 @@
- *               1.Setup parmeters.
+ *               1.Setup parameters.
@@ -505 +505 @@
-/* Stop CPU request Routins                                                 */
+/* Stop CPU request Routines                                                 */
@@ -569 +569 @@
-/* Call function Routins                                                     */
+/* Call function Routines                                                    */
@@ -693 +693 @@
-/* Timer Routins                                                             */
+/* Timer Routines                                                            */
@@ -805 +805 @@
-/* Send IPI Routins                                                          */
+/* Send IPI Routines                                                         */
@@ -817 +817 @@
- *                     !0 : The following IPI is not sended when Target CPU
+ *                     !0 : The following IPI is not sent when Target CPU
@@ -847 +847 @@
- *                     !0 : The following IPI is not sended when Target CPU
+ *                     !0 : The following IPI is not sent when Target CPU
@@ -888 +888 @@
- *                     !0 : The following IPI is not sended when Target CPU
+ *                     !0 : The following IPI is not sent when Target CPU
--- ./projects/linux/linux-2.6.26/arch/m32r/kernel/smp.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/arch/m32r/kernel/smp.c	2008-10-10 00:13:53.000000000 +0200
@@ -38,16 +37,0 @@
- * Structure and data for smp_call_function(). This is designed to minimise
- * static memory requirements. It also looks cleaner.
- */
-static DEFINE_SPINLOCK(call_lock);
-
-struct call_data_struct {
-	void (*func) (void *info);
-	void *info;
-	atomic_t started;
-	atomic_t finished;
-	int wait;
-} __attribute__ ((__aligned__(SMP_CACHE_BYTES)));
-
-static struct call_data_struct *call_data;
-
-/*
@@ -99,3 +82,0 @@
-int smp_call_function(void (*) (void *), void *, int, int);
-void smp_call_function_interrupt(void);
-
@@ -106 +87 @@
-void send_IPI_allbutself(int, int);
+static void send_IPI_allbutself(int, int);
@@ -234 +215 @@
-	smp_call_function(flush_tlb_all_ipi, NULL, 1, 1);
+	smp_call_function(flush_tlb_all_ipi, NULL, 1);
@@ -527 +508 @@
-	smp_call_function(stop_this_cpu, NULL, 1, 0);
+	smp_call_function(stop_this_cpu, NULL, 0);
@@ -568,34 +549 @@
-/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
-/* Call function Routines                                                    */
-/*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*/
-
-/*==========================================================================*
- * Name:         smp_call_function
- *
- * Description:  This routine sends a 'CALL_FUNCTION_IPI' to all other CPUs
- *               in the system.
- *
- * Born on Date: 2002.02.05
- *
- * Arguments:    *func - The function to run. This must be fast and
- *                       non-blocking.
- *               *info - An arbitrary pointer to pass to the function.
- *               nonatomic - currently unused.
- *               wait - If true, wait (atomically) until function has
- *                      completed on other CPUs.
- *
- * Returns:      0 on success, else a negative status code. Does not return
- *               until remote CPUs are nearly ready to execute <<func>> or
- *               are or have executed.
- *
- * Cautions:     You must not call this function with disabled interrupts or
- *               from a hardware interrupt handler, you may call it from a
- *               bottom half handler.
- *
- * Modification log:
- * Date       Who Description
- * ---------- --- --------------------------------------------------------
- *
- *==========================================================================*/
-int smp_call_function(void (*func) (void *info), void *info, int nonatomic,
-	int wait)
+void arch_send_call_function_ipi(cpumask_t mask)
@@ -603,43 +551,2 @@
-	struct call_data_struct data;
-	int cpus;
-
-#ifdef DEBUG_SMP
-	unsigned long flags;
-	__save_flags(flags);
-	if (!(flags & 0x0040))	/* Interrupt Disable NONONO */
-		BUG();
-#endif /* DEBUG_SMP */
-
-	/* Holding any lock stops cpus from going down. */
-	spin_lock(&call_lock);
-	cpus = num_online_cpus() - 1;
-
-	if (!cpus) {
-		spin_unlock(&call_lock);
-		return 0;
-	}
-
-	/* Can deadlock when called with interrupts disabled */
-	WARN_ON(irqs_disabled());
-
-	data.func = func;
-	data.info = info;
-	atomic_set(&data.started, 0);
-	data.wait = wait;
-	if (wait)
-		atomic_set(&data.finished, 0);
-
-	call_data = &data;
-	mb();
-
-	/* Send a message to all other CPUs and wait for them to respond */
-	send_IPI_allbutself(CALL_FUNCTION_IPI, 0);
-
-	/* Wait for response */
-	while (atomic_read(&data.started) != cpus)
-		barrier();
-
-	if (wait)
-		while (atomic_read(&data.finished) != cpus)
-			barrier();
-	spin_unlock(&call_lock);
+	send_IPI_mask(mask, CALL_FUNCTION_IPI, 0);
+}
@@ -647 +554,3 @@
-	return 0;
+void arch_send_call_function_single_ipi(int cpu)
+{
+	send_IPI_mask(cpumask_of_cpu(cpu), CALL_FUNC_SINGLE_IPI, 0);
@@ -669,13 +577,0 @@
-	void (*func) (void *info) = call_data->func;
-	void *info = call_data->info;
-	int wait = call_data->wait;
-
-	/*
-	 * Notify initiating CPU that I've grabbed the data and am
-	 * about to execute the function
-	 */
-	mb();
-	atomic_inc(&call_data->started);
-	/*
-	 * At this point the info structure may be out of scope unless wait==1
-	 */
@@ -683 +579 @@
-	(*func)(info);
+	generic_smp_call_function_interrupt();
@@ -684,0 +581 @@
+}
@@ -686,4 +583,5 @@
-	if (wait) {
-		mb();
-		atomic_inc(&call_data->finished);
-	}
+void smp_call_function_single_interrupt(void)
+{
+	irq_enter();
+	generic_smp_call_function_single_interrupt();
+	irq_exit();
@@ -827 +725 @@
-void send_IPI_allbutself(int ipi_num, int try)
+static void send_IPI_allbutself(int ipi_num, int try)
--- ./projects/linux/linux-2.6.23/arch/powerpc/boot/prpmc2800.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/arch/powerpc/boot/prpmc2800.c	2008-01-24 23:58:37.000000000 +0100
@@ -24,6 +23,0 @@
-extern char _end[];
-extern char _vmlinux_start[], _vmlinux_end[];
-extern char _dtb_start[], _dtb_end[];
-
-extern void udelay(long delay);
-
--- ./projects/linux/linux-2.6.24/arch/powerpc/boot/prpmc2800.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/powerpc/boot/prpmc2800.c	2008-04-17 04:49:44.000000000 +0200
@@ -550,2 +550 @@
-	if (ft_init(dtb, dt_size, 16))
-		exit();
+	fdt_init(dtb);
--- ./projects/linux/linux-2.6.25/arch/powerpc/boot/prpmc2800.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/arch/powerpc/boot/prpmc2800.c	2008-07-13 23:51:29.000000000 +0200
@@ -347 +347 @@
-	devp = finddevice("/mv64x60/pci@80000000");
+	devp = find_node_by_compatible(NULL, "marvell,mv64360-pci");
@@ -349 +349 @@
-		fatal("Error: Missing /mv64x60/pci@80000000"
+		fatal("Error: Missing marvell,mv64360-pci"
@@ -354 +354 @@
-		fatal("Error: Can't find /mv64x60/pci@80000000/ranges"
+		fatal("Error: Can't find marvell,mv64360-pci ranges"
@@ -358 +358 @@
-	devp = finddevice("/mv64x60");
+	devp = find_node_by_compatible(NULL, "marvell,mv64360");
@@ -360 +360 @@
-		fatal("Error: Missing /mv64x60 device tree node\n\r");
+		fatal("Error: Missing marvell,mv64360 device tree node\n\r");
@@ -432 +432 @@
-	devp = finddevice("/cpus/PowerPC,7447");
+	devp = find_node_by_prop_value_str(NULL, "device_type", "cpu");
@@ -434 +434 @@
-		fatal("Error: Missing proper /cpus device tree node\n\r");
+		fatal("Error: Missing proper cpu device tree node\n\r");
@@ -446 +446 @@
-	/* Update /mv64x60/model, if this is a mv64362 */
+	/* Update model, if this is a mv64362 */
@@ -448 +448 @@
-		devp = finddevice("/mv64x60");
+		devp = find_node_by_compatible(NULL, "marvell,mv64360");
@@ -450 +450,2 @@
-			fatal("Error: Missing /mv64x60 device tree node\n\r");
+			fatal("Error: Missing marvell,mv64360"
+					" device tree node\n\r");
@@ -455 +456 @@
-	devp = finddevice("/mv64x60/flash@a0000000");
+	devp = find_node_by_compatible(NULL, "direct-mapped");
--- ./projects/linux/linux-2.6.15/arch/powerpc/kernel/ptrace.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/arch/powerpc/kernel/ptrace.c	2006-03-20 06:53:29.000000000 +0100
@@ -564,4 +564 @@
-#ifdef CONFIG_PPC64
-	     || test_thread_flag(TIF_SINGLESTEP)
-#endif
-	     )
+	     || test_thread_flag(TIF_SINGLESTEP))
--- ./projects/linux/linux-2.6.16/arch/powerpc/kernel/ptrace.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/arch/powerpc/kernel/ptrace.c	2006-06-18 03:49:35.000000000 +0200
@@ -541 +541 @@
-		audit_syscall_entry(current,
+		audit_syscall_entry(
@@ -559,2 +559 @@
-		audit_syscall_exit(current,
-				   (regs->ccr&0x1000)?AUDITSC_FAILURE:AUDITSC_SUCCESS,
+		audit_syscall_exit((regs->ccr&0x1000)?AUDITSC_FAILURE:AUDITSC_SUCCESS,
--- ./projects/linux/linux-2.6.17/arch/powerpc/kernel/ptrace.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/powerpc/kernel/ptrace.c	2006-09-20 05:42:06.000000000 +0200
@@ -18 +17,0 @@
-#include <linux/config.h>
@@ -407 +405,0 @@
-#ifdef CONFIG_PPC64
@@ -471 +468,0 @@
-#endif /* CONFIG_PPC64 */
--- ./projects/linux/linux-2.6.18/arch/powerpc/kernel/ptrace.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/powerpc/kernel/ptrace.c	2006-11-29 22:57:37.000000000 +0100
@@ -529 +528,0 @@
-#ifdef CONFIG_PPC64
@@ -531 +529,0 @@
-#endif
@@ -551,4 +548,0 @@
-#ifdef CONFIG_PPC32
-	secure_computing(regs->gpr[0]);
-#endif
-
@@ -556 +550 @@
-		audit_syscall_exit((regs->ccr&0x1000)?AUDITSC_FAILURE:AUDITSC_SUCCESS,
+		audit_syscall_exit((regs->ccr&0x10000000)?AUDITSC_FAILURE:AUDITSC_SUCCESS,
@@ -564,5 +557,0 @@
-
-#ifdef CONFIG_PPC32
-EXPORT_SYMBOL(do_syscall_trace_enter);
-EXPORT_SYMBOL(do_syscall_trace_leave);
-#endif
--- ./projects/linux/linux-2.6.20/arch/powerpc/kernel/ptrace.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/arch/powerpc/kernel/ptrace.c	2007-04-26 05:08:32.000000000 +0200
@@ -535,6 +535,8 @@
-	if (unlikely(current->audit_context))
-		audit_syscall_entry(
-#ifdef CONFIG_PPC32
-				    AUDIT_ARCH_PPC,
-#else
-				    test_thread_flag(TIF_32BIT)?AUDIT_ARCH_PPC:AUDIT_ARCH_PPC64,
+	if (unlikely(current->audit_context)) {
+#ifdef CONFIG_PPC64
+		if (!test_thread_flag(TIF_32BIT))
+			audit_syscall_entry(AUDIT_ARCH_PPC64,
+					    regs->gpr[0],
+					    regs->gpr[3], regs->gpr[4],
+					    regs->gpr[5], regs->gpr[6]);
+		else
@@ -542,3 +544,7 @@
-				    regs->gpr[0],
-				    regs->gpr[3], regs->gpr[4],
-				    regs->gpr[5], regs->gpr[6]);
+			audit_syscall_entry(AUDIT_ARCH_PPC,
+					    regs->gpr[0],
+					    regs->gpr[3] & 0xffffffff,
+					    regs->gpr[4] & 0xffffffff,
+					    regs->gpr[5] & 0xffffffff,
+					    regs->gpr[6] & 0xffffffff);
+	}
--- ./projects/linux/linux-2.6.21/arch/powerpc/kernel/ptrace.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/arch/powerpc/kernel/ptrace.c	2007-07-09 01:32:17.000000000 +0200
@@ -22 +21,0 @@
-#include <linux/smp_lock.h>
@@ -221,0 +221 @@
+	set_tsk_thread_flag(task, TIF_SINGLESTEP);
@@ -236,0 +237 @@
+	clear_tsk_thread_flag(task, TIF_SINGLESTEP);
--- ./projects/linux/linux-2.6.22/arch/powerpc/kernel/ptrace.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/arch/powerpc/kernel/ptrace.c	2007-10-09 22:31:38.000000000 +0200
@@ -38,3 +38,4 @@
-#ifdef CONFIG_PPC64
-#include "ptrace-common.h"
-#endif
+/*
+ * does not yet catch signals sent when the child dies.
+ * in exit.c or in signal.c.
+ */
@@ -42 +42,0 @@
-#ifdef CONFIG_PPC32
@@ -51 +50,0 @@
-#endif /* CONFIG_PPC32 */
@@ -54,2 +53 @@
- * does not yet catch signals sent when the child dies.
- * in exit.c or in signal.c.
+ * Max register writeable via put_reg
@@ -57 +54,0 @@
-
@@ -58,0 +56,5 @@
+#define PT_MAX_PUT_REG	PT_MQ
+#else
+#define PT_MAX_PUT_REG	PT_CCR
+#endif
+
@@ -62 +64 @@
-static inline unsigned long get_reg(struct task_struct *task, int regno)
+unsigned long ptrace_get_reg(struct task_struct *task, int regno)
@@ -64,2 +66,11 @@
-	if (regno < sizeof(struct pt_regs) / sizeof(unsigned long)
-	    && task->thread.regs != NULL)
+	unsigned long tmp = 0;
+
+	if (task->thread.regs == NULL)
+		return -EIO;
+
+	if (regno == PT_MSR) {
+		tmp = ((unsigned long *)task->thread.regs)[PT_MSR];
+		return tmp | task->thread.fpexc_mode;
+	}
+
+	if (regno < (sizeof(struct pt_regs) / sizeof(unsigned long)))
@@ -67 +78,2 @@
-	return (0);
+
+	return -EIO;
@@ -73,2 +85 @@
-static inline int put_reg(struct task_struct *task, int regno,
-			  unsigned long data)
+int ptrace_put_reg(struct task_struct *task, int regno, unsigned long data)
@@ -76 +87,4 @@
-	if (regno <= PT_MQ && task->thread.regs != NULL) {
+	if (task->thread.regs == NULL)
+		return -EIO;
+
+	if (regno <= PT_MAX_PUT_REG || regno == PT_TRAP) {
@@ -79,0 +94,5 @@
+		/* We prevent mucking around with the reserved area of trap
+		 * which are used internally by the kernel
+		 */
+		if (regno == PT_TRAP)
+			data &= 0xfff0;
@@ -85,0 +105,22 @@
+
+static int get_fpregs(void __user *data, struct task_struct *task,
+		      int has_fpscr)
+{
+	unsigned int count = has_fpscr ? 33 : 32;
+
+	if (copy_to_user(data, task->thread.fpr, count * sizeof(double)))
+		return -EFAULT;
+	return 0;
+}
+
+static int set_fpregs(void __user *data, struct task_struct *task,
+		      int has_fpscr)
+{
+	unsigned int count = has_fpscr ? 33 : 32;
+
+	if (copy_from_user(task->thread.fpr, data, count * sizeof(double)))
+		return -EFAULT;
+	return 0;
+}
+
+
@@ -87,0 +129,13 @@
+ * Get/set all the altivec registers vr0..vr31, vscr, vrsave, in one go.
+ * The transfer totals 34 quadword.  Quadwords 0-31 contain the
+ * corresponding vector registers.  Quadword 32 contains the vscr as the
+ * last word (offset 12) within that quadword.  Quadword 33 contains the
+ * vrsave as the first word (offset 0) within the quadword.
+ *
+ * This definition of the VMX state is compatible with the current PPC32
+ * ptrace interface.  This allows signal handling and ptrace to use the
+ * same structures.  This also simplifies the implementation of a bi-arch
+ * (combined (32- and 64-bit) gdb.
+ */
+
+/*
@@ -90 +144 @@
-static inline int get_vrregs(unsigned long __user *data, struct task_struct *task)
+static int get_vrregs(unsigned long __user *data, struct task_struct *task)
@@ -92,4 +146 @@
-	int i, j;
-
-	if (!access_ok(VERIFY_WRITE, data, 133 * sizeof(unsigned long)))
-		return -EFAULT;
+	unsigned long regsize;
@@ -98,4 +149,4 @@
-	for (i = 0; i < 32; i++)
-		for (j = 0; j < 4; j++, data++)
-			if (__put_user(task->thread.vr[i].u[j], data))
-				return -EFAULT;
+	regsize = 32 * sizeof(vector128);
+	if (copy_to_user(data, task->thread.vr, regsize))
+		return -EFAULT;
+	data += (regsize / sizeof(unsigned long));
@@ -104,3 +155,4 @@
-	for (i = 0; i < 4; i++, data++)
-		if (__put_user(task->thread.vscr.u[i], data))
-			return -EFAULT;
+	regsize = 1 * sizeof(vector128);
+	if (copy_to_user(data, &task->thread.vscr, regsize))
+		return -EFAULT;
+	data += (regsize / sizeof(unsigned long));
@@ -108,2 +160,2 @@
-        /* copy VRSAVE */
-	if (__put_user(task->thread.vrsave, data))
+	/* copy VRSAVE */
+	if (put_user(task->thread.vrsave, (u32 __user *)data))
@@ -118 +170 @@
-static inline int set_vrregs(struct task_struct *task, unsigned long __user *data)
+static int set_vrregs(struct task_struct *task, unsigned long __user *data)
@@ -120,4 +172 @@
-	int i, j;
-
-	if (!access_ok(VERIFY_READ, data, 133 * sizeof(unsigned long)))
-		return -EFAULT;
+	unsigned long regsize;
@@ -126,4 +175,4 @@
-	for (i = 0; i < 32; i++)
-		for (j = 0; j < 4; j++, data++)
-			if (__get_user(task->thread.vr[i].u[j], data))
-				return -EFAULT;
+	regsize = 32 * sizeof(vector128);
+	if (copy_from_user(task->thread.vr, data, regsize))
+		return -EFAULT;
+	data += (regsize / sizeof(unsigned long));
@@ -132,3 +181,4 @@
-	for (i = 0; i < 4; i++, data++)
-		if (__get_user(task->thread.vscr.u[i], data))
-			return -EFAULT;
+	regsize = 1 * sizeof(vector128);
+	if (copy_from_user(&task->thread.vscr, data, regsize))
+		return -EFAULT;
+	data += (regsize / sizeof(unsigned long));
@@ -137 +187 @@
-	if (__get_user(task->thread.vrsave, data))
+	if (get_user(task->thread.vrsave, (u32 __user *)data))
@@ -142 +192 @@
-#endif
+#endif /* CONFIG_ALTIVEC */
@@ -159 +209 @@
-static inline int get_evrregs(unsigned long *data, struct task_struct *task)
+static int get_evrregs(unsigned long *data, struct task_struct *task)
@@ -185 +235 @@
-static inline int set_evrregs(struct task_struct *task, unsigned long *data)
+static int set_evrregs(struct task_struct *task, unsigned long *data)
@@ -208,2 +258,2 @@
-static inline void
-set_single_step(struct task_struct *task)
+
+static void set_single_step(struct task_struct *task)
@@ -224,2 +274 @@
-static inline void
-clear_single_step(struct task_struct *task)
+static void clear_single_step(struct task_struct *task)
@@ -239 +288,19 @@
-#endif /* CONFIG_PPC32 */
+
+static int ptrace_set_debugreg(struct task_struct *task, unsigned long addr,
+			       unsigned long data)
+{
+	/* We only support one DABR and no IABRS at the moment */
+	if (addr > 0)
+		return -EINVAL;
+
+	/* The bottom 3 bits are flags */
+	if ((data & ~0x7UL) >= TASK_SIZE)
+		return -EIO;
+
+	/* Ensure translation is on */
+	if (data && !(data & DABR_TRANSLATION))
+		return -EIO;
+
+	task->thread.dabr = data;
+	return 0;
+}
@@ -251,0 +319,56 @@
+/*
+ * Here are the old "legacy" powerpc specific getregs/setregs ptrace calls,
+ * we mark them as obsolete now, they will be removed in a future version
+ */
+static long arch_ptrace_old(struct task_struct *child, long request, long addr,
+			    long data)
+{
+	int ret = -EPERM;
+
+	switch(request) {
+	case PPC_PTRACE_GETREGS: { /* Get GPRs 0 - 31. */
+		int i;
+		unsigned long *reg = &((unsigned long *)child->thread.regs)[0];
+		unsigned long __user *tmp = (unsigned long __user *)addr;
+
+		for (i = 0; i < 32; i++) {
+			ret = put_user(*reg, tmp);
+			if (ret)
+				break;
+			reg++;
+			tmp++;
+		}
+		break;
+	}
+
+	case PPC_PTRACE_SETREGS: { /* Set GPRs 0 - 31. */
+		int i;
+		unsigned long *reg = &((unsigned long *)child->thread.regs)[0];
+		unsigned long __user *tmp = (unsigned long __user *)addr;
+
+		for (i = 0; i < 32; i++) {
+			ret = get_user(*reg, tmp);
+			if (ret)
+				break;
+			reg++;
+			tmp++;
+		}
+		break;
+	}
+
+	case PPC_PTRACE_GETFPREGS: { /* Get FPRs 0 - 31. */
+		flush_fp_to_thread(child);
+		ret = get_fpregs((void __user *)addr, child, 0);
+		break;
+	}
+
+	case PPC_PTRACE_SETFPREGS: { /* Get FPRs 0 - 31. */
+		flush_fp_to_thread(child);
+		ret = set_fpregs((void __user *)addr, child, 0);
+		break;
+	}
+
+	}
+	return ret;
+}
+
@@ -259,9 +382,2 @@
-	case PTRACE_PEEKDATA: {
-		unsigned long tmp;
-		int copied;
-
-		copied = access_process_vm(child, addr, &tmp, sizeof(tmp), 0);
-		ret = -EIO;
-		if (copied != sizeof(tmp))
-			break;
-		ret = put_user(tmp,(unsigned long __user *) data);
+	case PTRACE_PEEKDATA:
+		ret = generic_ptrace_peekdata(child, addr, data);
@@ -269 +384,0 @@
-	}
@@ -287 +401,0 @@
-#ifdef CONFIG_PPC32
@@ -289 +402,0 @@
-#endif
@@ -291 +404 @@
-			tmp = get_reg(child, (int) index);
+			tmp = ptrace_get_reg(child, (int) index);
@@ -303,5 +416 @@
-		ret = 0;
-		if (access_process_vm(child, addr, &data, sizeof(data), 1)
-				== sizeof(data))
-			break;
-		ret = -EIO;
+		ret = generic_ptrace_pokedata(child, addr, data);
@@ -326 +434,0 @@
-#ifdef CONFIG_PPC32
@@ -328,3 +435,0 @@
-#endif
-		if (index == PT_ORIG_R3)
-			break;
@@ -332 +437 @@
-			ret = put_reg(child, index, data);
+			ret = ptrace_put_reg(child, index, data);
@@ -387 +491,0 @@
-#ifdef CONFIG_PPC64
@@ -401 +504,0 @@
-#endif
@@ -407,11 +510,15 @@
-	case PPC_PTRACE_GETREGS: { /* Get GPRs 0 - 31. */
-		int i;
-		unsigned long *reg = &((unsigned long *)child->thread.regs)[0];
-		unsigned long __user *tmp = (unsigned long __user *)addr;
-
-		for (i = 0; i < 32; i++) {
-			ret = put_user(*reg, tmp);
-			if (ret)
-				break;
-			reg++;
-			tmp++;
+#ifdef CONFIG_PPC64
+	case PTRACE_GETREGS64:
+#endif
+	case PTRACE_GETREGS: { /* Get all pt_regs from the child. */
+		int ui;
+	  	if (!access_ok(VERIFY_WRITE, (void __user *)data,
+			       sizeof(struct pt_regs))) {
+			ret = -EIO;
+			break;
+		}
+		ret = 0;
+		for (ui = 0; ui < PT_REGS_COUNT; ui ++) {
+			ret |= __put_user(ptrace_get_reg(child, ui),
+					  (unsigned long __user *) data);
+			data += sizeof(long);
@@ -422,7 +529,14 @@
-	case PPC_PTRACE_SETREGS: { /* Set GPRs 0 - 31. */
-		int i;
-		unsigned long *reg = &((unsigned long *)child->thread.regs)[0];
-		unsigned long __user *tmp = (unsigned long __user *)addr;
-
-		for (i = 0; i < 32; i++) {
-			ret = get_user(*reg, tmp);
+#ifdef CONFIG_PPC64
+	case PTRACE_SETREGS64:
+#endif
+	case PTRACE_SETREGS: { /* Set all gp regs in the child. */
+		unsigned long tmp;
+		int ui;
+	  	if (!access_ok(VERIFY_READ, (void __user *)data,
+			       sizeof(struct pt_regs))) {
+			ret = -EIO;
+			break;
+		}
+		ret = 0;
+		for (ui = 0; ui < PT_REGS_COUNT; ui ++) {
+			ret = __get_user(tmp, (unsigned long __user *) data);
@@ -431,2 +545,2 @@
-			reg++;
-			tmp++;
+			ptrace_put_reg(child, ui, tmp);
+			data += sizeof(long);
@@ -437,5 +551 @@
-	case PPC_PTRACE_GETFPREGS: { /* Get FPRs 0 - 31. */
-		int i;
-		unsigned long *reg = &((unsigned long *)child->thread.fpr)[0];
-		unsigned long __user *tmp = (unsigned long __user *)addr;
-
+	case PTRACE_GETFPREGS: { /* Get the child FPU state (FPR0...31 + FPSCR) */
@@ -443,8 +553 @@
-
-		for (i = 0; i < 32; i++) {
-			ret = put_user(*reg, tmp);
-			if (ret)
-				break;
-			reg++;
-			tmp++;
-		}
+		ret = get_fpregs((void __user *)data, child, 1);
@@ -454,5 +557 @@
-	case PPC_PTRACE_SETFPREGS: { /* Get FPRs 0 - 31. */
-		int i;
-		unsigned long *reg = &((unsigned long *)child->thread.fpr)[0];
-		unsigned long __user *tmp = (unsigned long __user *)addr;
-
+	case PTRACE_SETFPREGS: { /* Set the child FPU state (FPR0...31 + FPSCR) */
@@ -460,8 +559 @@
-
-		for (i = 0; i < 32; i++) {
-			ret = get_user(*reg, tmp);
-			if (ret)
-				break;
-			reg++;
-			tmp++;
-		}
+		ret = set_fpregs((void __user *)data, child, 1);
@@ -501,0 +594,8 @@
+	/* Old reverse args ptrace callss */
+	case PPC_PTRACE_GETREGS: /* Get GPRs 0 - 31. */
+	case PPC_PTRACE_SETREGS: /* Set GPRs 0 - 31. */
+	case PPC_PTRACE_GETFPREGS: /* Get FPRs 0 - 31. */
+	case PPC_PTRACE_SETFPREGS: /* Get FPRs 0 - 31. */
+		ret = arch_ptrace_old(child, request, addr, data);
+		break;
+
@@ -506 +605,0 @@
-
--- ./projects/linux/linux-2.6.23/arch/powerpc/kernel/ptrace.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/arch/powerpc/kernel/ptrace.c	2008-01-24 23:58:37.000000000 +0100
@@ -333,0 +334 @@
+		CHECK_FULL_REGS(child->thread.regs);
@@ -348,0 +350 @@
+		CHECK_FULL_REGS(child->thread.regs);
@@ -506,4 +507,0 @@
-	case PTRACE_DETACH:
-		ret = ptrace_detach(child, data);
-		break;
-
@@ -519,0 +518 @@
+		CHECK_FULL_REGS(child->thread.regs);
@@ -539,0 +539 @@
+		CHECK_FULL_REGS(child->thread.regs);
@@ -579,2 +579 @@
-		if (child->thread.regs->msr & MSR_SPE)
-			giveup_spe(child);
+		flush_spe_to_thread(child);
@@ -588,2 +587 @@
-		if (child->thread.regs->msr & MSR_SPE)
-			giveup_spe(child);
+		flush_spe_to_thread(child);
--- ./projects/linux/linux-2.6.24/arch/powerpc/kernel/ptrace.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/powerpc/kernel/ptrace.c	2008-04-17 04:49:44.000000000 +0200
@@ -23,0 +24,2 @@
+#include <linux/regset.h>
+#include <linux/elf.h>
@@ -60,0 +63,22 @@
+static unsigned long get_user_msr(struct task_struct *task)
+{
+	return task->thread.regs->msr | task->thread.fpexc_mode;
+}
+
+static int set_user_msr(struct task_struct *task, unsigned long msr)
+{
+	task->thread.regs->msr &= ~MSR_DEBUGCHANGE;
+	task->thread.regs->msr |= msr & MSR_DEBUGCHANGE;
+	return 0;
+}
+
+/*
+ * We prevent mucking around with the reserved area of trap
+ * which are used internally by the kernel.
+ */
+static int set_user_trap(struct task_struct *task, unsigned long trap)
+{
+	task->thread.regs->trap = trap & 0xfff0;
+	return 0;
+}
+
@@ -66,2 +89,0 @@
-	unsigned long tmp = 0;
-
@@ -71,4 +93,2 @@
-	if (regno == PT_MSR) {
-		tmp = ((unsigned long *)task->thread.regs)[PT_MSR];
-		return tmp | task->thread.fpexc_mode;
-	}
+	if (regno == PT_MSR)
+		return get_user_msr(task);
@@ -90,9 +110,6 @@
-	if (regno <= PT_MAX_PUT_REG || regno == PT_TRAP) {
-		if (regno == PT_MSR)
-			data = (data & MSR_DEBUGCHANGE)
-				| (task->thread.regs->msr & ~MSR_DEBUGCHANGE);
-		/* We prevent mucking around with the reserved area of trap
-		 * which are used internally by the kernel
-		 */
-		if (regno == PT_TRAP)
-			data &= 0xfff0;
+	if (regno == PT_MSR)
+		return set_user_msr(task, data);
+	if (regno == PT_TRAP)
+		return set_user_trap(task, data);
+
+	if (regno <= PT_MAX_PUT_REG) {
@@ -104,0 +122,91 @@
+static int gpr_get(struct task_struct *target, const struct user_regset *regset,
+		   unsigned int pos, unsigned int count,
+		   void *kbuf, void __user *ubuf)
+{
+	int ret;
+
+	if (target->thread.regs == NULL)
+		return -EIO;
+
+	CHECK_FULL_REGS(target->thread.regs);
+
+	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+				  target->thread.regs,
+				  0, offsetof(struct pt_regs, msr));
+	if (!ret) {
+		unsigned long msr = get_user_msr(target);
+		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &msr,
+					  offsetof(struct pt_regs, msr),
+					  offsetof(struct pt_regs, msr) +
+					  sizeof(msr));
+	}
+
+	BUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=
+		     offsetof(struct pt_regs, msr) + sizeof(long));
+
+	if (!ret)
+		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+					  &target->thread.regs->orig_gpr3,
+					  offsetof(struct pt_regs, orig_gpr3),
+					  sizeof(struct pt_regs));
+	if (!ret)
+		ret = user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,
+					       sizeof(struct pt_regs), -1);
+
+	return ret;
+}
+
+static int gpr_set(struct task_struct *target, const struct user_regset *regset,
+		   unsigned int pos, unsigned int count,
+		   const void *kbuf, const void __user *ubuf)
+{
+	unsigned long reg;
+	int ret;
+
+	if (target->thread.regs == NULL)
+		return -EIO;
+
+	CHECK_FULL_REGS(target->thread.regs);
+
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+				 target->thread.regs,
+				 0, PT_MSR * sizeof(reg));
+
+	if (!ret && count > 0) {
+		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,
+					 PT_MSR * sizeof(reg),
+					 (PT_MSR + 1) * sizeof(reg));
+		if (!ret)
+			ret = set_user_msr(target, reg);
+	}
+
+	BUILD_BUG_ON(offsetof(struct pt_regs, orig_gpr3) !=
+		     offsetof(struct pt_regs, msr) + sizeof(long));
+
+	if (!ret)
+		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+					 &target->thread.regs->orig_gpr3,
+					 PT_ORIG_R3 * sizeof(reg),
+					 (PT_MAX_PUT_REG + 1) * sizeof(reg));
+
+	if (PT_MAX_PUT_REG + 1 < PT_TRAP && !ret)
+		ret = user_regset_copyin_ignore(
+			&pos, &count, &kbuf, &ubuf,
+			(PT_MAX_PUT_REG + 1) * sizeof(reg),
+			PT_TRAP * sizeof(reg));
+
+	if (!ret && count > 0) {
+		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &reg,
+					 PT_TRAP * sizeof(reg),
+					 (PT_TRAP + 1) * sizeof(reg));
+		if (!ret)
+			ret = set_user_trap(target, reg);
+	}
+
+	if (!ret)
+		ret = user_regset_copyin_ignore(
+			&pos, &count, &kbuf, &ubuf,
+			(PT_TRAP + 1) * sizeof(reg), -1);
+
+	return ret;
+}
@@ -106,2 +214,3 @@
-static int get_fpregs(void __user *data, struct task_struct *task,
-		      int has_fpscr)
+static int fpr_get(struct task_struct *target, const struct user_regset *regset,
+		   unsigned int pos, unsigned int count,
+		   void *kbuf, void __user *ubuf)
@@ -109 +218 @@
-	unsigned int count = has_fpscr ? 33 : 32;
+	flush_fp_to_thread(target);
@@ -111,3 +220,5 @@
-	if (copy_to_user(data, task->thread.fpr, count * sizeof(double)))
-		return -EFAULT;
-	return 0;
+	BUILD_BUG_ON(offsetof(struct thread_struct, fpscr) !=
+		     offsetof(struct thread_struct, fpr[32]));
+
+	return user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+				   &target->thread.fpr, 0, -1);
@@ -116,2 +227,3 @@
-static int set_fpregs(void __user *data, struct task_struct *task,
-		      int has_fpscr)
+static int fpr_set(struct task_struct *target, const struct user_regset *regset,
+		   unsigned int pos, unsigned int count,
+		   const void *kbuf, const void __user *ubuf)
@@ -119 +231 @@
-	unsigned int count = has_fpscr ? 33 : 32;
+	flush_fp_to_thread(target);
@@ -121,3 +233,5 @@
-	if (copy_from_user(task->thread.fpr, data, count * sizeof(double)))
-		return -EFAULT;
-	return 0;
+	BUILD_BUG_ON(offsetof(struct thread_struct, fpscr) !=
+		     offsetof(struct thread_struct, fpr[32]));
+
+	return user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+				  &target->thread.fpr, 0, -1);
@@ -141,4 +255,2 @@
-/*
- * Get contents of AltiVec register state in task TASK
- */
-static int get_vrregs(unsigned long __user *data, struct task_struct *task)
+static int vr_active(struct task_struct *target,
+		     const struct user_regset *regset)
@@ -146,19 +258,2 @@
-	unsigned long regsize;
-
-	/* copy AltiVec registers VR[0] .. VR[31] */
-	regsize = 32 * sizeof(vector128);
-	if (copy_to_user(data, task->thread.vr, regsize))
-		return -EFAULT;
-	data += (regsize / sizeof(unsigned long));
-
-	/* copy VSCR */
-	regsize = 1 * sizeof(vector128);
-	if (copy_to_user(data, &task->thread.vscr, regsize))
-		return -EFAULT;
-	data += (regsize / sizeof(unsigned long));
-
-	/* copy VRSAVE */
-	if (put_user(task->thread.vrsave, (u32 __user *)data))
-		return -EFAULT;
-
-	return 0;
+	flush_altivec_to_thread(target);
+	return target->thread.used_vr ? regset->n : 0;
@@ -167,4 +262,3 @@
-/*
- * Write contents of AltiVec register state into task TASK.
- */
-static int set_vrregs(struct task_struct *task, unsigned long __user *data)
+static int vr_get(struct task_struct *target, const struct user_regset *regset,
+		  unsigned int pos, unsigned int count,
+		  void *kbuf, void __user *ubuf)
@@ -172 +266 @@
-	unsigned long regsize;
+	int ret;
@@ -174,15 +268 @@
-	/* copy AltiVec registers VR[0] .. VR[31] */
-	regsize = 32 * sizeof(vector128);
-	if (copy_from_user(task->thread.vr, data, regsize))
-		return -EFAULT;
-	data += (regsize / sizeof(unsigned long));
-
-	/* copy VSCR */
-	regsize = 1 * sizeof(vector128);
-	if (copy_from_user(&task->thread.vscr, data, regsize))
-		return -EFAULT;
-	data += (regsize / sizeof(unsigned long));
-
-	/* copy VRSAVE */
-	if (get_user(task->thread.vrsave, (u32 __user *)data))
-		return -EFAULT;
+	flush_altivec_to_thread(target);
@@ -190 +270,53 @@
-	return 0;
+	BUILD_BUG_ON(offsetof(struct thread_struct, vscr) !=
+		     offsetof(struct thread_struct, vr[32]));
+
+	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+				  &target->thread.vr, 0,
+				  33 * sizeof(vector128));
+	if (!ret) {
+		/*
+		 * Copy out only the low-order word of vrsave.
+		 */
+		union {
+			elf_vrreg_t reg;
+			u32 word;
+		} vrsave;
+		memset(&vrsave, 0, sizeof(vrsave));
+		vrsave.word = target->thread.vrsave;
+		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf, &vrsave,
+					  33 * sizeof(vector128), -1);
+	}
+
+	return ret;
+}
+
+static int vr_set(struct task_struct *target, const struct user_regset *regset,
+		  unsigned int pos, unsigned int count,
+		  const void *kbuf, const void __user *ubuf)
+{
+	int ret;
+
+	flush_altivec_to_thread(target);
+
+	BUILD_BUG_ON(offsetof(struct thread_struct, vscr) !=
+		     offsetof(struct thread_struct, vr[32]));
+
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+				 &target->thread.vr, 0, 33 * sizeof(vector128));
+	if (!ret && count > 0) {
+		/*
+		 * We use only the first word of vrsave.
+		 */
+		union {
+			elf_vrreg_t reg;
+			u32 word;
+		} vrsave;
+		memset(&vrsave, 0, sizeof(vrsave));
+		vrsave.word = target->thread.vrsave;
+		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf, &vrsave,
+					 33 * sizeof(vector128), -1);
+		if (!ret)
+			target->thread.vrsave = vrsave.word;
+	}
+
+	return ret;
@@ -206,4 +338,10 @@
-/*
- * Get contents of SPE register state in task TASK.
- */
-static int get_evrregs(unsigned long *data, struct task_struct *task)
+static int evr_active(struct task_struct *target,
+		      const struct user_regset *regset)
+{
+	flush_spe_to_thread(target);
+	return target->thread.used_spe ? regset->n : 0;
+}
+
+static int evr_get(struct task_struct *target, const struct user_regset *regset,
+		   unsigned int pos, unsigned int count,
+		   void *kbuf, void __user *ubuf)
@@ -211 +349 @@
-	int i;
+	int ret;
@@ -213,2 +351 @@
-	if (!access_ok(VERIFY_WRITE, data, 35 * sizeof(unsigned long)))
-		return -EFAULT;
+	flush_spe_to_thread(target);
@@ -216,3 +353,3 @@
-	/* copy SPEFSCR */
-	if (__put_user(task->thread.spefscr, &data[34]))
-		return -EFAULT;
+	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+				  &target->thread.evr,
+				  0, sizeof(target->thread.evr));
@@ -220,4 +357,2 @@
-	/* copy SPE registers EVR[0] .. EVR[31] */
-	for (i = 0; i < 32; i++, data++)
-		if (__put_user(task->thread.evr[i], data))
-			return -EFAULT;
+	BUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=
+		     offsetof(struct thread_struct, spefscr));
@@ -225,3 +360,4 @@
-	/* copy ACC */
-	if (__put_user64(task->thread.acc, (unsigned long long *)data))
-		return -EFAULT;
+	if (!ret)
+		ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+					  &target->thread.acc,
+					  sizeof(target->thread.evr), -1);
@@ -229 +365 @@
-	return 0;
+	return ret;
@@ -231,0 +368,25 @@
+static int evr_set(struct task_struct *target, const struct user_regset *regset,
+		   unsigned int pos, unsigned int count,
+		   const void *kbuf, const void __user *ubuf)
+{
+	int ret;
+
+	flush_spe_to_thread(target);
+
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+				 &target->thread.evr,
+				 0, sizeof(target->thread.evr));
+
+	BUILD_BUG_ON(offsetof(struct thread_struct, acc) + sizeof(u64) !=
+		     offsetof(struct thread_struct, spefscr));
+
+	if (!ret)
+		ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+					 &target->thread.acc,
+					 sizeof(target->thread.evr), -1);
+
+	return ret;
+}
+#endif /* CONFIG_SPE */
+
+
@@ -233 +394 @@
- * Write contents of SPE register state into task TASK.
+ * These are our native regset flavors.
@@ -235,3 +396,42 @@
-static int set_evrregs(struct task_struct *task, unsigned long *data)
-{
-	int i;
+enum powerpc_regset {
+	REGSET_GPR,
+	REGSET_FPR,
+#ifdef CONFIG_ALTIVEC
+	REGSET_VMX,
+#endif
+#ifdef CONFIG_SPE
+	REGSET_SPE,
+#endif
+};
+
+static const struct user_regset native_regsets[] = {
+	[REGSET_GPR] = {
+		.core_note_type = NT_PRSTATUS, .n = ELF_NGREG,
+		.size = sizeof(long), .align = sizeof(long),
+		.get = gpr_get, .set = gpr_set
+	},
+	[REGSET_FPR] = {
+		.core_note_type = NT_PRFPREG, .n = ELF_NFPREG,
+		.size = sizeof(double), .align = sizeof(double),
+		.get = fpr_get, .set = fpr_set
+	},
+#ifdef CONFIG_ALTIVEC
+	[REGSET_VMX] = {
+		.core_note_type = NT_PPC_VMX, .n = 34,
+		.size = sizeof(vector128), .align = sizeof(vector128),
+		.active = vr_active, .get = vr_get, .set = vr_set
+	},
+#endif
+#ifdef CONFIG_SPE
+	[REGSET_SPE] = {
+		.n = 35,
+		.size = sizeof(u32), .align = sizeof(u32),
+		.active = evr_active, .get = evr_get, .set = evr_set
+	},
+#endif
+};
+
+static const struct user_regset_view user_ppc_native_view = {
+	.name = UTS_MACHINE, .e_machine = ELF_ARCH, .ei_osabi = ELF_OSABI,
+	.regsets = native_regsets, .n = ARRAY_SIZE(native_regsets)
+};
@@ -239,2 +439,2 @@
-	if (!access_ok(VERIFY_READ, data, 35 * sizeof(unsigned long)))
-		return -EFAULT;
+#ifdef CONFIG_PPC64
+#include <linux/compat.h>
@@ -242,3 +442,9 @@
-	/* copy SPEFSCR */
-	if (__get_user(task->thread.spefscr, &data[34]))
-		return -EFAULT;
+static int gpr32_get(struct task_struct *target,
+		     const struct user_regset *regset,
+		     unsigned int pos, unsigned int count,
+		     void *kbuf, void __user *ubuf)
+{
+	const unsigned long *regs = &target->thread.regs->gpr[0];
+	compat_ulong_t *k = kbuf;
+	compat_ulong_t __user *u = ubuf;
+	compat_ulong_t reg;
@@ -246,3 +452,21 @@
-	/* copy SPE registers EVR[0] .. EVR[31] */
-	for (i = 0; i < 32; i++, data++)
-		if (__get_user(task->thread.evr[i], data))
+	if (target->thread.regs == NULL)
+		return -EIO;
+
+	CHECK_FULL_REGS(target->thread.regs);
+
+	pos /= sizeof(reg);
+	count /= sizeof(reg);
+
+	if (kbuf)
+		for (; count > 0 && pos < PT_MSR; --count)
+			*k++ = regs[pos++];
+	else
+		for (; count > 0 && pos < PT_MSR; --count)
+			if (__put_user((compat_ulong_t) regs[pos++], u++))
+				return -EFAULT;
+
+	if (count > 0 && pos == PT_MSR) {
+		reg = get_user_msr(target);
+		if (kbuf)
+			*k++ = reg;
+		else if (__put_user(reg, u++))
@@ -250,3 +474,3 @@
-	/* copy ACC */
-	if (__get_user64(task->thread.acc, (unsigned long long*)data))
-		return -EFAULT;
+		++pos;
+		--count;
+	}
@@ -254 +478,87 @@
-	return 0;
+	if (kbuf)
+		for (; count > 0 && pos < PT_REGS_COUNT; --count)
+			*k++ = regs[pos++];
+	else
+		for (; count > 0 && pos < PT_REGS_COUNT; --count)
+			if (__put_user((compat_ulong_t) regs[pos++], u++))
+				return -EFAULT;
+
+	kbuf = k;
+	ubuf = u;
+	pos *= sizeof(reg);
+	count *= sizeof(reg);
+	return user_regset_copyout_zero(&pos, &count, &kbuf, &ubuf,
+					PT_REGS_COUNT * sizeof(reg), -1);
+}
+
+static int gpr32_set(struct task_struct *target,
+		     const struct user_regset *regset,
+		     unsigned int pos, unsigned int count,
+		     const void *kbuf, const void __user *ubuf)
+{
+	unsigned long *regs = &target->thread.regs->gpr[0];
+	const compat_ulong_t *k = kbuf;
+	const compat_ulong_t __user *u = ubuf;
+	compat_ulong_t reg;
+
+	if (target->thread.regs == NULL)
+		return -EIO;
+
+	CHECK_FULL_REGS(target->thread.regs);
+
+	pos /= sizeof(reg);
+	count /= sizeof(reg);
+
+	if (kbuf)
+		for (; count > 0 && pos < PT_MSR; --count)
+			regs[pos++] = *k++;
+	else
+		for (; count > 0 && pos < PT_MSR; --count) {
+			if (__get_user(reg, u++))
+				return -EFAULT;
+			regs[pos++] = reg;
+		}
+
+
+	if (count > 0 && pos == PT_MSR) {
+		if (kbuf)
+			reg = *k++;
+		else if (__get_user(reg, u++))
+			return -EFAULT;
+		set_user_msr(target, reg);
+		++pos;
+		--count;
+	}
+
+	if (kbuf) {
+		for (; count > 0 && pos <= PT_MAX_PUT_REG; --count)
+			regs[pos++] = *k++;
+		for (; count > 0 && pos < PT_TRAP; --count, ++pos)
+			++k;
+	} else {
+		for (; count > 0 && pos <= PT_MAX_PUT_REG; --count) {
+			if (__get_user(reg, u++))
+				return -EFAULT;
+			regs[pos++] = reg;
+		}
+		for (; count > 0 && pos < PT_TRAP; --count, ++pos)
+			if (__get_user(reg, u++))
+				return -EFAULT;
+	}
+
+	if (count > 0 && pos == PT_TRAP) {
+		if (kbuf)
+			reg = *k++;
+		else if (__get_user(reg, u++))
+			return -EFAULT;
+		set_user_trap(target, reg);
+		++pos;
+		--count;
+	}
+
+	kbuf = k;
+	ubuf = u;
+	pos *= sizeof(reg);
+	count *= sizeof(reg);
+	return user_regset_copyin_ignore(&pos, &count, &kbuf, &ubuf,
+					 (PT_TRAP + 1) * sizeof(reg), -1);
@@ -256 +565,0 @@
-#endif /* CONFIG_SPE */
@@ -257,0 +567,35 @@
+/*
+ * These are the regset flavors matching the CONFIG_PPC32 native set.
+ */
+static const struct user_regset compat_regsets[] = {
+	[REGSET_GPR] = {
+		.core_note_type = NT_PRSTATUS, .n = ELF_NGREG,
+		.size = sizeof(compat_long_t), .align = sizeof(compat_long_t),
+		.get = gpr32_get, .set = gpr32_set
+	},
+	[REGSET_FPR] = {
+		.core_note_type = NT_PRFPREG, .n = ELF_NFPREG,
+		.size = sizeof(double), .align = sizeof(double),
+		.get = fpr_get, .set = fpr_set
+	},
+#ifdef CONFIG_ALTIVEC
+	[REGSET_VMX] = {
+		.core_note_type = NT_PPC_VMX, .n = 34,
+		.size = sizeof(vector128), .align = sizeof(vector128),
+		.active = vr_active, .get = vr_get, .set = vr_set
+	},
+#endif
+#ifdef CONFIG_SPE
+	[REGSET_SPE] = {
+		.core_note_type = NT_PPC_SPE, .n = 35,
+		.size = sizeof(u32), .align = sizeof(u32),
+		.active = evr_active, .get = evr_get, .set = evr_set
+	},
+#endif
+};
+
+static const struct user_regset_view user_ppc_compat_view = {
+	.name = "ppc", .e_machine = EM_PPC, .ei_osabi = ELF_OSABI,
+	.regsets = compat_regsets, .n = ARRAY_SIZE(compat_regsets)
+};
+#endif	/* CONFIG_PPC64 */
@@ -259 +603,11 @@
-static void set_single_step(struct task_struct *task)
+const struct user_regset_view *task_user_regset_view(struct task_struct *task)
+{
+#ifdef CONFIG_PPC64
+	if (test_tsk_thread_flag(task, TIF_32BIT))
+		return &user_ppc_compat_view;
+#endif
+	return &user_ppc_native_view;
+}
+
+
+void user_enable_single_step(struct task_struct *task)
@@ -274 +628 @@
-static void clear_single_step(struct task_struct *task)
+void user_disable_single_step(struct task_struct *task)
@@ -316 +670 @@
-	clear_single_step(child);
+	user_disable_single_step(child);
@@ -326,45 +680,20 @@
-	int ret = -EPERM;
-
-	switch(request) {
-	case PPC_PTRACE_GETREGS: { /* Get GPRs 0 - 31. */
-		int i;
-		unsigned long *reg = &((unsigned long *)child->thread.regs)[0];
-		unsigned long __user *tmp = (unsigned long __user *)addr;
-
-		CHECK_FULL_REGS(child->thread.regs);
-		for (i = 0; i < 32; i++) {
-			ret = put_user(*reg, tmp);
-			if (ret)
-				break;
-			reg++;
-			tmp++;
-		}
-		break;
-	}
-
-	case PPC_PTRACE_SETREGS: { /* Set GPRs 0 - 31. */
-		int i;
-		unsigned long *reg = &((unsigned long *)child->thread.regs)[0];
-		unsigned long __user *tmp = (unsigned long __user *)addr;
-
-		CHECK_FULL_REGS(child->thread.regs);
-		for (i = 0; i < 32; i++) {
-			ret = get_user(*reg, tmp);
-			if (ret)
-				break;
-			reg++;
-			tmp++;
-		}
-		break;
-	}
-
-	case PPC_PTRACE_GETFPREGS: { /* Get FPRs 0 - 31. */
-		flush_fp_to_thread(child);
-		ret = get_fpregs((void __user *)addr, child, 0);
-		break;
-	}
-
-	case PPC_PTRACE_SETFPREGS: { /* Get FPRs 0 - 31. */
-		flush_fp_to_thread(child);
-		ret = set_fpregs((void __user *)addr, child, 0);
-		break;
+	switch (request) {
+	case PPC_PTRACE_GETREGS:	/* Get GPRs 0 - 31. */
+		return copy_regset_to_user(child, &user_ppc_native_view,
+					   REGSET_GPR, 0, 32 * sizeof(long),
+					   (void __user *) data);
+
+	case PPC_PTRACE_SETREGS:	/* Set GPRs 0 - 31. */
+		return copy_regset_from_user(child, &user_ppc_native_view,
+					     REGSET_GPR, 0, 32 * sizeof(long),
+					     (const void __user *) data);
+
+	case PPC_PTRACE_GETFPREGS:	/* Get FPRs 0 - 31. */
+		return copy_regset_to_user(child, &user_ppc_native_view,
+					   REGSET_FPR, 0, 32 * sizeof(double),
+					   (void __user *) data);
+
+	case PPC_PTRACE_SETFPREGS:	/* Set FPRs 0 - 31. */
+		return copy_regset_from_user(child, &user_ppc_native_view,
+					     REGSET_FPR, 0, 32 * sizeof(double),
+					     (const void __user *) data);
@@ -373,2 +702 @@
-	}
-	return ret;
+	return -EPERM;
@@ -382,6 +709,0 @@
-	/* when I and D space are separate, these will need to be fixed. */
-	case PTRACE_PEEKTEXT: /* read word at location addr. */
-	case PTRACE_PEEKDATA:
-		ret = generic_ptrace_peekdata(child, addr, data);
-		break;
-
@@ -415,6 +736,0 @@
-	/* If I and D space are separate, this will have to be fixed. */
-	case PTRACE_POKETEXT: /* write the word at location addr. */
-	case PTRACE_POKEDATA:
-		ret = generic_ptrace_pokedata(child, addr, data);
-		break;
-
@@ -448,46 +763,0 @@
-	case PTRACE_SYSCALL: /* continue and stop at next (return from) syscall */
-	case PTRACE_CONT: { /* restart after signal. */
-		ret = -EIO;
-		if (!valid_signal(data))
-			break;
-		if (request == PTRACE_SYSCALL)
-			set_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
-		else
-			clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
-		child->exit_code = data;
-		/* make sure the single step bit is not set. */
-		clear_single_step(child);
-		wake_up_process(child);
-		ret = 0;
-		break;
-	}
-
-/*
- * make the child exit.  Best I can do is send it a sigkill.
- * perhaps it should be put in the status that it wants to
- * exit.
- */
-	case PTRACE_KILL: {
-		ret = 0;
-		if (child->exit_state == EXIT_ZOMBIE)	/* already dead */
-			break;
-		child->exit_code = SIGKILL;
-		/* make sure the single step bit is not set. */
-		clear_single_step(child);
-		wake_up_process(child);
-		break;
-	}
-
-	case PTRACE_SINGLESTEP: {  /* set the trap flag. */
-		ret = -EIO;
-		if (!valid_signal(data))
-			break;
-		clear_tsk_thread_flag(child, TIF_SYSCALL_TRACE);
-		set_single_step(child);
-		child->exit_code = data;
-		/* give it a chance to run. */
-		wake_up_process(child);
-		ret = 0;
-		break;
-	}
-
@@ -511,16 +781,5 @@
-	case PTRACE_GETREGS: { /* Get all pt_regs from the child. */
-		int ui;
-	  	if (!access_ok(VERIFY_WRITE, (void __user *)data,
-			       sizeof(struct pt_regs))) {
-			ret = -EIO;
-			break;
-		}
-		CHECK_FULL_REGS(child->thread.regs);
-		ret = 0;
-		for (ui = 0; ui < PT_REGS_COUNT; ui ++) {
-			ret |= __put_user(ptrace_get_reg(child, ui),
-					  (unsigned long __user *) data);
-			data += sizeof(long);
-		}
-		break;
-	}
+	case PTRACE_GETREGS:	/* Get all pt_regs from the child. */
+		return copy_regset_to_user(child, &user_ppc_native_view,
+					   REGSET_GPR,
+					   0, sizeof(struct pt_regs),
+					   (void __user *) data);
@@ -531,31 +790,17 @@
-	case PTRACE_SETREGS: { /* Set all gp regs in the child. */
-		unsigned long tmp;
-		int ui;
-	  	if (!access_ok(VERIFY_READ, (void __user *)data,
-			       sizeof(struct pt_regs))) {
-			ret = -EIO;
-			break;
-		}
-		CHECK_FULL_REGS(child->thread.regs);
-		ret = 0;
-		for (ui = 0; ui < PT_REGS_COUNT; ui ++) {
-			ret = __get_user(tmp, (unsigned long __user *) data);
-			if (ret)
-				break;
-			ptrace_put_reg(child, ui, tmp);
-			data += sizeof(long);
-		}
-		break;
-	}
-
-	case PTRACE_GETFPREGS: { /* Get the child FPU state (FPR0...31 + FPSCR) */
-		flush_fp_to_thread(child);
-		ret = get_fpregs((void __user *)data, child, 1);
-		break;
-	}
-
-	case PTRACE_SETFPREGS: { /* Set the child FPU state (FPR0...31 + FPSCR) */
-		flush_fp_to_thread(child);
-		ret = set_fpregs((void __user *)data, child, 1);
-		break;
-	}
+	case PTRACE_SETREGS:	/* Set all gp regs in the child. */
+		return copy_regset_from_user(child, &user_ppc_native_view,
+					     REGSET_GPR,
+					     0, sizeof(struct pt_regs),
+					     (const void __user *) data);
+
+	case PTRACE_GETFPREGS: /* Get the child FPU state (FPR0...31 + FPSCR) */
+		return copy_regset_to_user(child, &user_ppc_native_view,
+					   REGSET_FPR,
+					   0, sizeof(elf_fpregset_t),
+					   (void __user *) data);
+
+	case PTRACE_SETFPREGS: /* Set the child FPU state (FPR0...31 + FPSCR) */
+		return copy_regset_from_user(child, &user_ppc_native_view,
+					     REGSET_FPR,
+					     0, sizeof(elf_fpregset_t),
+					     (const void __user *) data);
@@ -565,4 +810,5 @@
-		/* Get the child altivec register state. */
-		flush_altivec_to_thread(child);
-		ret = get_vrregs((unsigned long __user *)data, child);
-		break;
+		return copy_regset_to_user(child, &user_ppc_native_view,
+					   REGSET_VMX,
+					   0, (33 * sizeof(vector128) +
+					       sizeof(u32)),
+					   (void __user *) data);
@@ -571,4 +817,5 @@
-		/* Set the child altivec register state. */
-		flush_altivec_to_thread(child);
-		ret = set_vrregs(child, (unsigned long __user *)data);
-		break;
+		return copy_regset_from_user(child, &user_ppc_native_view,
+					     REGSET_VMX,
+					     0, (33 * sizeof(vector128) +
+						 sizeof(u32)),
+					     (const void __user *) data);
@@ -579,3 +826,3 @@
-		flush_spe_to_thread(child);
-		ret = get_evrregs((unsigned long __user *)data, child);
-		break;
+		return copy_regset_to_user(child, &user_ppc_native_view,
+					   REGSET_SPE, 0, 35 * sizeof(u32),
+					   (void __user *) data);
@@ -585,5 +832,3 @@
-		/* this is to clear the MSR_SPE bit to force a reload
-		 * of register state from memory */
-		flush_spe_to_thread(child);
-		ret = set_evrregs(child, (unsigned long __user *)data);
-		break;
+		return copy_regset_from_user(child, &user_ppc_native_view,
+					     REGSET_SPE, 0, 35 * sizeof(u32),
+					     (const void __user *) data);
--- ./projects/linux/linux-2.6.26/arch/powerpc/kernel/ptrace.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/arch/powerpc/kernel/ptrace.c	2008-10-10 00:13:53.000000000 +0200
@@ -24,0 +25 @@
+#include <linux/tracehook.h>
@@ -217,0 +219,4 @@
+#ifdef CONFIG_VSX
+	double buf[33];
+	int i;
+#endif
@@ -219,0 +225,8 @@
+#ifdef CONFIG_VSX
+	/* copy to local buffer then write that out */
+	for (i = 0; i < 32 ; i++)
+		buf[i] = target->thread.TS_FPR(i);
+	memcpy(&buf[32], &target->thread.fpscr, sizeof(double));
+	return user_regset_copyout(&pos, &count, &kbuf, &ubuf, buf, 0, -1);
+
+#else
@@ -221 +234 @@
-		     offsetof(struct thread_struct, fpr[32]));
+		     offsetof(struct thread_struct, TS_FPR(32)));
@@ -224,0 +238 @@
+#endif
@@ -230,0 +245,4 @@
+#ifdef CONFIG_VSX
+	double buf[33];
+	int i;
+#endif
@@ -232,0 +251,10 @@
+#ifdef CONFIG_VSX
+	/* copy to local buffer then write that out */
+	i = user_regset_copyin(&pos, &count, &kbuf, &ubuf, buf, 0, -1);
+	if (i)
+		return i;
+	for (i = 0; i < 32 ; i++)
+		target->thread.TS_FPR(i) = buf[i];
+	memcpy(&target->thread.fpscr, &buf[32], sizeof(double));
+	return 0;
+#else
@@ -234 +262 @@
-		     offsetof(struct thread_struct, fpr[32]));
+		     offsetof(struct thread_struct, TS_FPR(32)));
@@ -237,0 +266 @@
+#endif
@@ -240 +268,0 @@
-
@@ -325,0 +354,50 @@
+#ifdef CONFIG_VSX
+/*
+ * Currently to set and and get all the vsx state, you need to call
+ * the fp and VMX calls aswell.  This only get/sets the lower 32
+ * 128bit VSX registers.
+ */
+
+static int vsr_active(struct task_struct *target,
+		      const struct user_regset *regset)
+{
+	flush_vsx_to_thread(target);
+	return target->thread.used_vsr ? regset->n : 0;
+}
+
+static int vsr_get(struct task_struct *target, const struct user_regset *regset,
+		   unsigned int pos, unsigned int count,
+		   void *kbuf, void __user *ubuf)
+{
+	double buf[32];
+	int ret, i;
+
+	flush_vsx_to_thread(target);
+
+	for (i = 0; i < 32 ; i++)
+		buf[i] = target->thread.fpr[i][TS_VSRLOWOFFSET];
+	ret = user_regset_copyout(&pos, &count, &kbuf, &ubuf,
+				  buf, 0, 32 * sizeof(double));
+
+	return ret;
+}
+
+static int vsr_set(struct task_struct *target, const struct user_regset *regset,
+		   unsigned int pos, unsigned int count,
+		   const void *kbuf, const void __user *ubuf)
+{
+	double buf[32];
+	int ret,i;
+
+	flush_vsx_to_thread(target);
+
+	ret = user_regset_copyin(&pos, &count, &kbuf, &ubuf,
+				 buf, 0, 32 * sizeof(double));
+	for (i = 0; i < 32 ; i++)
+		target->thread.fpr[i][TS_VSRLOWOFFSET] = buf[i];
+
+
+	return ret;
+}
+#endif /* CONFIG_VSX */
+
@@ -401,0 +480,3 @@
+#ifdef CONFIG_VSX
+	REGSET_VSX,
+#endif
@@ -424,0 +506,7 @@
+#ifdef CONFIG_VSX
+	[REGSET_VSX] = {
+		.core_note_type = NT_PPC_VSX, .n = 32,
+		.size = sizeof(double), .align = sizeof(double),
+		.active = vsr_active, .get = vsr_get, .set = vsr_set
+	},
+#endif
@@ -619 +707 @@
-		task->thread.dbcr0 = DBCR0_IDM | DBCR0_IC;
+		task->thread.dbcr0 |= DBCR0_IDM | DBCR0_IC;
@@ -631,0 +720,7 @@
+
+#if defined(CONFIG_BOOKE)
+	/* If DAC then do not single step, skip */
+	if (task->thread.dabr)
+		return;
+#endif
+
@@ -634 +729 @@
-		task->thread.dbcr0 = 0;
+		task->thread.dbcr0 &= ~(DBCR0_IC | DBCR0_IDM);
@@ -643 +738 @@
-static int ptrace_set_debugreg(struct task_struct *task, unsigned long addr,
+int ptrace_set_debugreg(struct task_struct *task, unsigned long addr,
@@ -646 +741,4 @@
-	/* We only support one DABR and no IABRS at the moment */
+	/* For ppc64 we support one DABR and no IABR's at the moment (ppc64).
+	 *  For embedded processors we support one DAC and no IAC's at the
+	 *  moment.
+	 */
@@ -650 +748 @@
-	/* The bottom 3 bits are flags */
+	/* The bottom 3 bits in dabr are flags */
@@ -654 +752,15 @@
-	/* Ensure translation is on */
+#ifndef CONFIG_BOOKE
+
+	/* For processors using DABR (i.e. 970), the bottom 3 bits are flags.
+	 *  It was assumed, on previous implementations, that 3 bits were
+	 *  passed together with the data address, fitting the design of the
+	 *  DABR register, as follows:
+	 *
+	 *  bit 0: Read flag
+	 *  bit 1: Write flag
+	 *  bit 2: Breakpoint translation
+	 *
+	 *  Thus, we use them here as so.
+	 */
+
+	/* Ensure breakpoint translation bit is set */
@@ -657,0 +770 @@
+	/* Move contents to the DABR register */
@@ -658,0 +772,36 @@
+
+#endif
+#if defined(CONFIG_BOOKE)
+
+	/* As described above, it was assumed 3 bits were passed with the data
+	 *  address, but we will assume only the mode bits will be passed
+	 *  as to not cause alignment restrictions for DAC-based processors.
+	 */
+
+	/* DAC's hold the whole address without any mode flags */
+	task->thread.dabr = data & ~0x3UL;
+
+	if (task->thread.dabr == 0) {
+		task->thread.dbcr0 &= ~(DBSR_DAC1R | DBSR_DAC1W | DBCR0_IDM);
+		task->thread.regs->msr &= ~MSR_DE;
+		return 0;
+	}
+
+	/* Read or Write bits must be set */
+
+	if (!(data & 0x3UL))
+		return -EINVAL;
+
+	/* Set the Internal Debugging flag (IDM bit 1) for the DBCR0
+	   register */
+	task->thread.dbcr0 = DBCR0_IDM;
+
+	/* Check for write and read flags and set DBCR0
+	   accordingly */
+	if (data & 0x1UL)
+		task->thread.dbcr0 |= DBSR_DAC1R;
+	if (data & 0x2UL)
+		task->thread.dbcr0 |= DBSR_DAC1W;
+
+	task->thread.regs->msr |= MSR_DE;
+#endif
@@ -731 +880,2 @@
-			tmp = ((unsigned long *)child->thread.fpr)[index - PT_FPR0];
+			tmp = ((unsigned long *)child->thread.fpr)
+				[TS_FPRWIDTH * (index - PT_FPR0)];
@@ -758 +908,2 @@
-			((unsigned long *)child->thread.fpr)[index - PT_FPR0] = data;
+			((unsigned long *)child->thread.fpr)
+				[TS_FPRWIDTH * (index - PT_FPR0)] = data;
@@ -822,0 +974,13 @@
+#ifdef CONFIG_VSX
+	case PTRACE_GETVSRREGS:
+		return copy_regset_to_user(child, &user_ppc_native_view,
+					   REGSET_VSX,
+					   0, 32 * sizeof(double),
+					   (void __user *) data);
+
+	case PTRACE_SETVSRREGS:
+		return copy_regset_from_user(child, &user_ppc_native_view,
+					     REGSET_VSX,
+					     0, 32 * sizeof(double),
+					     (const void __user *) data);
+#endif
@@ -852 +1016,5 @@
-static void do_syscall_trace(void)
+/*
+ * We must return the syscall number to actually look up in the table.
+ * This can be -1L to skip running any syscall at all.
+ */
+long do_syscall_trace_enter(struct pt_regs *regs)
@@ -854,15 +1022 @@
-	/* the 0x80 provides a way for the tracing parent to distinguish
-	   between a syscall stop and SIGTRAP delivery */
-	ptrace_notify(SIGTRAP | ((current->ptrace & PT_TRACESYSGOOD)
-				 ? 0x80 : 0));
-
-	/*
-	 * this isn't the same as continuing with a signal, but it will do
-	 * for normal use.  strace only continues with a signal if the
-	 * stopping signal is not SIGTRAP.  -brl
-	 */
-	if (current->exit_code) {
-		send_sig(current->exit_code, current, 1);
-		current->exit_code = 0;
-	}
-}
+	long ret = 0;
@@ -870,2 +1023,0 @@
-void do_syscall_trace_enter(struct pt_regs *regs)
-{
@@ -874,3 +1026,8 @@
-	if (test_thread_flag(TIF_SYSCALL_TRACE)
-	    && (current->ptrace & PT_PTRACED))
-		do_syscall_trace();
+	if (test_thread_flag(TIF_SYSCALL_TRACE) &&
+	    tracehook_report_syscall_entry(regs))
+		/*
+		 * Tracing decided this syscall should not happen.
+		 * We'll return a bogus call number to get an ENOSYS
+		 * error, but leave the original number in regs->gpr[0].
+		 */
+		ret = -1L;
@@ -893,0 +1051,2 @@
+
+	return ret ?: regs->gpr[0];
@@ -897,0 +1057,2 @@
+	int step;
+
@@ -902,4 +1063,3 @@
-	if ((test_thread_flag(TIF_SYSCALL_TRACE)
-	     || test_thread_flag(TIF_SINGLESTEP))
-	    && (current->ptrace & PT_PTRACED))
-		do_syscall_trace();
+	step = test_thread_flag(TIF_SINGLESTEP);
+	if (step || test_thread_flag(TIF_SYSCALL_TRACE))
+		tracehook_report_syscall_exit(regs, step);
--- ./projects/linux/linux-2.6.15/arch/powerpc/platforms/pseries/iommu.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/arch/powerpc/platforms/pseries/iommu.c	2006-03-20 06:53:29.000000000 +0100
@@ -54,2 +53,0 @@
-extern int is_python(struct device_node *);
-
@@ -439 +437 @@
-	ppci = pdn->data;
+	ppci = PCI_DN(pdn);
@@ -486 +484 @@
-	while (dn && dn->data && PCI_DN(dn)->iommu_table == NULL)
+	while (dn && PCI_DN(dn) && PCI_DN(dn)->iommu_table == NULL)
@@ -489 +487 @@
-	if (dn && dn->data) {
+	if (dn && PCI_DN(dn)) {
@@ -500 +498 @@
-	struct pci_dn *pci = np->data;
+	struct pci_dn *pci = PCI_DN(np);
@@ -536 +534 @@
-	for (pdn = dn; pdn && pdn->data && !PCI_DN(pdn)->iommu_table;
+	for (pdn = dn; pdn && PCI_DN(pdn) && !PCI_DN(pdn)->iommu_table;
@@ -555 +553 @@
-	pci = pdn->data;
+	pci = PCI_DN(pdn);
--- ./projects/linux/linux-2.6.16/arch/powerpc/platforms/pseries/iommu.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/arch/powerpc/platforms/pseries/iommu.c	2006-06-18 03:49:35.000000000 +0200
@@ -2,2 +1,0 @@
- * arch/ppc64/kernel/pSeries_iommu.c
- *
@@ -585 +583 @@
-	if (platform_is_lpar()) {
+	if (firmware_has_feature(FW_FEATURE_LPAR)) {
--- ./projects/linux/linux-2.6.17/arch/powerpc/platforms/pseries/iommu.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/powerpc/platforms/pseries/iommu.c	2006-09-20 05:42:06.000000000 +0200
@@ -4 +4 @@
- * Rewrite, cleanup: 
+ * Rewrite, cleanup:
@@ -6,0 +7 @@
+ * Copyright (C) 2006 Olof Johansson <olof@lixom.net>
@@ -10 +11 @@
- * 
+ *
@@ -15 +16 @@
- * 
+ *
@@ -20 +21 @@
- * 
+ *
@@ -26 +26,0 @@
-#include <linux/config.h>
@@ -52,2 +52,2 @@
-static void tce_build_pSeries(struct iommu_table *tbl, long index, 
-			      long npages, unsigned long uaddr, 
+static void tce_build_pSeries(struct iommu_table *tbl, long index,
+			      long npages, unsigned long uaddr,
@@ -56,2 +56,3 @@
-	union tce_entry t;
-	union tce_entry *tp;
+	u64 proto_tce;
+	u64 *tcep;
+	u64 rpn;
@@ -62,2 +63 @@
-	t.te_word = 0;
-	t.te_rdwr = 1; // Read allowed 
+	proto_tce = TCE_PCI_READ; // Read allowed
@@ -66 +66 @@
-		t.te_pciwr = 1;
+		proto_tce |= TCE_PCI_WRITE;
@@ -68 +68 @@
-	tp = ((union tce_entry *)tbl->it_base) + index;
+	tcep = ((u64 *)tbl->it_base) + index;
@@ -72,3 +72,2 @@
-		t.te_rpn = (virt_to_abs(uaddr)) >> TCE_SHIFT;
-	
-		tp->te_word = t.te_word;
+		rpn = (virt_to_abs(uaddr)) >> TCE_SHIFT;
+		*tcep = proto_tce | (rpn & TCE_RPN_MASK) << TCE_RPN_SHIFT;
@@ -77 +76 @@
-		tp++;
+		tcep++;
@@ -84,2 +83 @@
-	union tce_entry t;
-	union tce_entry *tp;
+	u64 *tcep;
@@ -90,8 +88,4 @@
-	t.te_word = 0;
-	tp  = ((union tce_entry *)tbl->it_base) + index;
-		
-	while (npages--) {
-		tp->te_word = t.te_word;
-		
-		tp++;
-	}
+	tcep = ((u64 *)tbl->it_base) + index;
+
+	while (npages--)
+		*(tcep++) = 0;
@@ -99,0 +94,9 @@
+static unsigned long tce_get_pseries(struct iommu_table *tbl, long index)
+{
+	u64 *tcep;
+
+	index <<= TCE_PAGE_FACTOR;
+	tcep = ((u64 *)tbl->it_base) + index;
+
+	return *tcep;
+}
@@ -106 +109,2 @@
-	union tce_entry tce;
+	u64 proto_tce, tce;
+	u64 rpn;
@@ -111,3 +115,2 @@
-	tce.te_word = 0;
-	tce.te_rpn = (virt_to_abs(uaddr)) >> TCE_SHIFT;
-	tce.te_rdwr = 1;
+	rpn = (virt_to_abs(uaddr)) >> TCE_SHIFT;
+	proto_tce = TCE_PCI_READ;
@@ -115 +118 @@
-		tce.te_pciwr = 1;
+		proto_tce |= TCE_PCI_WRITE;
@@ -118,4 +121,3 @@
-		rc = plpar_tce_put((u64)tbl->it_index, 
-				   (u64)tcenum << 12, 
-				   tce.te_word );
-		
+		tce = proto_tce | (rpn & TCE_RPN_MASK) << TCE_RPN_SHIFT;
+		rc = plpar_tce_put((u64)tbl->it_index, (u64)tcenum << 12, tce);
+
@@ -126 +128 @@
-			printk("\ttce val = 0x%lx\n", tce.te_word );
+			printk("\ttce val = 0x%lx\n", tce );
@@ -129 +131 @@
-			
+
@@ -131 +133 @@
-		tce.te_rpn++;
+		rpn++;
@@ -135 +137 @@
-static DEFINE_PER_CPU(void *, tce_page) = NULL;
+static DEFINE_PER_CPU(u64 *, tce_page) = NULL;
@@ -142 +144,3 @@
-	union tce_entry tce, *tcep;
+	u64 proto_tce;
+	u64 *tcep;
+	u64 rpn;
@@ -155 +159 @@
-		tcep = (void *)__get_free_page(GFP_ATOMIC);
+		tcep = (u64 *)__get_free_page(GFP_ATOMIC);
@@ -166,3 +170,2 @@
-	tce.te_word = 0;
-	tce.te_rpn = (virt_to_abs(uaddr)) >> TCE_SHIFT;
-	tce.te_rdwr = 1;
+	rpn = (virt_to_abs(uaddr)) >> TCE_SHIFT;
+	proto_tce = TCE_PCI_READ;
@@ -170 +173 @@
-		tce.te_pciwr = 1;
+		proto_tce |= TCE_PCI_WRITE;
@@ -178 +181 @@
-		limit = min_t(long, npages, 4096/sizeof(union tce_entry));
+		limit = min_t(long, npages, 4096/TCE_ENTRY_SIZE);
@@ -181,2 +184,2 @@
-			tcep[l] = tce;
-			tce.te_rpn++;
+			tcep[l] = proto_tce | (rpn & TCE_RPN_MASK) << TCE_RPN_SHIFT;
+			rpn++;
@@ -198 +201 @@
-		printk("\ttce[0] val = 0x%lx\n", tcep[0].te_word);
+		printk("\ttce[0] val = 0x%lx\n", tcep[0]);
@@ -206 +208,0 @@
-	union tce_entry tce;
@@ -211,2 +212,0 @@
-	tce.te_word = 0;
-
@@ -214,3 +214 @@
-		rc = plpar_tce_put((u64)tbl->it_index,
-				   (u64)tcenum << 12,
-				   tce.te_word);
+		rc = plpar_tce_put((u64)tbl->it_index, (u64)tcenum << 12, 0);
@@ -222 +219,0 @@
-			printk("\ttce val = 0x%lx\n", tce.te_word );
@@ -234 +230,0 @@
-	union tce_entry tce;
@@ -239,6 +235 @@
-	tce.te_word = 0;
-
-	rc = plpar_tce_stuff((u64)tbl->it_index,
-			   (u64)tcenum << 12,
-			   tce.te_word,
-			   npages);
+	rc = plpar_tce_stuff((u64)tbl->it_index, (u64)tcenum << 12, 0, npages);
@@ -251 +241,0 @@
-		printk("\ttce val = 0x%lx\n", tce.te_word );
@@ -255,0 +246,19 @@
+static unsigned long tce_get_pSeriesLP(struct iommu_table *tbl, long tcenum)
+{
+	u64 rc;
+	unsigned long tce_ret;
+
+	tcenum <<= TCE_PAGE_FACTOR;
+	rc = plpar_tce_get((u64)tbl->it_index, (u64)tcenum << 12, &tce_ret);
+
+	if (rc && printk_ratelimit()) {
+		printk("tce_get_pSeriesLP: plpar_tce_get failed. rc=%ld\n",
+			rc);
+		printk("\tindex   = 0x%lx\n", (u64)tbl->it_index);
+		printk("\ttcenum  = 0x%lx\n", (u64)tcenum);
+		show_stack(current, (unsigned long *)__get_SP());
+	}
+
+	return tce_ret;
+}
+
@@ -258 +267 @@
-				 struct iommu_table *tbl) 
+				 struct iommu_table *tbl)
@@ -274,0 +284,2 @@
+
+#ifndef CONFIG_CRASH_DUMP
@@ -275,0 +287 @@
+#endif
@@ -278 +290 @@
-	
+
@@ -281 +293 @@
-	
+
@@ -285 +297 @@
-		panic("PCI_DMA: Unexpected number of IOAs under this PHB.\n"); 
+		panic("PCI_DMA: Unexpected number of IOAs under this PHB.\n");
@@ -287 +299 @@
-	
+
@@ -302,7 +313,0 @@
- *
- * ToDo: properly interpret the ibm,dma-window property.  The definition is:
- *	logical-bus-number	(1 word)
- *	phys-address		(#address-cells words)
- *	size			(#cell-size words)
- *
- * Currently we hard code these sizes (more or less).
@@ -313 +318 @@
-				      unsigned int *dma_window)
+				      unsigned char *dma_window)
@@ -314,0 +320,2 @@
+	unsigned long offset, size;
+
@@ -315,0 +323 @@
+	of_parse_dma_window(dn, dma_window, &tbl->it_index, &offset, &size);
@@ -317,5 +324,0 @@
-	/* TODO: Parse field size properties properly. */
-	tbl->it_size   = (((unsigned long)dma_window[4] << 32) |
-			   (unsigned long)dma_window[5]) >> PAGE_SHIFT;
-	tbl->it_offset = (((unsigned long)dma_window[2] << 32) |
-			   (unsigned long)dma_window[3]) >> PAGE_SHIFT;
@@ -323 +325,0 @@
-	tbl->it_index  = dma_window[0];
@@ -325,0 +328,2 @@
+	tbl->it_offset = offset >> PAGE_SHIFT;
+	tbl->it_size = size >> PAGE_SHIFT;
@@ -360,4 +364 @@
-	/* Count number of direct PCI children of the PHB.
-	 * All PCI device nodes have class-code property, so it's
-	 * an easy way to find them.
-	 */
+	/* Count number of direct PCI children of the PHB. */
@@ -365,2 +366 @@
-		if (get_property(tmp, "class-code", NULL))
-			children++;
+		children++;
@@ -397 +397,2 @@
-	tbl = kmalloc(sizeof(struct iommu_table), GFP_KERNEL);
+	tbl = kmalloc_node(sizeof(struct iommu_table), GFP_KERNEL,
+			   pci->phb->node);
@@ -400 +401 @@
-	pci->iommu_table = iommu_init_table(tbl);
+	pci->iommu_table = iommu_init_table(tbl, pci->phb->node);
@@ -417 +418 @@
-	unsigned int *dma_window = NULL;
+	unsigned char *dma_window = NULL;
@@ -425 +426 @@
-		dma_window = (unsigned int *)get_property(pdn, "ibm,dma-window", NULL);
+		dma_window = get_property(pdn, "ibm,dma-window", NULL);
@@ -443,3 +444,3 @@
-		tbl = (struct iommu_table *)kmalloc(sizeof(struct iommu_table),
-						    GFP_KERNEL);
-	
+		tbl = kmalloc_node(sizeof(struct iommu_table), GFP_KERNEL,
+				   ppci->phb->node);
+
@@ -448 +449 @@
-		ppci->iommu_table = iommu_init_table(tbl);
+		ppci->iommu_table = iommu_init_table(tbl, ppci->phb->node);
@@ -471 +472,2 @@
-		tbl = kmalloc(sizeof(struct iommu_table), GFP_KERNEL);
+		tbl = kmalloc_node(sizeof(struct iommu_table), GFP_KERNEL,
+				   PCI_DN(dn)->phb->node);
@@ -473 +475,2 @@
-		PCI_DN(mydn)->iommu_table = iommu_init_table(tbl);
+		PCI_DN(dn)->iommu_table = iommu_init_table(tbl,
+						PCI_DN(dn)->phb->node);
@@ -519 +522 @@
-	int *dma_window = NULL;
+	unsigned char *dma_window = NULL;
@@ -534,2 +537 @@
-		dma_window = (unsigned int *)
-			get_property(pdn, "ibm,dma-window", NULL);
+		dma_window = get_property(pdn, "ibm,dma-window", NULL);
@@ -556,2 +558,2 @@
-		tbl = (struct iommu_table *)kmalloc(sizeof(struct iommu_table),
-						    GFP_KERNEL);
+		tbl = kmalloc_node(sizeof(struct iommu_table), GFP_KERNEL,
+				   pci->phb->node);
@@ -561 +563 @@
-		pci->iommu_table = iommu_init_table(tbl);
+		pci->iommu_table = iommu_init_table(tbl, pci->phb->node);
@@ -590,0 +593 @@
+		ppc_md.tce_get   = tce_get_pSeriesLP;
@@ -595,0 +599 @@
+		ppc_md.tce_get   = tce_get_pseries;
--- ./projects/linux/linux-2.6.18/arch/powerpc/platforms/pseries/iommu.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/powerpc/platforms/pseries/iommu.c	2006-11-29 22:57:37.000000000 +0100
@@ -60,3 +59,0 @@
-	index <<= TCE_PAGE_FACTOR;
-	npages <<= TCE_PAGE_FACTOR;
-
@@ -85,3 +81,0 @@
-	npages <<= TCE_PAGE_FACTOR;
-	index <<= TCE_PAGE_FACTOR;
-
@@ -98 +91,0 @@
-	index <<= TCE_PAGE_FACTOR;
@@ -112,3 +104,0 @@
-	tcenum <<= TCE_PAGE_FACTOR;
-	npages <<= TCE_PAGE_FACTOR;
-
@@ -149 +139 @@
-	if (TCE_PAGE_FACTOR == 0 && npages == 1)
+	if (npages == 1)
@@ -167,3 +156,0 @@
-	tcenum <<= TCE_PAGE_FACTOR;
-	npages <<= TCE_PAGE_FACTOR;
-
@@ -210,3 +196,0 @@
-	tcenum <<= TCE_PAGE_FACTOR;
-	npages <<= TCE_PAGE_FACTOR;
-
@@ -232,3 +215,0 @@
-	tcenum <<= TCE_PAGE_FACTOR;
-	npages <<= TCE_PAGE_FACTOR;
-
@@ -251 +231,0 @@
-	tcenum <<= TCE_PAGE_FACTOR;
@@ -270,2 +250,2 @@
-	unsigned long *basep;
-	unsigned int *sizep;
+	const unsigned long *basep;
+	const u32 *sizep;
@@ -275,2 +255,2 @@
-	basep = (unsigned long *)get_property(node, "linux,tce-base", NULL);
-	sizep = (unsigned int *)get_property(node, "linux,tce-size", NULL);
+	basep = get_property(node, "linux,tce-base", NULL);
+	sizep = get_property(node, "linux,tce-size", NULL);
@@ -292 +272 @@
-	tbl->it_offset = phb->dma_window_base_cur >> PAGE_SHIFT;
+	tbl->it_offset = phb->dma_window_base_cur >> IOMMU_PAGE_SHIFT;
@@ -303 +283 @@
-	tbl->it_size = phb->dma_window_size >> PAGE_SHIFT;
+	tbl->it_size = phb->dma_window_size >> IOMMU_PAGE_SHIFT;
@@ -318 +298 @@
-				      unsigned char *dma_window)
+				      const void *dma_window)
@@ -328,2 +308,2 @@
-	tbl->it_offset = offset >> PAGE_SHIFT;
-	tbl->it_size = size >> PAGE_SHIFT;
+	tbl->it_offset = offset >> IOMMU_PAGE_SHIFT;
+	tbl->it_size = size >> IOMMU_PAGE_SHIFT;
@@ -418 +398 @@
-	unsigned char *dma_window = NULL;
+	const void *dma_window = NULL;
@@ -522 +502 @@
-	unsigned char *dma_window = NULL;
+	const void *dma_window = NULL;
@@ -525,2 +504,0 @@
-	DBG("iommu_dev_setup_pSeriesLP, dev %p (%s)\n", dev, pci_name(dev));
-
@@ -534,0 +513,3 @@
+	DBG("iommu_dev_setup_pSeriesLP, dev %p (%s) %s\n",
+	     dev, pci_name(dev), dn->full_name);
+
--- ./projects/linux/linux-2.6.19/arch/powerpc/platforms/pseries/iommu.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/arch/powerpc/platforms/pseries/iommu.c	2007-02-04 19:44:54.000000000 +0100
@@ -312 +312 @@
-static void iommu_bus_setup_pSeries(struct pci_bus *bus)
+static void pci_dma_bus_setup_pSeries(struct pci_bus *bus)
@@ -321,2 +320,0 @@
-	DBG("iommu_bus_setup_pSeries, bus %p, bus->self %p\n", bus, bus->self);
-
@@ -324 +322,2 @@
-	pci = PCI_DN(dn);
+
+	DBG("pci_dma_bus_setup_pSeries: setting up bus %s\n", dn->full_name);
@@ -331,0 +331 @@
+	pci = PCI_DN(dn);
@@ -393 +393 @@
-static void iommu_bus_setup_pSeriesLP(struct pci_bus *bus)
+static void pci_dma_bus_setup_pSeriesLP(struct pci_bus *bus)
@@ -400,2 +399,0 @@
-	DBG("iommu_bus_setup_pSeriesLP, bus %p, bus->self %p\n", bus, bus->self);
-
@@ -403,0 +402,2 @@
+	DBG("pci_dma_bus_setup_pSeriesLP: setting up bus %s\n", dn->full_name);
+
@@ -412 +412 @@
-		DBG("iommu_bus_setup_pSeriesLP: bus %s seems to have no ibm,dma-window property\n", dn->full_name);
+		DBG("  no ibm,dma-window property !\n");
@@ -416,0 +417,4 @@
+
+	DBG("  parent is %s, iommu_table: 0x%p\n",
+	    pdn->full_name, ppci->iommu_table);
+
@@ -429,0 +434 @@
+		DBG("  created table: %p\n", ppci->iommu_table);
@@ -437 +442 @@
-static void iommu_dev_setup_pSeries(struct pci_dev *dev)
+static void pci_dma_dev_setup_pSeries(struct pci_dev *dev)
@@ -439 +444 @@
-	struct device_node *dn, *mydn;
+	struct device_node *dn;
@@ -442 +447 @@
-	DBG("iommu_dev_setup_pSeries, dev %p (%s)\n", dev, pci_name(dev));
+	DBG("pci_dma_dev_setup_pSeries: %s\n", pci_name(dev));
@@ -444 +449 @@
-	mydn = dn = pci_device_to_OF_node(dev);
+	dn = dev->dev.archdata.of_node;
@@ -450,0 +456,2 @@
+		struct pci_controller *phb = PCI_DN(dn)->phb;
+
@@ -453,5 +460,4 @@
-				   PCI_DN(dn)->phb->node);
-		iommu_table_setparms(PCI_DN(dn)->phb, dn, tbl);
-		PCI_DN(dn)->iommu_table = iommu_init_table(tbl,
-						PCI_DN(dn)->phb->node);
-
+				   phb->node);
+		iommu_table_setparms(phb, dn, tbl);
+		PCI_DN(dn)->iommu_table = iommu_init_table(tbl, phb->node);
+		dev->dev.archdata.dma_data = PCI_DN(dn)->iommu_table;
@@ -468,5 +474,5 @@
-	if (dn && PCI_DN(dn)) {
-		PCI_DN(mydn)->iommu_table = PCI_DN(dn)->iommu_table;
-	} else {
-		DBG("iommu_dev_setup_pSeries, dev %p (%s) has no iommu table\n", dev, pci_name(dev));
-	}
+	if (dn && PCI_DN(dn))
+		dev->dev.archdata.dma_data = PCI_DN(dn)->iommu_table;
+	else
+		printk(KERN_WARNING "iommu: Device %s has no iommu table\n",
+		       pci_name(dev));
@@ -498 +504 @@
-static void iommu_dev_setup_pSeriesLP(struct pci_dev *dev)
+static void pci_dma_dev_setup_pSeriesLP(struct pci_dev *dev)
@@ -504,0 +511,2 @@
+	DBG("pci_dma_dev_setup_pSeriesLP: %s\n", pci_name(dev));
+
@@ -512,3 +520 @@
-
-	DBG("iommu_dev_setup_pSeriesLP, dev %p (%s) %s\n",
-	     dev, pci_name(dev), dn->full_name);
+	DBG("  node is %s\n", dn->full_name);
@@ -522,0 +529,2 @@
+	DBG("  parent is %s\n", pdn->full_name);
+
@@ -527,2 +535,2 @@
-		DBG("No dma window for device, linking to parent\n");
-		PCI_DN(dn)->iommu_table = PCI_DN(pdn)->iommu_table;
+		DBG("  no dma window for device, linking to parent\n");
+		dev->dev.archdata.dma_data = PCI_DN(pdn)->iommu_table;
@@ -530,2 +537,0 @@
-	} else {
-		DBG("Found DMA window, allocating table\n");
@@ -532,0 +539 @@
+	DBG("  found DMA window, table: %p\n", pci->iommu_table);
@@ -544,0 +552 @@
+		DBG("  created table: %p\n", pci->iommu_table);
@@ -547,2 +555 @@
-	if (pdn != dn)
-		PCI_DN(dn)->iommu_table = pci->iommu_table;
+	dev->dev.archdata.dma_data = pci->iommu_table;
@@ -551,3 +557,0 @@
-static void iommu_bus_setup_null(struct pci_bus *b) { }
-static void iommu_dev_setup_null(struct pci_dev *d) { }
-
@@ -559,4 +563,3 @@
-		ppc_md.iommu_dev_setup = iommu_dev_setup_null;
-		ppc_md.iommu_bus_setup = iommu_bus_setup_null;
-		pci_direct_iommu_init();
-
+		ppc_md.pci_dma_dev_setup = NULL;
+		ppc_md.pci_dma_bus_setup = NULL;
+		pci_dma_ops = &dma_direct_ops;
@@ -575,2 +578,2 @@
-		ppc_md.iommu_bus_setup = iommu_bus_setup_pSeriesLP;
-		ppc_md.iommu_dev_setup = iommu_dev_setup_pSeriesLP;
+		ppc_md.pci_dma_bus_setup = pci_dma_bus_setup_pSeriesLP;
+		ppc_md.pci_dma_dev_setup = pci_dma_dev_setup_pSeriesLP;
@@ -581,2 +584,2 @@
-		ppc_md.iommu_bus_setup = iommu_bus_setup_pSeries;
-		ppc_md.iommu_dev_setup = iommu_dev_setup_pSeries;
+		ppc_md.pci_dma_bus_setup = pci_dma_bus_setup_pSeries;
+		ppc_md.pci_dma_dev_setup = pci_dma_dev_setup_pSeries;
@@ -588 +591 @@
-	pci_iommu_init();
+	pci_dma_ops = &dma_iommu_ops;
--- ./projects/linux/linux-2.6.21/arch/powerpc/platforms/pseries/iommu.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/arch/powerpc/platforms/pseries/iommu.c	2007-07-09 01:32:17.000000000 +0200
@@ -244,0 +245 @@
+#ifdef CONFIG_PCI
@@ -255,2 +256,2 @@
-	basep = get_property(node, "linux,tce-base", NULL);
-	sizep = get_property(node, "linux,tce-size", NULL);
+	basep = of_get_property(node, "linux,tce-base", NULL);
+	sizep = of_get_property(node, "linux,tce-size", NULL);
@@ -406 +407 @@
-		dma_window = get_property(pdn, "ibm,dma-window", NULL);
+		dma_window = of_get_property(pdn, "ibm,dma-window", NULL);
@@ -481,23 +481,0 @@
-static int iommu_reconfig_notifier(struct notifier_block *nb, unsigned long action, void *node)
-{
-	int err = NOTIFY_OK;
-	struct device_node *np = node;
-	struct pci_dn *pci = PCI_DN(np);
-
-	switch (action) {
-	case PSERIES_RECONFIG_REMOVE:
-		if (pci && pci->iommu_table &&
-		    get_property(np, "ibm,dma-window", NULL))
-			iommu_free_table(np);
-		break;
-	default:
-		err = NOTIFY_DONE;
-		break;
-	}
-	return err;
-}
-
-static struct notifier_block iommu_reconfig_nb = {
-	.notifier_call = iommu_reconfig_notifier,
-};
-
@@ -524 +502 @@
-		dma_window = get_property(pdn, "ibm,dma-window", NULL);
+		dma_window = of_get_property(pdn, "ibm,dma-window", NULL);
@@ -528,0 +507,6 @@
+	if (!pdn || !PCI_DN(pdn)) {
+		printk(KERN_WARNING "pci_dma_dev_setup_pSeriesLP: "
+		       "no DMA window found for pci dev=%s dn=%s\n",
+				 pci_name(dev), dn? dn->full_name : "<null>");
+		return;
+	}
@@ -539 +522,0 @@
-	DBG("  found DMA window, table: %p\n", pci->iommu_table);
@@ -552,0 +536,2 @@
+	} else {
+		DBG("  found DMA window, table: %p\n", pci->iommu_table);
@@ -556,0 +542,29 @@
+#else  /* CONFIG_PCI */
+#define pci_dma_bus_setup_pSeries	NULL
+#define pci_dma_dev_setup_pSeries	NULL
+#define pci_dma_bus_setup_pSeriesLP	NULL
+#define pci_dma_dev_setup_pSeriesLP	NULL
+#endif /* !CONFIG_PCI */
+
+static int iommu_reconfig_notifier(struct notifier_block *nb, unsigned long action, void *node)
+{
+	int err = NOTIFY_OK;
+	struct device_node *np = node;
+	struct pci_dn *pci = PCI_DN(np);
+
+	switch (action) {
+	case PSERIES_RECONFIG_REMOVE:
+		if (pci && pci->iommu_table &&
+		    of_get_property(np, "ibm,dma-window", NULL))
+			iommu_free_table(np);
+		break;
+	default:
+		err = NOTIFY_DONE;
+		break;
+	}
+	return err;
+}
+
+static struct notifier_block iommu_reconfig_nb = {
+	.notifier_call = iommu_reconfig_notifier,
+};
@@ -561 +575 @@
-	if (of_chosen && get_property(of_chosen, "linux,iommu-off", NULL)) {
+	if (of_chosen && of_get_property(of_chosen, "linux,iommu-off", NULL)) {
@@ -565 +579 @@
-		pci_dma_ops = &dma_direct_ops;
+		set_pci_dma_ops(&dma_direct_ops);
@@ -591 +605 @@
-	pci_dma_ops = &dma_iommu_ops;
+	set_pci_dma_ops(&dma_iommu_ops);
--- ./projects/linux/linux-2.6.24/arch/powerpc/platforms/pseries/iommu.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/powerpc/platforms/pseries/iommu.c	2008-04-17 04:49:44.000000000 +0200
@@ -254 +254 @@
-	node = (struct device_node *)phb->arch_data;
+	node = phb->dn;
@@ -299 +299,2 @@
-				      const void *dma_window)
+				      const void *dma_window,
+				      int bussubno)
@@ -303 +304 @@
-	tbl->it_busno  = PCI_DN(dn)->bussubno;
+	tbl->it_busno  = bussubno;
@@ -423,6 +423,0 @@
-		/* Bussubno hasn't been copied yet.
-		 * Do it now because iommu_table_setparms_lpar needs it.
-		 */
-
-		ppci->bussubno = bus->number;
-
@@ -431,3 +426,2 @@
-
-		iommu_table_setparms_lpar(ppci->phb, pdn, tbl, dma_window);
-
+		iommu_table_setparms_lpar(ppci->phb, pdn, tbl, dma_window,
+			bus->number);
@@ -526,3 +519,0 @@
-		/* iommu_table_setparms_lpar needs bussubno. */
-		pci->bussubno = pci->phb->bus->number;
-
@@ -531,3 +522,2 @@
-
-		iommu_table_setparms_lpar(pci->phb, pdn, tbl, dma_window);
-
+		iommu_table_setparms_lpar(pci->phb, pdn, tbl, dma_window,
+			pci->phb->bus->number);
@@ -559 +549 @@
-			iommu_free_table(np);
+			iommu_free_table(pci->iommu_table, np->full_name);
--- ./projects/linux/linux-2.6.25/arch/powerpc/platforms/pseries/iommu.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/arch/powerpc/platforms/pseries/iommu.c	2008-07-13 23:51:29.000000000 +0200
@@ -50 +49,0 @@
-#define DBG(fmt...)
@@ -325 +324 @@
-	DBG("pci_dma_bus_setup_pSeries: setting up bus %s\n", dn->full_name);
+	pr_debug("pci_dma_bus_setup_pSeries: setting up bus %s\n", dn->full_name);
@@ -350 +349 @@
-	DBG("Children: %d\n", children);
+	pr_debug("Children: %d\n", children);
@@ -364,2 +363,2 @@
-		DBG("No ISA/IDE, window size is 0x%lx\n",
-			pci->phb->dma_window_size);
+		pr_debug("No ISA/IDE, window size is 0x%lx\n",
+			 pci->phb->dma_window_size);
@@ -390,2 +389 @@
-	DBG("ISA/IDE, window size is 0x%lx\n", pci->phb->dma_window_size);
-
+	pr_debug("ISA/IDE, window size is 0x%lx\n", pci->phb->dma_window_size);
@@ -404 +402,2 @@
-	DBG("pci_dma_bus_setup_pSeriesLP: setting up bus %s\n", dn->full_name);
+	pr_debug("pci_dma_bus_setup_pSeriesLP: setting up bus %s\n",
+		 dn->full_name);
@@ -414 +413 @@
-		DBG("  no ibm,dma-window property !\n");
+		pr_debug("  no ibm,dma-window property !\n");
@@ -420,2 +419,2 @@
-	DBG("  parent is %s, iommu_table: 0x%p\n",
-	    pdn->full_name, ppci->iommu_table);
+	pr_debug("  parent is %s, iommu_table: 0x%p\n",
+		 pdn->full_name, ppci->iommu_table);
@@ -429 +428 @@
-		DBG("  created table: %p\n", ppci->iommu_table);
+		pr_debug("  created table: %p\n", ppci->iommu_table);
@@ -442 +441 @@
-	DBG("pci_dma_dev_setup_pSeries: %s\n", pci_name(dev));
+	pr_debug("pci_dma_dev_setup_pSeries: %s\n", pci_name(dev));
@@ -453 +452 @@
-		DBG(" --> first child, no bridge. Allocating iommu table.\n");
+		pr_debug(" --> first child, no bridge. Allocating iommu table.\n");
@@ -483 +482 @@
-	DBG("pci_dma_dev_setup_pSeriesLP: %s\n", pci_name(dev));
+	pr_debug("pci_dma_dev_setup_pSeriesLP: %s\n", pci_name(dev));
@@ -492 +491 @@
-	DBG("  node is %s\n", dn->full_name);
+	pr_debug("  node is %s\n", dn->full_name);
@@ -507 +506 @@
-	DBG("  parent is %s\n", pdn->full_name);
+	pr_debug("  parent is %s\n", pdn->full_name);
@@ -513 +512 @@
-		DBG("  no dma window for device, linking to parent\n");
+		pr_debug("  no dma window for device, linking to parent\n");
@@ -525 +524 @@
-		DBG("  created table: %p\n", pci->iommu_table);
+		pr_debug("  created table: %p\n", pci->iommu_table);
@@ -527 +526 @@
-		DBG("  found DMA window, table: %p\n", pci->iommu_table);
+		pr_debug("  found DMA window, table: %p\n", pci->iommu_table);
--- ./projects/linux/linux-2.6.26/arch/powerpc/platforms/pseries/iommu.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/arch/powerpc/platforms/pseries/iommu.c	2008-10-10 00:13:53.000000000 +0200
@@ -51 +51 @@
-static void tce_build_pSeries(struct iommu_table *tbl, long index,
+static int tce_build_pSeries(struct iommu_table *tbl, long index,
@@ -53 +53,2 @@
-			      enum dma_data_direction direction)
+			      enum dma_data_direction direction,
+			      struct dma_attrs *attrs)
@@ -73,0 +75 @@
+	return 0;
@@ -96 +98,4 @@
-static void tce_build_pSeriesLP(struct iommu_table *tbl, long tcenum,
+static void tce_free_pSeriesLP(struct iommu_table*, long, long);
+static void tce_freemulti_pSeriesLP(struct iommu_table*, long, long);
+
+static int tce_build_pSeriesLP(struct iommu_table *tbl, long tcenum,
@@ -98 +103,2 @@
-				enum dma_data_direction direction)
+				enum dma_data_direction direction,
+				struct dma_attrs *attrs)
@@ -100 +106 @@
-	u64 rc;
+	u64 rc = 0;
@@ -102,0 +109,2 @@
+	int ret = 0;
+	long tcenum_start = tcenum, npages_start = npages;
@@ -112,0 +121,7 @@
+		if (unlikely(rc == H_NOT_ENOUGH_RESOURCES)) {
+			ret = (int)rc;
+			tce_free_pSeriesLP(tbl, tcenum_start,
+			                   (npages_start - (npages + 1)));
+			break;
+		}
+
@@ -123,0 +139 @@
+	return ret;
@@ -128 +144 @@
-static void tce_buildmulti_pSeriesLP(struct iommu_table *tbl, long tcenum,
+static int tce_buildmulti_pSeriesLP(struct iommu_table *tbl, long tcenum,
@@ -130 +146,2 @@
-				     enum dma_data_direction direction)
+				     enum dma_data_direction direction,
+				     struct dma_attrs *attrs)
@@ -132 +149 @@
-	u64 rc;
+	u64 rc = 0;
@@ -136,0 +154,2 @@
+	long tcenum_start = tcenum, npages_start = npages;
+	int ret = 0;
@@ -138 +157 @@
-	if (npages == 1)
+	if (npages == 1) {
@@ -140 +159,2 @@
-					   direction);
+		                           direction, attrs);
+	}
@@ -150,3 +170,4 @@
-		if (!tcep)
-			return tce_build_pSeriesLP(tbl, tcenum, npages,
-						   uaddr, direction);
+		if (!tcep) {
+			return tce_build_pSeriesLP(tbl, tcenum, npages, uaddr,
+					    direction, attrs);
+		}
@@ -182,0 +204,7 @@
+	if (unlikely(rc == H_NOT_ENOUGH_RESOURCES)) {
+		ret = (int)rc;
+		tce_freemulti_pSeriesLP(tbl, tcenum_start,
+		                        (npages_start - (npages + limit)));
+		return ret;
+	}
+
@@ -189,0 +218 @@
+	return ret;
--- ./projects/linux/linux-2.6.27/arch/powerpc/platforms/pseries/iommu.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/arch/powerpc/platforms/pseries/iommu.c	2008-12-25 00:26:37.000000000 +0100
@@ -34,0 +35 @@
+#include <linux/crash_dump.h>
@@ -294,3 +295,2 @@
-#ifndef CONFIG_CRASH_DUMP
-	memset((void *)tbl->it_base, 0, *sizep);
-#endif
+	if (!is_kdump_kernel())
+		memset((void *)tbl->it_base, 0, *sizep);
--- ./projects/linux/linux-2.6.28/arch/powerpc/platforms/pseries/iommu.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/arch/powerpc/platforms/pseries/iommu.c	2009-03-24 00:12:14.000000000 +0100
@@ -130,4 +130,4 @@
-			printk("tce_build_pSeriesLP: plpar_tce_put failed. rc=%ld\n", rc);
-			printk("\tindex   = 0x%lx\n", (u64)tbl->it_index);
-			printk("\ttcenum  = 0x%lx\n", (u64)tcenum);
-			printk("\ttce val = 0x%lx\n", tce );
+			printk("tce_build_pSeriesLP: plpar_tce_put failed. rc=%lld\n", rc);
+			printk("\tindex   = 0x%llx\n", (u64)tbl->it_index);
+			printk("\ttcenum  = 0x%llx\n", (u64)tcenum);
+			printk("\ttce val = 0x%llx\n", tce );
@@ -213,4 +213,4 @@
-		printk("tce_buildmulti_pSeriesLP: plpar_tce_put failed. rc=%ld\n", rc);
-		printk("\tindex   = 0x%lx\n", (u64)tbl->it_index);
-		printk("\tnpages  = 0x%lx\n", (u64)npages);
-		printk("\ttce[0] val = 0x%lx\n", tcep[0]);
+		printk("tce_buildmulti_pSeriesLP: plpar_tce_put failed. rc=%lld\n", rc);
+		printk("\tindex   = 0x%llx\n", (u64)tbl->it_index);
+		printk("\tnpages  = 0x%llx\n", (u64)npages);
+		printk("\ttce[0] val = 0x%llx\n", tcep[0]);
@@ -230,3 +230,3 @@
-			printk("tce_free_pSeriesLP: plpar_tce_put failed. rc=%ld\n", rc);
-			printk("\tindex   = 0x%lx\n", (u64)tbl->it_index);
-			printk("\ttcenum  = 0x%lx\n", (u64)tcenum);
+			printk("tce_free_pSeriesLP: plpar_tce_put failed. rc=%lld\n", rc);
+			printk("\tindex   = 0x%llx\n", (u64)tbl->it_index);
+			printk("\ttcenum  = 0x%llx\n", (u64)tcenum);
@@ -249,3 +249,3 @@
-		printk("\trc      = %ld\n", rc);
-		printk("\tindex   = 0x%lx\n", (u64)tbl->it_index);
-		printk("\tnpages  = 0x%lx\n", (u64)npages);
+		printk("\trc      = %lld\n", rc);
+		printk("\tindex   = 0x%llx\n", (u64)tbl->it_index);
+		printk("\tnpages  = 0x%llx\n", (u64)npages);
@@ -264,4 +264,3 @@
-		printk("tce_get_pSeriesLP: plpar_tce_get failed. rc=%ld\n",
-			rc);
-		printk("\tindex   = 0x%lx\n", (u64)tbl->it_index);
-		printk("\ttcenum  = 0x%lx\n", (u64)tcenum);
+		printk("tce_get_pSeriesLP: plpar_tce_get failed. rc=%lld\n", rc);
+		printk("\tindex   = 0x%llx\n", (u64)tbl->it_index);
+		printk("\ttcenum  = 0x%llx\n", (u64)tcenum);
--- ./projects/linux/linux-2.6.14/arch/ppc/4xx_io/serial_sicc.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/arch/ppc/4xx_io/serial_sicc.c	2006-01-03 04:21:10.000000000 +0100
@@ -1148,2 +1148,2 @@
-    state->close_delay = new_serial.close_delay * HZ / 100;
-    state->closing_wait = new_serial.closing_wait * HZ / 100;
+    state->close_delay = msecs_to_jiffies(10 * new_serial.close_delay);
+    state->closing_wait = msecs_to_jiffies(10 * new_serial.closing_wait);
@@ -1468,4 +1468,2 @@
-        if (info->state->close_delay) {
-            set_current_state(TASK_INTERRUPTIBLE);
-            schedule_timeout(info->state->close_delay);
-        }
+        if (info->state->close_delay)
+            schedule_timeout_interruptible(info->state->close_delay);
@@ -1499 +1497 @@
-    char_time = (info->timeout - HZ/50) / info->port->fifosize;
+    char_time = (info->timeout - msecs_to_jiffies(20)) / info->port->fifosize;
@@ -1524,2 +1522 @@
-        set_current_state(TASK_INTERRUPTIBLE);
-        schedule_timeout(char_time);
+        schedule_timeout_interruptible(char_time);
@@ -1776 +1773 @@
-        state->close_delay  = 5 * HZ / 10;
+        state->close_delay  = msecs_to_jiffies(500);
--- ./projects/linux/linux-2.6.15/arch/ppc/4xx_io/serial_sicc.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/arch/ppc/4xx_io/serial_sicc.c	2006-03-20 06:53:29.000000000 +0100
@@ -49,0 +50 @@
+#include <linux/capability.h>
@@ -217 +217,0 @@
-static DECLARE_MUTEX(tmp_buf_sem);
--- ./projects/linux/linux-2.6.16/arch/ppc/4xx_io/serial_sicc.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/arch/ppc/4xx_io/serial_sicc.c	2006-06-18 03:49:35.000000000 +0200
@@ -2,2 +1,0 @@
- *  arch/ppc/4xx_io/serial_sicc.c
- *
@@ -1642 +1640 @@
-    info = kmalloc(sizeof(struct SICC_info), GFP_KERNEL);
+    info = kzalloc(sizeof(struct SICC_info), GFP_KERNEL);
@@ -1644 +1641,0 @@
-        memset(info, 0, sizeof(struct SICC_info));
--- ./projects/linux/linux-2.6.17/arch/ppc/4xx_io/serial_sicc.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/ppc/4xx_io/serial_sicc.c	2006-09-20 05:42:06.000000000 +0200
@@ -31 +30,0 @@
-#include <linux/config.h>
@@ -1761 +1760 @@
-    siccnormal_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
+    siccnormal_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
--- ./projects/linux/linux-2.6.18/arch/ppc/4xx_io/serial_sicc.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/ppc/4xx_io/serial_sicc.c	2006-11-29 22:57:37.000000000 +0100
@@ -417 +417 @@
-siccuart_rx_chars(struct SICC_info *info, struct pt_regs *regs)
+siccuart_rx_chars(struct SICC_info *info)
@@ -444 +444 @@
-                handle_sysrq(ch, regs, NULL);
+                handle_sysrq(ch, NULL);
@@ -556 +556 @@
-static irqreturn_t siccuart_int_rx(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t siccuart_int_rx(int irq, void *dev_id)
@@ -559 +559 @@
-    siccuart_rx_chars(info, regs);
+    siccuart_rx_chars(info)
@@ -564 +564 @@
-static irqreturn_t siccuart_int_tx(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t siccuart_int_tx(int irq, void *dev_id)
@@ -1723 +1723 @@
-static struct tty_operations sicc_ops = {
+static const struct tty_operations sicc_ops = {
--- ./projects/linux/linux-2.6.21/arch/ppc/4xx_io/serial_sicc.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/arch/ppc/4xx_io/serial_sicc.c	2007-07-09 01:32:17.000000000 +0200
@@ -6 +6 @@
- *  Copyright 2001 IBM Crop.
+ *  Copyright 2001 IBM Corp.
@@ -158 +158 @@
-#define _TxCR_ET_MASK   0x80           /* transmiter enable mask */
+#define _TxCR_ET_MASK   0x80           /* transmitter enable mask */
@@ -165,3 +165,3 @@
-#define _TxCR_ET_ENABLE _TxCR_ET_MASK  /* transmiter enabled */
-#define _TxCR_DME_DISABLE 0x00         /* transmiter disabled, TBR intr disabled */
-#define _TxCR_DME_TBR   0x20           /* transmiter disabled, TBR intr enabled */
+#define _TxCR_ET_ENABLE _TxCR_ET_MASK  /* transmitter enabled */
+#define _TxCR_DME_DISABLE 0x00         /* transmitter disabled, TBR intr disabled */
+#define _TxCR_DME_TBR   0x20           /* transmitter disabled, TBR intr enabled */
--- ./projects/linux/linux-2.6.14/arch/ppc/kernel/process.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/arch/ppc/kernel/process.c	2006-01-03 04:21:10.000000000 +0100
@@ -155,3 +155,5 @@
-#ifdef CONFIG_ALTIVEC
-int
-dump_altivec(struct pt_regs *regs, elf_vrregset_t *vrregs)
+/*
+ * Make sure the floating-point register state in the
+ * the thread_struct is up to date for task tsk.
+ */
+void flush_fp_to_thread(struct task_struct *tsk)
@@ -159,3 +161,49 @@
-	if (regs->msr & MSR_VEC)
-		giveup_altivec(current);
-	memcpy(vrregs, &current->thread.vr[0], sizeof(*vrregs));
+	if (tsk->thread.regs) {
+		/*
+		 * We need to disable preemption here because if we didn't,
+		 * another process could get scheduled after the regs->msr
+		 * test but before we have finished saving the FP registers
+		 * to the thread_struct.  That process could take over the
+		 * FPU, and then when we get scheduled again we would store
+		 * bogus values for the remaining FP registers.
+		 */
+		preempt_disable();
+		if (tsk->thread.regs->msr & MSR_FP) {
+#ifdef CONFIG_SMP
+			/*
+			 * This should only ever be called for current or
+			 * for a stopped child process.  Since we save away
+			 * the FP register state on context switch on SMP,
+			 * there is something wrong if a stopped child appears
+			 * to still have its FP state in the CPU registers.
+			 */
+			BUG_ON(tsk != current);
+#endif
+			giveup_fpu(current);
+		}
+		preempt_enable();
+	}
+}
+
+void enable_kernel_fp(void)
+{
+	WARN_ON(preemptible());
+
+#ifdef CONFIG_SMP
+	if (current->thread.regs && (current->thread.regs->msr & MSR_FP))
+		giveup_fpu(current);
+	else
+		giveup_fpu(NULL);	/* just enables FP for kernel */
+#else
+	giveup_fpu(last_task_used_math);
+#endif /* CONFIG_SMP */
+}
+EXPORT_SYMBOL(enable_kernel_fp);
+
+int dump_task_fpu(struct task_struct *tsk, elf_fpregset_t *fpregs)
+{
+	preempt_disable();
+	if (tsk->thread.regs && (tsk->thread.regs->msr & MSR_FP))
+		giveup_fpu(tsk);
+	preempt_enable();
+	memcpy(fpregs, &tsk->thread.fpr[0], sizeof(*fpregs));
@@ -165,2 +213,2 @@
-void
-enable_kernel_altivec(void)
+#ifdef CONFIG_ALTIVEC
+void enable_kernel_altivec(void)
@@ -180 +227,0 @@
-#endif /* CONFIG_ALTIVEC */
@@ -182,3 +229,5 @@
-#ifdef CONFIG_SPE
-int
-dump_spe(struct pt_regs *regs, elf_vrregset_t *evrregs)
+/*
+ * Make sure the VMX/Altivec register state in the
+ * the thread_struct is up to date for task tsk.
+ */
+void flush_altivec_to_thread(struct task_struct *tsk)
@@ -186,4 +235,17 @@
-	if (regs->msr & MSR_SPE)
-		giveup_spe(current);
-	/* We copy u32 evr[32] + u64 acc + u32 spefscr -> 35 */
-	memcpy(evrregs, &current->thread.evr[0], sizeof(u32) * 35);
+	if (tsk->thread.regs) {
+		preempt_disable();
+		if (tsk->thread.regs->msr & MSR_VEC) {
+#ifdef CONFIG_SMP
+			BUG_ON(tsk != current);
+#endif
+			giveup_altivec(current);
+		}
+		preempt_enable();
+	}
+}
+
+int dump_altivec(struct pt_regs *regs, elf_vrregset_t *vrregs)
+{
+	if (regs->msr & MSR_VEC)
+		giveup_altivec(current);
+	memcpy(vrregs, &current->thread.vr[0], sizeof(*vrregs));
@@ -191,0 +254 @@
+#endif /* CONFIG_ALTIVEC */
@@ -192,0 +256 @@
+#ifdef CONFIG_SPE
@@ -208 +271,0 @@
-#endif /* CONFIG_SPE */
@@ -210,2 +273 @@
-void
-enable_kernel_fp(void)
+void flush_spe_to_thread(struct task_struct *tsk)
@@ -213,2 +275,3 @@
-	WARN_ON(preemptible());
-
+	if (tsk->thread.regs) {
+		preempt_disable();
+		if (tsk->thread.regs->msr & MSR_SPE) {
@@ -216,7 +279,6 @@
-	if (current->thread.regs && (current->thread.regs->msr & MSR_FP))
-		giveup_fpu(current);
-	else
-		giveup_fpu(NULL);	/* just enables FP for kernel */
-#else
-	giveup_fpu(last_task_used_math);
-#endif /* CONFIG_SMP */
+			BUG_ON(tsk != current);
+#endif
+			giveup_spe(current);
+		}
+		preempt_enable();
+	}
@@ -224 +285,0 @@
-EXPORT_SYMBOL(enable_kernel_fp);
@@ -226,2 +287 @@
-int
-dump_task_fpu(struct task_struct *tsk, elf_fpregset_t *fpregs)
+int dump_spe(struct pt_regs *regs, elf_vrregset_t *evrregs)
@@ -229,5 +289,4 @@
-	preempt_disable();
-	if (tsk->thread.regs && (tsk->thread.regs->msr & MSR_FP))
-		giveup_fpu(tsk);
-	preempt_enable();
-	memcpy(fpregs, &tsk->thread.fpr[0], sizeof(*fpregs));
+	if (regs->msr & MSR_SPE)
+		giveup_spe(current);
+	/* We copy u32 evr[32] + u64 acc + u32 spefscr -> 35 */
+	memcpy(evrregs, &current->thread.evr[0], sizeof(u32) * 35);
@@ -235,0 +295 @@
+#endif /* CONFIG_SPE */
@@ -289,0 +350 @@
+#ifdef CONFIG_ALTIVEC
@@ -294,0 +356 @@
+#endif
@@ -357,0 +420 @@
+	preempt_disable();
@@ -365,0 +429 @@
+	preempt_enable();
@@ -369,0 +434 @@
+	preempt_disable();
@@ -377,0 +443 @@
+	preempt_enable();
@@ -475,0 +542 @@
+	preempt_disable();
@@ -483,0 +551 @@
+	preempt_enable();
@@ -485 +553 @@
-	current->thread.fpscr = 0;
+	current->thread.fpscr.val = 0;
@@ -560 +628,2 @@
-int sys_fork(int p1, int p2, int p3, int p4, int p5, int p6,
+int sys_fork(unsigned long p1, unsigned long p2, unsigned long p3,
+	     unsigned long p4, unsigned long p5, unsigned long p6,
@@ -567 +636,2 @@
-int sys_vfork(int p1, int p2, int p3, int p4, int p5, int p6,
+int sys_vfork(unsigned long p1, unsigned long p2, unsigned long p3,
+	      unsigned long p4, unsigned long p5, unsigned long p6,
--- ./projects/linux/linux-2.6.13/arch/s390/kernel/debug.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/arch/s390/kernel/debug.c	2005-10-28 02:02:08.000000000 +0200
@@ -65 +65 @@
-extern void tod_to_timeval(uint64_t todval, struct timeval *xtime);
+extern void tod_to_timeval(uint64_t todval, struct timespec *xtime);
@@ -376,0 +377,17 @@
+        unsigned long flags;
+
+	/* get a consistent copy of the debug areas */
+	do {
+		rc = debug_info_alloc(in->name, in->pages_per_area,
+			in->nr_areas, in->buf_size, in->level, mode);
+		spin_lock_irqsave(&in->lock, flags);
+		if(!rc)
+			goto out;
+		/* has something changed in the meantime ? */
+		if((rc->pages_per_area == in->pages_per_area) &&
+		   (rc->nr_areas == in->nr_areas)) {
+			break;
+		}
+		spin_unlock_irqrestore(&in->lock, flags);
+		debug_info_free(rc);
+	} while (1);
@@ -378,2 +394,0 @@
-        rc = debug_info_alloc(in->name, in->pages_per_area, in->nr_areas,
-				in->buf_size, in->level, mode);
@@ -388,0 +404 @@
+        spin_unlock_irqrestore(&in->lock, flags);
@@ -596,11 +612,8 @@
-
-	/* find debug log and view */
-	debug_info = debug_area_first;
-	while(debug_info != NULL){
-		for (i = 0; i < DEBUG_MAX_VIEWS; i++) {
-			if (!debug_info->views[i])
-				continue;
-			else if (debug_info->debugfs_entries[i] ==
-				 file->f_dentry) {
-				goto found;	/* found view ! */
-			}
+	debug_info = (struct debug_info*)file->f_dentry->d_inode->u.generic_ip;
+	/* find debug view */
+	for (i = 0; i < DEBUG_MAX_VIEWS; i++) {
+		if (!debug_info->views[i])
+			continue;
+		else if (debug_info->debugfs_entries[i] ==
+			 file->f_dentry) {
+			goto found;	/* found view ! */
@@ -608 +620,0 @@
-		debug_info = debug_info->next;
@@ -836 +848 @@
-	STCK(active->id.stck);
+	active->id.stck = get_clock();
@@ -1081 +1093 @@
-				NULL, &debug_file_ops);
+				id , &debug_file_ops);
@@ -1435 +1447 @@
-	struct timeval time_val;
+	struct timespec time_spec;
@@ -1446 +1458 @@
-	tod_to_timeval(time, &time_val);
+	tod_to_timeval(time, &time_spec);
@@ -1454 +1466 @@
-		      area, time_val.tv_sec, time_val.tv_usec, level,
+		      area, time_spec.tv_sec, time_spec.tv_nsec / 1000, level,
--- ./projects/linux/linux-2.6.14/arch/s390/kernel/debug.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/arch/s390/kernel/debug.c	2006-01-03 04:21:10.000000000 +0100
@@ -489 +489 @@
-extern inline int
+static inline int
@@ -803 +803 @@
-extern inline void
+static inline void
@@ -820 +820 @@
-extern inline void
+static inline void
@@ -831 +831 @@
-extern inline debug_entry_t*
+static inline debug_entry_t*
@@ -844 +844 @@
-extern inline void
+static inline void
@@ -974 +974 @@
-extern inline int
+static inline int
--- ./projects/linux/linux-2.6.16/arch/s390/kernel/debug.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/arch/s390/kernel/debug.c	2006-06-18 03:49:35.000000000 +0200
@@ -207,2 +207 @@
-			areas[i][j] = (debug_entry_t*)kmalloc(PAGE_SIZE,
-						GFP_KERNEL);
+			areas[i][j] = kzalloc(PAGE_SIZE, GFP_KERNEL);
@@ -215,2 +213,0 @@
-			} else {
-				memset(areas[i][j],0,PAGE_SIZE);
@@ -252 +249 @@
-	rc->active_entries = (int*)kmalloc(nr_areas * sizeof(int), GFP_KERNEL);
+	rc->active_entries = kcalloc(nr_areas, sizeof(int), GFP_KERNEL);
@@ -255,2 +252 @@
-	memset(rc->active_entries, 0, nr_areas * sizeof(int));
-	rc->active_pages = (int*)kmalloc(nr_areas * sizeof(int), GFP_KERNEL);
+	rc->active_pages = kcalloc(nr_areas, sizeof(int), GFP_KERNEL);
@@ -259 +254,0 @@
-	memset(rc->active_pages, 0, nr_areas * sizeof(int));
--- ./projects/linux/linux-2.6.17/arch/s390/kernel/debug.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/s390/kernel/debug.c	2006-09-20 05:42:06.000000000 +0200
@@ -13 +12,0 @@
-#include <linux/config.h>
--- ./projects/linux/linux-2.6.18/arch/s390/kernel/debug.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/s390/kernel/debug.c	2006-11-29 22:57:37.000000000 +0100
@@ -606 +606 @@
-	debug_info = (struct debug_info*)file->f_dentry->d_inode->u.generic_ip;
+	debug_info = file->f_dentry->d_inode->i_private;
--- ./projects/linux/linux-2.6.19/arch/s390/kernel/debug.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/arch/s390/kernel/debug.c	2007-02-04 19:44:54.000000000 +0100
@@ -194 +194 @@
-	areas = (debug_entry_t ***) kmalloc(nr_areas *
+	areas = kmalloc(nr_areas *
@@ -200 +200 @@
-		areas[i] = (debug_entry_t**) kmalloc(pages_per_area *
+		areas[i] = kmalloc(pages_per_area *
@@ -245 +245 @@
-	rc = (debug_info_t*) kmalloc(sizeof(debug_info_t), GFP_KERNEL);
+	rc = kmalloc(sizeof(debug_info_t), GFP_KERNEL);
@@ -606 +606 @@
-	debug_info = file->f_dentry->d_inode->i_private;
+	debug_info = file->f_path.dentry->d_inode->i_private;
@@ -612 +612 @@
-			 file->f_dentry) {
+			 file->f_path.dentry) {
@@ -637 +637 @@
-	p_info = (file_private_info_t *) kmalloc(sizeof(file_private_info_t),
+	p_info = kmalloc(sizeof(file_private_info_t),
--- ./projects/linux/linux-2.6.20/arch/s390/kernel/debug.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/arch/s390/kernel/debug.c	2007-04-26 05:08:32.000000000 +0200
@@ -123 +123 @@
-struct debug_view debug_level_view = {
+static struct debug_view debug_level_view = {
@@ -132 +132 @@
-struct debug_view debug_pages_view = {
+static struct debug_view debug_pages_view = {
@@ -141 +141 @@
-struct debug_view debug_flush_view = {
+static struct debug_view debug_flush_view = {
@@ -159 +159 @@
-
+/* used by dump analysis tools to determine version of debug feature */
@@ -166 +166 @@
-DECLARE_MUTEX(debug_lock);
+static DECLARE_MUTEX(debug_lock);
@@ -170 +170 @@
-static struct file_operations debug_file_ops = {
+static const struct file_operations debug_file_ops = {
@@ -271 +271 @@
-	strlcpy(rc->name, name, sizeof(rc->name)-1);
+	strlcpy(rc->name, name, sizeof(rc->name));
@@ -855 +854,0 @@
-#define CTL_S390DBF 5677
@@ -908 +907 @@
-struct ctl_table_header *s390dbf_sysctl_header;
+static struct ctl_table_header *s390dbf_sysctl_header;
@@ -1057 +1056 @@
-	s390dbf_sysctl_header = register_sysctl_table(s390dbf_dir_table, 1);
+	s390dbf_sysctl_header = register_sysctl_table(s390dbf_dir_table);
@@ -1303,2 +1302 @@
-void
-debug_flush(debug_info_t* id, int area)
+static void debug_flush(debug_info_t* id, int area)
@@ -1514,2 +1512 @@
-void
-__exit debug_exit(void)
+static void __exit debug_exit(void)
--- ./projects/linux/linux-2.6.21/arch/s390/kernel/debug.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/arch/s390/kernel/debug.c	2007-07-09 01:32:17.000000000 +0200
@@ -166 +166 @@
-static DECLARE_MUTEX(debug_lock);
+static DEFINE_MUTEX(debug_mutex);
@@ -579 +579 @@
-	down(&debug_lock);
+	mutex_lock(&debug_mutex);
@@ -587 +587 @@
-	up(&debug_lock);
+	mutex_unlock(&debug_mutex);
@@ -605 +605 @@
-	down(&debug_lock);
+	mutex_lock(&debug_mutex);
@@ -656 +656 @@
-	up(&debug_lock);
+	mutex_unlock(&debug_mutex);
@@ -691 +691 @@
-	down(&debug_lock);
+	mutex_lock(&debug_mutex);
@@ -705 +705 @@
-	up(&debug_lock);
+	mutex_unlock(&debug_mutex);
@@ -719 +719 @@
-	down(&debug_lock);
+	mutex_lock(&debug_mutex);
@@ -721 +721 @@
-	up(&debug_lock);
+	mutex_unlock(&debug_mutex);
@@ -1057 +1057 @@
-	down(&debug_lock);
+	mutex_lock(&debug_mutex);
@@ -1061 +1061 @@
-	up(&debug_lock);
+	mutex_unlock(&debug_mutex);
--- ./projects/linux/linux-2.6.25/arch/s390/kernel/debug.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/arch/s390/kernel/debug.c	2008-07-13 23:51:29.000000000 +0200
@@ -20 +19,0 @@
-#include <asm/semaphore.h>
@@ -75,2 +74,2 @@
-static debug_info_t*  debug_info_create(char *name, int pages_per_area,
-			int nr_areas, int buf_size);
+static debug_info_t *debug_info_create(const char *name, int pages_per_area,
+			int nr_areas, int buf_size, mode_t mode);
@@ -160 +159 @@
-unsigned int debug_feature_version = __DEBUG_FEATURE_VERSION;
+static unsigned int __used debug_feature_version = __DEBUG_FEATURE_VERSION;
@@ -238,2 +237,2 @@
-debug_info_alloc(char *name, int pages_per_area, int nr_areas, int buf_size,
-		int level, int mode)
+debug_info_alloc(const char *name, int pages_per_area, int nr_areas,
+		 int buf_size, int level, int mode)
@@ -330 +329,2 @@
-debug_info_create(char *name, int pages_per_area, int nr_areas, int buf_size)
+debug_info_create(const char *name, int pages_per_area, int nr_areas,
+		  int buf_size, mode_t mode)
@@ -338,0 +339,2 @@
+	rc->mode = mode & ~S_IFMT;
+
@@ -679,3 +681,4 @@
- * debug_register:
- * - creates and initializes debug area for the caller
- * - returns handle for debug area
+ * debug_register_mode:
+ * - Creates and initializes debug area for the caller
+ *   The mode parameter allows to specify access rights for the s390dbf files
+ * - Returns handle for debug area
@@ -684,2 +687,3 @@
-debug_info_t*
-debug_register (char *name, int pages_per_area, int nr_areas, int buf_size)
+debug_info_t *debug_register_mode(const char *name, int pages_per_area,
+				  int nr_areas, int buf_size, mode_t mode,
+				  uid_t uid, gid_t gid)
@@ -688,0 +693,5 @@
+	/* Since debugfs currently does not support uid/gid other than root, */
+	/* we do not allow gid/uid != 0 until we get support for that. */
+	if ((uid != 0) || (gid != 0))
+		printk(KERN_WARNING "debug: Warning - Currently only uid/gid "
+		       "= 0 are supported. Using root as owner now!");
@@ -695 +704 @@
-	rc = debug_info_create(name, pages_per_area, nr_areas, buf_size);
+	rc = debug_info_create(name, pages_per_area, nr_areas, buf_size, mode);
@@ -707,0 +717,14 @@
+EXPORT_SYMBOL(debug_register_mode);
+
+/*
+ * debug_register:
+ * - creates and initializes debug area for the caller
+ * - returns handle for debug area
+ */
+
+debug_info_t *debug_register(const char *name, int pages_per_area,
+			     int nr_areas, int buf_size)
+{
+	return debug_register_mode(name, pages_per_area, nr_areas, buf_size,
+				   S_IRUSR | S_IWUSR, 0, 0);
+}
@@ -1076 +1099 @@
-	mode_t mode = S_IFREG;
+	mode_t mode;
@@ -1081,4 +1104,5 @@
-	if (view->prolog_proc || view->format_proc || view->header_proc)
-		mode |= S_IRUSR;
-	if (view->input_proc)
-		mode |= S_IWUSR;
+	mode = (id->mode | S_IFREG) & ~S_IXUGO;
+	if (!(view->prolog_proc || view->format_proc || view->header_proc))
+		mode &= ~(S_IRUSR | S_IRGRP | S_IROTH);
+	if (!view->input_proc)
+		mode &= ~(S_IWUSR | S_IWGRP | S_IWOTH);
--- ./projects/linux/linux-2.6.26/arch/s390/kernel/debug.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/arch/s390/kernel/debug.c	2008-10-10 00:13:53.000000000 +0200
@@ -1082 +1081,0 @@
-	printk(KERN_INFO "debug: Initialization complete\n");
@@ -1196 +1194,0 @@
-		printk("debug: no integer specified!\n");
@@ -1343 +1340,0 @@
-                printk(KERN_INFO "debug: %s: all areas flushed\n",id->name);
@@ -1350,6 +1346,0 @@
-                printk(KERN_INFO "debug: %s: area %i has been flushed\n",
-                        id->name, area);
-        } else {
-                printk(KERN_INFO
-                      "debug: %s: area %i cannot be flushed (range: %i - %i)\n",
-                        id->name, area, 0, id->nr_areas-1);
--- ./projects/linux/linux-2.6.28/arch/s390/kernel/debug.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/arch/s390/kernel/debug.c	2009-03-24 00:12:14.000000000 +0100
@@ -12,0 +13,3 @@
+#define KMSG_COMPONENT "s390dbf"
+#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
+
@@ -391 +394 @@
-        if(!rc || (mode == NO_AREAS))
+	if (mode == NO_AREAS)
@@ -696,2 +699,2 @@
-		printk(KERN_WARNING "debug: Warning - Currently only uid/gid "
-		       "= 0 are supported. Using root as owner now!");
+		pr_warning("Root becomes the owner of all s390dbf files "
+			   "in sysfs\n");
@@ -712 +715 @@
-		printk(KERN_ERR "debug: debug_register failed for %s\n",name);
+		pr_err("Registering debug feature %s failed\n", name);
@@ -766,2 +769,2 @@
-			printk(KERN_WARNING "debug: could not allocate memory "\
-					 "for pagenumber: %i\n",pages_per_area);
+			pr_info("Allocating memory for %i pages failed\n",
+				pages_per_area);
@@ -783,2 +786 @@
-	printk(KERN_INFO "debug: %s: set new size (%i pages)\n"\
-			 ,id->name, pages_per_area);
+	pr_info("%s: set new size (%i pages)\n" ,id->name, pages_per_area);
@@ -803 +805 @@
-                printk(KERN_INFO "debug: %s: switched off\n",id->name);
+		pr_info("%s: switched off\n",id->name);
@@ -805,2 +807 @@
-                printk(KERN_INFO
-                        "debug: %s: level %i is out of range (%i - %i)\n",
+		pr_info("%s: level %i is out of range (%i - %i)\n",
@@ -1111,2 +1112,2 @@
-		printk(KERN_WARNING "debug: debugfs_create_file() failed!"\
-			" Cannot register view %s/%s\n", id->name,view->name);
+		pr_err("Registering view %s/%s failed due to out of "
+		       "memory\n", id->name,view->name);
@@ -1122,4 +1123,2 @@
-		printk(KERN_WARNING "debug: cannot register view %s/%s\n",
-			id->name,view->name);
-		printk(KERN_WARNING 
-			"debug: maximum number of views reached (%i)!\n", i);
+		pr_err("Registering view %s/%s would exceed the maximum "
+		       "number of views %i\n", id->name, view->name, i);
@@ -1306 +1305,2 @@
-		printk(KERN_INFO "debug: level `%s` is not valid\n", str);
+		pr_warning("%s is not a valid level for a debug "
+			   "feature\n", str);
@@ -1383 +1383,2 @@
-        printk(KERN_INFO "debug: area `%c` is not valid\n", input_buf[0]);
+	pr_info("Flushing debug data failed because %c is not a valid "
+		 "area\n", input_buf[0]);
--- ./projects/linux/linux-2.6.29/arch/s390/kernel/debug.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/arch/s390/kernel/debug.c	2009-06-27 11:32:31.000000000 +0200
@@ -606 +606 @@
-	int i = 0, rc = 0;
+	int i, rc = 0;
@@ -645,2 +645 @@
-		if(debug_info_snapshot)
-			debug_info_free(debug_info_snapshot);
+		debug_info_free(debug_info_snapshot);
@@ -701,2 +700 @@
-	if (!initialized)
-		BUG();
+	BUG_ON(!initialized);
@@ -1159 +1156,0 @@
-		rc = 0;
--- ./projects/linux/linux-2.6.24/arch/s390/mm/pgtable.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/s390/mm/pgtable.c	2008-04-17 04:49:44.000000000 +0200
@@ -25,0 +26 @@
+#include <asm/mmu_context.h>
@@ -28,0 +30,3 @@
+#define TABLES_PER_PAGE	4
+#define FRAG_MASK	15UL
+#define SECOND_HALVES	10UL
@@ -30,0 +35,3 @@
+#define TABLES_PER_PAGE	2
+#define FRAG_MASK	3UL
+#define SECOND_HALVES	2UL
@@ -47,0 +55,3 @@
+	spin_lock(&mm->page_table_lock);
+	list_add(&page->lru, &mm->context.crst_list);
+	spin_unlock(&mm->page_table_lock);
@@ -51 +61 @@
-void crst_table_free(unsigned long *table)
+void crst_table_free(struct mm_struct *mm, unsigned long *table)
@@ -53,0 +64 @@
+	struct page *page = virt_to_page(table);
@@ -54,0 +66,3 @@
+	spin_lock(&mm->page_table_lock);
+	list_del(&page->lru);
+	spin_unlock(&mm->page_table_lock);
@@ -59,0 +74,73 @@
+#ifdef CONFIG_64BIT
+int crst_table_upgrade(struct mm_struct *mm, unsigned long limit)
+{
+	unsigned long *table, *pgd;
+	unsigned long entry;
+
+	BUG_ON(limit > (1UL << 53));
+repeat:
+	table = crst_table_alloc(mm, mm->context.noexec);
+	if (!table)
+		return -ENOMEM;
+	spin_lock(&mm->page_table_lock);
+	if (mm->context.asce_limit < limit) {
+		pgd = (unsigned long *) mm->pgd;
+		if (mm->context.asce_limit <= (1UL << 31)) {
+			entry = _REGION3_ENTRY_EMPTY;
+			mm->context.asce_limit = 1UL << 42;
+			mm->context.asce_bits = _ASCE_TABLE_LENGTH |
+						_ASCE_USER_BITS |
+						_ASCE_TYPE_REGION3;
+		} else {
+			entry = _REGION2_ENTRY_EMPTY;
+			mm->context.asce_limit = 1UL << 53;
+			mm->context.asce_bits = _ASCE_TABLE_LENGTH |
+						_ASCE_USER_BITS |
+						_ASCE_TYPE_REGION2;
+		}
+		crst_table_init(table, entry);
+		pgd_populate(mm, (pgd_t *) table, (pud_t *) pgd);
+		mm->pgd = (pgd_t *) table;
+		table = NULL;
+	}
+	spin_unlock(&mm->page_table_lock);
+	if (table)
+		crst_table_free(mm, table);
+	if (mm->context.asce_limit < limit)
+		goto repeat;
+	update_mm(mm, current);
+	return 0;
+}
+
+void crst_table_downgrade(struct mm_struct *mm, unsigned long limit)
+{
+	pgd_t *pgd;
+
+	if (mm->context.asce_limit <= limit)
+		return;
+	__tlb_flush_mm(mm);
+	while (mm->context.asce_limit > limit) {
+		pgd = mm->pgd;
+		switch (pgd_val(*pgd) & _REGION_ENTRY_TYPE_MASK) {
+		case _REGION_ENTRY_TYPE_R2:
+			mm->context.asce_limit = 1UL << 42;
+			mm->context.asce_bits = _ASCE_TABLE_LENGTH |
+						_ASCE_USER_BITS |
+						_ASCE_TYPE_REGION3;
+			break;
+		case _REGION_ENTRY_TYPE_R3:
+			mm->context.asce_limit = 1UL << 31;
+			mm->context.asce_bits = _ASCE_TABLE_LENGTH |
+						_ASCE_USER_BITS |
+						_ASCE_TYPE_SEGMENT;
+			break;
+		default:
+			BUG();
+		}
+		mm->pgd = (pgd_t *) (pgd_val(*pgd) & _REGION_ENTRY_ORIGIN);
+		crst_table_free(mm, (unsigned long *) pgd);
+	}
+	update_mm(mm, current);
+}
+#endif
+
@@ -63 +150 @@
-unsigned long *page_table_alloc(int noexec)
+unsigned long *page_table_alloc(struct mm_struct *mm)
@@ -65 +152 @@
-	struct page *page = alloc_page(GFP_KERNEL);
+	struct page *page;
@@ -66,0 +154 @@
+	unsigned long bits;
@@ -68,7 +156,13 @@
-	if (!page)
-		return NULL;
-	page->index = 0;
-	if (noexec) {
-		struct page *shadow = alloc_page(GFP_KERNEL);
-		if (!shadow) {
-			__free_page(page);
+	bits = mm->context.noexec ? 3UL : 1UL;
+	spin_lock(&mm->page_table_lock);
+	page = NULL;
+	if (!list_empty(&mm->context.pgtable_list)) {
+		page = list_first_entry(&mm->context.pgtable_list,
+					struct page, lru);
+		if ((page->flags & FRAG_MASK) == ((1UL << TABLES_PER_PAGE) - 1))
+			page = NULL;
+	}
+	if (!page) {
+		spin_unlock(&mm->page_table_lock);
+		page = alloc_page(GFP_KERNEL|__GFP_REPEAT);
+		if (!page)
@@ -76,2 +170,3 @@
-		}
-		table = (unsigned long *) page_to_phys(shadow);
+		pgtable_page_ctor(page);
+		page->flags &= ~FRAG_MASK;
+		table = (unsigned long *) page_to_phys(page);
@@ -79 +174,2 @@
-		page->index = (addr_t) table;
+		spin_lock(&mm->page_table_lock);
+		list_add(&page->lru, &mm->context.pgtable_list);
@@ -82 +178,8 @@
-	clear_table(table, _PAGE_TYPE_EMPTY, PAGE_SIZE);
+	while (page->flags & bits) {
+		table += 256;
+		bits <<= 1;
+	}
+	page->flags |= bits;
+	if ((page->flags & FRAG_MASK) == ((1UL << TABLES_PER_PAGE) - 1))
+		list_move_tail(&page->lru, &mm->context.pgtable_list);
+	spin_unlock(&mm->page_table_lock);
@@ -86 +189 @@
-void page_table_free(unsigned long *table)
+void page_table_free(struct mm_struct *mm, unsigned long *table)
@@ -88 +191,2 @@
-	unsigned long *shadow = get_shadow_pte(table);
+	struct page *page;
+	unsigned long bits;
@@ -90,3 +194,18 @@
-	if (shadow)
-		free_page((unsigned long) shadow);
-	free_page((unsigned long) table);
+	bits = mm->context.noexec ? 3UL : 1UL;
+	bits <<= (__pa(table) & (PAGE_SIZE - 1)) / 256 / sizeof(unsigned long);
+	page = pfn_to_page(__pa(table) >> PAGE_SHIFT);
+	spin_lock(&mm->page_table_lock);
+	page->flags ^= bits;
+	if (page->flags & FRAG_MASK) {
+		/* Page now has some free pgtable fragments. */
+		list_move(&page->lru, &mm->context.pgtable_list);
+		page = NULL;
+	} else
+		/* All fragments of the 4K page have been freed. */
+		list_del(&page->lru);
+	spin_unlock(&mm->page_table_lock);
+	if (page) {
+		pgtable_page_dtor(page);
+		__free_page(page);
+	}
+}
@@ -93,0 +213,17 @@
+void disable_noexec(struct mm_struct *mm, struct task_struct *tsk)
+{
+	struct page *page;
+
+	spin_lock(&mm->page_table_lock);
+	/* Free shadow region and segment tables. */
+	list_for_each_entry(page, &mm->context.crst_list, lru)
+		if (page->index) {
+			free_pages((unsigned long) page->index, ALLOC_ORDER);
+			page->index = 0;
+		}
+	/* "Free" second halves of page tables. */
+	list_for_each_entry(page, &mm->context.pgtable_list, lru)
+		page->flags &= ~SECOND_HALVES;
+	spin_unlock(&mm->page_table_lock);
+	mm->context.noexec = 0;
+	update_mm(mm, tsk);
--- ./projects/linux/linux-2.6.25/arch/s390/mm/pgtable.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/arch/s390/mm/pgtable.c	2008-07-13 23:51:29.000000000 +0200
@@ -32,0 +33,9 @@
+
+void clear_table_pgstes(unsigned long *table)
+{
+	clear_table(table, _PAGE_TYPE_EMPTY, PAGE_SIZE/4);
+	memset(table + 256, 0, PAGE_SIZE/4);
+	clear_table(table + 512, _PAGE_TYPE_EMPTY, PAGE_SIZE/4);
+	memset(table + 768, 0, PAGE_SIZE/4);
+}
+
@@ -37,0 +47,7 @@
+
+void clear_table_pgstes(unsigned long *table)
+{
+	clear_table(table, _PAGE_TYPE_EMPTY, PAGE_SIZE/2);
+	memset(table + 256, 0, PAGE_SIZE/2);
+}
+
@@ -156 +172 @@
-	bits = mm->context.noexec ? 3UL : 1UL;
+	bits = (mm->context.noexec || mm->context.pgstes) ? 3UL : 1UL;
@@ -173 +189,4 @@
-		clear_table(table, _PAGE_TYPE_EMPTY, PAGE_SIZE);
+		if (mm->context.pgstes)
+			clear_table_pgstes(table);
+		else
+			clear_table(table, _PAGE_TYPE_EMPTY, PAGE_SIZE);
@@ -194 +213 @@
-	bits = mm->context.noexec ? 3UL : 1UL;
+	bits = (mm->context.noexec || mm->context.pgstes) ? 3UL : 1UL;
@@ -230,0 +250,50 @@
+
+/*
+ * switch on pgstes for its userspace process (for kvm)
+ */
+int s390_enable_sie(void)
+{
+	struct task_struct *tsk = current;
+	struct mm_struct *mm, *old_mm;
+
+	/* Do we have pgstes? if yes, we are done */
+	if (tsk->mm->context.pgstes)
+		return 0;
+
+	/* lets check if we are allowed to replace the mm */
+	task_lock(tsk);
+	if (!tsk->mm || atomic_read(&tsk->mm->mm_users) > 1 ||
+	    tsk->mm != tsk->active_mm || tsk->mm->ioctx_list) {
+		task_unlock(tsk);
+		return -EINVAL;
+	}
+	task_unlock(tsk);
+
+	/* we copy the mm with pgstes enabled */
+	tsk->mm->context.pgstes = 1;
+	mm = dup_mm(tsk);
+	tsk->mm->context.pgstes = 0;
+	if (!mm)
+		return -ENOMEM;
+
+	/* Now lets check again if somebody attached ptrace etc */
+	task_lock(tsk);
+	if (!tsk->mm || atomic_read(&tsk->mm->mm_users) > 1 ||
+	    tsk->mm != tsk->active_mm || tsk->mm->ioctx_list) {
+		mmput(mm);
+		task_unlock(tsk);
+		return -EINVAL;
+	}
+
+	/* ok, we are alone. No ptrace, no threads, etc. */
+	old_mm = tsk->mm;
+	tsk->mm = tsk->active_mm = mm;
+	preempt_disable();
+	update_mm(mm, tsk);
+	cpu_set(smp_processor_id(), mm->cpu_vm_mask);
+	preempt_enable();
+	task_unlock(tsk);
+	mmput(old_mm);
+	return 0;
+}
+EXPORT_SYMBOL_GPL(s390_enable_sie);
--- ./projects/linux/linux-2.6.27/arch/s390/mm/pgtable.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/arch/s390/mm/pgtable.c	2008-12-25 00:26:37.000000000 +0100
@@ -172 +172 @@
-	bits = (mm->context.noexec || mm->context.pgstes) ? 3UL : 1UL;
+	bits = (mm->context.noexec || mm->context.has_pgste) ? 3UL : 1UL;
@@ -189 +189 @@
-		if (mm->context.pgstes)
+		if (mm->context.has_pgste)
@@ -213 +213 @@
-	bits = (mm->context.noexec || mm->context.pgstes) ? 3UL : 1UL;
+	bits = (mm->context.noexec || mm->context.has_pgste) ? 3UL : 1UL;
@@ -260 +260 @@
-	if (tsk->mm->context.pgstes)
+	if (tsk->mm->context.has_pgste)
@@ -272,2 +272,2 @@
-	/* we copy the mm with pgstes enabled */
-	tsk->mm->context.pgstes = 1;
+	/* we copy the mm and let dup_mm create the page tables with_pgstes */
+	tsk->mm->context.alloc_pgste = 1;
@@ -275 +275 @@
-	tsk->mm->context.pgstes = 0;
+	tsk->mm->context.alloc_pgste = 0;
@@ -279 +279 @@
-	/* Now lets check again if somebody attached ptrace etc */
+	/* Now lets check again if something happened */
--- ./projects/linux/linux-2.6.28/arch/s390/mm/pgtable.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/arch/s390/mm/pgtable.c	2009-03-24 00:12:14.000000000 +0100
@@ -119,0 +120 @@
+		mm->task_size = mm->context.asce_limit;
@@ -156,0 +158 @@
+		mm->task_size = mm->context.asce_limit;
@@ -266 +268 @@
-	    tsk->mm != tsk->active_mm || tsk->mm->ioctx_list) {
+	    tsk->mm != tsk->active_mm || !hlist_empty(&tsk->mm->ioctx_list)) {
@@ -282 +284 @@
-	    tsk->mm != tsk->active_mm || tsk->mm->ioctx_list) {
+	    tsk->mm != tsk->active_mm || !hlist_empty(&tsk->mm->ioctx_list)) {
--- ./projects/linux/linux-2.6.29/arch/s390/mm/pgtable.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/arch/s390/mm/pgtable.c	2009-06-27 11:32:31.000000000 +0200
@@ -260,0 +261,4 @@
+	/* Do we have switched amode? If no, we cannot do sie */
+	if (!switch_amode)
+		return -EINVAL;
+
@@ -295 +299 @@
-	cpu_set(smp_processor_id(), mm->cpu_vm_mask);
+	cpumask_set_cpu(smp_processor_id(), mm_cpumask(mm));
--- ./projects/linux/linux-2.6.25/arch/sh/mm/ioremap_64.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/arch/sh/mm/ioremap_64.c	2008-07-13 23:51:29.000000000 +0200
@@ -345,0 +346 @@
+EXPORT_SYMBOL(onchip_remap);
@@ -372,0 +374 @@
+EXPORT_SYMBOL(onchip_unmap);
--- ./projects/linux/linux-2.6.28/arch/sh/mm/ioremap_64.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/arch/sh/mm/ioremap_64.c	2009-03-24 00:12:14.000000000 +0100
@@ -74 +73,0 @@
-	pr_debug("Get vm_area returns %p addr %p\n",area,area->addr);
@@ -76,0 +76 @@
+	pr_debug("Get vm_area returns %p addr %p\n", area, area->addr);
--- ./projects/linux/linux-2.6.14/arch/sh64/mm/ioremap.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/arch/sh64/mm/ioremap.c	2006-01-03 04:21:10.000000000 +0100
@@ -82 +82 @@
-		pte_t * pte = pte_alloc_kernel(&init_mm, pmd, address);
+		pte_t * pte = pte_alloc_kernel(pmd, address);
@@ -104 +103,0 @@
-	spin_lock(&init_mm.page_table_lock);
@@ -118 +116,0 @@
-	spin_unlock(&init_mm.page_table_lock);
--- ./projects/linux/linux-2.6.17/arch/sh64/mm/ioremap.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/sh64/mm/ioremap.c	2006-09-20 05:42:06.000000000 +0200
@@ -452 +452,3 @@
-		p += sprintf(p, "%08lx-%08lx: %s\n", r->start, r->end, nm);
+		p += sprintf(p, "%08lx-%08lx: %s\n",
+			     (unsigned long)r->start,
+			     (unsigned long)r->end, nm);
--- ./projects/linux/linux-2.6.19/arch/sh64/mm/ioremap.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/arch/sh64/mm/ioremap.c	2007-02-04 19:44:54.000000000 +0100
@@ -21 +21 @@
-#include <asm/io.h>
+#include <linux/io.h>
@@ -31,90 +30,0 @@
-static inline void remap_area_pte(pte_t * pte, unsigned long address, unsigned long size,
-	unsigned long phys_addr, unsigned long flags)
-{
-	unsigned long end;
-	unsigned long pfn;
-	pgprot_t pgprot = __pgprot(_PAGE_PRESENT  | _PAGE_READ   |
-				   _PAGE_WRITE    | _PAGE_DIRTY  |
-				   _PAGE_ACCESSED | _PAGE_SHARED | flags);
-
-	address &= ~PMD_MASK;
-	end = address + size;
-	if (end > PMD_SIZE)
-		end = PMD_SIZE;
-	if (address >= end)
-		BUG();
-
-	pfn = phys_addr >> PAGE_SHIFT;
-
-	pr_debug("    %s: pte %p address %lx size %lx phys_addr %lx\n",
-		 __FUNCTION__,pte,address,size,phys_addr);
-
-	do {
-		if (!pte_none(*pte)) {
-			printk("remap_area_pte: page already exists\n");
-			BUG();
-		}
-
-		set_pte(pte, pfn_pte(pfn, pgprot));
-		address += PAGE_SIZE;
-		pfn++;
-		pte++;
-	} while (address && (address < end));
-}
-
-static inline int remap_area_pmd(pmd_t * pmd, unsigned long address, unsigned long size,
-	unsigned long phys_addr, unsigned long flags)
-{
-	unsigned long end;
-
-	address &= ~PGDIR_MASK;
-	end = address + size;
-
-	if (end > PGDIR_SIZE)
-		end = PGDIR_SIZE;
-
-	phys_addr -= address;
-
-	if (address >= end)
-		BUG();
-
-	do {
-		pte_t * pte = pte_alloc_kernel(pmd, address);
-		if (!pte)
-			return -ENOMEM;
-		remap_area_pte(pte, address, end - address, address + phys_addr, flags);
-		address = (address + PMD_SIZE) & PMD_MASK;
-		pmd++;
-	} while (address && (address < end));
-	return 0;
-}
-
-static int remap_area_pages(unsigned long address, unsigned long phys_addr,
-				 unsigned long size, unsigned long flags)
-{
-	int error;
-	pgd_t * dir;
-	unsigned long end = address + size;
-
-	phys_addr -= address;
-	dir = pgd_offset_k(address);
-	flush_cache_all();
-	if (address >= end)
-		BUG();
-	do {
-		pmd_t *pmd = pmd_alloc(&init_mm, dir, address);
-		error = -ENOMEM;
-		if (!pmd)
-			break;
-		if (remap_area_pmd(pmd, address, end - address,
-				   phys_addr + address, flags)) {
-			 break;
-		}
-		error = 0;
-		address = (address + PGDIR_SIZE) & PGDIR_MASK;
-		dir++;
-	} while (address && (address < end));
-	flush_tlb_all();
-	return 0;
-}
-
@@ -138,0 +49 @@
+	pgprot_t pgprot;
@@ -144,0 +56,4 @@
+	pgprot = __pgprot(_PAGE_PRESENT  | _PAGE_READ   |
+			  _PAGE_WRITE    | _PAGE_DIRTY  |
+			  _PAGE_ACCESSED | _PAGE_SHARED | flags);
+
@@ -161 +76,2 @@
-	if (remap_area_pages((unsigned long)addr, phys_addr, size, flags)) {
+	if (ioremap_page_range((unsigned long)addr, (unsigned long)addr + size,
+			       phys_addr, pgprot)) {
--- ./projects/linux/linux-2.6.22/arch/sh64/mm/ioremap.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/arch/sh64/mm/ioremap.c	2007-10-09 22:31:38.000000000 +0200
@@ -245 +245 @@
-static void *sh64_get_page(void)
+static __init_refok void *sh64_get_page(void)
--- ./projects/linux/linux-2.6.23/arch/sh64/mm/ioremap.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/arch/sh64/mm/ioremap.c	2008-01-24 23:58:37.000000000 +0100
@@ -22,2 +21,0 @@
-#include <asm/pgalloc.h>
-#include <asm/tlbflush.h>
@@ -26,0 +25,3 @@
+#include <linux/module.h>
+#include <asm/pgalloc.h>
+#include <asm/tlbflush.h>
@@ -82,0 +84 @@
+EXPORT_SYMBOL(__ioremap);
@@ -96,0 +99 @@
+EXPORT_SYMBOL(iounmap);
--- ./projects/linux/linux-2.6.13/arch/sparc64/kernel/pci_iommu.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/arch/sparc64/kernel/pci_iommu.c	2005-10-28 02:02:08.000000000 +0200
@@ -52,6 +51,0 @@
-
-	/* Now update everyone's flush point. */
-	for (entry = 0; entry < PBM_NCLUSTERS; entry++) {
-		iommu->alloc_info[entry].flush =
-			iommu->alloc_info[entry].next;
-	}
@@ -83 +77,2 @@
-void pci_iommu_table_init(struct pci_iommu *iommu, int tsbsize)
+/* Based largely upon the ppc64 iommu allocator.  */
+static long pci_arena_alloc(struct pci_iommu *iommu, unsigned long npages)
@@ -85,3 +80,23 @@
-	int i;
-
-	tsbsize /= sizeof(iopte_t);
+	struct pci_iommu_arena *arena = &iommu->arena;
+	unsigned long n, i, start, end, limit;
+	int pass;
+
+	limit = arena->limit;
+	start = arena->hint;
+	pass = 0;
+
+again:
+	n = find_next_zero_bit(arena->map, limit, start);
+	end = n + npages;
+	if (unlikely(end >= limit)) {
+		if (likely(pass < 1)) {
+			limit = start;
+			start = 0;
+			__iommu_flushall(iommu);
+			pass++;
+			goto again;
+		} else {
+			/* Scanned the whole thing, give up. */
+			return -1;
+		}
+	}
@@ -89,3 +104,6 @@
-	for (i = 0; i < tsbsize; i++)
-		iopte_make_dummy(iommu, &iommu->page_table[i]);
-}
+	for (i = n; i < end; i++) {
+		if (test_bit(i, arena->map)) {
+			start = i + 1;
+			goto again;
+		}
+	}
@@ -93,4 +111,2 @@
-static iopte_t *alloc_streaming_cluster(struct pci_iommu *iommu, unsigned long npages)
-{
-	iopte_t *iopte, *limit, *first;
-	unsigned long cnum, ent, flush_point;
+	for (i = n; i < end; i++)
+		__set_bit(i, arena->map);
@@ -98,12 +114 @@
-	cnum = 0;
-	while ((1UL << cnum) < npages)
-		cnum++;
-	iopte  = (iommu->page_table +
-		  (cnum << (iommu->page_table_sz_bits - PBM_LOGCLUSTERS)));
-
-	if (cnum == 0)
-		limit = (iommu->page_table +
-			 iommu->lowest_consistent_map);
-	else
-		limit = (iopte +
-			 (1 << (iommu->page_table_sz_bits - PBM_LOGCLUSTERS)));
+	arena->hint = end;
@@ -111,28 +116,2 @@
-	iopte += ((ent = iommu->alloc_info[cnum].next) << cnum);
-	flush_point = iommu->alloc_info[cnum].flush;
-	
-	first = iopte;
-	for (;;) {
-		if (IOPTE_IS_DUMMY(iommu, iopte)) {
-			if ((iopte + (1 << cnum)) >= limit)
-				ent = 0;
-			else
-				ent = ent + 1;
-			iommu->alloc_info[cnum].next = ent;
-			if (ent == flush_point)
-				__iommu_flushall(iommu);
-			break;
-		}
-		iopte += (1 << cnum);
-		ent++;
-		if (iopte >= limit) {
-			iopte = (iommu->page_table +
-				 (cnum <<
-				  (iommu->page_table_sz_bits - PBM_LOGCLUSTERS)));
-			ent = 0;
-		}
-		if (ent == flush_point)
-			__iommu_flushall(iommu);
-		if (iopte == first)
-			goto bad;
-	}
+	return n;
+}
@@ -140,2 +119,3 @@
-	/* I've got your streaming cluster right here buddy boy... */
-	return iopte;
+static void pci_arena_free(struct pci_iommu_arena *arena, unsigned long base, unsigned long npages)
+{
+	unsigned long i;
@@ -143,4 +123,2 @@
-bad:
-	printk(KERN_EMERG "pci_iommu: alloc_streaming_cluster of npages(%ld) failed!\n",
-	       npages);
-	return NULL;
+	for (i = base; i < (base + npages); i++)
+		__clear_bit(i, arena->map);
@@ -149,2 +127 @@
-static void free_streaming_cluster(struct pci_iommu *iommu, dma_addr_t base,
-				   unsigned long npages, unsigned long ctx)
+void pci_iommu_table_init(struct pci_iommu *iommu, int tsbsize, u32 dma_offset, u32 dma_addr_mask)
@@ -152 +129,3 @@
-	unsigned long cnum, ent;
+	unsigned long i, tsbbase, order, sz, num_tsb_entries;
+
+	num_tsb_entries = tsbsize / sizeof(iopte_t);
@@ -154,3 +133,5 @@
-	cnum = 0;
-	while ((1UL << cnum) < npages)
-		cnum++;
+	/* Setup initial software IOMMU state. */
+	spin_lock_init(&iommu->lock);
+	iommu->ctx_lowest_free = 1;
+	iommu->page_table_map_base = dma_offset;
+	iommu->dma_addr_mask = dma_addr_mask;
@@ -158,2 +139,10 @@
-	ent = (base << (32 - IO_PAGE_SHIFT + PBM_LOGCLUSTERS - iommu->page_table_sz_bits))
-		>> (32 + PBM_LOGCLUSTERS + cnum - iommu->page_table_sz_bits);
+	/* Allocate and initialize the free area map.  */
+	sz = num_tsb_entries / 8;
+	sz = (sz + 7UL) & ~7UL;
+	iommu->arena.map = kmalloc(sz, GFP_KERNEL);
+	if (!iommu->arena.map) {
+		prom_printf("PCI_IOMMU: Error, kmalloc(arena.map) failed.\n");
+		prom_halt();
+	}
+	memset(iommu->arena.map, 0, sz);
+	iommu->arena.limit = num_tsb_entries;
@@ -161,3 +150,2 @@
-	/* If the global flush might not have caught this entry,
-	 * adjust the flush point such that we will flush before
-	 * ever trying to reuse it.
+	/* Allocate and initialize the dummy page which we
+	 * set inactive IO PTEs to point to.
@@ -165,4 +153,19 @@
-#define between(X,Y,Z)	(((Z) - (Y)) >= ((X) - (Y)))
-	if (between(ent, iommu->alloc_info[cnum].next, iommu->alloc_info[cnum].flush))
-		iommu->alloc_info[cnum].flush = ent;
-#undef between
+	iommu->dummy_page = __get_free_pages(GFP_KERNEL, 0);
+	if (!iommu->dummy_page) {
+		prom_printf("PCI_IOMMU: Error, gfp(dummy_page) failed.\n");
+		prom_halt();
+	}
+	memset((void *)iommu->dummy_page, 0, PAGE_SIZE);
+	iommu->dummy_page_pa = (unsigned long) __pa(iommu->dummy_page);
+
+	/* Now allocate and setup the IOMMU page table itself.  */
+	order = get_order(tsbsize);
+	tsbbase = __get_free_pages(GFP_KERNEL, order);
+	if (!tsbbase) {
+		prom_printf("PCI_IOMMU: Error, gfp(tsb) failed.\n");
+		prom_halt();
+	}
+	iommu->page_table = (iopte_t *)tsbbase;
+
+	for (i = 0; i < num_tsb_entries; i++)
+		iopte_make_dummy(iommu, &iommu->page_table[i]);
@@ -171,2 +174 @@
-/* We allocate consistent mappings from the end of cluster zero. */
-static iopte_t *alloc_consistent_cluster(struct pci_iommu *iommu, unsigned long npages)
+static inline iopte_t *alloc_npages(struct pci_iommu *iommu, unsigned long npages)
@@ -174 +176 @@
-	iopte_t *iopte;
+	long entry;
@@ -176,13 +178,3 @@
-	iopte = iommu->page_table + (1 << (iommu->page_table_sz_bits - PBM_LOGCLUSTERS));
-	while (iopte > iommu->page_table) {
-		iopte--;
-		if (IOPTE_IS_DUMMY(iommu, iopte)) {
-			unsigned long tmp = npages;
-
-			while (--tmp) {
-				iopte--;
-				if (!IOPTE_IS_DUMMY(iommu, iopte))
-					break;
-			}
-			if (tmp == 0) {
-				u32 entry = (iopte - iommu->page_table);
+	entry = pci_arena_alloc(iommu, npages);
+	if (unlikely(entry < 0))
+		return NULL;
@@ -190,7 +182,6 @@
-				if (entry < iommu->lowest_consistent_map)
-					iommu->lowest_consistent_map = entry;
-				return iopte;
-			}
-		}
-	}
-	return NULL;
+	return iommu->page_table + entry;
+}
+
+static inline void free_npages(struct pci_iommu *iommu, dma_addr_t base, unsigned long npages)
+{
+	pci_arena_free(&iommu->arena, base >> IO_PAGE_SHIFT, npages);
@@ -236 +227 @@
-	unsigned long flags, order, first_page, ctx;
+	unsigned long flags, order, first_page;
@@ -254,3 +245,4 @@
-	iopte = alloc_consistent_cluster(iommu, size >> IO_PAGE_SHIFT);
-	if (iopte == NULL) {
-		spin_unlock_irqrestore(&iommu->lock, flags);
+	iopte = alloc_npages(iommu, size >> IO_PAGE_SHIFT);
+	spin_unlock_irqrestore(&iommu->lock, flags);
+
+	if (unlikely(iopte == NULL)) {
@@ -265,3 +256,0 @@
-	ctx = 0;
-	if (iommu->iommu_ctxflush)
-		ctx = iommu_alloc_ctx(iommu);
@@ -270 +259 @@
-		iopte_val(*iopte) = (IOPTE_CONSISTENT(ctx) |
+		iopte_val(*iopte) = (IOPTE_CONSISTENT(0UL) |
@@ -277,13 +265,0 @@
-	{
-		int i;
-		u32 daddr = *dma_addrp;
-
-		npages = size >> IO_PAGE_SHIFT;
-		for (i = 0; i < npages; i++) {
-			pci_iommu_write(iommu->iommu_flush, daddr);
-			daddr += IO_PAGE_SIZE;
-		}
-	}
-
-	spin_unlock_irqrestore(&iommu->lock, flags);
-
@@ -299 +275 @@
-	unsigned long flags, order, npages, i, ctx;
+	unsigned long flags, order, npages;
@@ -309,40 +285 @@
-	if ((iopte - iommu->page_table) ==
-	    iommu->lowest_consistent_map) {
-		iopte_t *walk = iopte + npages;
-		iopte_t *limit;
-
-		limit = (iommu->page_table +
-			 (1 << (iommu->page_table_sz_bits - PBM_LOGCLUSTERS)));
-		while (walk < limit) {
-			if (!IOPTE_IS_DUMMY(iommu, walk))
-				break;
-			walk++;
-		}
-		iommu->lowest_consistent_map =
-			(walk - iommu->page_table);
-	}
-
-	/* Data for consistent mappings cannot enter the streaming
-	 * buffers, so we only need to update the TSB.  We flush
-	 * the IOMMU here as well to prevent conflicts with the
-	 * streaming mapping deferred tlb flush scheme.
-	 */
-
-	ctx = 0;
-	if (iommu->iommu_ctxflush)
-		ctx = (iopte_val(*iopte) & IOPTE_CONTEXT) >> 47UL;
-
-	for (i = 0; i < npages; i++, iopte++)
-		iopte_make_dummy(iommu, iopte);
-
-	if (iommu->iommu_ctxflush) {
-		pci_iommu_write(iommu->iommu_ctxflush, ctx);
-	} else {
-		for (i = 0; i < npages; i++) {
-			u32 daddr = dvma + (i << IO_PAGE_SHIFT);
-
-			pci_iommu_write(iommu->iommu_flush, daddr);
-		}
-	}
-
-	iommu_free_ctx(iommu, ctx);
+	free_npages(iommu, dvma, npages);
@@ -375,2 +312,2 @@
-	if (direction == PCI_DMA_NONE)
-		BUG();
+	if (unlikely(direction == PCI_DMA_NONE))
+		goto bad_no_ctx;
@@ -382,0 +320,5 @@
+	base = alloc_npages(iommu, npages);
+	ctx = 0;
+	if (iommu->iommu_ctxflush)
+		ctx = iommu_alloc_ctx(iommu);
+	spin_unlock_irqrestore(&iommu->lock, flags);
@@ -384,2 +326 @@
-	base = alloc_streaming_cluster(iommu, npages);
-	if (base == NULL)
+	if (unlikely(!base))
@@ -386,0 +328 @@
+
@@ -391,3 +332,0 @@
-	ctx = 0;
-	if (iommu->iommu_ctxflush)
-		ctx = iommu_alloc_ctx(iommu);
@@ -404,2 +342,0 @@
-	spin_unlock_irqrestore(&iommu->lock, flags);
-
@@ -409 +346,4 @@
-	spin_unlock_irqrestore(&iommu->lock, flags);
+	iommu_free_ctx(iommu, ctx);
+bad_no_ctx:
+	if (printk_ratelimit())
+		WARN_ON(1);
@@ -469 +409 @@
-		membar("#LoadLoad");
+		rmb();
@@ -484 +424 @@
-	unsigned long flags, npages, ctx;
+	unsigned long flags, npages, ctx, i;
@@ -486,2 +426,5 @@
-	if (direction == PCI_DMA_NONE)
-		BUG();
+	if (unlikely(direction == PCI_DMA_NONE)) {
+		if (printk_ratelimit())
+			WARN_ON(1);
+		return;
+	}
@@ -513 +456,2 @@
-		pci_strbuf_flush(strbuf, iommu, bus_addr, ctx, npages, direction);
+		pci_strbuf_flush(strbuf, iommu, bus_addr, ctx,
+				 npages, direction);
@@ -515,2 +459,3 @@
-	/* Step 2: Clear out first TSB entry. */
-	iopte_make_dummy(iommu, base);
+	/* Step 2: Clear out TSB entries. */
+	for (i = 0; i < npages; i++)
+		iopte_make_dummy(iommu, base + i);
@@ -518,2 +463 @@
-	free_streaming_cluster(iommu, bus_addr - iommu->page_table_map_base,
-			       npages, ctx);
+	free_npages(iommu, bus_addr - iommu->page_table_map_base, npages);
@@ -623,0 +568,2 @@
+		if (unlikely(sglist->dma_address == PCI_DMA_ERROR_CODE))
+			return 0;
@@ -632,2 +578,2 @@
-	if (direction == PCI_DMA_NONE)
-		BUG();
+	if (unlikely(direction == PCI_DMA_NONE))
+		goto bad_no_ctx;
@@ -639 +585 @@
-	/* Step 2: Allocate a cluster. */
+	/* Step 2: Allocate a cluster and context, if necessary. */
@@ -643 +589,7 @@
-	base = alloc_streaming_cluster(iommu, npages);
+	base = alloc_npages(iommu, npages);
+	ctx = 0;
+	if (iommu->iommu_ctxflush)
+		ctx = iommu_alloc_ctx(iommu);
+
+	spin_unlock_irqrestore(&iommu->lock, flags);
+
@@ -646 +598,3 @@
-	dma_base = iommu->page_table_map_base + ((base - iommu->page_table) << IO_PAGE_SHIFT);
+
+	dma_base = iommu->page_table_map_base +
+		((base - iommu->page_table) << IO_PAGE_SHIFT);
@@ -659,6 +613 @@
-	/* Step 4: Choose a context if necessary. */
-	ctx = 0;
-	if (iommu->iommu_ctxflush)
-		ctx = iommu_alloc_ctx(iommu);
-
-	/* Step 5: Create the mappings. */
+	/* Step 4: Create the mappings. */
@@ -671 +620,3 @@
-	fill_sg (base, sglist, used, nelems, iopte_protection);
+
+	fill_sg(base, sglist, used, nelems, iopte_protection);
+
@@ -676,2 +626,0 @@
-	spin_unlock_irqrestore(&iommu->lock, flags);
-
@@ -681,2 +630,5 @@
-	spin_unlock_irqrestore(&iommu->lock, flags);
-	return PCI_DMA_ERROR_CODE;
+	iommu_free_ctx(iommu, ctx);
+bad_no_ctx:
+	if (printk_ratelimit())
+		WARN_ON(1);
+	return 0;
@@ -695,2 +647,4 @@
-	if (direction == PCI_DMA_NONE)
-		BUG();
+	if (unlikely(direction == PCI_DMA_NONE)) {
+		if (printk_ratelimit())
+			WARN_ON(1);
+	}
@@ -708 +662,2 @@
-	npages = (IO_PAGE_ALIGN(sglist[i].dma_address + sglist[i].dma_length) - bus_addr) >> IO_PAGE_SHIFT;
+	npages = (IO_PAGE_ALIGN(sglist[i].dma_address + sglist[i].dma_length) -
+		  bus_addr) >> IO_PAGE_SHIFT;
@@ -729,2 +684,3 @@
-	/* Step 2: Clear out first TSB entry. */
-	iopte_make_dummy(iommu, base);
+	/* Step 2: Clear out the TSB entries. */
+	for (i = 0; i < npages; i++)
+		iopte_make_dummy(iommu, base + i);
@@ -732,2 +688 @@
-	free_streaming_cluster(iommu, bus_addr - iommu->page_table_map_base,
-			       npages, ctx);
+	free_npages(iommu, bus_addr - iommu->page_table_map_base, npages);
--- ./projects/linux/linux-2.6.16/arch/sparc64/kernel/pci_iommu.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/arch/sparc64/kernel/pci_iommu.c	2006-06-18 03:49:35.000000000 +0200
@@ -142 +142 @@
-	iommu->arena.map = kmalloc(sz, GFP_KERNEL);
+	iommu->arena.map = kzalloc(sz, GFP_KERNEL);
@@ -147 +146,0 @@
-	memset(iommu->arena.map, 0, sz);
@@ -222 +221 @@
-void *pci_alloc_consistent(struct pci_dev *pdev, size_t size, dma_addr_t *dma_addrp)
+static void *pci_4u_alloc_consistent(struct pci_dev *pdev, size_t size, dma_addr_t *dma_addrp, gfp_t gfp)
@@ -236 +235 @@
-	first_page = __get_free_pages(GFP_ATOMIC, order);
+	first_page = __get_free_pages(gfp, order);
@@ -270 +269 @@
-void pci_free_consistent(struct pci_dev *pdev, size_t size, void *cpu, dma_addr_t dvma)
+static void pci_4u_free_consistent(struct pci_dev *pdev, size_t size, void *cpu, dma_addr_t dvma)
@@ -297 +296 @@
-dma_addr_t pci_map_single(struct pci_dev *pdev, void *ptr, size_t sz, int direction)
+static dma_addr_t pci_4u_map_single(struct pci_dev *pdev, void *ptr, size_t sz, int direction)
@@ -418 +417 @@
-void pci_unmap_single(struct pci_dev *pdev, dma_addr_t bus_addr, size_t sz, int direction)
+static void pci_4u_unmap_single(struct pci_dev *pdev, dma_addr_t bus_addr, size_t sz, int direction)
@@ -551 +550 @@
-int pci_map_sg(struct pci_dev *pdev, struct scatterlist *sglist, int nelems, int direction)
+static int pci_4u_map_sg(struct pci_dev *pdev, struct scatterlist *sglist, int nelems, int direction)
@@ -565,3 +564,3 @@
-			pci_map_single(pdev,
-				       (page_address(sglist->page) + sglist->offset),
-				       sglist->length, direction);
+			pci_4u_map_single(pdev,
+					  (page_address(sglist->page) + sglist->offset),
+					  sglist->length, direction);
@@ -638 +637 @@
-void pci_unmap_sg(struct pci_dev *pdev, struct scatterlist *sglist, int nelems, int direction)
+static void pci_4u_unmap_sg(struct pci_dev *pdev, struct scatterlist *sglist, int nelems, int direction)
@@ -698 +697 @@
-void pci_dma_sync_single_for_cpu(struct pci_dev *pdev, dma_addr_t bus_addr, size_t sz, int direction)
+static void pci_4u_dma_sync_single_for_cpu(struct pci_dev *pdev, dma_addr_t bus_addr, size_t sz, int direction)
@@ -738 +737 @@
-void pci_dma_sync_sg_for_cpu(struct pci_dev *pdev, struct scatterlist *sglist, int nelems, int direction)
+static void pci_4u_dma_sync_sg_for_cpu(struct pci_dev *pdev, struct scatterlist *sglist, int nelems, int direction)
@@ -778,0 +778,11 @@
+struct pci_iommu_ops pci_sun4u_iommu_ops = {
+	.alloc_consistent		= pci_4u_alloc_consistent,
+	.free_consistent		= pci_4u_free_consistent,
+	.map_single			= pci_4u_map_single,
+	.unmap_single			= pci_4u_unmap_single,
+	.map_sg				= pci_4u_map_sg,
+	.unmap_sg			= pci_4u_unmap_sg,
+	.dma_sync_single_for_cpu	= pci_4u_dma_sync_single_for_cpu,
+	.dma_sync_sg_for_cpu		= pci_4u_dma_sync_sg_for_cpu,
+};
+
--- ./projects/linux/linux-2.6.18/arch/sparc64/kernel/pci_iommu.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/sparc64/kernel/pci_iommu.c	2006-11-29 22:57:37.000000000 +0100
@@ -284 +284 @@
-	free_npages(iommu, dvma, npages);
+	free_npages(iommu, dvma - iommu->page_table_map_base, npages);
--- ./projects/linux/linux-2.6.20/arch/sparc64/kernel/pci_iommu.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/arch/sparc64/kernel/pci_iommu.c	2007-04-26 05:08:32.000000000 +0200
@@ -67 +67 @@
-static void inline iopte_make_dummy(struct pci_iommu *iommu, iopte_t *iopte)
+static inline void iopte_make_dummy(struct pci_iommu *iommu, iopte_t *iopte)
--- ./projects/linux/linux-2.6.21/arch/sparc64/kernel/pci_iommu.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/arch/sparc64/kernel/pci_iommu.c	2007-07-09 01:32:17.000000000 +0200
@@ -1,2 +1 @@
-/* $Id: pci_iommu.c,v 1.17 2001/12/17 07:05:09 davem Exp $
- * pci_iommu.c: UltraSparc PCI controller IOM/STC support.
+/* pci_iommu.c: UltraSparc PCI controller IOM/STC support.
@@ -4 +3 @@
- * Copyright (C) 1999 David S. Miller (davem@redhat.com)
+ * Copyright (C) 1999, 2007 David S. Miller (davem@davemloft.net)
@@ -11,0 +11 @@
+#include <linux/pci.h>
@@ -13 +13 @@
-#include <asm/pbm.h>
+#include <asm/oplib.h>
@@ -15,0 +16 @@
+#include "pci_impl.h"
@@ -39 +40 @@
-static void __iommu_flushall(struct pci_iommu *iommu)
+static void __iommu_flushall(struct iommu *iommu)
@@ -41,2 +42,5 @@
-	unsigned long tag;
-	int entry;
+	if (iommu->iommu_flushinv) {
+		pci_iommu_write(iommu->iommu_flushinv, ~(u64)0);
+	} else {
+		unsigned long tag;
+		int entry;
@@ -44,5 +48,5 @@
-	tag = iommu->iommu_flush + (0xa580UL - 0x0210UL);
-	for (entry = 0; entry < 16; entry++) {
-		pci_iommu_write(tag, 0);
-		tag += 8;
-	}
+		tag = iommu->iommu_flush + (0xa580UL - 0x0210UL);
+		for (entry = 0; entry < 16; entry++) {
+			pci_iommu_write(tag, 0);
+			tag += 8;
+		}
@@ -50,2 +54,3 @@
-	/* Ensure completion of previous PIO writes. */
-	(void) pci_iommu_read(iommu->write_complete_reg);
+		/* Ensure completion of previous PIO writes. */
+		(void) pci_iommu_read(iommu->write_complete_reg);
+	}
@@ -67 +72 @@
-static inline void iopte_make_dummy(struct pci_iommu *iommu, iopte_t *iopte)
+static inline void iopte_make_dummy(struct iommu *iommu, iopte_t *iopte)
@@ -78 +83 @@
-static long pci_arena_alloc(struct pci_iommu *iommu, unsigned long npages)
+static long pci_arena_alloc(struct iommu *iommu, unsigned long npages)
@@ -80 +85 @@
-	struct pci_iommu_arena *arena = &iommu->arena;
+	struct iommu_arena *arena = &iommu->arena;
@@ -119 +124 @@
-static void pci_arena_free(struct pci_iommu_arena *arena, unsigned long base, unsigned long npages)
+static void pci_arena_free(struct iommu_arena *arena, unsigned long base, unsigned long npages)
@@ -127 +132 @@
-void pci_iommu_table_init(struct pci_iommu *iommu, int tsbsize, u32 dma_offset, u32 dma_addr_mask)
+void pci_iommu_table_init(struct iommu *iommu, int tsbsize, u32 dma_offset, u32 dma_addr_mask)
@@ -173 +178 @@
-static inline iopte_t *alloc_npages(struct pci_iommu *iommu, unsigned long npages)
+static inline iopte_t *alloc_npages(struct iommu *iommu, unsigned long npages)
@@ -184 +189 @@
-static inline void free_npages(struct pci_iommu *iommu, dma_addr_t base, unsigned long npages)
+static inline void free_npages(struct iommu *iommu, dma_addr_t base, unsigned long npages)
@@ -189 +194 @@
-static int iommu_alloc_ctx(struct pci_iommu *iommu)
+static int iommu_alloc_ctx(struct iommu *iommu)
@@ -208 +213 @@
-static inline void iommu_free_ctx(struct pci_iommu *iommu, int ctx)
+static inline void iommu_free_ctx(struct iommu *iommu, int ctx)
@@ -223,2 +228 @@
-	struct pcidev_cookie *pcp;
-	struct pci_iommu *iommu;
+	struct iommu *iommu;
@@ -240,2 +244 @@
-	pcp = pdev->sysdata;
-	iommu = pcp->pbm->iommu;
+	iommu = pdev->dev.archdata.iommu;
@@ -271,2 +274 @@
-	struct pcidev_cookie *pcp;
-	struct pci_iommu *iommu;
+	struct iommu *iommu;
@@ -277,2 +279 @@
-	pcp = pdev->sysdata;
-	iommu = pcp->pbm->iommu;
+	iommu = pdev->dev.archdata.iommu;
@@ -298,3 +299,2 @@
-	struct pcidev_cookie *pcp;
-	struct pci_iommu *iommu;
-	struct pci_strbuf *strbuf;
+	struct iommu *iommu;
+	struct strbuf *strbuf;
@@ -307,3 +307,2 @@
-	pcp = pdev->sysdata;
-	iommu = pcp->pbm->iommu;
-	strbuf = &pcp->pbm->stc;
+	iommu = pdev->dev.archdata.iommu;
+	strbuf = pdev->dev.archdata.stc;
@@ -352 +351 @@
-static void pci_strbuf_flush(struct pci_strbuf *strbuf, struct pci_iommu *iommu, u32 vaddr, unsigned long ctx, unsigned long npages, int direction)
+static void pci_strbuf_flush(struct strbuf *strbuf, struct iommu *iommu, u32 vaddr, unsigned long ctx, unsigned long npages, int direction)
@@ -419,3 +418,2 @@
-	struct pcidev_cookie *pcp;
-	struct pci_iommu *iommu;
-	struct pci_strbuf *strbuf;
+	struct iommu *iommu;
+	struct strbuf *strbuf;
@@ -431,3 +429,2 @@
-	pcp = pdev->sysdata;
-	iommu = pcp->pbm->iommu;
-	strbuf = &pcp->pbm->stc;
+	iommu = pdev->dev.archdata.iommu;
+	strbuf = pdev->dev.archdata.stc;
@@ -548 +545 @@
- * hard time to kepp this routine out of using stack slots for holding variables.
+ * hard time to keep this routine out of using stack slots for holding variables.
@@ -552,3 +549,2 @@
-	struct pcidev_cookie *pcp;
-	struct pci_iommu *iommu;
-	struct pci_strbuf *strbuf;
+	struct iommu *iommu;
+	struct strbuf *strbuf;
@@ -573,3 +569,2 @@
-	pcp = pdev->sysdata;
-	iommu = pcp->pbm->iommu;
-	strbuf = &pcp->pbm->stc;
+	iommu = pdev->dev.archdata.iommu;
+	strbuf = pdev->dev.archdata.stc;
@@ -639,3 +634,2 @@
-	struct pcidev_cookie *pcp;
-	struct pci_iommu *iommu;
-	struct pci_strbuf *strbuf;
+	struct iommu *iommu;
+	struct strbuf *strbuf;
@@ -651,3 +645,2 @@
-	pcp = pdev->sysdata;
-	iommu = pcp->pbm->iommu;
-	strbuf = &pcp->pbm->stc;
+	iommu = pdev->dev.archdata.iommu;
+	strbuf = pdev->dev.archdata.stc;
@@ -699,3 +692,2 @@
-	struct pcidev_cookie *pcp;
-	struct pci_iommu *iommu;
-	struct pci_strbuf *strbuf;
+	struct iommu *iommu;
+	struct strbuf *strbuf;
@@ -704,3 +696,2 @@
-	pcp = pdev->sysdata;
-	iommu = pcp->pbm->iommu;
-	strbuf = &pcp->pbm->stc;
+	iommu = pdev->dev.archdata.iommu;
+	strbuf = pdev->dev.archdata.stc;
@@ -739,3 +730,2 @@
-	struct pcidev_cookie *pcp;
-	struct pci_iommu *iommu;
-	struct pci_strbuf *strbuf;
+	struct iommu *iommu;
+	struct strbuf *strbuf;
@@ -745,3 +735,2 @@
-	pcp = pdev->sysdata;
-	iommu = pcp->pbm->iommu;
-	strbuf = &pcp->pbm->stc;
+	iommu = pdev->dev.archdata.iommu;
+	strbuf = pdev->dev.archdata.stc;
@@ -778 +767 @@
-struct pci_iommu_ops pci_sun4u_iommu_ops = {
+const struct pci_iommu_ops pci_sun4u_iommu_ops = {
@@ -812 +800,0 @@
-	struct pcidev_cookie *pcp = pdev->sysdata;
@@ -818 +806 @@
-		struct pci_iommu *iommu = pcp->pbm->iommu;
+		struct iommu *iommu = pdev->dev.archdata.iommu;
--- ./projects/linux/linux-2.6.15/arch/um/drivers/line.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/arch/um/drivers/line.c	2006-03-20 06:53:29.000000000 +0100
@@ -1 +1 @@
-/* 
+/*
@@ -26,2 +26,3 @@
-	struct tty_struct *tty = data;
-	struct line *line = tty->driver_data;
+	struct chan *chan = data;
+	struct line *line = chan->line;
+	struct tty_struct *tty = line->tty;
@@ -36,2 +37 @@
-	struct tty_struct *tty = arg;
-	struct line *line = tty->driver_data;
+	struct line *line = arg;
@@ -39 +39,3 @@
-	line_interrupt(line->driver->read_irq, arg, NULL);
+	if(!line->throttled)
+		chan_interrupt(&line->chan_list, &line->task, line->tty,
+			       line->driver->read_irq);
@@ -127 +129,2 @@
-	} else {
+	}
+	else {
@@ -173 +176 @@
-	n = write_chan(&line->chan_list, line->head, count, 
+	n = write_chan(&line->chan_list, line->head, count,
@@ -230 +233 @@
-		n = write_chan(&line->chan_list, buf, len, 
+		n = write_chan(&line->chan_list, buf, len,
@@ -340,0 +344,24 @@
+void line_throttle(struct tty_struct *tty)
+{
+	struct line *line = tty->driver_data;
+
+	deactivate_chan(&line->chan_list, line->driver->read_irq);
+	line->throttled = 1;
+}
+
+void line_unthrottle(struct tty_struct *tty)
+{
+	struct line *line = tty->driver_data;
+
+	line->throttled = 0;
+	chan_interrupt(&line->chan_list, &line->task, tty,
+		       line->driver->read_irq);
+
+	/* Maybe there is enough stuff pending that calling the interrupt
+	 * throttles us again.  In this case, line->throttled will be 1
+	 * again and we shouldn't turn the interrupt back on.
+	 */
+	if(!line->throttled)
+		reactivate_chan(&line->chan_list, line->driver->read_irq);
+}
+
@@ -344,2 +371,3 @@
-	struct tty_struct *tty = data;
-	struct line *line = tty->driver_data;
+	struct chan *chan = data;
+	struct line *line = chan->line;
+	struct tty_struct *tty = line->tty;
@@ -367 +395 @@
-	
+
@@ -379 +407 @@
-int line_setup_irq(int fd, int input, int output, struct tty_struct *tty)
+int line_setup_irq(int fd, int input, int output, struct line *line, void *data)
@@ -381 +408,0 @@
-	struct line *line = tty->driver_data;
@@ -387,2 +414,2 @@
-				       line_interrupt, flags, 
-				       driver->read_irq_name, tty);
+				       line_interrupt, flags,
+				       driver->read_irq_name, data);
@@ -393,2 +420,2 @@
-					line_write_interrupt, flags, 
-					driver->write_irq_name, tty);
+					line_write_interrupt, flags,
+					driver->write_irq_name, data);
@@ -399,24 +426 @@
-void line_disable(struct tty_struct *tty, int current_irq)
-{
-	struct line *line = tty->driver_data;
-
-	if(!line->have_irq)
-		return;
-
-	if(line->driver->read_irq == current_irq)
-		free_irq_later(line->driver->read_irq, tty);
-	else {
-		free_irq(line->driver->read_irq, tty);
-	}
-
-	if(line->driver->write_irq == current_irq)
-		free_irq_later(line->driver->write_irq, tty);
-	else {
-		free_irq(line->driver->write_irq, tty);
-	}
-
-	line->have_irq = 0;
-}
-
-int line_open(struct line *lines, struct tty_struct *tty,
-	      struct chan_opts *opts)
+int line_open(struct line *lines, struct tty_struct *tty)
@@ -425 +429 @@
-	int err = 0;
+	int err = -ENODEV;
@@ -433,4 +437,16 @@
-	if (tty->count == 1) {
-		if (!line->valid) {
-			err = -ENODEV;
-			goto out;
+
+	tty->driver_data = line;
+	line->tty = tty;
+	if(!line->valid)
+		goto out;
+
+	if(tty->count == 1){
+		/* Here the device is opened, if necessary, and interrupt
+		 * is registered.
+		 */
+		enable_chan(line);
+		INIT_WORK(&line->task, line_timer_cb, line);
+
+		if(!line->sigio){
+			chan_enable_winch(&line->chan_list, tty);
+			line->sigio = 1;
@@ -438,19 +453,0 @@
-		if (list_empty(&line->chan_list)) {
-			err = parse_chan_pair(line->init_str, &line->chan_list,
-					      line->init_pri, tty->index, opts);
-			if(err) goto out;
-			err = open_chan(&line->chan_list);
-			if(err) goto out;
-		}
-		/* Here the interrupt is registered.*/
-		enable_chan(&line->chan_list, tty);
-		INIT_WORK(&line->task, line_timer_cb, tty);
-	}
-
-	if(!line->sigio){
-		chan_enable_winch(&line->chan_list, tty);
-		line->sigio = 1;
-	}
-	chan_window_size(&line->chan_list, &tty->winsize.ws_row,
-			 &tty->winsize.ws_col);
-	line->count++;
@@ -457,0 +455,5 @@
+		chan_window_size(&line->chan_list, &tty->winsize.ws_row,
+				 &tty->winsize.ws_col);
+	}
+
+	err = 0;
@@ -477,3 +479,2 @@
-	line->count--;
-	if (tty->count == 1) {
-		line_disable(tty, -1);
+	if(tty->count == 1){
+		line->tty = NULL;
@@ -481 +481,0 @@
-	}
@@ -483,3 +483,4 @@
-        if((line->count == 0) && line->sigio){
-                unregister_winch(tty);
-                line->sigio = 0;
+		if(line->sigio){
+			unregister_winch(tty);
+			line->sigio = 0;
+		}
@@ -496 +497 @@
-		close_chan(&lines[i].chan_list);
+		close_chan(&lines[i].chan_list, 0);
@@ -502,3 +503 @@
- * @all_allowed is a boolean saying if we can setup the whole @lines
- * at once. For instance, it will be usually true for startup init. (where we
- * can use con=xterm) and false for mconsole.*/
+ */
@@ -506 +505 @@
-int line_setup(struct line *lines, unsigned int num, char *init, int all_allowed)
+int line_setup(struct line *lines, unsigned int num, char *init)
@@ -515 +514,2 @@
-	} else {
+	}
+	else {
@@ -518 +518 @@
-			printk(KERN_ERR "line_setup failed to parse \"%s\"\n", 
+			printk(KERN_ERR "line_setup failed to parse \"%s\"\n",
@@ -530,2 +530,3 @@
-	} else if (n >= 0){
-		if (lines[n].count > 0) {
+	}
+	else if (n >= 0){
+		if (lines[n].tty != NULL) {
@@ -542 +543 @@
-			}	
+			}
@@ -544,5 +545,2 @@
-	} else if(!all_allowed){
-		printk("line_setup - can't configure all devices from "
-		       "mconsole\n");
-		return 0;
-	} else {
+	}
+	else {
@@ -560 +558 @@
-	return 1;
+	return n == -1 ? num : n;
@@ -563 +561,2 @@
-int line_config(struct line *lines, unsigned int num, char *str)
+int line_config(struct line *lines, unsigned int num, char *str,
+		struct chan_opts *opts)
@@ -565 +564,3 @@
-	char *new = uml_strdup(str);
+	struct line *line;
+	char *new;
+	int n;
@@ -566,0 +568,7 @@
+	if(*str == '='){
+		printk("line_config - can't configure all devices from "
+		       "mconsole\n");
+		return 1;
+	}
+
+	new = kstrdup(str, GFP_KERNEL);
@@ -568,2 +576,2 @@
-		printk("line_config - uml_strdup failed\n");
-		return -ENOMEM;
+		printk("line_config - kstrdup failed\n");
+		return 1;
@@ -571 +579,6 @@
-	return !line_setup(lines, num, new, 0);
+	n = line_setup(lines, num, new);
+	if(n < 0)
+		return 1;
+
+	line = &lines[n];
+	return parse_chan_pair(line->init_str, line, n, opts);
@@ -597 +610 @@
-	else if(line->count == 0)
+	else if(line->tty == NULL)
@@ -621,0 +635 @@
+	int err;
@@ -625 +639,4 @@
-	return !line_setup(lines, num, config, 0);
+	err = line_setup(lines, num, config);
+	if(err >= 0)
+		err = 0;
+	return err;
@@ -629 +646 @@
-			 struct line_driver *line_driver, 
+			 struct line_driver *line_driver,
@@ -658 +675 @@
-		if(!lines[i].valid) 
+		if(!lines[i].valid)
@@ -666,2 +683,2 @@
-static spinlock_t winch_handler_lock;
-LIST_HEAD(winch_handlers);
+static DEFINE_SPINLOCK(winch_handler_lock);
+static LIST_HEAD(winch_handlers);
@@ -669 +686 @@
-void lines_init(struct line *lines, int nlines)
+void lines_init(struct line *lines, int nlines, struct chan_opts *opts)
@@ -674 +690,0 @@
-	spin_lock_init(&winch_handler_lock);
@@ -678,6 +694,11 @@
-		spin_lock_init(&line->lock);
-		if(line->init_str != NULL){
-			line->init_str = uml_strdup(line->init_str);
-			if(line->init_str == NULL)
-				printk("lines_init - uml_strdup returned "
-				       "NULL\n");
+
+		if(line->init_str == NULL)
+			continue;
+
+		line->init_str = kstrdup(line->init_str, GFP_KERNEL);
+		if(line->init_str == NULL)
+			printk("lines_init - kstrdup returned NULL\n");
+
+		if(parse_chan_pair(line->init_str, line, i, opts)){
+			printk("parse_chan_pair failed for device %d\n", i);
+			line->valid = 0;
@@ -696 +717 @@
-irqreturn_t winch_interrupt(int irq, void *data, struct pt_regs *unused)
+static irqreturn_t winch_interrupt(int irq, void *data, struct pt_regs *unused)
@@ -720,2 +741 @@
-		chan_window_size(&line->chan_list,
-				 &tty->winsize.ws_row, 
+		chan_window_size(&line->chan_list, &tty->winsize.ws_row,
@@ -752 +772 @@
-			  SA_INTERRUPT | SA_SHIRQ | SA_SAMPLE_RANDOM, 
+			  SA_INTERRUPT | SA_SHIRQ | SA_SAMPLE_RANDOM,
@@ -756,0 +777,13 @@
+static void free_winch(struct winch *winch)
+{
+	list_del(&winch->list);
+
+	if(winch->pid != -1)
+		os_kill_process(winch->pid, 1);
+	if(winch->fd != -1)
+		os_close_file(winch->fd);
+
+	free_irq(WINCH_IRQ, winch);
+	kfree(winch);
+}
+
@@ -760 +793 @@
-	struct winch *winch, *found = NULL;
+	struct winch *winch;
@@ -762,0 +796 @@
+
@@ -766,2 +800,2 @@
-                        found = winch;
-                        break;
+			free_winch(winch);
+			break;
@@ -770,14 +803,0 @@
-        if(found == NULL)
-		goto err;
-
-	list_del(&winch->list);
-	spin_unlock(&winch_handler_lock);
-
-        if(winch->pid != -1)
-                os_kill_process(winch->pid, 1);
-
-        free_irq(WINCH_IRQ, winch);
-        kfree(winch);
-
-	return;
-err:
@@ -787,2 +806,0 @@
-/* XXX: No lock as it's an exitcall... is this valid? Depending on cleanup
- * order... are we sure that nothing else is done on the list? */
@@ -791 +809 @@
-	struct list_head *ele;
+	struct list_head *ele, *next;
@@ -794 +812,3 @@
-	list_for_each(ele, &winch_handlers){
+	spin_lock(&winch_handler_lock);
+
+	list_for_each_safe(ele, next, &winch_handlers){
@@ -796,9 +816 @@
-		if(winch->fd != -1){
-			/* Why is this different from the above free_irq(),
-			 * which deactivates SIGIO? This searches the FD
-			 * somewhere else and removes it from the list... */
-			deactivate_fd(winch->fd, WINCH_IRQ);
-			os_close_file(winch->fd);
-		}
-		if(winch->pid != -1) 
-			os_kill_process(winch->pid, 1);
+		free_winch(winch);
@@ -805,0 +818,2 @@
+
+	spin_unlock(&winch_handler_lock);
@@ -814,2 +828,2 @@
-	umid = get_umid(1);
-	if(umid == NULL)
+	umid = get_umid();
+	if(*umid == '\0')
@@ -817 +831 @@
-	
+
--- ./projects/linux/linux-2.6.17/arch/um/drivers/line.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/um/drivers/line.c	2006-09-20 05:42:06.000000000 +0200
@@ -11 +10,0 @@
-#include "linux/devfs_fs_kernel.h"
@@ -377 +376 @@
-	 * SA_INTERRUPT (see line_setup_irq).*/
+	 * IRQF_DISABLED (see line_setup_irq).*/
@@ -410 +409 @@
-	int err = 0, flags = SA_INTERRUPT | SA_SHIRQ | SA_SAMPLE_RANDOM;
+	int err = 0, flags = IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM;
@@ -658 +656,0 @@
-	driver->devfs_name = line_driver->devfs_name;
@@ -772 +770 @@
-			  SA_INTERRUPT | SA_SHIRQ | SA_SAMPLE_RANDOM,
+			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
--- ./projects/linux/linux-2.6.18/arch/um/drivers/line.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/um/drivers/line.c	2006-11-29 22:57:37.000000000 +0100
@@ -23 +23 @@
-static irqreturn_t line_interrupt(int irq, void *data, struct pt_regs *unused)
+static irqreturn_t line_interrupt(int irq, void *data)
@@ -254 +254 @@
-static struct {
+static const struct {
@@ -367,2 +367 @@
-static irqreturn_t line_write_interrupt(int irq, void *data,
-					struct pt_regs *unused)
+static irqreturn_t line_write_interrupt(int irq, void *data)
@@ -408 +407 @@
-	struct line_driver *driver = line->driver;
+	const struct line_driver *driver = line->driver;
@@ -500 +499 @@
- * @lines contains the the array (of size @num) to modify;
+ * @lines contains the array (of size @num) to modify;
@@ -561 +560 @@
-		struct chan_opts *opts)
+		const struct chan_opts *opts)
@@ -645,3 +644,3 @@
-			 struct line_driver *line_driver,
-			 struct tty_operations *ops, struct line *lines,
-			 int nlines)
+				       struct line_driver *line_driver,
+				       const struct tty_operations *ops,
+				       struct line *lines, int nlines)
@@ -715 +714 @@
-static irqreturn_t winch_interrupt(int irq, void *data, struct pt_regs *unused)
+static irqreturn_t winch_interrupt(int irq, void *data)
--- ./projects/linux/linux-2.6.19/arch/um/drivers/line.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/arch/um/drivers/line.c	2007-02-04 19:44:54.000000000 +0100
@@ -34 +34 @@
-static void line_timer_cb(void *arg)
+static void line_timer_cb(struct work_struct *work)
@@ -36 +36 @@
-	struct line *line = arg;
+	struct line *line = container_of(work, struct line, task.work);
@@ -249 +249 @@
-void line_set_termios(struct tty_struct *tty, struct termios * old)
+void line_set_termios(struct tty_struct *tty, struct ktermios * old)
@@ -446 +446 @@
-		INIT_WORK(&line->task, line_timer_cb, line);
+		INIT_DELAYED_WORK(&line->task, line_timer_cb);
--- ./projects/linux/linux-2.6.20/arch/um/drivers/line.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/arch/um/drivers/line.c	2007-04-26 05:08:32.000000000 +0200
@@ -194 +193,0 @@
-		//return 0;
@@ -374 +373 @@
-	/* Interrupts are enabled here because we registered the interrupt with
+	/* Interrupts are disabled here because we registered the interrupt with
@@ -377 +376 @@
-	spin_lock_irq(&line->lock);
+	spin_lock(&line->lock);
@@ -385 +384 @@
-	spin_unlock_irq(&line->lock);
+	spin_unlock(&line->lock);
@@ -423,0 +423,16 @@
+/* Normally, a driver like this can rely mostly on the tty layer
+ * locking, particularly when it comes to the driver structure.
+ * However, in this case, mconsole requests can come in "from the
+ * side", and race with opens and closes.
+ *
+ * mconsole config requests will want to be sure the device isn't in
+ * use, and get_config, open, and close will want a stable
+ * configuration.  The checking and modification of the configuration
+ * is done under a spinlock.  Checking whether the device is in use is
+ * line->tty->count > 1, also under the spinlock.
+ *
+ * tty->count serves to decide whether the device should be enabled or
+ * disabled on the host.  If it's equal to 1, then we are doing the
+ * first open or last close.  Otherwise, open and close just return.
+ */
+
@@ -426 +441 @@
-	struct line *line;
+	struct line *line = &lines[tty->index];
@@ -429,2 +444,3 @@
-	line = &lines[tty->index];
-	tty->driver_data = line;
+	spin_lock(&line->count_lock);
+	if(!line->valid)
+		goto out_unlock;
@@ -432,3 +448,5 @@
-	/* The IRQ which takes this lock is not yet enabled and won't be run
-	 * before the end, so we don't need to use spin_lock_irq.*/
-	spin_lock(&line->lock);
+	err = 0;
+	if(tty->count > 1)
+		goto out_unlock;
+
+	spin_unlock(&line->count_lock);
@@ -438,2 +455,0 @@
-	if(!line->valid)
-		goto out;
@@ -441,11 +457,2 @@
-	if(tty->count == 1){
-		/* Here the device is opened, if necessary, and interrupt
-		 * is registered.
-		 */
-		enable_chan(line);
-		INIT_DELAYED_WORK(&line->task, line_timer_cb);
-
-		if(!line->sigio){
-			chan_enable_winch(&line->chan_list, tty);
-			line->sigio = 1;
-		}
+	enable_chan(line);
+	INIT_DELAYED_WORK(&line->task, line_timer_cb);
@@ -453,2 +460,3 @@
-		chan_window_size(&line->chan_list, &tty->winsize.ws_row,
-				 &tty->winsize.ws_col);
+	if(!line->sigio){
+		chan_enable_winch(&line->chan_list, tty);
+		line->sigio = 1;
@@ -457,3 +465,7 @@
-	err = 0;
-out:
-	spin_unlock(&line->lock);
+	chan_window_size(&line->chan_list, &tty->winsize.ws_row,
+			 &tty->winsize.ws_col);
+
+	return err;
+
+out_unlock:
+	spin_unlock(&line->count_lock);
@@ -469,4 +481,5 @@
-	/* XXX: I assume this should be called in process context, not with
-         *  interrupts disabled!
-         */
-	spin_lock_irq(&line->lock);
+	/* If line_open fails (and tty->driver_data is never set),
+	 * tty_open will call line_close.  So just return in this case.
+	 */
+	if(line == NULL)
+		return;
@@ -477,8 +490,15 @@
-	if(tty->count == 1){
-		line->tty = NULL;
-		tty->driver_data = NULL;
-
-		if(line->sigio){
-			unregister_winch(tty);
-			line->sigio = 0;
-		}
+	spin_lock(&line->count_lock);
+	if(!line->valid)
+		goto out_unlock;
+
+	if(tty->count > 1)
+		goto out_unlock;
+
+	spin_unlock(&line->count_lock);
+
+	line->tty = NULL;
+	tty->driver_data = NULL;
+
+	if(line->sigio){
+		unregister_winch(tty);
+		line->sigio = 0;
@@ -487 +507,4 @@
-	spin_unlock_irq(&line->lock);
+	return;
+
+out_unlock:
+	spin_unlock(&line->count_lock);
@@ -497,0 +521,28 @@
+static int setup_one_line(struct line *lines, int n, char *init, int init_prio,
+			  char **error_out)
+{
+	struct line *line = &lines[n];
+	int err = -EINVAL;
+
+	spin_lock(&line->count_lock);
+
+	if(line->tty != NULL){
+		*error_out = "Device is already open";
+		goto out;
+	}
+
+	if (line->init_pri <= init_prio){
+		line->init_pri = init_prio;
+		if (!strcmp(init, "none"))
+			line->valid = 0;
+		else {
+			line->init_str = init;
+			line->valid = 1;
+		}
+	}
+	err = 0;
+out:
+	spin_unlock(&line->count_lock);
+	return err;
+}
+
@@ -500,0 +552 @@
+ * @error_out is an error string in the case of failure;
@@ -503 +555,2 @@
-int line_setup(struct line *lines, unsigned int num, char *init)
+int line_setup(struct line *lines, unsigned int num, char *init,
+	       char **error_out)
@@ -505 +558 @@
-	int i, n;
+	int i, n, err;
@@ -516,3 +569,2 @@
-			printk(KERN_ERR "line_setup failed to parse \"%s\"\n",
-			       init);
-			return 0;
+			*error_out = "Couldn't parse device number";
+			return -EINVAL;
@@ -525,3 +577,2 @@
-		printk("line_setup - %d out of range ((0 ... %d) allowed)\n",
-		       n, num - 1);
-		return 0;
+		*error_out = "Device number out of range";
+		return -EINVAL;
@@ -530,13 +581,3 @@
-		if (lines[n].tty != NULL) {
-			printk("line_setup - device %d is open\n", n);
-			return 0;
-		}
-		if (lines[n].init_pri <= INIT_ONE){
-			lines[n].init_pri = INIT_ONE;
-			if (!strcmp(init, "none"))
-				lines[n].valid = 0;
-			else {
-				lines[n].init_str = init;
-				lines[n].valid = 1;
-			}
-		}
+		err = setup_one_line(lines, n, init, INIT_ONE, error_out);
+		if(err)
+			return err;
@@ -546,8 +587,4 @@
-			if(lines[i].init_pri <= INIT_ALL){
-				lines[i].init_pri = INIT_ALL;
-				if(!strcmp(init, "none")) lines[i].valid = 0;
-				else {
-					lines[i].init_str = init;
-					lines[i].valid = 1;
-				}
-			}
+			err = setup_one_line(lines, i, init, INIT_ALL,
+					     error_out);
+			if(err)
+				return err;
@@ -560 +597 @@
-		const struct chan_opts *opts)
+		const struct chan_opts *opts, char **error_out)
@@ -567,3 +604,2 @@
-		printk("line_config - can't configure all devices from "
-		       "mconsole\n");
-		return 1;
+		*error_out = "Can't configure all devices from mconsole";
+		return -EINVAL;
@@ -574,2 +610,2 @@
-		printk("line_config - kstrdup failed\n");
-		return 1;
+		*error_out = "Failed to allocate memory";
+		return -ENOMEM;
@@ -577 +613 @@
-	n = line_setup(lines, num, new);
+	n = line_setup(lines, num, new, error_out);
@@ -579 +615 @@
-		return 1;
+		return n;
@@ -582 +618 @@
-	return parse_chan_pair(line->init_str, line, n, opts);
+	return parse_chan_pair(line->init_str, line, n, opts, error_out);
@@ -605 +641 @@
-	spin_lock(&line->lock);
+	spin_lock(&line->count_lock);
@@ -611 +647 @@
-	spin_unlock(&line->lock);
+	spin_unlock(&line->count_lock);
@@ -631 +667 @@
-int line_remove(struct line *lines, unsigned int num, int n)
+int line_remove(struct line *lines, unsigned int num, int n, char **error_out)
@@ -637 +673 @@
-	err = line_setup(lines, num, config);
+	err = line_setup(lines, num, config, error_out);
@@ -643,4 +679,3 @@
-struct tty_driver *line_register_devfs(struct lines *set,
-				       struct line_driver *line_driver,
-				       const struct tty_operations *ops,
-				       struct line *lines, int nlines)
+struct tty_driver *register_lines(struct line_driver *line_driver,
+				  const struct tty_operations *ops,
+				  struct line *lines, int nlines)
@@ -685,0 +721 @@
+	char *error;
@@ -699,2 +735,3 @@
-		if(parse_chan_pair(line->init_str, line, i, opts)){
-			printk("parse_chan_pair failed for device %d\n", i);
+		if(parse_chan_pair(line->init_str, line, i, opts, &error)){
+			printk("parse_chan_pair failed for device %d : %s\n",
+			       i, error);
@@ -740 +777 @@
-		kill_pg(tty->pgrp, SIGWINCH, 1);
+		kill_pgrp(tty->pgrp, SIGWINCH, 1);
--- ./projects/linux/linux-2.6.21/arch/um/drivers/line.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/arch/um/drivers/line.c	2007-07-09 01:32:17.000000000 +0200
@@ -5,0 +6 @@
+#include "linux/kernel.h"
@@ -16 +16,0 @@
-#include "user_util.h"
--- ./projects/linux/linux-2.6.22/arch/um/drivers/line.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/arch/um/drivers/line.c	2007-10-09 22:31:38.000000000 +0200
@@ -457 +457,4 @@
-	enable_chan(line);
+	err = enable_chan(line);
+	if (err)
+		return err;
+
@@ -748,0 +752 @@
+	unsigned long stack;
@@ -750,0 +755,15 @@
+static void free_winch(struct winch *winch, int free_irq_ok)
+{
+	list_del(&winch->list);
+
+	if (winch->pid != -1)
+		os_kill_process(winch->pid, 1);
+	if (winch->fd != -1)
+		os_close_file(winch->fd);
+	if (winch->stack != 0)
+		free_stack(winch->stack, 0);
+	if (free_irq_ok)
+		free_irq(WINCH_IRQ, winch);
+	kfree(winch);
+}
+
@@ -766,0 +786 @@
+				free_winch(winch, 0);
@@ -772 +792 @@
-	tty  = winch->tty;
+	tty = winch->tty;
@@ -785 +805,2 @@
-void register_winch_irq(int fd, int tty_fd, int pid, struct tty_struct *tty)
+void register_winch_irq(int fd, int tty_fd, int pid, struct tty_struct *tty,
+			unsigned long stack)
@@ -792 +813 @@
-		return;
+		goto cleanup;
@@ -799 +820,9 @@
-				   .tty 	= tty });
+				   .tty 	= tty,
+				   .stack	= stack });
+
+	if (um_request_irq(WINCH_IRQ, fd, IRQ_READ, winch_interrupt,
+			   IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
+			   "winch", winch) < 0) {
+		printk("register_winch_irq - failed to register IRQ\n");
+		goto out_free;
+	}
@@ -805,14 +834 @@
-	if(um_request_irq(WINCH_IRQ, fd, IRQ_READ, winch_interrupt,
-			  IRQF_DISABLED | IRQF_SHARED | IRQF_SAMPLE_RANDOM,
-			  "winch", winch) < 0)
-		printk("register_winch_irq - failed to register IRQ\n");
-}
-
-static void free_winch(struct winch *winch)
-{
-	list_del(&winch->list);
-
-	if(winch->pid != -1)
-		os_kill_process(winch->pid, 1);
-	if(winch->fd != -1)
-		os_close_file(winch->fd);
+	return;
@@ -820 +836 @@
-	free_irq(WINCH_IRQ, winch);
+ out_free:
@@ -821,0 +838,5 @@
+ cleanup:
+	os_kill_process(pid, 1);
+	os_close_file(fd);
+	if (stack != 0)
+		free_stack(stack, 0);
@@ -834 +855 @@
-			free_winch(winch);
+			free_winch(winch, 1);
@@ -850 +871 @@
-		free_winch(winch);
+		free_winch(winch, 1);
--- ./projects/linux/linux-2.6.23/arch/um/drivers/line.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/arch/um/drivers/line.c	2008-01-24 23:58:37.000000000 +0100
@@ -2 +2 @@
- * Copyright (C) 2001, 2002 Jeff Dike (jdike@karaya.com)
+ * Copyright (C) 2001 - 2007 Jeff Dike (jdike@{addtoit,linux.intel}.com)
@@ -6,4 +6 @@
-#include "linux/kernel.h"
-#include "linux/sched.h"
-#include "linux/slab.h"
-#include "linux/list.h"
+#include "linux/irqreturn.h"
@@ -11,2 +7,0 @@
-#include "linux/interrupt.h"
-#include "asm/uaccess.h"
@@ -13,0 +9 @@
+#include "irq_kern.h"
@@ -15,3 +10,0 @@
-#include "line.h"
-#include "kern.h"
-#include "kern_util.h"
@@ -19 +11,0 @@
-#include "irq_kern.h"
@@ -38 +30 @@
-	if(!line->throttled)
+	if (!line->throttled)
@@ -43 +35,2 @@
-/* Returns the free space inside the ring buffer of this line.
+/*
+ * Returns the free space inside the ring buffer of this line.
@@ -45 +38 @@
- * Should be called while holding line->lock (this does not modify datas).
+ * Should be called while holding line->lock (this does not modify data).
@@ -110 +103 @@
-	if(line->buffer == NULL){
+	if (line->buffer == NULL) {
@@ -113,2 +106,3 @@
-			printk("buffer_data - atomic allocation failed\n");
-			return(0);
+			printk(KERN_ERR "buffer_data - atomic allocation "
+			       "failed\n");
+			return 0;
@@ -125 +119 @@
-	if (len < end){
+	if (len < end) {
@@ -165,2 +159,4 @@
-			/* We have flushed from ->head to buffer end, now we
-			 * must flush only from the beginning to ->tail.*/
+			/*
+			 * We have flushed from ->head to buffer end, now we
+			 * must flush only from the beginning to ->tail.
+			 */
@@ -178 +174 @@
-	if(n < 0)
+	if (n < 0)
@@ -192 +188 @@
-	if(tty->stopped)
+	if (tty->stopped)
@@ -197,2 +192,0 @@
-	/*if (err == 1)
-		err = 0;*/
@@ -200 +193,0 @@
-	//return err;
@@ -203,2 +196,4 @@
-/* We map both ->flush_chars and ->put_char (which go in pair) onto ->flush_buffer
- * and ->write. Hope it's not that bad.*/
+/*
+ * We map both ->flush_chars and ->put_char (which go in pair) onto
+ * ->flush_buffer and ->write. Hope it's not that bad.
+ */
@@ -219 +214 @@
-	int n, err, ret = 0;
+	int n, ret = 0;
@@ -221 +216 @@
-	if(tty->stopped)
+	if (tty->stopped)
@@ -225 +220 @@
-	if (line->head != line->tail) {
+	if (line->head != line->tail)
@@ -227,4 +222 @@
-		err = flush_buffer(line);
-		if (err <= 0 && (err != -EAGAIN || !ret))
-			ret = err;
-	} else {
+	else {
@@ -260,4 +252,4 @@
-        { TCSETS,      NULL,       "TCSETS"      },
-        { TCSETSW,     NULL,       "TCSETSW"     },
-        { TCFLSH,      NULL,       "TCFLSH"      },
-        { TCSBRK,      NULL,       "TCSBRK"      },
+	{ TCSETS,      NULL,       "TCSETS"      },
+	{ TCSETSW,     NULL,       "TCSETSW"     },
+	{ TCFLSH,      NULL,       "TCFLSH"      },
+	{ TCSBRK,      NULL,       "TCSBRK"      },
@@ -266,5 +258,5 @@
-        { TCSETSF,     KERN_DEBUG, "TCSETSF"     },
-        { TCGETA,      KERN_DEBUG, "TCGETA"      },
-        { TIOCMGET,    KERN_DEBUG, "TIOCMGET"    },
-        { TCSBRKP,     KERN_DEBUG, "TCSBRKP"     },
-        { TIOCMSET,    KERN_DEBUG, "TIOCMSET"    },
+	{ TCSETSF,     KERN_DEBUG, "TCSETSF"     },
+	{ TCGETA,      KERN_DEBUG, "TCGETA"      },
+	{ TIOCMGET,    KERN_DEBUG, "TIOCMGET"    },
+	{ TCSBRKP,     KERN_DEBUG, "TCSBRKP"     },
+	{ TIOCMSET,    KERN_DEBUG, "TIOCMSET"    },
@@ -327,6 +319 @@
-		if (i < ARRAY_SIZE(tty_ioctls)) {
-			if (NULL != tty_ioctls[i].level)
-				printk("%s%s: %s: ioctl %s called\n",
-				       tty_ioctls[i].level, __FUNCTION__,
-				       tty->name, tty_ioctls[i].name);
-		} else {
+		if (i == ARRAY_SIZE(tty_ioctls)) {
@@ -358 +345,2 @@
-	/* Maybe there is enough stuff pending that calling the interrupt
+	/*
+	 * Maybe there is enough stuff pending that calling the interrupt
@@ -362 +350 @@
-	if(!line->throttled)
+	if (!line->throttled)
@@ -373,2 +361,4 @@
-	/* Interrupts are disabled here because we registered the interrupt with
-	 * IRQF_DISABLED (see line_setup_irq).*/
+	/*
+	 * Interrupts are disabled here because we registered the interrupt with
+	 * IRQF_DISABLED (see line_setup_irq).
+	 */
@@ -380 +370 @@
-	} else if(err < 0) {
+	} else if (err < 0) {
@@ -386 +376 @@
-	if(tty == NULL)
+	if (tty == NULL)
@@ -393 +383,2 @@
-	/* BLOCKING mode
+	/*
+	 * BLOCKING mode
@@ -423 +414,2 @@
-/* Normally, a driver like this can rely mostly on the tty layer
+/*
+ * Normally, a driver like this can rely mostly on the tty layer
@@ -445 +437 @@
-	if(!line->valid)
+	if (!line->valid)
@@ -449 +441 @@
-	if(tty->count > 1)
+	if (tty->count > 1)
@@ -463 +455 @@
-	if(!line->sigio){
+	if (!line->sigio) {
@@ -484 +476,2 @@
-	/* If line_open fails (and tty->driver_data is never set),
+	/*
+	 * If line_open fails (and tty->driver_data is never set),
@@ -487 +480 @@
-	if(line == NULL)
+	if (line == NULL)
@@ -494 +487 @@
-	if(!line->valid)
+	if (!line->valid)
@@ -497 +490 @@
-	if(tty->count > 1)
+	if (tty->count > 1)
@@ -505 +498 @@
-	if(line->sigio){
+	if (line->sigio) {
@@ -508 +501 @@
-        }
+	}
@@ -532 +525 @@
-	if(line->tty != NULL){
+	if (line->tty != NULL) {
@@ -537 +530 @@
-	if (line->init_pri <= init_prio){
+	if (line->init_pri <= init_prio) {
@@ -552 +545,2 @@
-/* Common setup code for both startup command line and mconsole initialization.
+/*
+ * Common setup code for both startup command line and mconsole initialization.
@@ -564,3 +558,5 @@
-	if(*init == '=') {
-		/* We said con=/ssl= instead of con#=, so we are configuring all
-		 * consoles at once.*/
+	if (*init == '=') {
+		/*
+		 * We said con=/ssl= instead of con#=, so we are configuring all
+		 * consoles at once.
+		 */
@@ -571 +567 @@
-		if(*end != '='){
+		if (*end != '=') {
@@ -583 +579 @@
-	else if (n >= 0){
+	else if (n >= 0) {
@@ -585 +581 @@
-		if(err)
+		if (err)
@@ -589 +585 @@
-		for(i = 0; i < num; i++){
+		for(i = 0; i < num; i++) {
@@ -592 +588 @@
-			if(err)
+			if (err)
@@ -606 +602 @@
-	if(*str == '='){
+	if (*str == '=') {
@@ -612 +608 @@
-	if(new == NULL){
+	if (new == NULL) {
@@ -617 +613 @@
-	if(n < 0)
+	if (n < 0)
@@ -632 +628 @@
-	if((*end != '\0') || (end == name)){
+	if ((*end != '\0') || (end == name)) {
@@ -637 +633 @@
-	if((dev < 0) || (dev >= num)){
+	if ((dev < 0) || (dev >= num)) {
@@ -645 +641 @@
-	if(!line->valid)
+	if (!line->valid)
@@ -647 +643 @@
-	else if(line->tty == NULL)
+	else if (line->tty == NULL)
@@ -658 +654 @@
-        int n;
+	int n;
@@ -661,2 +657,2 @@
-	if((*end != '\0') || (end == *str))
-                return -1;
+	if ((*end != '\0') || (end == *str))
+		return -1;
@@ -664,4 +660,4 @@
-        *str = end;
-        *start_out = n;
-        *end_out = n;
-        return n;
+	*str = end;
+	*start_out = n;
+	*end_out = n;
+	return n;
@@ -677 +673 @@
-	if(err >= 0)
+	if (err >= 0)
@@ -703,2 +699,2 @@
-		printk("%s: can't register %s driver\n",
-		       __FUNCTION__,line_driver->name);
+		printk(KERN_ERR "register_lines : can't register %s driver\n",
+		       line_driver->name);
@@ -709,2 +705,2 @@
-	for(i = 0; i < nlines; i++){
-		if(!lines[i].valid)
+	for(i = 0; i < nlines; i++) {
+		if (!lines[i].valid)
@@ -727 +723 @@
-	for(i = 0; i < nlines; i++){
+	for(i = 0; i < nlines; i++) {
@@ -731 +727 @@
-		if(line->init_str == NULL)
+		if (line->init_str == NULL)
@@ -735,2 +731,2 @@
-		if(line->init_str == NULL)
-			printk("lines_init - kstrdup returned NULL\n");
+		if (line->init_str == NULL)
+			printk(KERN_ERR "lines_init - kstrdup returned NULL\n");
@@ -738,3 +734,3 @@
-		if(parse_chan_pair(line->init_str, line, i, opts, &error)){
-			printk("parse_chan_pair failed for device %d : %s\n",
-			       i, error);
+		if (parse_chan_pair(line->init_str, line, i, opts, &error)) {
+			printk(KERN_ERR "parse_chan_pair failed for "
+			       "device %d : %s\n", i, error);
@@ -778 +774 @@
-	if(winch->fd != -1){
+	if (winch->fd != -1) {
@@ -780,6 +776,6 @@
-		if(err < 0){
-			if(err != -EAGAIN){
-				printk("winch_interrupt : read failed, "
-				       "errno = %d\n", -err);
-				printk("fd %d is losing SIGWINCH support\n",
-				       winch->tty_fd);
+		if (err < 0) {
+			if (err != -EAGAIN) {
+				printk(KERN_ERR "winch_interrupt : "
+				       "read failed, errno = %d\n", -err);
+				printk(KERN_ERR "fd %d is losing SIGWINCH "
+				       "support\n", winch->tty_fd);
@@ -800 +796 @@
-	if(winch->fd != -1)
+	if (winch->fd != -1)
@@ -812 +808 @@
-		printk("register_winch_irq - kmalloc failed\n");
+		printk(KERN_ERR "register_winch_irq - kmalloc failed\n");
@@ -826 +822,2 @@
-		printk("register_winch_irq - failed to register IRQ\n");
+		printk(KERN_ERR "register_winch_irq - failed to register "
+		       "IRQ\n");
@@ -852 +849 @@
-	list_for_each(ele, &winch_handlers){
+	list_for_each(ele, &winch_handlers) {
@@ -854 +851 @@
-                if(winch->tty == tty){
+		if (winch->tty == tty) {
@@ -857,2 +854,2 @@
-                }
-        }
+		}
+	}
@@ -869 +866 @@
-	list_for_each_safe(ele, next, &winch_handlers){
+	list_for_each_safe(ele, next, &winch_handlers) {
@@ -884 +881 @@
-	if(*umid == '\0')
+	if (*umid == '\0')
@@ -889,2 +886,2 @@
-	if(title == NULL){
-		printk("Failed to allocate buffer for xterm title\n");
+	if (title == NULL) {
+		printk(KERN_ERR "Failed to allocate buffer for xterm title\n");
--- ./projects/linux/linux-2.6.24/arch/um/drivers/line.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/um/drivers/line.c	2008-04-17 04:49:44.000000000 +0200
@@ -10,0 +11 @@
+#include "kern_util.h"
@@ -51 +52 @@
-		n = LINE_BUFSIZE + n; /* The other case */
+		n += LINE_BUFSIZE; /* The other case */
@@ -61,3 +61,0 @@
-	if (tty->stopped)
-		return 0;
-
@@ -68,4 +65,0 @@
-	/*XXX: Warning to remove */
-	if (0 == room)
-		printk(KERN_DEBUG "%s: %s: no room left in buffer\n",
-		       __FUNCTION__,tty->name);
@@ -82,2 +76 @@
-
-	/*write_room subtracts 1 for the needed NULL, so we readd it.*/
+	/* write_room subtracts 1 for the needed NULL, so we readd it.*/
@@ -187,4 +179,0 @@
-	/*XXX: copied from line_write, verify if it is correct!*/
-	if (tty->stopped)
-		return;
-
@@ -216,3 +204,0 @@
-	if (tty->stopped)
-		return 0;
-
@@ -791,3 +777,5 @@
-		chan_window_size(&line->chan_list, &tty->winsize.ws_row,
-				 &tty->winsize.ws_col);
-		kill_pgrp(tty->pgrp, SIGWINCH, 1);
+		if (line != NULL) {
+			chan_window_size(&line->chan_list, &tty->winsize.ws_row,
+					 &tty->winsize.ws_col);
+			kill_pgrp(tty->pgrp, SIGWINCH, 1);
+		}
--- ./projects/linux/linux-2.6.25/arch/um/drivers/line.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/arch/um/drivers/line.c	2008-07-13 23:51:29.000000000 +0200
@@ -194 +194 @@
-void line_put_char(struct tty_struct *tty, unsigned char ch)
+int line_put_char(struct tty_struct *tty, unsigned char ch)
@@ -196 +196 @@
-	line_write(tty, &ch, sizeof(ch));
+	return line_write(tty, &ch, sizeof(ch));
@@ -307 +307 @@
-			       __FUNCTION__, tty->name, cmd);
+			       __func__, tty->name, cmd);
--- ./projects/linux/linux-2.6.26/arch/um/drivers/line.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/arch/um/drivers/line.c	2008-10-10 00:13:53.000000000 +0200
@@ -365,13 +365 @@
-	if (test_bit(TTY_DO_WRITE_WAKEUP, &tty->flags) &&
-	   (tty->ldisc.write_wakeup != NULL))
-		(tty->ldisc.write_wakeup)(tty);
-
-	/*
-	 * BLOCKING mode
-	 * In blocking mode, everything sleeps on tty->write_wait.
-	 * Sleeping in the console driver would break non-blocking
-	 * writes.
-	 */
-
-	if (waitqueue_active(&tty->write_wait))
-		wake_up_interruptible(&tty->write_wait);
+	tty_wakeup(tty);
--- ./projects/linux/linux-2.6.27/arch/um/drivers/line.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/arch/um/drivers/line.c	2008-12-25 00:26:37.000000000 +0100
@@ -277,0 +278,2 @@
+	/* Note: these are out of date as we now have TCGETS2 etc but this
+	   whole lot should probably go away */
--- ./projects/linux/linux-2.6.18/arch/x86_64/kernel/stacktrace.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/x86_64/kernel/stacktrace.c	2006-11-29 22:57:37.000000000 +0100
@@ -9,0 +10,2 @@
+#include <linux/module.h>
+#include <asm/stacktrace.h>
@@ -11,4 +13 @@
-#include <asm/smp.h>
-
-static inline int
-in_range(unsigned long start, unsigned long addr, unsigned long end)
+static void save_stack_warning(void *data, char *msg)
@@ -16 +14,0 @@
-	return addr >= start && addr <= end;
@@ -19,2 +17,2 @@
-static unsigned long
-get_stack_end(struct task_struct *task, unsigned long stack)
+static void
+save_stack_warning_symbol(void *data, char *msg, unsigned long symbol)
@@ -22,83 +19,0 @@
-	unsigned long stack_start, stack_end, flags;
-	int i, cpu;
-
-	/*
-	 * The most common case is that we are in the task stack:
-	 */
-	stack_start = (unsigned long)task->thread_info;
-	stack_end = stack_start + THREAD_SIZE;
-
-	if (in_range(stack_start, stack, stack_end))
-		return stack_end;
-
-	/*
-	 * We are in an interrupt if irqstackptr is set:
-	 */
-	raw_local_irq_save(flags);
-	cpu = safe_smp_processor_id();
-	stack_end = (unsigned long)cpu_pda(cpu)->irqstackptr;
-
-	if (stack_end) {
-		stack_start = stack_end & ~(IRQSTACKSIZE-1);
-		if (in_range(stack_start, stack, stack_end))
-			goto out_restore;
-		/*
-		 * We get here if we are in an IRQ context but we
-		 * are also in an exception stack.
-		 */
-	}
-
-	/*
-	 * Iterate over all exception stacks, and figure out whether
-	 * 'stack' is in one of them:
-	 */
-	for (i = 0; i < N_EXCEPTION_STACKS; i++) {
-		/*
-		 * set 'end' to the end of the exception stack.
-		 */
-		stack_end = per_cpu(init_tss, cpu).ist[i];
-		stack_start = stack_end - EXCEPTION_STKSZ;
-
-		/*
-		 * Is 'stack' above this exception frame's end?
-		 * If yes then skip to the next frame.
-		 */
-		if (stack >= stack_end)
-			continue;
-		/*
-		 * Is 'stack' above this exception frame's start address?
-		 * If yes then we found the right frame.
-		 */
-		if (stack >= stack_start)
-			goto out_restore;
-
-		/*
-		 * If this is a debug stack, and if it has a larger size than
-		 * the usual exception stacks, then 'stack' might still
-		 * be within the lower portion of the debug stack:
-		 */
-#if DEBUG_STKSZ > EXCEPTION_STKSZ
-		if (i == DEBUG_STACK - 1 && stack >= stack_end - DEBUG_STKSZ) {
-			/*
-			 * Black magic. A large debug stack is composed of
-			 * multiple exception stack entries, which we
-			 * iterate through now. Dont look:
-			 */
-			do {
-				stack_end -= EXCEPTION_STKSZ;
-				stack_start -= EXCEPTION_STKSZ;
-			} while (stack < stack_start);
-
-			goto out_restore;
-		}
-#endif
-	}
-	/*
-	 * Ok, 'stack' is not pointing to any of the system stacks.
-	 */
-	stack_end = 0;
-
-out_restore:
-	raw_local_irq_restore(flags);
-
-	return stack_end;
@@ -107,7 +22 @@
-
-/*
- * Save stack-backtrace addresses into a stack_trace buffer:
- */
-static inline unsigned long
-save_context_stack(struct stack_trace *trace, unsigned int skip,
-		   unsigned long stack, unsigned long stack_end)
+static int save_stack_stack(void *data, char *name)
@@ -115,4 +24,3 @@
-	unsigned long addr;
-
-#ifdef CONFIG_FRAME_POINTER
-	unsigned long prev_stack = 0;
+	struct stack_trace *trace = (struct stack_trace *)data;
+	return trace->all_contexts ? 0 : -1;
+}
@@ -120,33 +28,6 @@
-	while (in_range(prev_stack, stack, stack_end)) {
-		pr_debug("stack:          %p\n", (void *)stack);
-		addr = (unsigned long)(((unsigned long *)stack)[1]);
-		pr_debug("addr:           %p\n", (void *)addr);
-		if (!skip)
-			trace->entries[trace->nr_entries++] = addr-1;
-		else
-			skip--;
-		if (trace->nr_entries >= trace->max_entries)
-			break;
-		if (!addr)
-			return 0;
-		/*
-		 * Stack frames must go forwards (otherwise a loop could
-		 * happen if the stackframe is corrupted), so we move
-		 * prev_stack forwards:
-		 */
-		prev_stack = stack;
-		stack = (unsigned long)(((unsigned long *)stack)[0]);
-	}
-	pr_debug("invalid:        %p\n", (void *)stack);
-#else
-	while (stack < stack_end) {
-		addr = ((unsigned long *)stack)[0];
-		stack += sizeof(long);
-		if (__kernel_text_address(addr)) {
-			if (!skip)
-				trace->entries[trace->nr_entries++] = addr-1;
-			else
-				skip--;
-			if (trace->nr_entries >= trace->max_entries)
-				break;
-		}
+static void save_stack_address(void *data, unsigned long addr)
+{
+	struct stack_trace *trace = (struct stack_trace *)data;
+	if (trace->skip > 0) {
+		trace->skip--;
+		return;
@@ -154,2 +35,2 @@
-#endif
-	return stack;
+	if (trace->nr_entries < trace->max_entries - 1)
+		trace->entries[trace->nr_entries++] = addr;
@@ -158 +39,6 @@
-#define MAX_STACKS 10
+static struct stacktrace_ops save_stack_ops = {
+	.warning = save_stack_warning,
+	.warning_symbol = save_stack_warning_symbol,
+	.stack = save_stack_stack,
+	.address = save_stack_address,
+};
@@ -162,2 +47,0 @@
- * If all_contexts is set, all contexts (hardirq, softirq and process)
- * are saved. If not set then only the current context is saved.
@@ -165,3 +49 @@
-void save_stack_trace(struct stack_trace *trace,
-		      struct task_struct *task, int all_contexts,
-		      unsigned int skip)
+void save_stack_trace(struct stack_trace *trace, struct task_struct *task)
@@ -169,51 +51,2 @@
-	unsigned long stack = (unsigned long)&stack;
-	int i, nr_stacks = 0, stacks_done[MAX_STACKS];
-
-	WARN_ON(trace->nr_entries || !trace->max_entries);
-
-	if (!task)
-		task = current;
-
-	pr_debug("task: %p, ti: %p\n", task, task->thread_info);
-
-	if (!task || task == current) {
-		/* Grab rbp right from our regs: */
-		asm ("mov %%rbp, %0" : "=r" (stack));
-		pr_debug("rbp:            %p\n", (void *)stack);
-	} else {
-		/* rbp is the last reg pushed by switch_to(): */
-		stack = task->thread.rsp;
-		pr_debug("other task rsp: %p\n", (void *)stack);
-		stack = (unsigned long)(((unsigned long *)stack)[0]);
-		pr_debug("other task rbp: %p\n", (void *)stack);
-	}
-
-	while (1) {
-		unsigned long stack_end = get_stack_end(task, stack);
-
-		pr_debug("stack:          %p\n", (void *)stack);
-		pr_debug("stack end:      %p\n", (void *)stack_end);
-
-		/*
-		 * Invalid stack addres?
-		 */
-		if (!stack_end)
-			return;
-		/*
-		 * Were we in this stack already? (recursion)
-		 */
-		for (i = 0; i < nr_stacks; i++)
-			if (stacks_done[i] == stack_end)
-				return;
-		stacks_done[nr_stacks] = stack_end;
-
-		stack = save_context_stack(trace, skip, stack, stack_end);
-		if (!all_contexts || !stack ||
-				trace->nr_entries >= trace->max_entries)
-			return;
-		trace->entries[trace->nr_entries++] = ULONG_MAX;
-		if (trace->nr_entries >= trace->max_entries)
-			return;
-		if (++nr_stacks >= MAX_STACKS)
-			return;
-	}
+	dump_trace(task, NULL, NULL, &save_stack_ops, trace);
+	trace->entries[trace->nr_entries++] = ULONG_MAX;
@@ -220,0 +54 @@
+EXPORT_SYMBOL(save_stack_trace);
--- ./projects/linux/linux-2.6.20/arch/x86_64/kernel/stacktrace.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/arch/x86_64/kernel/stacktrace.c	2007-04-26 05:08:32.000000000 +0200
@@ -35 +35 @@
-	if (trace->nr_entries < trace->max_entries - 1)
+	if (trace->nr_entries < trace->max_entries)
@@ -52 +52,2 @@
-	trace->entries[trace->nr_entries++] = ULONG_MAX;
+	if (trace->nr_entries < trace->max_entries)
+		trace->entries[trace->nr_entries++] = ULONG_MAX;
--- ./projects/linux/linux-2.6.21/arch/x86_64/kernel/stacktrace.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/arch/x86_64/kernel/stacktrace.c	2007-07-09 01:32:17.000000000 +0200
@@ -24,2 +24 @@
-	struct stack_trace *trace = (struct stack_trace *)data;
-	return trace->all_contexts ? 0 : -1;
+	return -1;
@@ -49 +48 @@
-void save_stack_trace(struct stack_trace *trace, struct task_struct *task)
+void save_stack_trace(struct stack_trace *trace)
@@ -51 +50 @@
-	dump_trace(task, NULL, NULL, &save_stack_ops, trace);
+	dump_trace(current, NULL, NULL, &save_stack_ops, trace);
@@ -56 +54,0 @@
-
--- ./projects/linux/linux-2.6.13/arch/xtensa/kernel/process.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/arch/xtensa/kernel/process.c	2005-10-28 02:02:08.000000000 +0200
@@ -46 +46 @@
-#include <asm/offsets.h>
+#include <asm/asm-offsets.h>
@@ -460 +460 @@
-#if TOTAL_CPEXTRA_SIZE > 16
+#if XTENSA_CP_EXTRA_SIZE > 16
--- ./projects/linux/linux-2.6.14/arch/xtensa/kernel/process.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/arch/xtensa/kernel/process.c	2006-01-03 04:21:10.000000000 +0100
@@ -99 +99 @@
-		preempt_enable();
+		preempt_enable_no_resched();
@@ -100,0 +101 @@
+		preempt_disable();
--- ./projects/linux/linux-2.6.15/arch/xtensa/kernel/process.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/arch/xtensa/kernel/process.c	2006-03-20 06:53:29.000000000 +0100
@@ -66,0 +67,3 @@
+void (*pm_power_off)(void) = NULL;
+EXPORT_SYMBOL(pm_power_off);
+
@@ -148 +151 @@
-	tos = (unsigned long)p->thread_info + THREAD_SIZE;
+	tos = (unsigned long)task_stack_page(p) + THREAD_SIZE;
@@ -220 +223 @@
-	unsigned long stack_page = (unsigned long) p->thread_info;
+	unsigned long stack_page = (unsigned long) task_stack_page(p);
--- ./projects/linux/linux-2.6.17/arch/xtensa/kernel/process.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/xtensa/kernel/process.c	2006-09-20 05:42:06.000000000 +0200
@@ -19 +18,0 @@
-#include <linux/config.h>
--- ./projects/linux/linux-2.6.19/arch/xtensa/kernel/process.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/arch/xtensa/kernel/process.c	2007-02-04 19:44:54.000000000 +0100
@@ -1 +0,0 @@
-// TODO	verify coprocessor handling
@@ -46 +45 @@
-#include <asm/coprocessor.h>
+#include <asm/regs.h>
@@ -70,19 +68,0 @@
-#if XCHAL_CP_NUM > 0
-
-/*
- * Coprocessor ownership.
- */
-
-coprocessor_info_t coprocessor_info[] = {
-	{ 0, XTENSA_CPE_CP0_OFFSET },
-	{ 0, XTENSA_CPE_CP1_OFFSET },
-	{ 0, XTENSA_CPE_CP2_OFFSET },
-	{ 0, XTENSA_CPE_CP3_OFFSET },
-	{ 0, XTENSA_CPE_CP4_OFFSET },
-	{ 0, XTENSA_CPE_CP5_OFFSET },
-	{ 0, XTENSA_CPE_CP6_OFFSET },
-	{ 0, XTENSA_CPE_CP7_OFFSET },
-};
-
-#endif
-
@@ -113 +92,0 @@
-	release_coprocessors(current);	/* Empty macro if no CPs are defined */
@@ -118 +96,0 @@
-	release_coprocessors(current);	/* Empty macro if no CPs are defined */
@@ -186,30 +163,0 @@
- * Create a kernel thread
- */
-
-int kernel_thread(int (*fn)(void *), void * arg, unsigned long flags)
-{
-	long retval;
-	__asm__ __volatile__
-		("mov           a5, %4\n\t" /* preserve fn in a5 */
-		 "mov           a6, %3\n\t" /* preserve and setup arg in a6 */
-		 "movi		a2, %1\n\t" /* load __NR_clone for syscall*/
-		 "mov		a3, sp\n\t" /* sp check and sys_clone */
-		 "mov		a4, %5\n\t" /* load flags for syscall */
-		 "syscall\n\t"
-		 "beq		a3, sp, 1f\n\t" /* branch if parent */
-		 "callx4	a5\n\t"     /* call fn */
-		 "movi		a2, %2\n\t" /* load __NR_exit for syscall */
-		 "mov		a3, a6\n\t" /* load fn return value */
-		 "syscall\n"
-		 "1:\n\t"
-		 "mov		%0, a2\n\t" /* parent returns zero */
-		 :"=r" (retval)
-		 :"i" (__NR_clone), "i" (__NR_exit),
-		 "r" (arg), "r" (fn),
-		 "r" (flags | CLONE_VM)
-		 : "a2", "a3", "a4", "a5", "a6" );
-	return retval;
-}
-
-
-/*
@@ -278 +226 @@
-	elfregs->ps		= (regs->ps & ~XCHAL_PS_EXCM_MASK);
+	elfregs->ps		= (regs->ps & ~(1 << PS_EXCM_BIT));
@@ -328 +276 @@
-	regs->ps		= (elfregs->ps | XCHAL_PS_EXCM_MASK);
+	regs->ps		= (elfregs->ps | (1 << PS_EXCM_BIT));
@@ -462,8 +409,0 @@
-/* see asm/coprocessor.h for this magic number 16 */
-#if XTENSA_CP_EXTRA_SIZE > 16
-	do_save_fpregs (r, regs, task);
-
-	/*  For now, bit 16 means some extra state may be present:  */
-// FIXME!! need to track to return more accurate mask
-	return 0x10000 | XCHAL_CP_MASK;
-#else
@@ -471 +410,0 @@
-#endif
@@ -485,0 +425,41 @@
+
+asmlinkage
+long xtensa_clone(unsigned long clone_flags, unsigned long newsp,
+                  void __user *parent_tid, void *child_tls,
+                  void __user *child_tid, long a5,
+                  struct pt_regs *regs)
+{
+        if (!newsp)
+                newsp = regs->areg[1];
+        return do_fork(clone_flags, newsp, regs, 0, parent_tid, child_tid);
+}
+
+/*
+ *  * xtensa_execve() executes a new program.
+ *   */
+
+asmlinkage
+long xtensa_execve(char __user *name, char __user * __user *argv,
+                   char __user * __user *envp,
+                   long a3, long a4, long a5,
+                   struct pt_regs *regs)
+{
+	long error;
+	char * filename;
+
+	filename = getname(name);
+	error = PTR_ERR(filename);
+	if (IS_ERR(filename))
+		goto out;
+	// FIXME: release coprocessor??
+	error = do_execve(filename, argv, envp, regs);
+	if (error == 0) {
+		task_lock(current);
+		current->ptrace &= ~PT_DTRACE;
+		task_unlock(current);
+	}
+	putname(filename);
+out:
+	return error;
+}
+
--- ./projects/linux/linux-2.6.21/arch/xtensa/kernel/process.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/arch/xtensa/kernel/process.c	2007-07-09 01:32:17.000000000 +0200
@@ -23 +22,0 @@
-#include <linux/smp_lock.h>
--- ./projects/linux/linux-2.6.22/arch/xtensa/kernel/process.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/arch/xtensa/kernel/process.c	2007-10-09 22:31:38.000000000 +0200
@@ -32,0 +33 @@
+#include <linux/fs.h>
@@ -48,14 +48,0 @@
-static struct fs_struct init_fs = INIT_FS;
-static struct files_struct init_files = INIT_FILES;
-static struct signal_struct init_signals = INIT_SIGNALS(init_signals);
-static struct sighand_struct init_sighand = INIT_SIGHAND(init_sighand);
-struct mm_struct init_mm = INIT_MM(init_mm);
-EXPORT_SYMBOL(init_mm);
-
-union thread_union init_thread_union
-	__attribute__((__section__(".data.init_task"))) =
-{ INIT_THREAD_INFO(init_task) };
-
-struct task_struct init_task = INIT_TASK(init_task);
-EXPORT_SYMBOL(init_task);
-
--- ./projects/linux/linux-2.6.24/arch/xtensa/kernel/process.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/xtensa/kernel/process.c	2008-04-17 04:49:44.000000000 +0200
@@ -54,0 +55,49 @@
+#if XTENSA_HAVE_COPROCESSORS
+
+void coprocessor_release_all(struct thread_info *ti)
+{
+	unsigned long cpenable;
+	int i;
+
+	/* Make sure we don't switch tasks during this operation. */
+
+	preempt_disable();
+
+	/* Walk through all cp owners and release it for the requested one. */
+
+	cpenable = ti->cpenable;
+
+	for (i = 0; i < XCHAL_CP_MAX; i++) {
+		if (coprocessor_owner[i] == ti) {
+			coprocessor_owner[i] = 0;
+			cpenable &= ~(1 << i);
+		}
+	}
+
+	ti->cpenable = cpenable;
+	coprocessor_clear_cpenable();
+
+	preempt_enable();
+}
+
+void coprocessor_flush_all(struct thread_info *ti)
+{
+	unsigned long cpenable;
+	int i;
+
+	preempt_disable();
+
+	cpenable = ti->cpenable;
+
+	for (i = 0; i < XCHAL_CP_MAX; i++) {
+		if ((cpenable & 1) != 0 && coprocessor_owner[i] == ti)
+			coprocessor_flush(ti, i);
+		cpenable >>= 1;
+	}
+
+	preempt_enable();
+}
+
+#endif
+
+
@@ -74 +123 @@
- * Free current thread data structures etc..
+ * This is called when the thread calls exit().
@@ -76 +124,0 @@
-
@@ -78,0 +127,3 @@
+#if XTENSA_HAVE_COPROCESSORS
+	coprocessor_release_all(current_thread_info());
+#endif
@@ -80,0 +132,4 @@
+/*
+ * Flush thread state. This is called when a thread does an execve()
+ * Note that we flush coprocessor registers for the case execve fails.
+ */
@@ -82,0 +138,15 @@
+#if XTENSA_HAVE_COPROCESSORS
+	struct thread_info *ti = current_thread_info();
+	coprocessor_flush_all(ti);
+	coprocessor_release_all(ti);
+#endif
+}
+
+/*
+ * This is called before the thread is copied. 
+ */
+void prepare_to_copy(struct task_struct *tsk)
+{
+#if XTENSA_HAVE_COPROCESSORS
+	coprocessor_flush_all(task_thread_info(tsk));
+#endif
@@ -109,0 +180 @@
+	struct thread_info *ti;
@@ -130,0 +202 @@
+
@@ -137 +209 @@
-
+// FIXME: we need to set THREADPTR in thread_info...
@@ -144,0 +217,6 @@
+
+#if (XTENSA_HAVE_COPROCESSORS || XTENSA_HAVE_IO_PORTS)
+	ti = task_thread_info(p);
+	ti->cpenable = 0;
+#endif
+
@@ -182,4 +259,0 @@
- * do_copy_regs() gathers information from 'struct pt_regs' and
- * 'current->thread.areg[]' to fill in the xtensa_gregset_t
- * structure.
- *
@@ -194,2 +268 @@
-void do_copy_regs (xtensa_gregset_t *elfregs, struct pt_regs *regs,
-		   struct task_struct *tsk)
+void xtensa_elf_core_copy_regs (xtensa_gregset_t *elfregs, struct pt_regs *regs)
@@ -197 +270,7 @@
-	int i, n, wb_offset;
+	unsigned long wb, ws, wm;
+	int live, last;
+
+	wb = regs->windowbase;
+	ws = regs->windowstart;
+	wm = regs->wmask;
+	ws = ((ws >> wb) | (ws << (WSBITS - wb))) & ((1 << WSBITS) - 1);
@@ -199,2 +278 @@
-	elfregs->xchal_config_id0 = XCHAL_HW_CONFIGID0;
-	elfregs->xchal_config_id1 = XCHAL_HW_CONFIGID1;
+	/* Don't leak any random bits. */
@@ -202,4 +280 @@
-	__asm__ __volatile__ ("rsr  %0, 176\n" : "=a" (i));
- 	elfregs->cpux = i;
-	__asm__ __volatile__ ("rsr  %0, 208\n" : "=a" (i));
- 	elfregs->cpuy = i;
+	memset(elfregs, 0, sizeof (elfregs));
@@ -213,4 +287,0 @@
-	elfregs->exccause	= regs->exccause;
-	elfregs->excvaddr	= regs->excvaddr;
-	elfregs->windowbase	= regs->windowbase;
-	elfregs->windowstart	= regs->windowstart;
@@ -221,27 +292 @@
-	elfregs->syscall	= regs->syscall;
-
-	/* Copy register file.
-	 * The layout looks like this:
-	 *
-	 * |  a0 ... a15  | Z ... Z |  arX ... arY  |
-	 *  current window  unused    saved frames
-	 */
-
-	memset (elfregs->ar, 0, sizeof(elfregs->ar));
-
-	wb_offset = regs->windowbase * 4;
-	n = (regs->wmask&1)? 4 : (regs->wmask&2)? 8 : (regs->wmask&4)? 12 : 16;
-
-	for (i = 0; i < n; i++)
-		elfregs->ar[(wb_offset + i) % XCHAL_NUM_AREGS] = regs->areg[i];
-
-	n = (regs->wmask >> 4) * 4;
-
-	for (i = XCHAL_NUM_AREGS - n; n > 0; i++, n--)
-		elfregs->ar[(wb_offset + i) % XCHAL_NUM_AREGS] = regs->areg[i];
-}
-
-void xtensa_elf_core_copy_regs (xtensa_gregset_t *elfregs, struct pt_regs *regs)
-{
-	do_copy_regs ((xtensa_gregset_t *)elfregs, regs, current);
-}
+	elfregs->windowstart	= ws;
@@ -249,82 +294,4 @@
-
-/* The inverse of do_copy_regs().  No error or sanity checking. */
-
-void do_restore_regs (xtensa_gregset_t *elfregs, struct pt_regs *regs,
-		      struct task_struct *tsk)
-{
-	int i, n, wb_offset;
-
-	/* Note:  PS.EXCM is not set while user task is running; it
-	 * needs to be set in regs->ps is for exception handling convenience.
-	 */
-
-	regs->pc		= elfregs->pc;
-	regs->ps		= (elfregs->ps | (1 << PS_EXCM_BIT));
-	regs->exccause		= elfregs->exccause;
-	regs->excvaddr		= elfregs->excvaddr;
-	regs->windowbase	= elfregs->windowbase;
-	regs->windowstart	= elfregs->windowstart;
-	regs->lbeg		= elfregs->lbeg;
-	regs->lend		= elfregs->lend;
-	regs->lcount		= elfregs->lcount;
-	regs->sar		= elfregs->sar;
-	regs->syscall	= elfregs->syscall;
-
-	/* Clear everything. */
-
-	memset (regs->areg, 0, sizeof(regs->areg));
-
-	/* Copy regs from live window frame. */
-
-	wb_offset = regs->windowbase * 4;
-	n = (regs->wmask&1)? 4 : (regs->wmask&2)? 8 : (regs->wmask&4)? 12 : 16;
-
-	for (i = 0; i < n; i++)
-		regs->areg[(wb_offset+i) % XCHAL_NUM_AREGS] = elfregs->ar[i];
-
-	n = (regs->wmask >> 4) * 4;
-
-	for (i = XCHAL_NUM_AREGS - n; n > 0; i++, n--)
-		regs->areg[(wb_offset+i) % XCHAL_NUM_AREGS] = elfregs->ar[i];
-}
-
-/*
- * do_save_fpregs() gathers information from 'struct pt_regs' and
- * 'current->thread' to fill in the elf_fpregset_t structure.
- *
- * Core files and ptrace use elf_fpregset_t.
- */
-
-void do_save_fpregs (elf_fpregset_t *fpregs, struct pt_regs *regs,
-		     struct task_struct *tsk)
-{
-#if XCHAL_HAVE_CP
-
-	extern unsigned char	_xtensa_reginfo_tables[];
-	extern unsigned		_xtensa_reginfo_table_size;
-	int i;
-	unsigned long flags;
-
-	/* Before dumping coprocessor state from memory,
-	 * ensure any live coprocessor contents for this
-	 * task are first saved to memory:
-	 */
-	local_irq_save(flags);
-
-	for (i = 0; i < XCHAL_CP_MAX; i++) {
-		if (tsk == coprocessor_info[i].owner) {
-			enable_coprocessor(i);
-			save_coprocessor_registers(
-			    tsk->thread.cp_save+coprocessor_info[i].offset,i);
-			disable_coprocessor(i);
-		}
-	}
-
-	local_irq_restore(flags);
-
-	/* Now dump coprocessor & extra state: */
-	memcpy((unsigned char*)fpregs,
-		_xtensa_reginfo_tables, _xtensa_reginfo_table_size);
-	memcpy((unsigned char*)fpregs + _xtensa_reginfo_table_size,
-		tsk->thread.cp_save, XTENSA_CP_EXTRA_SIZE);
-#endif
+	live = (wm & 2) ? 4 : (wm & 4) ? 8 : (wm & 8) ? 12 : 16;
+	last = XCHAL_NUM_AREGS - (wm >> 4) * 4;
+	memcpy(elfregs->a, regs->areg, live * 4);
+	memcpy(elfregs->a + last, regs->areg + last, (wm >> 4) * 16);
@@ -333,8 +300 @@
-/*
- * The inverse of do_save_fpregs().
- * Copies coprocessor and extra state from fpregs into regs and tsk->thread.
- * Returns 0 on success, non-zero if layout doesn't match.
- */
-
-int  do_restore_fpregs (elf_fpregset_t *fpregs, struct pt_regs *regs,
-		        struct task_struct *tsk)
+int dump_fpu(void)
@@ -342,45 +301,0 @@
-#if XCHAL_HAVE_CP
-
-	extern unsigned char	_xtensa_reginfo_tables[];
-	extern unsigned		_xtensa_reginfo_table_size;
-	int i;
-	unsigned long flags;
-
-	/* Make sure save area layouts match.
-	 * FIXME:  in the future we could allow restoring from
-	 * a different layout of the same registers, by comparing
-	 * fpregs' table with _xtensa_reginfo_tables and matching
-	 * entries and copying registers one at a time.
-	 * Not too sure yet whether that's very useful.
-	 */
-
-	if( memcmp((unsigned char*)fpregs,
-		_xtensa_reginfo_tables, _xtensa_reginfo_table_size) ) {
-	    return -1;
-	}
-
-	/* Before restoring coprocessor state from memory,
-	 * ensure any live coprocessor contents for this
-	 * task are first invalidated.
-	 */
-
-	local_irq_save(flags);
-
-	for (i = 0; i < XCHAL_CP_MAX; i++) {
-		if (tsk == coprocessor_info[i].owner) {
-			enable_coprocessor(i);
-			save_coprocessor_registers(
-			    tsk->thread.cp_save+coprocessor_info[i].offset,i);
-			coprocessor_info[i].owner = 0;
-			disable_coprocessor(i);
-		}
-	}
-
-	local_irq_restore(flags);
-
-	/*  Now restore coprocessor & extra state:  */
-
-	memcpy(tsk->thread.cp_save,
-		(unsigned char*)fpregs + _xtensa_reginfo_table_size,
-		XTENSA_CP_EXTRA_SIZE);
-#endif
@@ -389,22 +303,0 @@
-/*
- * Fill in the CP structure for a core dump for a particular task.
- */
-
-int
-dump_task_fpu(struct pt_regs *regs, struct task_struct *task, elf_fpregset_t *r)
-{
-	return 0;	/* no coprocessors active on this processor */
-}
-
-/*
- * Fill in the CP structure for a core dump.
- * This includes any FPU coprocessor.
- * Here, we dump all coprocessors, and other ("extra") custom state.
- *
- * This function is called by elf_core_dump() in fs/binfmt_elf.c
- * (in which case 'regs' comes from calls to do_coredump, see signals.c).
- */
-int  dump_fpu(struct pt_regs *regs, elf_fpregset_t *r)
-{
-	return dump_task_fpu(regs, current, r);
-}
@@ -424,2 +317,2 @@
- *  * xtensa_execve() executes a new program.
- *   */
+ * xtensa_execve() executes a new program.
+ */
@@ -440 +332,0 @@
-	// FIXME: release coprocessor??
--- ./projects/linux/linux-2.6.29/arch/xtensa/kernel/process.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/arch/xtensa/kernel/process.c	2009-06-27 11:32:31.000000000 +0200
@@ -175 +175 @@
-int copy_thread(int nr, unsigned long clone_flags, unsigned long usp,
+int copy_thread(unsigned long clone_flags, unsigned long usp,
--- ./projects/linux/linux-2.6.27/block/blk-integrity.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/block/blk-integrity.c	2008-12-25 00:26:37.000000000 +0100
@@ -111,3 +111,3 @@
- * blk_integrity_compare - Compare integrity profile of two block devices
- * @b1:		Device to compare
- * @b2:		Device to compare
+ * blk_integrity_compare - Compare integrity profile of two disks
+ * @gd1:	Disk to compare
+ * @gd2:	Disk to compare
@@ -118 +118 @@
- * function can be used to check whether two block devices have
+ * function can be used to check whether two gendisk devices have
@@ -121 +121 @@
-int blk_integrity_compare(struct block_device *bd1, struct block_device *bd2)
+int blk_integrity_compare(struct gendisk *gd1, struct gendisk *gd2)
@@ -123,2 +123,2 @@
-	struct blk_integrity *b1 = bd1->bd_disk->integrity;
-	struct blk_integrity *b2 = bd2->bd_disk->integrity;
+	struct blk_integrity *b1 = gd1->integrity;
+	struct blk_integrity *b2 = gd2->integrity;
@@ -126,2 +126,2 @@
-	BUG_ON(bd1->bd_disk == NULL);
-	BUG_ON(bd2->bd_disk == NULL);
+	if (!b1 && !b2)
+		return 0;
@@ -130 +130 @@
-		return 0;
+		return -1;
@@ -134 +134 @@
-		       bd1->bd_disk->disk_name, bd2->bd_disk->disk_name,
+		       gd1->disk_name, gd2->disk_name,
@@ -141 +141 @@
-		       bd1->bd_disk->disk_name, bd2->bd_disk->disk_name,
+		       gd1->disk_name, gd2->disk_name,
@@ -148 +148 @@
-		       bd1->bd_disk->disk_name, bd2->bd_disk->disk_name,
+		       gd1->disk_name, gd2->disk_name,
@@ -155 +155 @@
-		       bd1->bd_disk->disk_name, bd2->bd_disk->disk_name,
+		       gd1->disk_name, gd2->disk_name,
@@ -334 +334,2 @@
-					 &disk->dev.kobj, "%s", "integrity")) {
+					 &disk_to_dev(disk)->kobj,
+					 "%s", "integrity")) {
@@ -378 +378,0 @@
-	kobject_put(&disk->dev.kobj);
@@ -379,0 +380 @@
+	disk->integrity = NULL;
--- ./projects/linux/linux-2.6.28/block/blk-integrity.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/block/blk-integrity.c	2009-03-24 00:12:14.000000000 +0100
@@ -312 +312 @@
- * @template:	integrity profile
+ * @template:	optional integrity profile to register
@@ -318 +318,2 @@
- * hardware.  See Documentation/block/data-integrity.txt.
+ * hardware.  If template is NULL the new profile is allocated but
+ * not filled out. See Documentation/block/data-integrity.txt.
@@ -325 +325,0 @@
-	BUG_ON(template == NULL);
@@ -329 +329 @@
-						GFP_KERNEL | __GFP_ZERO);
+				      GFP_KERNEL | __GFP_ZERO);
@@ -349,7 +349,10 @@
-	bi->name = template->name;
-	bi->generate_fn = template->generate_fn;
-	bi->verify_fn = template->verify_fn;
-	bi->tuple_size = template->tuple_size;
-	bi->set_tag_fn = template->set_tag_fn;
-	bi->get_tag_fn = template->get_tag_fn;
-	bi->tag_size = template->tag_size;
+	if (template != NULL) {
+		bi->name = template->name;
+		bi->generate_fn = template->generate_fn;
+		bi->verify_fn = template->verify_fn;
+		bi->tuple_size = template->tuple_size;
+		bi->set_tag_fn = template->set_tag_fn;
+		bi->get_tag_fn = template->get_tag_fn;
+		bi->tag_size = template->tag_size;
+	} else
+		bi->name = "unsupported";
--- ./projects/linux/linux-2.6.13/drivers/acpi/executer/exmutex.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/acpi/executer/exmutex.c	2005-10-28 02:02:08.000000000 +0200
@@ -45 +44,0 @@
-
@@ -50 +49 @@
-	 ACPI_MODULE_NAME    ("exmutex")
+ACPI_MODULE_NAME("exmutex")
@@ -53 +51,0 @@
-
@@ -55,4 +53,2 @@
-acpi_ex_link_mutex (
-	union acpi_operand_object       *obj_desc,
-	struct acpi_thread_state        *thread);
-
+acpi_ex_link_mutex(union acpi_operand_object *obj_desc,
+		   struct acpi_thread_state *thread);
@@ -72,3 +68 @@
-void
-acpi_ex_unlink_mutex (
-	union acpi_operand_object       *obj_desc)
+void acpi_ex_unlink_mutex(union acpi_operand_object *obj_desc)
@@ -76,2 +70 @@
-	struct acpi_thread_state        *thread = obj_desc->mutex.owner_thread;
-
+	struct acpi_thread_state *thread = obj_desc->mutex.owner_thread;
@@ -91,2 +84 @@
-	}
-	else {
+	} else {
@@ -97 +88,0 @@
-
@@ -112,3 +103,2 @@
-acpi_ex_link_mutex (
-	union acpi_operand_object       *obj_desc,
-	struct acpi_thread_state        *thread)
+acpi_ex_link_mutex(union acpi_operand_object *obj_desc,
+		   struct acpi_thread_state *thread)
@@ -116,2 +106 @@
-	union acpi_operand_object       *list_head;
-
+	union acpi_operand_object *list_head;
@@ -137 +125,0 @@
-
@@ -153,4 +141,3 @@
-acpi_ex_acquire_mutex (
-	union acpi_operand_object       *time_desc,
-	union acpi_operand_object       *obj_desc,
-	struct acpi_walk_state          *walk_state)
+acpi_ex_acquire_mutex(union acpi_operand_object *time_desc,
+		      union acpi_operand_object *obj_desc,
+		      struct acpi_walk_state *walk_state)
@@ -158,4 +145 @@
-	acpi_status                     status;
-
-
-	ACPI_FUNCTION_TRACE_PTR ("ex_acquire_mutex", obj_desc);
+	acpi_status status;
@@ -162,0 +147 @@
+	ACPI_FUNCTION_TRACE_PTR("ex_acquire_mutex", obj_desc);
@@ -165 +150 @@
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
@@ -171,3 +156,2 @@
-		ACPI_REPORT_ERROR (("Cannot acquire Mutex [%4.4s], null thread info\n",
-			acpi_ut_get_node_name (obj_desc->mutex.node)));
-		return_ACPI_STATUS (AE_AML_INTERNAL);
+		ACPI_REPORT_ERROR(("Cannot acquire Mutex [%4.4s], null thread info\n", acpi_ut_get_node_name(obj_desc->mutex.node)));
+		return_ACPI_STATUS(AE_AML_INTERNAL);
@@ -181,4 +165,2 @@
-		ACPI_REPORT_ERROR ((
-			"Cannot acquire Mutex [%4.4s], incorrect sync_level\n",
-			acpi_ut_get_node_name (obj_desc->mutex.node)));
-		return_ACPI_STATUS (AE_AML_MUTEX_ORDER);
+		ACPI_REPORT_ERROR(("Cannot acquire Mutex [%4.4s], incorrect sync_level\n", acpi_ut_get_node_name(obj_desc->mutex.node)));
+		return_ACPI_STATUS(AE_AML_MUTEX_ORDER);
@@ -193,3 +175,3 @@
-				walk_state->thread->thread_id)      ||
-			(obj_desc->mutex.semaphore ==
-				acpi_gbl_global_lock_semaphore)) {
+		     walk_state->thread->thread_id) ||
+		    (obj_desc->mutex.semaphore ==
+		     acpi_gbl_global_lock_semaphore)) {
@@ -201 +183 @@
-			return_ACPI_STATUS (AE_OK);
+			return_ACPI_STATUS(AE_OK);
@@ -207,2 +189,2 @@
-	status = acpi_ex_system_acquire_mutex (time_desc, obj_desc);
-	if (ACPI_FAILURE (status)) {
+	status = acpi_ex_system_acquire_mutex(time_desc, obj_desc);
+	if (ACPI_FAILURE(status)) {
@@ -211 +193 @@
-		return_ACPI_STATUS (status);
+		return_ACPI_STATUS(status);
@@ -216 +198 @@
-	obj_desc->mutex.owner_thread     = walk_state->thread;
+	obj_desc->mutex.owner_thread = walk_state->thread;
@@ -218 +200,2 @@
-	obj_desc->mutex.original_sync_level = walk_state->thread->current_sync_level;
+	obj_desc->mutex.original_sync_level =
+	    walk_state->thread->current_sync_level;
@@ -224 +207 @@
-	acpi_ex_link_mutex (obj_desc, walk_state->thread);
+	acpi_ex_link_mutex(obj_desc, walk_state->thread);
@@ -226 +209 @@
-	return_ACPI_STATUS (AE_OK);
+	return_ACPI_STATUS(AE_OK);
@@ -229 +211,0 @@
-
@@ -244,3 +226,2 @@
-acpi_ex_release_mutex (
-	union acpi_operand_object       *obj_desc,
-	struct acpi_walk_state          *walk_state)
+acpi_ex_release_mutex(union acpi_operand_object *obj_desc,
+		      struct acpi_walk_state *walk_state)
@@ -248,4 +229 @@
-	acpi_status                     status;
-
-
-	ACPI_FUNCTION_TRACE ("ex_release_mutex");
+	acpi_status status;
@@ -252,0 +231 @@
+	ACPI_FUNCTION_TRACE("ex_release_mutex");
@@ -255 +234 @@
-		return_ACPI_STATUS (AE_BAD_PARAMETER);
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
@@ -261,3 +240,2 @@
-		ACPI_REPORT_ERROR (("Cannot release Mutex [%4.4s], not acquired\n",
-				acpi_ut_get_node_name (obj_desc->mutex.node)));
-		return_ACPI_STATUS (AE_AML_MUTEX_NOT_ACQUIRED);
+		ACPI_REPORT_ERROR(("Cannot release Mutex [%4.4s], not acquired\n", acpi_ut_get_node_name(obj_desc->mutex.node)));
+		return_ACPI_STATUS(AE_AML_MUTEX_NOT_ACQUIRED);
@@ -269,3 +247,2 @@
-		ACPI_REPORT_ERROR (("Cannot release Mutex [%4.4s], null thread info\n",
-				acpi_ut_get_node_name (obj_desc->mutex.node)));
-		return_ACPI_STATUS (AE_AML_INTERNAL);
+		ACPI_REPORT_ERROR(("Cannot release Mutex [%4.4s], null thread info\n", acpi_ut_get_node_name(obj_desc->mutex.node)));
+		return_ACPI_STATUS(AE_AML_INTERNAL);
@@ -278,8 +255,5 @@
-	if ((obj_desc->mutex.owner_thread->thread_id != walk_state->thread->thread_id) &&
-		(obj_desc->mutex.semaphore != acpi_gbl_global_lock_semaphore)) {
-		ACPI_REPORT_ERROR ((
-			"Thread %X cannot release Mutex [%4.4s] acquired by thread %X\n",
-			walk_state->thread->thread_id,
-			acpi_ut_get_node_name (obj_desc->mutex.node),
-			obj_desc->mutex.owner_thread->thread_id));
-		return_ACPI_STATUS (AE_AML_NOT_OWNER);
+	if ((obj_desc->mutex.owner_thread->thread_id !=
+	     walk_state->thread->thread_id)
+	    && (obj_desc->mutex.semaphore != acpi_gbl_global_lock_semaphore)) {
+		ACPI_REPORT_ERROR(("Thread %X cannot release Mutex [%4.4s] acquired by thread %X\n", walk_state->thread->thread_id, acpi_ut_get_node_name(obj_desc->mutex.node), obj_desc->mutex.owner_thread->thread_id));
+		return_ACPI_STATUS(AE_AML_NOT_OWNER);
@@ -293,4 +267,2 @@
-		ACPI_REPORT_ERROR ((
-			"Cannot release Mutex [%4.4s], incorrect sync_level\n",
-			acpi_ut_get_node_name (obj_desc->mutex.node)));
-		return_ACPI_STATUS (AE_AML_MUTEX_ORDER);
+		ACPI_REPORT_ERROR(("Cannot release Mutex [%4.4s], incorrect sync_level\n", acpi_ut_get_node_name(obj_desc->mutex.node)));
+		return_ACPI_STATUS(AE_AML_MUTEX_ORDER);
@@ -305 +277 @@
-		return_ACPI_STATUS (AE_OK);
+		return_ACPI_STATUS(AE_OK);
@@ -310 +282 @@
-	acpi_ex_unlink_mutex (obj_desc);
+	acpi_ex_unlink_mutex(obj_desc);
@@ -314 +286 @@
-	status = acpi_ex_system_release_mutex (obj_desc);
+	status = acpi_ex_system_release_mutex(obj_desc);
@@ -319 +291,2 @@
-	walk_state->thread->current_sync_level = obj_desc->mutex.original_sync_level;
+	walk_state->thread->current_sync_level =
+	    obj_desc->mutex.original_sync_level;
@@ -321 +294 @@
-	return_ACPI_STATUS (status);
+	return_ACPI_STATUS(status);
@@ -324 +296,0 @@
-
@@ -337,3 +309 @@
-void
-acpi_ex_release_all_mutexes (
-	struct acpi_thread_state        *thread)
+void acpi_ex_release_all_mutexes(struct acpi_thread_state *thread)
@@ -341,6 +311,3 @@
-	union acpi_operand_object       *next = thread->acquired_mutex_list;
-	union acpi_operand_object       *this;
-	acpi_status                     status;
-
-
-	ACPI_FUNCTION_ENTRY ();
+	union acpi_operand_object *next = thread->acquired_mutex_list;
+	union acpi_operand_object *this;
+	acpi_status status;
@@ -347,0 +315 @@
+	ACPI_FUNCTION_ENTRY();
@@ -356,2 +324,2 @@
-		this->mutex.prev             = NULL;
-		this->mutex.next             = NULL;
+		this->mutex.prev = NULL;
+		this->mutex.next = NULL;
@@ -359 +327 @@
-		 /* Release the mutex */
+		/* Release the mutex */
@@ -361,2 +329,2 @@
-		status = acpi_ex_system_release_mutex (this);
-		if (ACPI_FAILURE (status)) {
+		status = acpi_ex_system_release_mutex(this);
+		if (ACPI_FAILURE(status)) {
@@ -375,2 +342,0 @@
-
-
--- ./projects/linux/linux-2.6.15/drivers/acpi/executer/exmutex.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/acpi/executer/exmutex.c	2006-03-20 06:53:29.000000000 +0100
@@ -9 +9 @@
- * Copyright (C) 2000 - 2005, R. Byron Moore
+ * Copyright (C) 2000 - 2006, R. Byron Moore
@@ -156 +156,3 @@
-		ACPI_REPORT_ERROR(("Cannot acquire Mutex [%4.4s], null thread info\n", acpi_ut_get_node_name(obj_desc->mutex.node)));
+		ACPI_ERROR((AE_INFO,
+			    "Cannot acquire Mutex [%4.4s], null thread info",
+			    acpi_ut_get_node_name(obj_desc->mutex.node)));
@@ -165 +167,3 @@
-		ACPI_REPORT_ERROR(("Cannot acquire Mutex [%4.4s], incorrect sync_level\n", acpi_ut_get_node_name(obj_desc->mutex.node)));
+		ACPI_ERROR((AE_INFO,
+			    "Cannot acquire Mutex [%4.4s], incorrect sync_level",
+			    acpi_ut_get_node_name(obj_desc->mutex.node)));
@@ -240 +244,3 @@
-		ACPI_REPORT_ERROR(("Cannot release Mutex [%4.4s], not acquired\n", acpi_ut_get_node_name(obj_desc->mutex.node)));
+		ACPI_ERROR((AE_INFO,
+			    "Cannot release Mutex [%4.4s], not acquired",
+			    acpi_ut_get_node_name(obj_desc->mutex.node)));
@@ -247 +253,3 @@
-		ACPI_REPORT_ERROR(("Cannot release Mutex [%4.4s], null thread info\n", acpi_ut_get_node_name(obj_desc->mutex.node)));
+		ACPI_ERROR((AE_INFO,
+			    "Cannot release Mutex [%4.4s], null thread info",
+			    acpi_ut_get_node_name(obj_desc->mutex.node)));
@@ -258 +266,5 @@
-		ACPI_REPORT_ERROR(("Thread %X cannot release Mutex [%4.4s] acquired by thread %X\n", walk_state->thread->thread_id, acpi_ut_get_node_name(obj_desc->mutex.node), obj_desc->mutex.owner_thread->thread_id));
+		ACPI_ERROR((AE_INFO,
+			    "Thread %X cannot release Mutex [%4.4s] acquired by thread %X",
+			    walk_state->thread->thread_id,
+			    acpi_ut_get_node_name(obj_desc->mutex.node),
+			    obj_desc->mutex.owner_thread->thread_id));
@@ -267 +279,3 @@
-		ACPI_REPORT_ERROR(("Cannot release Mutex [%4.4s], incorrect sync_level\n", acpi_ut_get_node_name(obj_desc->mutex.node)));
+		ACPI_ERROR((AE_INFO,
+			    "Cannot release Mutex [%4.4s], incorrect sync_level",
+			    acpi_ut_get_node_name(obj_desc->mutex.node)));
--- ./projects/linux/linux-2.6.17/drivers/acpi/executer/exmutex.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/acpi/executer/exmutex.c	2006-09-20 05:42:06.000000000 +0200
@@ -64 +64 @@
- * DESCRIPTION: Remove a mutex from the "acquired_mutex" list
+ * DESCRIPTION: Remove a mutex from the "AcquiredMutex" list
@@ -98 +98 @@
- * DESCRIPTION: Add a mutex to the "acquired_mutex" list for this walk
+ * DESCRIPTION: Add a mutex to the "AcquiredMutex" list for this walk
@@ -147 +147 @@
-	ACPI_FUNCTION_TRACE_PTR("ex_acquire_mutex", obj_desc);
+	ACPI_FUNCTION_TRACE_PTR(ex_acquire_mutex, obj_desc);
@@ -164 +164 @@
-	 * mutex.  This mechanism provides some deadlock prevention
+	 * mutex. This mechanism provides some deadlock prevention
@@ -168,2 +168,3 @@
-			    "Cannot acquire Mutex [%4.4s], incorrect sync_level",
-			    acpi_ut_get_node_name(obj_desc->mutex.node)));
+			    "Cannot acquire Mutex [%4.4s], current SyncLevel is too large (%d)",
+			    acpi_ut_get_node_name(obj_desc->mutex.node),
+			    walk_state->thread->current_sync_level));
@@ -175,0 +177 @@
+
@@ -180,2 +182 @@
-		    (obj_desc->mutex.semaphore ==
-		     acpi_gbl_global_lock_semaphore)) {
+		    (obj_desc->mutex.os_mutex == ACPI_GLOBAL_LOCK)) {
@@ -194,0 +196 @@
+
@@ -235 +237 @@
-	ACPI_FUNCTION_TRACE("ex_release_mutex");
+	ACPI_FUNCTION_TRACE(ex_release_mutex);
@@ -265 +267 @@
-	    && (obj_desc->mutex.semaphore != acpi_gbl_global_lock_semaphore)) {
+	    && (obj_desc->mutex.os_mutex != ACPI_GLOBAL_LOCK)) {
@@ -268 +270 @@
-			    walk_state->thread->thread_id,
+			    (u32) walk_state->thread->thread_id,
@@ -270 +272 @@
-			    obj_desc->mutex.owner_thread->thread_id));
+			    (u32) obj_desc->mutex.owner_thread->thread_id));
@@ -280 +282 @@
-			    "Cannot release Mutex [%4.4s], incorrect sync_level",
+			    "Cannot release Mutex [%4.4s], incorrect SyncLevel",
@@ -288,0 +291 @@
+
--- ./projects/linux/linux-2.6.19/drivers/acpi/executer/exmutex.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/acpi/executer/exmutex.c	2007-02-04 19:44:54.000000000 +0100
@@ -269,2 +269,2 @@
-			    "Thread %X cannot release Mutex [%4.4s] acquired by thread %X",
-			    (u32) walk_state->thread->thread_id,
+			    "Thread %lX cannot release Mutex [%4.4s] acquired by thread %lX",
+			    (unsigned long)walk_state->thread->thread_id,
@@ -272 +272 @@
-			    (u32) obj_desc->mutex.owner_thread->thread_id));
+			    (unsigned long)obj_desc->mutex.owner_thread->thread_id));
--- ./projects/linux/linux-2.6.20/drivers/acpi/executer/exmutex.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/acpi/executer/exmutex.c	2007-04-26 05:08:32.000000000 +0200
@@ -9 +9 @@
- * Copyright (C) 2000 - 2006, R. Byron Moore
+ * Copyright (C) 2000 - 2007, R. Byron Moore
@@ -46,0 +47 @@
+#include <acpi/acevents.h>
@@ -68 +69,2 @@
-void acpi_ex_unlink_mutex(union acpi_operand_object *obj_desc)
+void acpi_ex_unlink_mutex(union acpi_operand_object *obj_desc,
+			  struct acpi_thread_state *thread)
@@ -70,2 +71,0 @@
-	struct acpi_thread_state *thread = obj_desc->mutex.owner_thread;
-
@@ -153 +153 @@
-	/* Sanity check -- we must have a valid thread ID */
+	/* Sanity check: we must have a valid thread ID */
@@ -176 +176,8 @@
-	if (obj_desc->mutex.owner_thread) {
+	if (obj_desc->mutex.owner_thread_id == acpi_os_get_thread_id()) {
+		/*
+		 * The mutex is already owned by this thread, just increment the
+		 * acquisition depth
+		 */
+		obj_desc->mutex.acquisition_depth++;
+		return_ACPI_STATUS(AE_OK);
+	}
@@ -178 +185 @@
-		/* Special case for Global Lock, allow all threads */
+	/* Acquire the mutex, wait if necessary. Special case for Global Lock */
@@ -180,10 +187,7 @@
-		if ((obj_desc->mutex.owner_thread->thread_id ==
-		     walk_state->thread->thread_id) ||
-		    (obj_desc->mutex.os_mutex == ACPI_GLOBAL_LOCK)) {
-			/*
-			 * The mutex is already owned by this thread,
-			 * just increment the acquisition depth
-			 */
-			obj_desc->mutex.acquisition_depth++;
-			return_ACPI_STATUS(AE_OK);
-		}
+	if (obj_desc->mutex.os_mutex == acpi_gbl_global_lock_mutex) {
+		status =
+		    acpi_ev_acquire_global_lock((u16) time_desc->integer.value);
+	} else {
+		status = acpi_ex_system_wait_mutex(obj_desc->mutex.os_mutex,
+						   (u16) time_desc->integer.
+						   value);
@@ -192,3 +195,0 @@
-	/* Acquire the mutex, wait if necessary */
-
-	status = acpi_ex_system_acquire_mutex(time_desc, obj_desc);
@@ -204 +205 @@
-	obj_desc->mutex.owner_thread = walk_state->thread;
+	obj_desc->mutex.owner_thread_id = acpi_os_get_thread_id();
@@ -214 +214,0 @@
-
@@ -235 +235 @@
-	acpi_status status;
+	acpi_status status = AE_OK;
@@ -245 +245 @@
-	if (!obj_desc->mutex.owner_thread) {
+	if (!obj_desc->mutex.owner_thread_id) {
@@ -252 +252 @@
-	/* Sanity check -- we must have a valid thread ID */
+	/* Sanity check: we must have a valid thread ID */
@@ -265 +265 @@
-	if ((obj_desc->mutex.owner_thread->thread_id !=
+	if ((obj_desc->mutex.owner_thread_id !=
@@ -267 +267 @@
-	    && (obj_desc->mutex.os_mutex != ACPI_GLOBAL_LOCK)) {
+	    && (obj_desc->mutex.os_mutex != acpi_gbl_global_lock_mutex)) {
@@ -272 +272 @@
-			    (unsigned long)obj_desc->mutex.owner_thread->thread_id));
+			    (unsigned long)obj_desc->mutex.owner_thread_id));
@@ -277,2 +277,2 @@
-	 * The sync level of the mutex must be less than or
-	 * equal to the current sync level
+	 * The sync level of the mutex must be less than or equal to the current
+	 * sync level
@@ -299 +299 @@
-	acpi_ex_unlink_mutex(obj_desc);
+	acpi_ex_unlink_mutex(obj_desc, walk_state->thread);
@@ -301 +301 @@
-	/* Release the mutex */
+	/* Release the mutex, special case for Global Lock */
@@ -303 +303,5 @@
-	status = acpi_ex_system_release_mutex(obj_desc);
+	if (obj_desc->mutex.os_mutex == acpi_gbl_global_lock_mutex) {
+		status = acpi_ev_release_global_lock();
+	} else {
+		acpi_os_release_mutex(obj_desc->mutex.os_mutex);
+	}
@@ -305 +309 @@
-	/* Update the mutex and walk state, restore sync_level before acquire */
+	/* Update the mutex and restore sync_level */
@@ -307 +311 @@
-	obj_desc->mutex.owner_thread = NULL;
+	obj_desc->mutex.owner_thread_id = ACPI_MUTEX_NOT_ACQUIRED;
@@ -323,0 +328,6 @@
+ * NOTE: This function is called as the thread is exiting the interpreter.
+ * Mutexes are not released when an individual control method is exited, but
+ * only when the parent thread actually exits the interpreter. This allows one
+ * method to acquire a mutex, and a different method to release it, as long as
+ * this is performed underneath a single parent control method.
+ *
@@ -329,2 +339 @@
-	union acpi_operand_object *this;
-	acpi_status status;
+	union acpi_operand_object *obj_desc;
@@ -337,2 +346,12 @@
-		this = next;
-		next = this->mutex.next;
+		obj_desc = next;
+		next = obj_desc->mutex.next;
+
+		obj_desc->mutex.prev = NULL;
+		obj_desc->mutex.next = NULL;
+		obj_desc->mutex.acquisition_depth = 0;
+
+		/* Release the mutex, special case for Global Lock */
+
+		if (obj_desc->mutex.os_mutex == acpi_gbl_global_lock_mutex) {
+
+			/* Ignore errors */
@@ -340,9 +359,3 @@
-		this->mutex.acquisition_depth = 1;
-		this->mutex.prev = NULL;
-		this->mutex.next = NULL;
-
-		/* Release the mutex */
-
-		status = acpi_ex_system_release_mutex(this);
-		if (ACPI_FAILURE(status)) {
-			continue;
+			(void)acpi_ev_release_global_lock();
+		} else {
+			acpi_os_release_mutex(obj_desc->mutex.os_mutex);
@@ -353 +366 @@
-		this->mutex.owner_thread = NULL;
+		obj_desc->mutex.owner_thread_id = ACPI_MUTEX_NOT_ACQUIRED;
@@ -357 +370,2 @@
-		thread->current_sync_level = this->mutex.original_sync_level;
+		thread->current_sync_level =
+		    obj_desc->mutex.original_sync_level;
--- ./projects/linux/linux-2.6.21/drivers/acpi/executer/exmutex.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/acpi/executer/exmutex.c	2007-07-09 01:32:17.000000000 +0200
@@ -69,2 +69 @@
-void acpi_ex_unlink_mutex(union acpi_operand_object *obj_desc,
-			  struct acpi_thread_state *thread)
+void acpi_ex_unlink_mutex(union acpi_operand_object *obj_desc)
@@ -71,0 +71,2 @@
+	struct acpi_thread_state *thread = obj_desc->mutex.owner_thread;
+
@@ -176,7 +177,10 @@
-	if (obj_desc->mutex.owner_thread_id == acpi_os_get_thread_id()) {
-		/*
-		 * The mutex is already owned by this thread, just increment the
-		 * acquisition depth
-		 */
-		obj_desc->mutex.acquisition_depth++;
-		return_ACPI_STATUS(AE_OK);
+	if (obj_desc->mutex.owner_thread) {
+		if (obj_desc->mutex.owner_thread->thread_id ==
+		    walk_state->thread->thread_id) {
+			/*
+			 * The mutex is already owned by this thread, just increment the
+			 * acquisition depth
+			 */
+			obj_desc->mutex.acquisition_depth++;
+			return_ACPI_STATUS(AE_OK);
+		}
@@ -205 +209 @@
-	obj_desc->mutex.owner_thread_id = acpi_os_get_thread_id();
+	obj_desc->mutex.owner_thread = walk_state->thread;
@@ -245 +249 @@
-	if (!obj_desc->mutex.owner_thread_id) {
+	if (!obj_desc->mutex.owner_thread) {
@@ -265 +269 @@
-	if ((obj_desc->mutex.owner_thread_id !=
+	if ((obj_desc->mutex.owner_thread->thread_id !=
@@ -272 +276,2 @@
-			    (unsigned long)obj_desc->mutex.owner_thread_id));
+			    (unsigned long)obj_desc->mutex.owner_thread->
+			    thread_id));
@@ -299 +304 @@
-	acpi_ex_unlink_mutex(obj_desc, walk_state->thread);
+	acpi_ex_unlink_mutex(obj_desc);
@@ -311 +316 @@
-	obj_desc->mutex.owner_thread_id = ACPI_MUTEX_NOT_ACQUIRED;
+	obj_desc->mutex.owner_thread = NULL;
@@ -366 +371 @@
-		obj_desc->mutex.owner_thread_id = ACPI_MUTEX_NOT_ACQUIRED;
+		obj_desc->mutex.owner_thread = NULL;
--- ./projects/linux/linux-2.6.25/drivers/acpi/executer/exmutex.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/acpi/executer/exmutex.c	2008-07-13 23:51:29.000000000 +0200
@@ -9 +9 @@
- * Copyright (C) 2000 - 2007, R. Byron Moore
+ * Copyright (C) 2000 - 2008, Intel Corp.
@@ -128,0 +129,73 @@
+ * FUNCTION:    acpi_ex_acquire_mutex_object
+ *
+ * PARAMETERS:  time_desc           - Timeout in milliseconds
+ *              obj_desc            - Mutex object
+ *              Thread              - Current thread state
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Acquire an AML mutex, low-level interface. Provides a common
+ *              path that supports multiple acquires by the same thread.
+ *
+ * MUTEX:       Interpreter must be locked
+ *
+ * NOTE: This interface is called from three places:
+ * 1) From acpi_ex_acquire_mutex, via an AML Acquire() operator
+ * 2) From acpi_ex_acquire_global_lock when an AML Field access requires the
+ *    global lock
+ * 3) From the external interface, acpi_acquire_global_lock
+ *
+ ******************************************************************************/
+
+acpi_status
+acpi_ex_acquire_mutex_object(u16 timeout,
+			     union acpi_operand_object *obj_desc,
+			     acpi_thread_id thread_id)
+{
+	acpi_status status;
+
+	ACPI_FUNCTION_TRACE_PTR(ex_acquire_mutex_object, obj_desc);
+
+	if (!obj_desc) {
+		return_ACPI_STATUS(AE_BAD_PARAMETER);
+	}
+
+	/* Support for multiple acquires by the owning thread */
+
+	if (obj_desc->mutex.thread_id == thread_id) {
+		/*
+		 * The mutex is already owned by this thread, just increment the
+		 * acquisition depth
+		 */
+		obj_desc->mutex.acquisition_depth++;
+		return_ACPI_STATUS(AE_OK);
+	}
+
+	/* Acquire the mutex, wait if necessary. Special case for Global Lock */
+
+	if (obj_desc == acpi_gbl_global_lock_mutex) {
+		status = acpi_ev_acquire_global_lock(timeout);
+	} else {
+		status = acpi_ex_system_wait_mutex(obj_desc->mutex.os_mutex,
+						   timeout);
+	}
+
+	if (ACPI_FAILURE(status)) {
+
+		/* Includes failure from a timeout on time_desc */
+
+		return_ACPI_STATUS(status);
+	}
+
+	/* Acquired the mutex: update mutex object */
+
+	obj_desc->mutex.thread_id = thread_id;
+	obj_desc->mutex.acquisition_depth = 1;
+	obj_desc->mutex.original_sync_level = 0;
+	obj_desc->mutex.owner_thread = NULL;	/* Used only for AML Acquire() */
+
+	return_ACPI_STATUS(AE_OK);
+}
+
+/*******************************************************************************
+ *
@@ -154 +227 @@
-	/* Sanity check: we must have a valid thread ID */
+	/* Must have a valid thread ID */
@@ -164 +237 @@
-	 * Current Sync must be less than or equal to the sync level of the
+	 * Current sync level must be less than or equal to the sync level of the
@@ -175 +248,12 @@
-	/* Support for multiple acquires by the owning thread */
+	status = acpi_ex_acquire_mutex_object((u16) time_desc->integer.value,
+					      obj_desc,
+					      walk_state->thread->thread_id);
+	if (ACPI_SUCCESS(status) && obj_desc->mutex.acquisition_depth == 1) {
+
+		/* Save Thread object, original/current sync levels */
+
+		obj_desc->mutex.owner_thread = walk_state->thread;
+		obj_desc->mutex.original_sync_level =
+		    walk_state->thread->current_sync_level;
+		walk_state->thread->current_sync_level =
+		    obj_desc->mutex.sync_level;
@@ -177,10 +261,3 @@
-	if (obj_desc->mutex.owner_thread) {
-		if (obj_desc->mutex.owner_thread->thread_id ==
-		    walk_state->thread->thread_id) {
-			/*
-			 * The mutex is already owned by this thread, just increment the
-			 * acquisition depth
-			 */
-			obj_desc->mutex.acquisition_depth++;
-			return_ACPI_STATUS(AE_OK);
-		}
+		/* Link the mutex to the current thread for force-unlock at method exit */
+
+		acpi_ex_link_mutex(obj_desc, walk_state->thread);
@@ -189 +266,2 @@
-	/* Acquire the mutex, wait if necessary. Special case for Global Lock */
+	return_ACPI_STATUS(status);
+}
@@ -191,7 +269,30 @@
-	if (obj_desc->mutex.os_mutex == acpi_gbl_global_lock_mutex) {
-		status =
-		    acpi_ev_acquire_global_lock((u16) time_desc->integer.value);
-	} else {
-		status = acpi_ex_system_wait_mutex(obj_desc->mutex.os_mutex,
-						   (u16) time_desc->integer.
-						   value);
+/*******************************************************************************
+ *
+ * FUNCTION:    acpi_ex_release_mutex_object
+ *
+ * PARAMETERS:  obj_desc            - The object descriptor for this op
+ *
+ * RETURN:      Status
+ *
+ * DESCRIPTION: Release a previously acquired Mutex, low level interface.
+ *              Provides a common path that supports multiple releases (after
+ *              previous multiple acquires) by the same thread.
+ *
+ * MUTEX:       Interpreter must be locked
+ *
+ * NOTE: This interface is called from three places:
+ * 1) From acpi_ex_release_mutex, via an AML Acquire() operator
+ * 2) From acpi_ex_release_global_lock when an AML Field access requires the
+ *    global lock
+ * 3) From the external interface, acpi_release_global_lock
+ *
+ ******************************************************************************/
+
+acpi_status acpi_ex_release_mutex_object(union acpi_operand_object *obj_desc)
+{
+	acpi_status status = AE_OK;
+
+	ACPI_FUNCTION_TRACE(ex_release_mutex_object);
+
+	if (obj_desc->mutex.acquisition_depth == 0) {
+		return (AE_NOT_ACQUIRED);
@@ -200 +301 @@
-	if (ACPI_FAILURE(status)) {
+	/* Match multiple Acquires with multiple Releases */
@@ -202 +303,2 @@
-		/* Includes failure from a timeout on time_desc */
+	obj_desc->mutex.acquisition_depth--;
+	if (obj_desc->mutex.acquisition_depth != 0) {
@@ -204 +306,3 @@
-		return_ACPI_STATUS(status);
+		/* Just decrement the depth and return */
+
+		return_ACPI_STATUS(AE_OK);
@@ -207 +311,3 @@
-	/* Have the mutex: update mutex and walk info and save the sync_level */
+	if (obj_desc->mutex.owner_thread) {
+
+		/* Unlink the mutex from the owner's list */
@@ -209,4 +315,3 @@
-	obj_desc->mutex.owner_thread = walk_state->thread;
-	obj_desc->mutex.acquisition_depth = 1;
-	obj_desc->mutex.original_sync_level =
-	    walk_state->thread->current_sync_level;
+		acpi_ex_unlink_mutex(obj_desc);
+		obj_desc->mutex.owner_thread = NULL;
+	}
@@ -214 +319 @@
-	walk_state->thread->current_sync_level = obj_desc->mutex.sync_level;
+	/* Release the mutex, special case for Global Lock */
@@ -216 +321,5 @@
-	/* Link the mutex to the current thread for force-unlock at method exit */
+	if (obj_desc == acpi_gbl_global_lock_mutex) {
+		status = acpi_ev_release_global_lock();
+	} else {
+		acpi_os_release_mutex(obj_desc->mutex.os_mutex);
+	}
@@ -218,2 +327,4 @@
-	acpi_ex_link_mutex(obj_desc, walk_state->thread);
-	return_ACPI_STATUS(AE_OK);
+	/* Clear mutex info */
+
+	obj_desc->mutex.thread_id = NULL;
+	return_ACPI_STATUS(status);
@@ -256,9 +366,0 @@
-	/* Sanity check: we must have a valid thread ID */
-
-	if (!walk_state->thread) {
-		ACPI_ERROR((AE_INFO,
-			    "Cannot release Mutex [%4.4s], null thread info",
-			    acpi_ut_get_node_name(obj_desc->mutex.node)));
-		return_ACPI_STATUS(AE_AML_INTERNAL);
-	}
-
@@ -271 +373 @@
-	    && (obj_desc->mutex.os_mutex != acpi_gbl_global_lock_mutex)) {
+	    && (obj_desc != acpi_gbl_global_lock_mutex)) {
@@ -280,0 +383,9 @@
+	/* Must have a valid thread ID */
+
+	if (!walk_state->thread) {
+		ACPI_ERROR((AE_INFO,
+			    "Cannot release Mutex [%4.4s], null thread info",
+			    acpi_ut_get_node_name(obj_desc->mutex.node)));
+		return_ACPI_STATUS(AE_AML_INTERNAL);
+	}
+
@@ -287,2 +398,4 @@
-			    "Cannot release Mutex [%4.4s], incorrect SyncLevel",
-			    acpi_ut_get_node_name(obj_desc->mutex.node)));
+			    "Cannot release Mutex [%4.4s], SyncLevel mismatch: mutex %d current %d",
+			    acpi_ut_get_node_name(obj_desc->mutex.node),
+			    obj_desc->mutex.sync_level,
+			    walk_state->thread->current_sync_level));
@@ -292 +405 @@
-	/* Match multiple Acquires with multiple Releases */
+	status = acpi_ex_release_mutex_object(obj_desc);
@@ -294,2 +407 @@
-	obj_desc->mutex.acquisition_depth--;
-	if (obj_desc->mutex.acquisition_depth != 0) {
+	if (obj_desc->mutex.acquisition_depth == 0) {
@@ -297,10 +409 @@
-		/* Just decrement the depth and return */
-
-		return_ACPI_STATUS(AE_OK);
-	}
-
-	/* Unlink the mutex from the owner's list */
-
-	acpi_ex_unlink_mutex(obj_desc);
-
-	/* Release the mutex, special case for Global Lock */
+		/* Restore the original sync_level */
@@ -308,4 +411,2 @@
-	if (obj_desc->mutex.os_mutex == acpi_gbl_global_lock_mutex) {
-		status = acpi_ev_release_global_lock();
-	} else {
-		acpi_os_release_mutex(obj_desc->mutex.os_mutex);
+		walk_state->thread->current_sync_level =
+		    obj_desc->mutex.original_sync_level;
@@ -313,7 +413,0 @@
-
-	/* Update the mutex and restore sync_level */
-
-	obj_desc->mutex.owner_thread = NULL;
-	walk_state->thread->current_sync_level =
-	    obj_desc->mutex.original_sync_level;
-
@@ -360 +454 @@
-		if (obj_desc->mutex.os_mutex == acpi_gbl_global_lock_mutex) {
+		if (obj_desc == acpi_gbl_global_lock_mutex) {
@@ -371,0 +466 @@
+		obj_desc->mutex.thread_id = NULL;
--- ./projects/linux/linux-2.6.13/drivers/acpi/processor_throttling.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/acpi/processor_throttling.c	2005-10-28 02:02:08.000000000 +0200
@@ -46,2 +46 @@
-ACPI_MODULE_NAME                ("acpi_processor")
-
+ACPI_MODULE_NAME("acpi_processor")
@@ -52,4 +51 @@
-
-static int
-acpi_processor_get_throttling (
-	struct acpi_processor	*pr)
+static int acpi_processor_get_throttling(struct acpi_processor *pr)
@@ -57,4 +53,4 @@
-	int			state = 0;
-	u32			value = 0;
-	u32			duty_mask = 0;
-	u32			duty_value = 0;
+	int state = 0;
+	u32 value = 0;
+	u32 duty_mask = 0;
+	u32 duty_value = 0;
@@ -89 +85 @@
-			state = pr->throttling.state_count-duty_value;
+			state = pr->throttling.state_count - duty_value;
@@ -97,2 +93,2 @@
-		"Throttling state is T%d (%d%% throttling applied)\n",
-		state, pr->throttling.states[state].performance));
+			  "Throttling state is T%d (%d%% throttling applied)\n",
+			  state, pr->throttling.states[state].performance));
@@ -103,4 +99 @@
-
-int acpi_processor_set_throttling (
-	struct acpi_processor	*pr,
-	int			state)
+int acpi_processor_set_throttling(struct acpi_processor *pr, int state)
@@ -108,3 +101,3 @@
-	u32                     value = 0;
-	u32                     duty_mask = 0;
-	u32                     duty_value = 0;
+	u32 value = 0;
+	u32 duty_mask = 0;
+	u32 duty_value = 0;
@@ -171,2 +164,3 @@
-		"Throttling state set to T%d (%d%%)\n", state,
-		(pr->throttling.states[state].performance?pr->throttling.states[state].performance/10:0)));
+			  "Throttling state set to T%d (%d%%)\n", state,
+			  (pr->throttling.states[state].performance ? pr->
+			   throttling.states[state].performance / 10 : 0)));
@@ -177,4 +171 @@
-
-int
-acpi_processor_get_throttling_info (
-	struct acpi_processor	*pr)
+int acpi_processor_get_throttling_info(struct acpi_processor *pr)
@@ -182,3 +173,3 @@
-	int			result = 0;
-	int			step = 0;
-	int			i = 0;
+	int result = 0;
+	int step = 0;
+	int i = 0;
@@ -189,4 +180,4 @@
-		"pblk_address[0x%08x] duty_offset[%d] duty_width[%d]\n",
-		pr->throttling.address,
-		pr->throttling.duty_offset,
-		pr->throttling.duty_width));
+			  "pblk_address[0x%08x] duty_offset[%d] duty_width[%d]\n",
+			  pr->throttling.address,
+			  pr->throttling.duty_offset,
+			  pr->throttling.duty_width));
@@ -202,2 +193 @@
-	}
-	else if (!pr->throttling.duty_width) {
+	} else if (!pr->throttling.duty_width) {
@@ -208,2 +198 @@
-	else if ((pr->throttling.duty_offset
-		+ pr->throttling.duty_width) > 4) {
+	else if ((pr->throttling.duty_offset + pr->throttling.duty_width) > 4) {
@@ -221 +210 @@
-			"Throttling not supported on PIIX4 A- or B-step\n"));
+				  "Throttling not supported on PIIX4 A- or B-step\n"));
@@ -235 +224 @@
-	for (i=0; i<pr->throttling.state_count; i++) {
+	for (i = 0; i < pr->throttling.state_count; i++) {
@@ -241 +230 @@
-		pr->throttling.state_count));
+			  pr->throttling.state_count));
@@ -256,2 +245,3 @@
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Disabling throttling (was T%d)\n",
-			pr->throttling.state));
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+				  "Disabling throttling (was T%d)\n",
+				  pr->throttling.state));
@@ -263 +253 @@
-end:
+      end:
@@ -270 +259,0 @@
-
@@ -273 +262,2 @@
-static int acpi_processor_throttling_seq_show(struct seq_file *seq, void *offset)
+static int acpi_processor_throttling_seq_show(struct seq_file *seq,
+					      void *offset)
@@ -275,3 +265,3 @@
-	struct acpi_processor	*pr = (struct acpi_processor *)seq->private;
-	int			i = 0;
-	int                     result = 0;
+	struct acpi_processor *pr = (struct acpi_processor *)seq->private;
+	int i = 0;
+	int result = 0;
@@ -292 +282,2 @@
-		seq_puts(seq, "Could not determine current throttling state.\n");
+		seq_puts(seq,
+			 "Could not determine current throttling state.\n");
@@ -297,3 +288,2 @@
-			"active state:            T%d\n",
-			pr->throttling.state_count,
-			pr->throttling.state);
+		   "active state:            T%d\n",
+		   pr->throttling.state_count, pr->throttling.state);
@@ -304,2 +294,3 @@
-			(i == pr->throttling.state?'*':' '), i,
-			(pr->throttling.states[i].performance?pr->throttling.states[i].performance/10:0));
+			   (i == pr->throttling.state ? '*' : ' '), i,
+			   (pr->throttling.states[i].performance ? pr->
+			    throttling.states[i].performance / 10 : 0));
@@ -307 +298 @@
-end:
+      end:
@@ -311 +302,2 @@
-static int acpi_processor_throttling_open_fs(struct inode *inode, struct file *file)
+static int acpi_processor_throttling_open_fs(struct inode *inode,
+					     struct file *file)
@@ -314 +306 @@
-						PDE(inode)->data);
+			   PDE(inode)->data);
@@ -317,5 +309,3 @@
-ssize_t acpi_processor_write_throttling (
-        struct file		*file,
-        const char		__user *buffer,
-        size_t			count,
-        loff_t			*data)
+ssize_t acpi_processor_write_throttling(struct file * file,
+					const char __user * buffer,
+					size_t count, loff_t * data)
@@ -323,4 +313,4 @@
-	int			result = 0;
-        struct seq_file 	*m = (struct seq_file *)file->private_data;
-	struct acpi_processor	*pr = (struct acpi_processor *)m->private;
-	char			state_string[12] = {'\0'};
+	int result = 0;
+	struct seq_file *m = (struct seq_file *)file->private_data;
+	struct acpi_processor *pr = (struct acpi_processor *)m->private;
+	char state_string[12] = { '\0' };
@@ -339 +329,2 @@
-		simple_strtoul(state_string, NULL, 0));
+					       simple_strtoul(state_string,
+							      NULL, 0));
@@ -347,4 +338,4 @@
-	.open 		= acpi_processor_throttling_open_fs,
-	.read		= seq_read,
-	.llseek		= seq_lseek,
-	.release	= single_release,
+	.open = acpi_processor_throttling_open_fs,
+	.read = seq_read,
+	.llseek = seq_lseek,
+	.release = single_release,
--- ./projects/linux/linux-2.6.15/drivers/acpi/processor_throttling.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/acpi/processor_throttling.c	2006-03-20 06:53:29.000000000 +0100
@@ -309,3 +309,3 @@
-ssize_t acpi_processor_write_throttling(struct file * file,
-					const char __user * buffer,
-					size_t count, loff_t * data)
+static ssize_t acpi_processor_write_throttling(struct file * file,
+					       const char __user * buffer,
+					       size_t count, loff_t * data)
@@ -339,0 +340 @@
+	.write = acpi_processor_write_throttling,
--- ./projects/linux/linux-2.6.17/drivers/acpi/processor_throttling.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/acpi/processor_throttling.c	2006-09-20 05:42:06.000000000 +0200
@@ -58 +57,0 @@
-	ACPI_FUNCTION_TRACE("acpi_processor_get_throttling");
@@ -61 +60 @@
-		return_VALUE(-EINVAL);
+		return -EINVAL;
@@ -64 +63 @@
-		return_VALUE(-ENODEV);
+		return -ENODEV;
@@ -96 +95 @@
-	return_VALUE(0);
+	return 0;
@@ -105 +103,0 @@
-	ACPI_FUNCTION_TRACE("acpi_processor_set_throttling");
@@ -108 +106 @@
-		return_VALUE(-EINVAL);
+		return -EINVAL;
@@ -111 +109 @@
-		return_VALUE(-EINVAL);
+		return -EINVAL;
@@ -114 +112 @@
-		return_VALUE(-ENODEV);
+		return -ENODEV;
@@ -117 +115 @@
-		return_VALUE(0);
+		return 0;
@@ -168 +166 @@
-	return_VALUE(0);
+	return 0;
@@ -177 +174,0 @@
-	ACPI_FUNCTION_TRACE("acpi_processor_get_throttling_info");
@@ -186 +183 @@
-		return_VALUE(-EINVAL);
+		return -EINVAL;
@@ -192 +189 @@
-		return_VALUE(0);
+		return 0;
@@ -195 +192 @@
-		return_VALUE(0);
+		return 0;
@@ -199,2 +196,2 @@
-		ACPI_DEBUG_PRINT((ACPI_DB_WARN, "duty_cycle spans bit 4\n"));
-		return_VALUE(0);
+		printk(KERN_WARNING PREFIX "duty_cycle spans bit 4\n");
+		return 0;
@@ -211 +208 @@
-		return_VALUE(0);
+		return 0;
@@ -257 +254 @@
-	return_VALUE(result);
+	return result;
@@ -269 +265,0 @@
-	ACPI_FUNCTION_TRACE("acpi_processor_throttling_seq_show");
@@ -299 +295 @@
-	return_VALUE(0);
+	return 0;
@@ -318 +313,0 @@
-	ACPI_FUNCTION_TRACE("acpi_processor_write_throttling");
@@ -321 +316 @@
-		return_VALUE(-EINVAL);
+		return -EINVAL;
@@ -324 +319 @@
-		return_VALUE(-EFAULT);
+		return -EFAULT;
@@ -332 +327 @@
-		return_VALUE(result);
+		return result;
@@ -334 +329 @@
-	return_VALUE(count);
+	return count;
--- ./projects/linux/linux-2.6.19/drivers/acpi/processor_throttling.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/acpi/processor_throttling.c	2007-02-04 19:44:54.000000000 +0100
@@ -262 +262 @@
-	struct acpi_processor *pr = (struct acpi_processor *)seq->private;
+	struct acpi_processor *pr = seq->private;
@@ -310,2 +310,2 @@
-	struct seq_file *m = (struct seq_file *)file->private_data;
-	struct acpi_processor *pr = (struct acpi_processor *)m->private;
+	struct seq_file *m = file->private_data;
+	struct acpi_processor *pr = m->private;
--- ./projects/linux/linux-2.6.20/drivers/acpi/processor_throttling.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/acpi/processor_throttling.c	2007-04-26 05:08:32.000000000 +0200
@@ -44 +43,0 @@
-#define ACPI_PROCESSOR_DRIVER_NAME      "ACPI Processor Driver"
@@ -46 +45 @@
-ACPI_MODULE_NAME("acpi_processor")
+ACPI_MODULE_NAME("processor_throttling");
@@ -128 +127 @@
-		duty_mask <<= acpi_fadt.duty_offset;
+		duty_mask <<= acpi_gbl_FADT.duty_offset;
@@ -211 +210 @@
-	pr->throttling.state_count = 1 << acpi_fadt.duty_width;
+	pr->throttling.state_count = 1 << acpi_gbl_FADT.duty_width;
--- ./projects/linux/linux-2.6.22/drivers/acpi/processor_throttling.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/acpi/processor_throttling.c	2007-10-09 22:31:38.000000000 +0200
@@ -46,0 +47,235 @@
+static int acpi_processor_get_throttling(struct acpi_processor *pr);
+int acpi_processor_set_throttling(struct acpi_processor *pr, int state);
+
+/*
+ * _TPC - Throttling Present Capabilities
+ */
+static int acpi_processor_get_platform_limit(struct acpi_processor *pr)
+{
+	acpi_status status = 0;
+	unsigned long tpc = 0;
+
+	if (!pr)
+		return -EINVAL;
+	status = acpi_evaluate_integer(pr->handle, "_TPC", NULL, &tpc);
+	if (ACPI_FAILURE(status)) {
+		if (status != AE_NOT_FOUND) {
+			ACPI_EXCEPTION((AE_INFO, status, "Evaluating _TPC"));
+		}
+		return -ENODEV;
+	}
+	pr->throttling_platform_limit = (int)tpc;
+	return 0;
+}
+
+int acpi_processor_tstate_has_changed(struct acpi_processor *pr)
+{
+	return acpi_processor_get_platform_limit(pr);
+}
+
+/*
+ * _PTC - Processor Throttling Control (and status) register location
+ */
+static int acpi_processor_get_throttling_control(struct acpi_processor *pr)
+{
+	int result = 0;
+	acpi_status status = 0;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	union acpi_object *ptc = NULL;
+	union acpi_object obj = { 0 };
+
+	status = acpi_evaluate_object(pr->handle, "_PTC", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		if (status != AE_NOT_FOUND) {
+			ACPI_EXCEPTION((AE_INFO, status, "Evaluating _PTC"));
+		}
+		return -ENODEV;
+	}
+
+	ptc = (union acpi_object *)buffer.pointer;
+	if (!ptc || (ptc->type != ACPI_TYPE_PACKAGE)
+	    || (ptc->package.count != 2)) {
+		printk(KERN_ERR PREFIX "Invalid _PTC data\n");
+		result = -EFAULT;
+		goto end;
+	}
+
+	/*
+	 * control_register
+	 */
+
+	obj = ptc->package.elements[0];
+
+	if ((obj.type != ACPI_TYPE_BUFFER)
+	    || (obj.buffer.length < sizeof(struct acpi_ptc_register))
+	    || (obj.buffer.pointer == NULL)) {
+		printk(KERN_ERR PREFIX
+		       "Invalid _PTC data (control_register)\n");
+		result = -EFAULT;
+		goto end;
+	}
+	memcpy(&pr->throttling.control_register, obj.buffer.pointer,
+	       sizeof(struct acpi_ptc_register));
+
+	/*
+	 * status_register
+	 */
+
+	obj = ptc->package.elements[1];
+
+	if ((obj.type != ACPI_TYPE_BUFFER)
+	    || (obj.buffer.length < sizeof(struct acpi_ptc_register))
+	    || (obj.buffer.pointer == NULL)) {
+		printk(KERN_ERR PREFIX "Invalid _PTC data (status_register)\n");
+		result = -EFAULT;
+		goto end;
+	}
+
+	memcpy(&pr->throttling.status_register, obj.buffer.pointer,
+	       sizeof(struct acpi_ptc_register));
+
+      end:
+	kfree(buffer.pointer);
+
+	return result;
+}
+
+/*
+ * _TSS - Throttling Supported States
+ */
+static int acpi_processor_get_throttling_states(struct acpi_processor *pr)
+{
+	int result = 0;
+	acpi_status status = AE_OK;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_buffer format = { sizeof("NNNNN"), "NNNNN" };
+	struct acpi_buffer state = { 0, NULL };
+	union acpi_object *tss = NULL;
+	int i;
+
+	status = acpi_evaluate_object(pr->handle, "_TSS", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		if (status != AE_NOT_FOUND) {
+			ACPI_EXCEPTION((AE_INFO, status, "Evaluating _TSS"));
+		}
+		return -ENODEV;
+	}
+
+	tss = buffer.pointer;
+	if (!tss || (tss->type != ACPI_TYPE_PACKAGE)) {
+		printk(KERN_ERR PREFIX "Invalid _TSS data\n");
+		result = -EFAULT;
+		goto end;
+	}
+
+	ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Found %d throttling states\n",
+			  tss->package.count));
+
+	pr->throttling.state_count = tss->package.count;
+	pr->throttling.states_tss =
+	    kmalloc(sizeof(struct acpi_processor_tx_tss) * tss->package.count,
+		    GFP_KERNEL);
+	if (!pr->throttling.states_tss) {
+		result = -ENOMEM;
+		goto end;
+	}
+
+	for (i = 0; i < pr->throttling.state_count; i++) {
+
+		struct acpi_processor_tx_tss *tx =
+		    (struct acpi_processor_tx_tss *)&(pr->throttling.
+						      states_tss[i]);
+
+		state.length = sizeof(struct acpi_processor_tx_tss);
+		state.pointer = tx;
+
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Extracting state %d\n", i));
+
+		status = acpi_extract_package(&(tss->package.elements[i]),
+					      &format, &state);
+		if (ACPI_FAILURE(status)) {
+			ACPI_EXCEPTION((AE_INFO, status, "Invalid _TSS data"));
+			result = -EFAULT;
+			kfree(pr->throttling.states_tss);
+			goto end;
+		}
+
+		if (!tx->freqpercentage) {
+			printk(KERN_ERR PREFIX
+			       "Invalid _TSS data: freq is zero\n");
+			result = -EFAULT;
+			kfree(pr->throttling.states_tss);
+			goto end;
+		}
+	}
+
+      end:
+	kfree(buffer.pointer);
+
+	return result;
+}
+
+/*
+ * _TSD - T-State Dependencies
+ */
+static int acpi_processor_get_tsd(struct acpi_processor *pr)
+{
+	int result = 0;
+	acpi_status status = AE_OK;
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
+	struct acpi_buffer format = { sizeof("NNNNN"), "NNNNN" };
+	struct acpi_buffer state = { 0, NULL };
+	union acpi_object *tsd = NULL;
+	struct acpi_tsd_package *pdomain;
+
+	status = acpi_evaluate_object(pr->handle, "_TSD", NULL, &buffer);
+	if (ACPI_FAILURE(status)) {
+		if (status != AE_NOT_FOUND) {
+			ACPI_EXCEPTION((AE_INFO, status, "Evaluating _TSD"));
+		}
+		return -ENODEV;
+	}
+
+	tsd = buffer.pointer;
+	if (!tsd || (tsd->type != ACPI_TYPE_PACKAGE)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _TSD data\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	if (tsd->package.count != 1) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _TSD data\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	pdomain = &(pr->throttling.domain_info);
+
+	state.length = sizeof(struct acpi_tsd_package);
+	state.pointer = pdomain;
+
+	status = acpi_extract_package(&(tsd->package.elements[0]),
+				      &format, &state);
+	if (ACPI_FAILURE(status)) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _TSD data\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	if (pdomain->num_entries != ACPI_TSD_REV0_ENTRIES) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unknown _TSD:num_entries\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+	if (pdomain->revision != ACPI_TSD_REV0_REVISION) {
+		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unknown _TSD:revision\n"));
+		result = -EFAULT;
+		goto end;
+	}
+
+      end:
+	kfree(buffer.pointer);
+	return result;
+}
+
@@ -50 +285 @@
-static int acpi_processor_get_throttling(struct acpi_processor *pr)
+static int acpi_processor_get_throttling_fadt(struct acpi_processor *pr)
@@ -57 +291,0 @@
-
@@ -97 +331,104 @@
-int acpi_processor_set_throttling(struct acpi_processor *pr, int state)
+static int acpi_read_throttling_status(struct acpi_processor_throttling
+				       *throttling)
+{
+	int value = -1;
+	switch (throttling->status_register.space_id) {
+	case ACPI_ADR_SPACE_SYSTEM_IO:
+		acpi_os_read_port((acpi_io_address) throttling->status_register.
+				  address, &value,
+				  (u32) throttling->status_register.bit_width *
+				  8);
+		break;
+	case ACPI_ADR_SPACE_FIXED_HARDWARE:
+		printk(KERN_ERR PREFIX
+		       "HARDWARE addr space,NOT supported yet\n");
+		break;
+	default:
+		printk(KERN_ERR PREFIX "Unknown addr space %d\n",
+		       (u32) (throttling->status_register.space_id));
+	}
+	return value;
+}
+
+static int acpi_write_throttling_state(struct acpi_processor_throttling
+				       *throttling, int value)
+{
+	int ret = -1;
+
+	switch (throttling->control_register.space_id) {
+	case ACPI_ADR_SPACE_SYSTEM_IO:
+		acpi_os_write_port((acpi_io_address) throttling->
+				   control_register.address, value,
+				   (u32) throttling->control_register.
+				   bit_width * 8);
+		ret = 0;
+		break;
+	case ACPI_ADR_SPACE_FIXED_HARDWARE:
+		printk(KERN_ERR PREFIX
+		       "HARDWARE addr space,NOT supported yet\n");
+		break;
+	default:
+		printk(KERN_ERR PREFIX "Unknown addr space %d\n",
+		       (u32) (throttling->control_register.space_id));
+	}
+	return ret;
+}
+
+static int acpi_get_throttling_state(struct acpi_processor *pr, int value)
+{
+	int i;
+
+	for (i = 0; i < pr->throttling.state_count; i++) {
+		struct acpi_processor_tx_tss *tx =
+		    (struct acpi_processor_tx_tss *)&(pr->throttling.
+						      states_tss[i]);
+		if (tx->control == value)
+			break;
+	}
+	if (i > pr->throttling.state_count)
+		i = -1;
+	return i;
+}
+
+static int acpi_get_throttling_value(struct acpi_processor *pr, int state)
+{
+	int value = -1;
+	if (state >= 0 && state <= pr->throttling.state_count) {
+		struct acpi_processor_tx_tss *tx =
+		    (struct acpi_processor_tx_tss *)&(pr->throttling.
+						      states_tss[state]);
+		value = tx->control;
+	}
+	return value;
+}
+
+static int acpi_processor_get_throttling_ptc(struct acpi_processor *pr)
+{
+	int state = 0;
+	u32 value = 0;
+
+	if (!pr)
+		return -EINVAL;
+
+	if (!pr->flags.throttling)
+		return -ENODEV;
+
+	pr->throttling.state = 0;
+	local_irq_disable();
+	value = acpi_read_throttling_status(&pr->throttling);
+	if (value >= 0) {
+		state = acpi_get_throttling_state(pr, value);
+		pr->throttling.state = state;
+	}
+	local_irq_enable();
+
+	return 0;
+}
+
+static int acpi_processor_get_throttling(struct acpi_processor *pr)
+{
+	return pr->throttling.acpi_processor_get_throttling(pr);
+}
+
+static int acpi_processor_set_throttling_fadt(struct acpi_processor *pr,
+					      int state)
@@ -103 +439,0 @@
-
@@ -115,0 +452,2 @@
+	if (state < pr->throttling_platform_limit)
+		return -EPERM;
@@ -167,0 +506,37 @@
+static int acpi_processor_set_throttling_ptc(struct acpi_processor *pr,
+					     int state)
+{
+	u32 value = 0;
+
+	if (!pr)
+		return -EINVAL;
+
+	if ((state < 0) || (state > (pr->throttling.state_count - 1)))
+		return -EINVAL;
+
+	if (!pr->flags.throttling)
+		return -ENODEV;
+
+	if (state == pr->throttling.state)
+		return 0;
+
+	if (state < pr->throttling_platform_limit)
+		return -EPERM;
+
+	local_irq_disable();
+
+	value = acpi_get_throttling_value(pr, state);
+	if (value >= 0) {
+		acpi_write_throttling_state(&pr->throttling, value);
+		pr->throttling.state = state;
+	}
+	local_irq_enable();
+
+	return 0;
+}
+
+int acpi_processor_set_throttling(struct acpi_processor *pr, int state)
+{
+	return pr->throttling.acpi_processor_set_throttling(pr, state);
+}
+
@@ -174 +548,0 @@
-
@@ -184 +558,20 @@
-	/* TBD: Support ACPI 2.0 objects */
+	/*
+	 * Evaluate _PTC, _TSS and _TPC
+	 * They must all be present or none of them can be used.
+	 */
+	if (acpi_processor_get_throttling_control(pr) ||
+		acpi_processor_get_throttling_states(pr) ||
+		acpi_processor_get_platform_limit(pr))
+	{
+		pr->throttling.acpi_processor_get_throttling =
+		    &acpi_processor_get_throttling_fadt;
+		pr->throttling.acpi_processor_set_throttling =
+		    &acpi_processor_set_throttling_fadt;
+	} else {
+		pr->throttling.acpi_processor_get_throttling =
+		    &acpi_processor_get_throttling_ptc;
+		pr->throttling.acpi_processor_set_throttling =
+		    &acpi_processor_set_throttling_ptc;
+	}
+
+	acpi_processor_get_tsd(pr);
@@ -265 +657,0 @@
-
@@ -283,2 +675,5 @@
-		   "active state:            T%d\n",
-		   pr->throttling.state_count, pr->throttling.state);
+		   "active state:            T%d\n"
+		   "state available: T%d to T%d\n",
+		   pr->throttling.state_count, pr->throttling.state,
+		   pr->throttling_platform_limit,
+		   pr->throttling.state_count - 1);
@@ -287,5 +682,14 @@
-	for (i = 0; i < pr->throttling.state_count; i++)
-		seq_printf(seq, "   %cT%d:                  %02d%%\n",
-			   (i == pr->throttling.state ? '*' : ' '), i,
-			   (pr->throttling.states[i].performance ? pr->
-			    throttling.states[i].performance / 10 : 0));
+	if (pr->throttling.acpi_processor_get_throttling ==
+			acpi_processor_get_throttling_fadt) {
+		for (i = 0; i < pr->throttling.state_count; i++)
+			seq_printf(seq, "   %cT%d:                  %02d%%\n",
+				   (i == pr->throttling.state ? '*' : ' '), i,
+				   (pr->throttling.states[i].performance ? pr->
+				    throttling.states[i].performance / 10 : 0));
+	} else {
+		for (i = 0; i < pr->throttling.state_count; i++)
+			seq_printf(seq, "   %cT%d:                  %02d%%\n",
+				   (i == pr->throttling.state ? '*' : ' '), i,
+				   (int)pr->throttling.states_tss[i].
+				   freqpercentage);
+	}
@@ -304 +708 @@
-static ssize_t acpi_processor_write_throttling(struct file * file,
+static ssize_t acpi_processor_write_throttling(struct file *file,
@@ -313 +716,0 @@
-
--- ./projects/linux/linux-2.6.23/drivers/acpi/processor_throttling.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/acpi/processor_throttling.c	2008-01-24 23:58:37.000000000 +0100
@@ -31,0 +32 @@
+#include <linux/sched.h>
@@ -73 +74,49 @@
-	return acpi_processor_get_platform_limit(pr);
+	int result = 0;
+	int throttling_limit;
+	int current_state;
+	struct acpi_processor_limit *limit;
+	int target_state;
+
+	result = acpi_processor_get_platform_limit(pr);
+	if (result) {
+		/* Throttling Limit is unsupported */
+		return result;
+	}
+
+	throttling_limit = pr->throttling_platform_limit;
+	if (throttling_limit >= pr->throttling.state_count) {
+		/* Uncorrect Throttling Limit */
+		return -EINVAL;
+	}
+
+	current_state = pr->throttling.state;
+	if (current_state > throttling_limit) {
+		/*
+		 * The current state can meet the requirement of
+		 * _TPC limit. But it is reasonable that OSPM changes
+		 * t-states from high to low for better performance.
+		 * Of course the limit condition of thermal
+		 * and user should be considered.
+		 */
+		limit = &pr->limit;
+		target_state = throttling_limit;
+		if (limit->thermal.tx > target_state)
+			target_state = limit->thermal.tx;
+		if (limit->user.tx > target_state)
+			target_state = limit->user.tx;
+	} else if (current_state == throttling_limit) {
+		/*
+		 * Unnecessary to change the throttling state
+		 */
+		return 0;
+	} else {
+		/*
+		 * If the current state is lower than the limit of _TPC, it
+		 * will be forced to switch to the throttling state defined
+		 * by throttling_platfor_limit.
+		 * Because the previous state meets with the limit condition
+		 * of thermal and user, it is unnecessary to check it again.
+		 */
+		target_state = throttling_limit;
+	}
+	return acpi_processor_set_throttling(pr, target_state);
@@ -85,0 +135 @@
+	struct acpi_processor_throttling *throttling;
@@ -136,0 +187,16 @@
+	throttling = &pr->throttling;
+
+	if ((throttling->control_register.bit_width +
+		throttling->control_register.bit_offset) > 32) {
+		printk(KERN_ERR PREFIX "Invalid _PTC control register\n");
+		result = -EFAULT;
+		goto end;
+	}
+
+	if ((throttling->status_register.bit_width +
+		throttling->status_register.bit_offset) > 32) {
+		printk(KERN_ERR PREFIX "Invalid _PTC status register\n");
+		result = -EFAULT;
+		goto end;
+	}
+
@@ -331,2 +397,30 @@
-static int acpi_read_throttling_status(struct acpi_processor_throttling
-				       *throttling)
+#ifdef CONFIG_X86
+static int acpi_throttling_rdmsr(struct acpi_processor *pr,
+					acpi_integer * value)
+{
+	struct cpuinfo_x86 *c;
+	u64 msr_high, msr_low;
+	unsigned int cpu;
+	u64 msr = 0;
+	int ret = -1;
+
+	cpu = pr->id;
+	c = &cpu_data(cpu);
+
+	if ((c->x86_vendor != X86_VENDOR_INTEL) ||
+		!cpu_has(c, X86_FEATURE_ACPI)) {
+		printk(KERN_ERR PREFIX
+			"HARDWARE addr space,NOT supported yet\n");
+	} else {
+		msr_low = 0;
+		msr_high = 0;
+		rdmsr_safe(MSR_IA32_THERM_CONTROL,
+			(u32 *)&msr_low , (u32 *) &msr_high);
+		msr = (msr_high << 32) | msr_low;
+		*value = (acpi_integer) msr;
+		ret = 0;
+	}
+	return ret;
+}
+
+static int acpi_throttling_wrmsr(struct acpi_processor *pr, acpi_integer value)
@@ -334 +428,47 @@
-	int value = -1;
+	struct cpuinfo_x86 *c;
+	unsigned int cpu;
+	int ret = -1;
+	u64 msr;
+
+	cpu = pr->id;
+	c = &cpu_data(cpu);
+
+	if ((c->x86_vendor != X86_VENDOR_INTEL) ||
+		!cpu_has(c, X86_FEATURE_ACPI)) {
+		printk(KERN_ERR PREFIX
+			"HARDWARE addr space,NOT supported yet\n");
+	} else {
+		msr = value;
+		wrmsr_safe(MSR_IA32_THERM_CONTROL,
+			msr & 0xffffffff, msr >> 32);
+		ret = 0;
+	}
+	return ret;
+}
+#else
+static int acpi_throttling_rdmsr(struct acpi_processor *pr,
+				acpi_integer * value)
+{
+	printk(KERN_ERR PREFIX
+		"HARDWARE addr space,NOT supported yet\n");
+	return -1;
+}
+
+static int acpi_throttling_wrmsr(struct acpi_processor *pr, acpi_integer value)
+{
+	printk(KERN_ERR PREFIX
+		"HARDWARE addr space,NOT supported yet\n");
+	return -1;
+}
+#endif
+
+static int acpi_read_throttling_status(struct acpi_processor *pr,
+					acpi_integer *value)
+{
+	u32 bit_width, bit_offset;
+	u64 ptc_value;
+	u64 ptc_mask;
+	struct acpi_processor_throttling *throttling;
+	int ret = -1;
+
+	throttling = &pr->throttling;
@@ -336,0 +477,4 @@
+		ptc_value = 0;
+		bit_width = throttling->status_register.bit_width;
+		bit_offset = throttling->status_register.bit_offset;
+
@@ -338,3 +482,5 @@
-				  address, &value,
-				  (u32) throttling->status_register.bit_width *
-				  8);
+				  address, (u32 *) &ptc_value,
+				  (u32) (bit_width + bit_offset));
+		ptc_mask = (1 << bit_width) - 1;
+		*value = (acpi_integer) ((ptc_value >> bit_offset) & ptc_mask);
+		ret = 0;
@@ -343,2 +489 @@
-		printk(KERN_ERR PREFIX
-		       "HARDWARE addr space,NOT supported yet\n");
+		ret = acpi_throttling_rdmsr(pr, value);
@@ -350 +495 @@
-	return value;
+	return ret;
@@ -353,2 +498,2 @@
-static int acpi_write_throttling_state(struct acpi_processor_throttling
-				       *throttling, int value)
+static int acpi_write_throttling_state(struct acpi_processor *pr,
+				acpi_integer value)
@@ -355,0 +501,4 @@
+	u32 bit_width, bit_offset;
+	u64 ptc_value;
+	u64 ptc_mask;
+	struct acpi_processor_throttling *throttling;
@@ -357,0 +507 @@
+	throttling = &pr->throttling;
@@ -359,0 +510,5 @@
+		bit_width = throttling->control_register.bit_width;
+		bit_offset = throttling->control_register.bit_offset;
+		ptc_mask = (1 << bit_width) - 1;
+		ptc_value = value & ptc_mask;
+
@@ -361,3 +516,3 @@
-				   control_register.address, value,
-				   (u32) throttling->control_register.
-				   bit_width * 8);
+					control_register.address,
+					(u32) (ptc_value << bit_offset),
+					(u32) (bit_width + bit_offset));
@@ -367,2 +522 @@
-		printk(KERN_ERR PREFIX
-		       "HARDWARE addr space,NOT supported yet\n");
+		ret = acpi_throttling_wrmsr(pr, value);
@@ -377 +531,2 @@
-static int acpi_get_throttling_state(struct acpi_processor *pr, int value)
+static int acpi_get_throttling_state(struct acpi_processor *pr,
+				acpi_integer value)
@@ -393 +548,2 @@
-static int acpi_get_throttling_value(struct acpi_processor *pr, int state)
+static int acpi_get_throttling_value(struct acpi_processor *pr,
+			int state, acpi_integer *value)
@@ -395 +551,2 @@
-	int value = -1;
+	int ret = -1;
+
@@ -400 +557,2 @@
-		value = tx->control;
+		*value = tx->control;
+		ret = 0;
@@ -402 +560 @@
-	return value;
+	return ret;
@@ -408 +566,2 @@
-	u32 value = 0;
+	int ret;
+	acpi_integer value;
@@ -417,3 +576,4 @@
-	local_irq_disable();
-	value = acpi_read_throttling_status(&pr->throttling);
-	if (value >= 0) {
+
+	value = 0;
+	ret = acpi_read_throttling_status(pr, &value);
+	if (ret >= 0) {
@@ -423 +582,0 @@
-	local_irq_enable();
@@ -430 +589,47 @@
-	return pr->throttling.acpi_processor_get_throttling(pr);
+	cpumask_t saved_mask;
+	int ret;
+
+	/*
+	 * Migrate task to the cpu pointed by pr.
+	 */
+	saved_mask = current->cpus_allowed;
+	set_cpus_allowed(current, cpumask_of_cpu(pr->id));
+	ret = pr->throttling.acpi_processor_get_throttling(pr);
+	/* restore the previous state */
+	set_cpus_allowed(current, saved_mask);
+
+	return ret;
+}
+
+static int acpi_processor_get_fadt_info(struct acpi_processor *pr)
+{
+	int i, step;
+
+	if (!pr->throttling.address) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling register\n"));
+		return -EINVAL;
+	} else if (!pr->throttling.duty_width) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling states\n"));
+		return -EINVAL;
+	}
+	/* TBD: Support duty_cycle values that span bit 4. */
+	else if ((pr->throttling.duty_offset + pr->throttling.duty_width) > 4) {
+		printk(KERN_WARNING PREFIX "duty_cycle spans bit 4\n");
+		return -EINVAL;
+	}
+
+	pr->throttling.state_count = 1 << acpi_gbl_FADT.duty_width;
+
+	/*
+	 * Compute state values. Note that throttling displays a linear power
+	 * performance relationship (at 50% performance the CPU will consume
+	 * 50% power).  Values are in 1/10th of a percent to preserve accuracy.
+	 */
+
+	step = (1000 / pr->throttling.state_count);
+
+	for (i = 0; i < pr->throttling.state_count; i++) {
+		pr->throttling.states[i].performance = 1000 - step * i;
+		pr->throttling.states[i].power = 1000 - step * i;
+	}
+	return 0;
@@ -509 +714,2 @@
-	u32 value = 0;
+	int ret;
+	acpi_integer value;
@@ -526,5 +732,4 @@
-	local_irq_disable();
-
-	value = acpi_get_throttling_value(pr, state);
-	if (value >= 0) {
-		acpi_write_throttling_state(&pr->throttling, value);
+	value = 0;
+	ret = acpi_get_throttling_value(pr, state, &value);
+	if (ret >= 0) {
+		acpi_write_throttling_state(pr, value);
@@ -533 +737,0 @@
-	local_irq_enable();
@@ -540 +744,11 @@
-	return pr->throttling.acpi_processor_set_throttling(pr, state);
+	cpumask_t saved_mask;
+	int ret;
+	/*
+	 * Migrate task to the cpu pointed by pr.
+	 */
+	saved_mask = current->cpus_allowed;
+	set_cpus_allowed(current, cpumask_of_cpu(pr->id));
+	ret = pr->throttling.acpi_processor_set_throttling(pr, state);
+	/* restore the previous state */
+	set_cpus_allowed(current, saved_mask);
+	return ret;
@@ -546,2 +759,0 @@
-	int step = 0;
-	int i = 0;
@@ -569,0 +782,2 @@
+		if (acpi_processor_get_fadt_info(pr))
+			return 0;
@@ -579,13 +792,0 @@
-	if (!pr->throttling.address) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling register\n"));
-		return 0;
-	} else if (!pr->throttling.duty_width) {
-		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "No throttling states\n"));
-		return 0;
-	}
-	/* TBD: Support duty_cycle values that span bit 4. */
-	else if ((pr->throttling.duty_offset + pr->throttling.duty_width) > 4) {
-		printk(KERN_WARNING PREFIX "duty_cycle spans bit 4\n");
-		return 0;
-	}
-
@@ -603,15 +803,0 @@
-	pr->throttling.state_count = 1 << acpi_gbl_FADT.duty_width;
-
-	/*
-	 * Compute state values. Note that throttling displays a linear power/
-	 * performance relationship (at 50% performance the CPU will consume
-	 * 50% power).  Values are in 1/10th of a percent to preserve accuracy.
-	 */
-
-	step = (1000 / pr->throttling.state_count);
-
-	for (i = 0; i < pr->throttling.state_count; i++) {
-		pr->throttling.states[i].performance = step * i;
-		pr->throttling.states[i].power = step * i;
-	}
-
--- ./projects/linux/linux-2.6.24/drivers/acpi/processor_throttling.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/acpi/processor_throttling.c	2008-04-17 04:49:44.000000000 +0200
@@ -47,0 +48,8 @@
+struct throttling_tstate {
+	unsigned int cpu;		/* cpu nr */
+	int target_state;		/* target T-state */
+};
+
+#define THROTTLING_PRECHANGE       (1)
+#define THROTTLING_POSTCHANGE      (2)
+
@@ -50,0 +59,212 @@
+static int acpi_processor_update_tsd_coord(void)
+{
+	int count, count_target;
+	int retval = 0;
+	unsigned int i, j;
+	cpumask_t covered_cpus;
+	struct acpi_processor *pr, *match_pr;
+	struct acpi_tsd_package *pdomain, *match_pdomain;
+	struct acpi_processor_throttling *pthrottling, *match_pthrottling;
+
+	/*
+	 * Now that we have _TSD data from all CPUs, lets setup T-state
+	 * coordination between all CPUs.
+	 */
+	for_each_possible_cpu(i) {
+		pr = processors[i];
+		if (!pr)
+			continue;
+
+		/* Basic validity check for domain info */
+		pthrottling = &(pr->throttling);
+
+		/*
+		 * If tsd package for one cpu is invalid, the coordination
+		 * among all CPUs is thought as invalid.
+		 * Maybe it is ugly.
+		 */
+		if (!pthrottling->tsd_valid_flag) {
+			retval = -EINVAL;
+			break;
+		}
+	}
+	if (retval)
+		goto err_ret;
+
+	cpus_clear(covered_cpus);
+	for_each_possible_cpu(i) {
+		pr = processors[i];
+		if (!pr)
+			continue;
+
+		if (cpu_isset(i, covered_cpus))
+			continue;
+		pthrottling = &pr->throttling;
+
+		pdomain = &(pthrottling->domain_info);
+		cpu_set(i, pthrottling->shared_cpu_map);
+		cpu_set(i, covered_cpus);
+		/*
+		 * If the number of processor in the TSD domain is 1, it is
+		 * unnecessary to parse the coordination for this CPU.
+		 */
+		if (pdomain->num_processors <= 1)
+			continue;
+
+		/* Validate the Domain info */
+		count_target = pdomain->num_processors;
+		count = 1;
+
+		for_each_possible_cpu(j) {
+			if (i == j)
+				continue;
+
+			match_pr = processors[j];
+			if (!match_pr)
+				continue;
+
+			match_pthrottling = &(match_pr->throttling);
+			match_pdomain = &(match_pthrottling->domain_info);
+			if (match_pdomain->domain != pdomain->domain)
+				continue;
+
+			/* Here i and j are in the same domain.
+			 * If two TSD packages have the same domain, they
+			 * should have the same num_porcessors and
+			 * coordination type. Otherwise it will be regarded
+			 * as illegal.
+			 */
+			if (match_pdomain->num_processors != count_target) {
+				retval = -EINVAL;
+				goto err_ret;
+			}
+
+			if (pdomain->coord_type != match_pdomain->coord_type) {
+				retval = -EINVAL;
+				goto err_ret;
+			}
+
+			cpu_set(j, covered_cpus);
+			cpu_set(j, pthrottling->shared_cpu_map);
+			count++;
+		}
+		for_each_possible_cpu(j) {
+			if (i == j)
+				continue;
+
+			match_pr = processors[j];
+			if (!match_pr)
+				continue;
+
+			match_pthrottling = &(match_pr->throttling);
+			match_pdomain = &(match_pthrottling->domain_info);
+			if (match_pdomain->domain != pdomain->domain)
+				continue;
+
+			/*
+			 * If some CPUS have the same domain, they
+			 * will have the same shared_cpu_map.
+			 */
+			match_pthrottling->shared_cpu_map =
+				pthrottling->shared_cpu_map;
+		}
+	}
+
+err_ret:
+	for_each_possible_cpu(i) {
+		pr = processors[i];
+		if (!pr)
+			continue;
+
+		/*
+		 * Assume no coordination on any error parsing domain info.
+		 * The coordination type will be forced as SW_ALL.
+		 */
+		if (retval) {
+			pthrottling = &(pr->throttling);
+			cpus_clear(pthrottling->shared_cpu_map);
+			cpu_set(i, pthrottling->shared_cpu_map);
+			pthrottling->shared_type = DOMAIN_COORD_TYPE_SW_ALL;
+		}
+	}
+
+	return retval;
+}
+
+/*
+ * Update the T-state coordination after the _TSD
+ * data for all cpus is obtained.
+ */
+void acpi_processor_throttling_init(void)
+{
+	if (acpi_processor_update_tsd_coord())
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+			"Assume no T-state coordination\n"));
+
+	return;
+}
+
+static int acpi_processor_throttling_notifier(unsigned long event, void *data)
+{
+	struct throttling_tstate *p_tstate = data;
+	struct acpi_processor *pr;
+	unsigned int cpu ;
+	int target_state;
+	struct acpi_processor_limit *p_limit;
+	struct acpi_processor_throttling *p_throttling;
+
+	cpu = p_tstate->cpu;
+	pr = processors[cpu];
+	if (!pr) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Invalid pr pointer\n"));
+		return 0;
+	}
+	if (!pr->flags.throttling) {
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "Throttling control is "
+				"unsupported on CPU %d\n", cpu));
+		return 0;
+	}
+	target_state = p_tstate->target_state;
+	p_throttling = &(pr->throttling);
+	switch (event) {
+	case THROTTLING_PRECHANGE:
+		/*
+		 * Prechange event is used to choose one proper t-state,
+		 * which meets the limits of thermal, user and _TPC.
+		 */
+		p_limit = &pr->limit;
+		if (p_limit->thermal.tx > target_state)
+			target_state = p_limit->thermal.tx;
+		if (p_limit->user.tx > target_state)
+			target_state = p_limit->user.tx;
+		if (pr->throttling_platform_limit > target_state)
+			target_state = pr->throttling_platform_limit;
+		if (target_state >= p_throttling->state_count) {
+			printk(KERN_WARNING
+				"Exceed the limit of T-state \n");
+			target_state = p_throttling->state_count - 1;
+		}
+		p_tstate->target_state = target_state;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "PreChange Event:"
+				"target T-state of CPU %d is T%d\n",
+				cpu, target_state));
+		break;
+	case THROTTLING_POSTCHANGE:
+		/*
+		 * Postchange event is only used to update the
+		 * T-state flag of acpi_processor_throttling.
+		 */
+		p_throttling->state = target_state;
+		ACPI_DEBUG_PRINT((ACPI_DB_INFO, "PostChange Event:"
+				"CPU %d is switched to T%d\n",
+				cpu, target_state));
+		break;
+	default:
+		printk(KERN_WARNING
+			"Unsupported Throttling notifier event\n");
+		break;
+	}
+
+	return 0;
+}
+
@@ -295,0 +516,4 @@
+	struct acpi_processor_throttling *pthrottling;
+
+	pthrottling = &pr->throttling;
+	pthrottling->tsd_valid_flag = 0;
@@ -342,0 +567,16 @@
+	pthrottling = &pr->throttling;
+	pthrottling->tsd_valid_flag = 1;
+	pthrottling->shared_type = pdomain->coord_type;
+	cpu_set(pr->id, pthrottling->shared_cpu_map);
+	/*
+	 * If the coordination type is not defined in ACPI spec,
+	 * the tsd_valid_flag will be clear and coordination type
+	 * will be forecd as DOMAIN_COORD_TYPE_SW_ALL.
+	 */
+	if (pdomain->coord_type != DOMAIN_COORD_TYPE_SW_ALL &&
+		pdomain->coord_type != DOMAIN_COORD_TYPE_SW_ANY &&
+		pdomain->coord_type != DOMAIN_COORD_TYPE_HW_ALL) {
+		pthrottling->tsd_valid_flag = 0;
+		pthrottling->shared_type = DOMAIN_COORD_TYPE_SW_ALL;
+	}
+
@@ -591,0 +832,5 @@
+	if (!pr)
+		return -EINVAL;
+
+	if (!pr->flags.throttling)
+		return -ENODEV;
@@ -745 +990,21 @@
-	int ret;
+	int ret = 0;
+	unsigned int i;
+	struct acpi_processor *match_pr;
+	struct acpi_processor_throttling *p_throttling;
+	struct throttling_tstate t_state;
+	cpumask_t online_throttling_cpus;
+
+	if (!pr)
+		return -EINVAL;
+
+	if (!pr->flags.throttling)
+		return -ENODEV;
+
+	if ((state < 0) || (state > (pr->throttling.state_count - 1)))
+		return -EINVAL;
+
+	saved_mask = current->cpus_allowed;
+	t_state.target_state = state;
+	p_throttling = &(pr->throttling);
+	cpus_and(online_throttling_cpus, cpu_online_map,
+			p_throttling->shared_cpu_map);
@@ -747 +1012,3 @@
-	 * Migrate task to the cpu pointed by pr.
+	 * The throttling notifier will be called for every
+	 * affected cpu in order to get one proper T-state.
+	 * The notifier event is THROTTLING_PRECHANGE.
@@ -749,3 +1016,60 @@
-	saved_mask = current->cpus_allowed;
-	set_cpus_allowed(current, cpumask_of_cpu(pr->id));
-	ret = pr->throttling.acpi_processor_set_throttling(pr, state);
+	for_each_cpu_mask(i, online_throttling_cpus) {
+		t_state.cpu = i;
+		acpi_processor_throttling_notifier(THROTTLING_PRECHANGE,
+							&t_state);
+	}
+	/*
+	 * The function of acpi_processor_set_throttling will be called
+	 * to switch T-state. If the coordination type is SW_ALL or HW_ALL,
+	 * it is necessary to call it for every affected cpu. Otherwise
+	 * it can be called only for the cpu pointed by pr.
+	 */
+	if (p_throttling->shared_type == DOMAIN_COORD_TYPE_SW_ANY) {
+		set_cpus_allowed(current, cpumask_of_cpu(pr->id));
+		ret = p_throttling->acpi_processor_set_throttling(pr,
+						t_state.target_state);
+	} else {
+		/*
+		 * When the T-state coordination is SW_ALL or HW_ALL,
+		 * it is necessary to set T-state for every affected
+		 * cpus.
+		 */
+		for_each_cpu_mask(i, online_throttling_cpus) {
+			match_pr = processors[i];
+			/*
+			 * If the pointer is invalid, we will report the
+			 * error message and continue.
+			 */
+			if (!match_pr) {
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					"Invalid Pointer for CPU %d\n", i));
+				continue;
+			}
+			/*
+			 * If the throttling control is unsupported on CPU i,
+			 * we will report the error message and continue.
+			 */
+			if (!match_pr->flags.throttling) {
+				ACPI_DEBUG_PRINT((ACPI_DB_INFO,
+					"Throttling Controll is unsupported "
+					"on CPU %d\n", i));
+				continue;
+			}
+			t_state.cpu = i;
+			set_cpus_allowed(current, cpumask_of_cpu(i));
+			ret = match_pr->throttling.
+				acpi_processor_set_throttling(
+				match_pr, t_state.target_state);
+		}
+	}
+	/*
+	 * After the set_throttling is called, the
+	 * throttling notifier is called for every
+	 * affected cpu to update the T-states.
+	 * The notifier event is THROTTLING_POSTCHANGE
+	 */
+	for_each_cpu_mask(i, online_throttling_cpus) {
+		t_state.cpu = i;
+		acpi_processor_throttling_notifier(THROTTLING_POSTCHANGE,
+							&t_state);
+	}
@@ -759,0 +1084 @@
+	struct acpi_processor_throttling *pthrottling;
@@ -791 +1116,10 @@
-	acpi_processor_get_tsd(pr);
+	/*
+	 * If TSD package for one CPU can't be parsed successfully, it means
+	 * that this CPU will have no coordination with other CPUs.
+	 */
+	if (acpi_processor_get_tsd(pr)) {
+		pthrottling = &pr->throttling;
+		pthrottling->tsd_valid_flag = 0;
+		cpu_set(pr->id, pthrottling->shared_cpu_map);
+		pthrottling->shared_type = DOMAIN_COORD_TYPE_SW_ALL;
+	}
--- ./projects/linux/linux-2.6.25/drivers/acpi/processor_throttling.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/acpi/processor_throttling.c	2008-07-13 23:51:29.000000000 +0200
@@ -841 +841 @@
-	set_cpus_allowed(current, cpumask_of_cpu(pr->id));
+	set_cpus_allowed_ptr(current, &cpumask_of_cpu(pr->id));
@@ -844 +844 @@
-	set_cpus_allowed(current, saved_mask);
+	set_cpus_allowed_ptr(current, &saved_mask);
@@ -1028 +1028 @@
-		set_cpus_allowed(current, cpumask_of_cpu(pr->id));
+		set_cpus_allowed_ptr(current, &cpumask_of_cpu(pr->id));
@@ -1059 +1059 @@
-			set_cpus_allowed(current, cpumask_of_cpu(i));
+			set_cpus_allowed_ptr(current, &cpumask_of_cpu(i));
@@ -1077 +1077 @@
-	set_cpus_allowed(current, saved_mask);
+	set_cpus_allowed_ptr(current, &saved_mask);
@@ -1254,0 +1255 @@
+	.owner = THIS_MODULE,
--- ./projects/linux/linux-2.6.26/drivers/acpi/processor_throttling.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/acpi/processor_throttling.c	2008-10-10 00:13:53.000000000 +0200
@@ -74 +74 @@
-		pr = processors[i];
+		pr = per_cpu(processors, i);
@@ -96 +96 @@
-		pr = processors[i];
+		pr = per_cpu(processors, i);
@@ -122 +122 @@
-			match_pr = processors[j];
+			match_pr = per_cpu(processors, j);
@@ -155 +155 @@
-			match_pr = processors[j];
+			match_pr = per_cpu(processors, j);
@@ -175 +175 @@
-		pr = processors[i];
+		pr = per_cpu(processors, i);
@@ -217 +217 @@
-	pr = processors[cpu];
+	pr = per_cpu(processors, cpu);
@@ -1016 +1016 @@
-	for_each_cpu_mask(i, online_throttling_cpus) {
+	for_each_cpu_mask_nr(i, online_throttling_cpus) {
@@ -1037,2 +1037,2 @@
-		for_each_cpu_mask(i, online_throttling_cpus) {
-			match_pr = processors[i];
+		for_each_cpu_mask_nr(i, online_throttling_cpus) {
+			match_pr = per_cpu(processors, i);
@@ -1071 +1071 @@
-	for_each_cpu_mask(i, online_throttling_cpus) {
+	for_each_cpu_mask_nr(i, online_throttling_cpus) {
@@ -1235 +1235,4 @@
-	char state_string[12] = { '\0' };
+	char state_string[5] = "";
+	char *charp = NULL;
+	size_t state_val = 0;
+	char tmpbuf[5] = "";
@@ -1243,0 +1247,2 @@
+	if ((count > 0) && (state_string[count-1] == '\n'))
+		state_string[count-1] = '\0';
@@ -1245,3 +1250,14 @@
-	result = acpi_processor_set_throttling(pr,
-					       simple_strtoul(state_string,
-							      NULL, 0));
+	charp = state_string;
+	if ((state_string[0] == 't') || (state_string[0] == 'T'))
+		charp++;
+
+	state_val = simple_strtoul(charp, NULL, 0);
+	if (state_val >= pr->throttling.state_count)
+		return -EINVAL;
+
+	snprintf(tmpbuf, 5, "%zu", state_val);
+
+	if (strcmp(tmpbuf, charp) != 0)
+		return -EINVAL;
+
+	result = acpi_processor_set_throttling(pr, state_val);
--- ./projects/linux/linux-2.6.27/drivers/acpi/processor_throttling.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/acpi/processor_throttling.c	2008-12-25 00:26:37.000000000 +0100
@@ -40,0 +41 @@
+#include <acpi/acpi_drivers.h>
@@ -43 +43,0 @@
-#define ACPI_PROCESSOR_COMPONENT        0x01000000
@@ -277 +277 @@
-	unsigned long tpc = 0;
+	unsigned long long tpc = 0;
@@ -531 +531 @@
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _TSD data\n"));
+		printk(KERN_ERR PREFIX "Invalid _TSD data\n");
@@ -537 +537 @@
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _TSD data\n"));
+		printk(KERN_ERR PREFIX "Invalid _TSD data\n");
@@ -550 +550 @@
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Invalid _TSD data\n"));
+		printk(KERN_ERR PREFIX "Invalid _TSD data\n");
@@ -556 +556 @@
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unknown _TSD:num_entries\n"));
+		printk(KERN_ERR PREFIX "Unknown _TSD:num_entries\n");
@@ -562 +562 @@
-		ACPI_DEBUG_PRINT((ACPI_DB_ERROR, "Unknown _TSD:revision\n"));
+		printk(KERN_ERR PREFIX "Unknown _TSD:revision\n");
--- ./projects/linux/linux-2.6.28/drivers/acpi/processor_throttling.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/acpi/processor_throttling.c	2009-03-24 00:12:14.000000000 +0100
@@ -64 +64 @@
-	cpumask_t covered_cpus;
+	cpumask_var_t covered_cpus;
@@ -68,0 +69,3 @@
+	if (!alloc_cpumask_var(&covered_cpus, GFP_KERNEL))
+		return -ENOMEM;
+
@@ -94 +97 @@
-	cpus_clear(covered_cpus);
+	cpumask_clear(covered_cpus);
@@ -100 +103 @@
-		if (cpu_isset(i, covered_cpus))
+		if (cpumask_test_cpu(i, covered_cpus))
@@ -105,2 +108,2 @@
-		cpu_set(i, pthrottling->shared_cpu_map);
-		cpu_set(i, covered_cpus);
+		cpumask_set_cpu(i, pthrottling->shared_cpu_map);
+		cpumask_set_cpu(i, covered_cpus);
@@ -147,2 +150,2 @@
-			cpu_set(j, covered_cpus);
-			cpu_set(j, pthrottling->shared_cpu_map);
+			cpumask_set_cpu(j, covered_cpus);
+			cpumask_set_cpu(j, pthrottling->shared_cpu_map);
@@ -168,2 +171,2 @@
-			match_pthrottling->shared_cpu_map =
-				pthrottling->shared_cpu_map;
+			cpumask_copy(match_pthrottling->shared_cpu_map,
+				     pthrottling->shared_cpu_map);
@@ -173,0 +177,2 @@
+	free_cpumask_var(covered_cpus);
+
@@ -185,2 +190,2 @@
-			cpus_clear(pthrottling->shared_cpu_map);
-			cpu_set(i, pthrottling->shared_cpu_map);
+			cpumask_clear(pthrottling->shared_cpu_map);
+			cpumask_set_cpu(i, pthrottling->shared_cpu_map);
@@ -570 +575 @@
-	cpu_set(pr->id, pthrottling->shared_cpu_map);
+	cpumask_set_cpu(pr->id, pthrottling->shared_cpu_map);
@@ -829 +834 @@
-	cpumask_t saved_mask;
+	cpumask_var_t saved_mask;
@@ -836,0 +842,4 @@
+
+	if (!alloc_cpumask_var(&saved_mask, GFP_KERNEL))
+		return -ENOMEM;
+
@@ -840,2 +849,3 @@
-	saved_mask = current->cpus_allowed;
-	set_cpus_allowed_ptr(current, &cpumask_of_cpu(pr->id));
+	cpumask_copy(saved_mask, &current->cpus_allowed);
+	/* FIXME: use work_on_cpu() */
+	set_cpus_allowed_ptr(current, cpumask_of(pr->id));
@@ -844 +854,2 @@
-	set_cpus_allowed_ptr(current, &saved_mask);
+	set_cpus_allowed_ptr(current, saved_mask);
+	free_cpumask_var(saved_mask);
@@ -989 +1000 @@
-	cpumask_t saved_mask;
+	cpumask_var_t saved_mask;
@@ -995 +1006 @@
-	cpumask_t online_throttling_cpus;
+	cpumask_var_t online_throttling_cpus;
@@ -1006 +1017,9 @@
-	saved_mask = current->cpus_allowed;
+	if (!alloc_cpumask_var(&saved_mask, GFP_KERNEL))
+		return -ENOMEM;
+
+	if (!alloc_cpumask_var(&online_throttling_cpus, GFP_KERNEL)) {
+		free_cpumask_var(saved_mask);
+		return -ENOMEM;
+	}
+
+	cpumask_copy(saved_mask, &current->cpus_allowed);
@@ -1009,2 +1028,2 @@
-	cpus_and(online_throttling_cpus, cpu_online_map,
-			p_throttling->shared_cpu_map);
+	cpumask_and(online_throttling_cpus, cpu_online_mask,
+		    p_throttling->shared_cpu_map);
@@ -1016 +1035 @@
-	for_each_cpu_mask_nr(i, online_throttling_cpus) {
+	for_each_cpu(i, online_throttling_cpus) {
@@ -1028 +1047,2 @@
-		set_cpus_allowed_ptr(current, &cpumask_of_cpu(pr->id));
+		/* FIXME: use work_on_cpu() */
+		set_cpus_allowed_ptr(current, cpumask_of(pr->id));
@@ -1037 +1057 @@
-		for_each_cpu_mask_nr(i, online_throttling_cpus) {
+		for_each_cpu(i, online_throttling_cpus) {
@@ -1059 +1079,2 @@
-			set_cpus_allowed_ptr(current, &cpumask_of_cpu(i));
+			/* FIXME: use work_on_cpu() */
+			set_cpus_allowed_ptr(current, cpumask_of(i));
@@ -1071 +1092 @@
-	for_each_cpu_mask_nr(i, online_throttling_cpus) {
+	for_each_cpu(i, online_throttling_cpus) {
@@ -1077 +1098,4 @@
-	set_cpus_allowed_ptr(current, &saved_mask);
+	/* FIXME: use work_on_cpu() */
+	set_cpus_allowed_ptr(current, saved_mask);
+	free_cpumask_var(online_throttling_cpus);
+	free_cpumask_var(saved_mask);
@@ -1123 +1147 @@
-		cpu_set(pr->id, pthrottling->shared_cpu_map);
+		cpumask_set_cpu(pr->id, pthrottling->shared_cpu_map);
--- ./projects/linux/linux-2.6.29/drivers/acpi/processor_throttling.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/acpi/processor_throttling.c	2009-06-27 11:32:32.000000000 +0200
@@ -47,0 +48,8 @@
+/* ignore_tpc:
+ *  0 -> acpi processor driver doesn't ignore _TPC values
+ *  1 -> acpi processor driver ignores _TPC values
+ */
+static int ignore_tpc;
+module_param(ignore_tpc, int, 0644);
+MODULE_PARM_DESC(ignore_tpc, "Disable broken BIOS _TPC throttling support");
+
@@ -285,0 +294,4 @@
+
+	if (ignore_tpc)
+		goto end;
+
@@ -292,0 +305,2 @@
+
+end:
@@ -304,0 +319,3 @@
+	if (ignore_tpc)
+		return 0;
+
@@ -786 +803 @@
-			break;
+			return i;
@@ -788,3 +805 @@
-	if (i > pr->throttling.state_count)
-		i = -1;
-	return i;
+	return -1;
@@ -825,0 +841,8 @@
+		if (state == -1) {
+			ACPI_WARNING((AE_INFO,
+				"Invalid throttling state, reset"));
+			state = 0;
+			ret = acpi_processor_set_throttling(pr, state);
+			if (ret)
+				return ret;
+		}
@@ -1294 +1317 @@
-struct file_operations acpi_processor_throttling_fops = {
+const struct file_operations acpi_processor_throttling_fops = {
--- ./projects/linux/linux-2.6.19/drivers/ata/libata-core.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/ata/libata-core.c	2007-02-04 19:44:54.000000000 +0100
@@ -202 +202,2 @@
- *	@qc: command to examine and configure
+ *	@tf: command to examine and configure
+ *	@dev: device tf belongs to
@@ -210 +211 @@
-int ata_rwcmd_protocol(struct ata_queued_cmd *qc)
+static int ata_rwcmd_protocol(struct ata_taskfile *tf, struct ata_device *dev)
@@ -212,2 +212,0 @@
-	struct ata_taskfile *tf = &qc->tf;
-	struct ata_device *dev = qc->dev;
@@ -225 +224 @@
-	} else if (lba48 && (qc->ap->flags & ATA_FLAG_PIO_LBA48)) {
+	} else if (lba48 && (dev->ap->flags & ATA_FLAG_PIO_LBA48)) {
@@ -242,0 +242,168 @@
+ *	ata_tf_read_block - Read block address from ATA taskfile
+ *	@tf: ATA taskfile of interest
+ *	@dev: ATA device @tf belongs to
+ *
+ *	LOCKING:
+ *	None.
+ *
+ *	Read block address from @tf.  This function can handle all
+ *	three address formats - LBA, LBA48 and CHS.  tf->protocol and
+ *	flags select the address format to use.
+ *
+ *	RETURNS:
+ *	Block address read from @tf.
+ */
+u64 ata_tf_read_block(struct ata_taskfile *tf, struct ata_device *dev)
+{
+	u64 block = 0;
+
+	if (tf->flags & ATA_TFLAG_LBA) {
+		if (tf->flags & ATA_TFLAG_LBA48) {
+			block |= (u64)tf->hob_lbah << 40;
+			block |= (u64)tf->hob_lbam << 32;
+			block |= tf->hob_lbal << 24;
+		} else
+			block |= (tf->device & 0xf) << 24;
+
+		block |= tf->lbah << 16;
+		block |= tf->lbam << 8;
+		block |= tf->lbal;
+	} else {
+		u32 cyl, head, sect;
+
+		cyl = tf->lbam | (tf->lbah << 8);
+		head = tf->device & 0xf;
+		sect = tf->lbal;
+
+		block = (cyl * dev->heads + head) * dev->sectors + sect;
+	}
+
+	return block;
+}
+
+/**
+ *	ata_build_rw_tf - Build ATA taskfile for given read/write request
+ *	@tf: Target ATA taskfile
+ *	@dev: ATA device @tf belongs to
+ *	@block: Block address
+ *	@n_block: Number of blocks
+ *	@tf_flags: RW/FUA etc...
+ *	@tag: tag
+ *
+ *	LOCKING:
+ *	None.
+ *
+ *	Build ATA taskfile @tf for read/write request described by
+ *	@block, @n_block, @tf_flags and @tag on @dev.
+ *
+ *	RETURNS:
+ *
+ *	0 on success, -ERANGE if the request is too large for @dev,
+ *	-EINVAL if the request is invalid.
+ */
+int ata_build_rw_tf(struct ata_taskfile *tf, struct ata_device *dev,
+		    u64 block, u32 n_block, unsigned int tf_flags,
+		    unsigned int tag)
+{
+	tf->flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;
+	tf->flags |= tf_flags;
+
+	if ((dev->flags & (ATA_DFLAG_PIO | ATA_DFLAG_NCQ_OFF |
+			   ATA_DFLAG_NCQ)) == ATA_DFLAG_NCQ &&
+	    likely(tag != ATA_TAG_INTERNAL)) {
+		/* yay, NCQ */
+		if (!lba_48_ok(block, n_block))
+			return -ERANGE;
+
+		tf->protocol = ATA_PROT_NCQ;
+		tf->flags |= ATA_TFLAG_LBA | ATA_TFLAG_LBA48;
+
+		if (tf->flags & ATA_TFLAG_WRITE)
+			tf->command = ATA_CMD_FPDMA_WRITE;
+		else
+			tf->command = ATA_CMD_FPDMA_READ;
+
+		tf->nsect = tag << 3;
+		tf->hob_feature = (n_block >> 8) & 0xff;
+		tf->feature = n_block & 0xff;
+
+		tf->hob_lbah = (block >> 40) & 0xff;
+		tf->hob_lbam = (block >> 32) & 0xff;
+		tf->hob_lbal = (block >> 24) & 0xff;
+		tf->lbah = (block >> 16) & 0xff;
+		tf->lbam = (block >> 8) & 0xff;
+		tf->lbal = block & 0xff;
+
+		tf->device = 1 << 6;
+		if (tf->flags & ATA_TFLAG_FUA)
+			tf->device |= 1 << 7;
+	} else if (dev->flags & ATA_DFLAG_LBA) {
+		tf->flags |= ATA_TFLAG_LBA;
+
+		if (lba_28_ok(block, n_block)) {
+			/* use LBA28 */
+			tf->device |= (block >> 24) & 0xf;
+		} else if (lba_48_ok(block, n_block)) {
+			if (!(dev->flags & ATA_DFLAG_LBA48))
+				return -ERANGE;
+
+			/* use LBA48 */
+			tf->flags |= ATA_TFLAG_LBA48;
+
+			tf->hob_nsect = (n_block >> 8) & 0xff;
+
+			tf->hob_lbah = (block >> 40) & 0xff;
+			tf->hob_lbam = (block >> 32) & 0xff;
+			tf->hob_lbal = (block >> 24) & 0xff;
+		} else
+			/* request too large even for LBA48 */
+			return -ERANGE;
+
+		if (unlikely(ata_rwcmd_protocol(tf, dev) < 0))
+			return -EINVAL;
+
+		tf->nsect = n_block & 0xff;
+
+		tf->lbah = (block >> 16) & 0xff;
+		tf->lbam = (block >> 8) & 0xff;
+		tf->lbal = block & 0xff;
+
+		tf->device |= ATA_LBA;
+	} else {
+		/* CHS */
+		u32 sect, head, cyl, track;
+
+		/* The request -may- be too large for CHS addressing. */
+		if (!lba_28_ok(block, n_block))
+			return -ERANGE;
+
+		if (unlikely(ata_rwcmd_protocol(tf, dev) < 0))
+			return -EINVAL;
+
+		/* Convert LBA to CHS */
+		track = (u32)block / dev->sectors;
+		cyl   = track / dev->heads;
+		head  = track % dev->heads;
+		sect  = (u32)block % dev->sectors + 1;
+
+		DPRINTK("block %u track %u cyl %u head %u sect %u\n",
+			(u32)block, track, cyl, head, sect);
+
+		/* Check whether the converted CHS can fit.
+		   Cylinder: 0-65535
+		   Head: 0-15
+		   Sector: 1-255*/
+		if ((cyl >> 16) || (head >> 4) || (sect >> 8) || (!sect))
+			return -ERANGE;
+
+		tf->nsect = n_block & 0xff; /* Sector count 0 means 256 sectors */
+		tf->lbal = sect;
+		tf->lbam = cyl;
+		tf->lbah = cyl >> 8;
+		tf->device |= head;
+	}
+
+	return 0;
+}
+
+/**
@@ -873 +1040 @@
-		u8 mode = id[ATA_ID_OLD_PIO_MODES] & 0xFF;
+		u8 mode = (id[ATA_ID_OLD_PIO_MODES] >> 8) & 0xFF;
@@ -917 +1084 @@
- *	@data: data value to pass to workqueue function
+ *	@data: data for @fn to use
@@ -932 +1099 @@
-void ata_port_queue_task(struct ata_port *ap, void (*fn)(void *), void *data,
+void ata_port_queue_task(struct ata_port *ap, work_func_t fn, void *data,
@@ -940 +1107,2 @@
-	PREPARE_WORK(&ap->port_task, fn, data);
+	PREPARE_DELAYED_WORK(&ap->port_task, fn);
+	ap->port_task_data = data;
@@ -942,4 +1110 @@
-	if (!delay)
-		rc = queue_work(ata_wq, &ap->port_task);
-	else
-		rc = queue_delayed_work(ata_wq, &ap->port_task, delay);
+	rc = queue_delayed_work(ata_wq, &ap->port_task, delay);
@@ -1002 +1167 @@
- *	ata_exec_internal - execute libata internal command
+ *	ata_exec_internal_sg - execute libata internal command
@@ -1007,2 +1172,2 @@
- *	@buf: Data buffer of the command
- *	@buflen: Length of data buffer
+ *	@sg: sg list for the data buffer of the command
+ *	@n_elem: Number of sg entries
@@ -1022,3 +1187,4 @@
-unsigned ata_exec_internal(struct ata_device *dev,
-			   struct ata_taskfile *tf, const u8 *cdb,
-			   int dma_dir, void *buf, unsigned int buflen)
+unsigned ata_exec_internal_sg(struct ata_device *dev,
+			      struct ata_taskfile *tf, const u8 *cdb,
+			      int dma_dir, struct scatterlist *sg,
+			      unsigned int n_elem)
@@ -1080 +1246,6 @@
-		ata_sg_init_one(qc, buf, buflen);
+		unsigned int i, buflen = 0;
+
+		for (i = 0; i < n_elem; i++)
+			buflen += sg[i].length;
+
+		ata_sg_init(qc, sg, n_elem);
@@ -1081,0 +1253 @@
+		qc->nbytes = buflen;
@@ -1163,0 +1336,35 @@
+ *	ata_exec_internal - execute libata internal command
+ *	@dev: Device to which the command is sent
+ *	@tf: Taskfile registers for the command and the result
+ *	@cdb: CDB for packet command
+ *	@dma_dir: Data tranfer direction of the command
+ *	@buf: Data buffer of the command
+ *	@buflen: Length of data buffer
+ *
+ *	Wrapper around ata_exec_internal_sg() which takes simple
+ *	buffer instead of sg list.
+ *
+ *	LOCKING:
+ *	None.  Should be called with kernel context, might sleep.
+ *
+ *	RETURNS:
+ *	Zero on success, AC_ERR_* mask on failure
+ */
+unsigned ata_exec_internal(struct ata_device *dev,
+			   struct ata_taskfile *tf, const u8 *cdb,
+			   int dma_dir, void *buf, unsigned int buflen)
+{
+	struct scatterlist *psg = NULL, sg;
+	unsigned int n_elem = 0;
+
+	if (dma_dir != DMA_NONE) {
+		WARN_ON(!buf);
+		sg_init_one(&sg, buf, buflen);
+		psg = &sg;
+		n_elem++;
+	}
+
+	return ata_exec_internal_sg(dev, tf, cdb, dma_dir, psg, n_elem);
+}
+
+/**
@@ -1227 +1434 @@
- *	@post_reset: is this read ID post-reset?
+ *	@flags: ATA_READID_* flags
@@ -1242 +1449 @@
-		    int post_reset, u16 *id)
+		    unsigned int flags, u16 *id)
@@ -1273,0 +1481 @@
+	tf.flags |= ATA_TFLAG_POLLING; /* for polling presence detection */
@@ -1277,0 +1486,6 @@
+		if (err_mask & AC_ERR_NODEV_HINT) {
+			DPRINTK("ata%u.%d: NODEV after polling detection\n",
+				ap->id, dev->devno);
+			return -ENOENT;
+		}
+
@@ -1297 +1511 @@
-	if (post_reset && class == ATA_DEV_ATA) {
+	if ((flags & ATA_READID_POSTRESET) && class == ATA_DEV_ATA) {
@@ -1317 +1531 @@
-			post_reset = 0;
+			flags &= ~ATA_READID_POSTRESET;
@@ -1348 +1562,4 @@
-
+	if (ata_device_blacklisted(dev) & ATA_HORKAGE_NONCQ) {
+		snprintf(desc, desc_sz, "NCQ (not used)");
+		return;
+	}
@@ -1377 +1593,0 @@
- *	@print_info: Enable device info printout
@@ -1388 +1604 @@
-int ata_dev_configure(struct ata_device *dev, int print_info)
+int ata_dev_configure(struct ata_device *dev)
@@ -1390,0 +1607 @@
+	int print_info = ap->eh_context.i.flags & ATA_EHI_PRINTINFO;
@@ -1456,0 +1674,4 @@
+
+				if (dev->n_sectors >= (1UL << 28) &&
+				    ata_id_has_flush_ext(id))
+					dev->flags |= ATA_DFLAG_FLUSH_EXT;
@@ -1532,0 +1754,5 @@
+	/* determine max_sectors */
+	dev->max_sectors = ATA_MAX_SECTORS;
+	if (dev->flags & ATA_DFLAG_LBA48)
+		dev->max_sectors = ATA_MAX_SECTORS_LBA48;
+
@@ -1634 +1860,2 @@
-		rc = ata_dev_read_id(dev, &dev->class, 1, dev->id);
+		rc = ata_dev_read_id(dev, &dev->class, ATA_READID_POSTRESET,
+				     dev->id);
@@ -1638 +1865,3 @@
-		rc = ata_dev_configure(dev, 1);
+		ap->eh_context.i.flags |= ATA_EHI_PRINTINFO;
+		rc = ata_dev_configure(dev);
+		ap->eh_context.i.flags &= ~ATA_EHI_PRINTINFO;
@@ -2084 +2313 @@
-	if (speed > XFER_PIO_4) {
+	if (speed > XFER_PIO_6) {
@@ -2155,0 +2385 @@
+	struct ata_eh_context *ehc = &dev->ap->eh_context;
@@ -2169,0 +2400 @@
+	ehc->i.flags |= ATA_EHI_POST_SETMODE;
@@ -2170,0 +2402 @@
+	ehc->i.flags &= ~ATA_EHI_POST_SETMODE;
@@ -2203,12 +2435,2 @@
-	if (ap->ops->set_mode) {
-		/* FIXME: make ->set_mode handle no device case and
-		 * return error code and failing device on failure.
-		 */
-		for (i = 0; i < ATA_MAX_DEVICES; i++) {
-			if (ata_dev_ready(&ap->device[i])) {
-				ap->ops->set_mode(ap);
-				break;
-			}
-		}
-		return 0;
-	}
+	if (ap->ops->set_mode)
+		return ap->ops->set_mode(ap, r_failed_dev);
@@ -2328 +2550,5 @@
- *	LOCKING: None.
+ *	LOCKING:
+ *	Kernel thread context (may sleep).
+ *
+ *	RETURNS:
+ *	0 on success, -errno otherwise.
@@ -2330,3 +2556,2 @@
-
-unsigned int ata_busy_sleep (struct ata_port *ap,
-			     unsigned long tmout_pat, unsigned long tmout)
+int ata_busy_sleep(struct ata_port *ap,
+		   unsigned long tmout_pat, unsigned long tmout)
@@ -2340 +2565,2 @@
-	while ((status & ATA_BUSY) && (time_before(jiffies, timeout))) {
+	while (status != 0xff && (status & ATA_BUSY) &&
+	       time_before(jiffies, timeout)) {
@@ -2345 +2571 @@
-	if (status & ATA_BUSY)
+	if (status != 0xff && (status & ATA_BUSY))
@@ -2351 +2577,2 @@
-	while ((status & ATA_BUSY) && (time_before(jiffies, timeout))) {
+	while (status != 0xff && (status & ATA_BUSY) &&
+	       time_before(jiffies, timeout)) {
@@ -2355,0 +2583,3 @@
+	if (status == 0xff)
+		return -ENODEV;
+
@@ -2360 +2590 @@
-		return 1;
+		return -EBUSY;
@@ -2451,4 +2681,2 @@
-	if (ata_check_status(ap) == 0xFF) {
-		ata_port_printk(ap, KERN_ERR, "SRST failed (status 0xFF)\n");
-		return AC_ERR_OTHER;
-	}
+	if (ata_check_status(ap) == 0xFF)
+		return 0;
@@ -2780 +3008 @@
- *	sata_std_hardreset - reset host port via SATA phy reset
+ *	sata_port_hardreset - reset port via SATA phy reset
@@ -2782 +3010 @@
- *	@class: resulting class of attached device
+ *	@timing: timing parameters { interval, duratinon, timeout } in msec
@@ -2792 +3020 @@
-int sata_std_hardreset(struct ata_port *ap, unsigned int *class)
+int sata_port_hardreset(struct ata_port *ap, const unsigned long *timing)
@@ -2794,2 +3021,0 @@
-	struct ata_eh_context *ehc = &ap->eh_context;
-	const unsigned long *timing = sata_ehc_deb_timing(ehc);
@@ -2808 +3034 @@
-			return rc;
+			goto out;
@@ -2813 +3039 @@
-			return rc;
+			goto out;
@@ -2820 +3046 @@
-		return rc;
+		goto out;
@@ -2825 +3051 @@
-		return rc;
+		goto out;
@@ -2833 +3059,34 @@
-	sata_phy_resume(ap, timing);
+	rc = sata_phy_resume(ap, timing);
+ out:
+	DPRINTK("EXIT, rc=%d\n", rc);
+	return rc;
+}
+
+/**
+ *	sata_std_hardreset - reset host port via SATA phy reset
+ *	@ap: port to reset
+ *	@class: resulting class of attached device
+ *
+ *	SATA phy-reset host port using DET bits of SControl register,
+ *	wait for !BSY and classify the attached device.
+ *
+ *	LOCKING:
+ *	Kernel thread context (may sleep)
+ *
+ *	RETURNS:
+ *	0 on success, -errno otherwise.
+ */
+int sata_std_hardreset(struct ata_port *ap, unsigned int *class)
+{
+	const unsigned long *timing = sata_ehc_deb_timing(&ap->eh_context);
+	int rc;
+
+	DPRINTK("ENTER\n");
+
+	/* do hardreset */
+	rc = sata_port_hardreset(ap, timing);
+	if (rc) {
+		ata_port_printk(ap, KERN_ERR,
+				"COMRESET failed (errno=%d)\n", rc);
+		return rc;
+	}
@@ -2972 +3231 @@
- *	@post_reset: is this revalidation after reset?
+ *	@readid_flags: read ID flags
@@ -2983 +3242 @@
-int ata_dev_revalidate(struct ata_device *dev, int post_reset)
+int ata_dev_revalidate(struct ata_device *dev, unsigned int readid_flags)
@@ -2995 +3254 @@
-	rc = ata_dev_read_id(dev, &class, post_reset, id);
+	rc = ata_dev_read_id(dev, &class, readid_flags, id);
@@ -3008 +3267 @@
-	rc = ata_dev_configure(dev, 0);
+	rc = ata_dev_configure(dev);
@@ -3017,31 +3276,49 @@
-static const char * const ata_dma_blacklist [] = {
-	"WDC AC11000H", NULL,
-	"WDC AC22100H", NULL,
-	"WDC AC32500H", NULL,
-	"WDC AC33100H", NULL,
-	"WDC AC31600H", NULL,
-	"WDC AC32100H", "24.09P07",
-	"WDC AC23200L", "21.10N21",
-	"Compaq CRD-8241B",  NULL,
-	"CRD-8400B", NULL,
-	"CRD-8480B", NULL,
-	"CRD-8482B", NULL,
- 	"CRD-84", NULL,
-	"SanDisk SDP3B", NULL,
-	"SanDisk SDP3B-64", NULL,
-	"SANYO CD-ROM CRD", NULL,
-	"HITACHI CDR-8", NULL,
-	"HITACHI CDR-8335", NULL,
-	"HITACHI CDR-8435", NULL,
-	"Toshiba CD-ROM XM-6202B", NULL,
-	"TOSHIBA CD-ROM XM-1702BC", NULL,
-	"CD-532E-A", NULL,
-	"E-IDE CD-ROM CR-840", NULL,
-	"CD-ROM Drive/F5A", NULL,
-	"WPI CDD-820", NULL,
-	"SAMSUNG CD-ROM SC-148C", NULL,
-	"SAMSUNG CD-ROM SC", NULL,
-	"SanDisk SDP3B-64", NULL,
-	"ATAPI CD-ROM DRIVE 40X MAXIMUM",NULL,
-	"_NEC DV5800A", NULL,
-	"SAMSUNG CD-ROM SN-124", "N001"
+struct ata_blacklist_entry {
+	const char *model_num;
+	const char *model_rev;
+	unsigned long horkage;
+};
+
+static const struct ata_blacklist_entry ata_device_blacklist [] = {
+	/* Devices with DMA related problems under Linux */
+	{ "WDC AC11000H",	NULL,		ATA_HORKAGE_NODMA },
+	{ "WDC AC22100H",	NULL,		ATA_HORKAGE_NODMA },
+	{ "WDC AC32500H",	NULL,		ATA_HORKAGE_NODMA },
+	{ "WDC AC33100H",	NULL,		ATA_HORKAGE_NODMA },
+	{ "WDC AC31600H",	NULL,		ATA_HORKAGE_NODMA },
+	{ "WDC AC32100H",	"24.09P07",	ATA_HORKAGE_NODMA },
+	{ "WDC AC23200L",	"21.10N21",	ATA_HORKAGE_NODMA },
+	{ "Compaq CRD-8241B", 	NULL,		ATA_HORKAGE_NODMA },
+	{ "CRD-8400B",		NULL, 		ATA_HORKAGE_NODMA },
+	{ "CRD-8480B",		NULL,		ATA_HORKAGE_NODMA },
+	{ "CRD-8482B",		NULL,		ATA_HORKAGE_NODMA },
+	{ "CRD-84",		NULL,		ATA_HORKAGE_NODMA },
+	{ "SanDisk SDP3B",	NULL,		ATA_HORKAGE_NODMA },
+	{ "SanDisk SDP3B-64",	NULL,		ATA_HORKAGE_NODMA },
+	{ "SANYO CD-ROM CRD",	NULL,		ATA_HORKAGE_NODMA },
+	{ "HITACHI CDR-8",	NULL,		ATA_HORKAGE_NODMA },
+	{ "HITACHI CDR-8335",	NULL,		ATA_HORKAGE_NODMA },
+	{ "HITACHI CDR-8435",	NULL,		ATA_HORKAGE_NODMA },
+	{ "Toshiba CD-ROM XM-6202B", NULL,	ATA_HORKAGE_NODMA },
+	{ "TOSHIBA CD-ROM XM-1702BC", NULL,	ATA_HORKAGE_NODMA },
+	{ "CD-532E-A", 		NULL,		ATA_HORKAGE_NODMA },
+	{ "E-IDE CD-ROM CR-840",NULL,		ATA_HORKAGE_NODMA },
+	{ "CD-ROM Drive/F5A",	NULL,		ATA_HORKAGE_NODMA },
+	{ "WPI CDD-820", 	NULL,		ATA_HORKAGE_NODMA },
+	{ "SAMSUNG CD-ROM SC-148C", NULL,	ATA_HORKAGE_NODMA },
+	{ "SAMSUNG CD-ROM SC",	NULL,		ATA_HORKAGE_NODMA },
+	{ "SanDisk SDP3B-64", 	NULL,		ATA_HORKAGE_NODMA },
+	{ "ATAPI CD-ROM DRIVE 40X MAXIMUM",NULL,ATA_HORKAGE_NODMA },
+	{ "_NEC DV5800A", 	NULL,		ATA_HORKAGE_NODMA },
+	{ "SAMSUNG CD-ROM SN-124","N001",	ATA_HORKAGE_NODMA },
+
+	/* Devices we expect to fail diagnostics */
+
+	/* Devices where NCQ should be avoided */
+	/* NCQ is slow */
+        { "WDC WD740ADFD-00",   NULL,		ATA_HORKAGE_NONCQ },
+
+	/* Devices with NCQ limits */
+
+	/* End Marker */
+	{ }
@@ -3062 +3339 @@
-static int ata_dma_blacklisted(const struct ata_device *dev)
+unsigned long ata_device_blacklisted(const struct ata_device *dev)
@@ -3067,9 +3344 @@
-	int i;
-
-	/* We don't support polling DMA.
-	 * DMA blacklist those ATAPI devices with CDB-intr (and use PIO)
-	 * if the LLDD handles only interrupts in the HSM_ST_LAST state.
-	 */
-	if ((dev->ap->flags & ATA_FLAG_PIO_POLLING) &&
-	    (dev->flags & ATA_DFLAG_CDB_INTR))
-		return 1;
+	const struct ata_blacklist_entry *ad = ata_device_blacklist;
@@ -3084,6 +3353,6 @@
-	for (i = 0; i < ARRAY_SIZE(ata_dma_blacklist); i += 2) {
-		if (!strncmp(ata_dma_blacklist[i], model_num, nlen)) {
-			if (ata_dma_blacklist[i+1] == NULL)
-				return 1;
-			if (!strncmp(ata_dma_blacklist[i], model_rev, rlen))
-				return 1;
+	while (ad->model_num) {
+		if (!strncmp(ad->model_num, model_num, nlen)) {
+			if (ad->model_rev == NULL)
+				return ad->horkage;
+			if (!strncmp(ad->model_rev, model_rev, rlen))
+				return ad->horkage;
@@ -3090,0 +3360 @@
+		ad++;
@@ -3094,0 +3365,12 @@
+static int ata_dma_blacklisted(const struct ata_device *dev)
+{
+	/* We don't support polling DMA.
+	 * DMA blacklist those ATAPI devices with CDB-intr (and use PIO)
+	 * if the LLDD handles only interrupts in the HSM_ST_LAST state.
+	 */
+	if ((dev->ap->flags & ATA_FLAG_PIO_POLLING) &&
+	    (dev->flags & ATA_DFLAG_CDB_INTR))
+		return 1;
+	return (ata_device_blacklisted(dev) & ATA_HORKAGE_NODMA) ? 1 : 0;
+}
+
@@ -3121,0 +3404,7 @@
+	/* Apply drive side cable rule. Unknown or 80 pin cables reported
+	 * host side are checked drive side as well. Cases where we know a
+	 * 40wire cable is used safely for 80 are not checked here.
+	 */
+        if (ata_drive_40wire(dev->id) && (ap->cbl == ATA_CBL_PATA_UNK || ap->cbl == ATA_CBL_PATA80))
+		xfer_mask &= ~(0xF8 << ATA_SHIFT_UDMA);
+
@@ -3239,2 +3528 @@
-
-static void ata_sg_clean(struct ata_queued_cmd *qc)
+void ata_sg_clean(struct ata_queued_cmd *qc)
@@ -3398,2 +3685,0 @@
-	struct scatterlist *sg;
-
@@ -3402 +3687,0 @@
-	memset(&qc->sgent, 0, sizeof(qc->sgent));
@@ -3409,2 +3694 @@
-	sg = qc->__sg;
-	sg_init_one(sg, buf, buflen);
+	sg_init_one(&qc->sgent, buf, buflen);
@@ -4203,2 +4487,6 @@
-					/* HSM violation. Let EH handle this */
-					qc->err_mask |= AC_ERR_HSM;
+					/* HSM violation. Let EH handle this.
+					 * Phantom devices also trigger this
+					 * condition.  Mark hint.
+					 */
+					qc->err_mask |= AC_ERR_HSM |
+							AC_ERR_NODEV_HINT;
@@ -4298 +4586 @@
-static void ata_pio_task(void *_data)
+static void ata_pio_task(struct work_struct *work)
@@ -4300,2 +4588,3 @@
-	struct ata_queued_cmd *qc = _data;
-	struct ata_port *ap = qc->ap;
+	struct ata_port *ap =
+		container_of(work, struct ata_port, port_task.work);
+	struct ata_queued_cmd *qc = ap->port_task_data;
@@ -4442,0 +4732,8 @@
+static void fill_result_tf(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+
+	ap->ops->tf_read(ap, &qc->result_tf);
+	qc->result_tf.flags = qc->tf.flags;
+}
+
@@ -4480 +4777 @@
-				ap->ops->tf_read(ap, &qc->result_tf);
+				fill_result_tf(qc);
@@ -4488 +4785 @@
-			ap->ops->tf_read(ap, &qc->result_tf);
+			fill_result_tf(qc);
@@ -4497 +4794 @@
-			ap->ops->tf_read(ap, &qc->result_tf);
+			fill_result_tf(qc);
@@ -4662,0 +4960 @@
+		case ATA_PROT_NODATA:
@@ -4676,0 +4975,8 @@
+	/* Some controllers show flaky interrupt behavior after
+	 * setting xfer mode.  Use polling instead.
+	 */
+	if (unlikely(qc->tf.command == ATA_CMD_SET_FEATURES &&
+		     qc->tf.feature == SETFEATURES_XFER) &&
+	    (ap->flags & ATA_FLAG_SETXFER_POLLING))
+		qc->tf.flags |= ATA_TFLAG_POLLING;
+
@@ -4784,0 +5091 @@
+	struct ata_eh_info *ehi = &ap->eh_info;
@@ -4844,0 +5152,5 @@
+
+	if (unlikely(qc->err_mask) && (qc->tf.protocol == ATA_PROT_DMA ||
+				       qc->tf.protocol == ATA_PROT_ATAPI_DMA))
+		ata_ehi_push_desc(ehi, "BMDMA stat 0x%x", host_stat);
+
@@ -5051 +5363 @@
-	if (ata_id_has_flush_ext(dev->id))
+	if (dev->flags & ATA_DFLAG_FLUSH_EXT)
@@ -5323,3 +5635,3 @@
-	INIT_WORK(&ap->port_task, NULL, NULL);
-	INIT_WORK(&ap->hotplug_task, ata_scsi_hotplug, ap);
-	INIT_WORK(&ap->scsi_rescan_task, ata_scsi_dev_rescan, ap);
+	INIT_DELAYED_WORK(&ap->port_task, NULL);
+	INIT_DELAYED_WORK(&ap->hotplug_task, ata_scsi_hotplug);
+	INIT_WORK(&ap->scsi_rescan_task, ata_scsi_dev_rescan);
@@ -5523,3 +5835,2 @@
-		ata_chk_status(ap);
-		host->ops->irq_clear(ap);
-		ata_eh_freeze_port(ap);	/* freeze port before requesting IRQ */
+		/* freeze port before requesting IRQ */
+		ata_eh_freeze_port(ap);
@@ -6122,0 +6434 @@
+EXPORT_SYMBOL_GPL(sata_port_hardreset);
@@ -6148,0 +6461 @@
+EXPORT_SYMBOL_GPL(ata_device_blacklisted);
--- ./projects/linux/linux-2.6.20/drivers/ata/libata-core.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/ata/libata-core.c	2007-04-26 05:08:32.000000000 +0200
@@ -61,0 +62,3 @@
+#define DRV_VERSION	"2.20"	/* must be exactly four chars */
+
+
@@ -72 +75 @@
-static unsigned int ata_unique_id = 1;
+static unsigned int ata_print_id = 1;
@@ -92,0 +96,4 @@
+int libata_noacpi = 1;
+module_param_named(noacpi, libata_noacpi, int, 0444);
+MODULE_PARM_DESC(noacpi, "Disables the use of ACPI in suspend/resume when set");
+
@@ -311,3 +318 @@
-	if ((dev->flags & (ATA_DFLAG_PIO | ATA_DFLAG_NCQ_OFF |
-			   ATA_DFLAG_NCQ)) == ATA_DFLAG_NCQ &&
-	    likely(tag != ATA_TAG_INTERNAL)) {
+	if (ata_ncq_enabled(dev) && likely(tag != ATA_TAG_INTERNAL)) {
@@ -595,0 +601,2 @@
+		ata_down_xfermask_limit(dev, ATA_DNXFER_FORCE_PIO0 |
+					     ATA_DNXFER_QUIET);
@@ -601,45 +608 @@
- *	ata_pio_devchk - PATA device presence detection
- *	@ap: ATA channel to examine
- *	@device: Device to examine (starting at zero)
- *
- *	This technique was originally described in
- *	Hale Landis's ATADRVR (www.ata-atapi.com), and
- *	later found its way into the ATA/ATAPI spec.
- *
- *	Write a pattern to the ATA shadow registers,
- *	and if a device is present, it will respond by
- *	correctly storing and echoing back the
- *	ATA shadow register contents.
- *
- *	LOCKING:
- *	caller.
- */
-
-static unsigned int ata_pio_devchk(struct ata_port *ap,
-				   unsigned int device)
-{
-	struct ata_ioports *ioaddr = &ap->ioaddr;
-	u8 nsect, lbal;
-
-	ap->ops->dev_select(ap, device);
-
-	outb(0x55, ioaddr->nsect_addr);
-	outb(0xaa, ioaddr->lbal_addr);
-
-	outb(0xaa, ioaddr->nsect_addr);
-	outb(0x55, ioaddr->lbal_addr);
-
-	outb(0x55, ioaddr->nsect_addr);
-	outb(0xaa, ioaddr->lbal_addr);
-
-	nsect = inb(ioaddr->nsect_addr);
-	lbal = inb(ioaddr->lbal_addr);
-
-	if ((nsect == 0x55) && (lbal == 0xaa))
-		return 1;	/* we found a device */
-
-	return 0;		/* nothing found */
-}
-
-/**
- *	ata_mmio_devchk - PATA device presence detection
+ *	ata_devchk - PATA device presence detection
@@ -662,2 +625 @@
-static unsigned int ata_mmio_devchk(struct ata_port *ap,
-				    unsigned int device)
+static unsigned int ata_devchk(struct ata_port *ap, unsigned int device)
@@ -670,2 +632,2 @@
-	writeb(0x55, (void __iomem *) ioaddr->nsect_addr);
-	writeb(0xaa, (void __iomem *) ioaddr->lbal_addr);
+	iowrite8(0x55, ioaddr->nsect_addr);
+	iowrite8(0xaa, ioaddr->lbal_addr);
@@ -673,2 +635,2 @@
-	writeb(0xaa, (void __iomem *) ioaddr->nsect_addr);
-	writeb(0x55, (void __iomem *) ioaddr->lbal_addr);
+	iowrite8(0xaa, ioaddr->nsect_addr);
+	iowrite8(0x55, ioaddr->lbal_addr);
@@ -676,2 +638,2 @@
-	writeb(0x55, (void __iomem *) ioaddr->nsect_addr);
-	writeb(0xaa, (void __iomem *) ioaddr->lbal_addr);
+	iowrite8(0x55, ioaddr->nsect_addr);
+	iowrite8(0xaa, ioaddr->lbal_addr);
@@ -679,2 +641,2 @@
-	nsect = readb((void __iomem *) ioaddr->nsect_addr);
-	lbal = readb((void __iomem *) ioaddr->lbal_addr);
+	nsect = ioread8(ioaddr->nsect_addr);
+	lbal = ioread8(ioaddr->lbal_addr);
@@ -689,21 +650,0 @@
- *	ata_devchk - PATA device presence detection
- *	@ap: ATA channel to examine
- *	@device: Device to examine (starting at zero)
- *
- *	Dispatch ATA device presence detection, depending
- *	on whether we are using PIO or MMIO to talk to the
- *	ATA shadow registers.
- *
- *	LOCKING:
- *	caller.
- */
-
-static unsigned int ata_devchk(struct ata_port *ap,
-				    unsigned int device)
-{
-	if (ap->flags & ATA_FLAG_MMIO)
-		return ata_mmio_devchk(ap, device);
-	return ata_pio_devchk(ap, device);
-}
-
-/**
@@ -770 +711 @@
-static unsigned int
+unsigned int
@@ -885,0 +827,42 @@
+ *	ata_id_to_dma_mode	-	Identify DMA mode from id block
+ *	@dev: device to identify
+ *	@unknown: mode to assume if we cannot tell
+ *
+ *	Set up the timing values for the device based upon the identify
+ *	reported values for the DMA mode. This function is used by drivers
+ *	which rely upon firmware configured modes, but wish to report the
+ *	mode correctly when possible.
+ *
+ *	In addition we emit similarly formatted messages to the default
+ *	ata_dev_set_mode handler, in order to provide consistency of
+ *	presentation.
+ */
+
+void ata_id_to_dma_mode(struct ata_device *dev, u8 unknown)
+{
+	unsigned int mask;
+	u8 mode;
+
+	/* Pack the DMA modes */
+	mask = ((dev->id[63] >> 8) << ATA_SHIFT_MWDMA) & ATA_MASK_MWDMA;
+	if (dev->id[53] & 0x04)
+		mask |= ((dev->id[88] >> 8) << ATA_SHIFT_UDMA) & ATA_MASK_UDMA;
+
+	/* Select the mode in use */
+	mode = ata_xfer_mask2mode(mask);
+
+	if (mode != 0) {
+		ata_dev_printk(dev, KERN_INFO, "configured for %s\n",
+		       ata_mode_string(mask));
+	} else {
+		/* SWDMA perhaps ? */
+		mode = unknown;
+		ata_dev_printk(dev, KERN_INFO, "configured for DMA\n");
+	}
+
+	/* Configure the device reporting */
+	dev->xfer_mode = mode;
+	dev->xfer_shift = ata_xfer_mode2shift(mode);
+}
+
+/**
@@ -926,5 +909 @@
-	if (ap->flags & ATA_FLAG_MMIO) {
-		writeb(tmp, (void __iomem *) ap->ioaddr.device_addr);
-	} else {
-		outb(tmp, ap->ioaddr.device_addr);
-	}
+	iowrite8(tmp, ap->ioaddr.device_addr);
@@ -957,2 +936,2 @@
-		ata_port_printk(ap, KERN_INFO, "ata_dev_select: ENTER, ata%u: "
-				"device %u, wait %u\n", ap->id, device, wait);
+		ata_port_printk(ap, KERN_INFO, "ata_dev_select: ENTER, "
+				"device %u, wait %u\n", device, wait);
@@ -1159 +1138 @@
-void ata_qc_complete_internal(struct ata_queued_cmd *qc)
+static void ata_qc_complete_internal(struct ata_queued_cmd *qc)
@@ -1252 +1230,0 @@
-		qc->nsect = buflen / ATA_SECT_SIZE;
@@ -1295 +1273 @@
-	if (qc->flags & ATA_QCFLAG_FAILED && !qc->err_mask) {
+	if ((qc->flags & ATA_QCFLAG_FAILED) && !qc->err_mask) {
@@ -1459,2 +1437 @@
-		ata_dev_printk(dev, KERN_DEBUG, "%s: ENTER, host %u, dev %u\n",
-			       __FUNCTION__, ap->id, dev->devno);
+		ata_dev_printk(dev, KERN_DEBUG, "%s: ENTER\n", __FUNCTION__);
@@ -1481 +1458,10 @@
-	tf.flags |= ATA_TFLAG_POLLING; /* for polling presence detection */
+
+	/* Some devices choke if TF registers contain garbage.  Make
+	 * sure those are properly initialized.
+	 */
+	tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;
+
+	/* Device presence detection is unreliable on some
+	 * controllers.  Always poll IDENTIFY if available.
+	 */
+	tf.flags |= ATA_TFLAG_POLLING;
@@ -1488 +1474 @@
-				ap->id, dev->devno);
+				ap->print_id, dev->devno);
@@ -1610,0 +1597,2 @@
+	char fwrevbuf[ATA_ID_FW_REV_LEN+1];
+	char modelbuf[ATA_ID_PROD_LEN+1];
@@ -1614,3 +1602,2 @@
-		ata_dev_printk(dev, KERN_INFO,
-			       "%s: ENTER/EXIT (host %u, dev %u) -- nodev\n",
-			       __FUNCTION__, ap->id, dev->devno);
+		ata_dev_printk(dev, KERN_INFO, "%s: ENTER/EXIT -- nodev\n",
+			       __FUNCTION__);
@@ -1621,2 +1608,11 @@
-		ata_dev_printk(dev, KERN_DEBUG, "%s: ENTER, host %u, dev %u\n",
-			       __FUNCTION__, ap->id, dev->devno);
+		ata_dev_printk(dev, KERN_DEBUG, "%s: ENTER\n", __FUNCTION__);
+
+	/* set _SDD */
+	rc = ata_acpi_push_id(ap, dev->devno);
+	if (rc) {
+		ata_dev_printk(dev, KERN_WARNING, "failed to set _SDD(%d)\n",
+			rc);
+	}
+
+	/* retrieve and execute the ATA task file of _GTF */
+	ata_acpi_exec_tfs(ap);
@@ -1656,2 +1652,3 @@
-				ata_dev_printk(dev, KERN_WARNING, "ata%u: device %u  supports DRM functions and may not be fully accessable.\n",
-					ap->id, dev->devno);
+				ata_dev_printk(dev, KERN_WARNING,
+					       "supports DRM functions and may "
+					       "not be fully accessable.\n");
@@ -1664,0 +1662,10 @@
+		/* SCSI only uses 4-char revisions, dump full 8 chars from ATA */
+		ata_id_c_string(dev->id, fwrevbuf, ATA_ID_FW_REV,
+				sizeof(fwrevbuf));
+
+		ata_id_c_string(dev->id, modelbuf, ATA_ID_PROD,
+				sizeof(modelbuf));
+
+		if (dev->id[59] & 0x100)
+			dev->multi_count = dev->id[59] & 0xff;
+
@@ -1684,5 +1691,7 @@
-			if (ata_msg_drv(ap) && print_info)
-				ata_dev_printk(dev, KERN_INFO, "%s, "
-					"max %s, %Lu sectors: %s %s\n",
-					revbuf,
-					ata_mode_string(xfer_mask),
+			if (ata_msg_drv(ap) && print_info) {
+				ata_dev_printk(dev, KERN_INFO,
+					"%s: %s, %s, max %s\n",
+					revbuf, modelbuf, fwrevbuf,
+					ata_mode_string(xfer_mask));
+				ata_dev_printk(dev, KERN_INFO,
+					"%Lu sectors, multi %u: %s %s\n",
@@ -1690 +1699,2 @@
-					lba_desc, ncq_desc);
+					dev->multi_count, lba_desc, ncq_desc);
+			}
@@ -1707,13 +1717,5 @@
-			if (ata_msg_drv(ap) && print_info)
-				ata_dev_printk(dev, KERN_INFO, "%s, "
-					"max %s, %Lu sectors: CHS %u/%u/%u\n",
-					revbuf,
-					ata_mode_string(xfer_mask),
-					(unsigned long long)dev->n_sectors,
-					dev->cylinders, dev->heads,
-					dev->sectors);
-		}
-
-		if (dev->id[59] & 0x100) {
-			dev->multi_count = dev->id[59] & 0xff;
-			if (ata_msg_drv(ap) && print_info)
+			if (ata_msg_drv(ap) && print_info) {
+				ata_dev_printk(dev, KERN_INFO,
+					"%s: %s, %s, max %s\n",
+					revbuf,	modelbuf, fwrevbuf,
+					ata_mode_string(xfer_mask));
@@ -1721,2 +1723,5 @@
-					"ata%u: dev %u multi count %u\n",
-					ap->id, dev->devno, dev->multi_count);
+					"%Lu sectors, multi %u, CHS %u/%u/%u\n",
+					(unsigned long long)dev->n_sectors,
+					dev->multi_count, dev->cylinders,
+					dev->heads, dev->sectors);
+			}
@@ -1781,0 +1787,7 @@
+	if (ata_device_blacklisted(dev) & ATA_HORKAGE_MAX_SEC_128)
+		dev->max_sectors = min(ATA_MAX_SECTORS_128, dev->max_sectors);
+
+	/* limit ATAPI DMA to R/W commands only */
+	if (ata_device_blacklisted(dev) & ATA_HORKAGE_DMA_RW_ONLY)
+		dev->horkage |= ATA_HORKAGE_DMA_RW_ONLY;
+
@@ -1816 +1828 @@
-	int i, rc, down_xfermask;
+	int i, rc;
@@ -1825,2 +1836,0 @@
-	down_xfermask = 0;
-
@@ -1850,2 +1860,5 @@
-	/* read IDENTIFY page and configure devices */
-	for (i = 0; i < ATA_MAX_DEVICES; i++) {
+	/* read IDENTIFY page and configure devices. We have to do the identify
+	   specific sequence bass-ackwards so that PDIAG- is released by
+	   the slave device */
+
+	for (i = ATA_MAX_DEVICES - 1; i >=  0; i--) {
@@ -1863,0 +1877,9 @@
+	}
+
+	/* After the identify sequence we can now set up the devices. We do
+	   this in the normal order so that the user doesn't get confused */
+
+	for(i = 0; i < ATA_MAX_DEVICES; i++) {
+		dev = &ap->device[i];
+		if (!ata_dev_enabled(dev))
+			continue;
@@ -1874,2 +1896 @@
-	if (rc) {
-		down_xfermask = 1;
+	if (rc)
@@ -1877 +1897,0 @@
-	}
@@ -1888,0 +1909,2 @@
+	tries[dev->devno]--;
+
@@ -1891 +1913 @@
-	case -ENODEV:
+		/* eeek, something went very wrong, give up */
@@ -1893,0 +1916,4 @@
+
+	case -ENODEV:
+		/* give it just one more chance */
+		tries[dev->devno] = min(tries[dev->devno], 1);
@@ -1895,7 +1921,7 @@
-		sata_down_spd_limit(ap);
-		/* fall through */
-	default:
-		tries[dev->devno]--;
-		if (down_xfermask &&
-		    ata_down_xfermask_limit(dev, tries[dev->devno] == 1))
-			tries[dev->devno] = 0;
+		if (tries[dev->devno] == 1) {
+			/* This is the last chance, better to slow
+			 * down than lose it.
+			 */
+			sata_down_spd_limit(ap);
+			ata_down_xfermask_limit(dev, ATA_DNXFER_PIO);
+		}
@@ -1904,2 +1930 @@
-	if (!tries[dev->devno]) {
-		ata_down_xfermask_limit(dev, 1);
+	if (!tries[dev->devno])
@@ -1907 +1931,0 @@
-	}
@@ -2338 +2362 @@
- *	@force_pio0: Force PIO0
+ *	@sel: ATA_DNXFER_* selector
@@ -2350 +2374 @@
-int ata_down_xfermask_limit(struct ata_device *dev, int force_pio0)
+int ata_down_xfermask_limit(struct ata_device *dev, unsigned int sel)
@@ -2352,2 +2376,4 @@
-	unsigned long xfer_mask;
-	int highbit;
+	char buf[32];
+	unsigned int orig_mask, xfer_mask;
+	unsigned int pio_mask, mwdma_mask, udma_mask;
+	int quiet, highbit;
@@ -2355,2 +2381,2 @@
-	xfer_mask = ata_pack_xfermask(dev->pio_mask, dev->mwdma_mask,
-				      dev->udma_mask);
+	quiet = !!(sel & ATA_DNXFER_QUIET);
+	sel &= ~ATA_DNXFER_QUIET;
@@ -2358,5 +2384,10 @@
-	if (!xfer_mask)
-		goto fail;
-	/* don't gear down to MWDMA from UDMA, go directly to PIO */
-	if (xfer_mask & ATA_MASK_UDMA)
-		xfer_mask &= ~ATA_MASK_MWDMA;
+	xfer_mask = orig_mask = ata_pack_xfermask(dev->pio_mask,
+						  dev->mwdma_mask,
+						  dev->udma_mask);
+	ata_unpack_xfermask(xfer_mask, &pio_mask, &mwdma_mask, &udma_mask);
+
+	switch (sel) {
+	case ATA_DNXFER_PIO:
+		highbit = fls(pio_mask) - 1;
+		pio_mask &= ~(1 << highbit);
+		break;
@@ -2364,6 +2395,46 @@
-	highbit = fls(xfer_mask) - 1;
-	xfer_mask &= ~(1 << highbit);
-	if (force_pio0)
-		xfer_mask &= 1 << ATA_SHIFT_PIO;
-	if (!xfer_mask)
-		goto fail;
+	case ATA_DNXFER_DMA:
+		if (udma_mask) {
+			highbit = fls(udma_mask) - 1;
+			udma_mask &= ~(1 << highbit);
+			if (!udma_mask)
+				return -ENOENT;
+		} else if (mwdma_mask) {
+			highbit = fls(mwdma_mask) - 1;
+			mwdma_mask &= ~(1 << highbit);
+			if (!mwdma_mask)
+				return -ENOENT;
+		}
+		break;
+
+	case ATA_DNXFER_40C:
+		udma_mask &= ATA_UDMA_MASK_40C;
+		break;
+
+	case ATA_DNXFER_FORCE_PIO0:
+		pio_mask &= 1;
+	case ATA_DNXFER_FORCE_PIO:
+		mwdma_mask = 0;
+		udma_mask = 0;
+		break;
+
+	default:
+		BUG();
+	}
+
+	xfer_mask &= ata_pack_xfermask(pio_mask, mwdma_mask, udma_mask);
+
+	if (!(xfer_mask & ATA_MASK_PIO) || xfer_mask == orig_mask)
+		return -ENOENT;
+
+	if (!quiet) {
+		if (xfer_mask & (ATA_MASK_MWDMA | ATA_MASK_UDMA))
+			snprintf(buf, sizeof(buf), "%s:%s",
+				 ata_mode_string(xfer_mask),
+				 ata_mode_string(xfer_mask & ATA_MASK_PIO));
+		else
+			snprintf(buf, sizeof(buf), "%s",
+				 ata_mode_string(xfer_mask));
+
+		ata_dev_printk(dev, KERN_WARNING,
+			       "limiting speed to %s\n", buf);
+	}
@@ -2374,3 +2444,0 @@
-	ata_dev_printk(dev, KERN_WARNING, "limiting speed to %s\n",
-		       ata_mode_string(xfer_mask));
-
@@ -2378,3 +2445,0 @@
-
- fail:
-	return -EINVAL;
@@ -2393,0 +2459,4 @@
+	/* Old CFA may refuse this command, which is just fine */
+	if (dev->xfer_shift == ATA_SHIFT_PIO && ata_id_is_cfa(dev->id))
+        	err_mask &= ~AC_ERR_DEV;
+
@@ -2496 +2565 @@
-		/* don't udpate suspended devices' xfer mode */
+		/* don't update suspended devices' xfer mode */
@@ -2509 +2578 @@
-		ap->host->simplex_claimed = 1;
+		ap->host->simplex_claimed = ap;
@@ -2514 +2582,0 @@
-
@@ -2617,7 +2685,2 @@
-		if (ap->flags & ATA_FLAG_MMIO) {
-			nsect = readb((void __iomem *) ioaddr->nsect_addr);
-			lbal = readb((void __iomem *) ioaddr->lbal_addr);
-		} else {
-			nsect = inb(ioaddr->nsect_addr);
-			lbal = inb(ioaddr->lbal_addr);
-		}
+		nsect = ioread8(ioaddr->nsect_addr);
+		lbal = ioread8(ioaddr->lbal_addr);
@@ -2648 +2711 @@
-	DPRINTK("ata%u: bus reset via SRST\n", ap->id);
+	DPRINTK("ata%u: bus reset via SRST\n", ap->print_id);
@@ -2651,13 +2714,5 @@
-	if (ap->flags & ATA_FLAG_MMIO) {
-		writeb(ap->ctl, (void __iomem *) ioaddr->ctl_addr);
-		udelay(20);	/* FIXME: flush */
-		writeb(ap->ctl | ATA_SRST, (void __iomem *) ioaddr->ctl_addr);
-		udelay(20);	/* FIXME: flush */
-		writeb(ap->ctl, (void __iomem *) ioaddr->ctl_addr);
-	} else {
-		outb(ap->ctl, ioaddr->ctl_addr);
-		udelay(10);
-		outb(ap->ctl | ATA_SRST, ioaddr->ctl_addr);
-		udelay(10);
-		outb(ap->ctl, ioaddr->ctl_addr);
-	}
+	iowrite8(ap->ctl, ioaddr->ctl_addr);
+	udelay(20);	/* FIXME: flush */
+	iowrite8(ap->ctl | ATA_SRST, ioaddr->ctl_addr);
+	udelay(20);	/* FIXME: flush */
+	iowrite8(ap->ctl, ioaddr->ctl_addr);
@@ -2716 +2771 @@
-	DPRINTK("ENTER, host %u, port %u\n", ap->id, ap->port_no);
+	DPRINTK("ENTER, host %u, port %u\n", ap->print_id, ap->port_no);
@@ -2748,2 +2803 @@
-	if (ap->ioaddr.ctl_addr)	/* FIXME: hack. create a hook instead */
-		ata_irq_on(ap);
+	ap->ops->irq_on(ap);
@@ -2764,4 +2818 @@
-		if (ap->flags & ATA_FLAG_MMIO)
-			writeb(ap->ctl, (void __iomem *) ioaddr->ctl_addr);
-		else
-			outb(ap->ctl, ioaddr->ctl_addr);
+		iowrite8(ap->ctl, ioaddr->ctl_addr);
@@ -3100,0 +3152,3 @@
+	/* wait a while before checking status, see SRST for more info */
+	msleep(150);
+
@@ -3141,5 +3195,2 @@
-	if (!ap->ops->error_handler) {
-		/* FIXME: hack. create a hook instead */
-		if (ap->ioaddr.ctl_addr)
-			ata_irq_on(ap);
-	}
+	if (!ap->ops->error_handler)
+		ap->ops->irq_on(ap);
@@ -3160,6 +3211,2 @@
-	if (ap->ioaddr.ctl_addr) {
-		if (ap->flags & ATA_FLAG_MMIO)
-			writeb(ap->ctl, (void __iomem *) ap->ioaddr.ctl_addr);
-		else
-			outb(ap->ctl, ap->ioaddr.ctl_addr);
-	}
+	if (ap->ioaddr.ctl_addr)
+		iowrite8(ap->ctl, ap->ioaddr.ctl_addr);
@@ -3190 +3237,2 @@
-	unsigned char model[2][41], serial[2][21];
+	unsigned char model[2][ATA_ID_PROD_LEN + 1];
+	unsigned char serial[2][ATA_ID_SERNO_LEN + 1];
@@ -3199,4 +3247,4 @@
-	ata_id_c_string(old_id, model[0], ATA_ID_PROD_OFS, sizeof(model[0]));
-	ata_id_c_string(new_id, model[1], ATA_ID_PROD_OFS, sizeof(model[1]));
-	ata_id_c_string(old_id, serial[0], ATA_ID_SERNO_OFS, sizeof(serial[0]));
-	ata_id_c_string(new_id, serial[1], ATA_ID_SERNO_OFS, sizeof(serial[1]));
+	ata_id_c_string(old_id, model[0], ATA_ID_PROD, sizeof(model[0]));
+	ata_id_c_string(new_id, model[1], ATA_ID_PROD, sizeof(model[1]));
+	ata_id_c_string(old_id, serial[0], ATA_ID_SERNO, sizeof(serial[0]));
+	ata_id_c_string(new_id, serial[1], ATA_ID_SERNO, sizeof(serial[1]));
@@ -3310 +3357,0 @@
-	{ "SanDisk SDP3B-64", 	NULL,		ATA_HORKAGE_NODMA },
@@ -3314,0 +3362,4 @@
+	/* Weird ATAPI devices */
+	{ "TORiSAN DVD-ROM DRD-N216", NULL,	ATA_HORKAGE_MAX_SEC_128 |
+						ATA_HORKAGE_DMA_RW_ONLY },
+
@@ -3319,0 +3371,11 @@
+	/* http://thread.gmane.org/gmane.linux.ide/14907 */
+	{ "FUJITSU MHT2060BH",	NULL,		ATA_HORKAGE_NONCQ },
+	/* NCQ is broken */
+	{ "Maxtor 6L250S0",     "BANC1G10",     ATA_HORKAGE_NONCQ },
+	/* NCQ hard hangs device under heavier load, needs hard power cycle */
+	{ "Maxtor 6B250S0",	"BANC1B70",	ATA_HORKAGE_NONCQ },
+	/* Blacklist entries taken from Silicon Image 3124/3132
+	   Windows driver .inf file - also several Linux problem reports */
+	{ "HTS541060G9SA00",    "MB3OC60D",     ATA_HORKAGE_NONCQ, },
+	{ "HTS541080G9SA00",    "MB4OC60D",     ATA_HORKAGE_NONCQ, },
+	{ "HTS541010G9SA00",    "MBZOC60D",     ATA_HORKAGE_NONCQ, },
@@ -3327,12 +3388,0 @@
-static int ata_strim(char *s, size_t len)
-{
-	len = strnlen(s, len);
-
-	/* ATAPI specifies that empty space is blank-filled; remove blanks */
-	while ((len > 0) && (s[len - 1] == ' ')) {
-		len--;
-		s[len] = 0;
-	}
-	return len;
-}
-
@@ -3341,3 +3391,2 @@
-	unsigned char model_num[40];
-	unsigned char model_rev[16];
-	unsigned int nlen, rlen;
+	unsigned char model_num[ATA_ID_PROD_LEN + 1];
+	unsigned char model_rev[ATA_ID_FW_REV_LEN + 1];
@@ -3346,6 +3395,2 @@
-	ata_id_string(dev->id, model_num, ATA_ID_PROD_OFS,
-			  sizeof(model_num));
-	ata_id_string(dev->id, model_rev, ATA_ID_FW_REV_OFS,
-			  sizeof(model_rev));
-	nlen = ata_strim(model_num, sizeof(model_num));
-	rlen = ata_strim(model_rev, sizeof(model_rev));
+	ata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));
+	ata_id_c_string(dev->id, model_rev, ATA_ID_FW_REV, sizeof(model_rev));
@@ -3354 +3399 @@
-		if (!strncmp(ad->model_num, model_num, nlen)) {
+		if (!strcmp(ad->model_num, model_num)) {
@@ -3357 +3402 @@
-			if (!strncmp(ad->model_rev, model_rev, rlen))
+			if (!strcmp(ad->model_rev, model_rev))
@@ -3433 +3478,2 @@
-	if ((host->flags & ATA_HOST_SIMPLEX) && host->simplex_claimed) {
+	if ((host->flags & ATA_HOST_SIMPLEX) &&
+            host->simplex_claimed && host->simplex_claimed != ap) {
@@ -3646,0 +3693,20 @@
+	/* some drives can only do ATAPI DMA on read/write */
+	if (unlikely(qc->dev->horkage & ATA_HORKAGE_DMA_RW_ONLY)) {
+		struct scsi_cmnd *cmd = qc->scsicmd;
+		u8 *scsicmd = cmd->cmnd;
+
+		switch (scsicmd[0]) {
+		case READ_10:
+		case WRITE_10:
+		case READ_12:
+		case WRITE_12:
+		case READ_6:
+		case WRITE_6:
+			/* atapi dma maybe ok */
+			break;
+		default:
+			/* turn off atapi dma */
+			return 1;
+		}
+	}
+
@@ -3810 +3876 @@
-	VPRINTK("ENTER, ata%u\n", ap->id);
+	VPRINTK("ENTER, ata%u\n", ap->print_id);
@@ -3897,47 +3963 @@
- *	ata_mmio_data_xfer - Transfer data by MMIO
- *	@adev: device for this I/O
- *	@buf: data buffer
- *	@buflen: buffer length
- *	@write_data: read/write
- *
- *	Transfer data from/to the device data register by MMIO.
- *
- *	LOCKING:
- *	Inherited from caller.
- */
-
-void ata_mmio_data_xfer(struct ata_device *adev, unsigned char *buf,
-			unsigned int buflen, int write_data)
-{
-	struct ata_port *ap = adev->ap;
-	unsigned int i;
-	unsigned int words = buflen >> 1;
-	u16 *buf16 = (u16 *) buf;
-	void __iomem *mmio = (void __iomem *)ap->ioaddr.data_addr;
-
-	/* Transfer multiple of 2 bytes */
-	if (write_data) {
-		for (i = 0; i < words; i++)
-			writew(le16_to_cpu(buf16[i]), mmio);
-	} else {
-		for (i = 0; i < words; i++)
-			buf16[i] = cpu_to_le16(readw(mmio));
-	}
-
-	/* Transfer trailing 1 byte, if any. */
-	if (unlikely(buflen & 0x01)) {
-		u16 align_buf[1] = { 0 };
-		unsigned char *trailing_buf = buf + buflen - 1;
-
-		if (write_data) {
-			memcpy(align_buf, trailing_buf, 1);
-			writew(le16_to_cpu(align_buf[0]), mmio);
-		} else {
-			align_buf[0] = cpu_to_le16(readw(mmio));
-			memcpy(trailing_buf, align_buf, 1);
-		}
-	}
-}
-
-/**
- *	ata_pio_data_xfer - Transfer data by PIO
+ *	ata_data_xfer - Transfer data by PIO
@@ -3954,3 +3974,2 @@
-
-void ata_pio_data_xfer(struct ata_device *adev, unsigned char *buf,
-		       unsigned int buflen, int write_data)
+void ata_data_xfer(struct ata_device *adev, unsigned char *buf,
+		   unsigned int buflen, int write_data)
@@ -3963 +3982 @@
-		outsw(ap->ioaddr.data_addr, buf, words);
+		iowrite16_rep(ap->ioaddr.data_addr, buf, words);
@@ -3965 +3984 @@
-		insw(ap->ioaddr.data_addr, buf, words);
+		ioread16_rep(ap->ioaddr.data_addr, buf, words);
@@ -3974 +3993 @@
-			outw(le16_to_cpu(align_buf[0]), ap->ioaddr.data_addr);
+			iowrite16(le16_to_cpu(align_buf[0]), ap->ioaddr.data_addr);
@@ -3976 +3995 @@
-			align_buf[0] = cpu_to_le16(inw(ap->ioaddr.data_addr));
+			align_buf[0] = cpu_to_le16(ioread16(ap->ioaddr.data_addr));
@@ -3983 +4002 @@
- *	ata_pio_data_xfer_noirq - Transfer data by PIO
+ *	ata_data_xfer_noirq - Transfer data by PIO
@@ -3995,3 +4014,2 @@
-
-void ata_pio_data_xfer_noirq(struct ata_device *adev, unsigned char *buf,
-				    unsigned int buflen, int write_data)
+void ata_data_xfer_noirq(struct ata_device *adev, unsigned char *buf,
+			 unsigned int buflen, int write_data)
@@ -4001 +4019 @@
-	ata_pio_data_xfer(adev, buf, buflen, write_data);
+	ata_data_xfer(adev, buf, buflen, write_data);
@@ -4025 +4043 @@
-	if (qc->cursect == (qc->nsect - 1))
+	if (qc->curbytes == qc->nbytes - ATA_SECT_SIZE)
@@ -4029 +4047 @@
-	offset = sg[qc->cursg].offset + qc->cursg_ofs * ATA_SECT_SIZE;
+	offset = sg[qc->cursg].offset + qc->cursg_ofs;
@@ -4054,2 +4072,2 @@
-	qc->cursect++;
-	qc->cursg_ofs++;
+	qc->curbytes += ATA_SECT_SIZE;
+	qc->cursg_ofs += ATA_SECT_SIZE;
@@ -4057 +4075 @@
-	if ((qc->cursg_ofs * ATA_SECT_SIZE) == (&sg[qc->cursg])->length) {
+	if (qc->cursg_ofs == (&sg[qc->cursg])->length) {
@@ -4082 +4100,2 @@
-		nsect = min(qc->nsect - qc->cursect, qc->dev->multi_count);
+		nsect = min((qc->nbytes - qc->curbytes) / ATA_SECT_SIZE,
+			    qc->dev->multi_count);
@@ -4258 +4277 @@
-	VPRINTK("ata%u: xfering %d bytes\n", ap->id, bytes);
+	VPRINTK("ata%u: xfering %d bytes\n", ap->print_id, bytes);
@@ -4323 +4342 @@
-					ata_irq_on(ap);
+					ap->ops->irq_on(ap);
@@ -4339 +4358 @@
-			ata_irq_on(ap);
+			ap->ops->irq_on(ap);
@@ -4375 +4394 @@
-		ap->id, qc->tf.protocol, ap->hsm_task_state, status);
+		ap->print_id, qc->tf.protocol, ap->hsm_task_state, status);
@@ -4408,2 +4427,2 @@
-			printk(KERN_WARNING "ata%d: DRQ=1 with device error, dev_stat 0x%X\n",
-			       ap->id, status);
+			ata_port_printk(ap, KERN_WARNING, "DRQ=1 with device "
+					"error, dev_stat 0x%X\n", status);
@@ -4466,2 +4485,3 @@
-				printk(KERN_WARNING "ata%d: DRQ=1 with device error, dev_stat 0x%X\n",
-				       ap->id, status);
+				ata_port_printk(ap, KERN_WARNING, "DRQ=1 with "
+						"device error, dev_stat 0x%X\n",
+						status);
@@ -4553 +4573 @@
-			ap->id, qc->dev->devno, status);
+			ap->print_id, qc->dev->devno, status);
@@ -4736 +4755,0 @@
-	ap->ops->tf_read(ap, &qc->result_tf);
@@ -4737,0 +4757 @@
+	ap->ops->tf_read(ap, &qc->result_tf);
@@ -5095 +5115 @@
-		ap->id, qc->tf.protocol, ap->hsm_task_state);
+		ap->print_id, qc->tf.protocol, ap->hsm_task_state);
@@ -5116 +5136,2 @@
-			VPRINTK("ata%u: host_stat 0x%X\n", ap->id, host_stat);
+			VPRINTK("ata%u: host_stat 0x%X\n",
+				ap->print_id, host_stat);
@@ -5164 +5185 @@
-		ata_irq_ack(ap, 0); /* debug trap */
+		ap->ops->irq_ack(ap, 0); /* debug trap */
@@ -5376,0 +5398 @@
+#ifdef CONFIG_PM
@@ -5491,0 +5514 @@
+#endif
@@ -5505,2 +5528 @@
-
-int ata_port_start (struct ata_port *ap)
+int ata_port_start(struct ata_port *ap)
@@ -5511 +5533,2 @@
-	ap->prd = dma_alloc_coherent(dev, ATA_PRD_TBL_SZ, &ap->prd_dma, GFP_KERNEL);
+	ap->prd = dmam_alloc_coherent(dev, ATA_PRD_TBL_SZ, &ap->prd_dma,
+				      GFP_KERNEL);
@@ -5516,2 +5539 @@
-	if (rc) {
-		dma_free_coherent(dev, ATA_PRD_TBL_SZ, ap->prd, ap->prd_dma);
+	if (rc)
@@ -5519,3 +5540,0 @@
-	}
-
-	DPRINTK("prd alloc, virt %p, dma %llx\n", ap->prd, (unsigned long long) ap->prd_dma);
@@ -5522,0 +5542,2 @@
+	DPRINTK("prd alloc, virt %p, dma %llx\n", ap->prd,
+		(unsigned long long)ap->prd_dma);
@@ -5526,27 +5546,0 @@
-
-/**
- *	ata_port_stop - Undo ata_port_start()
- *	@ap: Port to shut down
- *
- *	Frees the PRD table.
- *
- *	May be used as the port_stop() entry in ata_port_operations.
- *
- *	LOCKING:
- *	Inherited from caller.
- */
-
-void ata_port_stop (struct ata_port *ap)
-{
-	struct device *dev = ap->dev;
-
-	dma_free_coherent(dev, ATA_PRD_TBL_SZ, ap->prd, ap->prd_dma);
-	ata_pad_free(ap, dev);
-}
-
-void ata_host_stop (struct ata_host *host)
-{
-	if (host->mmio_base)
-		iounmap(host->mmio_base);
-}
-
@@ -5604 +5598 @@
-	ap->id = ata_unique_id++;
+	ap->print_id = ata_print_id++;
@@ -5675 +5669 @@
-	shost->unique_id = ap->id;
+	shost->unique_id = ap->print_id;
@@ -5725,0 +5720,27 @@
+static void ata_host_release(struct device *gendev, void *res)
+{
+	struct ata_host *host = dev_get_drvdata(gendev);
+	int i;
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
+		if (ap && ap->ops->port_stop)
+			ap->ops->port_stop(ap);
+	}
+
+	if (host->ops->host_stop)
+		host->ops->host_stop(host);
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
+		if (ap)
+			scsi_host_put(ap->scsi_host);
+
+		host->ports[i] = NULL;
+	}
+
+	dev_set_drvdata(gendev, NULL);
+}
+
@@ -5773 +5794 @@
-	
+
@@ -5777,0 +5799,4 @@
+
+	if (!devres_open_group(dev, ata_device_add, GFP_KERNEL))
+		return 0;
+
@@ -5779,2 +5804,2 @@
-	host = kzalloc(sizeof(struct ata_host) +
-		       (ent->n_ports * sizeof(void *)), GFP_KERNEL);
+	host = devres_alloc(ata_host_release, sizeof(struct ata_host) +
+			    (ent->n_ports * sizeof(void *)), GFP_KERNEL);
@@ -5782 +5807,3 @@
-		return 0;
+		goto err_out;
+	devres_add(dev, host);
+	dev_set_drvdata(dev, host);
@@ -5788 +5815 @@
-	host->mmio_base = ent->mmio_base;
+	host->iomap = ent->iomap;
@@ -5826,2 +5853,2 @@
-		ata_port_printk(ap, KERN_INFO, "%cATA max %s cmd 0x%lX "
-				"ctl 0x%lX bmdma 0x%lX irq %d\n",
+		ata_port_printk(ap, KERN_INFO, "%cATA max %s cmd 0x%p "
+				"ctl 0x%p bmdma 0x%p irq %d\n",
@@ -5840,2 +5867,2 @@
-	rc = request_irq(ent->irq, ent->port_ops->irq_handler, ent->irq_flags,
-			 DRV_NAME, host);
+	rc = devm_request_irq(dev, ent->irq, ent->port_ops->irq_handler,
+			      ent->irq_flags, DRV_NAME, host);
@@ -5854,2 +5881,3 @@
-		rc = request_irq(ent->irq2, ent->port_ops->irq_handler, ent->irq_flags,
-			 DRV_NAME, host);
+		rc = devm_request_irq(dev, ent->irq2,
+				ent->port_ops->irq_handler, ent->irq_flags,
+				DRV_NAME, host);
@@ -5859 +5887 @@
-			goto err_out_free_irq;
+			goto err_out;
@@ -5862,0 +5891,3 @@
+	/* resource acquisition complete */
+	devres_remove_group(dev, ata_device_add);
+
@@ -5908 +5939 @@
-			DPRINTK("ata%u: bus probe begin\n", ap->id);
+			DPRINTK("ata%u: bus probe begin\n", ap->print_id);
@@ -5910 +5941 @@
-			DPRINTK("ata%u: bus probe end\n", ap->id);
+			DPRINTK("ata%u: bus probe end\n", ap->print_id);
@@ -5931,2 +5961,0 @@
-	dev_set_drvdata(dev, host);
-
@@ -5936,13 +5965,3 @@
-err_out_free_irq:
-	free_irq(ent->irq, host);
-err_out:
-	for (i = 0; i < host->n_ports; i++) {
-		struct ata_port *ap = host->ports[i];
-		if (ap) {
-			ap->ops->port_stop(ap);
-			scsi_host_put(ap->scsi_host);
-		}
-	}
-
-	kfree(host);
-	VPRINTK("EXIT, returning 0\n");
+ err_out:
+	devres_release_group(dev, ata_device_add);
+	VPRINTK("EXIT, returning %d\n", rc);
@@ -6011,2 +6030,2 @@
- *	ata_host_remove - PCI layer callback for device removal
- *	@host: ATA host set that was removed
+ *	ata_host_detach - Detach all ports of an ATA host
+ *	@host: Host to detach
@@ -6014,2 +6033 @@
- *	Unregister all objects associated with this host set. Free those
- *	objects.
+ *	Detach all ports of @host.
@@ -6018 +6036 @@
- *	Inherited from calling layer (may sleep).
+ *	Kernel thread context (may sleep).
@@ -6020,2 +6038 @@
-
-void ata_host_remove(struct ata_host *host)
+void ata_host_detach(struct ata_host *host)
@@ -6023 +6040 @@
-	unsigned int i;
+	int i;
@@ -6027,54 +6043,0 @@
-
-	free_irq(host->irq, host);
-	if (host->irq2)
-		free_irq(host->irq2, host);
-
-	for (i = 0; i < host->n_ports; i++) {
-		struct ata_port *ap = host->ports[i];
-
-		ata_scsi_release(ap->scsi_host);
-
-		if ((ap->flags & ATA_FLAG_NO_LEGACY) == 0) {
-			struct ata_ioports *ioaddr = &ap->ioaddr;
-
-			/* FIXME: Add -ac IDE pci mods to remove these special cases */
-			if (ioaddr->cmd_addr == ATA_PRIMARY_CMD)
-				release_region(ATA_PRIMARY_CMD, 8);
-			else if (ioaddr->cmd_addr == ATA_SECONDARY_CMD)
-				release_region(ATA_SECONDARY_CMD, 8);
-		}
-
-		scsi_host_put(ap->scsi_host);
-	}
-
-	if (host->ops->host_stop)
-		host->ops->host_stop(host);
-
-	kfree(host);
-}
-
-/**
- *	ata_scsi_release - SCSI layer callback hook for host unload
- *	@shost: libata host to be unloaded
- *
- *	Performs all duties necessary to shut down a libata port...
- *	Kill port kthread, disable port, and release resources.
- *
- *	LOCKING:
- *	Inherited from SCSI layer.
- *
- *	RETURNS:
- *	One.
- */
-
-int ata_scsi_release(struct Scsi_Host *shost)
-{
-	struct ata_port *ap = ata_shost_to_port(shost);
-
-	DPRINTK("ENTER\n");
-
-	ap->ops->port_disable(ap);
-	ap->ops->port_stop(ap);
-
-	DPRINTK("EXIT\n");
-	return 1;
@@ -6088 +6051 @@
-	probe_ent = kzalloc(sizeof(*probe_ent), GFP_KERNEL);
+	probe_ent = devm_kzalloc(dev, sizeof(*probe_ent), GFP_KERNEL);
@@ -6138,7 +6100,0 @@
-void ata_pci_host_stop (struct ata_host *host)
-{
-	struct pci_dev *pdev = to_pci_dev(host->dev);
-
-	pci_iounmap(pdev, host->mmio_base);
-}
-
@@ -6149,5 +6105,3 @@
- *	PCI layer indicates to libata via this hook that
- *	hot-unplug or module unload event has occurred.
- *	Handle this by unregistering all objects associated
- *	with this PCI device.  Free those objects.  Then finally
- *	release PCI resources and disable device.
+ *	PCI layer indicates to libata via this hook that hot-unplug or
+ *	module unload event has occurred.  Detach all ports.  Resource
+ *	release is handled via devres.
@@ -6158,2 +6112 @@
-
-void ata_pci_remove_one (struct pci_dev *pdev)
+void ata_pci_remove_one(struct pci_dev *pdev)
@@ -6164,5 +6117 @@
-	ata_host_remove(host);
-
-	pci_release_regions(pdev);
-	pci_disable_device(pdev);
-	dev_set_drvdata(dev, NULL);
+	ata_host_detach(host);
@@ -6204,0 +6154 @@
+#ifdef CONFIG_PM
@@ -6207,0 +6158 @@
+	pci_disable_device(pdev);
@@ -6209,2 +6160 @@
-	if (mesg.event == PM_EVENT_SUSPEND) {
-		pci_disable_device(pdev);
+	if (mesg.event == PM_EVENT_SUSPEND)
@@ -6212 +6161,0 @@
-	}
@@ -6215 +6164 @@
-void ata_pci_device_do_resume(struct pci_dev *pdev)
+int ata_pci_device_do_resume(struct pci_dev *pdev)
@@ -6216,0 +6166,2 @@
+	int rc;
+
@@ -6219 +6170,8 @@
-	pci_enable_device(pdev);
+
+	rc = pcim_enable_device(pdev);
+	if (rc) {
+		dev_printk(KERN_ERR, &pdev->dev,
+			   "failed to enable device after resume (%d)\n", rc);
+		return rc;
+	}
+
@@ -6220,0 +6179 @@
+	return 0;
@@ -6239,0 +6199 @@
+	int rc;
@@ -6241,3 +6201,4 @@
-	ata_pci_device_do_resume(pdev);
-	ata_host_resume(host);
-	return 0;
+	rc = ata_pci_device_do_resume(pdev);
+	if (rc == 0)
+		ata_host_resume(host);
+	return rc;
@@ -6244,0 +6206,2 @@
+#endif /* CONFIG_PM */
+
@@ -6389,2 +6352 @@
-EXPORT_SYMBOL_GPL(ata_port_detach);
-EXPORT_SYMBOL_GPL(ata_host_remove);
+EXPORT_SYMBOL_GPL(ata_host_detach);
@@ -6407,2 +6368,0 @@
-EXPORT_SYMBOL_GPL(ata_port_stop);
-EXPORT_SYMBOL_GPL(ata_host_stop);
@@ -6410,3 +6370,2 @@
-EXPORT_SYMBOL_GPL(ata_mmio_data_xfer);
-EXPORT_SYMBOL_GPL(ata_pio_data_xfer);
-EXPORT_SYMBOL_GPL(ata_pio_data_xfer_noirq);
+EXPORT_SYMBOL_GPL(ata_data_xfer);
+EXPORT_SYMBOL_GPL(ata_data_xfer_noirq);
@@ -6425,0 +6385 @@
+EXPORT_SYMBOL_GPL(ata_dev_disable);
@@ -6449 +6408,0 @@
-EXPORT_SYMBOL_GPL(ata_scsi_release);
@@ -6456,0 +6416 @@
+#ifdef CONFIG_PM
@@ -6458,0 +6419 @@
+#endif /* CONFIG_PM */
@@ -6460,0 +6422 @@
+EXPORT_SYMBOL_GPL(ata_id_to_dma_mode);
@@ -6470 +6431,0 @@
-EXPORT_SYMBOL_GPL(ata_pci_host_stop);
@@ -6473,0 +6435 @@
+#ifdef CONFIG_PM
@@ -6477,0 +6440 @@
+#endif /* CONFIG_PM */
@@ -6481,0 +6445 @@
+#ifdef CONFIG_PM
@@ -6483,0 +6448 @@
+#endif /* CONFIG_PM */
@@ -6493,0 +6459,5 @@
+EXPORT_SYMBOL_GPL(ata_irq_on);
+EXPORT_SYMBOL_GPL(ata_dummy_irq_on);
+EXPORT_SYMBOL_GPL(ata_irq_ack);
+EXPORT_SYMBOL_GPL(ata_dummy_irq_ack);
+EXPORT_SYMBOL_GPL(ata_dev_try_classify);
--- ./projects/linux/linux-2.6.21/drivers/ata/libata-core.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/ata/libata-core.c	2007-07-09 01:32:17.000000000 +0200
@@ -62 +62 @@
-#define DRV_VERSION	"2.20"	/* must be exactly four chars */
+#define DRV_VERSION	"2.21"	/* must be exactly four chars */
@@ -75 +75 @@
-static unsigned int ata_print_id = 1;
+unsigned int ata_print_id = 1;
@@ -91,0 +92,4 @@
+static int ata_ignore_hpa = 0;
+module_param_named(ignore_hpa, ata_ignore_hpa, int, 0644);
+MODULE_PARM_DESC(ignore_hpa, "Ignore HPA limit (0=keep BIOS limits, 1=ignore limits, using full disk)");
+
@@ -599,2 +603,3 @@
-	if (ata_dev_enabled(dev) && ata_msg_drv(dev->ap)) {
-		ata_dev_printk(dev, KERN_WARNING, "disabled\n");
+	if (ata_dev_enabled(dev)) {
+		if (ata_msg_drv(dev->ap))
+			ata_dev_printk(dev, KERN_WARNING, "disabled\n");
@@ -810,0 +816,200 @@
+static u64 ata_tf_to_lba48(struct ata_taskfile *tf)
+{
+	u64 sectors = 0;
+
+	sectors |= ((u64)(tf->hob_lbah & 0xff)) << 40;
+	sectors |= ((u64)(tf->hob_lbam & 0xff)) << 32;
+	sectors |= (tf->hob_lbal & 0xff) << 24;
+	sectors |= (tf->lbah & 0xff) << 16;
+	sectors |= (tf->lbam & 0xff) << 8;
+	sectors |= (tf->lbal & 0xff);
+
+	return ++sectors;
+}
+
+static u64 ata_tf_to_lba(struct ata_taskfile *tf)
+{
+	u64 sectors = 0;
+
+	sectors |= (tf->device & 0x0f) << 24;
+	sectors |= (tf->lbah & 0xff) << 16;
+	sectors |= (tf->lbam & 0xff) << 8;
+	sectors |= (tf->lbal & 0xff);
+
+	return ++sectors;
+}
+
+/**
+ *	ata_read_native_max_address_ext	-	LBA48 native max query
+ *	@dev: Device to query
+ *
+ *	Perform an LBA48 size query upon the device in question. Return the
+ *	actual LBA48 size or zero if the command fails.
+ */
+
+static u64 ata_read_native_max_address_ext(struct ata_device *dev)
+{
+	unsigned int err;
+	struct ata_taskfile tf;
+
+	ata_tf_init(dev, &tf);
+
+	tf.command = ATA_CMD_READ_NATIVE_MAX_EXT;
+	tf.flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48 | ATA_TFLAG_ISADDR;
+	tf.protocol |= ATA_PROT_NODATA;
+	tf.device |= 0x40;
+
+	err = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
+	if (err)
+		return 0;
+
+	return ata_tf_to_lba48(&tf);
+}
+
+/**
+ *	ata_read_native_max_address	-	LBA28 native max query
+ *	@dev: Device to query
+ *
+ *	Performa an LBA28 size query upon the device in question. Return the
+ *	actual LBA28 size or zero if the command fails.
+ */
+
+static u64 ata_read_native_max_address(struct ata_device *dev)
+{
+	unsigned int err;
+	struct ata_taskfile tf;
+
+	ata_tf_init(dev, &tf);
+
+	tf.command = ATA_CMD_READ_NATIVE_MAX;
+	tf.flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;
+	tf.protocol |= ATA_PROT_NODATA;
+	tf.device |= 0x40;
+
+	err = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
+	if (err)
+		return 0;
+
+	return ata_tf_to_lba(&tf);
+}
+
+/**
+ *	ata_set_native_max_address_ext	-	LBA48 native max set
+ *	@dev: Device to query
+ *	@new_sectors: new max sectors value to set for the device
+ *
+ *	Perform an LBA48 size set max upon the device in question. Return the
+ *	actual LBA48 size or zero if the command fails.
+ */
+
+static u64 ata_set_native_max_address_ext(struct ata_device *dev, u64 new_sectors)
+{
+	unsigned int err;
+	struct ata_taskfile tf;
+
+	new_sectors--;
+
+	ata_tf_init(dev, &tf);
+
+	tf.command = ATA_CMD_SET_MAX_EXT;
+	tf.flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48 | ATA_TFLAG_ISADDR;
+	tf.protocol |= ATA_PROT_NODATA;
+	tf.device |= 0x40;
+
+	tf.lbal = (new_sectors >> 0) & 0xff;
+	tf.lbam = (new_sectors >> 8) & 0xff;
+	tf.lbah = (new_sectors >> 16) & 0xff;
+
+	tf.hob_lbal = (new_sectors >> 24) & 0xff;
+	tf.hob_lbam = (new_sectors >> 32) & 0xff;
+	tf.hob_lbah = (new_sectors >> 40) & 0xff;
+
+	err = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
+	if (err)
+		return 0;
+
+	return ata_tf_to_lba48(&tf);
+}
+
+/**
+ *	ata_set_native_max_address	-	LBA28 native max set
+ *	@dev: Device to query
+ *	@new_sectors: new max sectors value to set for the device
+ *
+ *	Perform an LBA28 size set max upon the device in question. Return the
+ *	actual LBA28 size or zero if the command fails.
+ */
+
+static u64 ata_set_native_max_address(struct ata_device *dev, u64 new_sectors)
+{
+	unsigned int err;
+	struct ata_taskfile tf;
+
+	new_sectors--;
+
+	ata_tf_init(dev, &tf);
+
+	tf.command = ATA_CMD_SET_MAX;
+	tf.flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_ISADDR;
+	tf.protocol |= ATA_PROT_NODATA;
+
+	tf.lbal = (new_sectors >> 0) & 0xff;
+	tf.lbam = (new_sectors >> 8) & 0xff;
+	tf.lbah = (new_sectors >> 16) & 0xff;
+	tf.device |= ((new_sectors >> 24) & 0x0f) | 0x40;
+
+	err = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
+	if (err)
+		return 0;
+
+	return ata_tf_to_lba(&tf);
+}
+
+/**
+ *	ata_hpa_resize		-	Resize a device with an HPA set
+ *	@dev: Device to resize
+ *
+ *	Read the size of an LBA28 or LBA48 disk with HPA features and resize
+ *	it if required to the full size of the media. The caller must check
+ *	the drive has the HPA feature set enabled.
+ */
+
+static u64 ata_hpa_resize(struct ata_device *dev)
+{
+	u64 sectors = dev->n_sectors;
+	u64 hpa_sectors;
+
+	if (ata_id_has_lba48(dev->id))
+		hpa_sectors = ata_read_native_max_address_ext(dev);
+	else
+		hpa_sectors = ata_read_native_max_address(dev);
+
+	if (hpa_sectors > sectors) {
+		ata_dev_printk(dev, KERN_INFO,
+			"Host Protected Area detected:\n"
+			"\tcurrent size: %lld sectors\n"
+			"\tnative size: %lld sectors\n",
+			(long long)sectors, (long long)hpa_sectors);
+
+		if (ata_ignore_hpa) {
+			if (ata_id_has_lba48(dev->id))
+				hpa_sectors = ata_set_native_max_address_ext(dev, hpa_sectors);
+			else
+				hpa_sectors = ata_set_native_max_address(dev,
+								hpa_sectors);
+
+			if (hpa_sectors) {
+				ata_dev_printk(dev, KERN_INFO, "native size "
+					"increased to %lld sectors\n",
+					(long long)hpa_sectors);
+				return hpa_sectors;
+			}
+		}
+	} else if (hpa_sectors < sectors)
+		ata_dev_printk(dev, KERN_WARNING, "%s 1: hpa sectors (%lld) "
+			       "is smaller than sectors (%lld)\n", __FUNCTION__,
+			       (long long)hpa_sectors, (long long)sectors);
+
+	return sectors;
+}
+
@@ -1116 +1321 @@
-	flush_workqueue(ata_wq);
+	cancel_work_sync(&ap->port_task.work); /* akpm: seems unneeded */
@@ -1127 +1332 @@
-		flush_workqueue(ata_wq);
+		cancel_work_sync(&ap->port_task.work);
@@ -1273,6 +1478,10 @@
-	if ((qc->flags & ATA_QCFLAG_FAILED) && !qc->err_mask) {
-		if (ata_msg_warn(ap))
-			ata_dev_printk(dev, KERN_WARNING,
-				"zero err_mask for failed "
-				"internal command, assuming AC_ERR_OTHER\n");
-		qc->err_mask |= AC_ERR_OTHER;
+	/* perform minimal error analysis */
+	if (qc->flags & ATA_QCFLAG_FAILED) {
+		if (qc->result_tf.command & (ATA_ERR | ATA_DF))
+			qc->err_mask |= AC_ERR_DEV;
+
+		if (!qc->err_mask)
+			qc->err_mask |= AC_ERR_OTHER;
+
+		if (qc->err_mask & ~AC_ERR_OTHER)
+			qc->err_mask &= ~AC_ERR_OTHER;
@@ -1385,4 +1594,3 @@
-	int pio;
-	int speed = adev->pio_mode - XFER_PIO_0;
-
-	if (speed < 2)
+	/* Controller doesn't support  IORDY. Probably a pointless check
+	   as the caller should know this */
+	if (adev->ap->flags & ATA_FLAG_NO_IORDY)
@@ -1390 +1598,2 @@
-	if (speed > 2)
+	/* PIO3 and higher it is mandatory */
+	if (adev->pio_mode > XFER_PIO_2)
@@ -1391,0 +1601,5 @@
+	/* We turn it on when possible */
+	if (ata_id_has_iordy(adev->id))
+		return 1;
+	return 0;
+}
@@ -1393 +1607,7 @@
-	/* If we have no drive specific rule, then PIO 2 is non IORDY */
+/**
+ *	ata_pio_mask_no_iordy	-	Return the non IORDY mask
+ *	@adev: ATA device
+ *
+ *	Compute the highest mode possible if we are not using iordy. Return
+ *	-1 if no iordy mode is available.
+ */
@@ -1394,0 +1615,3 @@
+static u32 ata_pio_mask_no_iordy(const struct ata_device *adev)
+{
+	/* If we have no drive specific rule, then PIO 2 is non IORDY */
@@ -1396 +1619 @@
-		pio = adev->id[ATA_ID_EIDE_PIO];
+		u16 pio = adev->id[ATA_ID_EIDE_PIO];
@@ -1401,2 +1624,2 @@
-				return 1;
-			return 0;
+				return 3 << ATA_SHIFT_PIO;
+			return 7 << ATA_SHIFT_PIO;
@@ -1405 +1628 @@
-	return 0;
+	return 3 << ATA_SHIFT_PIO;
@@ -1433,0 +1657 @@
+	int may_fallback = 1, tried_spinup = 0;
@@ -1440 +1663,0 @@
-
@@ -1477,0 +1701,15 @@
+		/* Device or controller might have reported the wrong
+		 * device class.  Give a shot at the other IDENTIFY if
+		 * the current one is aborted by the device.
+		 */
+		if (may_fallback &&
+		    (err_mask == AC_ERR_DEV) && (tf.feature & ATA_ABORTED)) {
+			may_fallback = 0;
+
+			if (class == ATA_DEV_ATA)
+				class = ATA_DEV_ATAPI;
+			else
+				class = ATA_DEV_ATA;
+			goto retry;
+		}
+
@@ -1482,0 +1721,5 @@
+	/* Falling back doesn't make sense if ID data was read
+	 * successfully at least once.
+	 */
+	may_fallback = 0;
+
@@ -1487 +1730 @@
-	reason = "device reports illegal type";
+	reason = "device reports invalid type";
@@ -1496,0 +1740,26 @@
+	if (!tried_spinup && (id[2] == 0x37c8 || id[2] == 0x738c)) {
+		tried_spinup = 1;
+		/*
+		 * Drive powered-up in standby mode, and requires a specific
+		 * SET_FEATURES spin-up subcommand before it will accept
+		 * anything other than the original IDENTIFY command.
+		 */
+		ata_tf_init(dev, &tf);
+		tf.command = ATA_CMD_SET_FEATURES;
+		tf.feature = SETFEATURES_SPINUP;
+		tf.protocol = ATA_PROT_NODATA;
+		tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;
+		err_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
+		if (err_mask) {
+			rc = -EIO;
+			reason = "SPINUP failed";
+			goto err_out;
+		}
+		/*
+		 * If the drive initially returned incomplete IDENTIFY info,
+		 * we now must reissue the IDENTIFY command.
+		 */
+		if (id[2] == 0x37c8)
+			goto retry;
+	}
+
@@ -1563,14 +1831,0 @@
-static void ata_set_port_max_cmd_len(struct ata_port *ap)
-{
-	int i;
-
-	if (ap->scsi_host) {
-		unsigned int len = 0;
-
-		for (i = 0; i < ATA_MAX_DEVICES; i++)
-			len = max(len, ap->device[i].cdb_len);
-
-		ap->scsi_host->max_cmd_len = len;
-	}
-}
-
@@ -1611 +1866 @@
-	rc = ata_acpi_push_id(ap, dev->devno);
+	rc = ata_acpi_push_id(dev);
@@ -1647,0 +1903,7 @@
+	/* SCSI only uses 4-char revisions, dump full 8 chars from ATA */
+	ata_id_c_string(dev->id, fwrevbuf, ATA_ID_FW_REV,
+			sizeof(fwrevbuf));
+
+	ata_id_c_string(dev->id, modelbuf, ATA_ID_PROD,
+			sizeof(modelbuf));
+
@@ -1662,7 +1923,0 @@
-		/* SCSI only uses 4-char revisions, dump full 8 chars from ATA */
-		ata_id_c_string(dev->id, fwrevbuf, ATA_ID_FW_REV,
-				sizeof(fwrevbuf));
-
-		ata_id_c_string(dev->id, modelbuf, ATA_ID_PROD,
-				sizeof(modelbuf));
-
@@ -1686,0 +1942,3 @@
+			if (ata_id_hpa_enabled(dev->id))
+				dev->n_sectors = ata_hpa_resize(dev);
+
@@ -1754 +2012,3 @@
-			ata_dev_printk(dev, KERN_INFO, "ATAPI, max %s%s\n",
+			ata_dev_printk(dev, KERN_INFO,
+				       "ATAPI: %s, %s, max %s%s\n",
+				       modelbuf, fwrevbuf,
@@ -1776,2 +2035,0 @@
-	ata_set_port_max_cmd_len(ap);
-
@@ -1788,5 +2046,2 @@
-		dev->max_sectors = min(ATA_MAX_SECTORS_128, dev->max_sectors);
-
-	/* limit ATAPI DMA to R/W commands only */
-	if (ata_device_blacklisted(dev) & ATA_HORKAGE_DMA_RW_ONLY)
-		dev->horkage |= ATA_HORKAGE_DMA_RW_ONLY;
+		dev->max_sectors = min_t(unsigned int, ATA_MAX_SECTORS_128,
+					 dev->max_sectors);
@@ -1795 +2050 @@
-		ap->ops->dev_config(ap, dev);
+		ap->ops->dev_config(dev);
@@ -1809,0 +2065,50 @@
+ *	ata_cable_40wire	-	return 40 wire cable type
+ *	@ap: port
+ *
+ *	Helper method for drivers which want to hardwire 40 wire cable
+ *	detection.
+ */
+
+int ata_cable_40wire(struct ata_port *ap)
+{
+	return ATA_CBL_PATA40;
+}
+
+/**
+ *	ata_cable_80wire	-	return 80 wire cable type
+ *	@ap: port
+ *
+ *	Helper method for drivers which want to hardwire 80 wire cable
+ *	detection.
+ */
+
+int ata_cable_80wire(struct ata_port *ap)
+{
+	return ATA_CBL_PATA80;
+}
+
+/**
+ *	ata_cable_unknown	-	return unknown PATA cable.
+ *	@ap: port
+ *
+ *	Helper method for drivers which have no PATA cable detection.
+ */
+
+int ata_cable_unknown(struct ata_port *ap)
+{
+	return ATA_CBL_PATA_UNK;
+}
+
+/**
+ *	ata_cable_sata	-	return SATA cable type
+ *	@ap: port
+ *
+ *	Helper method for drivers which have SATA cables
+ */
+
+int ata_cable_sata(struct ata_port *ap)
+{
+	return ATA_CBL_SATA;
+}
+
+/**
@@ -1878,0 +2184,4 @@
+	/* Now ask for the cable type as PDIAG- should have been released */
+	if (ap->ops->cable_detect)
+		ap->cbl = ap->ops->cable_detect(ap);
+
@@ -1961 +2270 @@
-static void sata_print_link_status(struct ata_port *ap)
+void sata_print_link_status(struct ata_port *ap)
@@ -2355,0 +2665,6 @@
+	/* In a few cases quantisation may produce enough errors to
+	   leave t->cycle too low for the sum of active and recovery
+	   if so we must correct this */
+	if (t->active + t->recover > t->cycle)
+		t->cycle = t->active + t->recover;
+
@@ -2484 +2799 @@
- *	ata_set_mode - Program timings and issue SET FEATURES - XFER
+ *	ata_do_set_mode - Program timings and issue SET FEATURES - XFER
@@ -2488,2 +2803,3 @@
- *	Set ATA device disk transfer mode (PIO3, UDMA6, etc.).  If
- *	ata_set_mode() fails, pointer to the failing device is
+ *	Standard implementation of the function used to tune and set
+ *	ATA device disk transfer mode (PIO3, UDMA6, etc.).  If
+ *	ata_dev_set_mode() fails, pointer to the failing device is
@@ -2498 +2814,2 @@
-int ata_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev)
+
+int ata_do_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev)
@@ -2503,3 +2819,0 @@
-	/* has private set_mode? */
-	if (ap->ops->set_mode)
-		return ap->ops->set_mode(ap, r_failed_dev);
@@ -2566 +2880 @@
-		if (!ata_dev_ready(dev))
+		if (!ata_dev_enabled(dev))
@@ -2580,3 +2893,0 @@
-	/* step5: chip specific finalisation */
-	if (ap->ops->post_set_mode)
-		ap->ops->post_set_mode(ap);
@@ -2589,0 +2901,23 @@
+ *	ata_set_mode - Program timings and issue SET FEATURES - XFER
+ *	@ap: port on which timings will be programmed
+ *	@r_failed_dev: out paramter for failed device
+ *
+ *	Set ATA device disk transfer mode (PIO3, UDMA6, etc.).  If
+ *	ata_set_mode() fails, pointer to the failing device is
+ *	returned in @r_failed_dev.
+ *
+ *	LOCKING:
+ *	PCI/etc. bus probe sem.
+ *
+ *	RETURNS:
+ *	0 on success, negative errno otherwise
+ */
+int ata_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev)
+{
+	/* has private set_mode? */
+	if (ap->ops->set_mode)
+		return ap->ops->set_mode(ap, r_failed_dev);
+	return ata_do_set_mode(ap, r_failed_dev);
+}
+
+/**
@@ -2664 +2998,44 @@
-static void ata_bus_post_reset(struct ata_port *ap, unsigned int devmask)
+/**
+ *	ata_wait_ready - sleep until BSY clears, or timeout
+ *	@ap: port containing status register to be polled
+ *	@deadline: deadline jiffies for the operation
+ *
+ *	Sleep until ATA Status register bit BSY clears, or timeout
+ *	occurs.
+ *
+ *	LOCKING:
+ *	Kernel thread context (may sleep).
+ *
+ *	RETURNS:
+ *	0 on success, -errno otherwise.
+ */
+int ata_wait_ready(struct ata_port *ap, unsigned long deadline)
+{
+	unsigned long start = jiffies;
+	int warned = 0;
+
+	while (1) {
+		u8 status = ata_chk_status(ap);
+		unsigned long now = jiffies;
+
+		if (!(status & ATA_BUSY))
+			return 0;
+		if (!ata_port_online(ap) && status == 0xff)
+			return -ENODEV;
+		if (time_after(now, deadline))
+			return -EBUSY;
+
+		if (!warned && time_after(now, start + 5 * HZ) &&
+		    (deadline - now > 3 * HZ)) {
+			ata_port_printk(ap, KERN_WARNING,
+				"port is slow to respond, please be patient "
+				"(Status 0x%x)\n", status);
+			warned = 1;
+		}
+
+		msleep(50);
+	}
+}
+
+static int ata_bus_post_reset(struct ata_port *ap, unsigned int devmask,
+			      unsigned long deadline)
@@ -2669 +3046 @@
-	unsigned long timeout;
+	int rc, ret = 0;
@@ -2674,2 +3051,8 @@
-	if (dev0)
-		ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT);
+	if (dev0) {
+		rc = ata_wait_ready(ap, deadline);
+		if (rc) {
+			if (rc != -ENODEV)
+				return rc;
+			ret = rc;
+		}
+	}
@@ -2677,2 +3060,2 @@
-	/* if device 1 was found in ata_devchk, wait for
-	 * register access, then wait for BSY to clear
+	/* if device 1 was found in ata_devchk, wait for register
+	 * access briefly, then wait for BSY to clear.
@@ -2680,3 +3063,2 @@
-	timeout = jiffies + ATA_TMOUT_BOOT;
-	while (dev1) {
-		u8 nsect, lbal;
+	if (dev1) {
+		int i;
@@ -2685,7 +3067,20 @@
-		nsect = ioread8(ioaddr->nsect_addr);
-		lbal = ioread8(ioaddr->lbal_addr);
-		if ((nsect == 1) && (lbal == 1))
-			break;
-		if (time_after(jiffies, timeout)) {
-			dev1 = 0;
-			break;
+
+		/* Wait for register access.  Some ATAPI devices fail
+		 * to set nsect/lbal after reset, so don't waste too
+		 * much time on it.  We're gonna wait for !BSY anyway.
+		 */
+		for (i = 0; i < 2; i++) {
+			u8 nsect, lbal;
+
+			nsect = ioread8(ioaddr->nsect_addr);
+			lbal = ioread8(ioaddr->lbal_addr);
+			if ((nsect == 1) && (lbal == 1))
+				break;
+			msleep(50);	/* give drive a breather */
+		}
+
+		rc = ata_wait_ready(ap, deadline);
+		if (rc) {
+			if (rc != -ENODEV)
+				return rc;
+			ret = rc;
@@ -2693 +3087,0 @@
-		msleep(50);	/* give drive a breather */
@@ -2695,2 +3088,0 @@
-	if (dev1)
-		ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT);
@@ -2703,0 +3096,2 @@
+
+	return ret;
@@ -2706,2 +3100,2 @@
-static unsigned int ata_bus_softreset(struct ata_port *ap,
-				      unsigned int devmask)
+static int ata_bus_softreset(struct ata_port *ap, unsigned int devmask,
+			     unsigned long deadline)
@@ -2737,3 +3131 @@
-		return 0;
-
-	ata_bus_post_reset(ap, devmask);
+		return -ENODEV;
@@ -2741 +3133 @@
-	return 0;
+	return ata_bus_post_reset(ap, devmask, deadline);
@@ -2769,0 +3162 @@
+	int rc;
@@ -2791,2 +3184,3 @@
-	if (ap->flags & ATA_FLAG_SRST)
-		if (ata_bus_softreset(ap, devmask))
+	if (ap->flags & ATA_FLAG_SRST) {
+		rc = ata_bus_softreset(ap, devmask, jiffies + 40 * HZ);
+		if (rc && rc != -ENODEV)
@@ -2793,0 +3188 @@
+	}
@@ -2834,0 +3230 @@
+ *	@deadline: deadline jiffies for the operation
@@ -2839,2 +3235,2 @@
- *	beginning of the stable state.  Because, after hot unplugging,
- *	DET gets stuck at 1 on some controllers, this functions waits
+ *	beginning of the stable state.  Because DET gets stuck at 1 on
+ *	some controllers after hot unplugging, this functions waits
@@ -2842,0 +3239,3 @@
+ *	@timeout is further limited by @deadline.  The sooner of the
+ *	two is used.
+ *
@@ -2849 +3248,2 @@
-int sata_phy_debounce(struct ata_port *ap, const unsigned long *params)
+int sata_phy_debounce(struct ata_port *ap, const unsigned long *params,
+		      unsigned long deadline)
@@ -2852,3 +3252,2 @@
-	unsigned long duration = params[1] * HZ / 1000;
-	unsigned long timeout = jiffies + params[2] * HZ / 1000;
-	unsigned long last_jiffies;
+	unsigned long duration = msecs_to_jiffies(params[1]);
+	unsigned long last_jiffies, t;
@@ -2857,0 +3257,4 @@
+	t = jiffies + msecs_to_jiffies(params[2]);
+	if (time_before(t, deadline))
+		deadline = t;
+
@@ -2873 +3276 @@
-			if (cur == 1 && time_before(jiffies, timeout))
+			if (cur == 1 && time_before(jiffies, deadline))
@@ -2884,2 +3287,2 @@
-		/* check timeout */
-		if (time_after(jiffies, timeout))
+		/* check deadline */
+		if (time_after(jiffies, deadline))
@@ -2893,0 +3297 @@
+ *	@deadline: deadline jiffies for the operation
@@ -2903 +3307,2 @@
-int sata_phy_resume(struct ata_port *ap, const unsigned long *params)
+int sata_phy_resume(struct ata_port *ap, const unsigned long *params,
+		    unsigned long deadline)
@@ -2921 +3326 @@
-	return sata_phy_debounce(ap, params);
+	return sata_phy_debounce(ap, params, deadline);
@@ -2924,42 +3329,18 @@
-static void ata_wait_spinup(struct ata_port *ap)
-{
-	struct ata_eh_context *ehc = &ap->eh_context;
-	unsigned long end, secs;
-	int rc;
-
-	/* first, debounce phy if SATA */
-	if (ap->cbl == ATA_CBL_SATA) {
-		rc = sata_phy_debounce(ap, sata_deb_timing_hotplug);
-
-		/* if debounced successfully and offline, no need to wait */
-		if ((rc == 0 || rc == -EOPNOTSUPP) && ata_port_offline(ap))
-			return;
-	}
-
-	/* okay, let's give the drive time to spin up */
-	end = ehc->i.hotplug_timestamp + ATA_SPINUP_WAIT * HZ / 1000;
-	secs = ((end - jiffies) + HZ - 1) / HZ;
-
-	if (time_after(jiffies, end))
-		return;
-
-	if (secs > 5)
-		ata_port_printk(ap, KERN_INFO, "waiting for device to spin up "
-				"(%lu secs)\n", secs);
-
-	schedule_timeout_uninterruptible(end - jiffies);
-}
-
-/**
- *	ata_std_prereset - prepare for reset
- *	@ap: ATA port to be reset
- *
- *	@ap is about to be reset.  Initialize it.
- *
- *	LOCKING:
- *	Kernel thread context (may sleep)
- *
- *	RETURNS:
- *	0 on success, -errno otherwise.
- */
-int ata_std_prereset(struct ata_port *ap)
+/**
+ *	ata_std_prereset - prepare for reset
+ *	@ap: ATA port to be reset
+ *	@deadline: deadline jiffies for the operation
+ *
+ *	@ap is about to be reset.  Initialize it.  Failure from
+ *	prereset makes libata abort whole reset sequence and give up
+ *	that port, so prereset should be best-effort.  It does its
+ *	best to prepare for reset sequence but if things go wrong, it
+ *	should just whine, not fail.
+ *
+ *	LOCKING:
+ *	Kernel thread context (may sleep)
+ *
+ *	RETURNS:
+ *	0 on success, -errno otherwise.
+ */
+int ata_std_prereset(struct ata_port *ap, unsigned long deadline)
@@ -2971 +3352 @@
-	/* handle link resume & hotplug spinup */
+	/* handle link resume */
@@ -2976,4 +3356,0 @@
-	if ((ehc->i.flags & ATA_EHI_HOTPLUGGED) &&
-	    (ap->flags & ATA_FLAG_SKIP_D2H_BSY))
-		ata_wait_spinup(ap);
-
@@ -2986,3 +3363,3 @@
-		rc = sata_phy_resume(ap, timing);
-		if (rc && rc != -EOPNOTSUPP) {
-			/* phy resume failed */
+		rc = sata_phy_resume(ap, timing, deadline);
+		/* whine about phy resume failure but proceed */
+		if (rc && rc != -EOPNOTSUPP)
@@ -2991,2 +3367,0 @@
-			return rc;
-		}
@@ -2998,2 +3373,8 @@
-	if (!(ap->flags & ATA_FLAG_SKIP_D2H_BSY) && !ata_port_offline(ap))
-		ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT);
+	if (!(ap->flags & ATA_FLAG_SKIP_D2H_BSY) && !ata_port_offline(ap)) {
+		rc = ata_wait_ready(ap, deadline);
+		if (rc && rc != -ENODEV) {
+			ata_port_printk(ap, KERN_WARNING, "device not ready "
+					"(errno=%d), forcing hardreset\n", rc);
+			ehc->i.action |= ATA_EH_HARDRESET;
+		}
+	}
@@ -3007,0 +3389 @@
+ *	@deadline: deadline jiffies for the operation
@@ -3017 +3399,2 @@
-int ata_std_softreset(struct ata_port *ap, unsigned int *classes)
+int ata_std_softreset(struct ata_port *ap, unsigned int *classes,
+		      unsigned long deadline)
@@ -3020 +3403,2 @@
-	unsigned int devmask = 0, err_mask;
+	unsigned int devmask = 0;
+	int rc;
@@ -3041,5 +3425,5 @@
-	err_mask = ata_bus_softreset(ap, devmask);
-	if (err_mask) {
-		ata_port_printk(ap, KERN_ERR, "SRST failed (err_mask=0x%x)\n",
-				err_mask);
-		return -EIO;
+	rc = ata_bus_softreset(ap, devmask, deadline);
+	/* if link is occupied, -ENODEV too is an error */
+	if (rc && (rc != -ENODEV || sata_scr_valid(ap))) {
+		ata_port_printk(ap, KERN_ERR, "SRST failed (errno=%d)\n", rc);
+		return rc;
@@ -3061,0 +3446 @@
+ *	@deadline: deadline jiffies for the operation
@@ -3071 +3456,2 @@
-int sata_port_hardreset(struct ata_port *ap, const unsigned long *timing)
+int sata_port_hardreset(struct ata_port *ap, const unsigned long *timing,
+			unsigned long deadline)
@@ -3110 +3496 @@
-	rc = sata_phy_resume(ap, timing);
+	rc = sata_phy_resume(ap, timing, deadline);
@@ -3119,0 +3506 @@
+ *	@deadline: deadline jiffies for the operation
@@ -3130 +3517,2 @@
-int sata_std_hardreset(struct ata_port *ap, unsigned int *class)
+int sata_std_hardreset(struct ata_port *ap, unsigned int *class,
+		       unsigned long deadline)
@@ -3138 +3526 @@
-	rc = sata_port_hardreset(ap, timing);
+	rc = sata_port_hardreset(ap, timing, deadline);
@@ -3155 +3543,3 @@
-	if (ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT)) {
+	rc = ata_wait_ready(ap, deadline);
+	/* link occupied, -ENODEV too is an error */
+	if (rc) {
@@ -3157,2 +3547,2 @@
-				"COMRESET failed (device not ready)\n");
-		return -EIO;
+				"COMRESET failed (errno=%d)\n", rc);
+		return rc;
@@ -3239 +3628,0 @@
-	u64 new_n_sectors;
@@ -3251 +3639,0 @@
-	new_n_sectors = ata_id_n_sectors(new_id);
@@ -3265,8 +3652,0 @@
-	if (dev->class == ATA_DEV_ATA && dev->n_sectors != new_n_sectors) {
-		ata_dev_printk(dev, KERN_INFO, "n_sectors mismatch "
-			       "%llu != %llu\n",
-			       (unsigned long long)dev->n_sectors,
-			       (unsigned long long)new_n_sectors);
-		return 0;
-	}
-
@@ -3277,2 +3657,2 @@
- *	ata_dev_revalidate - Revalidate ATA device
- *	@dev: device to revalidate
+ *	ata_dev_reread_id - Re-read IDENTIFY data
+ *	@dev: target ATA device
@@ -3290 +3670 @@
-int ata_dev_revalidate(struct ata_device *dev, unsigned int readid_flags)
+int ata_dev_reread_id(struct ata_device *dev, unsigned int readid_flags)
@@ -3296,5 +3675,0 @@
-	if (!ata_dev_enabled(dev)) {
-		rc = -ENODEV;
-		goto fail;
-	}
-
@@ -3304 +3679 @@
-		goto fail;
+		return rc;
@@ -3307,4 +3682,2 @@
-	if (!ata_dev_same_device(dev, class, id)) {
-		rc = -ENODEV;
-		goto fail;
-	}
+	if (!ata_dev_same_device(dev, class, id))
+		return -ENODEV;
@@ -3312,0 +3686,29 @@
+	return 0;
+}
+
+/**
+ *	ata_dev_revalidate - Revalidate ATA device
+ *	@dev: device to revalidate
+ *	@readid_flags: read ID flags
+ *
+ *	Re-read IDENTIFY page, make sure @dev is still attached to the
+ *	port and reconfigure it according to the new IDENTIFY page.
+ *
+ *	LOCKING:
+ *	Kernel thread context (may sleep)
+ *
+ *	RETURNS:
+ *	0 on success, negative errno otherwise
+ */
+int ata_dev_revalidate(struct ata_device *dev, unsigned int readid_flags)
+{
+	u64 n_sectors = dev->n_sectors;
+	int rc;
+
+	if (!ata_dev_enabled(dev))
+		return -ENODEV;
+
+	/* re-read ID */
+	rc = ata_dev_reread_id(dev, readid_flags);
+	if (rc)
+		goto fail;
@@ -3316,2 +3718,14 @@
-	if (rc == 0)
-		return 0;
+	if (rc)
+		goto fail;
+
+	/* verify n_sectors hasn't changed */
+	if (dev->class == ATA_DEV_ATA && dev->n_sectors != n_sectors) {
+		ata_dev_printk(dev, KERN_INFO, "n_sectors mismatch "
+			       "%llu != %llu\n",
+			       (unsigned long long)n_sectors,
+			       (unsigned long long)dev->n_sectors);
+		rc = -ENODEV;
+		goto fail;
+	}
+
+	return 0;
@@ -3360,0 +3775,2 @@
+	{ "Seagate STT20000A", NULL,		ATA_HORKAGE_NODMA },
+	{ "IOMEGA  ZIP 250       ATAPI", NULL,	ATA_HORKAGE_NODMA }, /* temporary fix */
@@ -3363,2 +3779 @@
-	{ "TORiSAN DVD-ROM DRD-N216", NULL,	ATA_HORKAGE_MAX_SEC_128 |
-						ATA_HORKAGE_DMA_RW_ONLY },
+	{ "TORiSAN DVD-ROM DRD-N216", NULL,	ATA_HORKAGE_MAX_SEC_128 },
@@ -3374,0 +3790 @@
+	{ "Maxtor 6B200M0",	"BANC1B10",	ATA_HORKAGE_NONCQ },
@@ -3381,0 +3798,5 @@
+	/* Drives which do spurious command completion */
+	{ "HTS541680J9SA00",	"SB2IC7EP",	ATA_HORKAGE_NONCQ, },
+	{ "HTS541612J9SA00",	"SBDIC7JP",	ATA_HORKAGE_NONCQ, },
+	{ "Hitachi HTS541616J9SA00", "SB4OC70P", ATA_HORKAGE_NONCQ, },
+	{ "WDC WD740ADFD-00NLR1", NULL,		ATA_HORKAGE_NONCQ, },
@@ -3444,13 +3865 @@
-	/* Apply cable rule here.  Don't apply it early because when
-	 * we handle hot plug the cable type can itself change.
-	 */
-	if (ap->cbl == ATA_CBL_PATA40)
-		xfer_mask &= ~(0xF8 << ATA_SHIFT_UDMA);
-	/* Apply drive side cable rule. Unknown or 80 pin cables reported
-	 * host side are checked drive side as well. Cases where we know a
-	 * 40wire cable is used safely for 80 are not checked here.
-	 */
-        if (ata_drive_40wire(dev->id) && (ap->cbl == ATA_CBL_PATA_UNK || ap->cbl == ATA_CBL_PATA80))
-		xfer_mask &= ~(0xF8 << ATA_SHIFT_UDMA);
-
-
+	/* drive modes available */
@@ -3484,0 +3894,3 @@
+	if (ap->flags & ATA_FLAG_NO_IORDY)
+		xfer_mask &= ata_pio_mask_no_iordy(dev);
+
@@ -3486 +3898,20 @@
-		xfer_mask = ap->ops->mode_filter(ap, dev, xfer_mask);
+		xfer_mask = ap->ops->mode_filter(dev, xfer_mask);
+
+	/* Apply cable rule here.  Don't apply it early because when
+	 * we handle hot plug the cable type can itself change.
+	 * Check this last so that we know if the transfer rate was
+	 * solely limited by the cable.
+	 * Unknown or 80 wire cables reported host side are checked
+	 * drive side as well. Cases where we know a 40wire cable
+	 * is used safely for 80 are not checked here.
+	 */
+	if (xfer_mask & (0xF8 << ATA_SHIFT_UDMA))
+		/* UDMA/44 or higher would be available */
+		if((ap->cbl == ATA_CBL_PATA40) ||
+   		    (ata_drive_40wire(dev->id) &&
+		     (ap->cbl == ATA_CBL_PATA_UNK ||
+                     ap->cbl == ATA_CBL_PATA80))) {
+		      	ata_dev_printk(dev, KERN_WARNING,
+				 "limited to UDMA/33 due to 40-wire cable\n");
+			xfer_mask &= ~(0xF8 << ATA_SHIFT_UDMA);
+		}
@@ -3513,0 +3945,3 @@
+	/* Some controllers and ATAPI devices show flaky interrupt
+	 * behavior after setting xfer mode.  Use polling instead.
+	 */
@@ -3517 +3951 @@
-	tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;
+	tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE | ATA_TFLAG_POLLING;
@@ -3673,0 +4108 @@
+
@@ -3691 +4125,0 @@
-	int rc = 0; /* Assume ATAPI DMA is OK by default */
@@ -3693,19 +4127,5 @@
-	/* some drives can only do ATAPI DMA on read/write */
-	if (unlikely(qc->dev->horkage & ATA_HORKAGE_DMA_RW_ONLY)) {
-		struct scsi_cmnd *cmd = qc->scsicmd;
-		u8 *scsicmd = cmd->cmnd;
-
-		switch (scsicmd[0]) {
-		case READ_10:
-		case WRITE_10:
-		case READ_12:
-		case WRITE_12:
-		case READ_6:
-		case WRITE_6:
-			/* atapi dma maybe ok */
-			break;
-		default:
-			/* turn off atapi dma */
-			return 1;
-		}
-	}
+	/* Don't allow DMA if it isn't multiple of 16 bytes.  Quite a
+	 * few ATAPI devices choke on such DMA requests.
+	 */
+	if (unlikely(qc->nbytes & 15))
+		return 1;
@@ -3714 +4134 @@
-		rc = ap->ops->check_atapi_dma(qc);
+		return ap->ops->check_atapi_dma(qc);
@@ -3716 +4136 @@
-	return rc;
+	return 0;
@@ -3717,0 +4138 @@
+
@@ -4025 +4446 @@
- *	ata_pio_sector - Transfer ATA_SECT_SIZE (512 bytes) of data.
+ *	ata_pio_sector - Transfer a sector of data.
@@ -4028 +4449 @@
- *	Transfer ATA_SECT_SIZE of data from/to the ATA device.
+ *	Transfer qc->sect_size bytes of data from/to the ATA device.
@@ -4043 +4464 @@
-	if (qc->curbytes == qc->nbytes - ATA_SECT_SIZE)
+	if (qc->curbytes == qc->nbytes - qc->sect_size)
@@ -4063 +4484 @@
-		ap->ops->data_xfer(qc->dev, buf + offset, ATA_SECT_SIZE, do_write);
+		ap->ops->data_xfer(qc->dev, buf + offset, qc->sect_size, do_write);
@@ -4069 +4490 @@
-		ap->ops->data_xfer(qc->dev, buf + offset, ATA_SECT_SIZE, do_write);
+		ap->ops->data_xfer(qc->dev, buf + offset, qc->sect_size, do_write);
@@ -4072,2 +4493,2 @@
-	qc->curbytes += ATA_SECT_SIZE;
-	qc->cursg_ofs += ATA_SECT_SIZE;
+	qc->curbytes += qc->sect_size;
+	qc->cursg_ofs += qc->sect_size;
@@ -4082 +4503 @@
- *	ata_pio_sectors - Transfer one or many 512-byte sectors.
+ *	ata_pio_sectors - Transfer one or many sectors.
@@ -4085 +4506 @@
- *	Transfer one or many ATA_SECT_SIZE of data from/to the
+ *	Transfer one or many sectors of data from/to the
@@ -4100 +4521 @@
-		nsect = min((qc->nbytes - qc->curbytes) / ATA_SECT_SIZE,
+		nsect = min((qc->nbytes - qc->curbytes) / qc->sect_size,
@@ -4364,2 +4784,0 @@
-
-	ata_altstatus(ap); /* flush */
@@ -4995,8 +5413,0 @@
-	/* Some controllers show flaky interrupt behavior after
-	 * setting xfer mode.  Use polling instead.
-	 */
-	if (unlikely(qc->tf.command == ATA_CMD_SET_FEATURES &&
-		     qc->tf.feature == SETFEATURES_XFER) &&
-	    (ap->flags & ATA_FLAG_SETXFER_POLLING))
-		qc->tf.flags |= ATA_TFLAG_POLLING;
-
@@ -5463 +5874 @@
-	int i, j, rc;
+	int rc;
@@ -5466,28 +5877,2 @@
-	if (rc)
-		goto fail;
-
-	/* EH is quiescent now.  Fail if we have any ready device.
-	 * This happens if hotplug occurs between completion of device
-	 * suspension and here.
-	 */
-	for (i = 0; i < host->n_ports; i++) {
-		struct ata_port *ap = host->ports[i];
-
-		for (j = 0; j < ATA_MAX_DEVICES; j++) {
-			struct ata_device *dev = &ap->device[j];
-
-			if (ata_dev_ready(dev)) {
-				ata_port_printk(ap, KERN_WARNING,
-						"suspend failed, device %d "
-						"still active\n", dev->devno);
-				rc = -EBUSY;
-				goto fail;
-			}
-		}
-	}
-
-	host->dev->power.power_state = mesg;
-	return 0;
-
- fail:
-	ata_host_resume(host);
+	if (rc == 0)
+		host->dev->power.power_state = mesg;
@@ -5580,5 +5965,2 @@
- *	ata_port_init - Initialize an ata_port structure
- *	@ap: Structure to initialize
- *	@host: Collection of hosts to which @ap belongs
- *	@ent: Probe information provided by low-level driver
- *	@port_no: Port number associated with this ata_port
+ *	ata_port_alloc - allocate and initialize basic ATA port resources
+ *	@host: ATA host this allocated port belongs to
@@ -5586 +5968,4 @@
- *	Initialize a new ata_port structure.
+ *	Allocate and initialize basic ATA port resources.
+ *
+ *	RETURNS:
+ *	Allocate ATA port on success, NULL on failure.
@@ -5589 +5974 @@
- *	Inherited from caller.
+ *	Inherited from calling layer (may sleep).
@@ -5591,2 +5976 @@
-void ata_port_init(struct ata_port *ap, struct ata_host *host,
-		   const struct ata_probe_ent *ent, unsigned int port_no)
+struct ata_port *ata_port_alloc(struct ata_host *host)
@@ -5593,0 +5978 @@
+	struct ata_port *ap;
@@ -5595,0 +5981,7 @@
+	DPRINTK("ENTER\n");
+
+	ap = kzalloc(sizeof(*ap), GFP_KERNEL);
+	if (!ap)
+		return NULL;
+
+	ap->pflags |= ATA_PFLAG_INITIALIZING;
@@ -5598 +5990 @@
-	ap->print_id = ata_print_id++;
+	ap->print_id = -1;
@@ -5601,15 +5993,2 @@
-	ap->dev = ent->dev;
-	ap->port_no = port_no;
-	if (port_no == 1 && ent->pinfo2) {
-		ap->pio_mask = ent->pinfo2->pio_mask;
-		ap->mwdma_mask = ent->pinfo2->mwdma_mask;
-		ap->udma_mask = ent->pinfo2->udma_mask;
-		ap->flags |= ent->pinfo2->flags;
-		ap->ops = ent->pinfo2->port_ops;
-	} else {
-		ap->pio_mask = ent->pio_mask;
-		ap->mwdma_mask = ent->mwdma_mask;
-		ap->udma_mask = ent->udma_mask;
-		ap->flags |= ent->port_flags;
-		ap->ops = ent->port_ops;
-	}
+	ap->dev = host->dev;
+
@@ -5635 +6013,0 @@
-	/* set cable type */
@@ -5637,2 +6014,0 @@
-	if (ap->flags & ATA_FLAG_SATA)
-		ap->cbl = ATA_CBL_SATA;
@@ -5650,0 +6027,2 @@
+	return ap;
+}
@@ -5652 +6030,32 @@
-	memcpy(&ap->ioaddr, &ent->port[port_no], sizeof(struct ata_ioports));
+static void ata_host_release(struct device *gendev, void *res)
+{
+	struct ata_host *host = dev_get_drvdata(gendev);
+	int i;
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
+		if (!ap)
+			continue;
+
+		if ((host->flags & ATA_HOST_STARTED) && ap->ops->port_stop)
+			ap->ops->port_stop(ap);
+	}
+
+	if ((host->flags & ATA_HOST_STARTED) && host->ops->host_stop)
+		host->ops->host_stop(host);
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
+		if (!ap)
+			continue;
+
+		if (ap->scsi_host)
+			scsi_host_put(ap->scsi_host);
+
+		kfree(ap);
+		host->ports[i] = NULL;
+	}
+
+	dev_set_drvdata(gendev, NULL);
@@ -5656,3 +6065,7 @@
- *	ata_port_init_shost - Initialize SCSI host associated with ATA port
- *	@ap: ATA port to initialize SCSI host for
- *	@shost: SCSI host associated with @ap
+ *	ata_host_alloc - allocate and init basic ATA host resources
+ *	@dev: generic device this host is associated with
+ *	@max_ports: maximum number of ATA ports associated with this host
+ *
+ *	Allocate and initialize basic ATA host resources.  LLD calls
+ *	this function to allocate a host, initializes it fully and
+ *	attaches it using ata_host_register().
@@ -5660 +6073,7 @@
- *	Initialize SCSI host @shost associated with ATA port @ap.
+ *	@max_ports ports are allocated and host->n_ports is
+ *	initialized to @max_ports.  The caller is allowed to decrease
+ *	host->n_ports before calling ata_host_register().  The unused
+ *	ports will be automatically freed on registration.
+ *
+ *	RETURNS:
+ *	Allocate ATA host on success, NULL on failure.
@@ -5663 +6082 @@
- *	Inherited from caller.
+ *	Inherited from calling layer (may sleep).
@@ -5665 +6084 @@
-static void ata_port_init_shost(struct ata_port *ap, struct Scsi_Host *shost)
+struct ata_host *ata_host_alloc(struct device *dev, int max_ports)
@@ -5667 +6086,8 @@
-	ap->scsi_host = shost;
+	struct ata_host *host;
+	size_t sz;
+	int i;
+
+	DPRINTK("ENTER\n");
+
+	if (!devres_open_group(dev, NULL, GFP_KERNEL))
+		return NULL;
@@ -5669,5 +6095,32 @@
-	shost->unique_id = ap->print_id;
-	shost->max_id = 16;
-	shost->max_lun = 1;
-	shost->max_channel = 1;
-	shost->max_cmd_len = 12;
+	/* alloc a container for our list of ATA ports (buses) */
+	sz = sizeof(struct ata_host) + (max_ports + 1) * sizeof(void *);
+	/* alloc a container for our list of ATA ports (buses) */
+	host = devres_alloc(ata_host_release, sz, GFP_KERNEL);
+	if (!host)
+		goto err_out;
+
+	devres_add(dev, host);
+	dev_set_drvdata(dev, host);
+
+	spin_lock_init(&host->lock);
+	host->dev = dev;
+	host->n_ports = max_ports;
+
+	/* allocate ports bound to this host */
+	for (i = 0; i < max_ports; i++) {
+		struct ata_port *ap;
+
+		ap = ata_port_alloc(host);
+		if (!ap)
+			goto err_out;
+
+		ap->port_no = i;
+		host->ports[i] = ap;
+	}
+
+	devres_remove_group(dev, NULL);
+	return host;
+
+ err_out:
+	devres_release_group(dev, NULL);
+	return NULL;
@@ -5677,4 +6130,4 @@
- *	ata_port_add - Attach low-level ATA driver to system
- *	@ent: Information provided by low-level driver
- *	@host: Collections of ports to which we add
- *	@port_no: Port number associated with this host
+ *	ata_host_alloc_pinfo - alloc host and init with port_info array
+ *	@dev: generic device this host is associated with
+ *	@ppi: array of ATA port_info to initialize host with
+ *	@n_ports: number of ATA ports attached to this host
@@ -5682,4 +6135,3 @@
- *	Attach low-level ATA driver to system.
- *
- *	LOCKING:
- *	PCI/etc. bus probe sem.
+ *	Allocate ATA host and initialize with info from @ppi.  If NULL
+ *	terminated, @ppi may contain fewer entries than @n_ports.  The
+ *	last entry will be used for the remaining ports.
@@ -5688 +6140,4 @@
- *	New ata_port on success, for NULL on error.
+ *	Allocate ATA host on success, NULL on failure.
+ *
+ *	LOCKING:
+ *	Inherited from calling layer (may sleep).
@@ -5690,3 +6145,3 @@
-static struct ata_port * ata_port_add(const struct ata_probe_ent *ent,
-				      struct ata_host *host,
-				      unsigned int port_no)
+struct ata_host *ata_host_alloc_pinfo(struct device *dev,
+				      const struct ata_port_info * const * ppi,
+				      int n_ports)
@@ -5694,4 +6149,3 @@
-	struct Scsi_Host *shost;
-	struct ata_port *ap;
-
-	DPRINTK("ENTER\n");
+	const struct ata_port_info *pi;
+	struct ata_host *host;
+	int i, j;
@@ -5699,4 +6153,2 @@
-	if (!ent->port_ops->error_handler &&
-	    !(ent->port_flags & (ATA_FLAG_SATA_RESET | ATA_FLAG_SRST))) {
-		printk(KERN_ERR "ata%u: no reset mechanism available\n",
-		       port_no);
+	host = ata_host_alloc(dev, n_ports);
+	if (!host)
@@ -5704 +6155,0 @@
-	}
@@ -5706,3 +6157,2 @@
-	shost = scsi_host_alloc(ent->sht, sizeof(struct ata_port));
-	if (!shost)
-		return NULL;
+	for (i = 0, j = 0, pi = NULL; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
@@ -5710 +6160,2 @@
-	shost->transportt = &ata_scsi_transport_template;
+		if (ppi[j])
+			pi = ppi[j++];
@@ -5712 +6163,5 @@
-	ap = ata_shost_to_port(shost);
+		ap->pio_mask = pi->pio_mask;
+		ap->mwdma_mask = pi->mwdma_mask;
+		ap->udma_mask = pi->udma_mask;
+		ap->flags |= pi->flags;
+		ap->ops = pi->port_ops;
@@ -5714,2 +6169,5 @@
-	ata_port_init(ap, host, ent, port_no);
-	ata_port_init_shost(ap, shost);
+		if (!host->ops && (pi->port_ops != &ata_dummy_port_ops))
+			host->ops = pi->port_ops;
+		if (!host->private_data && pi->private_data)
+			host->private_data = pi->private_data;
+	}
@@ -5717 +6175 @@
-	return ap;
+	return host;
@@ -5720 +6178,17 @@
-static void ata_host_release(struct device *gendev, void *res)
+/**
+ *	ata_host_start - start and freeze ports of an ATA host
+ *	@host: ATA host to start ports for
+ *
+ *	Start and then freeze ports of @host.  Started status is
+ *	recorded in host->flags, so this function can be called
+ *	multiple times.  Ports are guaranteed to get started only
+ *	once.  If host->ops isn't initialized yet, its set to the
+ *	first non-dummy port ops.
+ *
+ *	LOCKING:
+ *	Inherited from calling layer (may sleep).
+ *
+ *	RETURNS:
+ *	0 if all ports are started successfully, -errno otherwise.
+ */
+int ata_host_start(struct ata_host *host)
@@ -5722,2 +6196,4 @@
-	struct ata_host *host = dev_get_drvdata(gendev);
-	int i;
+	int i, rc;
+
+	if (host->flags & ATA_HOST_STARTED)
+		return 0;
@@ -5728,2 +6204,13 @@
-		if (ap && ap->ops->port_stop)
-			ap->ops->port_stop(ap);
+		if (!host->ops && !ata_port_is_dummy(ap))
+			host->ops = ap->ops;
+
+		if (ap->ops->port_start) {
+			rc = ap->ops->port_start(ap);
+			if (rc) {
+				ata_port_printk(ap, KERN_ERR, "failed to "
+						"start port (errno=%d)\n", rc);
+				goto err_out;
+			}
+		}
+
+		ata_eh_freeze_port(ap);
@@ -5732,2 +6219,2 @@
-	if (host->ops->host_stop)
-		host->ops->host_stop(host);
+	host->flags |= ATA_HOST_STARTED;
+	return 0;
@@ -5735 +6222,2 @@
-	for (i = 0; i < host->n_ports; i++) {
+ err_out:
+	while (--i >= 0) {
@@ -5738,4 +6226,2 @@
-		if (ap)
-			scsi_host_put(ap->scsi_host);
-
-		host->ports[i] = NULL;
+		if (ap->ops->port_stop)
+			ap->ops->port_stop(ap);
@@ -5743,2 +6229 @@
-
-	dev_set_drvdata(gendev, NULL);
+	return rc;
@@ -5758 +6243 @@
-
+/* KILLME - the only user left is ipr */
@@ -5769,7 +6254,3 @@
- *	ata_device_add - Register hardware device with ATA and SCSI layers
- *	@ent: Probe information describing hardware device to be registered
- *
- *	This function processes the information provided in the probe
- *	information struct @ent, allocates the necessary ATA and SCSI
- *	host information structures, initializes them, and registers
- *	everything with requisite kernel subsystems.
+ *	ata_host_register - register initialized ATA host
+ *	@host: ATA host to register
+ *	@sht: template for SCSI host
@@ -5777,2 +6258,4 @@
- *	This function requests irqs, probes the ATA bus, and probes
- *	the SCSI bus.
+ *	Register initialized ATA host.  @host is allocated using
+ *	ata_host_alloc() and fully initialized by LLD.  This function
+ *	starts ports, registers @host with ATA and SCSI layers and
+ *	probe registered devices.
@@ -5781 +6264 @@
- *	PCI/etc. bus probe sem.
+ *	Inherited from calling layer (may sleep).
@@ -5784 +6267 @@
- *	Number of ports registered.  Zero on error (no ports registered).
+ *	0 on success, -errno otherwise.
@@ -5786 +6269 @@
-int ata_device_add(const struct ata_probe_ent *ent)
+int ata_host_register(struct ata_host *host, struct scsi_host_template *sht)
@@ -5788,6 +6271 @@
-	unsigned int i;
-	struct device *dev = ent->dev;
-	struct ata_host *host;
-	int rc;
-
-	DPRINTK("ENTER\n");
+	int i, rc;
@@ -5795,3 +6273,6 @@
-	if (ent->irq == 0) {
-		dev_printk(KERN_ERR, dev, "is not available: No interrupt assigned.\n");
-		return 0;
+	/* host must have been started */
+	if (!(host->flags & ATA_HOST_STARTED)) {
+		dev_printk(KERN_ERR, host->dev,
+			   "BUG: trying to register unstarted host\n");
+		WARN_ON(1);
+		return -EINVAL;
@@ -5800,2 +6281,6 @@
-	if (!devres_open_group(dev, ata_device_add, GFP_KERNEL))
-		return 0;
+	/* Blow away unused ports.  This happens when LLD can't
+	 * determine the exact number of ports to allocate at
+	 * allocation time.
+	 */
+	for (i = host->n_ports; host->ports[i]; i++)
+		kfree(host->ports[i]);
@@ -5803,7 +6288,3 @@
-	/* alloc a container for our list of ATA ports (buses) */
-	host = devres_alloc(ata_host_release, sizeof(struct ata_host) +
-			    (ent->n_ports * sizeof(void *)), GFP_KERNEL);
-	if (!host)
-		goto err_out;
-	devres_add(dev, host);
-	dev_set_drvdata(dev, host);
+	/* give ports names and add SCSI hosts */
+	for (i = 0; i < host->n_ports; i++)
+		host->ports[i]->print_id = ata_print_id++;
@@ -5811,6 +6292,3 @@
-	ata_host_init(host, dev, ent->_host_flags, ent->port_ops);
-	host->n_ports = ent->n_ports;
-	host->irq = ent->irq;
-	host->irq2 = ent->irq2;
-	host->iomap = ent->iomap;
-	host->private_data = ent->private_data;
+	rc = ata_scsi_add_hosts(host, sht);
+	if (rc)
+		return rc;
@@ -5818 +6296 @@
-	/* register each port bound to this device */
+	/* set cable, sata_spd_limit and report */
@@ -5820,3 +6298,4 @@
-		struct ata_port *ap;
-		unsigned long xfer_mode_mask;
-		int irq_line = ent->irq;
+		struct ata_port *ap = host->ports[i];
+		int irq_line;
+		u32 scontrol;
+		unsigned long xfer_mask;
@@ -5824,4 +6303,3 @@
-		ap = ata_port_add(ent, host, i);
-		host->ports[i] = ap;
-		if (!ap)
-			goto err_out;
+		/* set SATA cable type if still unset */
+		if (ap->cbl == ATA_CBL_NONE && (ap->flags & ATA_FLAG_SATA))
+			ap->cbl = ATA_CBL_SATA;
@@ -5829,5 +6307,5 @@
-		/* dummy? */
-		if (ent->dummy_port_mask & (1 << i)) {
-			ata_port_printk(ap, KERN_INFO, "DUMMY\n");
-			ap->ops = &ata_dummy_port_ops;
-			continue;
+		/* init sata_spd_limit to the current value */
+		if (sata_scr_read(ap, SCR_CONTROL, &scontrol) == 0) {
+			int spd = (scontrol >> 4) & 0xf;
+			if (spd)
+				ap->hw_sata_spd_limit &= (1 << spd) - 1;
@@ -5834,0 +6313 @@
+		ap->sata_spd_limit = ap->hw_sata_spd_limit;
@@ -5836,7 +6315,4 @@
-		/* start port */
-		rc = ap->ops->port_start(ap);
-		if (rc) {
-			host->ports[i] = NULL;
-			scsi_host_put(ap->scsi_host);
-			goto err_out;
-		}
+		/* report the secondary IRQ for second channel legacy */
+		irq_line = host->irq;
+		if (i == 1 && host->irq2)
+			irq_line = host->irq2;
@@ -5844,7 +6320,2 @@
-		/* Report the secondary IRQ for second channel legacy */
-		if (i == 1 && ent->irq2)
-			irq_line = ent->irq2;
-
-		xfer_mode_mask =(ap->udma_mask << ATA_SHIFT_UDMA) |
-				(ap->mwdma_mask << ATA_SHIFT_MWDMA) |
-				(ap->pio_mask << ATA_SHIFT_PIO);
+		xfer_mask = ata_pack_xfermask(ap->pio_mask, ap->mwdma_mask,
+					      ap->udma_mask);
@@ -5853,36 +6324,11 @@
-		ata_port_printk(ap, KERN_INFO, "%cATA max %s cmd 0x%p "
-				"ctl 0x%p bmdma 0x%p irq %d\n",
-				ap->flags & ATA_FLAG_SATA ? 'S' : 'P',
-				ata_mode_string(xfer_mode_mask),
-				ap->ioaddr.cmd_addr,
-				ap->ioaddr.ctl_addr,
-				ap->ioaddr.bmdma_addr,
-				irq_line);
-
-		/* freeze port before requesting IRQ */
-		ata_eh_freeze_port(ap);
-	}
-
-	/* obtain irq, that may be shared between channels */
-	rc = devm_request_irq(dev, ent->irq, ent->port_ops->irq_handler,
-			      ent->irq_flags, DRV_NAME, host);
-	if (rc) {
-		dev_printk(KERN_ERR, dev, "irq %lu request failed: %d\n",
-			   ent->irq, rc);
-		goto err_out;
-	}
-
-	/* do we have a second IRQ for the other channel, eg legacy mode */
-	if (ent->irq2) {
-		/* We will get weird core code crashes later if this is true
-		   so trap it now */
-		BUG_ON(ent->irq == ent->irq2);
-
-		rc = devm_request_irq(dev, ent->irq2,
-				ent->port_ops->irq_handler, ent->irq_flags,
-				DRV_NAME, host);
-		if (rc) {
-			dev_printk(KERN_ERR, dev, "irq %lu request failed: %d\n",
-				   ent->irq2, rc);
-			goto err_out;
-		}
+		if (!ata_port_is_dummy(ap))
+			ata_port_printk(ap, KERN_INFO, "%cATA max %s cmd 0x%p "
+					"ctl 0x%p bmdma 0x%p irq %d\n",
+					ap->cbl == ATA_CBL_SATA ? 'S' : 'P',
+					ata_mode_string(xfer_mask),
+					ap->ioaddr.cmd_addr,
+					ap->ioaddr.ctl_addr,
+					ap->ioaddr.bmdma_addr,
+					irq_line);
+		else
+			ata_port_printk(ap, KERN_INFO, "DUMMY\n");
@@ -5891,3 +6336,0 @@
-	/* resource acquisition complete */
-	devres_remove_group(dev, ata_device_add);
-
@@ -5898 +6340,0 @@
-		u32 scontrol;
@@ -5901,17 +6343 @@
-		/* init sata_spd_limit to the current value */
-		if (sata_scr_read(ap, SCR_CONTROL, &scontrol) == 0) {
-			int spd = (scontrol >> 4) & 0xf;
-			ap->hw_sata_spd_limit &= (1 << spd) - 1;
-		}
-		ap->sata_spd_limit = ap->hw_sata_spd_limit;
-
-		rc = scsi_add_host(ap->scsi_host, dev);
-		if (rc) {
-			ata_port_printk(ap, KERN_ERR, "scsi_add_host failed\n");
-			/* FIXME: do something useful here */
-			/* FIXME: handle unconditional calls to
-			 * scsi_scan_host and ata_host_remove, below,
-			 * at the very least
-			 */
-		}
-
+		/* probe */
@@ -5930,0 +6357 @@
+			ap->pflags &= ~ATA_PFLAG_INITIALIZING;
@@ -5962,6 +6388,0 @@
-	VPRINTK("EXIT, returning %u\n", ent->n_ports);
-	return ent->n_ports; /* success */
-
- err_out:
-	devres_release_group(dev, ata_device_add);
-	VPRINTK("EXIT, returning %d\n", rc);
@@ -5971,0 +6393,45 @@
+ *	ata_host_activate - start host, request IRQ and register it
+ *	@host: target ATA host
+ *	@irq: IRQ to request
+ *	@irq_handler: irq_handler used when requesting IRQ
+ *	@irq_flags: irq_flags used when requesting IRQ
+ *	@sht: scsi_host_template to use when registering the host
+ *
+ *	After allocating an ATA host and initializing it, most libata
+ *	LLDs perform three steps to activate the host - start host,
+ *	request IRQ and register it.  This helper takes necessasry
+ *	arguments and performs the three steps in one go.
+ *
+ *	LOCKING:
+ *	Inherited from calling layer (may sleep).
+ *
+ *	RETURNS:
+ *	0 on success, -errno otherwise.
+ */
+int ata_host_activate(struct ata_host *host, int irq,
+		      irq_handler_t irq_handler, unsigned long irq_flags,
+		      struct scsi_host_template *sht)
+{
+	int rc;
+
+	rc = ata_host_start(host);
+	if (rc)
+		return rc;
+
+	rc = devm_request_irq(host->dev, irq, irq_handler, irq_flags,
+			      dev_driver_string(host->dev), host);
+	if (rc)
+		return rc;
+
+	/* Used to print device info at probe */
+	host->irq = irq;
+
+	rc = ata_host_register(host, sht);
+	/* if failed, just free the IRQ and leave ports alone */
+	if (rc)
+		devm_free_irq(host->dev, irq, host);
+
+	return rc;
+}
+
+/**
@@ -6020 +6486 @@
-	flush_workqueue(ata_aux_wq);
+	cancel_work_sync(&ap->hotplug_task.work); /* akpm: why? */
@@ -6022 +6488 @@
-	flush_workqueue(ata_aux_wq);
+	cancel_work_sync(&ap->hotplug_task.work);
@@ -6046,26 +6511,0 @@
-struct ata_probe_ent *
-ata_probe_ent_alloc(struct device *dev, const struct ata_port_info *port)
-{
-	struct ata_probe_ent *probe_ent;
-
-	probe_ent = devm_kzalloc(dev, sizeof(*probe_ent), GFP_KERNEL);
-	if (!probe_ent) {
-		printk(KERN_ERR DRV_NAME "(%s): out of memory\n",
-		       kobject_name(&(dev->kobj)));
-		return NULL;
-	}
-
-	INIT_LIST_HEAD(&probe_ent->node);
-	probe_ent->dev = dev;
-
-	probe_ent->sht = port->sht;
-	probe_ent->port_flags = port->flags;
-	probe_ent->pio_mask = port->pio_mask;
-	probe_ent->mwdma_mask = port->mwdma_mask;
-	probe_ent->udma_mask = port->udma_mask;
-	probe_ent->port_ops = port->port_ops;
-	probe_ent->private_data = port->private_data;
-
-	return probe_ent;
-}
-
@@ -6336,0 +6777,4 @@
+const struct ata_port_info ata_dummy_port_info = {
+	.port_ops		= &ata_dummy_port_ops,
+};
+
@@ -6347,0 +6792 @@
+EXPORT_SYMBOL_GPL(ata_dummy_port_info);
@@ -6351 +6796,5 @@
-EXPORT_SYMBOL_GPL(ata_device_add);
+EXPORT_SYMBOL_GPL(ata_host_alloc);
+EXPORT_SYMBOL_GPL(ata_host_alloc_pinfo);
+EXPORT_SYMBOL_GPL(ata_host_start);
+EXPORT_SYMBOL_GPL(ata_host_register);
+EXPORT_SYMBOL_GPL(ata_host_activate);
@@ -6362,0 +6812 @@
+EXPORT_SYMBOL_GPL(sata_print_link_status);
@@ -6368,0 +6819 @@
+EXPORT_SYMBOL_GPL(ata_sff_port_start);
@@ -6369,0 +6821 @@
+EXPORT_SYMBOL_GPL(ata_do_set_mode);
@@ -6402,0 +6855 @@
+EXPORT_SYMBOL_GPL(ata_wait_ready);
@@ -6432 +6885,3 @@
-EXPORT_SYMBOL_GPL(ata_pci_init_native_mode);
+EXPORT_SYMBOL_GPL(ata_pci_init_native_host);
+EXPORT_SYMBOL_GPL(ata_pci_init_bmdma);
+EXPORT_SYMBOL_GPL(ata_pci_prepare_native_host);
@@ -6445,5 +6899,0 @@
-#ifdef CONFIG_PM
-EXPORT_SYMBOL_GPL(ata_scsi_device_suspend);
-EXPORT_SYMBOL_GPL(ata_scsi_device_resume);
-#endif /* CONFIG_PM */
-
@@ -6463,0 +6914,5 @@
+
+EXPORT_SYMBOL_GPL(ata_cable_40wire);
+EXPORT_SYMBOL_GPL(ata_cable_80wire);
+EXPORT_SYMBOL_GPL(ata_cable_unknown);
+EXPORT_SYMBOL_GPL(ata_cable_sata);
--- ./projects/linux/linux-2.6.22/drivers/ata/libata-core.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/ata/libata-core.c	2007-10-09 22:31:38.000000000 +0200
@@ -73,0 +74 @@
+static unsigned long ata_dev_blacklisted(const struct ata_device *dev);
@@ -113 +113,0 @@
- *	@fis: Buffer into which data will output
@@ -114,0 +115,2 @@
+ *	@is_cmd: This FIS is for command
+ *	@fis: Buffer into which data will output
@@ -122,2 +124 @@
-
-void ata_tf_to_fis(const struct ata_taskfile *tf, u8 *fis, u8 pmp)
+void ata_tf_to_fis(const struct ata_taskfile *tf, u8 pmp, int is_cmd, u8 *fis)
@@ -125,3 +126,5 @@
-	fis[0] = 0x27;	/* Register - Host to Device FIS */
-	fis[1] = (pmp & 0xf) | (1 << 7); /* Port multiplier number,
-					    bit 7 indicates Command FIS */
+	fis[0] = 0x27;			/* Register - Host to Device FIS */
+	fis[1] = pmp & 0xf;		/* Port multiplier number*/
+	if (is_cmd)
+		fis[1] |= (1 << 7);	/* bit 7 indicates Command FIS */
+
@@ -1286,5 +1288,0 @@
-	int rc;
-
-	if (ap->pflags & ATA_PFLAG_FLUSH_PORT_TASK)
-		return;
-
@@ -1294,4 +1292,2 @@
-	rc = queue_delayed_work(ata_wq, &ap->port_task, delay);
-
-	/* rc == 0 means that another user is using port task */
-	WARN_ON(rc == 0);
+	/* may fail if ata_port_flush_task() in progress */
+	queue_delayed_work(ata_wq, &ap->port_task, delay);
@@ -1312,2 +1307,0 @@
-	unsigned long flags;
-
@@ -1316,22 +1310 @@
-	spin_lock_irqsave(ap->lock, flags);
-	ap->pflags |= ATA_PFLAG_FLUSH_PORT_TASK;
-	spin_unlock_irqrestore(ap->lock, flags);
-
-	DPRINTK("flush #1\n");
-	cancel_work_sync(&ap->port_task.work); /* akpm: seems unneeded */
-
-	/*
-	 * At this point, if a task is running, it's guaranteed to see
-	 * the FLUSH flag; thus, it will never queue pio tasks again.
-	 * Cancel and flush.
-	 */
-	if (!cancel_delayed_work(&ap->port_task)) {
-		if (ata_msg_ctl(ap))
-			ata_port_printk(ap, KERN_DEBUG, "%s: flush #2\n",
-					__FUNCTION__);
-		cancel_work_sync(&ap->port_task.work);
-	}
-
-	spin_lock_irqsave(ap->lock, flags);
-	ap->pflags &= ~ATA_PFLAG_FLUSH_PORT_TASK;
-	spin_unlock_irqrestore(ap->lock, flags);
+	cancel_rearming_delayed_work(&ap->port_task);
@@ -1753 +1726 @@
-		if (err_mask) {
+		if (err_mask && id[2] != 0x738c) {
@@ -1817 +1790 @@
-	if (ata_device_blacklisted(dev) & ATA_HORKAGE_NONCQ) {
+	if (dev->horkage & ATA_HORKAGE_NONCQ) {
@@ -1848 +1821,2 @@
-	int print_info = ap->eh_context.i.flags & ATA_EHI_PRINTINFO;
+	struct ata_eh_context *ehc = &ap->eh_context;
+	int print_info = ehc->i.flags & ATA_EHI_PRINTINFO;
@@ -1865,6 +1839,2 @@
-	/* set _SDD */
-	rc = ata_acpi_push_id(dev);
-	if (rc) {
-		ata_dev_printk(dev, KERN_WARNING, "failed to set _SDD(%d)\n",
-			rc);
-	}
+	/* set horkage */
+	dev->horkage |= ata_dev_blacklisted(dev);
@@ -1872,2 +1842,4 @@
-	/* retrieve and execute the ATA task file of _GTF */
-	ata_acpi_exec_tfs(ap);
+	/* let ACPI work its magic */
+	rc = ata_acpi_on_devcfg(dev);
+	if (rc)
+		return rc;
@@ -1942,2 +1914,3 @@
-			if (ata_id_hpa_enabled(dev->id))
-				dev->n_sectors = ata_hpa_resize(dev);
+			if (!(dev->horkage & ATA_HORKAGE_BROKEN_HPA) &&
+			    ata_id_hpa_enabled(dev->id))
+ 				dev->n_sectors = ata_hpa_resize(dev);
@@ -2045 +2018 @@
-	if (ata_device_blacklisted(dev) & ATA_HORKAGE_MAX_SEC_128)
+	if (dev->horkage & ATA_HORKAGE_MAX_SEC_128)
@@ -2419,0 +2393,6 @@
+	if (!sata_scr_valid(ap))
+		return -EOPNOTSUPP;
+
+	/* If SCR can be read, use it to determine the current SPD.
+	 * If not, use cached value in ap->sata_spd.
+	 */
@@ -2421,2 +2400,4 @@
-	if (rc)
-		return rc;
+	if (rc == 0)
+		spd = (sstatus >> 4) & 0xf;
+	else
+		spd = ap->sata_spd;
@@ -2426,0 +2408,2 @@
+
+	/* unconditionally mask off the highest bit */
@@ -2430,5 +2413,9 @@
-	spd = (sstatus >> 4) & 0xf;
-	if (spd <= 1)
-		return -EINVAL;
-	spd--;
-	mask &= (1 << spd) - 1;
+	/* Mask off all speeds higher than or equal to the current
+	 * one.  Force 1.5Gbps if current SPD is not available.
+	 */
+	if (spd > 1)
+		mask &= (1 << (spd - 1)) - 1;
+	else
+		mask &= 1;
+
+	/* were we already at the bottom? */
@@ -3197,3 +3183,0 @@
-	/* re-enable interrupts */
-	ap->ops->irq_on(ap);
-
@@ -3287 +3271,3 @@
-		/* check deadline */
+		/* Check deadline.  If debouncing failed, return
+		 * -EPIPE to tell upper layer to lower link speed.
+		 */
@@ -3289 +3275 @@
-			return -EBUSY;
+			return -EPIPE;
@@ -3362 +3348 @@
-	if (ap->cbl == ATA_CBL_SATA) {
+	if (ap->flags & ATA_FLAG_SATA) {
@@ -3584,4 +3569,0 @@
-	/* re-enable interrupts */
-	if (!ap->ops->error_handler)
-		ap->ops->irq_on(ap);
-
@@ -3722 +3704,2 @@
-	if (dev->class == ATA_DEV_ATA && dev->n_sectors != n_sectors) {
+	if (dev->class == ATA_DEV_ATA && n_sectors &&
+	    dev->n_sectors != n_sectors) {
@@ -3726,0 +3710,4 @@
+
+		/* restore original n_sectors */
+		dev->n_sectors = n_sectors;
+
@@ -3776,0 +3764,2 @@
+	{ "IOMEGA  ZIP 250       ATAPI       Floppy",
+				NULL,		ATA_HORKAGE_NODMA },
@@ -3789,0 +3779 @@
+	{ "Maxtor 6B200M0",	"BANC1BM0",	ATA_HORKAGE_NONCQ },
@@ -3790,0 +3781,5 @@
+	{ "Maxtor 7B250S0",	"BANC1B70",	ATA_HORKAGE_NONCQ, },
+	{ "Maxtor 7B300S0",	"BANC1B70",	ATA_HORKAGE_NONCQ },
+	{ "Maxtor 7V300F0",	"VA111630",	ATA_HORKAGE_NONCQ },
+	{ "HITACHI HDS7250SASUN500G 0621KTAWSD", "K2AOAJ0AHITACHI",
+	 ATA_HORKAGE_NONCQ },
@@ -3803,2 +3798,10 @@
-
-	/* Devices with NCQ limits */
+	{ "FUJITSU MHV2080BH",	"00840028",	ATA_HORKAGE_NONCQ, },
+	{ "ST9160821AS",	"3.CLF",	ATA_HORKAGE_NONCQ, },
+	{ "ST3160812AS",	"3.AD",		ATA_HORKAGE_NONCQ, },
+	{ "SAMSUNG HD401LJ",	"ZZ100-15",	ATA_HORKAGE_NONCQ, },
+
+	/* devices which puke on READ_NATIVE_MAX */
+	{ "HDS724040KLSA80",	"KFAOA20N",	ATA_HORKAGE_BROKEN_HPA, },
+	{ "WDC WD3200JD-00KLB0", "WD-WCAMR1130137", ATA_HORKAGE_BROKEN_HPA },
+	{ "WDC WD2500JD-00HBB0", "WD-WMAL71490727", ATA_HORKAGE_BROKEN_HPA },
+	{ "MAXTOR 6L080L4",	"A93.0500",	ATA_HORKAGE_BROKEN_HPA },
@@ -3810 +3813 @@
-unsigned long ata_device_blacklisted(const struct ata_device *dev)
+static unsigned long ata_dev_blacklisted(const struct ata_device *dev)
@@ -3840 +3843 @@
-	return (ata_device_blacklisted(dev) & ATA_HORKAGE_NODMA) ? 1 : 0;
+	return (dev->horkage & ATA_HORKAGE_NODMA) ? 1 : 0;
@@ -3993,0 +3997,5 @@
+	/* A clean abort indicates an original or just out of spec drive
+	   and we should continue as we issue the setup based on the
+	   drive reported working geometry */
+	if (err_mask == AC_ERR_DEV && (tf.feature & ATA_ABORTED))
+		err_mask = 0;
@@ -4109,0 +4118,62 @@
+ *	ata_fill_sg_dumb - Fill PCI IDE PRD table
+ *	@qc: Metadata associated with taskfile to be transferred
+ *
+ *	Fill PCI IDE PRD (scatter-gather) table with segments
+ *	associated with the current disk command. Perform the fill
+ *	so that we avoid writing any length 64K records for
+ *	controllers that don't follow the spec.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host lock)
+ *
+ */
+static void ata_fill_sg_dumb(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	struct scatterlist *sg;
+	unsigned int idx;
+
+	WARN_ON(qc->__sg == NULL);
+	WARN_ON(qc->n_elem == 0 && qc->pad_len == 0);
+
+	idx = 0;
+	ata_for_each_sg(sg, qc) {
+		u32 addr, offset;
+		u32 sg_len, len, blen;
+
+ 		/* determine if physical DMA addr spans 64K boundary.
+		 * Note h/w doesn't support 64-bit, so we unconditionally
+		 * truncate dma_addr_t to u32.
+		 */
+		addr = (u32) sg_dma_address(sg);
+		sg_len = sg_dma_len(sg);
+
+		while (sg_len) {
+			offset = addr & 0xffff;
+			len = sg_len;
+			if ((offset + sg_len) > 0x10000)
+				len = 0x10000 - offset;
+
+			blen = len & 0xffff;
+			ap->prd[idx].addr = cpu_to_le32(addr);
+			if (blen == 0) {
+			   /* Some PATA chipsets like the CS5530 can't
+			      cope with 0x0000 meaning 64K as the spec says */
+				ap->prd[idx].flags_len = cpu_to_le32(0x8000);
+				blen = 0x8000;
+				ap->prd[++idx].addr = cpu_to_le32(addr + 0x8000);
+			}
+			ap->prd[idx].flags_len = cpu_to_le32(blen);
+			VPRINTK("PRD[%u] = (0x%X, 0x%X)\n", idx, addr, len);
+
+			idx++;
+			sg_len -= len;
+			addr += len;
+		}
+	}
+
+	if (idx)
+		ap->prd[idx - 1].flags_len |= cpu_to_le32(ATA_PRD_EOT);
+}
+
+/**
@@ -4155,0 +4226,17 @@
+/**
+ *	ata_dumb_qc_prep - Prepare taskfile for submission
+ *	@qc: Metadata associated with taskfile to be prepared
+ *
+ *	Prepare ATA taskfile for submission.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host lock)
+ */
+void ata_dumb_qc_prep(struct ata_queued_cmd *qc)
+{
+	if (!(qc->flags & ATA_QCFLAG_DMAMAP))
+		return;
+
+	ata_fill_sg_dumb(qc);
+}
+
@@ -5663 +5750 @@
-	return ap->cbl == ATA_CBL_SATA && ap->ops->scr_read;
+	return (ap->flags & ATA_FLAG_SATA) && ap->ops->scr_read;
@@ -5684,4 +5771,2 @@
-	if (sata_scr_valid(ap)) {
-		*val = ap->ops->scr_read(ap, reg);
-		return 0;
-	}
+	if (sata_scr_valid(ap))
+		return ap->ops->scr_read(ap, reg, val);
@@ -5709,4 +5794,2 @@
-	if (sata_scr_valid(ap)) {
-		ap->ops->scr_write(ap, reg, val);
-		return 0;
-	}
+	if (sata_scr_valid(ap))
+		return ap->ops->scr_write(ap, reg, val);
@@ -5732,0 +5816,2 @@
+	int rc;
+
@@ -5734,3 +5819,4 @@
-		ap->ops->scr_write(ap, reg, val);
-		ap->ops->scr_read(ap, reg);
-		return 0;
+		rc = ap->ops->scr_write(ap, reg, val);
+		if (rc == 0)
+			rc = ap->ops->scr_read(ap, reg, &val);
+		return rc;
@@ -5947,0 +6034 @@
+	ap->sata_spd = 0;
@@ -5954,0 +6042 @@
+	dev->horkage = 0;
@@ -6012,0 +6101,3 @@
+	init_timer_deferrable(&ap->fastdrain_timer);
+	ap->fastdrain_timer.function = ata_eh_fastdrain_timerfn;
+	ap->fastdrain_timer.data = (unsigned long)ap;
@@ -6295,0 +6387,3 @@
+	/* associate with ACPI nodes */
+	ata_acpi_associate(host);
+
@@ -6327 +6421 @@
-					ap->cbl == ATA_CBL_SATA ? 'S' : 'P',
+					(ap->flags & ATA_FLAG_SATA) ? 'S' : 'P',
@@ -6386 +6480 @@
-		ata_scsi_scan_host(ap);
+		ata_scsi_scan_host(ap, 1);
@@ -6482,7 +6576 @@
-
-	/* Flush hotplug task.  The sequence is similar to
-	 * ata_port_flush_task().
-	 */
-	cancel_work_sync(&ap->hotplug_task.work); /* akpm: why? */
-	cancel_delayed_work(&ap->hotplug_task);
-	cancel_work_sync(&ap->hotplug_task.work);
+	cancel_rearming_delayed_work(&ap->hotplug_task);
@@ -6824,0 +6913 @@
+EXPORT_SYMBOL_GPL(ata_dumb_qc_prep);
@@ -6876 +6964,0 @@
-EXPORT_SYMBOL_GPL(ata_device_blacklisted);
@@ -6885 +6973 @@
-EXPORT_SYMBOL_GPL(ata_pci_init_native_host);
+EXPORT_SYMBOL_GPL(ata_pci_init_sff_host);
@@ -6887 +6975 @@
-EXPORT_SYMBOL_GPL(ata_pci_prepare_native_host);
+EXPORT_SYMBOL_GPL(ata_pci_prepare_sff_host);
@@ -6899,0 +6988,3 @@
+EXPORT_SYMBOL_GPL(__ata_ehi_push_desc);
+EXPORT_SYMBOL_GPL(ata_ehi_push_desc);
+EXPORT_SYMBOL_GPL(ata_ehi_clear_desc);
--- ./projects/linux/linux-2.6.23/drivers/ata/libata-core.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/ata/libata-core.c	2008-01-24 23:58:37.000000000 +0100
@@ -32,0 +33,8 @@
+ *  Standards documents from:
+ *	http://www.t13.org (ATA standards, PCI DMA IDE spec)
+ *	http://www.t10.org (SCSI MMC - for ATAPI MMC)
+ *	http://www.sata-io.org (SATA)
+ *	http://www.compactflash.org (CF)
+ *	http://www.qic.org (QIC157 - Tape and DSC)
+ *	http://www.ce-ata.org (CE-ATA: not supported)
+ *
@@ -51,0 +60 @@
+#include <linux/io.h>
@@ -56 +64,0 @@
-#include <asm/io.h>
@@ -58,0 +67 @@
+#include <linux/cdrom.h>
@@ -62,2 +70,0 @@
-#define DRV_VERSION	"2.21"	/* must be exactly four chars */
-
@@ -72,0 +80,2 @@
+static unsigned int ata_dev_set_feature(struct ata_device *dev,
+					u8 enable, u8 feature);
@@ -88,0 +98,4 @@
+int atapi_passthru16 = 1;
+module_param(atapi_passthru16, int, 0444);
+MODULE_PARM_DESC(atapi_passthru16, "Enable ATA_16 passthru for ATAPI devices; on by default (0=off, 1=on)");
+
@@ -93 +106 @@
-static int ata_ignore_hpa = 0;
+static int ata_ignore_hpa;
@@ -96,0 +110,4 @@
+static int libata_dma_mask = ATA_DMA_MASK_ATA|ATA_DMA_MASK_ATAPI|ATA_DMA_MASK_CFA;
+module_param_named(dma, libata_dma_mask, int, 0444);
+MODULE_PARM_DESC(dma, "DMA enable/disable (0x1==ATA, 0x2==ATAPI, 0x4==CF)");
+
@@ -101 +118 @@
-int libata_noacpi = 1;
+int libata_noacpi = 0;
@@ -103 +120 @@
-MODULE_PARM_DESC(noacpi, "Disables the use of ACPI in suspend/resume when set");
+MODULE_PARM_DESC(noacpi, "Disables the use of ACPI in probe/suspend/resume when set");
@@ -238 +255 @@
-	} else if (lba48 && (dev->ap->flags & ATA_FLAG_PIO_LBA48)) {
+	} else if (lba48 && (dev->link->ap->flags & ATA_FLAG_PIO_LBA48)) {
@@ -607 +624 @@
-		if (ata_msg_drv(dev->ap))
+		if (ata_msg_drv(dev->link->ap))
@@ -608,0 +626 @@
+		ata_acpi_on_disable(dev);
@@ -614,0 +633,177 @@
+static int ata_dev_set_dipm(struct ata_device *dev, enum link_pm policy)
+{
+	struct ata_link *link = dev->link;
+	struct ata_port *ap = link->ap;
+	u32 scontrol;
+	unsigned int err_mask;
+	int rc;
+
+	/*
+	 * disallow DIPM for drivers which haven't set
+	 * ATA_FLAG_IPM.  This is because when DIPM is enabled,
+	 * phy ready will be set in the interrupt status on
+	 * state changes, which will cause some drivers to
+	 * think there are errors - additionally drivers will
+	 * need to disable hot plug.
+	 */
+	if (!(ap->flags & ATA_FLAG_IPM) || !ata_dev_enabled(dev)) {
+		ap->pm_policy = NOT_AVAILABLE;
+		return -EINVAL;
+	}
+
+	/*
+	 * For DIPM, we will only enable it for the
+	 * min_power setting.
+	 *
+	 * Why?  Because Disks are too stupid to know that
+	 * If the host rejects a request to go to SLUMBER
+	 * they should retry at PARTIAL, and instead it
+	 * just would give up.  So, for medium_power to
+	 * work at all, we need to only allow HIPM.
+	 */
+	rc = sata_scr_read(link, SCR_CONTROL, &scontrol);
+	if (rc)
+		return rc;
+
+	switch (policy) {
+	case MIN_POWER:
+		/* no restrictions on IPM transitions */
+		scontrol &= ~(0x3 << 8);
+		rc = sata_scr_write(link, SCR_CONTROL, scontrol);
+		if (rc)
+			return rc;
+
+		/* enable DIPM */
+		if (dev->flags & ATA_DFLAG_DIPM)
+			err_mask = ata_dev_set_feature(dev,
+					SETFEATURES_SATA_ENABLE, SATA_DIPM);
+		break;
+	case MEDIUM_POWER:
+		/* allow IPM to PARTIAL */
+		scontrol &= ~(0x1 << 8);
+		scontrol |= (0x2 << 8);
+		rc = sata_scr_write(link, SCR_CONTROL, scontrol);
+		if (rc)
+			return rc;
+
+		/*
+		 * we don't have to disable DIPM since IPM flags
+		 * disallow transitions to SLUMBER, which effectively
+		 * disable DIPM if it does not support PARTIAL
+		 */
+		break;
+	case NOT_AVAILABLE:
+	case MAX_PERFORMANCE:
+		/* disable all IPM transitions */
+		scontrol |= (0x3 << 8);
+		rc = sata_scr_write(link, SCR_CONTROL, scontrol);
+		if (rc)
+			return rc;
+
+		/*
+		 * we don't have to disable DIPM since IPM flags
+		 * disallow all transitions which effectively
+		 * disable DIPM anyway.
+		 */
+		break;
+	}
+
+	/* FIXME: handle SET FEATURES failure */
+	(void) err_mask;
+
+	return 0;
+}
+
+/**
+ *	ata_dev_enable_pm - enable SATA interface power management
+ *	@dev:  device to enable power management
+ *	@policy: the link power management policy
+ *
+ *	Enable SATA Interface power management.  This will enable
+ *	Device Interface Power Management (DIPM) for min_power
+ * 	policy, and then call driver specific callbacks for
+ *	enabling Host Initiated Power management.
+ *
+ *	Locking: Caller.
+ *	Returns: -EINVAL if IPM is not supported, 0 otherwise.
+ */
+void ata_dev_enable_pm(struct ata_device *dev, enum link_pm policy)
+{
+	int rc = 0;
+	struct ata_port *ap = dev->link->ap;
+
+	/* set HIPM first, then DIPM */
+	if (ap->ops->enable_pm)
+		rc = ap->ops->enable_pm(ap, policy);
+	if (rc)
+		goto enable_pm_out;
+	rc = ata_dev_set_dipm(dev, policy);
+
+enable_pm_out:
+	if (rc)
+		ap->pm_policy = MAX_PERFORMANCE;
+	else
+		ap->pm_policy = policy;
+	return /* rc */;	/* hopefully we can use 'rc' eventually */
+}
+
+#ifdef CONFIG_PM
+/**
+ *	ata_dev_disable_pm - disable SATA interface power management
+ *	@dev: device to disable power management
+ *
+ *	Disable SATA Interface power management.  This will disable
+ *	Device Interface Power Management (DIPM) without changing
+ * 	policy,  call driver specific callbacks for disabling Host
+ * 	Initiated Power management.
+ *
+ *	Locking: Caller.
+ *	Returns: void
+ */
+static void ata_dev_disable_pm(struct ata_device *dev)
+{
+	struct ata_port *ap = dev->link->ap;
+
+	ata_dev_set_dipm(dev, MAX_PERFORMANCE);
+	if (ap->ops->disable_pm)
+		ap->ops->disable_pm(ap);
+}
+#endif	/* CONFIG_PM */
+
+void ata_lpm_schedule(struct ata_port *ap, enum link_pm policy)
+{
+	ap->pm_policy = policy;
+	ap->link.eh_info.action |= ATA_EHI_LPM;
+	ap->link.eh_info.flags |= ATA_EHI_NO_AUTOPSY;
+	ata_port_schedule_eh(ap);
+}
+
+#ifdef CONFIG_PM
+static void ata_lpm_enable(struct ata_host *host)
+{
+	struct ata_link *link;
+	struct ata_port *ap;
+	struct ata_device *dev;
+	int i;
+
+	for (i = 0; i < host->n_ports; i++) {
+		ap = host->ports[i];
+		ata_port_for_each_link(link, ap) {
+			ata_link_for_each_dev(dev, link)
+				ata_dev_disable_pm(dev);
+		}
+	}
+}
+
+static void ata_lpm_disable(struct ata_host *host)
+{
+	int i;
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+		ata_lpm_schedule(ap, ap->pm_policy);
+	}
+}
+#endif	/* CONFIG_PM */
+
+
@@ -670,2 +865,2 @@
- *	Device type, %ATA_DEV_ATA, %ATA_DEV_ATAPI, or %ATA_DEV_UNKNOWN
- *	the event of failure.
+ *	Device type, %ATA_DEV_ATA, %ATA_DEV_ATAPI, %ATA_DEV_PMP or
+ *	%ATA_DEV_UNKNOWN the event of failure.
@@ -673 +867,0 @@
-
@@ -678,0 +873,14 @@
+	 *
+	 * ATA/ATAPI-7 (d1532v1r1: Feb. 19, 2003) specified separate
+	 * signatures for ATA and ATAPI devices attached on SerialATA,
+	 * 0x3c/0xc3 and 0x69/0x96 respectively.  However, SerialATA
+	 * spec has never mentioned about using different signatures
+	 * for ATA/ATAPI devices.  Then, Serial ATA II: Port
+	 * Multiplier specification began to use 0x69/0x96 to identify
+	 * port multpliers and 0x3c/0xc3 to identify SEMB device.
+	 * ATA/ATAPI-7 dropped descriptions about 0x3c/0xc3 and
+	 * 0x69/0x96 shortly and described them as reserved for
+	 * SerialATA.
+	 *
+	 * We follow the current spec and consider that 0x69/0x96
+	 * identifies a port multiplier and 0x3c/0xc3 a SEMB device.
@@ -680,3 +888 @@
-
-	if (((tf->lbam == 0) && (tf->lbah == 0)) ||
-	    ((tf->lbam == 0x3c) && (tf->lbah == 0xc3))) {
+	if ((tf->lbam == 0) && (tf->lbah == 0)) {
@@ -687,2 +893 @@
-	if (((tf->lbam == 0x14) && (tf->lbah == 0xeb)) ||
-	    ((tf->lbam == 0x69) && (tf->lbah == 0x96))) {
+	if ((tf->lbam == 0x14) && (tf->lbah == 0xeb)) {
@@ -692,0 +898,10 @@
+	if ((tf->lbam == 0x69) && (tf->lbah == 0x96)) {
+		DPRINTK("found PMP device by sig\n");
+		return ATA_DEV_PMP;
+	}
+
+	if ((tf->lbam == 0x3c) && (tf->lbah == 0xc3)) {
+		printk(KERN_INFO "ata: SEMB device ignored\n");
+		return ATA_DEV_SEMB_UNSUP; /* not yet */
+	}
+
@@ -699,2 +914,2 @@
- *	@ap: ATA channel to examine
- *	@device: Device to examine (starting at zero)
+ *	@dev: ATA device to classify (starting at zero)
+ *	@present: device seems present
@@ -718,3 +933,2 @@
-
-unsigned int
-ata_dev_try_classify(struct ata_port *ap, unsigned int device, u8 *r_err)
+unsigned int ata_dev_try_classify(struct ata_device *dev, int present,
+				  u8 *r_err)
@@ -721,0 +936 @@
+	struct ata_port *ap = dev->link->ap;
@@ -726 +941 @@
-	ap->ops->dev_select(ap, device);
+	ap->ops->dev_select(ap, dev->devno);
@@ -736 +951 @@
-	if (err == 0 && device == 0)
+	if (err == 0 && dev->devno == 0)
@@ -738 +953 @@
-		ap->device[device].horkage |= ATA_HORKAGE_DIAGNOSTIC;
+		dev->horkage |= ATA_HORKAGE_DIAGNOSTIC;
@@ -741 +956 @@
-	else if ((device == 0) && (err == 0x81))
+	else if ((dev->devno == 0) && (err == 0x81))
@@ -749,4 +964,14 @@
-	if (class == ATA_DEV_UNKNOWN)
-		return ATA_DEV_NONE;
-	if ((class == ATA_DEV_ATA) && (ata_chk_status(ap) == 0))
-		return ATA_DEV_NONE;
+	if (class == ATA_DEV_UNKNOWN) {
+		/* If the device failed diagnostic, it's likely to
+		 * have reported incorrect device signature too.
+		 * Assume ATA device if the device seems present but
+		 * device signature is invalid with diagnostic
+		 * failure.
+		 */
+		if (present && (dev->horkage & ATA_HORKAGE_DIAGNOSTIC))
+			class = ATA_DEV_ATA;
+		else
+			class = ATA_DEV_NONE;
+	} else if ((class == ATA_DEV_ATA) && (ata_chk_status(ap) == 0))
+		class = ATA_DEV_NONE;
+
@@ -818,0 +1044,15 @@
+static u64 ata_id_n_sectors(const u16 *id)
+{
+	if (ata_id_has_lba(id)) {
+		if (ata_id_has_lba48(id))
+			return ata_id_u64(id, 100);
+		else
+			return ata_id_u32(id, 60);
+	} else {
+		if (ata_id_current_chs_valid(id))
+			return ata_id_u32(id, 57);
+		else
+			return id[1] * id[3] * id[6];
+	}
+}
+
@@ -846,2 +1086,3 @@
- *	ata_read_native_max_address_ext	-	LBA48 native max query
- *	@dev: Device to query
+ *	ata_read_native_max_address - Read native max address
+ *	@dev: target device
+ *	@max_sectors: out parameter for the result native max address
@@ -849,26 +1090,2 @@
- *	Perform an LBA48 size query upon the device in question. Return the
- *	actual LBA48 size or zero if the command fails.
- */
-
-static u64 ata_read_native_max_address_ext(struct ata_device *dev)
-{
-	unsigned int err;
-	struct ata_taskfile tf;
-
-	ata_tf_init(dev, &tf);
-
-	tf.command = ATA_CMD_READ_NATIVE_MAX_EXT;
-	tf.flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48 | ATA_TFLAG_ISADDR;
-	tf.protocol |= ATA_PROT_NODATA;
-	tf.device |= 0x40;
-
-	err = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
-	if (err)
-		return 0;
-
-	return ata_tf_to_lba48(&tf);
-}
-
-/**
- *	ata_read_native_max_address	-	LBA28 native max query
- *	@dev: Device to query
+ *	Perform an LBA48 or LBA28 native size query upon the device in
+ *	question.
@@ -876,2 +1093,3 @@
- *	Performa an LBA28 size query upon the device in question. Return the
- *	actual LBA28 size or zero if the command fails.
+ *	RETURNS:
+ *	0 on success, -EACCES if command is aborted by the drive.
+ *	-EIO on other errors.
@@ -879,2 +1097 @@
-
-static u64 ata_read_native_max_address(struct ata_device *dev)
+static int ata_read_native_max_address(struct ata_device *dev, u64 *max_sectors)
@@ -882 +1099 @@
-	unsigned int err;
+	unsigned int err_mask;
@@ -883,0 +1101 @@
+	int lba48 = ata_id_has_lba48(dev->id);
@@ -887 +1105 @@
-	tf.command = ATA_CMD_READ_NATIVE_MAX;
+	/* always clear all address registers */
@@ -889,6 +1106,0 @@
-	tf.protocol |= ATA_PROT_NODATA;
-	tf.device |= 0x40;
-
-	err = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
-	if (err)
-		return 0;
@@ -896,20 +1108,5 @@
-	return ata_tf_to_lba(&tf);
-}
-
-/**
- *	ata_set_native_max_address_ext	-	LBA48 native max set
- *	@dev: Device to query
- *	@new_sectors: new max sectors value to set for the device
- *
- *	Perform an LBA48 size set max upon the device in question. Return the
- *	actual LBA48 size or zero if the command fails.
- */
-
-static u64 ata_set_native_max_address_ext(struct ata_device *dev, u64 new_sectors)
-{
-	unsigned int err;
-	struct ata_taskfile tf;
-
-	new_sectors--;
-
-	ata_tf_init(dev, &tf);
+	if (lba48) {
+		tf.command = ATA_CMD_READ_NATIVE_MAX_EXT;
+		tf.flags |= ATA_TFLAG_LBA48;
+	} else
+		tf.command = ATA_CMD_READ_NATIVE_MAX;
@@ -917,2 +1113,0 @@
-	tf.command = ATA_CMD_SET_MAX_EXT;
-	tf.flags |= ATA_TFLAG_DEVICE | ATA_TFLAG_LBA48 | ATA_TFLAG_ISADDR;
@@ -920,5 +1115 @@
-	tf.device |= 0x40;
-
-	tf.lbal = (new_sectors >> 0) & 0xff;
-	tf.lbam = (new_sectors >> 8) & 0xff;
-	tf.lbah = (new_sectors >> 16) & 0xff;
+	tf.device |= ATA_LBA;
@@ -926,7 +1117,8 @@
-	tf.hob_lbal = (new_sectors >> 24) & 0xff;
-	tf.hob_lbam = (new_sectors >> 32) & 0xff;
-	tf.hob_lbah = (new_sectors >> 40) & 0xff;
-
-	err = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
-	if (err)
-		return 0;
+	err_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);
+	if (err_mask) {
+		ata_dev_printk(dev, KERN_WARNING, "failed to read native "
+			       "max address (err_mask=0x%x)\n", err_mask);
+		if (err_mask == AC_ERR_DEV && (tf.feature & ATA_ABORTED))
+			return -EACCES;
+		return -EIO;
+	}
@@ -934 +1126,7 @@
-	return ata_tf_to_lba48(&tf);
+	if (lba48)
+		*max_sectors = ata_tf_to_lba48(&tf);
+	else
+		*max_sectors = ata_tf_to_lba(&tf);
+	if (dev->horkage & ATA_HORKAGE_HPA_SIZE)
+		(*max_sectors)--;
+	return 0;
@@ -938,2 +1136,2 @@
- *	ata_set_native_max_address	-	LBA28 native max set
- *	@dev: Device to query
+ *	ata_set_max_sectors - Set max sectors
+ *	@dev: target device
@@ -942,2 +1140,6 @@
- *	Perform an LBA28 size set max upon the device in question. Return the
- *	actual LBA28 size or zero if the command fails.
+ *	Set max sectors of @dev to @new_sectors.
+ *
+ *	RETURNS:
+ *	0 on success, -EACCES if command is aborted or denied (due to
+ *	previous non-volatile SET_MAX) by the drive.  -EIO on other
+ *	errors.
@@ -945,2 +1147 @@
-
-static u64 ata_set_native_max_address(struct ata_device *dev, u64 new_sectors)
+static int ata_set_max_sectors(struct ata_device *dev, u64 new_sectors)
@@ -948 +1149 @@
-	unsigned int err;
+	unsigned int err_mask;
@@ -949,0 +1151 @@
+	int lba48 = ata_id_has_lba48(dev->id);
@@ -955 +1156,0 @@
-	tf.command = ATA_CMD_SET_MAX;
@@ -956,0 +1158,14 @@
+
+	if (lba48) {
+		tf.command = ATA_CMD_SET_MAX_EXT;
+		tf.flags |= ATA_TFLAG_LBA48;
+
+		tf.hob_lbal = (new_sectors >> 24) & 0xff;
+		tf.hob_lbam = (new_sectors >> 32) & 0xff;
+		tf.hob_lbah = (new_sectors >> 40) & 0xff;
+	} else {
+		tf.command = ATA_CMD_SET_MAX;
+
+		tf.device |= (new_sectors >> 24) & 0xf;
+	}
+
@@ -957,0 +1173 @@
+	tf.device |= ATA_LBA;
@@ -962 +1177,0 @@
-	tf.device |= ((new_sectors >> 24) & 0x0f) | 0x40;
@@ -964,3 +1179,9 @@
-	err = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
-	if (err)
-		return 0;
+	err_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);
+	if (err_mask) {
+		ata_dev_printk(dev, KERN_WARNING, "failed to set "
+			       "max address (err_mask=0x%x)\n", err_mask);
+		if (err_mask == AC_ERR_DEV &&
+		    (tf.feature & (ATA_ABORTED | ATA_IDNF)))
+			return -EACCES;
+		return -EIO;
+	}
@@ -968 +1189 @@
-	return ata_tf_to_lba(&tf);
+	return 0;
@@ -977,0 +1199,3 @@
+ *
+ *	RETURNS:
+ *	0 on success, -errno on failure.
@@ -979,2 +1203 @@
-
-static u64 ata_hpa_resize(struct ata_device *dev)
+static int ata_hpa_resize(struct ata_device *dev)
@@ -982,7 +1205,5 @@
-	u64 sectors = dev->n_sectors;
-	u64 hpa_sectors;
-
-	if (ata_id_has_lba48(dev->id))
-		hpa_sectors = ata_read_native_max_address_ext(dev);
-	else
-		hpa_sectors = ata_read_native_max_address(dev);
+	struct ata_eh_context *ehc = &dev->link->eh_context;
+	int print_info = ehc->i.flags & ATA_EHI_PRINTINFO;
+	u64 sectors = ata_id_n_sectors(dev->id);
+	u64 native_sectors;
+	int rc;
@@ -990,13 +1211,5 @@
-	if (hpa_sectors > sectors) {
-		ata_dev_printk(dev, KERN_INFO,
-			"Host Protected Area detected:\n"
-			"\tcurrent size: %lld sectors\n"
-			"\tnative size: %lld sectors\n",
-			(long long)sectors, (long long)hpa_sectors);
-
-		if (ata_ignore_hpa) {
-			if (ata_id_has_lba48(dev->id))
-				hpa_sectors = ata_set_native_max_address_ext(dev, hpa_sectors);
-			else
-				hpa_sectors = ata_set_native_max_address(dev,
-								hpa_sectors);
+	/* do we need to do it? */
+	if (dev->class != ATA_DEV_ATA ||
+	    !ata_id_has_lba(dev->id) || !ata_id_hpa_enabled(dev->id) ||
+	    (dev->horkage & ATA_HORKAGE_BROKEN_HPA))
+		return 0;
@@ -1004,6 +1217,14 @@
-			if (hpa_sectors) {
-				ata_dev_printk(dev, KERN_INFO, "native size "
-					"increased to %lld sectors\n",
-					(long long)hpa_sectors);
-				return hpa_sectors;
-			}
+	/* read native max address */
+	rc = ata_read_native_max_address(dev, &native_sectors);
+	if (rc) {
+		/* If HPA isn't going to be unlocked, skip HPA
+		 * resizing from the next try.
+		 */
+		if (!ata_ignore_hpa) {
+			ata_dev_printk(dev, KERN_WARNING, "HPA support seems "
+				       "broken, will skip HPA handling\n");
+			dev->horkage |= ATA_HORKAGE_BROKEN_HPA;
+
+			/* we can continue if device aborted the command */
+			if (rc == -EACCES)
+				rc = 0;
@@ -1011,4 +1231,0 @@
-	} else if (hpa_sectors < sectors)
-		ata_dev_printk(dev, KERN_WARNING, "%s 1: hpa sectors (%lld) "
-			       "is smaller than sectors (%lld)\n", __FUNCTION__,
-			       (long long)hpa_sectors, (long long)sectors);
@@ -1016,2 +1233,2 @@
-	return sectors;
-}
+		return rc;
+	}
@@ -1019,12 +1236,38 @@
-static u64 ata_id_n_sectors(const u16 *id)
-{
-	if (ata_id_has_lba(id)) {
-		if (ata_id_has_lba48(id))
-			return ata_id_u64(id, 100);
-		else
-			return ata_id_u32(id, 60);
-	} else {
-		if (ata_id_current_chs_valid(id))
-			return ata_id_u32(id, 57);
-		else
-			return id[1] * id[3] * id[6];
+	/* nothing to do? */
+	if (native_sectors <= sectors || !ata_ignore_hpa) {
+		if (!print_info || native_sectors == sectors)
+			return 0;
+
+		if (native_sectors > sectors)
+			ata_dev_printk(dev, KERN_INFO,
+				"HPA detected: current %llu, native %llu\n",
+				(unsigned long long)sectors,
+				(unsigned long long)native_sectors);
+		else if (native_sectors < sectors)
+			ata_dev_printk(dev, KERN_WARNING,
+				"native sectors (%llu) is smaller than "
+				"sectors (%llu)\n",
+				(unsigned long long)native_sectors,
+				(unsigned long long)sectors);
+		return 0;
+	}
+
+	/* let's unlock HPA */
+	rc = ata_set_max_sectors(dev, native_sectors);
+	if (rc == -EACCES) {
+		/* if device aborted the command, skip HPA resizing */
+		ata_dev_printk(dev, KERN_WARNING, "device aborted resize "
+			       "(%llu -> %llu), skipping HPA handling\n",
+			       (unsigned long long)sectors,
+			       (unsigned long long)native_sectors);
+		dev->horkage |= ATA_HORKAGE_BROKEN_HPA;
+		return 0;
+	} else if (rc)
+		return rc;
+
+	/* re-read IDENTIFY data */
+	rc = ata_dev_reread_id(dev, 0);
+	if (rc) {
+		ata_dev_printk(dev, KERN_ERR, "failed to re-read IDENTIFY "
+			       "data after HPA resizing\n");
+		return rc;
@@ -1031,0 +1275,11 @@
+
+	if (print_info) {
+		u64 new_sectors = ata_id_n_sectors(dev->id);
+		ata_dev_printk(dev, KERN_INFO,
+			"HPA unlocked: %llu -> %llu, native %llu\n",
+			(unsigned long long)sectors,
+			(unsigned long long)new_sectors,
+			(unsigned long long)native_sectors);
+	}
+
+	return 0;
@@ -1088 +1342 @@
-void ata_noop_dev_select (struct ata_port *ap, unsigned int device)
+void ata_noop_dev_select(struct ata_port *ap, unsigned int device)
@@ -1108 +1362 @@
-void ata_std_dev_select (struct ata_port *ap, unsigned int device)
+void ata_std_dev_select(struct ata_port *ap, unsigned int device)
@@ -1153 +1407 @@
-		if (can_sleep && ap->device[device].class == ATA_DEV_ATAPI)
+		if (can_sleep && ap->link.device[device].class == ATA_DEV_ATAPI)
@@ -1229 +1483 @@
-                	pio_mask = (2 << mode) - 1;
+			pio_mask = (2 << mode) - 1;
@@ -1329 +1583 @@
- *	@sg: sg list for the data buffer of the command
+ *	@sgl: sg list for the data buffer of the command
@@ -1330,0 +1585 @@
+ *	@timeout: Timeout in msecs (0 for default)
@@ -1346,2 +1601,2 @@
-			      int dma_dir, struct scatterlist *sg,
-			      unsigned int n_elem)
+			      int dma_dir, struct scatterlist *sgl,
+			      unsigned int n_elem, unsigned long timeout)
@@ -1349 +1604,2 @@
-	struct ata_port *ap = dev->ap;
+	struct ata_link *link = dev->link;
+	struct ata_port *ap = link->ap;
@@ -1353,0 +1610 @@
+	int preempted_nr_active_links;
@@ -1389,2 +1646,2 @@
-	preempted_tag = ap->active_tag;
-	preempted_sactive = ap->sactive;
+	preempted_tag = link->active_tag;
+	preempted_sactive = link->sactive;
@@ -1392,2 +1649,3 @@
-	ap->active_tag = ATA_TAG_POISON;
-	ap->sactive = 0;
+	preempted_nr_active_links = ap->nr_active_links;
+	link->active_tag = ATA_TAG_POISON;
+	link->sactive = 0;
@@ -1394,0 +1653 @@
+	ap->nr_active_links = 0;
@@ -1403,0 +1663 @@
+		struct scatterlist *sg;
@@ -1405,2 +1665,2 @@
-		for (i = 0; i < n_elem; i++)
-			buflen += sg[i].length;
+		for_each_sg(sgl, sg, n_elem, i)
+			buflen += sg->length;
@@ -1408 +1668 @@
-		ata_sg_init(qc, sg, n_elem);
+		ata_sg_init(qc, sgl, n_elem);
@@ -1419 +1679,4 @@
-	rc = wait_for_completion_timeout(&wait, ata_probe_timeout);
+	if (!timeout)
+		timeout = ata_probe_timeout * 1000 / HZ;
+
+	rc = wait_for_completion_timeout(&wait, msecs_to_jiffies(timeout));
@@ -1470,2 +1733,2 @@
-	ap->active_tag = preempted_tag;
-	ap->sactive = preempted_sactive;
+	link->active_tag = preempted_tag;
+	link->sactive = preempted_sactive;
@@ -1472,0 +1736 @@
+	ap->nr_active_links = preempted_nr_active_links;
@@ -1502,0 +1767 @@
+ *	@timeout: Timeout in msecs (0 for default)
@@ -1515 +1780,2 @@
-			   int dma_dir, void *buf, unsigned int buflen)
+			   int dma_dir, void *buf, unsigned int buflen,
+			   unsigned long timeout)
@@ -1527 +1793,2 @@
-	return ata_exec_internal_sg(dev, tf, cdb, dma_dir, psg, n_elem);
+	return ata_exec_internal_sg(dev, tf, cdb, dma_dir, psg, n_elem,
+				    timeout);
@@ -1554 +1821 @@
-	return ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
+	return ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);
@@ -1569 +1836 @@
-	if (adev->ap->flags & ATA_FLAG_NO_IORDY)
+	if (adev->link->ap->flags & ATA_FLAG_NO_IORDY)
@@ -1615,0 +1883,3 @@
+ *	FIXME: ATA_CMD_ID_ATA is optional for early drives and right
+ *	now we abort if we hit that case.
+ *
@@ -1625 +1895 @@
-	struct ata_port *ap = dev->ap;
+	struct ata_port *ap = dev->link->ap;
@@ -1666 +1936 @@
-				     id, sizeof(id[0]) * ATA_ID_WORDS);
+				     id, sizeof(id[0]) * ATA_ID_WORDS, 0);
@@ -1720,6 +1990 @@
-		ata_tf_init(dev, &tf);
-		tf.command = ATA_CMD_SET_FEATURES;
-		tf.feature = SETFEATURES_SPINUP;
-		tf.protocol = ATA_PROT_NODATA;
-		tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;
-		err_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
+		err_mask = ata_dev_set_feature(dev, SETFEATURES_SPINUP, 0);
@@ -1743,2 +2008,2 @@
-		 * IDENTIFY
-		 * INITIALIZE DEVICE PARAMETERS
+		 * IDENTIFY (optional in early ATA)
+		 * INITIALIZE DEVICE PARAMETERS (later IDE and ATA)
@@ -1746,0 +2012,3 @@
+		 *
+		 * Note that ATA4 says lba is mandatory so the second check
+		 * shoud never trigger.
@@ -1777 +2045,2 @@
-	return ((dev->ap->cbl == ATA_CBL_SATA) && (!ata_id_is_sata(dev->id)));
+	struct ata_port *ap = dev->link->ap;
+	return ((ap->cbl == ATA_CBL_SATA) && (!ata_id_is_sata(dev->id)));
@@ -1783 +2052 @@
-	struct ata_port *ap = dev->ap;
+	struct ata_port *ap = dev->link->ap;
@@ -1820,2 +2089,2 @@
-	struct ata_port *ap = dev->ap;
-	struct ata_eh_context *ehc = &ap->eh_context;
+	struct ata_port *ap = dev->link->ap;
+	struct ata_eh_context *ehc = &dev->link->eh_context;
@@ -1846,0 +2116,5 @@
+	/* massage HPA, do it early as it might change IDENTIFY data */
+	rc = ata_hpa_resize(dev);
+	if (rc)
+		return rc;
+
@@ -1890,3 +2164,2 @@
-		}
-		else
-			snprintf(revbuf, 7, "ATA-%d",  ata_id_major_version(id));
+		} else
+			snprintf(revbuf, 7, "ATA-%d", ata_id_major_version(id));
@@ -1914,4 +2186,0 @@
-			if (!(dev->horkage & ATA_HORKAGE_BROKEN_HPA) &&
-			    ata_id_hpa_enabled(dev->id))
- 				dev->n_sectors = ata_hpa_resize(dev);
-
@@ -1966 +2235,3 @@
-		char *cdb_intr_string = "";
+		const char *cdb_intr_string = "";
+		const char *atapi_an_string = "";
+		u32 sntf;
@@ -1977,0 +2249,23 @@
+		/* Enable ATAPI AN if both the host and device have
+		 * the support.  If PMP is attached, SNTF is required
+		 * to enable ATAPI AN to discern between PHY status
+		 * changed notifications and ATAPI ANs.
+		 */
+		if ((ap->flags & ATA_FLAG_AN) && ata_id_has_atapi_AN(id) &&
+		    (!ap->nr_pmp_links ||
+		     sata_scr_read(&ap->link, SCR_NOTIFICATION, &sntf) == 0)) {
+			unsigned int err_mask;
+
+			/* issue SET feature command to turn this on */
+			err_mask = ata_dev_set_feature(dev,
+					SETFEATURES_SATA_ENABLE, SATA_AN);
+			if (err_mask)
+				ata_dev_printk(dev, KERN_ERR,
+					"failed to enable ATAPI AN "
+					"(err_mask=0x%x)\n", err_mask);
+			else {
+				dev->flags |= ATA_DFLAG_AN;
+				atapi_an_string = ", ATAPI AN";
+			}
+		}
+
@@ -1986 +2280 @@
-				       "ATAPI: %s, %s, max %s%s\n",
+				       "ATAPI: %s, %s, max %s%s%s\n",
@@ -1989 +2283 @@
-				       cdb_intr_string);
+				       cdb_intr_string, atapi_an_string);
@@ -1996,0 +2291,7 @@
+	if (!(dev->horkage & ATA_HORKAGE_IPM)) {
+		if (ata_id_has_hipm(dev->id))
+			dev->flags |= ATA_DFLAG_HIPM;
+		if (ata_id_has_dipm(dev->id))
+			dev->flags |= ATA_DFLAG_DIPM;
+	}
+
@@ -2001 +2302 @@
-                if (print_info) {
+		if (print_info) {
@@ -2017,0 +2319,6 @@
+	if ((dev->class == ATA_DEV_ATAPI) &&
+	    (atapi_command_packet_set(id) == TYPE_TAPE)) {
+		dev->max_sectors = ATA_MAX_SECTORS_TAPE;
+		dev->horkage |= ATA_HORKAGE_STUCK_ERR;
+	}
+
@@ -2021,0 +2329,7 @@
+	if (ata_dev_blacklisted(dev) & ATA_HORKAGE_IPM) {
+		dev->horkage |= ATA_HORKAGE_IPM;
+
+		/* reset link pm_policy for this port to no pm */
+		ap->pm_policy = MAX_PERFORMANCE;
+	}
+
@@ -2106 +2420 @@
-	int i, rc;
+	int rc;
@@ -2111,2 +2425,2 @@
-	for (i = 0; i < ATA_MAX_DEVICES; i++)
-		tries[i] = ATA_PROBE_MAX_TRIES;
+	ata_link_for_each_dev(dev, &ap->link)
+		tries[dev->devno] = ATA_PROBE_MAX_TRIES;
@@ -2114,0 +2429,19 @@
+	ata_link_for_each_dev(dev, &ap->link) {
+		/* If we issue an SRST then an ATA drive (not ATAPI)
+		 * may change configuration and be in PIO0 timing. If
+		 * we do a hard reset (or are coming from power on)
+		 * this is true for ATA or ATAPI. Until we've set a
+		 * suitable controller mode we should not touch the
+		 * bus as we may be talking too fast.
+		 */
+		dev->pio_mode = XFER_PIO_0;
+
+		/* If the controller has a pio mode setup function
+		 * then use it to set the chipset to rights. Don't
+		 * touch the DMA setup as that will be dealt with when
+		 * configuring devices.
+		 */
+		if (ap->ops->set_piomode)
+			ap->ops->set_piomode(ap, dev);
+	}
+
@@ -2118,3 +2451 @@
-	for (i = 0; i < ATA_MAX_DEVICES; i++) {
-		dev = &ap->device[i];
-
+	ata_link_for_each_dev(dev, &ap->link) {
@@ -2132,6 +2462,0 @@
-	/* after the reset the device state is PIO 0 and the controller
-	   state is undefined. Record the mode */
-
-	for (i = 0; i < ATA_MAX_DEVICES; i++)
-		ap->device[i].pio_mode = XFER_PIO_0;
-
@@ -2142,5 +2467,3 @@
-	for (i = ATA_MAX_DEVICES - 1; i >=  0; i--) {
-		dev = &ap->device[i];
-
-		if (tries[i])
-			dev->class = classes[i];
+	ata_link_for_each_dev(dev, &ap->link) {
+		if (tries[dev->devno])
+			dev->class = classes[dev->devno];
@@ -2160,0 +2484,11 @@
+	/* We may have SATA bridge glue hiding here irrespective of the
+	   reported cable types and sensed types */
+	ata_link_for_each_dev(dev, &ap->link) {
+		if (!ata_dev_enabled(dev))
+			continue;
+		/* SATA drives indicate we have a bridge. We don't know which
+		   end of the link the bridge is which is a problem */
+		if (ata_id_is_sata(dev->id))
+			ap->cbl = ATA_CBL_SATA;
+	}
+
@@ -2164,2 +2498 @@
-	for(i = 0; i < ATA_MAX_DEVICES; i++) {
-		dev = &ap->device[i];
+	ata_link_for_each_dev(dev, &ap->link) {
@@ -2169 +2502 @@
-		ap->eh_context.i.flags |= ATA_EHI_PRINTINFO;
+		ap->link.eh_context.i.flags |= ATA_EHI_PRINTINFO;
@@ -2171 +2504 @@
-		ap->eh_context.i.flags &= ~ATA_EHI_PRINTINFO;
+		ap->link.eh_context.i.flags &= ~ATA_EHI_PRINTINFO;
@@ -2177 +2510 @@
-	rc = ata_set_mode(ap, &dev);
+	rc = ata_set_mode(&ap->link, &dev);
@@ -2181,2 +2514,2 @@
-	for (i = 0; i < ATA_MAX_DEVICES; i++)
-		if (ata_dev_enabled(&ap->device[i]))
+	ata_link_for_each_dev(dev, &ap->link)
+		if (ata_dev_enabled(dev))
@@ -2187 +2519,0 @@
-	ap->ops->port_disable(ap);
@@ -2207 +2539 @@
-			sata_down_spd_limit(ap);
+			sata_down_spd_limit(&ap->link);
@@ -2236 +2568 @@
- *	@ap: SATA port to printk link status about
+ *	@link: SATA link to printk link status about
@@ -2243 +2575 @@
-void sata_print_link_status(struct ata_port *ap)
+void sata_print_link_status(struct ata_link *link)
@@ -2247 +2579 @@
-	if (sata_scr_read(ap, SCR_STATUS, &sstatus))
+	if (sata_scr_read(link, SCR_STATUS, &sstatus))
@@ -2249 +2581 @@
-	sata_scr_read(ap, SCR_CONTROL, &scontrol);
+	sata_scr_read(link, SCR_CONTROL, &scontrol);
@@ -2251 +2583 @@
-	if (ata_port_online(ap)) {
+	if (ata_link_online(link)) {
@@ -2253 +2585 @@
-		ata_port_printk(ap, KERN_INFO,
+		ata_link_printk(link, KERN_INFO,
@@ -2257 +2589 @@
-		ata_port_printk(ap, KERN_INFO,
+		ata_link_printk(link, KERN_INFO,
@@ -2264,74 +2595,0 @@
- *	__sata_phy_reset - Wake/reset a low-level SATA PHY
- *	@ap: SATA port associated with target SATA PHY.
- *
- *	This function issues commands to standard SATA Sxxx
- *	PHY registers, to wake up the phy (and device), and
- *	clear any reset condition.
- *
- *	LOCKING:
- *	PCI/etc. bus probe sem.
- *
- */
-void __sata_phy_reset(struct ata_port *ap)
-{
-	u32 sstatus;
-	unsigned long timeout = jiffies + (HZ * 5);
-
-	if (ap->flags & ATA_FLAG_SATA_RESET) {
-		/* issue phy wake/reset */
-		sata_scr_write_flush(ap, SCR_CONTROL, 0x301);
-		/* Couldn't find anything in SATA I/II specs, but
-		 * AHCI-1.1 10.4.2 says at least 1 ms. */
-		mdelay(1);
-	}
-	/* phy wake/clear reset */
-	sata_scr_write_flush(ap, SCR_CONTROL, 0x300);
-
-	/* wait for phy to become ready, if necessary */
-	do {
-		msleep(200);
-		sata_scr_read(ap, SCR_STATUS, &sstatus);
-		if ((sstatus & 0xf) != 1)
-			break;
-	} while (time_before(jiffies, timeout));
-
-	/* print link status */
-	sata_print_link_status(ap);
-
-	/* TODO: phy layer with polling, timeouts, etc. */
-	if (!ata_port_offline(ap))
-		ata_port_probe(ap);
-	else
-		ata_port_disable(ap);
-
-	if (ap->flags & ATA_FLAG_DISABLED)
-		return;
-
-	if (ata_busy_sleep(ap, ATA_TMOUT_BOOT_QUICK, ATA_TMOUT_BOOT)) {
-		ata_port_disable(ap);
-		return;
-	}
-
-	ap->cbl = ATA_CBL_SATA;
-}
-
-/**
- *	sata_phy_reset - Reset SATA bus.
- *	@ap: SATA port associated with target SATA PHY.
- *
- *	This function resets the SATA bus, and then probes
- *	the bus for devices.
- *
- *	LOCKING:
- *	PCI/etc. bus probe sem.
- *
- */
-void sata_phy_reset(struct ata_port *ap)
-{
-	__sata_phy_reset(ap);
-	if (ap->flags & ATA_FLAG_DISABLED)
-		return;
-	ata_bus_reset(ap);
-}
-
-/**
@@ -2347,2 +2605,2 @@
-	struct ata_port *ap = adev->ap;
-	struct ata_device *pair = &ap->device[1 - adev->devno];
+	struct ata_link *link = adev->link;
+	struct ata_device *pair = &link->device[1 - adev->devno];
@@ -2369,2 +2627,2 @@
-	ap->device[0].class = ATA_DEV_NONE;
-	ap->device[1].class = ATA_DEV_NONE;
+	ap->link.device[0].class = ATA_DEV_NONE;
+	ap->link.device[1].class = ATA_DEV_NONE;
@@ -2376 +2634 @@
- *	@ap: Port to adjust SATA spd limit for
+ *	@link: Link to adjust SATA spd limit for
@@ -2378 +2636 @@
- *	Adjust SATA spd limit of @ap downward.  Note that this
+ *	Adjust SATA spd limit of @link downward.  Note that this
@@ -2388 +2646 @@
-int sata_down_spd_limit(struct ata_port *ap)
+int sata_down_spd_limit(struct ata_link *link)
@@ -2393 +2651 @@
-	if (!sata_scr_valid(ap))
+	if (!sata_scr_valid(link))
@@ -2397 +2655 @@
-	 * If not, use cached value in ap->sata_spd.
+	 * If not, use cached value in link->sata_spd.
@@ -2399 +2657 @@
-	rc = sata_scr_read(ap, SCR_STATUS, &sstatus);
+	rc = sata_scr_read(link, SCR_STATUS, &sstatus);
@@ -2403 +2661 @@
-		spd = ap->sata_spd;
+		spd = link->sata_spd;
@@ -2405 +2663 @@
-	mask = ap->sata_spd_limit;
+	mask = link->sata_spd_limit;
@@ -2425 +2683 @@
-	ap->sata_spd_limit = mask;
+	link->sata_spd_limit = mask;
@@ -2427 +2685 @@
-	ata_port_printk(ap, KERN_WARNING, "limiting SATA link speed to %s\n",
+	ata_link_printk(link, KERN_WARNING, "limiting SATA link speed to %s\n",
@@ -2433 +2691 @@
-static int __sata_set_spd_needed(struct ata_port *ap, u32 *scontrol)
+static int __sata_set_spd_needed(struct ata_link *link, u32 *scontrol)
@@ -2435 +2693,4 @@
-	u32 spd, limit;
+	struct ata_link *host_link = &link->ap->link;
+	u32 limit, target, spd;
+
+	limit = link->sata_spd_limit;
@@ -2437,2 +2698,9 @@
-	if (ap->sata_spd_limit == UINT_MAX)
-		limit = 0;
+	/* Don't configure downstream link faster than upstream link.
+	 * It doesn't speed up anything and some PMPs choke on such
+	 * configuration.
+	 */
+	if (!ata_is_host_link(link) && host_link->sata_spd)
+		limit &= (1 << host_link->sata_spd) - 1;
+
+	if (limit == UINT_MAX)
+		target = 0;
@@ -2440 +2708 @@
-		limit = fls(ap->sata_spd_limit);
+		target = fls(limit);
@@ -2443 +2711 @@
-	*scontrol = (*scontrol & ~0xf0) | ((limit & 0xf) << 4);
+	*scontrol = (*scontrol & ~0xf0) | ((target & 0xf) << 4);
@@ -2445 +2713 @@
-	return spd != limit;
+	return spd != target;
@@ -2450 +2718 @@
- *	@ap: Port in question
+ *	@link: Link in question
@@ -2453 +2721 @@
- *	@ap->sata_spd_limit.  This function is used to determine
+ *	@link->sata_spd_limit.  This function is used to determine
@@ -2463 +2731 @@
-int sata_set_spd_needed(struct ata_port *ap)
+int sata_set_spd_needed(struct ata_link *link)
@@ -2467,2 +2735,2 @@
-	if (sata_scr_read(ap, SCR_CONTROL, &scontrol))
-		return 0;
+	if (sata_scr_read(link, SCR_CONTROL, &scontrol))
+		return 1;
@@ -2470 +2738 @@
-	return __sata_set_spd_needed(ap, &scontrol);
+	return __sata_set_spd_needed(link, &scontrol);
@@ -2475 +2743 @@
- *	@ap: Port to set SATA spd for
+ *	@link: Link to set SATA spd for
@@ -2477 +2745 @@
- *	Set SATA spd of @ap according to sata_spd_limit.
+ *	Set SATA spd of @link according to sata_spd_limit.
@@ -2486 +2754 @@
-int sata_set_spd(struct ata_port *ap)
+int sata_set_spd(struct ata_link *link)
@@ -2491 +2759 @@
-	if ((rc = sata_scr_read(ap, SCR_CONTROL, &scontrol)))
+	if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
@@ -2494 +2762 @@
-	if (!__sata_set_spd_needed(ap, &scontrol))
+	if (!__sata_set_spd_needed(link, &scontrol))
@@ -2497 +2765 @@
-	if ((rc = sata_scr_write(ap, SCR_CONTROL, scontrol)))
+	if ((rc = sata_scr_write(link, SCR_CONTROL, scontrol)))
@@ -2552,2 +2820,2 @@
-#define ENOUGH(v,unit)		(((v)-1)/(unit)+1)
-#define EZ(v,unit)		((v)?ENOUGH(v,unit):0)
+#define ENOUGH(v, unit)		(((v)-1)/(unit)+1)
+#define EZ(v, unit)		((v)?ENOUGH(v, unit):0)
@@ -2580 +2848 @@
-static const struct ata_timing* ata_timing_find_mode(unsigned short speed)
+static const struct ata_timing *ata_timing_find_mode(unsigned short speed)
@@ -2612 +2880 @@
-		if(speed >= XFER_PIO_0 && speed <= XFER_SW_DMA_0) {
+		if (speed >= XFER_PIO_0 && speed <= XFER_SW_DMA_0) {
@@ -2615 +2883 @@
-		} else if(speed >= XFER_MW_DMA_0 && speed <= XFER_MW_DMA_2) {
+		} else if (speed >= XFER_MW_DMA_0 && speed <= XFER_MW_DMA_2) {
@@ -2752 +3020 @@
-	struct ata_eh_context *ehc = &dev->ap->eh_context;
+	struct ata_eh_context *ehc = &dev->link->eh_context;
@@ -2760,0 +3029 @@
+
@@ -2763 +3032,14 @@
-        	err_mask &= ~AC_ERR_DEV;
+		err_mask &= ~AC_ERR_DEV;
+
+	/* Some very old devices and some bad newer ones fail any kind of
+	   SET_XFERMODE request but support PIO0-2 timings and no IORDY */
+	if (dev->xfer_shift == ATA_SHIFT_PIO && !ata_id_has_iordy(dev->id) &&
+			dev->pio_mode <= XFER_PIO_2)
+		err_mask &= ~AC_ERR_DEV;
+
+	/* Early MWDMA devices do DMA but don't allow DMA mode setting.
+	   Don't fail an MWDMA0 set IFF the device indicates it is in MWDMA0 */
+	if (dev->xfer_shift == ATA_SHIFT_MWDMA && 
+	    dev->dma_mode == XFER_MW_DMA_0 &&
+	    (dev->id[63] >> 8) & 1)
+		err_mask &= ~AC_ERR_DEV;
@@ -2772 +3054 @@
-	rc = ata_dev_revalidate(dev, 0);
+	rc = ata_dev_revalidate(dev, ATA_DEV_UNKNOWN, 0);
@@ -2787 +3069 @@
- *	@ap: port on which timings will be programmed
+ *	@link: link on which timings will be programmed
@@ -2802 +3084 @@
-int ata_do_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev)
+int ata_do_set_mode(struct ata_link *link, struct ata_device **r_failed_dev)
@@ -2803,0 +3086 @@
+	struct ata_port *ap = link->ap;
@@ -2805,2 +3088 @@
-	int i, rc = 0, used_dma = 0, found = 0;
-
+	int rc = 0, used_dma = 0, found = 0;
@@ -2809 +3091 @@
-	for (i = 0; i < ATA_MAX_DEVICES; i++) {
+	ata_link_for_each_dev(dev, link) {
@@ -2811,2 +3093 @@
-
-		dev = &ap->device[i];
+		unsigned int mode_mask;
@@ -2816,0 +3098,6 @@
+		mode_mask = ATA_DMA_MASK_ATA;
+		if (dev->class == ATA_DEV_ATAPI)
+			mode_mask = ATA_DMA_MASK_ATAPI;
+		else if (ata_id_is_cfa(dev->id))
+			mode_mask = ATA_DMA_MASK_CFA;
+
@@ -2820,0 +3108,6 @@
+
+		if (libata_dma_mask & mode_mask)
+			dma_mask = ata_pack_xfermask(0, dev->mwdma_mask, dev->udma_mask);
+		else
+			dma_mask = 0;
+
@@ -2832,2 +3125 @@
-	for (i = 0; i < ATA_MAX_DEVICES; i++) {
-		dev = &ap->device[i];
+	ata_link_for_each_dev(dev, link) {
@@ -2850,3 +3142 @@
-	for (i = 0; i < ATA_MAX_DEVICES; i++) {
-		dev = &ap->device[i];
-
+	ata_link_for_each_dev(dev, link) {
@@ -2863,3 +3153 @@
-	for (i = 0; i < ATA_MAX_DEVICES; i++) {
-		dev = &ap->device[i];
-
+	ata_link_for_each_dev(dev, link) {
@@ -2889 +3177 @@
- *	@ap: port on which timings will be programmed
+ *	@link: link on which timings will be programmed
@@ -2902 +3190 @@
-int ata_set_mode(struct ata_port *ap, struct ata_device **r_failed_dev)
+int ata_set_mode(struct ata_link *link, struct ata_device **r_failed_dev)
@@ -2903,0 +3192,2 @@
+	struct ata_port *ap = link->ap;
+
@@ -2906,2 +3196,2 @@
-		return ap->ops->set_mode(ap, r_failed_dev);
-	return ata_do_set_mode(ap, r_failed_dev);
+		return ap->ops->set_mode(link, r_failed_dev);
+	return ata_do_set_mode(link, r_failed_dev);
@@ -2985,0 +3276,55 @@
+ *	ata_wait_after_reset - wait before checking status after reset
+ *	@ap: port containing status register to be polled
+ *	@deadline: deadline jiffies for the operation
+ *
+ *	After reset, we need to pause a while before reading status.
+ *	Also, certain combination of controller and device report 0xff
+ *	for some duration (e.g. until SATA PHY is up and running)
+ *	which is interpreted as empty port in ATA world.  This
+ *	function also waits for such devices to get out of 0xff
+ *	status.
+ *
+ *	LOCKING:
+ *	Kernel thread context (may sleep).
+ */
+void ata_wait_after_reset(struct ata_port *ap, unsigned long deadline)
+{
+	unsigned long until = jiffies + ATA_TMOUT_FF_WAIT;
+
+	if (time_before(until, deadline))
+		deadline = until;
+
+	/* Spec mandates ">= 2ms" before checking status.  We wait
+	 * 150ms, because that was the magic delay used for ATAPI
+	 * devices in Hale Landis's ATADRVR, for the period of time
+	 * between when the ATA command register is written, and then
+	 * status is checked.  Because waiting for "a while" before
+	 * checking status is fine, post SRST, we perform this magic
+	 * delay here as well.
+	 *
+	 * Old drivers/ide uses the 2mS rule and then waits for ready.
+	 */
+	msleep(150);
+
+	/* Wait for 0xff to clear.  Some SATA devices take a long time
+	 * to clear 0xff after reset.  For example, HHD424020F7SV00
+	 * iVDR needs >= 800ms while.  Quantum GoVault needs even more
+	 * than that.
+	 *
+	 * Note that some PATA controllers (pata_ali) explode if
+	 * status register is read more than once when there's no
+	 * device attached.
+	 */
+	if (ap->flags & ATA_FLAG_SATA) {
+		while (1) {
+			u8 status = ata_chk_status(ap);
+
+			if (status != 0xff || time_after(jiffies, deadline))
+				return;
+
+			msleep(50);
+		}
+	}
+}
+
+/**
@@ -3010 +3355 @@
-		if (!ata_port_online(ap) && status == 0xff)
+		if (!ata_link_online(&ap->link) && status == 0xff)
@@ -3101,11 +3446,2 @@
-	/* spec mandates ">= 2ms" before checking status.
-	 * We wait 150ms, because that was the magic delay used for
-	 * ATAPI devices in Hale Landis's ATADRVR, for the period of time
-	 * between when the ATA command register is written, and then
-	 * status is checked.  Because waiting for "a while" before
-	 * checking status is fine, post SRST, we perform this magic
-	 * delay here as well.
-	 *
-	 * Old drivers/ide uses the 2mS rule and then waits for ready
-	 */
-	msleep(150);
+	/* wait a while before checking status */
+	ata_wait_after_reset(ap, deadline);
@@ -3117 +3453 @@
-	if (ata_check_status(ap) == 0xFF)
+	if (ata_chk_status(ap) == 0xFF)
@@ -3144,0 +3481 @@
+	struct ata_device *device = ap->link.device;
@@ -3180 +3517 @@
-	ap->device[0].class = ata_dev_try_classify(ap, 0, &err);
+	device[0].class = ata_dev_try_classify(&device[0], dev0, &err);
@@ -3182 +3519 @@
-		ap->device[1].class = ata_dev_try_classify(ap, 1, &err);
+		device[1].class = ata_dev_try_classify(&device[1], dev1, &err);
@@ -3185 +3522 @@
-	if (ap->device[1].class != ATA_DEV_NONE)
+	if (device[1].class != ATA_DEV_NONE)
@@ -3187 +3524 @@
-	if (ap->device[0].class != ATA_DEV_NONE)
+	if (device[0].class != ATA_DEV_NONE)
@@ -3191,2 +3528,2 @@
-	if ((ap->device[0].class == ATA_DEV_NONE) &&
-	    (ap->device[1].class == ATA_DEV_NONE))
+	if ((device[0].class == ATA_DEV_NONE) &&
+	    (device[1].class == ATA_DEV_NONE))
@@ -3205 +3542 @@
-	ap->ops->port_disable(ap);
+	ata_port_disable(ap);
@@ -3211,2 +3548,2 @@
- *	sata_phy_debounce - debounce SATA phy status
- *	@ap: ATA port to debounce SATA phy status for
+ *	sata_link_debounce - debounce SATA phy status
+ *	@link: ATA link to debounce SATA phy status for
@@ -3216 +3553 @@
- *	Make sure SStatus of @ap reaches stable state, determined by
+*	Make sure SStatus of @link reaches stable state, determined by
@@ -3232,2 +3569,2 @@
-int sata_phy_debounce(struct ata_port *ap, const unsigned long *params,
-		      unsigned long deadline)
+int sata_link_debounce(struct ata_link *link, const unsigned long *params,
+		       unsigned long deadline)
@@ -3245 +3582 @@
-	if ((rc = sata_scr_read(ap, SCR_STATUS, &cur)))
+	if ((rc = sata_scr_read(link, SCR_STATUS, &cur)))
@@ -3254 +3591 @@
-		if ((rc = sata_scr_read(ap, SCR_STATUS, &cur)))
+		if ((rc = sata_scr_read(link, SCR_STATUS, &cur)))
@@ -3280,2 +3617,2 @@
- *	sata_phy_resume - resume SATA phy
- *	@ap: ATA port to resume SATA phy for
+ *	sata_link_resume - resume SATA link
+ *	@link: ATA link to resume SATA
@@ -3285 +3622 @@
- *	Resume SATA phy of @ap and debounce it.
+ *	Resume SATA phy @link and debounce it.
@@ -3293,2 +3630,2 @@
-int sata_phy_resume(struct ata_port *ap, const unsigned long *params,
-		    unsigned long deadline)
+int sata_link_resume(struct ata_link *link, const unsigned long *params,
+		     unsigned long deadline)
@@ -3299 +3636 @@
-	if ((rc = sata_scr_read(ap, SCR_CONTROL, &scontrol)))
+	if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
@@ -3304 +3641 @@
-	if ((rc = sata_scr_write(ap, SCR_CONTROL, scontrol)))
+	if ((rc = sata_scr_write(link, SCR_CONTROL, scontrol)))
@@ -3312 +3649 @@
-	return sata_phy_debounce(ap, params, deadline);
+	return sata_link_debounce(link, params, deadline);
@@ -3317 +3654 @@
- *	@ap: ATA port to be reset
+ *	@link: ATA link to be reset
@@ -3320 +3657 @@
- *	@ap is about to be reset.  Initialize it.  Failure from
+ *	@link is about to be reset.  Initialize it.  Failure from
@@ -3332 +3669 @@
-int ata_std_prereset(struct ata_port *ap, unsigned long deadline)
+int ata_std_prereset(struct ata_link *link, unsigned long deadline)
@@ -3334 +3671,2 @@
-	struct ata_eh_context *ehc = &ap->eh_context;
+	struct ata_port *ap = link->ap;
+	struct ata_eh_context *ehc = &link->eh_context;
@@ -3340 +3678,7 @@
-	    (ap->flags & ATA_FLAG_HRST_TO_RESUME))
+	    (link->flags & ATA_LFLAG_HRST_TO_RESUME))
+		ehc->i.action |= ATA_EH_HARDRESET;
+
+	/* Some PMPs don't work with only SRST, force hardreset if PMP
+	 * is supported.
+	 */
+	if (ap->flags & ATA_FLAG_PMP)
@@ -3347 +3691 @@
-	/* if SATA, resume phy */
+	/* if SATA, resume link */
@@ -3349 +3693 @@
-		rc = sata_phy_resume(ap, timing, deadline);
+		rc = sata_link_resume(link, timing, deadline);
@@ -3352 +3696 @@
-			ata_port_printk(ap, KERN_WARNING, "failed to resume "
+			ata_link_printk(link, KERN_WARNING, "failed to resume "
@@ -3359 +3703 @@
-	if (!(ap->flags & ATA_FLAG_SKIP_D2H_BSY) && !ata_port_offline(ap)) {
+	if (!(link->flags & ATA_LFLAG_SKIP_D2H_BSY) && !ata_link_offline(link)) {
@@ -3362 +3706 @@
-			ata_port_printk(ap, KERN_WARNING, "device not ready "
+			ata_link_printk(link, KERN_WARNING, "device not ready "
@@ -3373 +3717 @@
- *	@ap: port to reset
+ *	@link: ATA link to reset
@@ -3385 +3729 @@
-int ata_std_softreset(struct ata_port *ap, unsigned int *classes,
+int ata_std_softreset(struct ata_link *link, unsigned int *classes,
@@ -3387,0 +3732 @@
+	struct ata_port *ap = link->ap;
@@ -3395 +3740 @@
-	if (ata_port_offline(ap)) {
+	if (ata_link_offline(link)) {
@@ -3413,2 +3758,2 @@
-	if (rc && (rc != -ENODEV || sata_scr_valid(ap))) {
-		ata_port_printk(ap, KERN_ERR, "SRST failed (errno=%d)\n", rc);
+	if (rc && (rc != -ENODEV || sata_scr_valid(link))) {
+		ata_link_printk(link, KERN_ERR, "SRST failed (errno=%d)\n", rc);
@@ -3419 +3764,2 @@
-	classes[0] = ata_dev_try_classify(ap, 0, &err);
+	classes[0] = ata_dev_try_classify(&link->device[0],
+					  devmask & (1 << 0), &err);
@@ -3421 +3767,2 @@
-		classes[1] = ata_dev_try_classify(ap, 1, &err);
+		classes[1] = ata_dev_try_classify(&link->device[1],
+						  devmask & (1 << 1), &err);
@@ -3429,2 +3776,2 @@
- *	sata_port_hardreset - reset port via SATA phy reset
- *	@ap: port to reset
+ *	sata_link_hardreset - reset link via SATA phy reset
+ *	@link: link to reset
@@ -3434 +3781 @@
- *	SATA phy-reset host port using DET bits of SControl register.
+ *	SATA phy-reset @link using DET bits of SControl register.
@@ -3442 +3789 @@
-int sata_port_hardreset(struct ata_port *ap, const unsigned long *timing,
+int sata_link_hardreset(struct ata_link *link, const unsigned long *timing,
@@ -3450 +3797 @@
-	if (sata_set_spd_needed(ap)) {
+	if (sata_set_spd_needed(link)) {
@@ -3456 +3803 @@
-		if ((rc = sata_scr_read(ap, SCR_CONTROL, &scontrol)))
+		if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
@@ -3461 +3808 @@
-		if ((rc = sata_scr_write(ap, SCR_CONTROL, scontrol)))
+		if ((rc = sata_scr_write(link, SCR_CONTROL, scontrol)))
@@ -3464 +3811 @@
-		sata_set_spd(ap);
+		sata_set_spd(link);
@@ -3468 +3815 @@
-	if ((rc = sata_scr_read(ap, SCR_CONTROL, &scontrol)))
+	if ((rc = sata_scr_read(link, SCR_CONTROL, &scontrol)))
@@ -3473 +3820 @@
-	if ((rc = sata_scr_write_flush(ap, SCR_CONTROL, scontrol)))
+	if ((rc = sata_scr_write_flush(link, SCR_CONTROL, scontrol)))
@@ -3481,2 +3828,2 @@
-	/* bring phy back */
-	rc = sata_phy_resume(ap, timing, deadline);
+	/* bring link back */
+	rc = sata_link_resume(link, timing, deadline);
@@ -3490 +3837 @@
- *	@ap: port to reset
+ *	@link: link to reset
@@ -3503 +3850 @@
-int sata_std_hardreset(struct ata_port *ap, unsigned int *class,
+int sata_std_hardreset(struct ata_link *link, unsigned int *class,
@@ -3506 +3853,2 @@
-	const unsigned long *timing = sata_ehc_deb_timing(&ap->eh_context);
+	struct ata_port *ap = link->ap;
+	const unsigned long *timing = sata_ehc_deb_timing(&link->eh_context);
@@ -3512 +3860 @@
-	rc = sata_port_hardreset(ap, timing, deadline);
+	rc = sata_link_hardreset(link, timing, deadline);
@@ -3514 +3862 @@
-		ata_port_printk(ap, KERN_ERR,
+		ata_link_printk(link, KERN_ERR,
@@ -3520 +3868 @@
-	if (ata_port_offline(ap)) {
+	if (ata_link_offline(link)) {
@@ -3526,2 +3874,12 @@
-	/* wait a while before checking status, see SRST for more info */
-	msleep(150);
+	/* wait a while before checking status */
+	ata_wait_after_reset(ap, deadline);
+
+	/* If PMP is supported, we have to do follow-up SRST.  Note
+	 * that some PMPs don't send D2H Reg FIS after hardreset at
+	 * all if the first port is empty.  Wait for it just for a
+	 * second and request follow-up SRST.
+	 */
+	if (ap->flags & ATA_FLAG_PMP) {
+		ata_wait_ready(ap, jiffies + HZ);
+		return -EAGAIN;
+	}
@@ -3532 +3890 @@
-		ata_port_printk(ap, KERN_ERR,
+		ata_link_printk(link, KERN_ERR,
@@ -3539 +3897 @@
-	*class = ata_dev_try_classify(ap, 0, NULL);
+	*class = ata_dev_try_classify(link->device, 1, NULL);
@@ -3547 +3905 @@
- *	@ap: the target ata_port
+ *	@link: the target ata_link
@@ -3557 +3915 @@
-void ata_std_postreset(struct ata_port *ap, unsigned int *classes)
+void ata_std_postreset(struct ata_link *link, unsigned int *classes)
@@ -3558,0 +3917 @@
+	struct ata_port *ap = link->ap;
@@ -3564 +3923 @@
-	sata_print_link_status(ap);
+	sata_print_link_status(link);
@@ -3567,2 +3926,3 @@
-	if (sata_scr_read(ap, SCR_ERROR, &serror) == 0)
-		sata_scr_write(ap, SCR_ERROR, serror);
+	if (sata_scr_read(link, SCR_ERROR, &serror) == 0)
+		sata_scr_write(link, SCR_ERROR, serror);
+	link->eh_info.serror = 0;
@@ -3655 +4015 @@
-	u16 *id = (void *)dev->ap->sector_buf;
+	u16 *id = (void *)dev->link->ap->sector_buf;
@@ -3673,0 +4034 @@
+ *	@new_class: new class code
@@ -3685 +4046,2 @@
-int ata_dev_revalidate(struct ata_device *dev, unsigned int readid_flags)
+int ata_dev_revalidate(struct ata_device *dev, unsigned int new_class,
+		       unsigned int readid_flags)
@@ -3692,0 +4055,9 @@
+	/* fail early if !ATA && !ATAPI to avoid issuing [P]IDENTIFY to PMP */
+	if (ata_class_enabled(new_class) &&
+	    new_class != ATA_DEV_ATA && new_class != ATA_DEV_ATAPI) {
+		ata_dev_printk(dev, KERN_INFO, "class mismatch %u != %u\n",
+			       dev->class, new_class);
+		rc = -ENODEV;
+		goto fail;
+	}
+
@@ -3761 +4132 @@
-	{ "SAMSUNG CD-ROM SN-124","N001",	ATA_HORKAGE_NODMA },
+	{ "SAMSUNG CD-ROM SN-124", "N001",	ATA_HORKAGE_NODMA },
@@ -3763,3 +4134,3 @@
-	{ "IOMEGA  ZIP 250       ATAPI", NULL,	ATA_HORKAGE_NODMA }, /* temporary fix */
-	{ "IOMEGA  ZIP 250       ATAPI       Floppy",
-				NULL,		ATA_HORKAGE_NODMA },
+	/* Odd clown on sil3726/4726 PMPs */
+	{ "Config  Disk",	NULL,		ATA_HORKAGE_NODMA |
+						ATA_HORKAGE_SKIP_PM },
@@ -3774 +4145,2 @@
-        { "WDC WD740ADFD-00",   NULL,		ATA_HORKAGE_NONCQ },
+	{ "WDC WD740ADFD-00",	NULL,		ATA_HORKAGE_NONCQ },
+	{ "WDC WD740ADFD-00NLR1", NULL,		ATA_HORKAGE_NONCQ, },
@@ -3778,5 +4150 @@
-	{ "Maxtor 6L250S0",     "BANC1G10",     ATA_HORKAGE_NONCQ },
-	{ "Maxtor 6B200M0",	"BANC1BM0",	ATA_HORKAGE_NONCQ },
-	{ "Maxtor 6B200M0",	"BANC1B10",	ATA_HORKAGE_NONCQ },
-	{ "Maxtor 7B250S0",	"BANC1B70",	ATA_HORKAGE_NONCQ, },
-	{ "Maxtor 7B300S0",	"BANC1B70",	ATA_HORKAGE_NONCQ },
+	{ "Maxtor *",		"BANC*",	ATA_HORKAGE_NONCQ },
@@ -3784,4 +4152,5 @@
-	{ "HITACHI HDS7250SASUN500G 0621KTAWSD", "K2AOAJ0AHITACHI",
-	 ATA_HORKAGE_NONCQ },
-	/* NCQ hard hangs device under heavier load, needs hard power cycle */
-	{ "Maxtor 6B250S0",	"BANC1B70",	ATA_HORKAGE_NONCQ },
+	{ "HITACHI HDS7250SASUN500G*", NULL,    ATA_HORKAGE_NONCQ },
+	{ "HITACHI HDS7225SBSUN250G*", NULL,    ATA_HORKAGE_NONCQ },
+	{ "ST380817AS",		"3.42",		ATA_HORKAGE_NONCQ },
+	{ "ST3160023AS",	"3.42",		ATA_HORKAGE_NONCQ },
+
@@ -3793,9 +4161,0 @@
-	/* Drives which do spurious command completion */
-	{ "HTS541680J9SA00",	"SB2IC7EP",	ATA_HORKAGE_NONCQ, },
-	{ "HTS541612J9SA00",	"SBDIC7JP",	ATA_HORKAGE_NONCQ, },
-	{ "Hitachi HTS541616J9SA00", "SB4OC70P", ATA_HORKAGE_NONCQ, },
-	{ "WDC WD740ADFD-00NLR1", NULL,		ATA_HORKAGE_NONCQ, },
-	{ "FUJITSU MHV2080BH",	"00840028",	ATA_HORKAGE_NONCQ, },
-	{ "ST9160821AS",	"3.CLF",	ATA_HORKAGE_NONCQ, },
-	{ "ST3160812AS",	"3.AD",		ATA_HORKAGE_NONCQ, },
-	{ "SAMSUNG HD401LJ",	"ZZ100-15",	ATA_HORKAGE_NONCQ, },
@@ -3808,0 +4169,11 @@
+	/* Devices which report 1 sector over size HPA */
+	{ "ST340823A",		NULL,		ATA_HORKAGE_HPA_SIZE, },
+	{ "ST320413A",		NULL,		ATA_HORKAGE_HPA_SIZE, },
+
+	/* Devices which get the IVB wrong */
+	{ "QUANTUM FIREBALLlct10 05", "A03.0900", ATA_HORKAGE_IVB, },
+	{ "TSSTcorp CDDVDW SH-S202J", "SB00",	  ATA_HORKAGE_IVB, },
+	{ "TSSTcorp CDDVDW SH-S202J", "SB01",	  ATA_HORKAGE_IVB, },
+	{ "TSSTcorp CDDVDW SH-S202N", "SB00",	  ATA_HORKAGE_IVB, },
+	{ "TSSTcorp CDDVDW SH-S202N", "SB01",	  ATA_HORKAGE_IVB, },
+
@@ -3812,0 +4184,23 @@
+static int strn_pattern_cmp(const char *patt, const char *name, int wildchar)
+{
+	const char *p;
+	int len;
+
+	/*
+	 * check for trailing wildcard: *\0
+	 */
+	p = strchr(patt, wildchar);
+	if (p && ((*(p + 1)) == 0))
+		len = p - patt;
+	else {
+		len = strlen(name);
+		if (!len) {
+			if (!*patt)
+				return 0;
+			return -1;
+		}
+	}
+
+	return strncmp(patt, name, len);
+}
+
@@ -3823 +4217 @@
-		if (!strcmp(ad->model_num, model_num)) {
+		if (!strn_pattern_cmp(ad->model_num, model_num, '*')) {
@@ -3826 +4220 @@
-			if (!strcmp(ad->model_rev, model_rev))
+			if (!strn_pattern_cmp(ad->model_rev, model_rev, '*'))
@@ -3840 +4234 @@
-	if ((dev->ap->flags & ATA_FLAG_PIO_POLLING) &&
+	if ((dev->link->ap->flags & ATA_FLAG_PIO_POLLING) &&
@@ -3846,0 +4241,15 @@
+ *	ata_is_40wire		-	check drive side detection
+ *	@dev: device
+ *
+ *	Perform drive side detection decoding, allowing for device vendors
+ *	who can't follow the documentation.
+ */
+
+static int ata_is_40wire(struct ata_device *dev)
+{
+	if (dev->horkage & ATA_HORKAGE_IVB)
+		return ata_drive_40wire_relaxed(dev->id);
+	return ata_drive_40wire(dev->id);
+}
+
+/**
@@ -3860 +4269,2 @@
-	struct ata_port *ap = dev->ap;
+	struct ata_link *link = dev->link;
+	struct ata_port *ap = link->ap;
@@ -3891 +4301 @@
-            host->simplex_claimed && host->simplex_claimed != ap) {
+	    host->simplex_claimed && host->simplex_claimed != ap) {
@@ -3913,5 +4323,5 @@
-		if((ap->cbl == ATA_CBL_PATA40) ||
-   		    (ata_drive_40wire(dev->id) &&
-		     (ap->cbl == ATA_CBL_PATA_UNK ||
-                     ap->cbl == ATA_CBL_PATA80))) {
-		      	ata_dev_printk(dev, KERN_WARNING,
+		if ((ap->cbl == ATA_CBL_PATA40) ||
+		    (ata_is_40wire(dev) &&
+		    (ap->cbl == ATA_CBL_PATA_UNK ||
+		     ap->cbl == ATA_CBL_PATA80))) {
+			ata_dev_printk(dev, KERN_WARNING,
@@ -3958 +4368,37 @@
-	err_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
+	err_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);
+
+	DPRINTK("EXIT, err_mask=%x\n", err_mask);
+	return err_mask;
+}
+/**
+ *	ata_dev_set_feature - Issue SET FEATURES - SATA FEATURES
+ *	@dev: Device to which command will be sent
+ *	@enable: Whether to enable or disable the feature
+ *	@feature: The sector count represents the feature to set
+ *
+ *	Issue SET FEATURES - SATA FEATURES command to device @dev
+ *	on port @ap with sector count
+ *
+ *	LOCKING:
+ *	PCI/etc. bus probe sem.
+ *
+ *	RETURNS:
+ *	0 on success, AC_ERR_* mask otherwise.
+ */
+static unsigned int ata_dev_set_feature(struct ata_device *dev, u8 enable,
+					u8 feature)
+{
+	struct ata_taskfile tf;
+	unsigned int err_mask;
+
+	/* set up set-features taskfile */
+	DPRINTK("set features - SATA features\n");
+
+	ata_tf_init(dev, &tf);
+	tf.command = ATA_CMD_SET_FEATURES;
+	tf.feature = enable;
+	tf.flags |= ATA_TFLAG_ISADDR | ATA_TFLAG_DEVICE;
+	tf.protocol = ATA_PROT_NODATA;
+	tf.nsect = feature;
+
+	err_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);
@@ -3996 +4442 @@
-	err_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0);
+	err_mask = ata_exec_internal(dev, &tf, NULL, DMA_NONE, NULL, 0, 0);
@@ -4042 +4488 @@
-		sg[qc->orig_n_elem - 1].length += qc->pad_len;
+		sg_last(sg, qc->orig_n_elem)->length += qc->pad_len;
@@ -4045 +4491 @@
-			void *addr = kmap_atomic(psg->page, KM_IRQ0);
+			void *addr = kmap_atomic(sg_page(psg), KM_IRQ0);
@@ -4144 +4590 @@
- 		/* determine if physical DMA addr spans 64K boundary.
+		/* determine if physical DMA addr spans 64K boundary.
@@ -4209,0 +4656,67 @@
+ *	atapi_qc_may_overflow - Check whether data transfer may overflow
+ *	@qc: ATA command in question
+ *
+ *	ATAPI commands which transfer variable length data to host
+ *	might overflow due to application error or hardare bug.  This
+ *	function checks whether overflow should be drained and ignored
+ *	for @qc.
+ *
+ *	LOCKING:
+ *	None.
+ *
+ *	RETURNS:
+ *	1 if @qc may overflow; otherwise, 0.
+ */
+static int atapi_qc_may_overflow(struct ata_queued_cmd *qc)
+{
+	if (qc->tf.protocol != ATA_PROT_ATAPI &&
+	    qc->tf.protocol != ATA_PROT_ATAPI_DMA)
+		return 0;
+
+	if (qc->tf.flags & ATA_TFLAG_WRITE)
+		return 0;
+
+	switch (qc->cdb[0]) {
+	case READ_10:
+	case READ_12:
+	case WRITE_10:
+	case WRITE_12:
+	case GPCMD_READ_CD:
+	case GPCMD_READ_CD_MSF:
+		return 0;
+	}
+
+	return 1;
+}
+
+/**
+ *	ata_std_qc_defer - Check whether a qc needs to be deferred
+ *	@qc: ATA command in question
+ *
+ *	Non-NCQ commands cannot run with any other command, NCQ or
+ *	not.  As upper layer only knows the queue depth, we are
+ *	responsible for maintaining exclusion.  This function checks
+ *	whether a new command @qc can be issued.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host lock)
+ *
+ *	RETURNS:
+ *	ATA_DEFER_* if deferring is needed, 0 otherwise.
+ */
+int ata_std_qc_defer(struct ata_queued_cmd *qc)
+{
+	struct ata_link *link = qc->dev->link;
+
+	if (qc->tf.protocol == ATA_PROT_NCQ) {
+		if (!ata_tag_valid(link->active_tag))
+			return 0;
+	} else {
+		if (!ata_tag_valid(link->active_tag) && !link->sactive)
+			return 0;
+	}
+
+	return ATA_DEFER_LINK;
+}
+
+/**
@@ -4266,0 +4780 @@
+	qc->cursg = qc->__sg;
@@ -4291,0 +4806 @@
+	qc->cursg = qc->__sg;
@@ -4381 +4896 @@
-	struct scatterlist *lsg = &sg[qc->n_elem - 1];
+	struct scatterlist *lsg = sg_last(qc->__sg, qc->n_elem);
@@ -4403,2 +4918,3 @@
-		psg->page = nth_page(lsg->page, offset >> PAGE_SHIFT);
-		psg->offset = offset_in_page(offset);
+		sg_init_table(psg, 1);
+		sg_set_page(psg, nth_page(sg_page(lsg), offset >> PAGE_SHIFT),
+				qc->pad_len, offset_in_page(offset));
@@ -4407 +4923 @@
-			void *addr = kmap_atomic(psg->page, KM_IRQ0);
+			void *addr = kmap_atomic(sg_page(psg), KM_IRQ0);
@@ -4485 +5001 @@
-	struct ata_port *ap = adev->ap;
+	struct ata_port *ap = adev->link->ap;
@@ -4545 +5060,0 @@
-	struct scatterlist *sg = qc->__sg;
@@ -4554,2 +5069,2 @@
-	page = sg[qc->cursg].page;
-	offset = sg[qc->cursg].offset + qc->cursg_ofs;
+	page = sg_page(qc->cursg);
+	offset = qc->cursg->offset + qc->cursg_ofs;
@@ -4583,2 +5098,2 @@
-	if (qc->cursg_ofs == (&sg[qc->cursg])->length) {
-		qc->cursg++;
+	if (qc->cursg_ofs == qc->cursg->length) {
+		qc->cursg = sg_next(qc->cursg);
@@ -4613,0 +5129,2 @@
+
+	ata_altstatus(qc->ap); /* flush */
@@ -4663,2 +5180 @@
-
-static void __atapi_pio_bytes(struct ata_queued_cmd *qc, unsigned int bytes)
+static int __atapi_pio_bytes(struct ata_queued_cmd *qc, unsigned int bytes)
@@ -4667 +5182,0 @@
-	struct scatterlist *sg = qc->__sg;
@@ -4668,0 +5184,2 @@
+	struct ata_eh_info *ehi = &qc->dev->link->eh_info;
+	struct scatterlist *sg;
@@ -4673,3 +5189,0 @@
-	if (qc->curbytes + bytes >= qc->nbytes)
-		ap->hsm_task_state = HSM_ST_LAST;
-
@@ -4677 +5191,2 @@
-	if (unlikely(qc->cursg >= qc->n_elem)) {
+	sg = qc->cursg;
+	if (unlikely(!sg)) {
@@ -4686 +5200,0 @@
-		unsigned int words = bytes >> 1;
@@ -4689,3 +5203,12 @@
-		if (words) /* warning if bytes > 1 */
-			ata_dev_printk(qc->dev, KERN_WARNING,
-				       "%u bytes trailing data\n", bytes);
+		if (bytes > qc->curbytes - qc->nbytes + ATAPI_MAX_DRAIN) {
+			ata_ehi_push_desc(ehi, "too much trailing data "
+					  "buf=%u cur=%u bytes=%u",
+					  qc->nbytes, qc->curbytes, bytes);
+			return -1;
+		}
+
+		 /* overflow is exptected for misc ATAPI commands */
+		if (bytes && !atapi_qc_may_overflow(qc))
+			ata_dev_printk(qc->dev, KERN_WARNING, "ATAPI %u bytes "
+				       "trailing data (cdb=%02x nbytes=%u)\n",
+				       bytes, qc->cdb[0], qc->nbytes);
@@ -4693,2 +5216,2 @@
-		for (i = 0; i < words; i++)
-			ap->ops->data_xfer(qc->dev, (unsigned char*)pad_buf, 2, do_write);
+		for (i = 0; i < (bytes + 1) / 2; i++)
+			ap->ops->data_xfer(qc->dev, (unsigned char *)pad_buf, 2, do_write);
@@ -4696,3 +5219 @@
-		ap->hsm_task_state = HSM_ST_LAST;
-		return;
-	}
+		qc->curbytes += bytes;
@@ -4700 +5221,2 @@
-	sg = &qc->__sg[qc->cursg];
+		return 0;
+	}
@@ -4702 +5224 @@
-	page = sg->page;
+	page = sg_page(sg);
@@ -4734,0 +5257,2 @@
+	if ((count & 1) && bytes)
+		bytes--;
@@ -4739 +5263 @@
-		qc->cursg++;
+		qc->cursg = sg_next(qc->cursg);
@@ -4744,0 +5269,2 @@
+
+	return 0;
@@ -4787 +5313,3 @@
-	__atapi_pio_bytes(qc, bytes);
+	if (__atapi_pio_bytes(qc, bytes))
+		goto err_out;
+	ata_altstatus(ap); /* flush */
@@ -4933,5 +5461,13 @@
-			ata_port_printk(ap, KERN_WARNING, "DRQ=1 with device "
-					"error, dev_stat 0x%X\n", status);
-			qc->err_mask |= AC_ERR_HSM;
-			ap->hsm_task_state = HSM_ST_ERR;
-			goto fsm_start;
+			/* Some ATAPI tape drives forget to clear the ERR bit
+			 * when doing the next command (mostly request sense).
+			 * We ignore ERR here to workaround and proceed sending
+			 * the CDB.
+			 */
+			if (!(qc->dev->horkage & ATA_HORKAGE_STUCK_ERR)) {
+				ata_port_printk(ap, KERN_WARNING,
+						"DRQ=1 with device error, "
+						"dev_stat 0x%X\n", status);
+				qc->err_mask |= AC_ERR_HSM;
+				ap->hsm_task_state = HSM_ST_ERR;
+				goto fsm_start;
+			}
@@ -4959 +5494,0 @@
-			ata_altstatus(ap); /* flush */
@@ -5040 +5574,0 @@
-					ata_altstatus(ap);
@@ -5060 +5593,0 @@
-				ata_altstatus(ap);
@@ -5066 +5598,0 @@
-		ata_altstatus(ap); /* flush */
@@ -5191 +5723 @@
-	struct ata_port *ap = dev->ap;
+	struct ata_port *ap = dev->link->ap;
@@ -5233,0 +5766 @@
+	struct ata_link *link = qc->dev->link;
@@ -5242,4 +5775,13 @@
-	if (qc->tf.protocol == ATA_PROT_NCQ)
-		ap->sactive &= ~(1 << qc->tag);
-	else
-		ap->active_tag = ATA_TAG_POISON;
+	if (qc->tf.protocol == ATA_PROT_NCQ) {
+		link->sactive &= ~(1 << qc->tag);
+		if (!link->sactive)
+			ap->nr_active_links--;
+	} else {
+		link->active_tag = ATA_TAG_POISON;
+		ap->nr_active_links--;
+	}
+
+	/* clear exclusive status */
+	if (unlikely(qc->flags & ATA_QCFLAG_CLEAR_EXCL &&
+		     ap->excl_link == link))
+		ap->excl_link = NULL;
@@ -5294,0 +5837,3 @@
+		struct ata_device *dev = qc->dev;
+		struct ata_eh_info *ehi = &dev->link->eh_info;
+
@@ -5312,0 +5858,21 @@
+		/* Some commands need post-processing after successful
+		 * completion.
+		 */
+		switch (qc->tf.command) {
+		case ATA_CMD_SET_FEATURES:
+			if (qc->tf.feature != SETFEATURES_WC_ON &&
+			    qc->tf.feature != SETFEATURES_WC_OFF)
+				break;
+			/* fall through */
+		case ATA_CMD_INIT_DEV_PARAMS: /* CHS translation changed */
+		case ATA_CMD_SET_MULTI: /* multi_count changed */
+			/* revalidate device */
+			ehi->dev_action[dev->devno] |= ATA_EH_REVALIDATE;
+			ata_port_schedule_eh(ap);
+			break;
+
+		case ATA_CMD_SLEEP:
+			dev->flags |= ATA_DFLAG_SLEEPING;
+			break;
+		}
+
@@ -5413,0 +5980 @@
+	struct ata_link *link = qc->dev->link;
@@ -5419 +5986 @@
-	WARN_ON(ap->ops->error_handler && ata_tag_valid(ap->active_tag));
+	WARN_ON(ap->ops->error_handler && ata_tag_valid(link->active_tag));
@@ -5422,2 +5989,5 @@
-		WARN_ON(ap->sactive & (1 << qc->tag));
-		ap->sactive |= 1 << qc->tag;
+		WARN_ON(link->sactive & (1 << qc->tag));
+
+		if (!link->sactive)
+			ap->nr_active_links++;
+		link->sactive |= 1 << qc->tag;
@@ -5425,2 +5995,4 @@
-		WARN_ON(ap->sactive);
-		ap->active_tag = qc->tag;
+		WARN_ON(link->sactive);
+
+		ap->nr_active_links++;
+		link->active_tag = qc->tag;
@@ -5443,0 +6016,8 @@
+	/* if device is sleeping, schedule softreset and abort the link */
+	if (unlikely(qc->dev->flags & ATA_DFLAG_SLEEPING)) {
+		link->eh_info.action |= ATA_EH_SOFTRESET;
+		ata_ehi_push_desc(&link->eh_info, "waking up from sleep");
+		ata_link_abort(link);
+		return;
+	}
+
@@ -5606,2 +6186,2 @@
-inline unsigned int ata_host_intr (struct ata_port *ap,
-				   struct ata_queued_cmd *qc)
+inline unsigned int ata_host_intr(struct ata_port *ap,
+				  struct ata_queued_cmd *qc)
@@ -5609 +6189 @@
-	struct ata_eh_info *ehi = &ap->eh_info;
+	struct ata_eh_info *ehi = &ap->link.eh_info;
@@ -5683 +6263,2 @@
-		ap->ops->irq_ack(ap, 0); /* debug trap */
+		ata_chk_status(ap);
+		ap->ops->irq_clear(ap);
@@ -5706 +6287 @@
-irqreturn_t ata_interrupt (int irq, void *dev_instance)
+irqreturn_t ata_interrupt(int irq, void *dev_instance)
@@ -5724 +6305 @@
-			qc = ata_qc_from_tag(ap, ap->active_tag);
+			qc = ata_qc_from_tag(ap, ap->link.active_tag);
@@ -5738 +6319 @@
- *	@ap: ATA port to test SCR accessibility for
+ *	@link: ATA link to test SCR accessibility for
@@ -5740 +6321 @@
- *	Test whether SCRs are accessible for @ap.
+ *	Test whether SCRs are accessible for @link.
@@ -5748 +6329 @@
-int sata_scr_valid(struct ata_port *ap)
+int sata_scr_valid(struct ata_link *link)
@@ -5749,0 +6331,2 @@
+	struct ata_port *ap = link->ap;
+
@@ -5755 +6338 @@
- *	@ap: ATA port to read SCR for
+ *	@link: ATA link to read SCR for
@@ -5759,3 +6342,3 @@
- *	Read SCR register @reg of @ap into *@val.  This function is
- *	guaranteed to succeed if the cable type of the port is SATA
- *	and the port implements ->scr_read.
+ *	Read SCR register @reg of @link into *@val.  This function is
+ *	guaranteed to succeed if @link is ap->link, the cable type of
+ *	the port is SATA and the port implements ->scr_read.
@@ -5764 +6347 @@
- *	None.
+ *	None if @link is ap->link.  Kernel thread context otherwise.
@@ -5769 +6352 @@
-int sata_scr_read(struct ata_port *ap, int reg, u32 *val)
+int sata_scr_read(struct ata_link *link, int reg, u32 *val)
@@ -5771,3 +6354,9 @@
-	if (sata_scr_valid(ap))
-		return ap->ops->scr_read(ap, reg, val);
-	return -EOPNOTSUPP;
+	if (ata_is_host_link(link)) {
+		struct ata_port *ap = link->ap;
+
+		if (sata_scr_valid(link))
+			return ap->ops->scr_read(ap, reg, val);
+		return -EOPNOTSUPP;
+	}
+
+	return sata_pmp_scr_read(link, reg, val);
@@ -5778 +6367 @@
- *	@ap: ATA port to write SCR for
+ *	@link: ATA link to write SCR for
@@ -5782,3 +6371,3 @@
- *	Write @val to SCR register @reg of @ap.  This function is
- *	guaranteed to succeed if the cable type of the port is SATA
- *	and the port implements ->scr_read.
+ *	Write @val to SCR register @reg of @link.  This function is
+ *	guaranteed to succeed if @link is ap->link, the cable type of
+ *	the port is SATA and the port implements ->scr_read.
@@ -5787 +6376 @@
- *	None.
+ *	None if @link is ap->link.  Kernel thread context otherwise.
@@ -5792 +6381 @@
-int sata_scr_write(struct ata_port *ap, int reg, u32 val)
+int sata_scr_write(struct ata_link *link, int reg, u32 val)
@@ -5794,3 +6383,9 @@
-	if (sata_scr_valid(ap))
-		return ap->ops->scr_write(ap, reg, val);
-	return -EOPNOTSUPP;
+	if (ata_is_host_link(link)) {
+		struct ata_port *ap = link->ap;
+
+		if (sata_scr_valid(link))
+			return ap->ops->scr_write(ap, reg, val);
+		return -EOPNOTSUPP;
+	}
+
+	return sata_pmp_scr_write(link, reg, val);
@@ -5801 +6396 @@
- *	@ap: ATA port to write SCR for
+ *	@link: ATA link to write SCR for
@@ -5809 +6404 @@
- *	None.
+ *	None if @link is ap->link.  Kernel thread context otherwise.
@@ -5814 +6409 @@
-int sata_scr_write_flush(struct ata_port *ap, int reg, u32 val)
+int sata_scr_write_flush(struct ata_link *link, int reg, u32 val)
@@ -5816 +6411,3 @@
-	int rc;
+	if (ata_is_host_link(link)) {
+		struct ata_port *ap = link->ap;
+		int rc;
@@ -5818,5 +6415,7 @@
-	if (sata_scr_valid(ap)) {
-		rc = ap->ops->scr_write(ap, reg, val);
-		if (rc == 0)
-			rc = ap->ops->scr_read(ap, reg, &val);
-		return rc;
+		if (sata_scr_valid(link)) {
+			rc = ap->ops->scr_write(ap, reg, val);
+			if (rc == 0)
+				rc = ap->ops->scr_read(ap, reg, &val);
+			return rc;
+		}
+		return -EOPNOTSUPP;
@@ -5824 +6423,2 @@
-	return -EOPNOTSUPP;
+
+	return sata_pmp_scr_write(link, reg, val);
@@ -5828,2 +6428,2 @@
- *	ata_port_online - test whether the given port is online
- *	@ap: ATA port to test
+ *	ata_link_online - test whether the given link is online
+ *	@link: ATA link to test
@@ -5831,3 +6431,3 @@
- *	Test whether @ap is online.  Note that this function returns 0
- *	if online status of @ap cannot be obtained, so
- *	ata_port_online(ap) != !ata_port_offline(ap).
+ *	Test whether @link is online.  Note that this function returns
+ *	0 if online status of @link cannot be obtained, so
+ *	ata_link_online(link) != !ata_link_offline(link).
@@ -5841 +6441 @@
-int ata_port_online(struct ata_port *ap)
+int ata_link_online(struct ata_link *link)
@@ -5845 +6445,2 @@
-	if (!sata_scr_read(ap, SCR_STATUS, &sstatus) && (sstatus & 0xf) == 0x3)
+	if (sata_scr_read(link, SCR_STATUS, &sstatus) == 0 &&
+	    (sstatus & 0xf) == 0x3)
@@ -5851,2 +6452,2 @@
- *	ata_port_offline - test whether the given port is offline
- *	@ap: ATA port to test
+ *	ata_link_offline - test whether the given link is offline
+ *	@link: ATA link to test
@@ -5854,3 +6455,3 @@
- *	Test whether @ap is offline.  Note that this function returns
- *	0 if offline status of @ap cannot be obtained, so
- *	ata_port_online(ap) != !ata_port_offline(ap).
+ *	Test whether @link is offline.  Note that this function
+ *	returns 0 if offline status of @link cannot be obtained, so
+ *	ata_link_online(link) != !ata_link_offline(link).
@@ -5864 +6465 @@
-int ata_port_offline(struct ata_port *ap)
+int ata_link_offline(struct ata_link *link)
@@ -5868 +6469,2 @@
-	if (!sata_scr_read(ap, SCR_STATUS, &sstatus) && (sstatus & 0xf) != 0x3)
+	if (sata_scr_read(link, SCR_STATUS, &sstatus) == 0 &&
+	    (sstatus & 0xf) != 0x3)
@@ -5885,0 +6488,4 @@
+	/* This is wrong. On a failed flush we get back the LBA of the lost
+	   sector and we should (assuming it wasn't aborted as unknown) issue
+	   a further flush command to continue the writeback until it
+	   does not error */
@@ -5904,0 +6511 @@
+		struct ata_link *link;
@@ -5924,2 +6531,4 @@
-		ap->eh_info.action |= action;
-		ap->eh_info.flags |= ehi_flags;
+		__ata_port_for_each_link(link, ap) {
+			link->eh_info.action |= action;
+			link->eh_info.flags |= ehi_flags;
+		}
@@ -5961,0 +6571,6 @@
+	/*
+	 * disable link pm on all ports before requesting
+	 * any pm activity
+	 */
+	ata_lpm_enable(host);
+
@@ -5983,0 +6599,3 @@
+
+	/* reenable link pm */
+	ata_lpm_disable(host);
@@ -6029 +6647,2 @@
-	struct ata_port *ap = dev->ap;
+	struct ata_link *link = dev->link;
+	struct ata_port *ap = link->ap;
@@ -6033,2 +6652,2 @@
-	ap->sata_spd_limit = ap->hw_sata_spd_limit;
-	ap->sata_spd = 0;
+	link->sata_spd_limit = link->hw_sata_spd_limit;
+	link->sata_spd = 0;
@@ -6052,0 +6672,64 @@
+ *	ata_link_init - Initialize an ata_link structure
+ *	@ap: ATA port link is attached to
+ *	@link: Link structure to initialize
+ *	@pmp: Port multiplier port number
+ *
+ *	Initialize @link.
+ *
+ *	LOCKING:
+ *	Kernel thread context (may sleep)
+ */
+void ata_link_init(struct ata_port *ap, struct ata_link *link, int pmp)
+{
+	int i;
+
+	/* clear everything except for devices */
+	memset(link, 0, offsetof(struct ata_link, device[0]));
+
+	link->ap = ap;
+	link->pmp = pmp;
+	link->active_tag = ATA_TAG_POISON;
+	link->hw_sata_spd_limit = UINT_MAX;
+
+	/* can't use iterator, ap isn't initialized yet */
+	for (i = 0; i < ATA_MAX_DEVICES; i++) {
+		struct ata_device *dev = &link->device[i];
+
+		dev->link = link;
+		dev->devno = dev - link->device;
+		ata_dev_init(dev);
+	}
+}
+
+/**
+ *	sata_link_init_spd - Initialize link->sata_spd_limit
+ *	@link: Link to configure sata_spd_limit for
+ *
+ *	Initialize @link->[hw_]sata_spd_limit to the currently
+ *	configured value.
+ *
+ *	LOCKING:
+ *	Kernel thread context (may sleep).
+ *
+ *	RETURNS:
+ *	0 on success, -errno on failure.
+ */
+int sata_link_init_spd(struct ata_link *link)
+{
+	u32 scontrol, spd;
+	int rc;
+
+	rc = sata_scr_read(link, SCR_CONTROL, &scontrol);
+	if (rc)
+		return rc;
+
+	spd = (scontrol >> 4) & 0xf;
+	if (spd)
+		link->hw_sata_spd_limit &= (1 << spd) - 1;
+
+	link->sata_spd_limit = link->hw_sata_spd_limit;
+
+	return 0;
+}
+
+/**
@@ -6067 +6749,0 @@
-	unsigned int i;
@@ -6082,3 +6763,0 @@
-
-	ap->hw_sata_spd_limit = UINT_MAX;
-	ap->active_tag = ATA_TAG_POISON;
@@ -6107,6 +6786 @@
-	for (i = 0; i < ATA_MAX_DEVICES; i++) {
-		struct ata_device *dev = &ap->device[i];
-		dev->ap = ap;
-		dev->devno = i;
-		ata_dev_init(dev);
-	}
+	ata_link_init(ap, &ap->link, 0);
@@ -6132,13 +6805,0 @@
-		if ((host->flags & ATA_HOST_STARTED) && ap->ops->port_stop)
-			ap->ops->port_stop(ap);
-	}
-
-	if ((host->flags & ATA_HOST_STARTED) && host->ops->host_stop)
-		host->ops->host_stop(host);
-
-	for (i = 0; i < host->n_ports; i++) {
-		struct ata_port *ap = host->ports[i];
-
-		if (!ap)
-			continue;
-
@@ -6147,0 +6809 @@
+		kfree(ap->pmp_link);
@@ -6257,0 +6920 @@
+		ap->link.flags |= pi->link_flags;
@@ -6268,0 +6932,18 @@
+static void ata_host_stop(struct device *gendev, void *res)
+{
+	struct ata_host *host = dev_get_drvdata(gendev);
+	int i;
+
+	WARN_ON(!(host->flags & ATA_HOST_STARTED));
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
+		if (ap->ops->port_stop)
+			ap->ops->port_stop(ap);
+	}
+
+	if (host->ops->host_stop)
+		host->ops->host_stop(host);
+}
+
@@ -6286,0 +6968,2 @@
+	int have_stop = 0;
+	void *start_dr = NULL;
@@ -6297,0 +6981,16 @@
+		if (ap->ops->port_stop)
+			have_stop = 1;
+	}
+
+	if (host->ops->host_stop)
+		have_stop = 1;
+
+	if (have_stop) {
+		start_dr = devres_alloc(ata_host_stop, 0, GFP_KERNEL);
+		if (!start_dr)
+			return -ENOMEM;
+	}
+
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_port *ap = host->ports[i];
+
@@ -6301,2 +7000,4 @@
-				ata_port_printk(ap, KERN_ERR, "failed to "
-						"start port (errno=%d)\n", rc);
+				if (rc != -ENODEV)
+					dev_printk(KERN_ERR, host->dev,
+						"failed to start port %d "
+						"(errno=%d)\n", i, rc);
@@ -6306 +7006,0 @@
-
@@ -6309,0 +7010,2 @@
+	if (start_dr)
+		devres_add(host->dev, start_dr);
@@ -6319,0 +7022 @@
+	devres_free(start_dr);
@@ -6393,2 +7095,0 @@
-		int irq_line;
-		u32 scontrol;
@@ -6402,11 +7103 @@
-		if (sata_scr_read(ap, SCR_CONTROL, &scontrol) == 0) {
-			int spd = (scontrol >> 4) & 0xf;
-			if (spd)
-				ap->hw_sata_spd_limit &= (1 << spd) - 1;
-		}
-		ap->sata_spd_limit = ap->hw_sata_spd_limit;
-
-		/* report the secondary IRQ for second channel legacy */
-		irq_line = host->irq;
-		if (i == 1 && host->irq2)
-			irq_line = host->irq2;
+		sata_link_init_spd(&ap->link);
@@ -6413,0 +7105 @@
+		/* print per-port info to dmesg */
@@ -6417,4 +7109,3 @@
-		/* print per-port info to dmesg */
-		if (!ata_port_is_dummy(ap))
-			ata_port_printk(ap, KERN_INFO, "%cATA max %s cmd 0x%p "
-					"ctl 0x%p bmdma 0x%p irq %d\n",
+		if (!ata_port_is_dummy(ap)) {
+			ata_port_printk(ap, KERN_INFO,
+					"%cATA max %s %s\n",
@@ -6423,5 +7114,3 @@
-					ap->ioaddr.cmd_addr,
-					ap->ioaddr.ctl_addr,
-					ap->ioaddr.bmdma_addr,
-					irq_line);
-		else
+					ap->link.eh_info.desc);
+			ata_ehi_clear_desc(&ap->link.eh_info);
+		} else
@@ -6439 +7128 @@
-			struct ata_eh_info *ehi = &ap->eh_info;
+			struct ata_eh_info *ehi = &ap->link.eh_info;
@@ -6447 +7136,2 @@
-			ehi->probe_mask = (1 << ATA_MAX_DEVICES) - 1;
+			ehi->probe_mask =
+				(1 << ata_link_max_devices(&ap->link)) - 1;
@@ -6480,0 +7171 @@
+		ata_lpm_schedule(ap, ap->pm_policy);
@@ -6498,0 +7190,4 @@
+ *	An invalid IRQ skips the IRQ registration and expects the host to
+ *	have set polling mode on the port. In this case, @irq_handler
+ *	should be NULL.
+ *
@@ -6509 +7204 @@
-	int rc;
+	int i, rc;
@@ -6514,0 +7210,6 @@
+	/* Special case for polling mode */
+	if (!irq) {
+		WARN_ON(irq_handler);
+		return ata_host_register(host, sht);
+	}
+
@@ -6520,2 +7221,2 @@
-	/* Used to print device info at probe */
-	host->irq = irq;
+	for (i = 0; i < host->n_ports; i++)
+		ata_port_desc(host->ports[i], "irq %d", irq);
@@ -6542 +7243 @@
-void ata_port_detach(struct ata_port *ap)
+static void ata_port_detach(struct ata_port *ap)
@@ -6545 +7246,2 @@
-	int i;
+	struct ata_link *link;
+	struct ata_device *dev;
@@ -6557,2 +7259,2 @@
-	/* EH is now guaranteed to see UNLOADING, so no new device
-	 * will be attached.  Disable all existing devices.
+	/* EH is now guaranteed to see UNLOADING - EH context belongs
+	 * to us.  Disable all existing devices.
@@ -6560,6 +7262,4 @@
-	spin_lock_irqsave(ap->lock, flags);
-
-	for (i = 0; i < ATA_MAX_DEVICES; i++)
-		ata_dev_disable(&ap->device[i]);
-
-	spin_unlock_irqrestore(ap->lock, flags);
+	ata_port_for_each_link(link, ap) {
+		ata_link_for_each_dev(dev, link)
+			ata_dev_disable(dev);
+	}
@@ -6597,0 +7298,3 @@
+
+	/* the host is dead now, dissociate ACPI */
+	ata_acpi_dissociate(host);
@@ -6642 +7345 @@
-	struct device *dev = pci_dev_to_dev(pdev);
+	struct device *dev = &pdev->dev;
@@ -6850 +7552,0 @@
-	.port_disable		= ata_port_disable,
@@ -6875 +7576,0 @@
-
@@ -6911,0 +7613 @@
+EXPORT_SYMBOL_GPL(ata_std_qc_defer);
@@ -6928,4 +7630,2 @@
-EXPORT_SYMBOL_GPL(sata_phy_debounce);
-EXPORT_SYMBOL_GPL(sata_phy_resume);
-EXPORT_SYMBOL_GPL(sata_phy_reset);
-EXPORT_SYMBOL_GPL(__sata_phy_reset);
+EXPORT_SYMBOL_GPL(sata_link_debounce);
+EXPORT_SYMBOL_GPL(sata_link_resume);
@@ -6935 +7635 @@
-EXPORT_SYMBOL_GPL(sata_port_hardreset);
+EXPORT_SYMBOL_GPL(sata_link_hardreset);
@@ -6943,0 +7644 @@
+EXPORT_SYMBOL_GPL(ata_wait_after_reset);
@@ -6956,2 +7657,2 @@
-EXPORT_SYMBOL_GPL(ata_port_online);
-EXPORT_SYMBOL_GPL(ata_port_offline);
+EXPORT_SYMBOL_GPL(ata_link_online);
+EXPORT_SYMBOL_GPL(ata_link_offline);
@@ -6987,0 +7689,6 @@
+EXPORT_SYMBOL_GPL(sata_pmp_qc_defer_cmd_switch);
+EXPORT_SYMBOL_GPL(sata_pmp_std_prereset);
+EXPORT_SYMBOL_GPL(sata_pmp_std_hardreset);
+EXPORT_SYMBOL_GPL(sata_pmp_std_postreset);
+EXPORT_SYMBOL_GPL(sata_pmp_do_eh);
+
@@ -6991 +7698,4 @@
-EXPORT_SYMBOL_GPL(ata_eng_timeout);
+EXPORT_SYMBOL_GPL(ata_port_desc);
+#ifdef CONFIG_PCI
+EXPORT_SYMBOL_GPL(ata_port_pbar_desc);
+#endif /* CONFIG_PCI */
@@ -6992,0 +7703 @@
+EXPORT_SYMBOL_GPL(ata_link_abort);
@@ -6994,0 +7706 @@
+EXPORT_SYMBOL_GPL(sata_async_notification);
@@ -7001,3 +7712,0 @@
-EXPORT_SYMBOL_GPL(ata_dummy_irq_on);
-EXPORT_SYMBOL_GPL(ata_irq_ack);
-EXPORT_SYMBOL_GPL(ata_dummy_irq_ack);
--- ./projects/linux/linux-2.6.24/drivers/ata/libata-core.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/ata/libata-core.c	2008-04-17 04:49:44.000000000 +0200
@@ -89,0 +90,23 @@
+struct ata_force_param {
+	const char	*name;
+	unsigned int	cbl;
+	int		spd_limit;
+	unsigned long	xfer_mask;
+	unsigned int	horkage_on;
+	unsigned int	horkage_off;
+};
+
+struct ata_force_ent {
+	int			port;
+	int			device;
+	struct ata_force_param	param;
+};
+
+static struct ata_force_ent *ata_force_tbl;
+static int ata_force_tbl_size;
+
+static char ata_force_param_buf[PAGE_SIZE] __initdata;
+/* param_buf is thrown away after initialization, disallow read */
+module_param_string(force, ata_force_param_buf, sizeof(ata_force_param_buf), 0);
+MODULE_PARM_DESC(force, "Force ATA configurations including cable type, link speed and transfer mode (see Documentation/kernel-parameters.txt for details)");
+
@@ -94 +117 @@
-int atapi_dmadir = 0;
+static int atapi_dmadir = 0;
@@ -121,0 +145,4 @@
+int libata_allow_tpm = 0;
+module_param_named(allow_tpm, libata_allow_tpm, int, 0444);
+MODULE_PARM_DESC(allow_tpm, "Permit the use of TPM commands");
+
@@ -128,0 +156,211 @@
+ *	ata_force_cbl - force cable type according to libata.force
+ *	@ap: ATA port of interest
+ *
+ *	Force cable type according to libata.force and whine about it.
+ *	The last entry which has matching port number is used, so it
+ *	can be specified as part of device force parameters.  For
+ *	example, both "a:40c,1.00:udma4" and "1.00:40c,udma4" have the
+ *	same effect.
+ *
+ *	LOCKING:
+ *	EH context.
+ */
+void ata_force_cbl(struct ata_port *ap)
+{
+	int i;
+
+	for (i = ata_force_tbl_size - 1; i >= 0; i--) {
+		const struct ata_force_ent *fe = &ata_force_tbl[i];
+
+		if (fe->port != -1 && fe->port != ap->print_id)
+			continue;
+
+		if (fe->param.cbl == ATA_CBL_NONE)
+			continue;
+
+		ap->cbl = fe->param.cbl;
+		ata_port_printk(ap, KERN_NOTICE,
+				"FORCE: cable set to %s\n", fe->param.name);
+		return;
+	}
+}
+
+/**
+ *	ata_force_spd_limit - force SATA spd limit according to libata.force
+ *	@link: ATA link of interest
+ *
+ *	Force SATA spd limit according to libata.force and whine about
+ *	it.  When only the port part is specified (e.g. 1:), the limit
+ *	applies to all links connected to both the host link and all
+ *	fan-out ports connected via PMP.  If the device part is
+ *	specified as 0 (e.g. 1.00:), it specifies the first fan-out
+ *	link not the host link.  Device number 15 always points to the
+ *	host link whether PMP is attached or not.
+ *
+ *	LOCKING:
+ *	EH context.
+ */
+static void ata_force_spd_limit(struct ata_link *link)
+{
+	int linkno, i;
+
+	if (ata_is_host_link(link))
+		linkno = 15;
+	else
+		linkno = link->pmp;
+
+	for (i = ata_force_tbl_size - 1; i >= 0; i--) {
+		const struct ata_force_ent *fe = &ata_force_tbl[i];
+
+		if (fe->port != -1 && fe->port != link->ap->print_id)
+			continue;
+
+		if (fe->device != -1 && fe->device != linkno)
+			continue;
+
+		if (!fe->param.spd_limit)
+			continue;
+
+		link->hw_sata_spd_limit = (1 << fe->param.spd_limit) - 1;
+		ata_link_printk(link, KERN_NOTICE,
+			"FORCE: PHY spd limit set to %s\n", fe->param.name);
+		return;
+	}
+}
+
+/**
+ *	ata_force_xfermask - force xfermask according to libata.force
+ *	@dev: ATA device of interest
+ *
+ *	Force xfer_mask according to libata.force and whine about it.
+ *	For consistency with link selection, device number 15 selects
+ *	the first device connected to the host link.
+ *
+ *	LOCKING:
+ *	EH context.
+ */
+static void ata_force_xfermask(struct ata_device *dev)
+{
+	int devno = dev->link->pmp + dev->devno;
+	int alt_devno = devno;
+	int i;
+
+	/* allow n.15 for the first device attached to host port */
+	if (ata_is_host_link(dev->link) && devno == 0)
+		alt_devno = 15;
+
+	for (i = ata_force_tbl_size - 1; i >= 0; i--) {
+		const struct ata_force_ent *fe = &ata_force_tbl[i];
+		unsigned long pio_mask, mwdma_mask, udma_mask;
+
+		if (fe->port != -1 && fe->port != dev->link->ap->print_id)
+			continue;
+
+		if (fe->device != -1 && fe->device != devno &&
+		    fe->device != alt_devno)
+			continue;
+
+		if (!fe->param.xfer_mask)
+			continue;
+
+		ata_unpack_xfermask(fe->param.xfer_mask,
+				    &pio_mask, &mwdma_mask, &udma_mask);
+		if (udma_mask)
+			dev->udma_mask = udma_mask;
+		else if (mwdma_mask) {
+			dev->udma_mask = 0;
+			dev->mwdma_mask = mwdma_mask;
+		} else {
+			dev->udma_mask = 0;
+			dev->mwdma_mask = 0;
+			dev->pio_mask = pio_mask;
+		}
+
+		ata_dev_printk(dev, KERN_NOTICE,
+			"FORCE: xfer_mask set to %s\n", fe->param.name);
+		return;
+	}
+}
+
+/**
+ *	ata_force_horkage - force horkage according to libata.force
+ *	@dev: ATA device of interest
+ *
+ *	Force horkage according to libata.force and whine about it.
+ *	For consistency with link selection, device number 15 selects
+ *	the first device connected to the host link.
+ *
+ *	LOCKING:
+ *	EH context.
+ */
+static void ata_force_horkage(struct ata_device *dev)
+{
+	int devno = dev->link->pmp + dev->devno;
+	int alt_devno = devno;
+	int i;
+
+	/* allow n.15 for the first device attached to host port */
+	if (ata_is_host_link(dev->link) && devno == 0)
+		alt_devno = 15;
+
+	for (i = 0; i < ata_force_tbl_size; i++) {
+		const struct ata_force_ent *fe = &ata_force_tbl[i];
+
+		if (fe->port != -1 && fe->port != dev->link->ap->print_id)
+			continue;
+
+		if (fe->device != -1 && fe->device != devno &&
+		    fe->device != alt_devno)
+			continue;
+
+		if (!(~dev->horkage & fe->param.horkage_on) &&
+		    !(dev->horkage & fe->param.horkage_off))
+			continue;
+
+		dev->horkage |= fe->param.horkage_on;
+		dev->horkage &= ~fe->param.horkage_off;
+
+		ata_dev_printk(dev, KERN_NOTICE,
+			"FORCE: horkage modified (%s)\n", fe->param.name);
+	}
+}
+
+/**
+ *	atapi_cmd_type - Determine ATAPI command type from SCSI opcode
+ *	@opcode: SCSI opcode
+ *
+ *	Determine ATAPI command type from @opcode.
+ *
+ *	LOCKING:
+ *	None.
+ *
+ *	RETURNS:
+ *	ATAPI_{READ|WRITE|READ_CD|PASS_THRU|MISC}
+ */
+int atapi_cmd_type(u8 opcode)
+{
+	switch (opcode) {
+	case GPCMD_READ_10:
+	case GPCMD_READ_12:
+		return ATAPI_READ;
+
+	case GPCMD_WRITE_10:
+	case GPCMD_WRITE_12:
+	case GPCMD_WRITE_AND_VERIFY_10:
+		return ATAPI_WRITE;
+
+	case GPCMD_READ_CD:
+	case GPCMD_READ_CD_MSF:
+		return ATAPI_READ_CD;
+
+	case ATA_16:
+	case ATA_12:
+		if (atapi_passthru16)
+			return ATAPI_PASS_THRU;
+		/* fall thru */
+	default:
+		return ATAPI_MISC;
+	}
+}
+
+/**
@@ -453,3 +691,3 @@
-static unsigned int ata_pack_xfermask(unsigned int pio_mask,
-				      unsigned int mwdma_mask,
-				      unsigned int udma_mask)
+unsigned long ata_pack_xfermask(unsigned long pio_mask,
+				unsigned long mwdma_mask,
+				unsigned long udma_mask)
@@ -472,4 +710,2 @@
-static void ata_unpack_xfermask(unsigned int xfer_mask,
-				unsigned int *pio_mask,
-				unsigned int *mwdma_mask,
-				unsigned int *udma_mask)
+void ata_unpack_xfermask(unsigned long xfer_mask, unsigned long *pio_mask,
+			 unsigned long *mwdma_mask, unsigned long *udma_mask)
@@ -489,3 +725,3 @@
-	{ ATA_SHIFT_PIO, ATA_BITS_PIO, XFER_PIO_0 },
-	{ ATA_SHIFT_MWDMA, ATA_BITS_MWDMA, XFER_MW_DMA_0 },
-	{ ATA_SHIFT_UDMA, ATA_BITS_UDMA, XFER_UDMA_0 },
+	{ ATA_SHIFT_PIO, ATA_NR_PIO_MODES, XFER_PIO_0 },
+	{ ATA_SHIFT_MWDMA, ATA_NR_MWDMA_MODES, XFER_MW_DMA_0 },
+	{ ATA_SHIFT_UDMA, ATA_NR_UDMA_MODES, XFER_UDMA_0 },
@@ -506 +742 @@
- *	Matching XFER_* value, 0 if no match found.
+ *	Matching XFER_* value, 0xff if no match found.
@@ -508 +744 @@
-static u8 ata_xfer_mask2mode(unsigned int xfer_mask)
+u8 ata_xfer_mask2mode(unsigned long xfer_mask)
@@ -516 +752 @@
-	return 0;
+	return 0xff;
@@ -531 +767 @@
-static unsigned int ata_xfer_mode2mask(u8 xfer_mode)
+unsigned long ata_xfer_mode2mask(u8 xfer_mode)
@@ -537 +773,2 @@
-			return 1 << (ent->shift + xfer_mode - ent->base);
+			return ((2 << (ent->shift + xfer_mode - ent->base)) - 1)
+				& ~((1 << ent->shift) - 1);
@@ -553 +790 @@
-static int ata_xfer_mode2shift(unsigned int xfer_mode)
+int ata_xfer_mode2shift(unsigned long xfer_mode)
@@ -577 +814 @@
-static const char *ata_mode_string(unsigned int xfer_mask)
+const char *ata_mode_string(unsigned long xfer_mask)
@@ -776 +1013 @@
-	ap->link.eh_info.action |= ATA_EHI_LPM;
+	ap->link.eh_info.action |= ATA_EH_LPM;
@@ -950,2 +1187,2 @@
-	/* see if device passed diags: if master then continue and warn later */
-	if (err == 0 && dev->devno == 0)
+	/* see if device passed diags: continue and warn later */
+	if (err == 0)
@@ -1220,2 +1457,2 @@
-		/* If HPA isn't going to be unlocked, skip HPA
-		 * resizing from the next try.
+		/* If device aborted the command or HPA isn't going to
+		 * be unlocked, skip HPA resizing.
@@ -1223 +1460 @@
-		if (!ata_ignore_hpa) {
+		if (rc == -EACCES || !ata_ignore_hpa) {
@@ -1225 +1462 @@
-				       "broken, will skip HPA handling\n");
+				       "broken, skipping HPA handling\n");
@@ -1289,42 +1525,0 @@
- *	ata_id_to_dma_mode	-	Identify DMA mode from id block
- *	@dev: device to identify
- *	@unknown: mode to assume if we cannot tell
- *
- *	Set up the timing values for the device based upon the identify
- *	reported values for the DMA mode. This function is used by drivers
- *	which rely upon firmware configured modes, but wish to report the
- *	mode correctly when possible.
- *
- *	In addition we emit similarly formatted messages to the default
- *	ata_dev_set_mode handler, in order to provide consistency of
- *	presentation.
- */
-
-void ata_id_to_dma_mode(struct ata_device *dev, u8 unknown)
-{
-	unsigned int mask;
-	u8 mode;
-
-	/* Pack the DMA modes */
-	mask = ((dev->id[63] >> 8) << ATA_SHIFT_MWDMA) & ATA_MASK_MWDMA;
-	if (dev->id[53] & 0x04)
-		mask |= ((dev->id[88] >> 8) << ATA_SHIFT_UDMA) & ATA_MASK_UDMA;
-
-	/* Select the mode in use */
-	mode = ata_xfer_mask2mode(mask);
-
-	if (mode != 0) {
-		ata_dev_printk(dev, KERN_INFO, "configured for %s\n",
-		       ata_mode_string(mask));
-	} else {
-		/* SWDMA perhaps ? */
-		mode = unknown;
-		ata_dev_printk(dev, KERN_INFO, "configured for DMA\n");
-	}
-
-	/* Configure the device reporting */
-	dev->xfer_mode = mode;
-	dev->xfer_shift = ata_xfer_mode2shift(mode);
-}
-
-/**
@@ -1467 +1662 @@
-static unsigned int ata_id_xfermask(const u16 *id)
+unsigned long ata_id_xfermask(const u16 *id)
@@ -1469 +1664 @@
-	unsigned int pio_mask, mwdma_mask, udma_mask;
+	unsigned long pio_mask, mwdma_mask, udma_mask;
@@ -1522 +1717 @@
- *	ata_port_queue_task - Queue port_task
+ *	ata_pio_queue_task - Queue port_task
@@ -1534 +1729 @@
- *	port_task and EH.  ata_port_queue_task() may be ignored for EH
+ *	port_task and EH.  ata_pio_queue_task() may be ignored for EH
@@ -1540,2 +1735,2 @@
-void ata_port_queue_task(struct ata_port *ap, work_func_t fn, void *data,
-			 unsigned long delay)
+static void ata_pio_queue_task(struct ata_port *ap, void *data,
+			       unsigned long delay)
@@ -1543 +1737,0 @@
-	PREPARE_DELAYED_WORK(&ap->port_task, fn);
@@ -1567 +1761 @@
-		ata_port_printk(ap, KERN_DEBUG, "%s: EXIT\n", __FUNCTION__);
+		ata_port_printk(ap, KERN_DEBUG, "%s: EXIT\n", __func__);
@@ -1904 +2098 @@
-		ata_dev_printk(dev, KERN_DEBUG, "%s: ENTER\n", __FUNCTION__);
+		ata_dev_printk(dev, KERN_DEBUG, "%s: ENTER\n", __func__);
@@ -1939,2 +2133,2 @@
-			DPRINTK("ata%u.%d: NODEV after polling detection\n",
-				ap->print_id, dev->devno);
+			ata_dev_printk(dev, KERN_DEBUG,
+				       "NODEV after polling detection\n");
@@ -1944,7 +2138,8 @@
-		/* Device or controller might have reported the wrong
-		 * device class.  Give a shot at the other IDENTIFY if
-		 * the current one is aborted by the device.
-		 */
-		if (may_fallback &&
-		    (err_mask == AC_ERR_DEV) && (tf.feature & ATA_ABORTED)) {
-			may_fallback = 0;
+		if ((err_mask == AC_ERR_DEV) && (tf.feature & ATA_ABORTED)) {
+			/* Device or controller might have reported
+			 * the wrong device class.  Give a shot at the
+			 * other IDENTIFY if the current one is
+			 * aborted by the device.
+			 */
+			if (may_fallback) {
+				may_fallback = 0;
@@ -1952,5 +2147,14 @@
-			if (class == ATA_DEV_ATA)
-				class = ATA_DEV_ATAPI;
-			else
-				class = ATA_DEV_ATA;
-			goto retry;
+				if (class == ATA_DEV_ATA)
+					class = ATA_DEV_ATAPI;
+				else
+					class = ATA_DEV_ATA;
+				goto retry;
+			}
+
+			/* Control reaches here iff the device aborted
+			 * both flavors of IDENTIFYs which happens
+			 * sometimes with phantom devices.
+			 */
+			ata_dev_printk(dev, KERN_DEBUG,
+				       "both IDENTIFYs aborted, assuming NODEV\n");
+			return -ENOENT;
@@ -2093 +2297 @@
-	unsigned int xfer_mask;
+	unsigned long xfer_mask;
@@ -2101 +2305 @@
-			       __FUNCTION__);
+			       __func__);
@@ -2106 +2310 @@
-		ata_dev_printk(dev, KERN_DEBUG, "%s: ENTER\n", __FUNCTION__);
+		ata_dev_printk(dev, KERN_DEBUG, "%s: ENTER\n", __func__);
@@ -2109,0 +2314 @@
+	ata_force_horkage(dev);
@@ -2126 +2331 @@
-			       __FUNCTION__,
+			       __func__,
@@ -2164 +2369 @@
-		} else
+		} else {
@@ -2165,0 +2371,6 @@
+			/* Warn the user if the device has TPM extensions */
+			if (ata_id_has_tpm(id))
+				ata_dev_printk(dev, KERN_WARNING,
+					       "supports DRM functions and may "
+					       "not be fully accessable.\n");
+		}
@@ -2236,0 +2448 @@
+		const char *dma_dir_string = "";
@@ -2276,0 +2489,5 @@
+		if (atapi_dmadir || atapi_id_dmadir(dev->id)) {
+			dev->flags |= ATA_DFLAG_DMADIR;
+			dma_dir_string = ", DMADIR";
+		}
+
@@ -2280 +2497 @@
-				       "ATAPI: %s, %s, max %s%s%s\n",
+				       "ATAPI: %s, %s, max %s%s%s%s\n",
@@ -2283 +2500,2 @@
-				       cdb_intr_string, atapi_an_string);
+				       cdb_intr_string, atapi_an_string,
+				       dma_dir_string);
@@ -2298,13 +2516,2 @@
-	if (dev->horkage & ATA_HORKAGE_DIAGNOSTIC) {
-		/* Let the user know. We don't want to disallow opens for
-		   rescue purposes, or in case the vendor is just a blithering
-		   idiot */
-		if (print_info) {
-			ata_dev_printk(dev, KERN_WARNING,
-"Drive reports diagnostics failure. This may indicate a drive\n");
-			ata_dev_printk(dev, KERN_WARNING,
-"fault or invalid emulation. Contact drive vendor for information.\n");
-		}
-	}
-
-	/* limit bridge transfers to udma5, 200 sectors */
+	/* Limit PATA drive on SATA cable bridge transfers to udma5,
+	   200 sectors */
@@ -2338,0 +2546,15 @@
+	if (dev->horkage & ATA_HORKAGE_DIAGNOSTIC) {
+		/* Let the user know. We don't want to disallow opens for
+		   rescue purposes, or in case the vendor is just a blithering
+		   idiot. Do this after the dev_config call as some controllers
+		   with buggy firmware may want to avoid reporting false device
+		   bugs */
+
+		if (print_info) {
+			ata_dev_printk(dev, KERN_WARNING,
+"Drive reports diagnostics failure. This may indicate a drive\n");
+			ata_dev_printk(dev, KERN_WARNING,
+"fault or invalid emulation. Contact drive vendor for information.\n");
+		}
+	}
+
@@ -2341 +2563 @@
-			__FUNCTION__, ata_chk_status(ap));
+			__func__, ata_chk_status(ap));
@@ -2347 +2569 @@
-			       "%s: EXIT, err\n", __FUNCTION__);
+			       "%s: EXIT, err\n", __func__);
@@ -2389,0 +2612,12 @@
+ *	ata_cable_ignore	-	return ignored PATA cable.
+ *	@ap: port
+ *
+ *	Helper method for drivers which don't use cable type to limit
+ *	transfer mode.
+ */
+int ata_cable_ignore(struct ata_port *ap)
+{
+	return ATA_CBL_PATA_IGN;
+}
+
+/**
@@ -2467 +2701 @@
-	ata_link_for_each_dev(dev, &ap->link) {
+	ata_link_for_each_dev_reverse(dev, &ap->link) {
@@ -2783,0 +3018,8 @@
+/*	{ XFER_PIO_SLOW, 120, 290, 240, 960, 290, 240, 960,   0 }, */
+	{ XFER_PIO_0,     70, 290, 240, 600, 165, 150, 600,   0 },
+	{ XFER_PIO_1,     50, 290,  93, 383, 125, 100, 383,   0 },
+	{ XFER_PIO_2,     30, 290,  40, 330, 100,  90, 240,   0 },
+	{ XFER_PIO_3,     30,  80,  70, 180,  80,  70, 180,   0 },
+	{ XFER_PIO_4,     25,  70,  25, 120,  70,  25, 120,   0 },
+	{ XFER_PIO_5,     15,  65,  25, 100,  65,  25, 100,   0 },
+	{ XFER_PIO_6,     10,  55,  20,  80,  55,  20,  80,   0 },
@@ -2785,4 +3027,3 @@
-	{ XFER_UDMA_6,     0,   0,   0,   0,   0,   0,   0,  15 },
-	{ XFER_UDMA_5,     0,   0,   0,   0,   0,   0,   0,  20 },
-	{ XFER_UDMA_4,     0,   0,   0,   0,   0,   0,   0,  30 },
-	{ XFER_UDMA_3,     0,   0,   0,   0,   0,   0,   0,  45 },
+	{ XFER_SW_DMA_0, 120,   0,   0,   0, 480, 480, 960,   0 },
+	{ XFER_SW_DMA_1,  90,   0,   0,   0, 240, 240, 480,   0 },
+	{ XFER_SW_DMA_2,  60,   0,   0,   0, 120, 120, 240,   0 },
@@ -2790 +3031,3 @@
-	{ XFER_MW_DMA_4,  25,   0,   0,   0,  55,  20,  80,   0 },
+	{ XFER_MW_DMA_0,  60,   0,   0,   0, 215, 215, 480,   0 },
+	{ XFER_MW_DMA_1,  45,   0,   0,   0,  80,  50, 150,   0 },
+	{ XFER_MW_DMA_2,  25,   0,   0,   0,  70,  25, 120,   0 },
@@ -2792,3 +3035 @@
-	{ XFER_UDMA_2,     0,   0,   0,   0,   0,   0,   0,  60 },
-	{ XFER_UDMA_1,     0,   0,   0,   0,   0,   0,   0,  80 },
-	{ XFER_UDMA_0,     0,   0,   0,   0,   0,   0,   0, 120 },
+	{ XFER_MW_DMA_4,  25,   0,   0,   0,  55,  20,  80,   0 },
@@ -2797,19 +3038,7 @@
-
-	{ XFER_MW_DMA_2,  25,   0,   0,   0,  70,  25, 120,   0 },
-	{ XFER_MW_DMA_1,  45,   0,   0,   0,  80,  50, 150,   0 },
-	{ XFER_MW_DMA_0,  60,   0,   0,   0, 215, 215, 480,   0 },
-
-	{ XFER_SW_DMA_2,  60,   0,   0,   0, 120, 120, 240,   0 },
-	{ XFER_SW_DMA_1,  90,   0,   0,   0, 240, 240, 480,   0 },
-	{ XFER_SW_DMA_0, 120,   0,   0,   0, 480, 480, 960,   0 },
-
-	{ XFER_PIO_6,     10,  55,  20,  80,  55,  20,  80,   0 },
-	{ XFER_PIO_5,     15,  65,  25, 100,  65,  25, 100,   0 },
-	{ XFER_PIO_4,     25,  70,  25, 120,  70,  25, 120,   0 },
-	{ XFER_PIO_3,     30,  80,  70, 180,  80,  70, 180,   0 },
-
-	{ XFER_PIO_2,     30, 290,  40, 330, 100,  90, 240,   0 },
-	{ XFER_PIO_1,     50, 290,  93, 383, 125, 100, 383,   0 },
-	{ XFER_PIO_0,     70, 290, 240, 600, 165, 150, 600,   0 },
-
-/*	{ XFER_PIO_SLOW, 120, 290, 240, 960, 290, 240, 960,   0 }, */
+	{ XFER_UDMA_0,     0,   0,   0,   0,   0,   0,   0, 120 },
+	{ XFER_UDMA_1,     0,   0,   0,   0,   0,   0,   0,  80 },
+	{ XFER_UDMA_2,     0,   0,   0,   0,   0,   0,   0,  60 },
+	{ XFER_UDMA_3,     0,   0,   0,   0,   0,   0,   0,  45 },
+	{ XFER_UDMA_4,     0,   0,   0,   0,   0,   0,   0,  30 },
+	{ XFER_UDMA_5,     0,   0,   0,   0,   0,   0,   0,  20 },
+	{ XFER_UDMA_6,     0,   0,   0,   0,   0,   0,   0,  15 },
@@ -2848 +3077 @@
-static const struct ata_timing *ata_timing_find_mode(unsigned short speed)
+const struct ata_timing *ata_timing_find_mode(u8 xfer_mode)
@@ -2850 +3079,4 @@
-	const struct ata_timing *t;
+	const struct ata_timing *t = ata_timing;
+
+	while (xfer_mode > t->mode)
+		t++;
@@ -2852,4 +3084,3 @@
-	for (t = ata_timing; t->mode != speed; t++)
-		if (t->mode == 0xFF)
-			return NULL;
-	return t;
+	if (xfer_mode == t->mode)
+		return t;
+	return NULL;
@@ -2929,0 +3161,51 @@
+ *	ata_timing_cycle2mode - find xfer mode for the specified cycle duration
+ *	@xfer_shift: ATA_SHIFT_* value for transfer type to examine.
+ *	@cycle: cycle duration in ns
+ *
+ *	Return matching xfer mode for @cycle.  The returned mode is of
+ *	the transfer type specified by @xfer_shift.  If @cycle is too
+ *	slow for @xfer_shift, 0xff is returned.  If @cycle is faster
+ *	than the fastest known mode, the fasted mode is returned.
+ *
+ *	LOCKING:
+ *	None.
+ *
+ *	RETURNS:
+ *	Matching xfer_mode, 0xff if no match found.
+ */
+u8 ata_timing_cycle2mode(unsigned int xfer_shift, int cycle)
+{
+	u8 base_mode = 0xff, last_mode = 0xff;
+	const struct ata_xfer_ent *ent;
+	const struct ata_timing *t;
+
+	for (ent = ata_xfer_tbl; ent->shift >= 0; ent++)
+		if (ent->shift == xfer_shift)
+			base_mode = ent->base;
+
+	for (t = ata_timing_find_mode(base_mode);
+	     t && ata_xfer_mode2shift(t->mode) == xfer_shift; t++) {
+		unsigned short this_cycle;
+
+		switch (xfer_shift) {
+		case ATA_SHIFT_PIO:
+		case ATA_SHIFT_MWDMA:
+			this_cycle = t->cycle;
+			break;
+		case ATA_SHIFT_UDMA:
+			this_cycle = t->udma;
+			break;
+		default:
+			return 0xff;
+		}
+
+		if (cycle > this_cycle)
+			break;
+
+		last_mode = t->mode;
+	}
+
+	return last_mode;
+}
+
+/**
@@ -2947,2 +3229,2 @@
-	unsigned int orig_mask, xfer_mask;
-	unsigned int pio_mask, mwdma_mask, udma_mask;
+	unsigned long orig_mask, xfer_mask;
+	unsigned long pio_mask, mwdma_mask, udma_mask;
@@ -3020,0 +3303,2 @@
+	const char *dev_err_whine = "";
+	int ign_dev_err = 0;
@@ -3029,0 +3314,10 @@
+	if (err_mask & ~AC_ERR_DEV)
+		goto fail;
+
+	/* revalidate */
+	ehc->i.flags |= ATA_EHI_POST_SETMODE;
+	rc = ata_dev_revalidate(dev, ATA_DEV_UNKNOWN, 0);
+	ehc->i.flags &= ~ATA_EHI_POST_SETMODE;
+	if (rc)
+		return rc;
+
@@ -3032 +3326 @@
-		err_mask &= ~AC_ERR_DEV;
+		ign_dev_err = 1;
@@ -3038 +3332 @@
-		err_mask &= ~AC_ERR_DEV;
+		ign_dev_err = 1;
@@ -3042 +3336 @@
-	if (dev->xfer_shift == ATA_SHIFT_MWDMA && 
+	if (dev->xfer_shift == ATA_SHIFT_MWDMA &&
@@ -3045 +3339 @@
-		err_mask &= ~AC_ERR_DEV;
+		ign_dev_err = 1;
@@ -3047,5 +3341,3 @@
-	if (err_mask) {
-		ata_dev_printk(dev, KERN_ERR, "failed to set xfermode "
-			       "(err_mask=0x%x)\n", err_mask);
-		return -EIO;
-	}
+	/* if the device is actually configured correctly, ignore dev err */
+	if (dev->xfer_mode == ata_xfer_mask2mode(ata_id_xfermask(dev->id)))
+		ign_dev_err = 1;
@@ -3053,5 +3345,6 @@
-	ehc->i.flags |= ATA_EHI_POST_SETMODE;
-	rc = ata_dev_revalidate(dev, ATA_DEV_UNKNOWN, 0);
-	ehc->i.flags &= ~ATA_EHI_POST_SETMODE;
-	if (rc)
-		return rc;
+	if (err_mask & AC_ERR_DEV) {
+		if (!ign_dev_err)
+			goto fail;
+		else
+			dev_err_whine = " (device error ignored)";
+	}
@@ -3062,2 +3355,4 @@
-	ata_dev_printk(dev, KERN_INFO, "configured for %s\n",
-		       ata_mode_string(ata_xfer_mode2mask(dev->xfer_mode)));
+	ata_dev_printk(dev, KERN_INFO, "configured for %s%s\n",
+		       ata_mode_string(ata_xfer_mode2mask(dev->xfer_mode)),
+		       dev_err_whine);
+
@@ -3064,0 +3360,5 @@
+
+ fail:
+	ata_dev_printk(dev, KERN_ERR, "failed to set xfermode "
+		       "(err_mask=0x%x)\n", err_mask);
+	return -EIO;
@@ -3070 +3370 @@
- *	@r_failed_dev: out paramter for failed device
+ *	@r_failed_dev: out parameter for failed device
@@ -3092 +3392 @@
-		unsigned int pio_mask, dma_mask;
+		unsigned long pio_mask, dma_mask;
@@ -3104,0 +3405 @@
+		ata_force_xfermask(dev);
@@ -3118 +3419 @@
-		if (dev->dma_mode)
+		if (dev->dma_mode != 0xff)
@@ -3129 +3430 @@
-		if (!dev->pio_mode) {
+		if (dev->pio_mode == 0xff) {
@@ -3143 +3444 @@
-		if (!ata_dev_enabled(dev) || !dev->dma_mode)
+		if (!ata_dev_enabled(dev) || dev->dma_mode == 0xff)
@@ -3176,25 +3476,0 @@
- *	ata_set_mode - Program timings and issue SET FEATURES - XFER
- *	@link: link on which timings will be programmed
- *	@r_failed_dev: out paramter for failed device
- *
- *	Set ATA device disk transfer mode (PIO3, UDMA6, etc.).  If
- *	ata_set_mode() fails, pointer to the failing device is
- *	returned in @r_failed_dev.
- *
- *	LOCKING:
- *	PCI/etc. bus probe sem.
- *
- *	RETURNS:
- *	0 on success, negative errno otherwise
- */
-int ata_set_mode(struct ata_link *link, struct ata_device **r_failed_dev)
-{
-	struct ata_port *ap = link->ap;
-
-	/* has private set_mode? */
-	if (ap->ops->set_mode)
-		return ap->ops->set_mode(link, r_failed_dev);
-	return ata_do_set_mode(link, r_failed_dev);
-}
-
-/**
@@ -4152,2 +4427,0 @@
-	{ "HITACHI HDS7250SASUN500G*", NULL,    ATA_HORKAGE_NONCQ },
-	{ "HITACHI HDS7225SBSUN250G*", NULL,    ATA_HORKAGE_NONCQ },
@@ -4171,0 +4446 @@
+	{ "ST310211A",		NULL,		ATA_HORKAGE_HPA_SIZE, },
@@ -4366 +4641,8 @@
-	tf.nsect = dev->xfer_mode;
+	/* If we are using IORDY we must send the mode setting command */
+	if (ata_pio_need_iordy(dev))
+		tf.nsect = dev->xfer_mode;
+	/* If the device has IORDY and the controller does not - turn it off */
+ 	else if (ata_id_has_iordy(dev->id))
+		tf.nsect = 0x01;
+	else /* In the ancient relic department - skip all of this */
+		return 0;
@@ -4465 +4747 @@
-	struct scatterlist *sg = qc->__sg;
+	struct scatterlist *sg = qc->sg;
@@ -4467 +4748,0 @@
-	void *pad_buf = NULL;
@@ -4469 +4749,0 @@
-	WARN_ON(!(qc->flags & ATA_QCFLAG_DMAMAP));
@@ -4472,3 +4751,0 @@
-	if (qc->flags & ATA_QCFLAG_SINGLE)
-		WARN_ON(qc->n_elem > 1);
-
@@ -4477,29 +4754,2 @@
-	/* if we padded the buffer out to 32-bit bound, and data
-	 * xfer direction is from-device, we must copy from the
-	 * pad buffer back into the supplied buffer
-	 */
-	if (qc->pad_len && !(qc->tf.flags & ATA_TFLAG_WRITE))
-		pad_buf = ap->pad + (qc->tag * ATA_DMA_PAD_SZ);
-
-	if (qc->flags & ATA_QCFLAG_SG) {
-		if (qc->n_elem)
-			dma_unmap_sg(ap->dev, sg, qc->n_elem, dir);
-		/* restore last sg */
-		sg_last(sg, qc->orig_n_elem)->length += qc->pad_len;
-		if (pad_buf) {
-			struct scatterlist *psg = &qc->pad_sgent;
-			void *addr = kmap_atomic(sg_page(psg), KM_IRQ0);
-			memcpy(addr + psg->offset, pad_buf, qc->pad_len);
-			kunmap_atomic(addr, KM_IRQ0);
-		}
-	} else {
-		if (qc->n_elem)
-			dma_unmap_single(ap->dev,
-				sg_dma_address(&sg[0]), sg_dma_len(&sg[0]),
-				dir);
-		/* restore sg */
-		sg->length += qc->pad_len;
-		if (pad_buf)
-			memcpy(qc->buf_virt + sg->length - qc->pad_len,
-			       pad_buf, qc->pad_len);
-	}
+	if (qc->n_elem)
+		dma_unmap_sg(ap->dev, sg, qc->n_elem, dir);
@@ -4508 +4758 @@
-	qc->__sg = NULL;
+	qc->sg = NULL;
@@ -4526 +4776 @@
-	unsigned int idx;
+	unsigned int si, pi;
@@ -4528,5 +4778,2 @@
-	WARN_ON(qc->__sg == NULL);
-	WARN_ON(qc->n_elem == 0 && qc->pad_len == 0);
-
-	idx = 0;
-	ata_for_each_sg(sg, qc) {
+	pi = 0;
+	for_each_sg(qc->sg, sg, qc->n_elem, si) {
@@ -4549,3 +4796,3 @@
-			ap->prd[idx].addr = cpu_to_le32(addr);
-			ap->prd[idx].flags_len = cpu_to_le32(len & 0xffff);
-			VPRINTK("PRD[%u] = (0x%X, 0x%X)\n", idx, addr, len);
+			ap->prd[pi].addr = cpu_to_le32(addr);
+			ap->prd[pi].flags_len = cpu_to_le32(len & 0xffff);
+			VPRINTK("PRD[%u] = (0x%X, 0x%X)\n", pi, addr, len);
@@ -4553 +4800 @@
-			idx++;
+			pi++;
@@ -4559,2 +4806 @@
-	if (idx)
-		ap->prd[idx - 1].flags_len |= cpu_to_le32(ATA_PRD_EOT);
+	ap->prd[pi - 1].flags_len |= cpu_to_le32(ATA_PRD_EOT);
@@ -4580,4 +4826 @@
-	unsigned int idx;
-
-	WARN_ON(qc->__sg == NULL);
-	WARN_ON(qc->n_elem == 0 && qc->pad_len == 0);
+	unsigned int si, pi;
@@ -4585,2 +4828,2 @@
-	idx = 0;
-	ata_for_each_sg(sg, qc) {
+	pi = 0;
+	for_each_sg(qc->sg, sg, qc->n_elem, si) {
@@ -4604 +4847 @@
-			ap->prd[idx].addr = cpu_to_le32(addr);
+			ap->prd[pi].addr = cpu_to_le32(addr);
@@ -4608 +4851 @@
-				ap->prd[idx].flags_len = cpu_to_le32(0x8000);
+				ap->prd[pi].flags_len = cpu_to_le32(0x8000);
@@ -4610 +4853 @@
-				ap->prd[++idx].addr = cpu_to_le32(addr + 0x8000);
+				ap->prd[++pi].addr = cpu_to_le32(addr + 0x8000);
@@ -4612,2 +4855,2 @@
-			ap->prd[idx].flags_len = cpu_to_le32(blen);
-			VPRINTK("PRD[%u] = (0x%X, 0x%X)\n", idx, addr, len);
+			ap->prd[pi].flags_len = cpu_to_le32(blen);
+			VPRINTK("PRD[%u] = (0x%X, 0x%X)\n", pi, addr, len);
@@ -4615 +4858 @@
-			idx++;
+			pi++;
@@ -4621,2 +4864 @@
-	if (idx)
-		ap->prd[idx - 1].flags_len |= cpu_to_le32(ATA_PRD_EOT);
+	ap->prd[pi - 1].flags_len |= cpu_to_le32(ATA_PRD_EOT);
@@ -4656,37 +4897,0 @@
- *	atapi_qc_may_overflow - Check whether data transfer may overflow
- *	@qc: ATA command in question
- *
- *	ATAPI commands which transfer variable length data to host
- *	might overflow due to application error or hardare bug.  This
- *	function checks whether overflow should be drained and ignored
- *	for @qc.
- *
- *	LOCKING:
- *	None.
- *
- *	RETURNS:
- *	1 if @qc may overflow; otherwise, 0.
- */
-static int atapi_qc_may_overflow(struct ata_queued_cmd *qc)
-{
-	if (qc->tf.protocol != ATA_PROT_ATAPI &&
-	    qc->tf.protocol != ATA_PROT_ATAPI_DMA)
-		return 0;
-
-	if (qc->tf.flags & ATA_TFLAG_WRITE)
-		return 0;
-
-	switch (qc->cdb[0]) {
-	case READ_10:
-	case READ_12:
-	case WRITE_10:
-	case WRITE_12:
-	case GPCMD_READ_CD:
-	case GPCMD_READ_CD_MSF:
-		return 0;
-	}
-
-	return 1;
-}
-
-/**
@@ -4759,27 +4963,0 @@
- *	ata_sg_init_one - Associate command with memory buffer
- *	@qc: Command to be associated
- *	@buf: Memory buffer
- *	@buflen: Length of memory buffer, in bytes.
- *
- *	Initialize the data-related elements of queued_cmd @qc
- *	to point to a single memory buffer, @buf of byte length @buflen.
- *
- *	LOCKING:
- *	spin_lock_irqsave(host lock)
- */
-
-void ata_sg_init_one(struct ata_queued_cmd *qc, void *buf, unsigned int buflen)
-{
-	qc->flags |= ATA_QCFLAG_SINGLE;
-
-	qc->__sg = &qc->sgent;
-	qc->n_elem = 1;
-	qc->orig_n_elem = 1;
-	qc->buf_virt = buf;
-	qc->nbytes = buflen;
-	qc->cursg = qc->__sg;
-
-	sg_init_one(&qc->sgent, buf, buflen);
-}
-
-/**
@@ -4798 +4975,0 @@
-
@@ -4802,2 +4979 @@
-	qc->flags |= ATA_QCFLAG_SG;
-	qc->__sg = sg;
+	qc->sg = sg;
@@ -4805,71 +4981 @@
-	qc->orig_n_elem = n_elem;
-	qc->cursg = qc->__sg;
-}
-
-/**
- *	ata_sg_setup_one - DMA-map the memory buffer associated with a command.
- *	@qc: Command with memory buffer to be mapped.
- *
- *	DMA-map the memory buffer associated with queued_cmd @qc.
- *
- *	LOCKING:
- *	spin_lock_irqsave(host lock)
- *
- *	RETURNS:
- *	Zero on success, negative on error.
- */
-
-static int ata_sg_setup_one(struct ata_queued_cmd *qc)
-{
-	struct ata_port *ap = qc->ap;
-	int dir = qc->dma_dir;
-	struct scatterlist *sg = qc->__sg;
-	dma_addr_t dma_address;
-	int trim_sg = 0;
-
-	/* we must lengthen transfers to end on a 32-bit boundary */
-	qc->pad_len = sg->length & 3;
-	if (qc->pad_len) {
-		void *pad_buf = ap->pad + (qc->tag * ATA_DMA_PAD_SZ);
-		struct scatterlist *psg = &qc->pad_sgent;
-
-		WARN_ON(qc->dev->class != ATA_DEV_ATAPI);
-
-		memset(pad_buf, 0, ATA_DMA_PAD_SZ);
-
-		if (qc->tf.flags & ATA_TFLAG_WRITE)
-			memcpy(pad_buf, qc->buf_virt + sg->length - qc->pad_len,
-			       qc->pad_len);
-
-		sg_dma_address(psg) = ap->pad_dma + (qc->tag * ATA_DMA_PAD_SZ);
-		sg_dma_len(psg) = ATA_DMA_PAD_SZ;
-		/* trim sg */
-		sg->length -= qc->pad_len;
-		if (sg->length == 0)
-			trim_sg = 1;
-
-		DPRINTK("padding done, sg->length=%u pad_len=%u\n",
-			sg->length, qc->pad_len);
-	}
-
-	if (trim_sg) {
-		qc->n_elem--;
-		goto skip_map;
-	}
-
-	dma_address = dma_map_single(ap->dev, qc->buf_virt,
-				     sg->length, dir);
-	if (dma_mapping_error(dma_address)) {
-		/* restore sg */
-		sg->length += qc->pad_len;
-		return -1;
-	}
-
-	sg_dma_address(sg) = dma_address;
-	sg_dma_len(sg) = sg->length;
-
-skip_map:
-	DPRINTK("mapped buffer of %d bytes for %s\n", sg_dma_len(sg),
-		qc->tf.flags & ATA_TFLAG_WRITE ? "write" : "read");
-
-	return 0;
+	qc->cursg = qc->sg;
@@ -4891 +4996,0 @@
-
@@ -4895,3 +5000 @@
-	struct scatterlist *sg = qc->__sg;
-	struct scatterlist *lsg = sg_last(qc->__sg, qc->n_elem);
-	int n_elem, pre_n_elem, dir, trim_sg = 0;
+	unsigned int n_elem;
@@ -4900,8 +5002,0 @@
-	WARN_ON(!(qc->flags & ATA_QCFLAG_SG));
-
-	/* we must lengthen transfers to end on a 32-bit boundary */
-	qc->pad_len = lsg->length & 3;
-	if (qc->pad_len) {
-		void *pad_buf = ap->pad + (qc->tag * ATA_DMA_PAD_SZ);
-		struct scatterlist *psg = &qc->pad_sgent;
-		unsigned int offset;
@@ -4909,44 +5004,2 @@
-		WARN_ON(qc->dev->class != ATA_DEV_ATAPI);
-
-		memset(pad_buf, 0, ATA_DMA_PAD_SZ);
-
-		/*
-		 * psg->page/offset are used to copy to-be-written
-		 * data in this function or read data in ata_sg_clean.
-		 */
-		offset = lsg->offset + lsg->length - qc->pad_len;
-		sg_init_table(psg, 1);
-		sg_set_page(psg, nth_page(sg_page(lsg), offset >> PAGE_SHIFT),
-				qc->pad_len, offset_in_page(offset));
-
-		if (qc->tf.flags & ATA_TFLAG_WRITE) {
-			void *addr = kmap_atomic(sg_page(psg), KM_IRQ0);
-			memcpy(pad_buf, addr + psg->offset, qc->pad_len);
-			kunmap_atomic(addr, KM_IRQ0);
-		}
-
-		sg_dma_address(psg) = ap->pad_dma + (qc->tag * ATA_DMA_PAD_SZ);
-		sg_dma_len(psg) = ATA_DMA_PAD_SZ;
-		/* trim last sg */
-		lsg->length -= qc->pad_len;
-		if (lsg->length == 0)
-			trim_sg = 1;
-
-		DPRINTK("padding done, sg[%d].length=%u pad_len=%u\n",
-			qc->n_elem - 1, lsg->length, qc->pad_len);
-	}
-
-	pre_n_elem = qc->n_elem;
-	if (trim_sg && pre_n_elem)
-		pre_n_elem--;
-
-	if (!pre_n_elem) {
-		n_elem = 0;
-		goto skip_map;
-	}
-
-	dir = qc->dma_dir;
-	n_elem = dma_map_sg(ap->dev, sg, pre_n_elem, dir);
-	if (n_elem < 1) {
-		/* restore last sg */
-		lsg->length += qc->pad_len;
+	n_elem = dma_map_sg(ap->dev, qc->sg, qc->n_elem, qc->dma_dir);
+	if (n_elem < 1)
@@ -4954 +5006,0 @@
-	}
@@ -4958 +5009,0 @@
-skip_map:
@@ -4959,0 +5011 @@
+	qc->flags |= ATA_QCFLAG_DMAMAP;
@@ -4988 +5040 @@
- *	@adev: device to target
+ *	@dev: device to target
@@ -4991 +5043 @@
- *	@write_data: read/write
+ *	@rw: read/write
@@ -4996,0 +5049,3 @@
+ *
+ *	RETURNS:
+ *	Bytes consumed.
@@ -4998,2 +5053,2 @@
-void ata_data_xfer(struct ata_device *adev, unsigned char *buf,
-		   unsigned int buflen, int write_data)
+unsigned int ata_data_xfer(struct ata_device *dev, unsigned char *buf,
+			   unsigned int buflen, int rw)
@@ -5001 +5056,2 @@
-	struct ata_port *ap = adev->link->ap;
+	struct ata_port *ap = dev->link->ap;
+	void __iomem *data_addr = ap->ioaddr.data_addr;
@@ -5005,2 +5061,2 @@
-	if (write_data)
-		iowrite16_rep(ap->ioaddr.data_addr, buf, words);
+	if (rw == READ)
+		ioread16_rep(data_addr, buf, words);
@@ -5008 +5064 @@
-		ioread16_rep(ap->ioaddr.data_addr, buf, words);
+		iowrite16_rep(data_addr, buf, words);
@@ -5012 +5068 @@
-		u16 align_buf[1] = { 0 };
+		__le16 align_buf[1] = { 0 };
@@ -5015,5 +5071,2 @@
-		if (write_data) {
-			memcpy(align_buf, trailing_buf, 1);
-			iowrite16(le16_to_cpu(align_buf[0]), ap->ioaddr.data_addr);
-		} else {
-			align_buf[0] = cpu_to_le16(ioread16(ap->ioaddr.data_addr));
+		if (rw == READ) {
+			align_buf[0] = cpu_to_le16(ioread16(data_addr));
@@ -5020,0 +5074,3 @@
+		} else {
+			memcpy(align_buf, trailing_buf, 1);
+			iowrite16(le16_to_cpu(align_buf[0]), data_addr);
@@ -5021,0 +5078 @@
+		words++;
@@ -5022,0 +5080,2 @@
+
+	return words << 1;
@@ -5027 +5086 @@
- *	@adev: device to target
+ *	@dev: device to target
@@ -5030 +5089 @@
- *	@write_data: read/write
+ *	@rw: read/write
@@ -5036,0 +5096,3 @@
+ *
+ *	RETURNS:
+ *	Bytes consumed.
@@ -5038,2 +5100,2 @@
-void ata_data_xfer_noirq(struct ata_device *adev, unsigned char *buf,
-			 unsigned int buflen, int write_data)
+unsigned int ata_data_xfer_noirq(struct ata_device *dev, unsigned char *buf,
+				 unsigned int buflen, int rw)
@@ -5041,0 +5104,2 @@
+	unsigned int consumed;
+
@@ -5043 +5107 @@
-	ata_data_xfer(adev, buf, buflen, write_data);
+	consumed = ata_data_xfer(dev, buf, buflen, rw);
@@ -5044,0 +5109,2 @@
+
+	return consumed;
@@ -5155 +5221 @@
-	case ATA_PROT_ATAPI:
+	case ATAPI_PROT_PIO:
@@ -5158 +5224 @@
-	case ATA_PROT_ATAPI_NODATA:
+	case ATAPI_PROT_NODATA:
@@ -5161 +5227 @@
-	case ATA_PROT_ATAPI_DMA:
+	case ATAPI_PROT_DMA:
@@ -5182 +5248 @@
-	int do_write = (qc->tf.flags & ATA_TFLAG_WRITE);
+	int rw = (qc->tf.flags & ATA_TFLAG_WRITE) ? WRITE : READ;
@@ -5184 +5250,2 @@
-	struct ata_eh_info *ehi = &qc->dev->link->eh_info;
+	struct ata_device *dev = qc->dev;
+	struct ata_eh_info *ehi = &dev->link->eh_info;
@@ -5188 +5255 @@
-	unsigned int offset, count;
+	unsigned int offset, count, consumed;
@@ -5193,29 +5260,4 @@
-		/*
-		 * The end of qc->sg is reached and the device expects
-		 * more data to transfer. In order not to overrun qc->sg
-		 * and fulfill length specified in the byte count register,
-		 *    - for read case, discard trailing data from the device
-		 *    - for write case, padding zero data to the device
-		 */
-		u16 pad_buf[1] = { 0 };
-		unsigned int i;
-
-		if (bytes > qc->curbytes - qc->nbytes + ATAPI_MAX_DRAIN) {
-			ata_ehi_push_desc(ehi, "too much trailing data "
-					  "buf=%u cur=%u bytes=%u",
-					  qc->nbytes, qc->curbytes, bytes);
-			return -1;
-		}
-
-		 /* overflow is exptected for misc ATAPI commands */
-		if (bytes && !atapi_qc_may_overflow(qc))
-			ata_dev_printk(qc->dev, KERN_WARNING, "ATAPI %u bytes "
-				       "trailing data (cdb=%02x nbytes=%u)\n",
-				       bytes, qc->cdb[0], qc->nbytes);
-
-		for (i = 0; i < (bytes + 1) / 2; i++)
-			ap->ops->data_xfer(qc->dev, (unsigned char *)pad_buf, 2, do_write);
-
-		qc->curbytes += bytes;
-
-		return 0;
+		ata_ehi_push_desc(ehi, "unexpected or too much trailing data "
+				  "buf=%u cur=%u bytes=%u",
+				  qc->nbytes, qc->curbytes, bytes);
+		return -1;
@@ -5247 +5289 @@
-		ap->ops->data_xfer(qc->dev,  buf + offset, count, do_write);
+		consumed = ap->ops->data_xfer(dev,  buf + offset, count, rw);
@@ -5253 +5295 @@
-		ap->ops->data_xfer(qc->dev,  buf + offset, count, do_write);
+		consumed = ap->ops->data_xfer(dev,  buf + offset, count, rw);
@@ -5256,3 +5298 @@
-	bytes -= count;
-	if ((count & 1) && bytes)
-		bytes--;
+	bytes -= min(bytes, consumed);
@@ -5266,0 +5307,3 @@
+	/* consumed can be larger than count only for the last transfer */
+	WARN_ON(qc->cursg && count != consumed);
+
@@ -5269 +5311,0 @@
-
@@ -5286,0 +5329 @@
+	struct ata_eh_info *ehi = &dev->link->eh_info;
@@ -5303,2 +5346,2 @@
-	if (ireason & (1 << 0))
-		goto err_out;
+	if (unlikely(ireason & (1 << 0)))
+		goto atapi_check;
@@ -5308,2 +5351,5 @@
-	if (do_write != i_write)
-		goto err_out;
+	if (unlikely(do_write != i_write))
+		goto atapi_check;
+
+	if (unlikely(!bytes))
+		goto atapi_check;
@@ -5313 +5359 @@
-	if (__atapi_pio_bytes(qc, bytes))
+	if (unlikely(__atapi_pio_bytes(qc, bytes)))
@@ -5319,2 +5365,4 @@
-err_out:
-	ata_dev_printk(dev, KERN_INFO, "ATAPI check failed\n");
+ atapi_check:
+	ata_ehi_push_desc(ehi, "ATAPI check failed (ireason=0x%x bytes=%u)",
+			  ireason, bytes);
+ err_out:
@@ -5344 +5392 @@
-		if (is_atapi_taskfile(&qc->tf) &&
+		if (ata_is_atapi(qc->tf.protocol) &&
@@ -5509 +5557 @@
-		if (qc->tf.protocol == ATA_PROT_ATAPI) {
+		if (qc->tf.protocol == ATAPI_PROT_PIO) {
@@ -5667 +5715 @@
-			ata_port_queue_task(ap, ata_pio_task, qc, ATA_SHORT_PAUSE);
+			ata_pio_queue_task(ap, qc, ATA_SHORT_PAUSE);
@@ -5807,0 +5856,16 @@
+static void ata_verify_xfer(struct ata_queued_cmd *qc)
+{
+	struct ata_device *dev = qc->dev;
+
+	if (ata_tag_internal(qc->tag))
+		return;
+
+	if (ata_is_nodata(qc->tf.protocol))
+		return;
+
+	if ((dev->mwdma_mask || dev->udma_mask) && ata_is_pio(qc->tf.protocol))
+		return;
+
+	dev->flags &= ~ATA_DFLAG_DUBIOUS_XFER;
+}
+
@@ -5878,0 +5943,3 @@
+		if (unlikely(dev->flags & ATA_DFLAG_DUBIOUS_XFER))
+			ata_verify_xfer(qc);
+
@@ -5941,24 +6007,0 @@
-static inline int ata_should_dma_map(struct ata_queued_cmd *qc)
-{
-	struct ata_port *ap = qc->ap;
-
-	switch (qc->tf.protocol) {
-	case ATA_PROT_NCQ:
-	case ATA_PROT_DMA:
-	case ATA_PROT_ATAPI_DMA:
-		return 1;
-
-	case ATA_PROT_ATAPI:
-	case ATA_PROT_PIO:
-		if (ap->flags & ATA_FLAG_PIO_DMA)
-			return 1;
-
-		/* fall through */
-
-	default:
-		return 0;
-	}
-
-	/* never reached */
-}
-
@@ -5980,0 +6024 @@
+	u8 prot = qc->tf.protocol;
@@ -5988 +6032 @@
-	if (qc->tf.protocol == ATA_PROT_NCQ) {
+	if (ata_is_ncq(prot)) {
@@ -6004,11 +6048,9 @@
-	if (ata_should_dma_map(qc)) {
-		if (qc->flags & ATA_QCFLAG_SG) {
-			if (ata_sg_setup(qc))
-				goto sg_err;
-		} else if (qc->flags & ATA_QCFLAG_SINGLE) {
-			if (ata_sg_setup_one(qc))
-				goto sg_err;
-		}
-	} else {
-		qc->flags &= ~ATA_QCFLAG_DMAMAP;
-	}
+	/* We guarantee to LLDs that they will have at least one
+	 * non-zero sg if the command is a data command.
+	 */
+	BUG_ON(ata_is_data(prot) && (!qc->sg || !qc->n_elem || !qc->nbytes));
+
+	if (ata_is_dma(prot) || (ata_is_pio(prot) &&
+				 (ap->flags & ATA_FLAG_PIO_DMA)))
+		if (ata_sg_setup(qc))
+			goto sg_err;
@@ -6032 +6073,0 @@
-	qc->flags &= ~ATA_QCFLAG_DMAMAP;
@@ -6067,2 +6108,2 @@
-		case ATA_PROT_ATAPI:
-		case ATA_PROT_ATAPI_NODATA:
+		case ATAPI_PROT_PIO:
+		case ATAPI_PROT_NODATA:
@@ -6071 +6112 @@
-		case ATA_PROT_ATAPI_DMA:
+		case ATAPI_PROT_DMA:
@@ -6094 +6135 @@
-			ata_port_queue_task(ap, ata_pio_task, qc, 0);
+			ata_pio_queue_task(ap, qc, 0);
@@ -6116 +6157 @@
-			ata_port_queue_task(ap, ata_pio_task, qc, 0);
+			ata_pio_queue_task(ap, qc, 0);
@@ -6126 +6167 @@
-				ata_port_queue_task(ap, ata_pio_task, qc, 0);
+				ata_pio_queue_task(ap, qc, 0);
@@ -6135,2 +6176,2 @@
-	case ATA_PROT_ATAPI:
-	case ATA_PROT_ATAPI_NODATA:
+	case ATAPI_PROT_PIO:
+	case ATAPI_PROT_NODATA:
@@ -6147 +6188 @@
-			ata_port_queue_task(ap, ata_pio_task, qc, 0);
+			ata_pio_queue_task(ap, qc, 0);
@@ -6150 +6191 @@
-	case ATA_PROT_ATAPI_DMA:
+	case ATAPI_PROT_DMA:
@@ -6159 +6200 @@
-			ata_port_queue_task(ap, ata_pio_task, qc, 0);
+			ata_pio_queue_task(ap, qc, 0);
@@ -6203,2 +6244,2 @@
-		 * The flag was turned on only for atapi devices.
-		 * No need to check is_atapi_taskfile(&qc->tf) again.
+		 * The flag was turned on only for atapi devices.  No
+		 * need to check ata_is_atapi(qc->tf.protocol) again.
@@ -6211 +6252 @@
-		    qc->tf.protocol == ATA_PROT_ATAPI_DMA) {
+		    qc->tf.protocol == ATAPI_PROT_DMA) {
@@ -6253 +6294 @@
-				       qc->tf.protocol == ATA_PROT_ATAPI_DMA))
+				       qc->tf.protocol == ATAPI_PROT_DMA))
@@ -6620 +6660,0 @@
-	int rc;
@@ -6627,6 +6666,0 @@
-	rc = ata_pad_alloc(ap, dev);
-	if (rc)
-		return rc;
-
-	DPRINTK("prd alloc, virt %p, dma %llx\n", ap->prd,
-		(unsigned long long)ap->prd_dma);
@@ -6719 +6753,2 @@
-	u32 scontrol, spd;
+	u32 scontrol;
+	u8 spd;
@@ -6729,0 +6765,2 @@
+	ata_force_spd_limit(link);
+
@@ -6775 +6812 @@
-	INIT_DELAYED_WORK(&ap->port_task, NULL);
+	INIT_DELAYED_WORK(&ap->port_task, ata_pio_task);
@@ -7124 +7160,0 @@
-		int rc;
@@ -7391 +7427 @@
-	if (mesg.event == PM_EVENT_SUSPEND)
+	if (mesg.event & PM_EVENT_SLEEP)
@@ -7440,0 +7477,174 @@
+static int __init ata_parse_force_one(char **cur,
+				      struct ata_force_ent *force_ent,
+				      const char **reason)
+{
+	/* FIXME: Currently, there's no way to tag init const data and
+	 * using __initdata causes build failure on some versions of
+	 * gcc.  Once __initdataconst is implemented, add const to the
+	 * following structure.
+	 */
+	static struct ata_force_param force_tbl[] __initdata = {
+		{ "40c",	.cbl		= ATA_CBL_PATA40 },
+		{ "80c",	.cbl		= ATA_CBL_PATA80 },
+		{ "short40c",	.cbl		= ATA_CBL_PATA40_SHORT },
+		{ "unk",	.cbl		= ATA_CBL_PATA_UNK },
+		{ "ign",	.cbl		= ATA_CBL_PATA_IGN },
+		{ "sata",	.cbl		= ATA_CBL_SATA },
+		{ "1.5Gbps",	.spd_limit	= 1 },
+		{ "3.0Gbps",	.spd_limit	= 2 },
+		{ "noncq",	.horkage_on	= ATA_HORKAGE_NONCQ },
+		{ "ncq",	.horkage_off	= ATA_HORKAGE_NONCQ },
+		{ "pio0",	.xfer_mask	= 1 << (ATA_SHIFT_PIO + 0) },
+		{ "pio1",	.xfer_mask	= 1 << (ATA_SHIFT_PIO + 1) },
+		{ "pio2",	.xfer_mask	= 1 << (ATA_SHIFT_PIO + 2) },
+		{ "pio3",	.xfer_mask	= 1 << (ATA_SHIFT_PIO + 3) },
+		{ "pio4",	.xfer_mask	= 1 << (ATA_SHIFT_PIO + 4) },
+		{ "pio5",	.xfer_mask	= 1 << (ATA_SHIFT_PIO + 5) },
+		{ "pio6",	.xfer_mask	= 1 << (ATA_SHIFT_PIO + 6) },
+		{ "mwdma0",	.xfer_mask	= 1 << (ATA_SHIFT_MWDMA + 0) },
+		{ "mwdma1",	.xfer_mask	= 1 << (ATA_SHIFT_MWDMA + 1) },
+		{ "mwdma2",	.xfer_mask	= 1 << (ATA_SHIFT_MWDMA + 2) },
+		{ "mwdma3",	.xfer_mask	= 1 << (ATA_SHIFT_MWDMA + 3) },
+		{ "mwdma4",	.xfer_mask	= 1 << (ATA_SHIFT_MWDMA + 4) },
+		{ "udma0",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 0) },
+		{ "udma16",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 0) },
+		{ "udma/16",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 0) },
+		{ "udma1",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 1) },
+		{ "udma25",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 1) },
+		{ "udma/25",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 1) },
+		{ "udma2",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 2) },
+		{ "udma33",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 2) },
+		{ "udma/33",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 2) },
+		{ "udma3",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 3) },
+		{ "udma44",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 3) },
+		{ "udma/44",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 3) },
+		{ "udma4",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 4) },
+		{ "udma66",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 4) },
+		{ "udma/66",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 4) },
+		{ "udma5",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 5) },
+		{ "udma100",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 5) },
+		{ "udma/100",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 5) },
+		{ "udma6",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 6) },
+		{ "udma133",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 6) },
+		{ "udma/133",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 6) },
+		{ "udma7",	.xfer_mask	= 1 << (ATA_SHIFT_UDMA + 7) },
+	};
+	char *start = *cur, *p = *cur;
+	char *id, *val, *endp;
+	const struct ata_force_param *match_fp = NULL;
+	int nr_matches = 0, i;
+
+	/* find where this param ends and update *cur */
+	while (*p != '\0' && *p != ',')
+		p++;
+
+	if (*p == '\0')
+		*cur = p;
+	else
+		*cur = p + 1;
+
+	*p = '\0';
+
+	/* parse */
+	p = strchr(start, ':');
+	if (!p) {
+		val = strstrip(start);
+		goto parse_val;
+	}
+	*p = '\0';
+
+	id = strstrip(start);
+	val = strstrip(p + 1);
+
+	/* parse id */
+	p = strchr(id, '.');
+	if (p) {
+		*p++ = '\0';
+		force_ent->device = simple_strtoul(p, &endp, 10);
+		if (p == endp || *endp != '\0') {
+			*reason = "invalid device";
+			return -EINVAL;
+		}
+	}
+
+	force_ent->port = simple_strtoul(id, &endp, 10);
+	if (p == endp || *endp != '\0') {
+		*reason = "invalid port/link";
+		return -EINVAL;
+	}
+
+ parse_val:
+	/* parse val, allow shortcuts so that both 1.5 and 1.5Gbps work */
+	for (i = 0; i < ARRAY_SIZE(force_tbl); i++) {
+		const struct ata_force_param *fp = &force_tbl[i];
+
+		if (strncasecmp(val, fp->name, strlen(val)))
+			continue;
+
+		nr_matches++;
+		match_fp = fp;
+
+		if (strcasecmp(val, fp->name) == 0) {
+			nr_matches = 1;
+			break;
+		}
+	}
+
+	if (!nr_matches) {
+		*reason = "unknown value";
+		return -EINVAL;
+	}
+	if (nr_matches > 1) {
+		*reason = "ambigious value";
+		return -EINVAL;
+	}
+
+	force_ent->param = *match_fp;
+
+	return 0;
+}
+
+static void __init ata_parse_force_param(void)
+{
+	int idx = 0, size = 1;
+	int last_port = -1, last_device = -1;
+	char *p, *cur, *next;
+
+	/* calculate maximum number of params and allocate force_tbl */
+	for (p = ata_force_param_buf; *p; p++)
+		if (*p == ',')
+			size++;
+
+	ata_force_tbl = kzalloc(sizeof(ata_force_tbl[0]) * size, GFP_KERNEL);
+	if (!ata_force_tbl) {
+		printk(KERN_WARNING "ata: failed to extend force table, "
+		       "libata.force ignored\n");
+		return;
+	}
+
+	/* parse and populate the table */
+	for (cur = ata_force_param_buf; *cur != '\0'; cur = next) {
+		const char *reason = "";
+		struct ata_force_ent te = { .port = -1, .device = -1 };
+
+		next = cur;
+		if (ata_parse_force_one(&next, &te, &reason)) {
+			printk(KERN_WARNING "ata: failed to parse force "
+			       "parameter \"%s\" (%s)\n",
+			       cur, reason);
+			continue;
+		}
+
+		if (te.port == -1) {
+			te.port = last_port;
+			te.device = last_device;
+		}
+
+		ata_force_tbl[idx++] = te;
+
+		last_port = te.port;
+		last_device = te.device;
+	}
+
+	ata_force_tbl_size = idx;
+}
@@ -7444,0 +7655,3 @@
+
+	ata_parse_force_param();
+
@@ -7460,0 +7674 @@
+	kfree(ata_force_tbl);
@@ -7592 +7805,0 @@
-EXPORT_SYMBOL_GPL(ata_sg_init_one);
@@ -7601,0 +7815 @@
+EXPORT_SYMBOL_GPL(atapi_cmd_type);
@@ -7603,0 +7818,7 @@
+EXPORT_SYMBOL_GPL(ata_pack_xfermask);
+EXPORT_SYMBOL_GPL(ata_unpack_xfermask);
+EXPORT_SYMBOL_GPL(ata_xfer_mask2mode);
+EXPORT_SYMBOL_GPL(ata_xfer_mode2mask);
+EXPORT_SYMBOL_GPL(ata_xfer_mode2shift);
+EXPORT_SYMBOL_GPL(ata_mode_string);
+EXPORT_SYMBOL_GPL(ata_id_xfermask);
@@ -7646 +7866,0 @@
-EXPORT_SYMBOL_GPL(ata_port_queue_task);
@@ -7665 +7884,0 @@
-EXPORT_SYMBOL_GPL(ata_id_to_dma_mode);
@@ -7668,0 +7888 @@
+EXPORT_SYMBOL_GPL(ata_timing_find_mode);
@@ -7670,0 +7891 @@
+EXPORT_SYMBOL_GPL(ata_timing_cycle2mode);
@@ -7676,0 +7898 @@
+EXPORT_SYMBOL_GPL(ata_pci_activate_sff_host);
@@ -7717,0 +7940 @@
+EXPORT_SYMBOL_GPL(ata_cable_ignore);
--- ./projects/linux/linux-2.6.25/drivers/ata/libata-core.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/ata/libata-core.c	2008-07-13 23:51:29.000000000 +0200
@@ -49 +48,0 @@
-#include <linux/highmem.h>
@@ -65 +63,0 @@
-#include <asm/semaphore.h>
@@ -76,0 +75,13 @@
+const struct ata_port_operations ata_base_port_ops = {
+	.prereset		= ata_std_prereset,
+	.postreset		= ata_std_postreset,
+	.error_handler		= ata_std_error_handler,
+};
+
+const struct ata_port_operations sata_port_ops = {
+	.inherits		= &ata_base_port_ops,
+
+	.qc_defer		= ata_std_qc_defer,
+	.hardreset		= sata_std_hardreset,
+};
+
@@ -1046,44 +1056,0 @@
-
-/**
- *	ata_devchk - PATA device presence detection
- *	@ap: ATA channel to examine
- *	@device: Device to examine (starting at zero)
- *
- *	This technique was originally described in
- *	Hale Landis's ATADRVR (www.ata-atapi.com), and
- *	later found its way into the ATA/ATAPI spec.
- *
- *	Write a pattern to the ATA shadow registers,
- *	and if a device is present, it will respond by
- *	correctly storing and echoing back the
- *	ATA shadow register contents.
- *
- *	LOCKING:
- *	caller.
- */
-
-static unsigned int ata_devchk(struct ata_port *ap, unsigned int device)
-{
-	struct ata_ioports *ioaddr = &ap->ioaddr;
-	u8 nsect, lbal;
-
-	ap->ops->dev_select(ap, device);
-
-	iowrite8(0x55, ioaddr->nsect_addr);
-	iowrite8(0xaa, ioaddr->lbal_addr);
-
-	iowrite8(0xaa, ioaddr->nsect_addr);
-	iowrite8(0x55, ioaddr->lbal_addr);
-
-	iowrite8(0x55, ioaddr->nsect_addr);
-	iowrite8(0xaa, ioaddr->lbal_addr);
-
-	nsect = ioread8(ioaddr->nsect_addr);
-	lbal = ioread8(ioaddr->lbal_addr);
-
-	if ((nsect == 0x55) && (lbal == 0xaa))
-		return 1;	/* we found a device */
-
-	return 0;		/* nothing found */
-}
-
@@ -1150,69 +1116,0 @@
- *	ata_dev_try_classify - Parse returned ATA device signature
- *	@dev: ATA device to classify (starting at zero)
- *	@present: device seems present
- *	@r_err: Value of error register on completion
- *
- *	After an event -- SRST, E.D.D., or SATA COMRESET -- occurs,
- *	an ATA/ATAPI-defined set of values is placed in the ATA
- *	shadow registers, indicating the results of device detection
- *	and diagnostics.
- *
- *	Select the ATA device, and read the values from the ATA shadow
- *	registers.  Then parse according to the Error register value,
- *	and the spec-defined values examined by ata_dev_classify().
- *
- *	LOCKING:
- *	caller.
- *
- *	RETURNS:
- *	Device type - %ATA_DEV_ATA, %ATA_DEV_ATAPI or %ATA_DEV_NONE.
- */
-unsigned int ata_dev_try_classify(struct ata_device *dev, int present,
-				  u8 *r_err)
-{
-	struct ata_port *ap = dev->link->ap;
-	struct ata_taskfile tf;
-	unsigned int class;
-	u8 err;
-
-	ap->ops->dev_select(ap, dev->devno);
-
-	memset(&tf, 0, sizeof(tf));
-
-	ap->ops->tf_read(ap, &tf);
-	err = tf.feature;
-	if (r_err)
-		*r_err = err;
-
-	/* see if device passed diags: continue and warn later */
-	if (err == 0)
-		/* diagnostic fail : do nothing _YET_ */
-		dev->horkage |= ATA_HORKAGE_DIAGNOSTIC;
-	else if (err == 1)
-		/* do nothing */ ;
-	else if ((dev->devno == 0) && (err == 0x81))
-		/* do nothing */ ;
-	else
-		return ATA_DEV_NONE;
-
-	/* determine if device is ATA or ATAPI */
-	class = ata_dev_classify(&tf);
-
-	if (class == ATA_DEV_UNKNOWN) {
-		/* If the device failed diagnostic, it's likely to
-		 * have reported incorrect device signature too.
-		 * Assume ATA device if the device seems present but
-		 * device signature is invalid with diagnostic
-		 * failure.
-		 */
-		if (present && (dev->horkage & ATA_HORKAGE_DIAGNOSTIC))
-			class = ATA_DEV_ATA;
-		else
-			class = ATA_DEV_NONE;
-	} else if ((class == ATA_DEV_ATA) && (ata_chk_status(ap) == 0))
-		class = ATA_DEV_NONE;
-
-	return class;
-}
-
-/**
@@ -1296 +1194 @@
-static u64 ata_tf_to_lba48(struct ata_taskfile *tf)
+u64 ata_tf_to_lba48(const struct ata_taskfile *tf)
@@ -1307 +1205 @@
-	return ++sectors;
+	return sectors;
@@ -1310 +1208 @@
-static u64 ata_tf_to_lba(struct ata_taskfile *tf)
+u64 ata_tf_to_lba(const struct ata_taskfile *tf)
@@ -1319 +1217 @@
-	return ++sectors;
+	return sectors;
@@ -1364 +1262 @@
-		*max_sectors = ata_tf_to_lba48(&tf);
+		*max_sectors = ata_tf_to_lba48(&tf) + 1;
@@ -1366 +1264 @@
-		*max_sectors = ata_tf_to_lba(&tf);
+		*max_sectors = ata_tf_to_lba(&tf) + 1;
@@ -1526,83 +1423,0 @@
- *	ata_noop_dev_select - Select device 0/1 on ATA bus
- *	@ap: ATA channel to manipulate
- *	@device: ATA device (numbered from zero) to select
- *
- *	This function performs no actual function.
- *
- *	May be used as the dev_select() entry in ata_port_operations.
- *
- *	LOCKING:
- *	caller.
- */
-void ata_noop_dev_select(struct ata_port *ap, unsigned int device)
-{
-}
-
-
-/**
- *	ata_std_dev_select - Select device 0/1 on ATA bus
- *	@ap: ATA channel to manipulate
- *	@device: ATA device (numbered from zero) to select
- *
- *	Use the method defined in the ATA specification to
- *	make either device 0, or device 1, active on the
- *	ATA channel.  Works with both PIO and MMIO.
- *
- *	May be used as the dev_select() entry in ata_port_operations.
- *
- *	LOCKING:
- *	caller.
- */
-
-void ata_std_dev_select(struct ata_port *ap, unsigned int device)
-{
-	u8 tmp;
-
-	if (device == 0)
-		tmp = ATA_DEVICE_OBS;
-	else
-		tmp = ATA_DEVICE_OBS | ATA_DEV1;
-
-	iowrite8(tmp, ap->ioaddr.device_addr);
-	ata_pause(ap);		/* needed; also flushes, for mmio */
-}
-
-/**
- *	ata_dev_select - Select device 0/1 on ATA bus
- *	@ap: ATA channel to manipulate
- *	@device: ATA device (numbered from zero) to select
- *	@wait: non-zero to wait for Status register BSY bit to clear
- *	@can_sleep: non-zero if context allows sleeping
- *
- *	Use the method defined in the ATA specification to
- *	make either device 0, or device 1, active on the
- *	ATA channel.
- *
- *	This is a high-level version of ata_std_dev_select(),
- *	which additionally provides the services of inserting
- *	the proper pauses and status polling, where needed.
- *
- *	LOCKING:
- *	caller.
- */
-
-void ata_dev_select(struct ata_port *ap, unsigned int device,
-			   unsigned int wait, unsigned int can_sleep)
-{
-	if (ata_msg_probe(ap))
-		ata_port_printk(ap, KERN_INFO, "ata_dev_select: ENTER, "
-				"device %u, wait %u\n", device, wait);
-
-	if (wait)
-		ata_wait_idle(ap);
-
-	ap->ops->dev_select(ap, device);
-
-	if (wait) {
-		if (can_sleep && ap->link.device[device].class == ATA_DEV_ATAPI)
-			msleep(150);
-		ata_wait_idle(ap);
-	}
-}
-
-/**
@@ -1735,2 +1550 @@
-static void ata_pio_queue_task(struct ata_port *ap, void *data,
-			       unsigned long delay)
+void ata_pio_queue_task(struct ata_port *ap, void *data, unsigned long delay)
@@ -2100 +1913,0 @@
-	ata_dev_select(ap, dev->devno, 1, 1); /* select device 0/1 */
@@ -2315,0 +2129,7 @@
+	if (dev->horkage & ATA_HORKAGE_DISABLE) {
+		ata_dev_printk(dev, KERN_INFO,
+			       "unsupported device, disabling\n");
+		ata_dev_disable(dev);
+		return 0;
+	}
+
@@ -2467 +2287 @@
-		    (!ap->nr_pmp_links ||
+		    (!sata_pmp_attached(ap) ||
@@ -2561,3 +2380,0 @@
-	if (ata_msg_probe(ap))
-		ata_dev_printk(dev, KERN_DEBUG, "%s: EXIT, drv_stat = 0x%x\n",
-			__func__, ata_chk_status(ap));
@@ -2809 +2626 @@
-void sata_print_link_status(struct ata_link *link)
+static void sata_print_link_status(struct ata_link *link)
@@ -2965 +2782 @@
-int sata_set_spd_needed(struct ata_link *link)
+static int sata_set_spd_needed(struct ata_link *link)
@@ -3324,10 +3141,15 @@
-	/* Old CFA may refuse this command, which is just fine */
-	if (dev->xfer_shift == ATA_SHIFT_PIO && ata_id_is_cfa(dev->id))
-		ign_dev_err = 1;
-
-	/* Some very old devices and some bad newer ones fail any kind of
-	   SET_XFERMODE request but support PIO0-2 timings and no IORDY */
-	if (dev->xfer_shift == ATA_SHIFT_PIO && !ata_id_has_iordy(dev->id) &&
-			dev->pio_mode <= XFER_PIO_2)
-		ign_dev_err = 1;
-
+	if (dev->xfer_shift == ATA_SHIFT_PIO) {
+		/* Old CFA may refuse this command, which is just fine */
+		if (ata_id_is_cfa(dev->id))
+			ign_dev_err = 1;
+		/* Catch several broken garbage emulations plus some pre
+		   ATA devices */
+		if (ata_id_major_version(dev->id) == 0 &&
+					dev->pio_mode <= XFER_PIO_2)
+			ign_dev_err = 1;
+		/* Some very old devices and some bad newer ones fail
+		   any kind of SET_XFERMODE request but support PIO0-2
+		   timings and no IORDY */
+		if (!ata_id_has_iordy(dev->id) && dev->pio_mode <= XFER_PIO_2)
+			ign_dev_err = 1;
+	}
@@ -3477,77 +3299,2 @@
- *	ata_tf_to_host - issue ATA taskfile to host controller
- *	@ap: port to which command is being issued
- *	@tf: ATA taskfile register set
- *
- *	Issues ATA taskfile register set to ATA host controller,
- *	with proper synchronization with interrupt handler and
- *	other threads.
- *
- *	LOCKING:
- *	spin_lock_irqsave(host lock)
- */
-
-static inline void ata_tf_to_host(struct ata_port *ap,
-				  const struct ata_taskfile *tf)
-{
-	ap->ops->tf_load(ap, tf);
-	ap->ops->exec_command(ap, tf);
-}
-
-/**
- *	ata_busy_sleep - sleep until BSY clears, or timeout
- *	@ap: port containing status register to be polled
- *	@tmout_pat: impatience timeout
- *	@tmout: overall timeout
- *
- *	Sleep until ATA Status register bit BSY clears,
- *	or a timeout occurs.
- *
- *	LOCKING:
- *	Kernel thread context (may sleep).
- *
- *	RETURNS:
- *	0 on success, -errno otherwise.
- */
-int ata_busy_sleep(struct ata_port *ap,
-		   unsigned long tmout_pat, unsigned long tmout)
-{
-	unsigned long timer_start, timeout;
-	u8 status;
-
-	status = ata_busy_wait(ap, ATA_BUSY, 300);
-	timer_start = jiffies;
-	timeout = timer_start + tmout_pat;
-	while (status != 0xff && (status & ATA_BUSY) &&
-	       time_before(jiffies, timeout)) {
-		msleep(50);
-		status = ata_busy_wait(ap, ATA_BUSY, 3);
-	}
-
-	if (status != 0xff && (status & ATA_BUSY))
-		ata_port_printk(ap, KERN_WARNING,
-				"port is slow to respond, please be patient "
-				"(Status 0x%x)\n", status);
-
-	timeout = timer_start + tmout;
-	while (status != 0xff && (status & ATA_BUSY) &&
-	       time_before(jiffies, timeout)) {
-		msleep(50);
-		status = ata_chk_status(ap);
-	}
-
-	if (status == 0xff)
-		return -ENODEV;
-
-	if (status & ATA_BUSY) {
-		ata_port_printk(ap, KERN_ERR, "port failed to respond "
-				"(%lu secs, Status 0x%x)\n",
-				tmout / HZ, status);
-		return -EBUSY;
-	}
-
-	return 0;
-}
-
-/**
- *	ata_wait_after_reset - wait before checking status after reset
- *	@ap: port containing status register to be polled
+ *	ata_wait_ready - wait for link to become ready
+ *	@link: link to be waited on
@@ -3554,0 +3302 @@
+ *	@check_ready: callback to check link readiness
@@ -3556,54 +3304,4 @@
- *	After reset, we need to pause a while before reading status.
- *	Also, certain combination of controller and device report 0xff
- *	for some duration (e.g. until SATA PHY is up and running)
- *	which is interpreted as empty port in ATA world.  This
- *	function also waits for such devices to get out of 0xff
- *	status.
- *
- *	LOCKING:
- *	Kernel thread context (may sleep).
- */
-void ata_wait_after_reset(struct ata_port *ap, unsigned long deadline)
-{
-	unsigned long until = jiffies + ATA_TMOUT_FF_WAIT;
-
-	if (time_before(until, deadline))
-		deadline = until;
-
-	/* Spec mandates ">= 2ms" before checking status.  We wait
-	 * 150ms, because that was the magic delay used for ATAPI
-	 * devices in Hale Landis's ATADRVR, for the period of time
-	 * between when the ATA command register is written, and then
-	 * status is checked.  Because waiting for "a while" before
-	 * checking status is fine, post SRST, we perform this magic
-	 * delay here as well.
-	 *
-	 * Old drivers/ide uses the 2mS rule and then waits for ready.
-	 */
-	msleep(150);
-
-	/* Wait for 0xff to clear.  Some SATA devices take a long time
-	 * to clear 0xff after reset.  For example, HHD424020F7SV00
-	 * iVDR needs >= 800ms while.  Quantum GoVault needs even more
-	 * than that.
-	 *
-	 * Note that some PATA controllers (pata_ali) explode if
-	 * status register is read more than once when there's no
-	 * device attached.
-	 */
-	if (ap->flags & ATA_FLAG_SATA) {
-		while (1) {
-			u8 status = ata_chk_status(ap);
-
-			if (status != 0xff || time_after(jiffies, deadline))
-				return;
-
-			msleep(50);
-		}
-	}
-}
-
-/**
- *	ata_wait_ready - sleep until BSY clears, or timeout
- *	@ap: port containing status register to be polled
- *	@deadline: deadline jiffies for the operation
+ *	Wait for @link to become ready.  @check_ready should return
+ *	positive number if @link is ready, 0 if it isn't, -ENODEV if
+ *	link doesn't seem to be occupied, other errno for other error
+ *	conditions.
@@ -3611,2 +3309,2 @@
- *	Sleep until ATA Status register bit BSY clears, or timeout
- *	occurs.
+ *	Transient -ENODEV conditions are allowed for
+ *	ATA_TMOUT_FF_WAIT.
@@ -3615 +3313 @@
- *	Kernel thread context (may sleep).
+ *	EH context.
@@ -3618 +3316 @@
- *	0 on success, -errno otherwise.
+ *	0 if @linke is ready before @deadline; otherwise, -errno.
@@ -3620 +3318,2 @@
-int ata_wait_ready(struct ata_port *ap, unsigned long deadline)
+int ata_wait_ready(struct ata_link *link, unsigned long deadline,
+		   int (*check_ready)(struct ata_link *link))
@@ -3622,0 +3322 @@
+	unsigned long nodev_deadline = start + ATA_TMOUT_FF_WAIT;
@@ -3624,0 +3325,3 @@
+	if (time_after(nodev_deadline, deadline))
+		nodev_deadline = deadline;
+
@@ -3626 +3328,0 @@
-		u8 status = ata_chk_status(ap);
@@ -3627,0 +3330 @@
+		int ready, tmp;
@@ -3629 +3332,2 @@
-		if (!(status & ATA_BUSY))
+		ready = tmp = check_ready(link);
+		if (ready > 0)
@@ -3631,2 +3335,23 @@
-		if (!ata_link_online(&ap->link) && status == 0xff)
-			return -ENODEV;
+
+		/* -ENODEV could be transient.  Ignore -ENODEV if link
+		 * is online.  Also, some SATA devices take a long
+		 * time to clear 0xff after reset.  For example,
+		 * HHD424020F7SV00 iVDR needs >= 800ms while Quantum
+		 * GoVault needs even more than that.  Wait for
+		 * ATA_TMOUT_FF_WAIT on -ENODEV if link isn't offline.
+		 *
+		 * Note that some PATA controllers (pata_ali) explode
+		 * if status register is read more than once when
+		 * there's no device attached.
+		 */
+		if (ready == -ENODEV) {
+			if (ata_link_online(link))
+				ready = 0;
+			else if ((link->ap->flags & ATA_FLAG_SATA) &&
+				 !ata_link_offline(link) &&
+				 time_before(now, nodev_deadline))
+				ready = 0;
+		}
+
+		if (ready)
+			return ready;
@@ -3638,3 +3363,3 @@
-			ata_port_printk(ap, KERN_WARNING,
-				"port is slow to respond, please be patient "
-				"(Status 0x%x)\n", status);
+			ata_link_printk(link, KERN_WARNING,
+				"link is slow to respond, please be patient "
+				"(ready=%d)\n", tmp);
@@ -3648,87 +3372,0 @@
-static int ata_bus_post_reset(struct ata_port *ap, unsigned int devmask,
-			      unsigned long deadline)
-{
-	struct ata_ioports *ioaddr = &ap->ioaddr;
-	unsigned int dev0 = devmask & (1 << 0);
-	unsigned int dev1 = devmask & (1 << 1);
-	int rc, ret = 0;
-
-	/* if device 0 was found in ata_devchk, wait for its
-	 * BSY bit to clear
-	 */
-	if (dev0) {
-		rc = ata_wait_ready(ap, deadline);
-		if (rc) {
-			if (rc != -ENODEV)
-				return rc;
-			ret = rc;
-		}
-	}
-
-	/* if device 1 was found in ata_devchk, wait for register
-	 * access briefly, then wait for BSY to clear.
-	 */
-	if (dev1) {
-		int i;
-
-		ap->ops->dev_select(ap, 1);
-
-		/* Wait for register access.  Some ATAPI devices fail
-		 * to set nsect/lbal after reset, so don't waste too
-		 * much time on it.  We're gonna wait for !BSY anyway.
-		 */
-		for (i = 0; i < 2; i++) {
-			u8 nsect, lbal;
-
-			nsect = ioread8(ioaddr->nsect_addr);
-			lbal = ioread8(ioaddr->lbal_addr);
-			if ((nsect == 1) && (lbal == 1))
-				break;
-			msleep(50);	/* give drive a breather */
-		}
-
-		rc = ata_wait_ready(ap, deadline);
-		if (rc) {
-			if (rc != -ENODEV)
-				return rc;
-			ret = rc;
-		}
-	}
-
-	/* is all this really necessary? */
-	ap->ops->dev_select(ap, 0);
-	if (dev1)
-		ap->ops->dev_select(ap, 1);
-	if (dev0)
-		ap->ops->dev_select(ap, 0);
-
-	return ret;
-}
-
-static int ata_bus_softreset(struct ata_port *ap, unsigned int devmask,
-			     unsigned long deadline)
-{
-	struct ata_ioports *ioaddr = &ap->ioaddr;
-
-	DPRINTK("ata%u: bus reset via SRST\n", ap->print_id);
-
-	/* software reset.  causes dev0 to be selected */
-	iowrite8(ap->ctl, ioaddr->ctl_addr);
-	udelay(20);	/* FIXME: flush */
-	iowrite8(ap->ctl | ATA_SRST, ioaddr->ctl_addr);
-	udelay(20);	/* FIXME: flush */
-	iowrite8(ap->ctl, ioaddr->ctl_addr);
-
-	/* wait a while before checking status */
-	ata_wait_after_reset(ap, deadline);
-
-	/* Before we perform post reset processing we want to see if
-	 * the bus shows 0xFF because the odd clown forgets the D7
-	 * pulldown resistor.
-	 */
-	if (ata_chk_status(ap) == 0xFF)
-		return -ENODEV;
-
-	return ata_bus_post_reset(ap, devmask, deadline);
-}
-
@@ -3736,2 +3374,4 @@
- *	ata_bus_reset - reset host port and associated ATA channel
- *	@ap: port to reset
+ *	ata_wait_after_reset - wait for link to become ready after reset
+ *	@link: link to be waited on
+ *	@deadline: deadline jiffies for the operation
+ *	@check_ready: callback to check link readiness
@@ -3739,7 +3379 @@
- *	This is typically the first time we actually start issuing
- *	commands to the ATA channel.  We wait for BSY to clear, then
- *	issue EXECUTE DEVICE DIAGNOSTIC command, polling for its
- *	result.  Determine what devices, if any, are on the channel
- *	by looking at the device 0/1 error register.  Look at the signature
- *	stored in each device's taskfile registers, to determine if
- *	the device is ATA or ATAPI.
+ *	Wait for @link to become ready after reset.
@@ -3748,2 +3382 @@
- *	PCI/etc. bus probe sem.
- *	Obtains host lock.
+ *	EH context.
@@ -3751,2 +3384,2 @@
- *	SIDE EFFECTS:
- *	Sets ATA_FLAG_DISABLED if bus reset fails.
+ *	RETURNS:
+ *	0 if @linke is ready before @deadline; otherwise, -errno.
@@ -3754,2 +3387,2 @@
-
-void ata_bus_reset(struct ata_port *ap)
+int ata_wait_after_reset(struct ata_link *link, unsigned long deadline,
+				int (*check_ready)(struct ata_link *link))
@@ -3757,58 +3390 @@
-	struct ata_device *device = ap->link.device;
-	struct ata_ioports *ioaddr = &ap->ioaddr;
-	unsigned int slave_possible = ap->flags & ATA_FLAG_SLAVE_POSS;
-	u8 err;
-	unsigned int dev0, dev1 = 0, devmask = 0;
-	int rc;
-
-	DPRINTK("ENTER, host %u, port %u\n", ap->print_id, ap->port_no);
-
-	/* determine if device 0/1 are present */
-	if (ap->flags & ATA_FLAG_SATA_RESET)
-		dev0 = 1;
-	else {
-		dev0 = ata_devchk(ap, 0);
-		if (slave_possible)
-			dev1 = ata_devchk(ap, 1);
-	}
-
-	if (dev0)
-		devmask |= (1 << 0);
-	if (dev1)
-		devmask |= (1 << 1);
-
-	/* select device 0 again */
-	ap->ops->dev_select(ap, 0);
-
-	/* issue bus reset */
-	if (ap->flags & ATA_FLAG_SRST) {
-		rc = ata_bus_softreset(ap, devmask, jiffies + 40 * HZ);
-		if (rc && rc != -ENODEV)
-			goto err_out;
-	}
-
-	/*
-	 * determine by signature whether we have ATA or ATAPI devices
-	 */
-	device[0].class = ata_dev_try_classify(&device[0], dev0, &err);
-	if ((slave_possible) && (err != 0x81))
-		device[1].class = ata_dev_try_classify(&device[1], dev1, &err);
-
-	/* is double-select really necessary? */
-	if (device[1].class != ATA_DEV_NONE)
-		ap->ops->dev_select(ap, 1);
-	if (device[0].class != ATA_DEV_NONE)
-		ap->ops->dev_select(ap, 0);
-
-	/* if no devices were detected, disable this port */
-	if ((device[0].class == ATA_DEV_NONE) &&
-	    (device[1].class == ATA_DEV_NONE))
-		goto err_out;
-
-	if (ap->flags & (ATA_FLAG_SATA_RESET | ATA_FLAG_SRST)) {
-		/* set up device control for ATA_FLAG_SATA_RESET */
-		iowrite8(ap->ctl, ioaddr->ctl_addr);
-	}
-
-	DPRINTK("EXIT\n");
-	return;
+	msleep(ATA_WAIT_AFTER_RESET_MSECS);
@@ -3816,5 +3392 @@
-err_out:
-	ata_port_printk(ap, KERN_ERR, "disabling port\n");
-	ata_port_disable(ap);
-
-	DPRINTK("EXIT\n");
+	return ata_wait_ready(link, deadline, check_ready);
@@ -3909 +3481 @@
-	u32 scontrol;
+	u32 scontrol, serror;
@@ -3925 +3497,8 @@
-	return sata_link_debounce(link, params, deadline);
+	if ((rc = sata_link_debounce(link, params, deadline)))
+		return rc;
+
+	/* clear SError, some PHYs require this even for SRST to work */
+	if (!(rc = sata_scr_read(link, SCR_ERROR, &serror)))
+		rc = sata_scr_write(link, SCR_ERROR, serror);
+
+	return rc != -EINVAL ? rc : 0;
@@ -3952,11 +3530,0 @@
-	/* handle link resume */
-	if ((ehc->i.flags & ATA_EHI_RESUME_LINK) &&
-	    (link->flags & ATA_LFLAG_HRST_TO_RESUME))
-		ehc->i.action |= ATA_EH_HARDRESET;
-
-	/* Some PMPs don't work with only SRST, force hardreset if PMP
-	 * is supported.
-	 */
-	if (ap->flags & ATA_FLAG_PMP)
-		ehc->i.action |= ATA_EH_HARDRESET;
-
@@ -3976,62 +3544,3 @@
-	/* Wait for !BSY if the controller can wait for the first D2H
-	 * Reg FIS and we don't know that no device is attached.
-	 */
-	if (!(link->flags & ATA_LFLAG_SKIP_D2H_BSY) && !ata_link_offline(link)) {
-		rc = ata_wait_ready(ap, deadline);
-		if (rc && rc != -ENODEV) {
-			ata_link_printk(link, KERN_WARNING, "device not ready "
-					"(errno=%d), forcing hardreset\n", rc);
-			ehc->i.action |= ATA_EH_HARDRESET;
-		}
-	}
-
-	return 0;
-}
-
-/**
- *	ata_std_softreset - reset host port via ATA SRST
- *	@link: ATA link to reset
- *	@classes: resulting classes of attached devices
- *	@deadline: deadline jiffies for the operation
- *
- *	Reset host port using ATA SRST.
- *
- *	LOCKING:
- *	Kernel thread context (may sleep)
- *
- *	RETURNS:
- *	0 on success, -errno otherwise.
- */
-int ata_std_softreset(struct ata_link *link, unsigned int *classes,
-		      unsigned long deadline)
-{
-	struct ata_port *ap = link->ap;
-	unsigned int slave_possible = ap->flags & ATA_FLAG_SLAVE_POSS;
-	unsigned int devmask = 0;
-	int rc;
-	u8 err;
-
-	DPRINTK("ENTER\n");
-
-	if (ata_link_offline(link)) {
-		classes[0] = ATA_DEV_NONE;
-		goto out;
-	}
-
-	/* determine if device 0/1 are present */
-	if (ata_devchk(ap, 0))
-		devmask |= (1 << 0);
-	if (slave_possible && ata_devchk(ap, 1))
-		devmask |= (1 << 1);
-
-	/* select device 0 again */
-	ap->ops->dev_select(ap, 0);
-
-	/* issue bus reset */
-	DPRINTK("about to softreset, devmask=%x\n", devmask);
-	rc = ata_bus_softreset(ap, devmask, deadline);
-	/* if link is occupied, -ENODEV too is an error */
-	if (rc && (rc != -ENODEV || sata_scr_valid(link))) {
-		ata_link_printk(link, KERN_ERR, "SRST failed (errno=%d)\n", rc);
-		return rc;
-	}
+	/* no point in trying softreset on offline link */
+	if (ata_link_offline(link))
+		ehc->i.action &= ~ATA_EH_SOFTRESET;
@@ -4039,9 +3547,0 @@
-	/* determine by signature whether we have ATA or ATAPI devices */
-	classes[0] = ata_dev_try_classify(&link->device[0],
-					  devmask & (1 << 0), &err);
-	if (slave_possible && err != 0x81)
-		classes[1] = ata_dev_try_classify(&link->device[1],
-						  devmask & (1 << 1), &err);
-
- out:
-	DPRINTK("EXIT, classes[0]=%u [1]=%u\n", classes[0], classes[1]);
@@ -4055,0 +3556,2 @@
+ *	@online: optional out parameter indicating link onlineness
+ *	@check_ready: optional callback to check link readiness
@@ -4057,0 +3560,8 @@
+ *	After hardreset, link readiness is waited upon using
+ *	ata_wait_ready() if @check_ready is specified.  LLDs are
+ *	allowed to not specify @check_ready and wait itself after this
+ *	function returns.  Device classification is LLD's
+ *	responsibility.
+ *
+ *	*@online is set to one iff reset succeeded and @link is online
+ *	after reset.
@@ -4066 +3576,2 @@
-			unsigned long deadline)
+			unsigned long deadline,
+			bool *online, int (*check_ready)(struct ata_link *))
@@ -4072,0 +3584,3 @@
+	if (online)
+		*online = false;
+
@@ -4106,2 +3620,40 @@
- out:
-	DPRINTK("EXIT, rc=%d\n", rc);
+	if (rc)
+		goto out;
+	/* if link is offline nothing more to do */
+	if (ata_link_offline(link))
+		goto out;
+
+	/* Link is online.  From this point, -ENODEV too is an error. */
+	if (online)
+		*online = true;
+
+	if (sata_pmp_supported(link->ap) && ata_is_host_link(link)) {
+		/* If PMP is supported, we have to do follow-up SRST.
+		 * Some PMPs don't send D2H Reg FIS after hardreset if
+		 * the first port is empty.  Wait only for
+		 * ATA_TMOUT_PMP_SRST_WAIT.
+		 */
+		if (check_ready) {
+			unsigned long pmp_deadline;
+
+			pmp_deadline = jiffies + ATA_TMOUT_PMP_SRST_WAIT;
+			if (time_after(pmp_deadline, deadline))
+				pmp_deadline = deadline;
+			ata_wait_ready(link, pmp_deadline, check_ready);
+		}
+		rc = -EAGAIN;
+		goto out;
+	}
+
+	rc = 0;
+	if (check_ready)
+		rc = ata_wait_ready(link, deadline, check_ready);
+ out:
+	if (rc && rc != -EAGAIN) {
+		/* online is set iff link is online && reset succeeded */
+		if (online)
+			*online = false;
+		ata_link_printk(link, KERN_ERR,
+				"COMRESET failed (errno=%d)\n", rc);
+	}
+	DPRINTK("EXIT, rc=%d\n", rc);
@@ -4112 +3664 @@
- *	sata_std_hardreset - reset host port via SATA phy reset
+ *	sata_std_hardreset - COMRESET w/o waiting or classification
@@ -4117,2 +3669 @@
- *	SATA phy-reset host port using DET bits of SControl register,
- *	wait for !BSY and classify the attached device.
+ *	Standard SATA COMRESET w/o waiting or classification.
@@ -4124 +3675 @@
- *	0 on success, -errno otherwise.
+ *	0 if link offline, -EAGAIN if link online, -errno on errors.
@@ -4129 +3679,0 @@
-	struct ata_port *ap = link->ap;
@@ -4130,0 +3681 @@
+	bool online;
@@ -4133,2 +3683,0 @@
-	DPRINTK("ENTER\n");
-
@@ -4136,41 +3685,2 @@
-	rc = sata_link_hardreset(link, timing, deadline);
-	if (rc) {
-		ata_link_printk(link, KERN_ERR,
-				"COMRESET failed (errno=%d)\n", rc);
-		return rc;
-	}
-
-	/* TODO: phy layer with polling, timeouts, etc. */
-	if (ata_link_offline(link)) {
-		*class = ATA_DEV_NONE;
-		DPRINTK("EXIT, link offline\n");
-		return 0;
-	}
-
-	/* wait a while before checking status */
-	ata_wait_after_reset(ap, deadline);
-
-	/* If PMP is supported, we have to do follow-up SRST.  Note
-	 * that some PMPs don't send D2H Reg FIS after hardreset at
-	 * all if the first port is empty.  Wait for it just for a
-	 * second and request follow-up SRST.
-	 */
-	if (ap->flags & ATA_FLAG_PMP) {
-		ata_wait_ready(ap, jiffies + HZ);
-		return -EAGAIN;
-	}
-
-	rc = ata_wait_ready(ap, deadline);
-	/* link occupied, -ENODEV too is an error */
-	if (rc) {
-		ata_link_printk(link, KERN_ERR,
-				"COMRESET failed (errno=%d)\n", rc);
-		return rc;
-	}
-
-	ap->ops->dev_select(ap, 0);	/* probably unnecessary */
-
-	*class = ata_dev_try_classify(link->device, 1, NULL);
-
-	DPRINTK("EXIT, class=%u\n", *class);
-	return 0;
+	rc = sata_link_hardreset(link, timing, deadline, &online, NULL);
+	return online ? -EAGAIN : rc;
@@ -4193 +3702,0 @@
-	struct ata_port *ap = link->ap;
@@ -4198,5 +3707,2 @@
-	/* print link status */
-	sata_print_link_status(link);
-
-	/* clear SError */
-	if (sata_scr_read(link, SCR_ERROR, &serror) == 0)
+	/* reset complete, clear SError */
+	if (!sata_scr_read(link, SCR_ERROR, &serror))
@@ -4204,13 +3709,0 @@
-	link->eh_info.serror = 0;
-
-	/* is double-select really necessary? */
-	if (classes[0] != ATA_DEV_NONE)
-		ap->ops->dev_select(ap, 1);
-	if (classes[1] != ATA_DEV_NONE)
-		ap->ops->dev_select(ap, 0);
-
-	/* bail out if no device is present */
-	if (classes[0] == ATA_DEV_NONE && classes[1] == ATA_DEV_NONE) {
-		DPRINTK("EXIT, no device\n");
-		return;
-	}
@@ -4218,3 +3711,2 @@
-	/* set up device control */
-	if (ap->ioaddr.ctl_addr)
-		iowrite8(ap->ctl, ap->ioaddr.ctl_addr);
+	/* print link status */
+	sata_print_link_status(link);
@@ -4411,2 +3903 @@
-	{ "Config  Disk",	NULL,		ATA_HORKAGE_NODMA |
-						ATA_HORKAGE_SKIP_PM },
+	{ "Config  Disk",	NULL,		ATA_HORKAGE_DISABLE },
@@ -4449,0 +3941,3 @@
+	/* Maybe we should just blacklist TSSTcorp... */
+	{ "TSSTcorp CDDVDW SH-S202H", "SB00",	  ATA_HORKAGE_IVB, },
+	{ "TSSTcorp CDDVDW SH-S202H", "SB01",	  ATA_HORKAGE_IVB, },
@@ -4530,0 +4025,47 @@
+ *	cable_is_40wire		-	40/80/SATA decider
+ *	@ap: port to consider
+ *
+ *	This function encapsulates the policy for speed management
+ *	in one place. At the moment we don't cache the result but
+ *	there is a good case for setting ap->cbl to the result when
+ *	we are called with unknown cables (and figuring out if it
+ *	impacts hotplug at all).
+ *
+ *	Return 1 if the cable appears to be 40 wire.
+ */
+
+static int cable_is_40wire(struct ata_port *ap)
+{
+	struct ata_link *link;
+	struct ata_device *dev;
+
+	/* If the controller thinks we are 40 wire, we are */
+	if (ap->cbl == ATA_CBL_PATA40)
+		return 1;
+	/* If the controller thinks we are 80 wire, we are */
+	if (ap->cbl == ATA_CBL_PATA80 || ap->cbl == ATA_CBL_SATA)
+		return 0;
+	/* If the system is known to be 40 wire short cable (eg laptop),
+	   then we allow 80 wire modes even if the drive isn't sure */
+	if (ap->cbl == ATA_CBL_PATA40_SHORT)
+		return 0;
+	/* If the controller doesn't know we scan
+
+	   - Note: We look for all 40 wire detects at this point.
+	     Any 80 wire detect is taken to be 80 wire cable
+	     because
+	     - In many setups only the one drive (slave if present)
+               will give a valid detect
+             - If you have a non detect capable drive you don't
+               want it to colour the choice
+        */
+	ata_port_for_each_link(link, ap) {
+		ata_link_for_each_dev(dev, link) {
+			if (!ata_is_40wire(dev))
+				return 0;
+		}
+	}
+	return 1;
+}
+
+/**
@@ -4598,4 +4139 @@
-		if ((ap->cbl == ATA_CBL_PATA40) ||
-		    (ata_is_40wire(dev) &&
-		    (ap->cbl == ATA_CBL_PATA_UNK ||
-		     ap->cbl == ATA_CBL_PATA80))) {
+		if (cable_is_40wire(ap)) {
@@ -4762,107 +4300 @@
- *	ata_fill_sg - Fill PCI IDE PRD table
- *	@qc: Metadata associated with taskfile to be transferred
- *
- *	Fill PCI IDE PRD (scatter-gather) table with segments
- *	associated with the current disk command.
- *
- *	LOCKING:
- *	spin_lock_irqsave(host lock)
- *
- */
-static void ata_fill_sg(struct ata_queued_cmd *qc)
-{
-	struct ata_port *ap = qc->ap;
-	struct scatterlist *sg;
-	unsigned int si, pi;
-
-	pi = 0;
-	for_each_sg(qc->sg, sg, qc->n_elem, si) {
-		u32 addr, offset;
-		u32 sg_len, len;
-
-		/* determine if physical DMA addr spans 64K boundary.
-		 * Note h/w doesn't support 64-bit, so we unconditionally
-		 * truncate dma_addr_t to u32.
-		 */
-		addr = (u32) sg_dma_address(sg);
-		sg_len = sg_dma_len(sg);
-
-		while (sg_len) {
-			offset = addr & 0xffff;
-			len = sg_len;
-			if ((offset + sg_len) > 0x10000)
-				len = 0x10000 - offset;
-
-			ap->prd[pi].addr = cpu_to_le32(addr);
-			ap->prd[pi].flags_len = cpu_to_le32(len & 0xffff);
-			VPRINTK("PRD[%u] = (0x%X, 0x%X)\n", pi, addr, len);
-
-			pi++;
-			sg_len -= len;
-			addr += len;
-		}
-	}
-
-	ap->prd[pi - 1].flags_len |= cpu_to_le32(ATA_PRD_EOT);
-}
-
-/**
- *	ata_fill_sg_dumb - Fill PCI IDE PRD table
- *	@qc: Metadata associated with taskfile to be transferred
- *
- *	Fill PCI IDE PRD (scatter-gather) table with segments
- *	associated with the current disk command. Perform the fill
- *	so that we avoid writing any length 64K records for
- *	controllers that don't follow the spec.
- *
- *	LOCKING:
- *	spin_lock_irqsave(host lock)
- *
- */
-static void ata_fill_sg_dumb(struct ata_queued_cmd *qc)
-{
-	struct ata_port *ap = qc->ap;
-	struct scatterlist *sg;
-	unsigned int si, pi;
-
-	pi = 0;
-	for_each_sg(qc->sg, sg, qc->n_elem, si) {
-		u32 addr, offset;
-		u32 sg_len, len, blen;
-
-		/* determine if physical DMA addr spans 64K boundary.
-		 * Note h/w doesn't support 64-bit, so we unconditionally
-		 * truncate dma_addr_t to u32.
-		 */
-		addr = (u32) sg_dma_address(sg);
-		sg_len = sg_dma_len(sg);
-
-		while (sg_len) {
-			offset = addr & 0xffff;
-			len = sg_len;
-			if ((offset + sg_len) > 0x10000)
-				len = 0x10000 - offset;
-
-			blen = len & 0xffff;
-			ap->prd[pi].addr = cpu_to_le32(addr);
-			if (blen == 0) {
-			   /* Some PATA chipsets like the CS5530 can't
-			      cope with 0x0000 meaning 64K as the spec says */
-				ap->prd[pi].flags_len = cpu_to_le32(0x8000);
-				blen = 0x8000;
-				ap->prd[++pi].addr = cpu_to_le32(addr + 0x8000);
-			}
-			ap->prd[pi].flags_len = cpu_to_le32(blen);
-			VPRINTK("PRD[%u] = (0x%X, 0x%X)\n", pi, addr, len);
-
-			pi++;
-			sg_len -= len;
-			addr += len;
-		}
-	}
-
-	ap->prd[pi - 1].flags_len |= cpu_to_le32(ATA_PRD_EOT);
-}
-
-/**
- *	ata_check_atapi_dma - Check whether ATAPI DMA can be supported
+ *	atapi_check_dma - Check whether ATAPI DMA can be supported
@@ -4881 +4313 @@
-int ata_check_atapi_dma(struct ata_queued_cmd *qc)
+int atapi_check_dma(struct ata_queued_cmd *qc)
@@ -4912,744 +4344,3 @@
-int ata_std_qc_defer(struct ata_queued_cmd *qc)
-{
-	struct ata_link *link = qc->dev->link;
-
-	if (qc->tf.protocol == ATA_PROT_NCQ) {
-		if (!ata_tag_valid(link->active_tag))
-			return 0;
-	} else {
-		if (!ata_tag_valid(link->active_tag) && !link->sactive)
-			return 0;
-	}
-
-	return ATA_DEFER_LINK;
-}
-
-/**
- *	ata_qc_prep - Prepare taskfile for submission
- *	@qc: Metadata associated with taskfile to be prepared
- *
- *	Prepare ATA taskfile for submission.
- *
- *	LOCKING:
- *	spin_lock_irqsave(host lock)
- */
-void ata_qc_prep(struct ata_queued_cmd *qc)
-{
-	if (!(qc->flags & ATA_QCFLAG_DMAMAP))
-		return;
-
-	ata_fill_sg(qc);
-}
-
-/**
- *	ata_dumb_qc_prep - Prepare taskfile for submission
- *	@qc: Metadata associated with taskfile to be prepared
- *
- *	Prepare ATA taskfile for submission.
- *
- *	LOCKING:
- *	spin_lock_irqsave(host lock)
- */
-void ata_dumb_qc_prep(struct ata_queued_cmd *qc)
-{
-	if (!(qc->flags & ATA_QCFLAG_DMAMAP))
-		return;
-
-	ata_fill_sg_dumb(qc);
-}
-
-void ata_noop_qc_prep(struct ata_queued_cmd *qc) { }
-
-/**
- *	ata_sg_init - Associate command with scatter-gather table.
- *	@qc: Command to be associated
- *	@sg: Scatter-gather table.
- *	@n_elem: Number of elements in s/g table.
- *
- *	Initialize the data-related elements of queued_cmd @qc
- *	to point to a scatter-gather table @sg, containing @n_elem
- *	elements.
- *
- *	LOCKING:
- *	spin_lock_irqsave(host lock)
- */
-void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
-		 unsigned int n_elem)
-{
-	qc->sg = sg;
-	qc->n_elem = n_elem;
-	qc->cursg = qc->sg;
-}
-
-/**
- *	ata_sg_setup - DMA-map the scatter-gather table associated with a command.
- *	@qc: Command with scatter-gather table to be mapped.
- *
- *	DMA-map the scatter-gather table associated with queued_cmd @qc.
- *
- *	LOCKING:
- *	spin_lock_irqsave(host lock)
- *
- *	RETURNS:
- *	Zero on success, negative on error.
- *
- */
-static int ata_sg_setup(struct ata_queued_cmd *qc)
-{
-	struct ata_port *ap = qc->ap;
-	unsigned int n_elem;
-
-	VPRINTK("ENTER, ata%u\n", ap->print_id);
-
-	n_elem = dma_map_sg(ap->dev, qc->sg, qc->n_elem, qc->dma_dir);
-	if (n_elem < 1)
-		return -1;
-
-	DPRINTK("%d sg elements mapped\n", n_elem);
-
-	qc->n_elem = n_elem;
-	qc->flags |= ATA_QCFLAG_DMAMAP;
-
-	return 0;
-}
-
-/**
- *	swap_buf_le16 - swap halves of 16-bit words in place
- *	@buf:  Buffer to swap
- *	@buf_words:  Number of 16-bit words in buffer.
- *
- *	Swap halves of 16-bit words if needed to convert from
- *	little-endian byte order to native cpu byte order, or
- *	vice-versa.
- *
- *	LOCKING:
- *	Inherited from caller.
- */
-void swap_buf_le16(u16 *buf, unsigned int buf_words)
-{
-#ifdef __BIG_ENDIAN
-	unsigned int i;
-
-	for (i = 0; i < buf_words; i++)
-		buf[i] = le16_to_cpu(buf[i]);
-#endif /* __BIG_ENDIAN */
-}
-
-/**
- *	ata_data_xfer - Transfer data by PIO
- *	@dev: device to target
- *	@buf: data buffer
- *	@buflen: buffer length
- *	@rw: read/write
- *
- *	Transfer data from/to the device data register by PIO.
- *
- *	LOCKING:
- *	Inherited from caller.
- *
- *	RETURNS:
- *	Bytes consumed.
- */
-unsigned int ata_data_xfer(struct ata_device *dev, unsigned char *buf,
-			   unsigned int buflen, int rw)
-{
-	struct ata_port *ap = dev->link->ap;
-	void __iomem *data_addr = ap->ioaddr.data_addr;
-	unsigned int words = buflen >> 1;
-
-	/* Transfer multiple of 2 bytes */
-	if (rw == READ)
-		ioread16_rep(data_addr, buf, words);
-	else
-		iowrite16_rep(data_addr, buf, words);
-
-	/* Transfer trailing 1 byte, if any. */
-	if (unlikely(buflen & 0x01)) {
-		__le16 align_buf[1] = { 0 };
-		unsigned char *trailing_buf = buf + buflen - 1;
-
-		if (rw == READ) {
-			align_buf[0] = cpu_to_le16(ioread16(data_addr));
-			memcpy(trailing_buf, align_buf, 1);
-		} else {
-			memcpy(align_buf, trailing_buf, 1);
-			iowrite16(le16_to_cpu(align_buf[0]), data_addr);
-		}
-		words++;
-	}
-
-	return words << 1;
-}
-
-/**
- *	ata_data_xfer_noirq - Transfer data by PIO
- *	@dev: device to target
- *	@buf: data buffer
- *	@buflen: buffer length
- *	@rw: read/write
- *
- *	Transfer data from/to the device data register by PIO. Do the
- *	transfer with interrupts disabled.
- *
- *	LOCKING:
- *	Inherited from caller.
- *
- *	RETURNS:
- *	Bytes consumed.
- */
-unsigned int ata_data_xfer_noirq(struct ata_device *dev, unsigned char *buf,
-				 unsigned int buflen, int rw)
-{
-	unsigned long flags;
-	unsigned int consumed;
-
-	local_irq_save(flags);
-	consumed = ata_data_xfer(dev, buf, buflen, rw);
-	local_irq_restore(flags);
-
-	return consumed;
-}
-
-
-/**
- *	ata_pio_sector - Transfer a sector of data.
- *	@qc: Command on going
- *
- *	Transfer qc->sect_size bytes of data from/to the ATA device.
- *
- *	LOCKING:
- *	Inherited from caller.
- */
-
-static void ata_pio_sector(struct ata_queued_cmd *qc)
-{
-	int do_write = (qc->tf.flags & ATA_TFLAG_WRITE);
-	struct ata_port *ap = qc->ap;
-	struct page *page;
-	unsigned int offset;
-	unsigned char *buf;
-
-	if (qc->curbytes == qc->nbytes - qc->sect_size)
-		ap->hsm_task_state = HSM_ST_LAST;
-
-	page = sg_page(qc->cursg);
-	offset = qc->cursg->offset + qc->cursg_ofs;
-
-	/* get the current page and offset */
-	page = nth_page(page, (offset >> PAGE_SHIFT));
-	offset %= PAGE_SIZE;
-
-	DPRINTK("data %s\n", qc->tf.flags & ATA_TFLAG_WRITE ? "write" : "read");
-
-	if (PageHighMem(page)) {
-		unsigned long flags;
-
-		/* FIXME: use a bounce buffer */
-		local_irq_save(flags);
-		buf = kmap_atomic(page, KM_IRQ0);
-
-		/* do the actual data transfer */
-		ap->ops->data_xfer(qc->dev, buf + offset, qc->sect_size, do_write);
-
-		kunmap_atomic(buf, KM_IRQ0);
-		local_irq_restore(flags);
-	} else {
-		buf = page_address(page);
-		ap->ops->data_xfer(qc->dev, buf + offset, qc->sect_size, do_write);
-	}
-
-	qc->curbytes += qc->sect_size;
-	qc->cursg_ofs += qc->sect_size;
-
-	if (qc->cursg_ofs == qc->cursg->length) {
-		qc->cursg = sg_next(qc->cursg);
-		qc->cursg_ofs = 0;
-	}
-}
-
-/**
- *	ata_pio_sectors - Transfer one or many sectors.
- *	@qc: Command on going
- *
- *	Transfer one or many sectors of data from/to the
- *	ATA device for the DRQ request.
- *
- *	LOCKING:
- *	Inherited from caller.
- */
-
-static void ata_pio_sectors(struct ata_queued_cmd *qc)
-{
-	if (is_multi_taskfile(&qc->tf)) {
-		/* READ/WRITE MULTIPLE */
-		unsigned int nsect;
-
-		WARN_ON(qc->dev->multi_count == 0);
-
-		nsect = min((qc->nbytes - qc->curbytes) / qc->sect_size,
-			    qc->dev->multi_count);
-		while (nsect--)
-			ata_pio_sector(qc);
-	} else
-		ata_pio_sector(qc);
-
-	ata_altstatus(qc->ap); /* flush */
-}
-
-/**
- *	atapi_send_cdb - Write CDB bytes to hardware
- *	@ap: Port to which ATAPI device is attached.
- *	@qc: Taskfile currently active
- *
- *	When device has indicated its readiness to accept
- *	a CDB, this function is called.  Send the CDB.
- *
- *	LOCKING:
- *	caller.
- */
-
-static void atapi_send_cdb(struct ata_port *ap, struct ata_queued_cmd *qc)
-{
-	/* send SCSI cdb */
-	DPRINTK("send cdb\n");
-	WARN_ON(qc->dev->cdb_len < 12);
-
-	ap->ops->data_xfer(qc->dev, qc->cdb, qc->dev->cdb_len, 1);
-	ata_altstatus(ap); /* flush */
-
-	switch (qc->tf.protocol) {
-	case ATAPI_PROT_PIO:
-		ap->hsm_task_state = HSM_ST;
-		break;
-	case ATAPI_PROT_NODATA:
-		ap->hsm_task_state = HSM_ST_LAST;
-		break;
-	case ATAPI_PROT_DMA:
-		ap->hsm_task_state = HSM_ST_LAST;
-		/* initiate bmdma */
-		ap->ops->bmdma_start(qc);
-		break;
-	}
-}
-
-/**
- *	__atapi_pio_bytes - Transfer data from/to the ATAPI device.
- *	@qc: Command on going
- *	@bytes: number of bytes
- *
- *	Transfer Transfer data from/to the ATAPI device.
- *
- *	LOCKING:
- *	Inherited from caller.
- *
- */
-static int __atapi_pio_bytes(struct ata_queued_cmd *qc, unsigned int bytes)
-{
-	int rw = (qc->tf.flags & ATA_TFLAG_WRITE) ? WRITE : READ;
-	struct ata_port *ap = qc->ap;
-	struct ata_device *dev = qc->dev;
-	struct ata_eh_info *ehi = &dev->link->eh_info;
-	struct scatterlist *sg;
-	struct page *page;
-	unsigned char *buf;
-	unsigned int offset, count, consumed;
-
-next_sg:
-	sg = qc->cursg;
-	if (unlikely(!sg)) {
-		ata_ehi_push_desc(ehi, "unexpected or too much trailing data "
-				  "buf=%u cur=%u bytes=%u",
-				  qc->nbytes, qc->curbytes, bytes);
-		return -1;
-	}
-
-	page = sg_page(sg);
-	offset = sg->offset + qc->cursg_ofs;
-
-	/* get the current page and offset */
-	page = nth_page(page, (offset >> PAGE_SHIFT));
-	offset %= PAGE_SIZE;
-
-	/* don't overrun current sg */
-	count = min(sg->length - qc->cursg_ofs, bytes);
-
-	/* don't cross page boundaries */
-	count = min(count, (unsigned int)PAGE_SIZE - offset);
-
-	DPRINTK("data %s\n", qc->tf.flags & ATA_TFLAG_WRITE ? "write" : "read");
-
-	if (PageHighMem(page)) {
-		unsigned long flags;
-
-		/* FIXME: use bounce buffer */
-		local_irq_save(flags);
-		buf = kmap_atomic(page, KM_IRQ0);
-
-		/* do the actual data transfer */
-		consumed = ap->ops->data_xfer(dev,  buf + offset, count, rw);
-
-		kunmap_atomic(buf, KM_IRQ0);
-		local_irq_restore(flags);
-	} else {
-		buf = page_address(page);
-		consumed = ap->ops->data_xfer(dev,  buf + offset, count, rw);
-	}
-
-	bytes -= min(bytes, consumed);
-	qc->curbytes += count;
-	qc->cursg_ofs += count;
-
-	if (qc->cursg_ofs == sg->length) {
-		qc->cursg = sg_next(qc->cursg);
-		qc->cursg_ofs = 0;
-	}
-
-	/* consumed can be larger than count only for the last transfer */
-	WARN_ON(qc->cursg && count != consumed);
-
-	if (bytes)
-		goto next_sg;
-	return 0;
-}
-
-/**
- *	atapi_pio_bytes - Transfer data from/to the ATAPI device.
- *	@qc: Command on going
- *
- *	Transfer Transfer data from/to the ATAPI device.
- *
- *	LOCKING:
- *	Inherited from caller.
- */
-
-static void atapi_pio_bytes(struct ata_queued_cmd *qc)
-{
-	struct ata_port *ap = qc->ap;
-	struct ata_device *dev = qc->dev;
-	struct ata_eh_info *ehi = &dev->link->eh_info;
-	unsigned int ireason, bc_lo, bc_hi, bytes;
-	int i_write, do_write = (qc->tf.flags & ATA_TFLAG_WRITE) ? 1 : 0;
-
-	/* Abuse qc->result_tf for temp storage of intermediate TF
-	 * here to save some kernel stack usage.
-	 * For normal completion, qc->result_tf is not relevant. For
-	 * error, qc->result_tf is later overwritten by ata_qc_complete().
-	 * So, the correctness of qc->result_tf is not affected.
-	 */
-	ap->ops->tf_read(ap, &qc->result_tf);
-	ireason = qc->result_tf.nsect;
-	bc_lo = qc->result_tf.lbam;
-	bc_hi = qc->result_tf.lbah;
-	bytes = (bc_hi << 8) | bc_lo;
-
-	/* shall be cleared to zero, indicating xfer of data */
-	if (unlikely(ireason & (1 << 0)))
-		goto atapi_check;
-
-	/* make sure transfer direction matches expected */
-	i_write = ((ireason & (1 << 1)) == 0) ? 1 : 0;
-	if (unlikely(do_write != i_write))
-		goto atapi_check;
-
-	if (unlikely(!bytes))
-		goto atapi_check;
-
-	VPRINTK("ata%u: xfering %d bytes\n", ap->print_id, bytes);
-
-	if (unlikely(__atapi_pio_bytes(qc, bytes)))
-		goto err_out;
-	ata_altstatus(ap); /* flush */
-
-	return;
-
- atapi_check:
-	ata_ehi_push_desc(ehi, "ATAPI check failed (ireason=0x%x bytes=%u)",
-			  ireason, bytes);
- err_out:
-	qc->err_mask |= AC_ERR_HSM;
-	ap->hsm_task_state = HSM_ST_ERR;
-}
-
-/**
- *	ata_hsm_ok_in_wq - Check if the qc can be handled in the workqueue.
- *	@ap: the target ata_port
- *	@qc: qc on going
- *
- *	RETURNS:
- *	1 if ok in workqueue, 0 otherwise.
- */
-
-static inline int ata_hsm_ok_in_wq(struct ata_port *ap, struct ata_queued_cmd *qc)
-{
-	if (qc->tf.flags & ATA_TFLAG_POLLING)
-		return 1;
-
-	if (ap->hsm_task_state == HSM_ST_FIRST) {
-		if (qc->tf.protocol == ATA_PROT_PIO &&
-		    (qc->tf.flags & ATA_TFLAG_WRITE))
-		    return 1;
-
-		if (ata_is_atapi(qc->tf.protocol) &&
-		    !(qc->dev->flags & ATA_DFLAG_CDB_INTR))
-			return 1;
-	}
-
-	return 0;
-}
-
-/**
- *	ata_hsm_qc_complete - finish a qc running on standard HSM
- *	@qc: Command to complete
- *	@in_wq: 1 if called from workqueue, 0 otherwise
- *
- *	Finish @qc which is running on standard HSM.
- *
- *	LOCKING:
- *	If @in_wq is zero, spin_lock_irqsave(host lock).
- *	Otherwise, none on entry and grabs host lock.
- */
-static void ata_hsm_qc_complete(struct ata_queued_cmd *qc, int in_wq)
-{
-	struct ata_port *ap = qc->ap;
-	unsigned long flags;
-
-	if (ap->ops->error_handler) {
-		if (in_wq) {
-			spin_lock_irqsave(ap->lock, flags);
-
-			/* EH might have kicked in while host lock is
-			 * released.
-			 */
-			qc = ata_qc_from_tag(ap, qc->tag);
-			if (qc) {
-				if (likely(!(qc->err_mask & AC_ERR_HSM))) {
-					ap->ops->irq_on(ap);
-					ata_qc_complete(qc);
-				} else
-					ata_port_freeze(ap);
-			}
-
-			spin_unlock_irqrestore(ap->lock, flags);
-		} else {
-			if (likely(!(qc->err_mask & AC_ERR_HSM)))
-				ata_qc_complete(qc);
-			else
-				ata_port_freeze(ap);
-		}
-	} else {
-		if (in_wq) {
-			spin_lock_irqsave(ap->lock, flags);
-			ap->ops->irq_on(ap);
-			ata_qc_complete(qc);
-			spin_unlock_irqrestore(ap->lock, flags);
-		} else
-			ata_qc_complete(qc);
-	}
-}
-
-/**
- *	ata_hsm_move - move the HSM to the next state.
- *	@ap: the target ata_port
- *	@qc: qc on going
- *	@status: current device status
- *	@in_wq: 1 if called from workqueue, 0 otherwise
- *
- *	RETURNS:
- *	1 when poll next status needed, 0 otherwise.
- */
-int ata_hsm_move(struct ata_port *ap, struct ata_queued_cmd *qc,
-		 u8 status, int in_wq)
-{
-	unsigned long flags = 0;
-	int poll_next;
-
-	WARN_ON((qc->flags & ATA_QCFLAG_ACTIVE) == 0);
-
-	/* Make sure ata_qc_issue_prot() does not throw things
-	 * like DMA polling into the workqueue. Notice that
-	 * in_wq is not equivalent to (qc->tf.flags & ATA_TFLAG_POLLING).
-	 */
-	WARN_ON(in_wq != ata_hsm_ok_in_wq(ap, qc));
-
-fsm_start:
-	DPRINTK("ata%u: protocol %d task_state %d (dev_stat 0x%X)\n",
-		ap->print_id, qc->tf.protocol, ap->hsm_task_state, status);
-
-	switch (ap->hsm_task_state) {
-	case HSM_ST_FIRST:
-		/* Send first data block or PACKET CDB */
-
-		/* If polling, we will stay in the work queue after
-		 * sending the data. Otherwise, interrupt handler
-		 * takes over after sending the data.
-		 */
-		poll_next = (qc->tf.flags & ATA_TFLAG_POLLING);
-
-		/* check device status */
-		if (unlikely((status & ATA_DRQ) == 0)) {
-			/* handle BSY=0, DRQ=0 as error */
-			if (likely(status & (ATA_ERR | ATA_DF)))
-				/* device stops HSM for abort/error */
-				qc->err_mask |= AC_ERR_DEV;
-			else
-				/* HSM violation. Let EH handle this */
-				qc->err_mask |= AC_ERR_HSM;
-
-			ap->hsm_task_state = HSM_ST_ERR;
-			goto fsm_start;
-		}
-
-		/* Device should not ask for data transfer (DRQ=1)
-		 * when it finds something wrong.
-		 * We ignore DRQ here and stop the HSM by
-		 * changing hsm_task_state to HSM_ST_ERR and
-		 * let the EH abort the command or reset the device.
-		 */
-		if (unlikely(status & (ATA_ERR | ATA_DF))) {
-			/* Some ATAPI tape drives forget to clear the ERR bit
-			 * when doing the next command (mostly request sense).
-			 * We ignore ERR here to workaround and proceed sending
-			 * the CDB.
-			 */
-			if (!(qc->dev->horkage & ATA_HORKAGE_STUCK_ERR)) {
-				ata_port_printk(ap, KERN_WARNING,
-						"DRQ=1 with device error, "
-						"dev_stat 0x%X\n", status);
-				qc->err_mask |= AC_ERR_HSM;
-				ap->hsm_task_state = HSM_ST_ERR;
-				goto fsm_start;
-			}
-		}
-
-		/* Send the CDB (atapi) or the first data block (ata pio out).
-		 * During the state transition, interrupt handler shouldn't
-		 * be invoked before the data transfer is complete and
-		 * hsm_task_state is changed. Hence, the following locking.
-		 */
-		if (in_wq)
-			spin_lock_irqsave(ap->lock, flags);
-
-		if (qc->tf.protocol == ATA_PROT_PIO) {
-			/* PIO data out protocol.
-			 * send first data block.
-			 */
-
-			/* ata_pio_sectors() might change the state
-			 * to HSM_ST_LAST. so, the state is changed here
-			 * before ata_pio_sectors().
-			 */
-			ap->hsm_task_state = HSM_ST;
-			ata_pio_sectors(qc);
-		} else
-			/* send CDB */
-			atapi_send_cdb(ap, qc);
-
-		if (in_wq)
-			spin_unlock_irqrestore(ap->lock, flags);
-
-		/* if polling, ata_pio_task() handles the rest.
-		 * otherwise, interrupt handler takes over from here.
-		 */
-		break;
-
-	case HSM_ST:
-		/* complete command or read/write the data register */
-		if (qc->tf.protocol == ATAPI_PROT_PIO) {
-			/* ATAPI PIO protocol */
-			if ((status & ATA_DRQ) == 0) {
-				/* No more data to transfer or device error.
-				 * Device error will be tagged in HSM_ST_LAST.
-				 */
-				ap->hsm_task_state = HSM_ST_LAST;
-				goto fsm_start;
-			}
-
-			/* Device should not ask for data transfer (DRQ=1)
-			 * when it finds something wrong.
-			 * We ignore DRQ here and stop the HSM by
-			 * changing hsm_task_state to HSM_ST_ERR and
-			 * let the EH abort the command or reset the device.
-			 */
-			if (unlikely(status & (ATA_ERR | ATA_DF))) {
-				ata_port_printk(ap, KERN_WARNING, "DRQ=1 with "
-						"device error, dev_stat 0x%X\n",
-						status);
-				qc->err_mask |= AC_ERR_HSM;
-				ap->hsm_task_state = HSM_ST_ERR;
-				goto fsm_start;
-			}
-
-			atapi_pio_bytes(qc);
-
-			if (unlikely(ap->hsm_task_state == HSM_ST_ERR))
-				/* bad ireason reported by device */
-				goto fsm_start;
-
-		} else {
-			/* ATA PIO protocol */
-			if (unlikely((status & ATA_DRQ) == 0)) {
-				/* handle BSY=0, DRQ=0 as error */
-				if (likely(status & (ATA_ERR | ATA_DF)))
-					/* device stops HSM for abort/error */
-					qc->err_mask |= AC_ERR_DEV;
-				else
-					/* HSM violation. Let EH handle this.
-					 * Phantom devices also trigger this
-					 * condition.  Mark hint.
-					 */
-					qc->err_mask |= AC_ERR_HSM |
-							AC_ERR_NODEV_HINT;
-
-				ap->hsm_task_state = HSM_ST_ERR;
-				goto fsm_start;
-			}
-
-			/* For PIO reads, some devices may ask for
-			 * data transfer (DRQ=1) alone with ERR=1.
-			 * We respect DRQ here and transfer one
-			 * block of junk data before changing the
-			 * hsm_task_state to HSM_ST_ERR.
-			 *
-			 * For PIO writes, ERR=1 DRQ=1 doesn't make
-			 * sense since the data block has been
-			 * transferred to the device.
-			 */
-			if (unlikely(status & (ATA_ERR | ATA_DF))) {
-				/* data might be corrputed */
-				qc->err_mask |= AC_ERR_DEV;
-
-				if (!(qc->tf.flags & ATA_TFLAG_WRITE)) {
-					ata_pio_sectors(qc);
-					status = ata_wait_idle(ap);
-				}
-
-				if (status & (ATA_BUSY | ATA_DRQ))
-					qc->err_mask |= AC_ERR_HSM;
-
-				/* ata_pio_sectors() might change the
-				 * state to HSM_ST_LAST. so, the state
-				 * is changed after ata_pio_sectors().
-				 */
-				ap->hsm_task_state = HSM_ST_ERR;
-				goto fsm_start;
-			}
-
-			ata_pio_sectors(qc);
-
-			if (ap->hsm_task_state == HSM_ST_LAST &&
-			    (!(qc->tf.flags & ATA_TFLAG_WRITE))) {
-				/* all data read */
-				status = ata_wait_idle(ap);
-				goto fsm_start;
-			}
-		}
-
-		poll_next = 1;
-		break;
-
-	case HSM_ST_LAST:
-		if (unlikely(!ata_ok(status))) {
-			qc->err_mask |= __ac_err_mask(status);
-			ap->hsm_task_state = HSM_ST_ERR;
-			goto fsm_start;
-		}
+int ata_std_qc_defer(struct ata_queued_cmd *qc)
+{
+	struct ata_link *link = qc->dev->link;
@@ -5657,3 +4348,7 @@
-		/* no more data to transfer */
-		DPRINTK("ata%u: dev %u command complete, drv_stat 0x%x\n",
-			ap->print_id, qc->dev->devno, status);
+	if (qc->tf.protocol == ATA_PROT_NCQ) {
+		if (!ata_tag_valid(link->active_tag))
+			return 0;
+	} else {
+		if (!ata_tag_valid(link->active_tag) && !link->sactive)
+			return 0;
+	}
@@ -5661 +4356,2 @@
-		WARN_ON(qc->err_mask);
+	return ATA_DEFER_LINK;
+}
@@ -5663 +4359 @@
-		ap->hsm_task_state = HSM_ST_IDLE;
+void ata_noop_qc_prep(struct ata_queued_cmd *qc) { }
@@ -5665,2 +4361,20 @@
-		/* complete taskfile transaction */
-		ata_hsm_qc_complete(qc, in_wq);
+/**
+ *	ata_sg_init - Associate command with scatter-gather table.
+ *	@qc: Command to be associated
+ *	@sg: Scatter-gather table.
+ *	@n_elem: Number of elements in s/g table.
+ *
+ *	Initialize the data-related elements of queued_cmd @qc
+ *	to point to a scatter-gather table @sg, containing @n_elem
+ *	elements.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host lock)
+ */
+void ata_sg_init(struct ata_queued_cmd *qc, struct scatterlist *sg,
+		 unsigned int n_elem)
+{
+	qc->sg = sg;
+	qc->n_elem = n_elem;
+	qc->cursg = qc->sg;
+}
@@ -5668,2 +4382,17 @@
-		poll_next = 0;
-		break;
+/**
+ *	ata_sg_setup - DMA-map the scatter-gather table associated with a command.
+ *	@qc: Command with scatter-gather table to be mapped.
+ *
+ *	DMA-map the scatter-gather table associated with queued_cmd @qc.
+ *
+ *	LOCKING:
+ *	spin_lock_irqsave(host lock)
+ *
+ *	RETURNS:
+ *	Zero on success, negative on error.
+ *
+ */
+static int ata_sg_setup(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	unsigned int n_elem;
@@ -5671,5 +4400 @@
-	case HSM_ST_ERR:
-		/* make sure qc->err_mask is available to
-		 * know what's wrong and recover
-		 */
-		WARN_ON(qc->err_mask == 0);
+	VPRINTK("ENTER, ata%u\n", ap->print_id);
@@ -5677 +4402,3 @@
-		ap->hsm_task_state = HSM_ST_IDLE;
+	n_elem = dma_map_sg(ap->dev, qc->sg, qc->n_elem, qc->dma_dir);
+	if (n_elem < 1)
+		return -1;
@@ -5679,2 +4406 @@
-		/* complete taskfile transaction */
-		ata_hsm_qc_complete(qc, in_wq);
+	DPRINTK("%d sg elements mapped\n", n_elem);
@@ -5682,6 +4408,2 @@
-		poll_next = 0;
-		break;
-	default:
-		poll_next = 0;
-		BUG();
-	}
+	qc->n_elem = n_elem;
+	qc->flags |= ATA_QCFLAG_DMAMAP;
@@ -5689 +4411 @@
-	return poll_next;
+	return 0;
@@ -5692 +4414,13 @@
-static void ata_pio_task(struct work_struct *work)
+/**
+ *	swap_buf_le16 - swap halves of 16-bit words in place
+ *	@buf:  Buffer to swap
+ *	@buf_words:  Number of 16-bit words in buffer.
+ *
+ *	Swap halves of 16-bit words if needed to convert from
+ *	little-endian byte order to native cpu byte order, or
+ *	vice-versa.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+void swap_buf_le16(u16 *buf, unsigned int buf_words)
@@ -5694,28 +4428,2 @@
-	struct ata_port *ap =
-		container_of(work, struct ata_port, port_task.work);
-	struct ata_queued_cmd *qc = ap->port_task_data;
-	u8 status;
-	int poll_next;
-
-fsm_start:
-	WARN_ON(ap->hsm_task_state == HSM_ST_IDLE);
-
-	/*
-	 * This is purely heuristic.  This is a fast path.
-	 * Sometimes when we enter, BSY will be cleared in
-	 * a chk-status or two.  If not, the drive is probably seeking
-	 * or something.  Snooze for a couple msecs, then
-	 * chk-status again.  If still busy, queue delayed work.
-	 */
-	status = ata_busy_wait(ap, ATA_BUSY, 5);
-	if (status & ATA_BUSY) {
-		msleep(2);
-		status = ata_busy_wait(ap, ATA_BUSY, 10);
-		if (status & ATA_BUSY) {
-			ata_pio_queue_task(ap, qc, ATA_SHORT_PAUSE);
-			return;
-		}
-	}
-
-	/* move the HSM */
-	poll_next = ata_hsm_move(ap, qc, status, 1);
+#ifdef __BIG_ENDIAN
+	unsigned int i;
@@ -5723,5 +4431,3 @@
-	/* another command or interrupt handler
-	 * may be running at this point.
-	 */
-	if (poll_next)
-		goto fsm_start;
+	for (i = 0; i < buf_words; i++)
+		buf[i] = le16_to_cpu(buf[i]);
+#endif /* __BIG_ENDIAN */
@@ -5853 +4559 @@
-	ap->ops->tf_read(ap, &qc->result_tf);
+	ap->ops->qc_fill_rtf(qc);
@@ -5963 +4668,0 @@
- *	@finish_qc: LLDD callback invoked before completing a qc
@@ -5976,2 +4681 @@
-int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active,
-			     void (*finish_qc)(struct ata_queued_cmd *))
+int ata_qc_complete_multiple(struct ata_port *ap, u32 qc_active)
@@ -5998,2 +4701,0 @@
-			if (finish_qc)
-				finish_qc(qc);
@@ -6058 +4760 @@
-	/* if device is sleeping, schedule softreset and abort the link */
+	/* if device is sleeping, schedule reset and abort the link */
@@ -6060 +4762 @@
-		link->eh_info.action |= ATA_EH_SOFTRESET;
+		link->eh_info.action |= ATA_EH_RESET;
@@ -6080,279 +4781,0 @@
- *	ata_qc_issue_prot - issue taskfile to device in proto-dependent manner
- *	@qc: command to issue to device
- *
- *	Using various libata functions and hooks, this function
- *	starts an ATA command.  ATA commands are grouped into
- *	classes called "protocols", and issuing each type of protocol
- *	is slightly different.
- *
- *	May be used as the qc_issue() entry in ata_port_operations.
- *
- *	LOCKING:
- *	spin_lock_irqsave(host lock)
- *
- *	RETURNS:
- *	Zero on success, AC_ERR_* mask on failure
- */
-
-unsigned int ata_qc_issue_prot(struct ata_queued_cmd *qc)
-{
-	struct ata_port *ap = qc->ap;
-
-	/* Use polling pio if the LLD doesn't handle
-	 * interrupt driven pio and atapi CDB interrupt.
-	 */
-	if (ap->flags & ATA_FLAG_PIO_POLLING) {
-		switch (qc->tf.protocol) {
-		case ATA_PROT_PIO:
-		case ATA_PROT_NODATA:
-		case ATAPI_PROT_PIO:
-		case ATAPI_PROT_NODATA:
-			qc->tf.flags |= ATA_TFLAG_POLLING;
-			break;
-		case ATAPI_PROT_DMA:
-			if (qc->dev->flags & ATA_DFLAG_CDB_INTR)
-				/* see ata_dma_blacklisted() */
-				BUG();
-			break;
-		default:
-			break;
-		}
-	}
-
-	/* select the device */
-	ata_dev_select(ap, qc->dev->devno, 1, 0);
-
-	/* start the command */
-	switch (qc->tf.protocol) {
-	case ATA_PROT_NODATA:
-		if (qc->tf.flags & ATA_TFLAG_POLLING)
-			ata_qc_set_polling(qc);
-
-		ata_tf_to_host(ap, &qc->tf);
-		ap->hsm_task_state = HSM_ST_LAST;
-
-		if (qc->tf.flags & ATA_TFLAG_POLLING)
-			ata_pio_queue_task(ap, qc, 0);
-
-		break;
-
-	case ATA_PROT_DMA:
-		WARN_ON(qc->tf.flags & ATA_TFLAG_POLLING);
-
-		ap->ops->tf_load(ap, &qc->tf);	 /* load tf registers */
-		ap->ops->bmdma_setup(qc);	    /* set up bmdma */
-		ap->ops->bmdma_start(qc);	    /* initiate bmdma */
-		ap->hsm_task_state = HSM_ST_LAST;
-		break;
-
-	case ATA_PROT_PIO:
-		if (qc->tf.flags & ATA_TFLAG_POLLING)
-			ata_qc_set_polling(qc);
-
-		ata_tf_to_host(ap, &qc->tf);
-
-		if (qc->tf.flags & ATA_TFLAG_WRITE) {
-			/* PIO data out protocol */
-			ap->hsm_task_state = HSM_ST_FIRST;
-			ata_pio_queue_task(ap, qc, 0);
-
-			/* always send first data block using
-			 * the ata_pio_task() codepath.
-			 */
-		} else {
-			/* PIO data in protocol */
-			ap->hsm_task_state = HSM_ST;
-
-			if (qc->tf.flags & ATA_TFLAG_POLLING)
-				ata_pio_queue_task(ap, qc, 0);
-
-			/* if polling, ata_pio_task() handles the rest.
-			 * otherwise, interrupt handler takes over from here.
-			 */
-		}
-
-		break;
-
-	case ATAPI_PROT_PIO:
-	case ATAPI_PROT_NODATA:
-		if (qc->tf.flags & ATA_TFLAG_POLLING)
-			ata_qc_set_polling(qc);
-
-		ata_tf_to_host(ap, &qc->tf);
-
-		ap->hsm_task_state = HSM_ST_FIRST;
-
-		/* send cdb by polling if no cdb interrupt */
-		if ((!(qc->dev->flags & ATA_DFLAG_CDB_INTR)) ||
-		    (qc->tf.flags & ATA_TFLAG_POLLING))
-			ata_pio_queue_task(ap, qc, 0);
-		break;
-
-	case ATAPI_PROT_DMA:
-		WARN_ON(qc->tf.flags & ATA_TFLAG_POLLING);
-
-		ap->ops->tf_load(ap, &qc->tf);	 /* load tf registers */
-		ap->ops->bmdma_setup(qc);	    /* set up bmdma */
-		ap->hsm_task_state = HSM_ST_FIRST;
-
-		/* send cdb by polling if no cdb interrupt */
-		if (!(qc->dev->flags & ATA_DFLAG_CDB_INTR))
-			ata_pio_queue_task(ap, qc, 0);
-		break;
-
-	default:
-		WARN_ON(1);
-		return AC_ERR_SYSTEM;
-	}
-
-	return 0;
-}
-
-/**
- *	ata_host_intr - Handle host interrupt for given (port, task)
- *	@ap: Port on which interrupt arrived (possibly...)
- *	@qc: Taskfile currently active in engine
- *
- *	Handle host interrupt for given queued command.  Currently,
- *	only DMA interrupts are handled.  All other commands are
- *	handled via polling with interrupts disabled (nIEN bit).
- *
- *	LOCKING:
- *	spin_lock_irqsave(host lock)
- *
- *	RETURNS:
- *	One if interrupt was handled, zero if not (shared irq).
- */
-
-inline unsigned int ata_host_intr(struct ata_port *ap,
-				  struct ata_queued_cmd *qc)
-{
-	struct ata_eh_info *ehi = &ap->link.eh_info;
-	u8 status, host_stat = 0;
-
-	VPRINTK("ata%u: protocol %d task_state %d\n",
-		ap->print_id, qc->tf.protocol, ap->hsm_task_state);
-
-	/* Check whether we are expecting interrupt in this state */
-	switch (ap->hsm_task_state) {
-	case HSM_ST_FIRST:
-		/* Some pre-ATAPI-4 devices assert INTRQ
-		 * at this state when ready to receive CDB.
-		 */
-
-		/* Check the ATA_DFLAG_CDB_INTR flag is enough here.
-		 * The flag was turned on only for atapi devices.  No
-		 * need to check ata_is_atapi(qc->tf.protocol) again.
-		 */
-		if (!(qc->dev->flags & ATA_DFLAG_CDB_INTR))
-			goto idle_irq;
-		break;
-	case HSM_ST_LAST:
-		if (qc->tf.protocol == ATA_PROT_DMA ||
-		    qc->tf.protocol == ATAPI_PROT_DMA) {
-			/* check status of DMA engine */
-			host_stat = ap->ops->bmdma_status(ap);
-			VPRINTK("ata%u: host_stat 0x%X\n",
-				ap->print_id, host_stat);
-
-			/* if it's not our irq... */
-			if (!(host_stat & ATA_DMA_INTR))
-				goto idle_irq;
-
-			/* before we do anything else, clear DMA-Start bit */
-			ap->ops->bmdma_stop(qc);
-
-			if (unlikely(host_stat & ATA_DMA_ERR)) {
-				/* error when transfering data to/from memory */
-				qc->err_mask |= AC_ERR_HOST_BUS;
-				ap->hsm_task_state = HSM_ST_ERR;
-			}
-		}
-		break;
-	case HSM_ST:
-		break;
-	default:
-		goto idle_irq;
-	}
-
-	/* check altstatus */
-	status = ata_altstatus(ap);
-	if (status & ATA_BUSY)
-		goto idle_irq;
-
-	/* check main status, clearing INTRQ */
-	status = ata_chk_status(ap);
-	if (unlikely(status & ATA_BUSY))
-		goto idle_irq;
-
-	/* ack bmdma irq events */
-	ap->ops->irq_clear(ap);
-
-	ata_hsm_move(ap, qc, status, 0);
-
-	if (unlikely(qc->err_mask) && (qc->tf.protocol == ATA_PROT_DMA ||
-				       qc->tf.protocol == ATAPI_PROT_DMA))
-		ata_ehi_push_desc(ehi, "BMDMA stat 0x%x", host_stat);
-
-	return 1;	/* irq handled */
-
-idle_irq:
-	ap->stats.idle_irq++;
-
-#ifdef ATA_IRQ_TRAP
-	if ((ap->stats.idle_irq % 1000) == 0) {
-		ata_chk_status(ap);
-		ap->ops->irq_clear(ap);
-		ata_port_printk(ap, KERN_WARNING, "irq trap\n");
-		return 1;
-	}
-#endif
-	return 0;	/* irq not handled */
-}
-
-/**
- *	ata_interrupt - Default ATA host interrupt handler
- *	@irq: irq line (unused)
- *	@dev_instance: pointer to our ata_host information structure
- *
- *	Default interrupt handler for PCI IDE devices.  Calls
- *	ata_host_intr() for each port that is not disabled.
- *
- *	LOCKING:
- *	Obtains host lock during operation.
- *
- *	RETURNS:
- *	IRQ_NONE or IRQ_HANDLED.
- */
-
-irqreturn_t ata_interrupt(int irq, void *dev_instance)
-{
-	struct ata_host *host = dev_instance;
-	unsigned int i;
-	unsigned int handled = 0;
-	unsigned long flags;
-
-	/* TODO: make _irqsave conditional on x86 PCI IDE legacy mode */
-	spin_lock_irqsave(&host->lock, flags);
-
-	for (i = 0; i < host->n_ports; i++) {
-		struct ata_port *ap;
-
-		ap = host->ports[i];
-		if (ap &&
-		    !(ap->flags & ATA_FLAG_DISABLED)) {
-			struct ata_queued_cmd *qc;
-
-			qc = ata_qc_from_tag(ap, ap->link.active_tag);
-			if (qc && (!(qc->tf.flags & ATA_TFLAG_POLLING)) &&
-			    (qc->flags & ATA_QCFLAG_ACTIVE))
-				handled |= ata_host_intr(ap, qc);
-		}
-	}
-
-	spin_unlock_irqrestore(&host->lock, flags);
-
-	return IRQ_RETVAL(handled);
-}
-
-/**
@@ -6516,26 +4938,0 @@
-int ata_flush_cache(struct ata_device *dev)
-{
-	unsigned int err_mask;
-	u8 cmd;
-
-	if (!ata_try_flush_cache(dev))
-		return 0;
-
-	if (dev->flags & ATA_DFLAG_FLUSH_EXT)
-		cmd = ATA_CMD_FLUSH_EXT;
-	else
-		cmd = ATA_CMD_FLUSH;
-
-	/* This is wrong. On a failed flush we get back the LBA of the lost
-	   sector and we should (assuming it wasn't aborted as unknown) issue
-	   a further flush command to continue the writeback until it
-	   does not error */
-	err_mask = ata_do_simple_cmd(dev, cmd);
-	if (err_mask) {
-		ata_dev_printk(dev, KERN_ERR, "failed to flush cache\n");
-		return -EIO;
-	}
-
-	return 0;
-}
-
@@ -6637 +5034 @@
-	ata_host_request_pm(host, PMSG_ON, ATA_EH_SOFTRESET,
+	ata_host_request_pm(host, PMSG_ON, ATA_EH_RESET,
@@ -6811,0 +5209 @@
+#ifdef CONFIG_ATA_SFF
@@ -6812,0 +5211 @@
+#endif
@@ -6962,2 +5360,0 @@
-		if (!host->private_data && pi->private_data)
-			host->private_data = pi->private_data;
@@ -6987,0 +5385,50 @@
+ *	ata_finalize_port_ops - finalize ata_port_operations
+ *	@ops: ata_port_operations to finalize
+ *
+ *	An ata_port_operations can inherit from another ops and that
+ *	ops can again inherit from another.  This can go on as many
+ *	times as necessary as long as there is no loop in the
+ *	inheritance chain.
+ *
+ *	Ops tables are finalized when the host is started.  NULL or
+ *	unspecified entries are inherited from the closet ancestor
+ *	which has the method and the entry is populated with it.
+ *	After finalization, the ops table directly points to all the
+ *	methods and ->inherits is no longer necessary and cleared.
+ *
+ *	Using ATA_OP_NULL, inheriting ops can force a method to NULL.
+ *
+ *	LOCKING:
+ *	None.
+ */
+static void ata_finalize_port_ops(struct ata_port_operations *ops)
+{
+	static DEFINE_SPINLOCK(lock);
+	const struct ata_port_operations *cur;
+	void **begin = (void **)ops;
+	void **end = (void **)&ops->inherits;
+	void **pp;
+
+	if (!ops || !ops->inherits)
+		return;
+
+	spin_lock(&lock);
+
+	for (cur = ops->inherits; cur; cur = cur->inherits) {
+		void **inherit = (void **)cur;
+
+		for (pp = begin; pp < end; pp++, inherit++)
+			if (!*pp)
+				*pp = *inherit;
+	}
+
+	for (pp = begin; pp < end; pp++)
+		if (IS_ERR(*pp))
+			*pp = NULL;
+
+	ops->inherits = NULL;
+
+	spin_unlock(&lock);
+}
+
+/**
@@ -7011,0 +5459,2 @@
+	ata_finalize_port_ops(host->ops);
+
@@ -7014,0 +5464,2 @@
+		ata_finalize_port_ops(ap->ops);
+
@@ -7076 +5527 @@
-		   unsigned long flags, const struct ata_port_operations *ops)
+		   unsigned long flags, struct ata_port_operations *ops)
@@ -7172,3 +5623,2 @@
-			ehi->probe_mask =
-				(1 << ata_link_max_devices(&ap->link)) - 1;
-			ehi->action |= ATA_EH_SOFTRESET;
+			ehi->probe_mask |= ATA_ALL_DEVICES;
+			ehi->action |= ATA_EH_RESET | ATA_EH_LPM;
@@ -7207 +5656,0 @@
-		ata_lpm_schedule(ap, ap->pm_policy);
@@ -7339,27 +5787,0 @@
-/**
- *	ata_std_ports - initialize ioaddr with standard port offsets.
- *	@ioaddr: IO address structure to be initialized
- *
- *	Utility function which initializes data_addr, error_addr,
- *	feature_addr, nsect_addr, lbal_addr, lbam_addr, lbah_addr,
- *	device_addr, status_addr, and command_addr to standard offsets
- *	relative to cmd_addr.
- *
- *	Does not set ctl_addr, altstatus_addr, bmdma_addr, or scr_addr.
- */
-
-void ata_std_ports(struct ata_ioports *ioaddr)
-{
-	ioaddr->data_addr = ioaddr->cmd_addr + ATA_REG_DATA;
-	ioaddr->error_addr = ioaddr->cmd_addr + ATA_REG_ERR;
-	ioaddr->feature_addr = ioaddr->cmd_addr + ATA_REG_FEATURE;
-	ioaddr->nsect_addr = ioaddr->cmd_addr + ATA_REG_NSECT;
-	ioaddr->lbal_addr = ioaddr->cmd_addr + ATA_REG_LBAL;
-	ioaddr->lbam_addr = ioaddr->cmd_addr + ATA_REG_LBAM;
-	ioaddr->lbah_addr = ioaddr->cmd_addr + ATA_REG_LBAH;
-	ioaddr->device_addr = ioaddr->cmd_addr + ATA_REG_DEVICE;
-	ioaddr->status_addr = ioaddr->cmd_addr + ATA_REG_STATUS;
-	ioaddr->command_addr = ioaddr->cmd_addr + ATA_REG_CMD;
-}
-
-
@@ -7752,5 +6174 @@
-static void ata_dummy_noret(struct ata_port *ap)	{ }
-static int ata_dummy_ret0(struct ata_port *ap)		{ return 0; }
-static void ata_dummy_qc_noret(struct ata_queued_cmd *qc) { }
-
-static u8 ata_dummy_check_status(struct ata_port *ap)
+static unsigned int ata_dummy_qc_issue(struct ata_queued_cmd *qc)
@@ -7758 +6176 @@
-	return ATA_DRDY;
+	return AC_ERR_SYSTEM;
@@ -7761 +6179 @@
-static unsigned int ata_dummy_qc_issue(struct ata_queued_cmd *qc)
+static void ata_dummy_error_handler(struct ata_port *ap)
@@ -7763 +6181 @@
-	return AC_ERR_SYSTEM;
+	/* truly dummy */
@@ -7766,4 +6184 @@
-const struct ata_port_operations ata_dummy_port_ops = {
-	.check_status		= ata_dummy_check_status,
-	.check_altstatus	= ata_dummy_check_status,
-	.dev_select		= ata_noop_dev_select,
+struct ata_port_operations ata_dummy_port_ops = {
@@ -7772,7 +6187 @@
-	.freeze			= ata_dummy_noret,
-	.thaw			= ata_dummy_noret,
-	.error_handler		= ata_dummy_noret,
-	.post_internal_cmd	= ata_dummy_qc_noret,
-	.irq_clear		= ata_dummy_noret,
-	.port_start		= ata_dummy_ret0,
-	.port_stop		= ata_dummy_noret,
+	.error_handler		= ata_dummy_error_handler,
@@ -7793,0 +6203,2 @@
+EXPORT_SYMBOL_GPL(ata_base_port_ops);
+EXPORT_SYMBOL_GPL(sata_port_ops);
@@ -7797 +6207,0 @@
-EXPORT_SYMBOL_GPL(ata_std_ports);
@@ -7806 +6215,0 @@
-EXPORT_SYMBOL_GPL(ata_hsm_move);
@@ -7809,6 +6217,0 @@
-EXPORT_SYMBOL_GPL(ata_qc_issue_prot);
-EXPORT_SYMBOL_GPL(ata_tf_load);
-EXPORT_SYMBOL_GPL(ata_tf_read);
-EXPORT_SYMBOL_GPL(ata_noop_dev_select);
-EXPORT_SYMBOL_GPL(ata_std_dev_select);
-EXPORT_SYMBOL_GPL(sata_print_link_status);
@@ -7825,3 +6227,0 @@
-EXPORT_SYMBOL_GPL(ata_check_status);
-EXPORT_SYMBOL_GPL(ata_altstatus);
-EXPORT_SYMBOL_GPL(ata_exec_command);
@@ -7829,2 +6228,0 @@
-EXPORT_SYMBOL_GPL(ata_sff_port_start);
-EXPORT_SYMBOL_GPL(ata_interrupt);
@@ -7832,2 +6229,0 @@
-EXPORT_SYMBOL_GPL(ata_data_xfer);
-EXPORT_SYMBOL_GPL(ata_data_xfer_noirq);
@@ -7835,2 +6230,0 @@
-EXPORT_SYMBOL_GPL(ata_qc_prep);
-EXPORT_SYMBOL_GPL(ata_dumb_qc_prep);
@@ -7838,10 +6231,0 @@
-EXPORT_SYMBOL_GPL(ata_bmdma_setup);
-EXPORT_SYMBOL_GPL(ata_bmdma_start);
-EXPORT_SYMBOL_GPL(ata_bmdma_irq_clear);
-EXPORT_SYMBOL_GPL(ata_bmdma_status);
-EXPORT_SYMBOL_GPL(ata_bmdma_stop);
-EXPORT_SYMBOL_GPL(ata_bmdma_freeze);
-EXPORT_SYMBOL_GPL(ata_bmdma_thaw);
-EXPORT_SYMBOL_GPL(ata_bmdma_drive_eh);
-EXPORT_SYMBOL_GPL(ata_bmdma_error_handler);
-EXPORT_SYMBOL_GPL(ata_bmdma_post_internal_cmd);
@@ -7850,0 +6235 @@
+EXPORT_SYMBOL_GPL(ata_wait_after_reset);
@@ -7853 +6237,0 @@
-EXPORT_SYMBOL_GPL(ata_bus_reset);
@@ -7855 +6238,0 @@
-EXPORT_SYMBOL_GPL(ata_std_softreset);
@@ -7864,3 +6246,0 @@
-EXPORT_SYMBOL_GPL(ata_busy_sleep);
-EXPORT_SYMBOL_GPL(ata_wait_after_reset);
-EXPORT_SYMBOL_GPL(ata_wait_ready);
@@ -7872 +6251,0 @@
-EXPORT_SYMBOL_GPL(ata_host_intr);
@@ -7895,5 +6273,0 @@
-EXPORT_SYMBOL_GPL(ata_pci_init_sff_host);
-EXPORT_SYMBOL_GPL(ata_pci_init_bmdma);
-EXPORT_SYMBOL_GPL(ata_pci_prepare_sff_host);
-EXPORT_SYMBOL_GPL(ata_pci_activate_sff_host);
-EXPORT_SYMBOL_GPL(ata_pci_init_one);
@@ -7907,2 +6280,0 @@
-EXPORT_SYMBOL_GPL(ata_pci_default_filter);
-EXPORT_SYMBOL_GPL(ata_pci_clear_simplex);
@@ -7911,6 +6282,0 @@
-EXPORT_SYMBOL_GPL(sata_pmp_qc_defer_cmd_switch);
-EXPORT_SYMBOL_GPL(sata_pmp_std_prereset);
-EXPORT_SYMBOL_GPL(sata_pmp_std_hardreset);
-EXPORT_SYMBOL_GPL(sata_pmp_std_postreset);
-EXPORT_SYMBOL_GPL(sata_pmp_do_eh);
-
@@ -7932,0 +6299 @@
+EXPORT_SYMBOL_GPL(ata_eh_analyze_ncq_error);
@@ -7934,2 +6301 @@
-EXPORT_SYMBOL_GPL(ata_irq_on);
-EXPORT_SYMBOL_GPL(ata_dev_try_classify);
+EXPORT_SYMBOL_GPL(ata_std_error_handler);
--- ./projects/linux/linux-2.6.26/drivers/ata/libata-core.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/ata/libata-core.c	2008-10-10 00:13:53.000000000 +0200
@@ -57 +56,0 @@
-#include <linux/jiffies.h>
@@ -107,0 +107 @@
+	unsigned int	lflags;
@@ -124 +124 @@
-int atapi_enabled = 1;
+static int atapi_enabled = 1;
@@ -148 +148 @@
-static int ata_probe_timeout = ATA_TMOUT_INTERNAL / HZ;
+static int ata_probe_timeout;
@@ -200 +200 @@
- *	ata_force_spd_limit - force SATA spd limit according to libata.force
+ *	ata_force_link_limits - force link limits according to libata.force
@@ -203,7 +203,7 @@
- *	Force SATA spd limit according to libata.force and whine about
- *	it.  When only the port part is specified (e.g. 1:), the limit
- *	applies to all links connected to both the host link and all
- *	fan-out ports connected via PMP.  If the device part is
- *	specified as 0 (e.g. 1.00:), it specifies the first fan-out
- *	link not the host link.  Device number 15 always points to the
- *	host link whether PMP is attached or not.
+ *	Force link flags and SATA spd limit according to libata.force
+ *	and whine about it.  When only the port part is specified
+ *	(e.g. 1:), the limit applies to all links connected to both
+ *	the host link and all fan-out ports connected via PMP.  If the
+ *	device part is specified as 0 (e.g. 1.00:), it specifies the
+ *	first fan-out link not the host link.  Device number 15 always
+ *	points to the host link whether PMP is attached or not.
@@ -214 +214 @@
-static void ata_force_spd_limit(struct ata_link *link)
+static void ata_force_link_limits(struct ata_link *link)
@@ -215,0 +216 @@
+	bool did_spd = false;
@@ -232,2 +233,8 @@
-		if (!fe->param.spd_limit)
-			continue;
+		/* only honor the first spd limit */
+		if (!did_spd && fe->param.spd_limit) {
+			link->hw_sata_spd_limit = (1 << fe->param.spd_limit) - 1;
+			ata_link_printk(link, KERN_NOTICE,
+					"FORCE: PHY spd limit set to %s\n",
+					fe->param.name);
+			did_spd = true;
+		}
@@ -235,4 +242,7 @@
-		link->hw_sata_spd_limit = (1 << fe->param.spd_limit) - 1;
-		ata_link_printk(link, KERN_NOTICE,
-			"FORCE: PHY spd limit set to %s\n", fe->param.name);
-		return;
+		/* let lflags stack */
+		if (fe->param.lflags) {
+			link->flags |= fe->param.lflags;
+			ata_link_printk(link, KERN_NOTICE,
+					"FORCE: link flag 0x%x forced -> 0x%x\n",
+					fe->param.lflags, link->flags);
+		}
@@ -1135,0 +1146,2 @@
+	BUG_ON(len & 1);
+
@@ -1169,2 +1180,0 @@
-	WARN_ON(!(len & 1));
-
@@ -1536 +1546 @@
- *	@delay: delay time for workqueue function
+ *	@delay: delay time in msecs for workqueue function
@@ -1555 +1565 @@
-	queue_delayed_work(ata_wq, &ap->port_task, delay);
+	queue_delayed_work(ata_wq, &ap->port_task, msecs_to_jiffies(delay));
@@ -1614,0 +1625 @@
+	int auto_timeout = 0;
@@ -1687,2 +1698,8 @@
-	if (!timeout)
-		timeout = ata_probe_timeout * 1000 / HZ;
+	if (!timeout) {
+		if (ata_probe_timeout)
+			timeout = ata_probe_timeout * 1000;
+		else {
+			timeout = ata_internal_cmd_timeout(dev, command);
+			auto_timeout = 1;
+		}
+	}
@@ -1763,0 +1781,3 @@
+	if ((err_mask & AC_ERR_TIMEOUT) && auto_timeout)
+		ata_internal_cmd_timed_out(dev, command);
+
@@ -1879,0 +1900,17 @@
+ *	ata_do_dev_read_id		-	default ID read method
+ *	@dev: device
+ *	@tf: proposed taskfile
+ *	@id: data buffer
+ *
+ *	Issue the identify taskfile and hand back the buffer containing
+ *	identify data. For some RAID controllers and for pre ATA devices
+ *	this function is wrapped or replaced by the driver
+ */
+unsigned int ata_do_dev_read_id(struct ata_device *dev,
+					struct ata_taskfile *tf, u16 *id)
+{
+	return ata_exec_internal(dev, tf, NULL, DMA_FROM_DEVICE,
+				     id, sizeof(id[0]) * ATA_ID_WORDS, 0);
+}
+
+/**
@@ -1914 +1951 @@
- retry:
+retry:
@@ -1942,2 +1979,5 @@
-	err_mask = ata_exec_internal(dev, &tf, NULL, DMA_FROM_DEVICE,
-				     id, sizeof(id[0]) * ATA_ID_WORDS, 0);
+	if (ap->ops->read_id)
+		err_mask = ap->ops->read_id(dev, &tf, id);
+	else
+		err_mask = ata_do_dev_read_id(dev, &tf, id);
+
@@ -2135,0 +2176,10 @@
+	if ((!atapi_enabled || (ap->flags & ATA_FLAG_NO_ATAPI)) &&
+	    dev->class == ATA_DEV_ATAPI) {
+		ata_dev_printk(dev, KERN_WARNING,
+			"WARNING: ATAPI is %s, device ignored.\n",
+			atapi_enabled ? "not supported with this driver"
+				      : "disabled");
+		ata_dev_disable(dev);
+		return 0;
+	}
+
@@ -3241 +3291 @@
-		if (dev->dma_mode != 0xff)
+		if (ata_dma_enabled(dev))
@@ -3266 +3316 @@
-		if (!ata_dev_enabled(dev) || dev->dma_mode == 0xff)
+		if (!ata_dev_enabled(dev) || !ata_dma_enabled(dev))
@@ -3322 +3372 @@
-	unsigned long nodev_deadline = start + ATA_TMOUT_FF_WAIT;
+	unsigned long nodev_deadline = ata_deadline(start, ATA_TMOUT_FF_WAIT);
@@ -3390 +3440 @@
-	msleep(ATA_WAIT_AFTER_RESET_MSECS);
+	msleep(ATA_WAIT_AFTER_RESET);
@@ -3420,2 +3470,2 @@
-	unsigned long interval_msec = params[0];
-	unsigned long duration = msecs_to_jiffies(params[1]);
+	unsigned long interval = params[0];
+	unsigned long duration = params[1];
@@ -3426 +3476 @@
-	t = jiffies + msecs_to_jiffies(params[2]);
+	t = ata_deadline(jiffies, params[2]);
@@ -3438 +3488 @@
-		msleep(interval_msec);
+		msleep(interval);
@@ -3447 +3497,2 @@
-			if (time_after(jiffies, last_jiffies + duration))
+			if (time_after(jiffies,
+				       ata_deadline(last_jiffies, duration)))
@@ -3639 +3690,2 @@
-			pmp_deadline = jiffies + ATA_TMOUT_PMP_SRST_WAIT;
+			pmp_deadline = ata_deadline(jiffies,
+						    ATA_TMOUT_PMP_SRST_WAIT);
@@ -5150 +5201,0 @@
-	u32 scontrol;
@@ -5154 +5205 @@
-	rc = sata_scr_read(link, SCR_CONTROL, &scontrol);
+	rc = sata_scr_read(link, SCR_CONTROL, &link->saved_scontrol);
@@ -5158 +5209 @@
-	spd = (scontrol >> 4) & 0xf;
+	spd = (link->saved_scontrol >> 4) & 0xf;
@@ -5162 +5213 @@
-	ata_force_spd_limit(link);
+	ata_force_link_limits(link);
@@ -5745 +5796 @@
-	 * to us.  Disable all existing devices.
+	 * to us.  Restore SControl and disable all existing devices.
@@ -5747 +5798,2 @@
-	ata_port_for_each_link(link, ap) {
+	__ata_port_for_each_link(link, ap) {
+		sata_scr_write(link, SCR_CONTROL, link->saved_scontrol);
@@ -5952,0 +6005,3 @@
+		{ "nohrst",	.lflags		= ATA_LFLAG_NO_HRST },
+		{ "nosrst",	.lflags		= ATA_LFLAG_NO_SRST },
+		{ "norst",	.lflags		= ATA_LFLAG_NO_HRST | ATA_LFLAG_NO_SRST },
@@ -6076,2 +6130,0 @@
-	ata_probe_timeout *= HZ;
-
@@ -6082 +6135 @@
-		return -ENOMEM;
+		goto free_force_tbl;
@@ -6085,4 +6138,2 @@
-	if (!ata_aux_wq) {
-		destroy_workqueue(ata_wq);
-		return -ENOMEM;
-	}
+	if (!ata_aux_wq)
+		goto free_wq;
@@ -6091,0 +6143,6 @@
+
+free_wq:
+	destroy_workqueue(ata_wq);
+free_force_tbl:
+	kfree(ata_force_tbl);
+	return -ENOMEM;
@@ -6130,2 +6187,2 @@
- *	@interval_msec: polling interval in milliseconds
- *	@timeout_msec: timeout in milliseconds
+ *	@interval: polling interval in milliseconds
+ *	@timeout: timeout in milliseconds
@@ -6149,2 +6206 @@
-		      unsigned long interval_msec,
-		      unsigned long timeout_msec)
+		      unsigned long interval, unsigned long timeout)
@@ -6152 +6208 @@
-	unsigned long timeout;
+	unsigned long deadline;
@@ -6161 +6217 @@
-	timeout = jiffies + (timeout_msec * HZ) / 1000;
+	deadline = ata_deadline(jiffies, timeout);
@@ -6163,2 +6219,2 @@
-	while ((tmp & mask) == val && time_before(jiffies, timeout)) {
-		msleep(interval_msec);
+	while ((tmp & mask) == val && time_before(jiffies, deadline)) {
+		msleep(interval);
@@ -6263,0 +6320 @@
+EXPORT_SYMBOL_GPL(ata_do_dev_read_id);
--- ./projects/linux/linux-2.6.27/drivers/ata/libata-core.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/ata/libata-core.c	2008-12-25 00:26:37.000000000 +0100
@@ -165,0 +166,61 @@
+/*
+ * Iterator helpers.  Don't use directly.
+ *
+ * LOCKING:
+ * Host lock or EH context.
+ */
+struct ata_link *__ata_port_next_link(struct ata_port *ap,
+				      struct ata_link *link, bool dev_only)
+{
+	/* NULL link indicates start of iteration */
+	if (!link) {
+		if (dev_only && sata_pmp_attached(ap))
+			return ap->pmp_link;
+		return &ap->link;
+	}
+
+	/* we just iterated over the host master link, what's next? */
+	if (link == &ap->link) {
+		if (!sata_pmp_attached(ap)) {
+			if (unlikely(ap->slave_link) && !dev_only)
+				return ap->slave_link;
+			return NULL;
+		}
+		return ap->pmp_link;
+	}
+
+	/* slave_link excludes PMP */
+	if (unlikely(link == ap->slave_link))
+		return NULL;
+
+	/* iterate to the next PMP link */
+	if (++link < ap->pmp_link + ap->nr_pmp_links)
+		return link;
+	return NULL;
+}
+
+/**
+ *	ata_dev_phys_link - find physical link for a device
+ *	@dev: ATA device to look up physical link for
+ *
+ *	Look up physical link which @dev is attached to.  Note that
+ *	this is different from @dev->link only when @dev is on slave
+ *	link.  For all other cases, it's the same as @dev->link.
+ *
+ *	LOCKING:
+ *	Don't care.
+ *
+ *	RETURNS:
+ *	Pointer to the found physical link.
+ */
+struct ata_link *ata_dev_phys_link(struct ata_device *dev)
+{
+	struct ata_port *ap = dev->link->ap;
+
+	if (!ap->slave_link)
+		return dev->link;
+	if (!dev->devno)
+		return &ap->link;
+	return ap->slave_link;
+}
+
@@ -209 +270,2 @@
- *	points to the host link whether PMP is attached or not.
+ *	points to the host link whether PMP is attached or not.  If the
+ *	controller has slave link, device number 16 points to it.
@@ -217 +279,2 @@
-	int linkno, i;
+	int linkno = link->pmp;
+	int i;
@@ -220,3 +283 @@
-		linkno = 15;
-	else
-		linkno = link->pmp;
+		linkno += 15;
@@ -269,3 +330,3 @@
-	/* allow n.15 for the first device attached to host port */
-	if (ata_is_host_link(dev->link) && devno == 0)
-		alt_devno = 15;
+	/* allow n.15/16 for devices attached to host port */
+	if (ata_is_host_link(dev->link))
+		alt_devno += 15;
@@ -323,3 +384,3 @@
-	/* allow n.15 for the first device attached to host port */
-	if (ata_is_host_link(dev->link) && devno == 0)
-		alt_devno = 15;
+	/* allow n.15/16 for devices attached to host port */
+	if (ata_is_host_link(dev->link))
+		alt_devno += 15;
@@ -554 +615 @@
-			block |= tf->hob_lbal << 24;
+			block |= (u64)tf->hob_lbal << 24;
@@ -1210 +1271 @@
-	sectors |= (tf->hob_lbal & 0xff) << 24;
+	sectors |= ((u64)(tf->hob_lbal & 0xff)) << 24;
@@ -1544 +1604,0 @@
- *	@fn: workqueue function to be scheduled
@@ -2102,0 +2163,4 @@
+
+	if (ata_dev_blacklisted(dev) & ATA_HORKAGE_BRIDGE_OK)
+		return 0;
+
@@ -2430,0 +2495,7 @@
+	if ((dev->horkage & ATA_HORKAGE_FIRMWARE_WARN) && print_info) {
+		ata_dev_printk(dev, KERN_WARNING, "WARNING: device requires "
+			       "firmware update to be fully functional.\n");
+		ata_dev_printk(dev, KERN_WARNING, "         contact the vendor "
+			       "or visit http://ata.wiki.kernel.org.\n");
+	}
+
@@ -2684 +2755 @@
-	if (ata_link_online(link)) {
+	if (ata_phys_link_online(link)) {
@@ -3374,0 +3446,6 @@
+	/* Slave readiness can't be tested separately from master.  On
+	 * M/S emulation configuration, this function should be called
+	 * only on the master and it will handle both master and slave.
+	 */
+	WARN_ON(link == link->ap->slave_link);
+
@@ -3596 +3673 @@
-	if (ata_link_offline(link))
+	if (ata_phys_link_offline(link))
@@ -3674 +3751 @@
-	if (ata_link_offline(link))
+	if (ata_phys_link_offline(link))
@@ -3958,0 +4036 @@
+	{ "QUANTUM DAT    DAT72-000", NULL,	ATA_HORKAGE_ATAPI_MOD16_DMA },
@@ -3973,0 +4052,67 @@
+	/* Seagate NCQ + FLUSH CACHE firmware bug */
+	{ "ST31500341AS",	"SD15",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST31500341AS",	"SD16",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST31500341AS",	"SD17",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST31500341AS",	"SD18",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST31500341AS",	"SD19",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+
+	{ "ST31000333AS",	"SD15",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST31000333AS",	"SD16",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST31000333AS",	"SD17",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST31000333AS",	"SD18",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST31000333AS",	"SD19",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+
+	{ "ST3640623AS",	"SD15",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3640623AS",	"SD16",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3640623AS",	"SD17",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3640623AS",	"SD18",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3640623AS",	"SD19",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+
+	{ "ST3640323AS",	"SD15",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3640323AS",	"SD16",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3640323AS",	"SD17",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3640323AS",	"SD18",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3640323AS",	"SD19",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+
+	{ "ST3320813AS",	"SD15",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3320813AS",	"SD16",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3320813AS",	"SD17",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3320813AS",	"SD18",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3320813AS",	"SD19",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+
+	{ "ST3320613AS",	"SD15",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3320613AS",	"SD16",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3320613AS",	"SD17",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3320613AS",	"SD18",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+	{ "ST3320613AS",	"SD19",		ATA_HORKAGE_NONCQ |
+						ATA_HORKAGE_FIRMWARE_WARN },
+
@@ -4000,0 +4146,3 @@
+	/* Devices that do not need bridging limits applied */
+	{ "MTRON MSP-SATA*",		NULL,	ATA_HORKAGE_BRIDGE_OK, },
+
@@ -4094 +4242 @@
-	/* If the controller thinks we are 40 wire, we are */
+	/* If the controller thinks we are 40 wire, we are. */
@@ -4097 +4245,2 @@
-	/* If the controller thinks we are 80 wire, we are */
+
+	/* If the controller thinks we are 80 wire, we are. */
@@ -4100,2 +4249,5 @@
-	/* If the system is known to be 40 wire short cable (eg laptop),
-	   then we allow 80 wire modes even if the drive isn't sure */
+
+	/* If the system is known to be 40 wire short cable (eg
+	 * laptop), then we allow 80 wire modes even if the drive
+	 * isn't sure.
+	 */
@@ -4104 +4255,0 @@
-	/* If the controller doesn't know we scan
@@ -4106,8 +4257,9 @@
-	   - Note: We look for all 40 wire detects at this point.
-	     Any 80 wire detect is taken to be 80 wire cable
-	     because
-	     - In many setups only the one drive (slave if present)
-               will give a valid detect
-             - If you have a non detect capable drive you don't
-               want it to colour the choice
-        */
+	/* If the controller doesn't know, we scan.
+	 *
+	 * Note: We look for all 40 wire detects at this point.  Any
+	 *       80 wire detect is taken to be 80 wire cable because
+	 * - in many setups only the one drive (slave if present) will
+	 *   give a valid detect
+	 * - if you have a non detect capable drive you don't want it
+	 *   to colour the choice
+	 */
@@ -4116 +4268 @@
-			if (!ata_is_40wire(dev))
+			if (ata_dev_enabled(dev) && !ata_is_40wire(dev))
@@ -4372 +4524,2 @@
-	if (unlikely(qc->nbytes & 15))
+	if (!(qc->dev->horkage & ATA_HORKAGE_ATAPI_MOD16_DMA) &&
+	    unlikely(qc->nbytes & 15))
@@ -4521,0 +4675 @@
+ *	@tag: command tag
@@ -4633 +4786,0 @@
- *	@err_mask: ATA Status register contents
@@ -4871,2 +5023,0 @@
-		struct ata_port *ap = link->ap;
-
@@ -4874 +5025 @@
-			return ap->ops->scr_read(ap, reg, val);
+			return link->ap->ops->scr_read(link, reg, val);
@@ -4900,2 +5050,0 @@
-		struct ata_port *ap = link->ap;
-
@@ -4903 +5052 @@
-			return ap->ops->scr_write(ap, reg, val);
+			return link->ap->ops->scr_write(link, reg, val);
@@ -4928 +5076,0 @@
-		struct ata_port *ap = link->ap;
@@ -4932 +5080 @@
-			rc = ap->ops->scr_write(ap, reg, val);
+			rc = link->ap->ops->scr_write(link, reg, val);
@@ -4934 +5082 @@
-				rc = ap->ops->scr_read(ap, reg, &val);
+				rc = link->ap->ops->scr_read(link, reg, &val);
@@ -4944 +5092 @@
- *	ata_link_online - test whether the given link is online
+ *	ata_phys_link_online - test whether the given link is online
@@ -4955 +5103 @@
- *	1 if the port online status is available and online.
+ *	True if the port online status is available and online.
@@ -4957 +5105 @@
-int ata_link_online(struct ata_link *link)
+bool ata_phys_link_online(struct ata_link *link)
@@ -4963,2 +5111,2 @@
-		return 1;
-	return 0;
+		return true;
+	return false;
@@ -4968 +5116 @@
- *	ata_link_offline - test whether the given link is offline
+ *	ata_phys_link_offline - test whether the given link is offline
@@ -4979 +5127 @@
- *	1 if the port offline status is available and offline.
+ *	True if the port offline status is available and offline.
@@ -4981 +5129 @@
-int ata_link_offline(struct ata_link *link)
+bool ata_phys_link_offline(struct ata_link *link)
@@ -4987,2 +5135,54 @@
-		return 1;
-	return 0;
+		return true;
+	return false;
+}
+
+/**
+ *	ata_link_online - test whether the given link is online
+ *	@link: ATA link to test
+ *
+ *	Test whether @link is online.  This is identical to
+ *	ata_phys_link_online() when there's no slave link.  When
+ *	there's a slave link, this function should only be called on
+ *	the master link and will return true if any of M/S links is
+ *	online.
+ *
+ *	LOCKING:
+ *	None.
+ *
+ *	RETURNS:
+ *	True if the port online status is available and online.
+ */
+bool ata_link_online(struct ata_link *link)
+{
+	struct ata_link *slave = link->ap->slave_link;
+
+	WARN_ON(link == slave);	/* shouldn't be called on slave link */
+
+	return ata_phys_link_online(link) ||
+		(slave && ata_phys_link_online(slave));
+}
+
+/**
+ *	ata_link_offline - test whether the given link is offline
+ *	@link: ATA link to test
+ *
+ *	Test whether @link is offline.  This is identical to
+ *	ata_phys_link_offline() when there's no slave link.  When
+ *	there's a slave link, this function should only be called on
+ *	the master link and will return true if both M/S links are
+ *	offline.
+ *
+ *	LOCKING:
+ *	None.
+ *
+ *	RETURNS:
+ *	True if the port offline status is available and offline.
+ */
+bool ata_link_offline(struct ata_link *link)
+{
+	struct ata_link *slave = link->ap->slave_link;
+
+	WARN_ON(link == slave);	/* shouldn't be called on slave link */
+
+	return ata_phys_link_offline(link) &&
+		(!slave || ata_phys_link_offline(slave));
@@ -5130 +5330 @@
-	struct ata_link *link = dev->link;
+	struct ata_link *link = ata_dev_phys_link(dev);
@@ -5134 +5334 @@
-	/* SATA spd limit is bound to the first device */
+	/* SATA spd limit is bound to the attached device, reset together */
@@ -5261,0 +5462,2 @@
+#else
+	INIT_DELAYED_WORK(&ap->port_task, NULL);
@@ -5266,0 +5469 @@
+	init_completion(&ap->park_req_pending);
@@ -5296,0 +5500 @@
+		kfree(ap->slave_link);
@@ -5416,0 +5621,62 @@
+/**
+ *	ata_slave_link_init - initialize slave link
+ *	@ap: port to initialize slave link for
+ *
+ *	Create and initialize slave link for @ap.  This enables slave
+ *	link handling on the port.
+ *
+ *	In libata, a port contains links and a link contains devices.
+ *	There is single host link but if a PMP is attached to it,
+ *	there can be multiple fan-out links.  On SATA, there's usually
+ *	a single device connected to a link but PATA and SATA
+ *	controllers emulating TF based interface can have two - master
+ *	and slave.
+ *
+ *	However, there are a few controllers which don't fit into this
+ *	abstraction too well - SATA controllers which emulate TF
+ *	interface with both master and slave devices but also have
+ *	separate SCR register sets for each device.  These controllers
+ *	need separate links for physical link handling
+ *	(e.g. onlineness, link speed) but should be treated like a
+ *	traditional M/S controller for everything else (e.g. command
+ *	issue, softreset).
+ *
+ *	slave_link is libata's way of handling this class of
+ *	controllers without impacting core layer too much.  For
+ *	anything other than physical link handling, the default host
+ *	link is used for both master and slave.  For physical link
+ *	handling, separate @ap->slave_link is used.  All dirty details
+ *	are implemented inside libata core layer.  From LLD's POV, the
+ *	only difference is that prereset, hardreset and postreset are
+ *	called once more for the slave link, so the reset sequence
+ *	looks like the following.
+ *
+ *	prereset(M) -> prereset(S) -> hardreset(M) -> hardreset(S) ->
+ *	softreset(M) -> postreset(M) -> postreset(S)
+ *
+ *	Note that softreset is called only for the master.  Softreset
+ *	resets both M/S by definition, so SRST on master should handle
+ *	both (the standard method will work just fine).
+ *
+ *	LOCKING:
+ *	Should be called before host is registered.
+ *
+ *	RETURNS:
+ *	0 on success, -errno on failure.
+ */
+int ata_slave_link_init(struct ata_port *ap)
+{
+	struct ata_link *link;
+
+	WARN_ON(ap->slave_link);
+	WARN_ON(ap->flags & ATA_FLAG_PMP);
+
+	link = kzalloc(sizeof(*link), GFP_KERNEL);
+	if (!link)
+		return -ENOMEM;
+
+	ata_link_init(ap, link, 1);
+	ap->slave_link = link;
+	return 0;
+}
+
@@ -5642,0 +5909,2 @@
+		if (ap->slave_link)
+			sata_link_init_spd(ap->slave_link);
@@ -5799 +6067 @@
-		sata_scr_write(link, SCR_CONTROL, link->saved_scontrol);
+		sata_scr_write(link, SCR_CONTROL, link->saved_scontrol & 0xff0);
@@ -6262,0 +6531 @@
+EXPORT_SYMBOL_GPL(__ata_port_next_link);
@@ -6266,0 +6536 @@
+EXPORT_SYMBOL_GPL(ata_slave_link_init);
--- ./projects/linux/linux-2.6.28/drivers/ata/libata-core.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/ata/libata-core.c	2009-03-24 00:12:14.000000000 +0100
@@ -58,0 +59 @@
+#include <linux/async.h>
@@ -166,2 +167,10 @@
-/*
- * Iterator helpers.  Don't use directly.
+static bool ata_sstatus_online(u32 sstatus)
+{
+	return (sstatus & 0xf) == 0x3;
+}
+
+/**
+ *	ata_link_next - link iteration helper
+ *	@link: the previous link, NULL to start
+ *	@ap: ATA port containing links to iterate
+ *	@mode: iteration mode, one of ATA_LITER_*
@@ -169,2 +178,5 @@
- * LOCKING:
- * Host lock or EH context.
+ *	LOCKING:
+ *	Host lock or EH context.
+ *
+ *	RETURNS:
+ *	Pointer to the next link.
@@ -172,2 +184,2 @@
-struct ata_link *__ata_port_next_link(struct ata_port *ap,
-				      struct ata_link *link, bool dev_only)
+struct ata_link *ata_link_next(struct ata_link *link, struct ata_port *ap,
+			       enum ata_link_iter_mode mode)
@@ -174,0 +187,3 @@
+	BUG_ON(mode != ATA_LITER_EDGE &&
+	       mode != ATA_LITER_PMP_FIRST && mode != ATA_LITER_HOST_FIRST);
+
@@ -176,5 +191,10 @@
-	if (!link) {
-		if (dev_only && sata_pmp_attached(ap))
-			return ap->pmp_link;
-		return &ap->link;
-	}
+	if (!link)
+		switch (mode) {
+		case ATA_LITER_EDGE:
+		case ATA_LITER_PMP_FIRST:
+			if (sata_pmp_attached(ap))
+				return ap->pmp_link;
+			/* fall through */
+		case ATA_LITER_HOST_FIRST:
+			return &ap->link;
+		}
@@ -182,4 +202,9 @@
-	/* we just iterated over the host master link, what's next? */
-	if (link == &ap->link) {
-		if (!sata_pmp_attached(ap)) {
-			if (unlikely(ap->slave_link) && !dev_only)
+	/* we just iterated over the host link, what's next? */
+	if (link == &ap->link)
+		switch (mode) {
+		case ATA_LITER_HOST_FIRST:
+			if (sata_pmp_attached(ap))
+				return ap->pmp_link;
+			/* fall through */
+		case ATA_LITER_PMP_FIRST:
+			if (unlikely(ap->slave_link))
@@ -186,0 +212,2 @@
+			/* fall through */
+		case ATA_LITER_EDGE:
@@ -189,2 +215,0 @@
-		return ap->pmp_link;
-	}
@@ -196 +221 @@
-	/* iterate to the next PMP link */
+	/* we were over a PMP link */
@@ -198,0 +224,4 @@
+
+	if (mode == ATA_LITER_PMP_FIRST)
+		return &ap->link;
+
@@ -202,0 +232,53 @@
+ *	ata_dev_next - device iteration helper
+ *	@dev: the previous device, NULL to start
+ *	@link: ATA link containing devices to iterate
+ *	@mode: iteration mode, one of ATA_DITER_*
+ *
+ *	LOCKING:
+ *	Host lock or EH context.
+ *
+ *	RETURNS:
+ *	Pointer to the next device.
+ */
+struct ata_device *ata_dev_next(struct ata_device *dev, struct ata_link *link,
+				enum ata_dev_iter_mode mode)
+{
+	BUG_ON(mode != ATA_DITER_ENABLED && mode != ATA_DITER_ENABLED_REVERSE &&
+	       mode != ATA_DITER_ALL && mode != ATA_DITER_ALL_REVERSE);
+
+	/* NULL dev indicates start of iteration */
+	if (!dev)
+		switch (mode) {
+		case ATA_DITER_ENABLED:
+		case ATA_DITER_ALL:
+			dev = link->device;
+			goto check;
+		case ATA_DITER_ENABLED_REVERSE:
+		case ATA_DITER_ALL_REVERSE:
+			dev = link->device + ata_link_max_devices(link) - 1;
+			goto check;
+		}
+
+ next:
+	/* move to the next one */
+	switch (mode) {
+	case ATA_DITER_ENABLED:
+	case ATA_DITER_ALL:
+		if (++dev < link->device + ata_link_max_devices(link))
+			goto check;
+		return NULL;
+	case ATA_DITER_ENABLED_REVERSE:
+	case ATA_DITER_ALL_REVERSE:
+		if (--dev >= link->device)
+			goto check;
+		return NULL;
+	}
+
+ check:
+	if ((mode == ATA_DITER_ENABLED || mode == ATA_DITER_ENABLED_REVERSE) &&
+	    !ata_dev_enabled(dev))
+		goto next;
+	return dev;
+}
+
+/**
@@ -932,0 +1015 @@
+		"6.0 Gbps",
@@ -940,12 +1022,0 @@
-void ata_dev_disable(struct ata_device *dev)
-{
-	if (ata_dev_enabled(dev)) {
-		if (ata_msg_drv(dev->link->ap))
-			ata_dev_printk(dev, KERN_WARNING, "disabled\n");
-		ata_acpi_on_disable(dev);
-		ata_down_xfermask_limit(dev, ATA_DNXFER_FORCE_PIO0 |
-					     ATA_DNXFER_QUIET);
-		dev->class++;
-	}
-}
-
@@ -1110,2 +1181,2 @@
-		ata_port_for_each_link(link, ap) {
-			ata_link_for_each_dev(dev, link)
+		ata_for_each_link(link, ap, EDGE) {
+			ata_for_each_dev(dev, link, ALL)
@@ -1254 +1325 @@
-			return ata_id_u64(id, 100);
+			return ata_id_u64(id, ATA_ID_LBA_CAPACITY_2);
@@ -1256 +1327 @@
-			return ata_id_u32(id, 60);
+			return ata_id_u32(id, ATA_ID_LBA_CAPACITY);
@@ -1259 +1330,2 @@
-			return ata_id_u32(id, 57);
+			return id[ATA_ID_CUR_CYLS] * id[ATA_ID_CUR_HEADS] *
+			       id[ATA_ID_CUR_SECTORS];
@@ -1261 +1333,2 @@
-			return id[1] * id[3] * id[6];
+			return id[ATA_ID_CYLS] * id[ATA_ID_HEADS] *
+			       id[ATA_ID_SECTORS];
@@ -1925,0 +1999,4 @@
+	/* CF spec. r4.1 Table 22 says no iordy on PIO5 and PIO6.  */
+	if (ata_id_is_cfa(adev->id)
+	    && (adev->pio_mode == XFER_PIO_5 || adev->pio_mode == XFER_PIO_6))
+		return 0;
@@ -2159,0 +2237,34 @@
+static int ata_do_link_spd_horkage(struct ata_device *dev)
+{
+	struct ata_link *plink = ata_dev_phys_link(dev);
+	u32 target, target_limit;
+
+	if (!sata_scr_valid(plink))
+		return 0;
+
+	if (dev->horkage & ATA_HORKAGE_1_5_GBPS)
+		target = 1;
+	else
+		return 0;
+
+	target_limit = (1 << target) - 1;
+
+	/* if already on stricter limit, no need to push further */
+	if (plink->sata_spd_limit <= target_limit)
+		return 0;
+
+	plink->sata_spd_limit = target_limit;
+
+	/* Request another EH round by returning -EAGAIN if link is
+	 * going faster than the target speed.  Forward progress is
+	 * guaranteed by setting sata_spd_limit to target_limit above.
+	 */
+	if (plink->sata_spd > target) {
+		ata_dev_printk(dev, KERN_INFO,
+			       "applying link speed limit horkage to %s\n",
+			       sata_spd_string(target));
+		return -EAGAIN;
+	}
+	return 0;
+}
+
@@ -2249,0 +2361,4 @@
+	rc = ata_do_link_spd_horkage(dev);
+	if (rc)
+		return rc;
+
@@ -2597 +2712 @@
-	ata_link_for_each_dev(dev, &ap->link)
+	ata_for_each_dev(dev, &ap->link, ALL)
@@ -2601 +2716 @@
-	ata_link_for_each_dev(dev, &ap->link) {
+	ata_for_each_dev(dev, &ap->link, ALL) {
@@ -2623 +2738 @@
-	ata_link_for_each_dev(dev, &ap->link) {
+	ata_for_each_dev(dev, &ap->link, ALL) {
@@ -2639 +2754 @@
-	ata_link_for_each_dev_reverse(dev, &ap->link) {
+	ata_for_each_dev(dev, &ap->link, ALL_REVERSE) {
@@ -2656,7 +2771,6 @@
-	/* We may have SATA bridge glue hiding here irrespective of the
-	   reported cable types and sensed types */
-	ata_link_for_each_dev(dev, &ap->link) {
-		if (!ata_dev_enabled(dev))
-			continue;
-		/* SATA drives indicate we have a bridge. We don't know which
-		   end of the link the bridge is which is a problem */
+	/* We may have SATA bridge glue hiding here irrespective of
+	 * the reported cable types and sensed types.  When SATA
+	 * drives indicate we have a bridge, we don't know which end
+	 * of the link the bridge is which is a problem.
+	 */
+	ata_for_each_dev(dev, &ap->link, ENABLED)
@@ -2665 +2778,0 @@
-	}
@@ -2670,4 +2783 @@
-	ata_link_for_each_dev(dev, &ap->link) {
-		if (!ata_dev_enabled(dev))
-			continue;
-
+	ata_for_each_dev(dev, &ap->link, ENABLED) {
@@ -2686,3 +2796,2 @@
-	ata_link_for_each_dev(dev, &ap->link)
-		if (ata_dev_enabled(dev))
-			return 0;
+	ata_for_each_dev(dev, &ap->link, ENABLED)
+		return 0;
@@ -2711 +2820 @@
-			sata_down_spd_limit(&ap->link);
+			sata_down_spd_limit(&ap->link, 0);
@@ -2806,0 +2916 @@
+ *	@spd_limit: Additional limit
@@ -2811,0 +2922,5 @@
+ *	If @spd_limit is non-zero, the speed is limited to equal to or
+ *	lower than @spd_limit if such speed is supported.  If
+ *	@spd_limit is slower than any supported speed, only the lowest
+ *	supported speed is allowed.
+ *
@@ -2818 +2933 @@
-int sata_down_spd_limit(struct ata_link *link)
+int sata_down_spd_limit(struct ata_link *link, u32 spd_limit)
@@ -2821 +2936 @@
-	int rc, highbit;
+	int rc, bit;
@@ -2830 +2945 @@
-	if (rc == 0)
+	if (rc == 0 && ata_sstatus_online(sstatus))
@@ -2840,2 +2955,2 @@
-	highbit = fls(mask) - 1;
-	mask &= ~(1 << highbit);
+	bit = fls(mask) - 1;
+	mask &= ~(1 << bit);
@@ -2854,0 +2970,9 @@
+	if (spd_limit) {
+		if (mask & ((1 << spd_limit) - 1))
+			mask &= (1 << spd_limit) - 1;
+		else {
+			bit = ffs(mask) - 1;
+			mask = 1 << bit;
+		}
+	}
+
@@ -2956,27 +3080,27 @@
-/*	{ XFER_PIO_SLOW, 120, 290, 240, 960, 290, 240, 960,   0 }, */
-	{ XFER_PIO_0,     70, 290, 240, 600, 165, 150, 600,   0 },
-	{ XFER_PIO_1,     50, 290,  93, 383, 125, 100, 383,   0 },
-	{ XFER_PIO_2,     30, 290,  40, 330, 100,  90, 240,   0 },
-	{ XFER_PIO_3,     30,  80,  70, 180,  80,  70, 180,   0 },
-	{ XFER_PIO_4,     25,  70,  25, 120,  70,  25, 120,   0 },
-	{ XFER_PIO_5,     15,  65,  25, 100,  65,  25, 100,   0 },
-	{ XFER_PIO_6,     10,  55,  20,  80,  55,  20,  80,   0 },
-
-	{ XFER_SW_DMA_0, 120,   0,   0,   0, 480, 480, 960,   0 },
-	{ XFER_SW_DMA_1,  90,   0,   0,   0, 240, 240, 480,   0 },
-	{ XFER_SW_DMA_2,  60,   0,   0,   0, 120, 120, 240,   0 },
-
-	{ XFER_MW_DMA_0,  60,   0,   0,   0, 215, 215, 480,   0 },
-	{ XFER_MW_DMA_1,  45,   0,   0,   0,  80,  50, 150,   0 },
-	{ XFER_MW_DMA_2,  25,   0,   0,   0,  70,  25, 120,   0 },
-	{ XFER_MW_DMA_3,  25,   0,   0,   0,  65,  25, 100,   0 },
-	{ XFER_MW_DMA_4,  25,   0,   0,   0,  55,  20,  80,   0 },
-
-/*	{ XFER_UDMA_SLOW,  0,   0,   0,   0,   0,   0,   0, 150 }, */
-	{ XFER_UDMA_0,     0,   0,   0,   0,   0,   0,   0, 120 },
-	{ XFER_UDMA_1,     0,   0,   0,   0,   0,   0,   0,  80 },
-	{ XFER_UDMA_2,     0,   0,   0,   0,   0,   0,   0,  60 },
-	{ XFER_UDMA_3,     0,   0,   0,   0,   0,   0,   0,  45 },
-	{ XFER_UDMA_4,     0,   0,   0,   0,   0,   0,   0,  30 },
-	{ XFER_UDMA_5,     0,   0,   0,   0,   0,   0,   0,  20 },
-	{ XFER_UDMA_6,     0,   0,   0,   0,   0,   0,   0,  15 },
+/*	{ XFER_PIO_SLOW, 120, 290, 240, 960, 290, 240, 0,  960,   0 }, */
+	{ XFER_PIO_0,     70, 290, 240, 600, 165, 150, 0,  600,   0 },
+	{ XFER_PIO_1,     50, 290,  93, 383, 125, 100, 0,  383,   0 },
+	{ XFER_PIO_2,     30, 290,  40, 330, 100,  90, 0,  240,   0 },
+	{ XFER_PIO_3,     30,  80,  70, 180,  80,  70, 0,  180,   0 },
+	{ XFER_PIO_4,     25,  70,  25, 120,  70,  25, 0,  120,   0 },
+	{ XFER_PIO_5,     15,  65,  25, 100,  65,  25, 0,  100,   0 },
+	{ XFER_PIO_6,     10,  55,  20,  80,  55,  20, 0,   80,   0 },
+
+	{ XFER_SW_DMA_0, 120,   0,   0,   0, 480, 480, 50, 960,   0 },
+	{ XFER_SW_DMA_1,  90,   0,   0,   0, 240, 240, 30, 480,   0 },
+	{ XFER_SW_DMA_2,  60,   0,   0,   0, 120, 120, 20, 240,   0 },
+
+	{ XFER_MW_DMA_0,  60,   0,   0,   0, 215, 215, 20, 480,   0 },
+	{ XFER_MW_DMA_1,  45,   0,   0,   0,  80,  50, 5,  150,   0 },
+	{ XFER_MW_DMA_2,  25,   0,   0,   0,  70,  25, 5,  120,   0 },
+	{ XFER_MW_DMA_3,  25,   0,   0,   0,  65,  25, 5,  100,   0 },
+	{ XFER_MW_DMA_4,  25,   0,   0,   0,  55,  20, 5,   80,   0 },
+
+/*	{ XFER_UDMA_SLOW,  0,   0,   0,   0,   0,   0, 0,    0, 150 }, */
+	{ XFER_UDMA_0,     0,   0,   0,   0,   0,   0, 0,    0, 120 },
+	{ XFER_UDMA_1,     0,   0,   0,   0,   0,   0, 0,    0,  80 },
+	{ XFER_UDMA_2,     0,   0,   0,   0,   0,   0, 0,    0,  60 },
+	{ XFER_UDMA_3,     0,   0,   0,   0,   0,   0, 0,    0,  45 },
+	{ XFER_UDMA_4,     0,   0,   0,   0,   0,   0, 0,    0,  30 },
+	{ XFER_UDMA_5,     0,   0,   0,   0,   0,   0, 0,    0,  20 },
+	{ XFER_UDMA_6,     0,   0,   0,   0,   0,   0, 0,    0,  15 },
@@ -2992,8 +3116,9 @@
-	q->setup   = EZ(t->setup   * 1000,  T);
-	q->act8b   = EZ(t->act8b   * 1000,  T);
-	q->rec8b   = EZ(t->rec8b   * 1000,  T);
-	q->cyc8b   = EZ(t->cyc8b   * 1000,  T);
-	q->active  = EZ(t->active  * 1000,  T);
-	q->recover = EZ(t->recover * 1000,  T);
-	q->cycle   = EZ(t->cycle   * 1000,  T);
-	q->udma    = EZ(t->udma    * 1000, UT);
+	q->setup	= EZ(t->setup      * 1000,  T);
+	q->act8b	= EZ(t->act8b      * 1000,  T);
+	q->rec8b	= EZ(t->rec8b      * 1000,  T);
+	q->cyc8b	= EZ(t->cyc8b      * 1000,  T);
+	q->active	= EZ(t->active     * 1000,  T);
+	q->recover	= EZ(t->recover    * 1000,  T);
+	q->dmack_hold	= EZ(t->dmack_hold * 1000,  T);
+	q->cycle	= EZ(t->cycle      * 1000,  T);
+	q->udma		= EZ(t->udma       * 1000, UT);
@@ -3010,0 +3136 @@
+	if (what & ATA_TIMING_DMACK_HOLD) m->dmack_hold = max(a->dmack_hold, b->dmack_hold);
@@ -3334 +3460 @@
-	ata_link_for_each_dev(dev, link) {
+	ata_for_each_dev(dev, link, ENABLED) {
@@ -3338,3 +3463,0 @@
-		if (!ata_dev_enabled(dev))
-			continue;
-
@@ -3369,4 +3492 @@
-	ata_link_for_each_dev(dev, link) {
-		if (!ata_dev_enabled(dev))
-			continue;
-
+	ata_for_each_dev(dev, link, ENABLED) {
@@ -3386,2 +3506,2 @@
-	ata_link_for_each_dev(dev, link) {
-		if (!ata_dev_enabled(dev) || !ata_dma_enabled(dev))
+	ata_for_each_dev(dev, link, ENABLED) {
+		if (!ata_dma_enabled(dev))
@@ -3397,5 +3517 @@
-	ata_link_for_each_dev(dev, link) {
-		/* don't update suspended devices' xfer mode */
-		if (!ata_dev_enabled(dev))
-			continue;
-
+	ata_for_each_dev(dev, link, ENABLED) {
@@ -4050,0 +4167 @@
+	{ "OCZ CORE_SSD",	"02.10104",	ATA_HORKAGE_NONCQ },
@@ -4148,0 +4266,3 @@
+	/* Devices which aren't very happy with higher link speeds */
+	{ "WD My Book",			NULL,	ATA_HORKAGE_1_5_GBPS, },
+
@@ -4266,3 +4386,3 @@
-	ata_port_for_each_link(link, ap) {
-		ata_link_for_each_dev(dev, link) {
-			if (ata_dev_enabled(dev) && !ata_is_40wire(dev))
+	ata_for_each_link(link, ap, EDGE) {
+		ata_for_each_dev(dev, link, ENABLED) {
+			if (!ata_is_40wire(dev))
@@ -4492 +4612 @@
-	WARN_ON(sg == NULL);
+	WARN_ON_ONCE(sg == NULL);
@@ -4497 +4617 @@
-		dma_unmap_sg(ap->dev, sg, qc->n_elem, dir);
+		dma_unmap_sg(ap->dev, sg, qc->orig_n_elem, dir);
@@ -4612 +4732 @@
-
+	qc->orig_n_elem = qc->n_elem;
@@ -4643,2 +4763 @@
- *	@ap: Port associated with device @dev
- *	@dev: Device from whom we request an available command structure
+ *	@ap: target port
@@ -4675 +4793,0 @@
- *	@tag: command tag
@@ -4713 +4831 @@
-	WARN_ON(qc == NULL);	/* ata_qc_from_tag _might_ return NULL */
+	WARN_ON_ONCE(qc == NULL); /* ata_qc_from_tag _might_ return NULL */
@@ -4728,2 +4846,2 @@
-	WARN_ON(qc == NULL);	/* ata_qc_from_tag _might_ return NULL */
-	WARN_ON(!(qc->flags & ATA_QCFLAG_ACTIVE));
+	WARN_ON_ONCE(qc == NULL); /* ata_qc_from_tag _might_ return NULL */
+	WARN_ON_ONCE(!(qc->flags & ATA_QCFLAG_ACTIVE));
@@ -4815 +4933 @@
-		WARN_ON(ap->pflags & ATA_PFLAG_FROZEN);
+		WARN_ON_ONCE(ap->pflags & ATA_PFLAG_FROZEN);
@@ -4937 +5055 @@
-	WARN_ON(ap->ops->error_handler && ata_tag_valid(link->active_tag));
+	WARN_ON_ONCE(ap->ops->error_handler && ata_tag_valid(link->active_tag));
@@ -4940 +5058 @@
-		WARN_ON(link->sactive & (1 << qc->tag));
+		WARN_ON_ONCE(link->sactive & (1 << qc->tag));
@@ -4946 +5064 @@
-		WARN_ON(link->sactive);
+		WARN_ON_ONCE(link->sactive);
@@ -5110 +5228 @@
-	    (sstatus & 0xf) == 0x3)
+	    ata_sstatus_online(sstatus))
@@ -5134 +5252 @@
-	    (sstatus & 0xf) != 0x3)
+	    !ata_sstatus_online(sstatus))
@@ -5221 +5339 @@
-		__ata_port_for_each_link(link, ap) {
+		ata_for_each_link(link, ap, HOST_FIRST) {
@@ -5347,2 +5465,2 @@
-	memset((void *)dev + ATA_DEVICE_CLEAR_OFFSET, 0,
-	       sizeof(*dev) - ATA_DEVICE_CLEAR_OFFSET);
+	memset((void *)dev + ATA_DEVICE_CLEAR_BEGIN, 0,
+	       ATA_DEVICE_CLEAR_END - ATA_DEVICE_CLEAR_BEGIN);
@@ -5851,0 +5970,59 @@
+
+static void async_port_probe(void *data, async_cookie_t cookie)
+{
+	int rc;
+	struct ata_port *ap = data;
+
+	/*
+	 * If we're not allowed to scan this host in parallel,
+	 * we need to wait until all previous scans have completed
+	 * before going further.
+	 * Jeff Garzik says this is only within a controller, so we
+	 * don't need to wait for port 0, only for later ports.
+	 */
+	if (!(ap->host->flags & ATA_HOST_PARALLEL_SCAN) && ap->port_no != 0)
+		async_synchronize_cookie(cookie);
+
+	/* probe */
+	if (ap->ops->error_handler) {
+		struct ata_eh_info *ehi = &ap->link.eh_info;
+		unsigned long flags;
+
+		ata_port_probe(ap);
+
+		/* kick EH for boot probing */
+		spin_lock_irqsave(ap->lock, flags);
+
+		ehi->probe_mask |= ATA_ALL_DEVICES;
+		ehi->action |= ATA_EH_RESET | ATA_EH_LPM;
+		ehi->flags |= ATA_EHI_NO_AUTOPSY | ATA_EHI_QUIET;
+
+		ap->pflags &= ~ATA_PFLAG_INITIALIZING;
+		ap->pflags |= ATA_PFLAG_LOADING;
+		ata_port_schedule_eh(ap);
+
+		spin_unlock_irqrestore(ap->lock, flags);
+
+		/* wait for EH to finish */
+		ata_port_wait_eh(ap);
+	} else {
+		DPRINTK("ata%u: bus probe begin\n", ap->print_id);
+		rc = ata_bus_probe(ap);
+		DPRINTK("ata%u: bus probe end\n", ap->print_id);
+
+		if (rc) {
+			/* FIXME: do something useful here?
+			 * Current libata behavior will
+			 * tear down everything when
+			 * the module is removed
+			 * or the h/w is unplugged.
+			 */
+		}
+	}
+
+	/* in order to keep device order, we need to synchronize at this point */
+	async_synchronize_cookie(cookie);
+
+	ata_scsi_scan_host(ap, 1);
+
+}
@@ -5931,45 +6108 @@
-
-		/* probe */
-		if (ap->ops->error_handler) {
-			struct ata_eh_info *ehi = &ap->link.eh_info;
-			unsigned long flags;
-
-			ata_port_probe(ap);
-
-			/* kick EH for boot probing */
-			spin_lock_irqsave(ap->lock, flags);
-
-			ehi->probe_mask |= ATA_ALL_DEVICES;
-			ehi->action |= ATA_EH_RESET | ATA_EH_LPM;
-			ehi->flags |= ATA_EHI_NO_AUTOPSY | ATA_EHI_QUIET;
-
-			ap->pflags &= ~ATA_PFLAG_INITIALIZING;
-			ap->pflags |= ATA_PFLAG_LOADING;
-			ata_port_schedule_eh(ap);
-
-			spin_unlock_irqrestore(ap->lock, flags);
-
-			/* wait for EH to finish */
-			ata_port_wait_eh(ap);
-		} else {
-			DPRINTK("ata%u: bus probe begin\n", ap->print_id);
-			rc = ata_bus_probe(ap);
-			DPRINTK("ata%u: bus probe end\n", ap->print_id);
-
-			if (rc) {
-				/* FIXME: do something useful here?
-				 * Current libata behavior will
-				 * tear down everything when
-				 * the module is removed
-				 * or the h/w is unplugged.
-				 */
-			}
-		}
-	}
-
-	/* probes are done, now scan each port's disk(s) */
-	DPRINTK("host probe begin\n");
-	for (i = 0; i < host->n_ports; i++) {
-		struct ata_port *ap = host->ports[i];
-
-		ata_scsi_scan_host(ap, 1);
+		async_schedule(async_port_probe, ap);
@@ -5976,0 +6110 @@
+	DPRINTK("probe end\n");
@@ -6050,2 +6183,0 @@
-	struct ata_link *link;
-	struct ata_device *dev;
@@ -6058,0 +6191 @@
+	ata_port_schedule_eh(ap);
@@ -6060,0 +6194 @@
+	/* wait till EH commits suicide */
@@ -6063,16 +6197,2 @@
-	/* EH is now guaranteed to see UNLOADING - EH context belongs
-	 * to us.  Restore SControl and disable all existing devices.
-	 */
-	__ata_port_for_each_link(link, ap) {
-		sata_scr_write(link, SCR_CONTROL, link->saved_scontrol & 0xff0);
-		ata_link_for_each_dev(dev, link)
-			ata_dev_disable(dev);
-	}
-
-	/* Final freeze & EH.  All in-flight commands are aborted.  EH
-	 * will be skipped and retrials will be terminated with bad
-	 * target.
-	 */
-	spin_lock_irqsave(ap->lock, flags);
-	ata_port_freeze(ap);	/* won't be thawed */
-	spin_unlock_irqrestore(ap->lock, flags);
+	/* it better be dead now */
+	WARN_ON(!(ap->pflags & ATA_PFLAG_UNLOADED));
@@ -6080 +6199,0 @@
-	ata_port_wait_eh(ap);
@@ -6531 +6650,2 @@
-EXPORT_SYMBOL_GPL(__ata_port_next_link);
+EXPORT_SYMBOL_GPL(ata_link_next);
+EXPORT_SYMBOL_GPL(ata_dev_next);
@@ -6573 +6692,0 @@
-EXPORT_SYMBOL_GPL(ata_scsi_ioctl);
--- ./projects/linux/linux-2.6.29/drivers/ata/libata-core.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/ata/libata-core.c	2009-06-27 11:32:32.000000000 +0200
@@ -59,0 +60 @@
+#include <linux/log2.h>
@@ -1232,0 +1234,3 @@
+	 * Unfortunately, WDC WD1600JS-62MHB5 (a hard drive) reports
+	 * SEMB signature.  This is worked around in
+	 * ata_dev_read_id().
@@ -1250,2 +1254,2 @@
-		printk(KERN_INFO "ata: SEMB device ignored\n");
-		return ATA_DEV_SEMB_UNSUP; /* not yet */
+		DPRINTK("found SEMB device by sig (could be ATA device)\n");
+		return ATA_DEV_SEMB;
@@ -1655,2 +1659,2 @@
-		int pio = id[163] & 0x7;
-		int dma = (id[163] >> 3) & 7;
+		int pio = (id[ATA_ID_CFA_MODES] >> 0) & 0x7;
+		int dma = (id[ATA_ID_CFA_MODES] >> 3) & 0x7;
@@ -2081,0 +2086 @@
+	bool is_semb = class == ATA_DEV_SEMB;
@@ -2091,0 +2097,2 @@
+	case ATA_DEV_SEMB:
+		class = ATA_DEV_ATA;	/* some hard drives report SEMB sig */
@@ -2127,0 +2135,8 @@
+		if (is_semb) {
+			ata_dev_printk(dev, KERN_INFO, "IDENTIFY failed on "
+				       "device w/ SEMB sig, disabled\n");
+			/* SEMB is not supported yet */
+			*p_class = ATA_DEV_SEMB_UNSUP;
+			return 0;
+		}
+
@@ -2391,0 +2407 @@
+	dev->multi_count = 0;
@@ -2413 +2429,2 @@
-			if (id[162] & 1) /* CPRM may make this media unusable */
+			/* CPRM may make this media unusable */
+			if (id[ATA_ID_CFA_KEY_MGMT] & 1)
@@ -2429,2 +2446,9 @@
-		if (dev->id[59] & 0x100)
-			dev->multi_count = dev->id[59] & 0xff;
+		/* get current R/W Multiple count setting */
+		if ((dev->id[47] >> 8) == 0x80 && (dev->id[59] & 0x100)) {
+			unsigned int max = dev->id[47] & 0xff;
+			unsigned int cnt = dev->id[59] & 0xff;
+			/* only recognize/allow powers of two here */
+			if (is_power_of_2(max) && is_power_of_2(cnt))
+				if (cnt <= max)
+					dev->multi_count = cnt;
+		}
@@ -4070 +4094,3 @@
-	    new_class != ATA_DEV_ATA && new_class != ATA_DEV_ATAPI) {
+	    new_class != ATA_DEV_ATA &&
+	    new_class != ATA_DEV_ATAPI &&
+	    new_class != ATA_DEV_SEMB) {
@@ -6104,2 +6130 @@
-	/* perform each probe synchronously */
-	DPRINTK("probe begin\n");
+	/* perform each probe asynchronously */
@@ -6110 +6134,0 @@
-	DPRINTK("probe end\n");
@@ -6711,0 +6736 @@
+EXPORT_SYMBOL_GPL(ata_pio_queue_task);
--- ./projects/linux/linux-2.6.19/drivers/ata/sata_mv.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/ata/sata_mv.c	2007-02-04 19:44:54.000000000 +0100
@@ -526,2 +526 @@
-		.flags		= (MV_COMMON_FLAGS | MV_6XXX_FLAGS |
-				   MV_FLAG_DUAL_HC),
+		.flags		= (MV_COMMON_FLAGS | MV_6XXX_FLAGS),
@@ -547,0 +547,2 @@
+	{ PCI_VDEVICE(TTI, 0x2310), chip_7042 },
+
--- ./projects/linux/linux-2.6.20/drivers/ata/sata_mv.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/ata/sata_mv.c	2007-04-26 05:08:32.000000000 +0200
@@ -31 +30,0 @@
-#include <linux/sched.h>
@@ -37 +35,0 @@
-#include <asm/io.h>
@@ -40 +38 @@
-#define DRV_VERSION	"0.7"
+#define DRV_VERSION	"0.8"
@@ -141,0 +140,2 @@
+	PORTS_0_3_COAL_DONE	= (1 << 8),
+	PORTS_4_7_COAL_DONE	= (1 << 17),
@@ -146,0 +147 @@
+	HC_MAIN_RSVD_5		= (0x1fff << 19), /* bits 31-19 */
@@ -149,0 +151,2 @@
+	HC_MAIN_MASKED_IRQS_5	= (PORTS_0_3_COAL_DONE | PORTS_4_7_COAL_DONE |
+				   HC_MAIN_RSVD_5),
@@ -345 +347,0 @@
-static void mv_host_stop(struct ata_host *host);
@@ -409 +411 @@
-	.data_xfer		= ata_mmio_data_xfer,
+	.data_xfer		= ata_data_xfer,
@@ -414,0 +417,2 @@
+	.irq_on			= ata_irq_on,
+	.irq_ack		= ata_irq_ack,
@@ -421 +424,0 @@
-	.host_stop		= mv_host_stop,
@@ -437 +440 @@
-	.data_xfer		= ata_mmio_data_xfer,
+	.data_xfer		= ata_data_xfer,
@@ -442,0 +446,2 @@
+	.irq_on			= ata_irq_on,
+	.irq_ack		= ata_irq_ack,
@@ -449 +453,0 @@
-	.host_stop		= mv_host_stop,
@@ -465 +469 @@
-	.data_xfer		= ata_mmio_data_xfer,
+	.data_xfer		= ata_data_xfer,
@@ -470,0 +475,2 @@
+	.irq_on			= ata_irq_on,
+	.irq_ack		= ata_irq_ack,
@@ -477 +482,0 @@
-	.host_stop		= mv_host_stop,
@@ -623 +628 @@
-	return mv_port_base(ap->host->mmio_base, ap->port_no);
+	return mv_port_base(ap->host->iomap[MV_PRIMARY_BAR], ap->port_no);
@@ -812,29 +816,0 @@
-/**
- *      mv_host_stop - Host specific cleanup/stop routine.
- *      @host: host data structure
- *
- *      Disable ints, cleanup host memory, call general purpose
- *      host_stop.
- *
- *      LOCKING:
- *      Inherited from caller.
- */
-static void mv_host_stop(struct ata_host *host)
-{
-	struct mv_host_priv *hpriv = host->private_data;
-	struct pci_dev *pdev = to_pci_dev(host->dev);
-
-	if (hpriv->hp_flags & MV_HP_FLAG_MSI) {
-		pci_disable_msi(pdev);
-	} else {
-		pci_intx(pdev, 0);
-	}
-	kfree(hpriv);
-	ata_host_stop(host);
-}
-
-static inline void mv_priv_free(struct mv_port_priv *pp, struct device *dev)
-{
-	dma_free_coherent(dev, MV_PORT_PRIV_DMA_SZ, pp->crpb, pp->crpb_dma);
-}
-
@@ -846,2 +821,0 @@
-	cfg &= ~0x1f;		/* clear queue depth */
-	cfg &= ~EDMA_CFG_NCQ;	/* clear NCQ mode */
@@ -850 +824,2 @@
-	if (IS_GEN_I(hpriv))
+	if (IS_GEN_I(hpriv)) {
+		cfg &= ~0x1f;		/* clear queue depth */
@@ -851,0 +827 @@
+	}
@@ -853 +829,2 @@
-	else if (IS_GEN_II(hpriv))
+	else if (IS_GEN_II(hpriv)) {
+		cfg &= ~0x1f;		/* clear queue depth */
@@ -854,0 +832,2 @@
+		cfg &= ~(EDMA_CFG_NCQ | EDMA_CFG_NCQ_GO_ON_ERR); /* clear NCQ */
+	}
@@ -857,2 +836,2 @@
-		cfg |= (1 << 23);	/* dis RX PM port mask */
-		cfg &= ~(1 << 16);	/* dis FIS-based switching (for now) */
+		cfg |= (1 << 23);	/* do not mask PM field in rx'd FIS */
+		cfg |= (1 << 22);	/* enab 4-entry host queue cache */
@@ -861,2 +840,3 @@
-		cfg |= (1 << 17);	/* enab host q cache */
-		cfg |= (1 << 22);	/* enab cutthrough */
+		cfg |= (1 << 17);	/* enab cut-through (dis stor&forwrd) */
+		cfg &= ~(1 << 16);	/* dis FIS-based switching (for now) */
+		cfg &= ~(EDMA_CFG_NCQ | EDMA_CFG_NCQ_GO_ON_ERR); /* clear NCQ */
@@ -886 +866 @@
-	int rc = -ENOMEM;
+	int rc;
@@ -888 +868 @@
-	pp = kmalloc(sizeof(*pp), GFP_KERNEL);
+	pp = devm_kzalloc(dev, sizeof(*pp), GFP_KERNEL);
@@ -890,2 +870 @@
-		goto err_out;
-	memset(pp, 0, sizeof(*pp));
+		return -ENOMEM;
@@ -893,2 +872,2 @@
-	mem = dma_alloc_coherent(dev, MV_PORT_PRIV_DMA_SZ, &mem_dma,
-				 GFP_KERNEL);
+	mem = dmam_alloc_coherent(dev, MV_PORT_PRIV_DMA_SZ, &mem_dma,
+				  GFP_KERNEL);
@@ -896 +875 @@
-		goto err_out_pp;
+		return -ENOMEM;
@@ -901 +880 @@
-		goto err_out_priv;
+		return rc;
@@ -954,7 +932,0 @@
-
-err_out_priv:
-	mv_priv_free(pp, dev);
-err_out_pp:
-	kfree(pp);
-err_out:
-	return rc;
@@ -974,2 +945,0 @@
-	struct device *dev = ap->host->dev;
-	struct mv_port_priv *pp = ap->private_data;
@@ -981,5 +950,0 @@
-
-	ap->private_data = NULL;
-	ata_pad_free(ap, dev);
-	mv_priv_free(pp, dev);
-	kfree(pp);
@@ -1323 +1288 @@
-		"SERR: 0x%08x\n", ap->id, edma_err_cause, serr);
+		"SERR: 0x%08x\n", ap->print_id, edma_err_cause, serr);
@@ -1351 +1316 @@
-	void __iomem *mmio = host->mmio_base;
+	void __iomem *mmio = host->iomap[MV_PRIMARY_BAR];
@@ -1394,2 +1359 @@
-				ata_status = readb((void __iomem *)
-					   ap->ioaddr.status_addr);
+				ata_status = readb(ap->ioaddr.status_addr);
@@ -1455 +1419 @@
-	void __iomem *mmio = host->mmio_base;
+	void __iomem *mmio = host->iomap[MV_PRIMARY_BAR];
@@ -1531 +1495,2 @@
-	void __iomem *mmio = mv5_phy_base(ap->host->mmio_base, ap->port_no);
+	void __iomem *mmio = ap->host->iomap[MV_PRIMARY_BAR];
+	void __iomem *addr = mv5_phy_base(mmio, ap->port_no);
@@ -1535 +1500 @@
-		return readl(mmio + ofs);
+		return readl(addr + ofs);
@@ -1542 +1507,2 @@
-	void __iomem *mmio = mv5_phy_base(ap->host->mmio_base, ap->port_no);
+	void __iomem *mmio = ap->host->iomap[MV_PRIMARY_BAR];
+	void __iomem *addr = mv5_phy_base(mmio, ap->port_no);
@@ -1546 +1512 @@
-		writelfl(val, mmio + ofs);
+		writelfl(val, addr + ofs);
@@ -1908 +1874 @@
-	void __iomem *mmio = ap->host->mmio_base;
+	void __iomem *mmio = ap->host->iomap[MV_PRIMARY_BAR];
@@ -2006,4 +1972,4 @@
-	tf.lbah = readb((void __iomem *) ap->ioaddr.lbah_addr);
-	tf.lbam = readb((void __iomem *) ap->ioaddr.lbam_addr);
-	tf.lbal = readb((void __iomem *) ap->ioaddr.lbal_addr);
-	tf.nsect = readb((void __iomem *) ap->ioaddr.nsect_addr);
+	tf.lbah = readb(ap->ioaddr.lbah_addr);
+	tf.lbam = readb(ap->ioaddr.lbam_addr);
+	tf.lbal = readb(ap->ioaddr.lbal_addr);
+	tf.nsect = readb(ap->ioaddr.nsect_addr);
@@ -2040,0 +2007 @@
+	void __iomem *mmio = ap->host->iomap[MV_PRIMARY_BAR];
@@ -2046,2 +2013 @@
-	mv_dump_all_regs(ap->host->mmio_base, ap->port_no,
-			 to_pci_dev(ap->host->dev));
+	mv_dump_all_regs(mmio, ap->port_no, to_pci_dev(ap->host->dev));
@@ -2051 +2017 @@
-	       ap->host->mmio_base, ap, qc, qc->scsicmd, &qc->scsicmd->cmnd);
+	       mmio, ap, qc, qc->scsicmd, &qc->scsicmd->cmnd);
@@ -2079 +2045 @@
-	unsigned long shd_base = (unsigned long) port_mmio + SHD_BLK_OFS;
+	void __iomem *shd_base = port_mmio + SHD_BLK_OFS;
@@ -2098 +2064 @@
-	port->cmd_addr = port->bmdma_addr = port->scr_addr = 0;
+	port->cmd_addr = port->bmdma_addr = port->scr_addr = NULL;
@@ -2227 +2193 @@
-	void __iomem *mmio = probe_ent->mmio_base;
+	void __iomem *mmio = probe_ent->iomap[MV_PRIMARY_BAR];
@@ -2286 +2252,5 @@
-	writelfl(~HC_MAIN_MASKED_IRQS, mmio + HC_MAIN_IRQ_MASK_OFS);
+
+	if (IS_50XX(hpriv))
+		writelfl(~HC_MAIN_MASKED_IRQS_5, mmio + HC_MAIN_IRQ_MASK_OFS);
+	else
+		writelfl(~HC_MAIN_MASKED_IRQS, mmio + HC_MAIN_IRQ_MASK_OFS);
@@ -2345 +2315,2 @@
-	struct ata_probe_ent *probe_ent = NULL;
+	struct device *dev = &pdev->dev;
+	struct ata_probe_ent *probe_ent;
@@ -2348,2 +2319 @@
-	void __iomem *mmio_base;
-	int pci_dev_busy = 0, rc;
+	int rc;
@@ -2354,2 +2324,2 @@
-	rc = pci_enable_device(pdev);
-	if (rc) {
+	rc = pcim_enable_device(pdev);
+	if (rc)
@@ -2357 +2326,0 @@
-	}
@@ -2360,5 +2329,5 @@
-	rc = pci_request_regions(pdev, DRV_NAME);
-	if (rc) {
-		pci_dev_busy = 1;
-		goto err_out;
-	}
+	rc = pcim_iomap_regions(pdev, 1 << MV_PRIMARY_BAR, DRV_NAME);
+	if (rc == -EBUSY)
+		pcim_pin_device(pdev);
+	if (rc)
+		return rc;
@@ -2366,5 +2335,3 @@
-	probe_ent = kmalloc(sizeof(*probe_ent), GFP_KERNEL);
-	if (probe_ent == NULL) {
-		rc = -ENOMEM;
-		goto err_out_regions;
-	}
+	probe_ent = devm_kzalloc(dev, sizeof(*probe_ent), GFP_KERNEL);
+	if (probe_ent == NULL)
+		return -ENOMEM;
@@ -2372 +2338,0 @@
-	memset(probe_ent, 0, sizeof(*probe_ent));
@@ -2376,12 +2342,3 @@
-	mmio_base = pci_iomap(pdev, MV_PRIMARY_BAR, 0);
-	if (mmio_base == NULL) {
-		rc = -ENOMEM;
-		goto err_out_free_ent;
-	}
-
-	hpriv = kmalloc(sizeof(*hpriv), GFP_KERNEL);
-	if (!hpriv) {
-		rc = -ENOMEM;
-		goto err_out_iounmap;
-	}
-	memset(hpriv, 0, sizeof(*hpriv));
+	hpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);
+	if (!hpriv)
+		return -ENOMEM;
@@ -2397 +2354 @@
-	probe_ent->mmio_base = mmio_base;
+	probe_ent->iomap = pcim_iomap_table(pdev);
@@ -2402,3 +2359,2 @@
-	if (rc) {
-		goto err_out_hpriv;
-	}
+	if (rc)
+		return rc;
@@ -2407,3 +2363 @@
-	if (msi && pci_enable_msi(pdev) == 0) {
-		hpriv->hp_flags |= MV_HP_FLAG_MSI;
-	} else {
+	if (msi && pci_enable_msi(pdev))
@@ -2411 +2364,0 @@
-	}
@@ -2416,4 +2369,2 @@
-	if (ata_device_add(probe_ent) == 0) {
-		rc = -ENODEV;		/* No devices discovered */
-		goto err_out_dev_add;
-	}
+	if (ata_device_add(probe_ent) == 0)
+		return -ENODEV;
@@ -2421 +2372 @@
-	kfree(probe_ent);
+	devm_kfree(dev, probe_ent);
@@ -2423,21 +2373,0 @@
-
-err_out_dev_add:
-	if (MV_HP_FLAG_MSI & hpriv->hp_flags) {
-		pci_disable_msi(pdev);
-	} else {
-		pci_intx(pdev, 0);
-	}
-err_out_hpriv:
-	kfree(hpriv);
-err_out_iounmap:
-	pci_iounmap(pdev, mmio_base);
-err_out_free_ent:
-	kfree(probe_ent);
-err_out_regions:
-	pci_release_regions(pdev);
-err_out:
-	if (!pci_dev_busy) {
-		pci_disable_device(pdev);
-	}
-
-	return rc;
--- ./projects/linux/linux-2.6.21/drivers/ata/sata_mv.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/ata/sata_mv.c	2007-07-09 01:32:17.000000000 +0200
@@ -23,0 +24,44 @@
+/*
+  sata_mv TODO list:
+
+  1) Needs a full errata audit for all chipsets.  I implemented most
+  of the errata workarounds found in the Marvell vendor driver, but
+  I distinctly remember a couple workarounds (one related to PCI-X)
+  are still needed.
+
+  2) Convert to LibATA new EH.  Required for hotplug, NCQ, and sane
+  probing/error handling in general.  MUST HAVE.
+
+  3) Add hotplug support (easy, once new-EH support appears)
+
+  4) Add NCQ support (easy to intermediate, once new-EH support appears)
+
+  5) Investigate problems with PCI Message Signalled Interrupts (MSI).
+
+  6) Add port multiplier support (intermediate)
+
+  7) Test and verify 3.0 Gbps support
+
+  8) Develop a low-power-consumption strategy, and implement it.
+
+  9) [Experiment, low priority] See if ATAPI can be supported using
+  "unknown FIS" or "vendor-specific FIS" support, or something creative
+  like that.
+
+  10) [Experiment, low priority] Investigate interrupt coalescing.
+  Quite often, especially with PCI Message Signalled Interrupts (MSI),
+  the overhead reduced by interrupt mitigation is quite often not
+  worth the latency cost.
+
+  11) [Experiment, Marvell value added] Is it possible to use target
+  mode to cross-connect two Linux boxes with Marvell cards?  If so,
+  creating LibATA target mode support would be very interesting.
+
+  Target mode, for those without docs, is the ability to directly
+  connect two SATA controllers.
+
+  13) Verify that 7042 is fully supported.  I only have a 6042.
+
+*/
+
+
@@ -38 +82 @@
-#define DRV_VERSION	"0.8"
+#define DRV_VERSION	"0.81"
@@ -256,4 +300 @@
-	/* Our DMA boundary is determined by an ePRD being unable to handle
-	 * anything larger than 64KB
-	 */
-	MV_DMA_BOUNDARY		= 0xffffU,
+	MV_DMA_BOUNDARY		= 0xffffffffU,
@@ -353 +393,0 @@
-static irqreturn_t mv_interrupt(int irq, void *dev_instance);
@@ -387 +427 @@
-	.sg_tablesize		= MV_MAX_SG_CT / 2,
+	.sg_tablesize		= MV_MAX_SG_CT,
@@ -390 +430 @@
-	.use_clustering		= ATA_SHT_USE_CLUSTERING,
+	.use_clustering		= 1,
@@ -407,0 +448 @@
+	.cable_detect		= ata_cable_sata,
@@ -415 +455,0 @@
-	.irq_handler		= mv_interrupt,
@@ -436,0 +477 @@
+	.cable_detect		= ata_cable_sata,
@@ -444 +484,0 @@
-	.irq_handler		= mv_interrupt,
@@ -465,0 +506 @@
+	.cable_detect		= ata_cable_sata,
@@ -473 +513,0 @@
-	.irq_handler		= mv_interrupt,
@@ -487 +526,0 @@
-		.sht		= &mv_sht,
@@ -494 +532,0 @@
-		.sht		= &mv_sht,
@@ -501 +538,0 @@
-		.sht		= &mv_sht,
@@ -508 +544,0 @@
-		.sht		= &mv_sht,
@@ -515 +550,0 @@
-		.sht		= &mv_sht,
@@ -523 +557,0 @@
-		.sht		= &mv_sht,
@@ -530 +563,0 @@
-		.sht		= &mv_sht,
@@ -551,0 +585,3 @@
+	/* Adaptec 1430SA */
+	{ PCI_VDEVICE(ADAPTEC2, 0x0243), chip_7042 },
+
@@ -553,0 +590,3 @@
+	/* add Marvell 7042 support */
+	{ PCI_VDEVICE(MARVELL, 0x7042), chip_7042 },
+
@@ -587,0 +627,33 @@
+/* move to PCI layer or libata core? */
+static int pci_go_64(struct pci_dev *pdev)
+{
+	int rc;
+
+	if (!pci_set_dma_mask(pdev, DMA_64BIT_MASK)) {
+		rc = pci_set_consistent_dma_mask(pdev, DMA_64BIT_MASK);
+		if (rc) {
+			rc = pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK);
+			if (rc) {
+				dev_printk(KERN_ERR, &pdev->dev,
+					   "64-bit DMA enable failed\n");
+				return rc;
+			}
+		}
+	} else {
+		rc = pci_set_dma_mask(pdev, DMA_32BIT_MASK);
+		if (rc) {
+			dev_printk(KERN_ERR, &pdev->dev,
+				   "32-bit DMA enable failed\n");
+			return rc;
+		}
+		rc = pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK);
+		if (rc) {
+			dev_printk(KERN_ERR, &pdev->dev,
+				   "32-bit consistent DMA enable failed\n");
+			return rc;
+		}
+	}
+
+	return rc;
+}
+
@@ -801 +873 @@
-	if (0xffffffffU != ofs) {
+	if (0xffffffffU != ofs)
@@ -803 +875 @@
-	} else {
+	else
@@ -805 +876,0 @@
-	}
@@ -812 +883 @@
-	if (0xffffffffU != ofs) {
+	if (0xffffffffU != ofs)
@@ -814 +884,0 @@
-	}
@@ -962 +1032 @@
-static void mv_fill_sg(struct ata_queued_cmd *qc)
+static unsigned int mv_fill_sg(struct ata_queued_cmd *qc)
@@ -965 +1035 @@
-	unsigned int i = 0;
+	unsigned int n_sg = 0;
@@ -966,0 +1037 @@
+	struct mv_sg *mv_sg;
@@ -967,0 +1039 @@
+	mv_sg = pp->sg_tbl;
@@ -969,2 +1041,2 @@
-		dma_addr_t addr;
-		u32 sg_len, len, offset;
+		dma_addr_t addr = sg_dma_address(sg);
+		u32 sg_len = sg_dma_len(sg);
@@ -972,2 +1044,3 @@
-		addr = sg_dma_address(sg);
-		sg_len = sg_dma_len(sg);
+		mv_sg->addr = cpu_to_le32(addr & 0xffffffff);
+		mv_sg->addr_hi = cpu_to_le32((addr >> 16) >> 16);
+		mv_sg->flags_size = cpu_to_le32(sg_len & 0xffff);
@@ -975,5 +1048,2 @@
-		while (sg_len) {
-			offset = addr & MV_DMA_BOUNDARY;
-			len = sg_len;
-			if ((offset + sg_len) > 0x10000)
-				len = 0x10000 - offset;
+		if (ata_sg_is_last(sg, qc))
+			mv_sg->flags_size |= cpu_to_le32(EPRD_FLAG_END_OF_TBL);
@@ -981,12 +1051,2 @@
-			pp->sg_tbl[i].addr = cpu_to_le32(addr & 0xffffffff);
-			pp->sg_tbl[i].addr_hi = cpu_to_le32((addr >> 16) >> 16);
-			pp->sg_tbl[i].flags_size = cpu_to_le32(len & 0xffff);
-
-			sg_len -= len;
-			addr += len;
-
-			if (!sg_len && ata_sg_is_last(sg, qc))
-				pp->sg_tbl[i].flags_size |= cpu_to_le32(EPRD_FLAG_END_OF_TBL);
-
-			i++;
-		}
+		mv_sg++;
+		n_sg++;
@@ -993,0 +1054,2 @@
+
+	return n_sg;
@@ -1323 +1385 @@
-	if (hc == 0) {
+	if (hc == 0)
@@ -1325 +1387 @@
-	} else {
+	else
@@ -1327 +1388,0 @@
-	}
@@ -1331 +1392 @@
-	if (hc_irq_cause) {
+	if (hc_irq_cause)
@@ -1333 +1393,0 @@
-	}
@@ -1428 +1488 @@
-	if (!irq_stat || (0xffffffffU == irq_stat)) {
+	if (!irq_stat || (0xffffffffU == irq_stat))
@@ -1430 +1489,0 @@
-	}
@@ -1955 +2013,0 @@
-	ap->cbl = ATA_CBL_SATA;
@@ -2080,2 +2138 @@
-static int mv_chip_id(struct pci_dev *pdev, struct mv_host_priv *hpriv,
-		      unsigned int board_idx)
+static int mv_chip_id(struct ata_host *host, unsigned int board_idx)
@@ -2082,0 +2140,2 @@
+	struct pci_dev *pdev = to_pci_dev(host->dev);
+	struct mv_host_priv *hpriv = host->private_data;
@@ -2180,2 +2239,2 @@
- *	@pdev: host PCI device
- *      @probe_ent: early data struct representing the host
+ *	@host: ATA host to initialize
+ *      @board_idx: controller index
@@ -2189,2 +2248 @@
-static int mv_init_host(struct pci_dev *pdev, struct ata_probe_ent *probe_ent,
-			unsigned int board_idx)
+static int mv_init_host(struct ata_host *host, unsigned int board_idx)
@@ -2193,2 +2251,3 @@
-	void __iomem *mmio = probe_ent->iomap[MV_PRIMARY_BAR];
-	struct mv_host_priv *hpriv = probe_ent->private_data;
+	struct pci_dev *pdev = to_pci_dev(host->dev);
+	void __iomem *mmio = host->iomap[MV_PRIMARY_BAR];
+	struct mv_host_priv *hpriv = host->private_data;
@@ -2199 +2258 @@
-	rc = mv_chip_id(pdev, hpriv, board_idx);
+	rc = mv_chip_id(host, board_idx);
@@ -2203,2 +2262 @@
-	n_hc = mv_get_hc_count(probe_ent->port_flags);
-	probe_ent->n_ports = MV_PORTS_PER_HC * n_hc;
+	n_hc = mv_get_hc_count(host->ports[0]->flags);
@@ -2206 +2264 @@
-	for (port = 0; port < probe_ent->n_ports; port++)
+	for (port = 0; port < host->n_ports; port++)
@@ -2217 +2275 @@
-	for (port = 0; port < probe_ent->n_ports; port++) {
+	for (port = 0; port < host->n_ports; port++) {
@@ -2230 +2288 @@
-	for (port = 0; port < probe_ent->n_ports; port++) {
+	for (port = 0; port < host->n_ports; port++) {
@@ -2232 +2290 @@
-		mv_port_init(&probe_ent->port[port], port_mmio);
+		mv_port_init(&host->ports[port]->ioaddr, port_mmio);
@@ -2271 +2329 @@
- *      @probe_ent: early data struct representing the host
+ *      @host: ATA host to print info about
@@ -2278 +2336 @@
-static void mv_print_info(struct ata_probe_ent *probe_ent)
+static void mv_print_info(struct ata_host *host)
@@ -2280,2 +2338,2 @@
-	struct pci_dev *pdev = to_pci_dev(probe_ent->dev);
-	struct mv_host_priv *hpriv = probe_ent->private_data;
+	struct pci_dev *pdev = to_pci_dev(host->dev);
+	struct mv_host_priv *hpriv = host->private_data;
@@ -2300 +2358 @@
-	       (unsigned)MV_MAX_Q_DEPTH, probe_ent->n_ports,
+	       (unsigned)MV_MAX_Q_DEPTH, host->n_ports,
@@ -2315,3 +2372,0 @@
-	struct device *dev = &pdev->dev;
-	struct ata_probe_ent *probe_ent;
-	struct mv_host_priv *hpriv;
@@ -2319 +2374,4 @@
-	int rc;
+	const struct ata_port_info *ppi[] = { &mv_port_info[board_idx], NULL };
+	struct ata_host *host;
+	struct mv_host_priv *hpriv;
+	int n_ports, rc;
@@ -2323,0 +2382,10 @@
+	/* allocate host */
+	n_ports = mv_get_hc_count(ppi[0]->flags) * MV_PORTS_PER_HC;
+
+	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
+	hpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);
+	if (!host || !hpriv)
+		return -ENOMEM;
+	host->private_data = hpriv;
+
+	/* acquire resources */
@@ -2327 +2394,0 @@
-	pci_set_master(pdev);
@@ -2333,0 +2401 @@
+	host->iomap = pcim_iomap_table(pdev);
@@ -2335,21 +2403,3 @@
-	probe_ent = devm_kzalloc(dev, sizeof(*probe_ent), GFP_KERNEL);
-	if (probe_ent == NULL)
-		return -ENOMEM;
-
-	probe_ent->dev = pci_dev_to_dev(pdev);
-	INIT_LIST_HEAD(&probe_ent->node);
-
-	hpriv = devm_kzalloc(dev, sizeof(*hpriv), GFP_KERNEL);
-	if (!hpriv)
-		return -ENOMEM;
-
-	probe_ent->sht = mv_port_info[board_idx].sht;
-	probe_ent->port_flags = mv_port_info[board_idx].flags;
-	probe_ent->pio_mask = mv_port_info[board_idx].pio_mask;
-	probe_ent->udma_mask = mv_port_info[board_idx].udma_mask;
-	probe_ent->port_ops = mv_port_info[board_idx].port_ops;
-
-	probe_ent->irq = pdev->irq;
-	probe_ent->irq_flags = IRQF_SHARED;
-	probe_ent->iomap = pcim_iomap_table(pdev);
-	probe_ent->private_data = hpriv;
+	rc = pci_go_64(pdev);
+	if (rc)
+		return rc;
@@ -2358 +2408 @@
-	rc = mv_init_host(pdev, probe_ent, board_idx);
+	rc = mv_init_host(host, board_idx);
@@ -2367,4 +2417 @@
-	mv_print_info(probe_ent);
-
-	if (ata_device_add(probe_ent) == 0)
-		return -ENODEV;
+	mv_print_info(host);
@@ -2372,2 +2419,3 @@
-	devm_kfree(dev, probe_ent);
-	return 0;
+	pci_set_master(pdev);
+	return ata_host_activate(host, pdev->irq, mv_interrupt, IRQF_SHARED,
+				 &mv_sht);
--- ./projects/linux/linux-2.6.22/drivers/ata/sata_mv.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/ata/sata_mv.c	2007-10-09 22:31:38.000000000 +0200
@@ -32,5 +31,0 @@
-  2) Convert to LibATA new EH.  Required for hotplug, NCQ, and sane
-  probing/error handling in general.  MUST HAVE.
-
-  3) Add hotplug support (easy, once new-EH support appears)
-
@@ -43,2 +37,0 @@
-  7) Test and verify 3.0 Gbps support
-
@@ -82 +75 @@
-#define DRV_VERSION	"0.81"
+#define DRV_VERSION	"1.0"
@@ -111,2 +103,0 @@
-	MV_USE_Q_DEPTH		= ATA_DEF_QUEUE,
-
@@ -136,3 +127,3 @@
-	MV_COMMON_FLAGS		= (ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
-				   ATA_FLAG_SATA_RESET | ATA_FLAG_MMIO |
-				   ATA_FLAG_NO_ATAPI | ATA_FLAG_PIO_POLLING),
+	MV_COMMON_FLAGS		= ATA_FLAG_SATA | ATA_FLAG_NO_LEGACY |
+				  ATA_FLAG_MMIO | ATA_FLAG_NO_ATAPI |
+				  ATA_FLAG_PIO_POLLING,
@@ -142,0 +134,2 @@
+	CRQB_IOID_SHIFT		= 6,	/* CRQB Gen-II/IIE IO Id shift */
+	CRQB_HOSTQ_SHIFT	= 17,	/* CRQB Gen-II/IIE HostQueTag shift */
@@ -147,0 +141,2 @@
+	CRPB_IOID_SHIFT_6	= 5,	/* CRPB Gen-II IO Id shift */
+	CRPB_IOID_SHIFT_7	= 7,	/* CRPB Gen-IIE IO Id shift */
@@ -233,13 +228,15 @@
-	EDMA_ERR_D_PAR		= (1 << 0),
-	EDMA_ERR_PRD_PAR	= (1 << 1),
-	EDMA_ERR_DEV		= (1 << 2),
-	EDMA_ERR_DEV_DCON	= (1 << 3),
-	EDMA_ERR_DEV_CON	= (1 << 4),
-	EDMA_ERR_SERR		= (1 << 5),
-	EDMA_ERR_SELF_DIS	= (1 << 7),
-	EDMA_ERR_BIST_ASYNC	= (1 << 8),
-	EDMA_ERR_CRBQ_PAR	= (1 << 9),
-	EDMA_ERR_CRPB_PAR	= (1 << 10),
-	EDMA_ERR_INTRL_PAR	= (1 << 11),
-	EDMA_ERR_IORDY		= (1 << 12),
-	EDMA_ERR_LNK_CTRL_RX	= (0xf << 13),
+	EDMA_ERR_D_PAR		= (1 << 0),	/* UDMA data parity err */
+	EDMA_ERR_PRD_PAR	= (1 << 1),	/* UDMA PRD parity err */
+	EDMA_ERR_DEV		= (1 << 2),	/* device error */
+	EDMA_ERR_DEV_DCON	= (1 << 3),	/* device disconnect */
+	EDMA_ERR_DEV_CON	= (1 << 4),	/* device connected */
+	EDMA_ERR_SERR		= (1 << 5),	/* SError bits [WBDST] raised */
+	EDMA_ERR_SELF_DIS	= (1 << 7),	/* Gen II/IIE self-disable */
+	EDMA_ERR_SELF_DIS_5	= (1 << 8),	/* Gen I self-disable */
+	EDMA_ERR_BIST_ASYNC	= (1 << 8),	/* BIST FIS or Async Notify */
+	EDMA_ERR_TRANS_IRQ_7	= (1 << 8),	/* Gen IIE transprt layer irq */
+	EDMA_ERR_CRQB_PAR	= (1 << 9),	/* CRQB parity error */
+	EDMA_ERR_CRPB_PAR	= (1 << 10),	/* CRPB parity error */
+	EDMA_ERR_INTRL_PAR	= (1 << 11),	/* internal parity error */
+	EDMA_ERR_IORDY		= (1 << 12),	/* IORdy timeout */
+	EDMA_ERR_LNK_CTRL_RX	= (0xf << 13),	/* link ctrl rx error */
@@ -247,11 +244,31 @@
-	EDMA_ERR_LNK_DATA_RX	= (0xf << 17),
-	EDMA_ERR_LNK_CTRL_TX	= (0x1f << 21),
-	EDMA_ERR_LNK_DATA_TX	= (0x1f << 26),
-	EDMA_ERR_TRANS_PROTO	= (1 << 31),
-	EDMA_ERR_FATAL		= (EDMA_ERR_D_PAR | EDMA_ERR_PRD_PAR |
-				   EDMA_ERR_DEV_DCON | EDMA_ERR_CRBQ_PAR |
-				   EDMA_ERR_CRPB_PAR | EDMA_ERR_INTRL_PAR |
-				   EDMA_ERR_IORDY | EDMA_ERR_LNK_CTRL_RX_2 |
-				   EDMA_ERR_LNK_DATA_RX |
-				   EDMA_ERR_LNK_DATA_TX |
-				   EDMA_ERR_TRANS_PROTO),
+	EDMA_ERR_LNK_DATA_RX	= (0xf << 17),	/* link data rx error */
+	EDMA_ERR_LNK_CTRL_TX	= (0x1f << 21),	/* link ctrl tx error */
+	EDMA_ERR_LNK_DATA_TX	= (0x1f << 26),	/* link data tx error */
+	EDMA_ERR_TRANS_PROTO	= (1 << 31),	/* transport protocol error */
+	EDMA_ERR_OVERRUN_5	= (1 << 5),
+	EDMA_ERR_UNDERRUN_5	= (1 << 6),
+	EDMA_EH_FREEZE		= EDMA_ERR_D_PAR |
+				  EDMA_ERR_PRD_PAR |
+				  EDMA_ERR_DEV_DCON |
+				  EDMA_ERR_DEV_CON |
+				  EDMA_ERR_SERR |
+				  EDMA_ERR_SELF_DIS |
+				  EDMA_ERR_CRQB_PAR |
+				  EDMA_ERR_CRPB_PAR |
+				  EDMA_ERR_INTRL_PAR |
+				  EDMA_ERR_IORDY |
+				  EDMA_ERR_LNK_CTRL_RX_2 |
+				  EDMA_ERR_LNK_DATA_RX |
+				  EDMA_ERR_LNK_DATA_TX |
+				  EDMA_ERR_TRANS_PROTO,
+	EDMA_EH_FREEZE_5	= EDMA_ERR_D_PAR |
+				  EDMA_ERR_PRD_PAR |
+				  EDMA_ERR_DEV_DCON |
+				  EDMA_ERR_DEV_CON |
+				  EDMA_ERR_OVERRUN_5 |
+				  EDMA_ERR_UNDERRUN_5 |
+				  EDMA_ERR_SELF_DIS_5 |
+				  EDMA_ERR_CRQB_PAR |
+				  EDMA_ERR_CRPB_PAR |
+				  EDMA_ERR_INTRL_PAR |
+				  EDMA_ERR_IORDY,
@@ -270,4 +287,4 @@
-	EDMA_CMD_OFS		= 0x28,
-	EDMA_EN			= (1 << 0),
-	EDMA_DS			= (1 << 1),
-	ATA_RST			= (1 << 2),
+	EDMA_CMD_OFS		= 0x28,		/* EDMA command register */
+	EDMA_EN			= (1 << 0),	/* enable EDMA */
+	EDMA_DS			= (1 << 1),	/* disable EDMA; self-negated */
+	ATA_RST			= (1 << 2),	/* reset trans/link/phy */
@@ -285,2 +302,3 @@
-	MV_HP_50XX		= (1 << 6),
-	MV_HP_GEN_IIE		= (1 << 7),
+	MV_HP_GEN_I		= (1 << 6),	/* Generation I: 50xx */
+	MV_HP_GEN_II		= (1 << 7),	/* Generation II: 60xx */
+	MV_HP_GEN_IIE		= (1 << 8),	/* Generation IIE: 6042/7042 */
@@ -289,2 +307,2 @@
-	MV_PP_FLAG_EDMA_EN	= (1 << 0),
-	MV_PP_FLAG_EDMA_DS_ACT	= (1 << 1),
+	MV_PP_FLAG_EDMA_EN	= (1 << 0),	/* is EDMA engine enabled? */
+	MV_PP_FLAG_HAD_A_RESET	= (1 << 2),	/* 1st hard reset complete? */
@@ -293,4 +311,2 @@
-#define IS_50XX(hpriv) ((hpriv)->hp_flags & MV_HP_50XX)
-#define IS_60XX(hpriv) (((hpriv)->hp_flags & MV_HP_50XX) == 0)
-#define IS_GEN_I(hpriv) IS_50XX(hpriv)
-#define IS_GEN_II(hpriv) IS_60XX(hpriv)
+#define IS_GEN_I(hpriv) ((hpriv)->hp_flags & MV_HP_GEN_I)
+#define IS_GEN_II(hpriv) ((hpriv)->hp_flags & MV_HP_GEN_II)
@@ -300 +316,4 @@
-	MV_DMA_BOUNDARY		= 0xffffffffU,
+	/* DMA boundary 0xffff is required by the s/g splitting
+	 * we need on /length/ in mv_fill-sg().
+	 */
+	MV_DMA_BOUNDARY		= 0xffffU,
@@ -301,0 +321,3 @@
+	/* mask of register bits containing lower 32 bits
+	 * of EDMA request queue DMA address
+	 */
@@ -303,0 +326 @@
+	/* ditto, for response queue */
@@ -354,0 +378,4 @@
+
+	unsigned int		req_idx;
+	unsigned int		resp_idx;
+
@@ -383,6 +410,4 @@
-static u32 mv_scr_read(struct ata_port *ap, unsigned int sc_reg_in);
-static void mv_scr_write(struct ata_port *ap, unsigned int sc_reg_in, u32 val);
-static u32 mv5_scr_read(struct ata_port *ap, unsigned int sc_reg_in);
-static void mv5_scr_write(struct ata_port *ap, unsigned int sc_reg_in, u32 val);
-static void mv_phy_reset(struct ata_port *ap);
-static void __mv_phy_reset(struct ata_port *ap, int can_sleep);
+static int mv_scr_read(struct ata_port *ap, unsigned int sc_reg_in, u32 *val);
+static int mv_scr_write(struct ata_port *ap, unsigned int sc_reg_in, u32 val);
+static int mv5_scr_read(struct ata_port *ap, unsigned int sc_reg_in, u32 *val);
+static int mv5_scr_write(struct ata_port *ap, unsigned int sc_reg_in, u32 val);
@@ -394 +419,4 @@
-static void mv_eng_timeout(struct ata_port *ap);
+static void mv_error_handler(struct ata_port *ap);
+static void mv_post_int_cmd(struct ata_queued_cmd *qc);
+static void mv_eh_freeze(struct ata_port *ap);
+static void mv_eh_thaw(struct ata_port *ap);
@@ -418 +445,0 @@
-static void mv_stop_and_reset(struct ata_port *ap);
@@ -420 +447 @@
-static struct scsi_host_template mv_sht = {
+static struct scsi_host_template mv5_sht = {
@@ -425 +452 @@
-	.can_queue		= MV_USE_Q_DEPTH,
+	.can_queue		= ATA_DEF_QUEUE,
@@ -427 +454,19 @@
-	.sg_tablesize		= MV_MAX_SG_CT,
+	.sg_tablesize		= MV_MAX_SG_CT / 2,
+	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
+	.emulated		= ATA_SHT_EMULATED,
+	.use_clustering		= 1,
+	.proc_name		= DRV_NAME,
+	.dma_boundary		= MV_DMA_BOUNDARY,
+	.slave_configure	= ata_scsi_slave_config,
+	.slave_destroy		= ata_scsi_slave_destroy,
+	.bios_param		= ata_std_bios_param,
+};
+
+static struct scsi_host_template mv6_sht = {
+	.module			= THIS_MODULE,
+	.name			= DRV_NAME,
+	.ioctl			= ata_scsi_ioctl,
+	.queuecommand		= ata_scsi_queuecmd,
+	.can_queue		= ATA_DEF_QUEUE,
+	.this_id		= ATA_SHT_THIS_ID,
+	.sg_tablesize		= MV_MAX_SG_CT / 2,
@@ -447 +491,0 @@
-	.phy_reset		= mv_phy_reset,
@@ -454,2 +497,0 @@
-	.eng_timeout		= mv_eng_timeout,
-
@@ -459,0 +502,5 @@
+	.error_handler		= mv_error_handler,
+	.post_internal_cmd	= mv_post_int_cmd,
+	.freeze			= mv_eh_freeze,
+	.thaw			= mv_eh_thaw,
+
@@ -476 +522,0 @@
-	.phy_reset		= mv_phy_reset,
@@ -483,2 +528,0 @@
-	.eng_timeout		= mv_eng_timeout,
-
@@ -488,0 +533,5 @@
+	.error_handler		= mv_error_handler,
+	.post_internal_cmd	= mv_post_int_cmd,
+	.freeze			= mv_eh_freeze,
+	.thaw			= mv_eh_thaw,
+
@@ -505 +553,0 @@
-	.phy_reset		= mv_phy_reset,
@@ -512,2 +559,0 @@
-	.eng_timeout		= mv_eng_timeout,
-
@@ -517,0 +564,5 @@
+	.error_handler		= mv_error_handler,
+	.post_internal_cmd	= mv_post_int_cmd,
+	.freeze			= mv_eh_freeze,
+	.thaw			= mv_eh_thaw,
+
@@ -529 +580 @@
-		.udma_mask	= 0x7f,	/* udma0-6 */
+		.udma_mask	= ATA_UDMA6,
@@ -533 +584 @@
-		.flags		= (MV_COMMON_FLAGS | MV_FLAG_DUAL_HC),
+		.flags		= MV_COMMON_FLAGS | MV_FLAG_DUAL_HC,
@@ -535 +586 @@
-		.udma_mask	= 0x7f,	/* udma0-6 */
+		.udma_mask	= ATA_UDMA6,
@@ -539 +590 @@
-		.flags		= (MV_COMMON_FLAGS | MV_FLAG_DUAL_HC),
+		.flags		= MV_COMMON_FLAGS | MV_FLAG_DUAL_HC,
@@ -541 +592 @@
-		.udma_mask	= 0x7f,	/* udma0-6 */
+		.udma_mask	= ATA_UDMA6,
@@ -545 +596 @@
-		.flags		= (MV_COMMON_FLAGS | MV_6XXX_FLAGS),
+		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS,
@@ -547 +598 @@
-		.udma_mask	= 0x7f,	/* udma0-6 */
+		.udma_mask	= ATA_UDMA6,
@@ -551,2 +602,2 @@
-		.flags		= (MV_COMMON_FLAGS | MV_6XXX_FLAGS |
-				   MV_FLAG_DUAL_HC),
+		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS |
+				  MV_FLAG_DUAL_HC,
@@ -554 +605 @@
-		.udma_mask	= 0x7f,	/* udma0-6 */
+		.udma_mask	= ATA_UDMA6,
@@ -558 +609 @@
-		.flags		= (MV_COMMON_FLAGS | MV_6XXX_FLAGS),
+		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS,
@@ -560 +611 @@
-		.udma_mask	= 0x7f,	/* udma0-6 */
+		.udma_mask	= ATA_UDMA6,
@@ -564 +615 @@
-		.flags		= (MV_COMMON_FLAGS | MV_6XXX_FLAGS),
+		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS,
@@ -566 +617 @@
-		.udma_mask	= 0x7f,	/* udma0-6 */
+		.udma_mask	= ATA_UDMA6,
@@ -575,0 +627,3 @@
+	/* RocketRAID 1740/174x have different identifiers */
+	{ PCI_VDEVICE(TTI, 0x1740), chip_508x },
+	{ PCI_VDEVICE(TTI, 0x1742), chip_508x },
@@ -711,0 +766,40 @@
+static void mv_set_edma_ptrs(void __iomem *port_mmio,
+			     struct mv_host_priv *hpriv,
+			     struct mv_port_priv *pp)
+{
+	u32 index;
+
+	/*
+	 * initialize request queue
+	 */
+	index = (pp->req_idx & MV_MAX_Q_DEPTH_MASK) << EDMA_REQ_Q_PTR_SHIFT;
+
+	WARN_ON(pp->crqb_dma & 0x3ff);
+	writel((pp->crqb_dma >> 16) >> 16, port_mmio + EDMA_REQ_Q_BASE_HI_OFS);
+	writelfl((pp->crqb_dma & EDMA_REQ_Q_BASE_LO_MASK) | index,
+		 port_mmio + EDMA_REQ_Q_IN_PTR_OFS);
+
+	if (hpriv->hp_flags & MV_HP_ERRATA_XX42A0)
+		writelfl((pp->crqb_dma & 0xffffffff) | index,
+			 port_mmio + EDMA_REQ_Q_OUT_PTR_OFS);
+	else
+		writelfl(index, port_mmio + EDMA_REQ_Q_OUT_PTR_OFS);
+
+	/*
+	 * initialize response queue
+	 */
+	index = (pp->resp_idx & MV_MAX_Q_DEPTH_MASK) << EDMA_RSP_Q_PTR_SHIFT;
+
+	WARN_ON(pp->crpb_dma & 0xff);
+	writel((pp->crpb_dma >> 16) >> 16, port_mmio + EDMA_RSP_Q_BASE_HI_OFS);
+
+	if (hpriv->hp_flags & MV_HP_ERRATA_XX42A0)
+		writelfl((pp->crpb_dma & 0xffffffff) | index,
+			 port_mmio + EDMA_RSP_Q_IN_PTR_OFS);
+	else
+		writelfl(index, port_mmio + EDMA_RSP_Q_IN_PTR_OFS);
+
+	writelfl((pp->crpb_dma & EDMA_RSP_Q_BASE_LO_MASK) | index,
+		 port_mmio + EDMA_RSP_Q_OUT_PTR_OFS);
+}
+
@@ -723 +817,2 @@
-static void mv_start_dma(void __iomem *base, struct mv_port_priv *pp)
+static void mv_start_dma(void __iomem *base, struct mv_host_priv *hpriv,
+			 struct mv_port_priv *pp)
@@ -725 +820,6 @@
-	if (!(MV_PP_FLAG_EDMA_EN & pp->pp_flags)) {
+	if (!(pp->pp_flags & MV_PP_FLAG_EDMA_EN)) {
+		/* clear EDMA event indicators, if any */
+		writelfl(0, base + EDMA_ERR_IRQ_CAUSE_OFS);
+
+		mv_set_edma_ptrs(base, hpriv, pp);
+
@@ -733 +833 @@
- *      mv_stop_dma - Disable eDMA engine
+ *      __mv_stop_dma - Disable eDMA engine
@@ -742 +842 @@
-static void mv_stop_dma(struct ata_port *ap)
+static int __mv_stop_dma(struct ata_port *ap)
@@ -747 +847 @@
-	int i;
+	int i, err = 0;
@@ -749 +849 @@
-	if (MV_PP_FLAG_EDMA_EN & pp->pp_flags) {
+	if (pp->pp_flags & MV_PP_FLAG_EDMA_EN) {
@@ -761 +861 @@
-		if (!(EDMA_EN & reg)) {
+		if (!(reg & EDMA_EN))
@@ -763 +863 @@
-		}
+
@@ -767 +867 @@
-	if (EDMA_EN & reg) {
+	if (reg & EDMA_EN) {
@@ -769 +869 @@
-		/* FIXME: Consider doing a reset here to recover */
+		err = -EIO;
@@ -770,0 +871,14 @@
+
+	return err;
+}
+
+static int mv_stop_dma(struct ata_port *ap)
+{
+	unsigned long flags;
+	int rc;
+
+	spin_lock_irqsave(&ap->host->lock, flags);
+	rc = __mv_stop_dma(ap);
+	spin_unlock_irqrestore(&ap->host->lock, flags);
+
+	return rc;
@@ -869 +983 @@
-static u32 mv_scr_read(struct ata_port *ap, unsigned int sc_reg_in)
+static int mv_scr_read(struct ata_port *ap, unsigned int sc_reg_in, u32 *val)
@@ -873,4 +987,5 @@
-	if (0xffffffffU != ofs)
-		return readl(mv_ap_base(ap) + ofs);
-	else
-		return (u32) ofs;
+	if (ofs != 0xffffffffU) {
+		*val = readl(mv_ap_base(ap) + ofs);
+		return 0;
+	} else
+		return -EINVAL;
@@ -879 +994 @@
-static void mv_scr_write(struct ata_port *ap, unsigned int sc_reg_in, u32 val)
+static int mv_scr_write(struct ata_port *ap, unsigned int sc_reg_in, u32 val)
@@ -883 +998 @@
-	if (0xffffffffU != ofs)
+	if (ofs != 0xffffffffU) {
@@ -884,0 +1000,3 @@
+		return 0;
+	} else
+		return -EINVAL;
@@ -887 +1005,2 @@
-static void mv_edma_cfg(struct mv_host_priv *hpriv, void __iomem *port_mmio)
+static void mv_edma_cfg(struct ata_port *ap, struct mv_host_priv *hpriv,
+			void __iomem *port_mmio)
@@ -892 +1011 @@
-	cfg &= ~(1 << 9);	/* disable equeue */
+	cfg &= ~(1 << 9);	/* disable eQue */
@@ -912 +1031 @@
-		cfg &= ~(EDMA_CFG_NCQ | EDMA_CFG_NCQ_GO_ON_ERR); /* clear NCQ */
+		cfg &= ~(EDMA_CFG_NCQ);	/* clear NCQ */
@@ -935,0 +1055 @@
+	unsigned long flags;
@@ -974,11 +1094 @@
-	mv_edma_cfg(hpriv, port_mmio);
-
-	writel((pp->crqb_dma >> 16) >> 16, port_mmio + EDMA_REQ_Q_BASE_HI_OFS);
-	writelfl(pp->crqb_dma & EDMA_REQ_Q_BASE_LO_MASK,
-		 port_mmio + EDMA_REQ_Q_IN_PTR_OFS);
-
-	if (hpriv->hp_flags & MV_HP_ERRATA_XX42A0)
-		writelfl(pp->crqb_dma & 0xffffffff,
-			 port_mmio + EDMA_REQ_Q_OUT_PTR_OFS);
-	else
-		writelfl(0, port_mmio + EDMA_REQ_Q_OUT_PTR_OFS);
+	spin_lock_irqsave(&ap->host->lock, flags);
@@ -986 +1096 @@
-	writel((pp->crpb_dma >> 16) >> 16, port_mmio + EDMA_RSP_Q_BASE_HI_OFS);
+	mv_edma_cfg(ap, hpriv, port_mmio);
@@ -988,5 +1098 @@
-	if (hpriv->hp_flags & MV_HP_ERRATA_XX42A0)
-		writelfl(pp->crpb_dma & 0xffffffff,
-			 port_mmio + EDMA_RSP_Q_IN_PTR_OFS);
-	else
-		writelfl(0, port_mmio + EDMA_RSP_Q_IN_PTR_OFS);
+	mv_set_edma_ptrs(port_mmio, hpriv, pp);
@@ -994,2 +1100 @@
-	writelfl(pp->crpb_dma & EDMA_RSP_Q_BASE_LO_MASK,
-		 port_mmio + EDMA_RSP_Q_OUT_PTR_OFS);
+	spin_unlock_irqrestore(&ap->host->lock, flags);
@@ -1016,3 +1120,0 @@
-	unsigned long flags;
-
-	spin_lock_irqsave(&ap->host->lock, flags);
@@ -1020 +1121,0 @@
-	spin_unlock_irqrestore(&ap->host->lock, flags);
@@ -1044,3 +1145,16 @@
-		mv_sg->addr = cpu_to_le32(addr & 0xffffffff);
-		mv_sg->addr_hi = cpu_to_le32((addr >> 16) >> 16);
-		mv_sg->flags_size = cpu_to_le32(sg_len & 0xffff);
+		while (sg_len) {
+			u32 offset = addr & 0xffff;
+			u32 len = sg_len;
+
+			if ((offset + sg_len > 0x10000))
+				len = 0x10000 - offset;
+
+			mv_sg->addr = cpu_to_le32(addr & 0xffffffff);
+			mv_sg->addr_hi = cpu_to_le32((addr >> 16) >> 16);
+			mv_sg->flags_size = cpu_to_le32(len);
+
+			sg_len -= len;
+			addr += len;
+
+			if (!sg_len && ata_sg_is_last(sg, qc))
+				mv_sg->flags_size |= cpu_to_le32(EPRD_FLAG_END_OF_TBL);
@@ -1048,2 +1162,3 @@
-		if (ata_sg_is_last(sg, qc))
-			mv_sg->flags_size |= cpu_to_le32(EPRD_FLAG_END_OF_TBL);
+			mv_sg++;
+			n_sg++;
+		}
@@ -1051,2 +1165,0 @@
-		mv_sg++;
-		n_sg++;
@@ -1058,5 +1170,0 @@
-static inline unsigned mv_inc_q_index(unsigned index)
-{
-	return (index + 1) & MV_MAX_Q_DEPTH_MASK;
-}
-
@@ -1091 +1199 @@
- 	if (ATA_PROT_DMA != qc->tf.protocol)
+ 	if (qc->tf.protocol != ATA_PROT_DMA)
@@ -1099,0 +1208 @@
+	flags |= qc->tag << CRQB_IOID_SHIFT;	/* 50xx appears to ignore this*/
@@ -1101,3 +1210,2 @@
-	/* get current queue index from hardware */
-	in_index = (readl(mv_ap_base(ap) + EDMA_REQ_Q_IN_PTR_OFS)
-			>> EDMA_REQ_Q_PTR_SHIFT) & MV_MAX_Q_DEPTH_MASK;
+	/* get current queue index from software */
+	in_index = pp->req_idx & MV_MAX_Q_DEPTH_MASK;
@@ -1183 +1291 @@
- 	if (ATA_PROT_DMA != qc->tf.protocol)
+ 	if (qc->tf.protocol != ATA_PROT_DMA)
@@ -1192,0 +1301,2 @@
+	flags |= qc->tag << CRQB_IOID_SHIFT;	/* "I/O Id" is -really-
+						   what we use as our tag */
@@ -1194,3 +1304,2 @@
-	/* get current queue index from hardware */
-	in_index = (readl(mv_ap_base(ap) + EDMA_REQ_Q_IN_PTR_OFS)
-			>> EDMA_REQ_Q_PTR_SHIFT) & MV_MAX_Q_DEPTH_MASK;
+	/* get current queue index from software */
+	in_index = pp->req_idx & MV_MAX_Q_DEPTH_MASK;
@@ -1244,4 +1353,5 @@
-	void __iomem *port_mmio = mv_ap_base(qc->ap);
-	struct mv_port_priv *pp = qc->ap->private_data;
-	unsigned in_index;
-	u32 in_ptr;
+	struct ata_port *ap = qc->ap;
+	void __iomem *port_mmio = mv_ap_base(ap);
+	struct mv_port_priv *pp = ap->private_data;
+	struct mv_host_priv *hpriv = ap->host->private_data;
+	u32 in_index;
@@ -1249 +1359 @@
-	if (ATA_PROT_DMA != qc->tf.protocol) {
+	if (qc->tf.protocol != ATA_PROT_DMA) {
@@ -1254 +1364 @@
-		mv_stop_dma(qc->ap);
+		__mv_stop_dma(ap);
@@ -1258,2 +1368,3 @@
-	in_ptr   = readl(port_mmio + EDMA_REQ_Q_IN_PTR_OFS);
-	in_index = (in_ptr >> EDMA_REQ_Q_PTR_SHIFT) & MV_MAX_Q_DEPTH_MASK;
+	mv_start_dma(port_mmio, hpriv, pp);
+
+	in_index = pp->req_idx & MV_MAX_Q_DEPTH_MASK;
@@ -1265 +1376 @@
-	in_index = mv_inc_q_index(in_index);	/* now incr producer index */
+	pp->req_idx++;
@@ -1267 +1378 @@
-	mv_start_dma(port_mmio, pp);
+	in_index = (pp->req_idx & MV_MAX_Q_DEPTH_MASK) << EDMA_REQ_Q_PTR_SHIFT;
@@ -1270,3 +1381,2 @@
-	in_ptr &= EDMA_REQ_Q_BASE_LO_MASK;
-	in_ptr |= in_index << EDMA_REQ_Q_PTR_SHIFT;
-	writelfl(in_ptr, port_mmio + EDMA_REQ_Q_IN_PTR_OFS);
+	writelfl((pp->crqb_dma & EDMA_REQ_Q_BASE_LO_MASK) | in_index,
+		 port_mmio + EDMA_REQ_Q_IN_PTR_OFS);
@@ -1278,43 +1387,0 @@
- *      mv_get_crpb_status - get status from most recently completed cmd
- *      @ap: ATA channel to manipulate
- *
- *      This routine is for use when the port is in DMA mode, when it
- *      will be using the CRPB (command response block) method of
- *      returning command completion information.  We check indices
- *      are good, grab status, and bump the response consumer index to
- *      prove that we're up to date.
- *
- *      LOCKING:
- *      Inherited from caller.
- */
-static u8 mv_get_crpb_status(struct ata_port *ap)
-{
-	void __iomem *port_mmio = mv_ap_base(ap);
-	struct mv_port_priv *pp = ap->private_data;
-	unsigned out_index;
-	u32 out_ptr;
-	u8 ata_status;
-
-	out_ptr   = readl(port_mmio + EDMA_RSP_Q_OUT_PTR_OFS);
-	out_index = (out_ptr >> EDMA_RSP_Q_PTR_SHIFT) & MV_MAX_Q_DEPTH_MASK;
-
-	ata_status = le16_to_cpu(pp->crpb[out_index].flags)
-					>> CRPB_FLAG_STATUS_SHIFT;
-
-	/* increment our consumer index... */
-	out_index = mv_inc_q_index(out_index);
-
-	/* and, until we do NCQ, there should only be 1 CRPB waiting */
-	WARN_ON(out_index != ((readl(port_mmio + EDMA_RSP_Q_IN_PTR_OFS)
-		>> EDMA_RSP_Q_PTR_SHIFT) & MV_MAX_Q_DEPTH_MASK));
-
-	/* write out our inc'd consumer index so EDMA knows we're caught up */
-	out_ptr &= EDMA_RSP_Q_BASE_LO_MASK;
-	out_ptr |= out_index << EDMA_RSP_Q_PTR_SHIFT;
-	writelfl(out_ptr, port_mmio + EDMA_RSP_Q_OUT_PTR_OFS);
-
-	/* Return ATA status register for completed CRPB */
-	return ata_status;
-}
-
-/**
@@ -1334 +1401 @@
-static void mv_err_intr(struct ata_port *ap, int reset_allowed)
+static void mv_err_intr(struct ata_port *ap, struct ata_queued_cmd *qc)
@@ -1337 +1404,16 @@
-	u32 edma_err_cause, serr = 0;
+	u32 edma_err_cause, eh_freeze_mask, serr = 0;
+	struct mv_port_priv *pp = ap->private_data;
+	struct mv_host_priv *hpriv = ap->host->private_data;
+	unsigned int edma_enabled = (pp->pp_flags & MV_PP_FLAG_EDMA_EN);
+	unsigned int action = 0, err_mask = 0;
+	struct ata_eh_info *ehi = &ap->eh_info;
+
+	ata_ehi_clear_desc(ehi);
+
+	if (!edma_enabled) {
+		/* just a guess: do we need to do this? should we
+		 * expand this, and do it in all cases?
+		 */
+		sata_scr_read(ap, SCR_ERROR, &serr);
+		sata_scr_write_flush(ap, SCR_ERROR, serr);
+	}
@@ -1341,3 +1423,19 @@
-	if (EDMA_ERR_SERR & edma_err_cause) {
-		sata_scr_read(ap, SCR_ERROR, &serr);
-		sata_scr_write_flush(ap, SCR_ERROR, serr);
+	ata_ehi_push_desc(ehi, "edma_err 0x%08x", edma_err_cause);
+
+	/*
+	 * all generations share these EDMA error cause bits
+	 */
+
+	if (edma_err_cause & EDMA_ERR_DEV)
+		err_mask |= AC_ERR_DEV;
+	if (edma_err_cause & (EDMA_ERR_D_PAR | EDMA_ERR_PRD_PAR |
+			EDMA_ERR_CRQB_PAR | EDMA_ERR_CRPB_PAR |
+			EDMA_ERR_INTRL_PAR)) {
+		err_mask |= AC_ERR_ATA_BUS;
+		action |= ATA_EH_HARDRESET;
+		ata_ehi_push_desc(ehi, "parity error");
+	}
+	if (edma_err_cause & (EDMA_ERR_DEV_DCON | EDMA_ERR_DEV_CON)) {
+		ata_ehi_hotplugged(ehi);
+		ata_ehi_push_desc(ehi, edma_err_cause & EDMA_ERR_DEV_DCON ?
+			"dev disconnect" : "dev connect");
@@ -1345,3 +1443,24 @@
-	if (EDMA_ERR_SELF_DIS & edma_err_cause) {
-		struct mv_port_priv *pp	= ap->private_data;
-		pp->pp_flags &= ~MV_PP_FLAG_EDMA_EN;
+
+	if (IS_GEN_I(hpriv)) {
+		eh_freeze_mask = EDMA_EH_FREEZE_5;
+
+		if (edma_err_cause & EDMA_ERR_SELF_DIS_5) {
+			struct mv_port_priv *pp	= ap->private_data;
+			pp->pp_flags &= ~MV_PP_FLAG_EDMA_EN;
+			ata_ehi_push_desc(ehi, "EDMA self-disable");
+		}
+	} else {
+		eh_freeze_mask = EDMA_EH_FREEZE;
+
+		if (edma_err_cause & EDMA_ERR_SELF_DIS) {
+			struct mv_port_priv *pp	= ap->private_data;
+			pp->pp_flags &= ~MV_PP_FLAG_EDMA_EN;
+			ata_ehi_push_desc(ehi, "EDMA self-disable");
+		}
+
+		if (edma_err_cause & EDMA_ERR_SERR) {
+			sata_scr_read(ap, SCR_ERROR, &serr);
+			sata_scr_write_flush(ap, SCR_ERROR, serr);
+			err_mask = AC_ERR_ATA_BUS;
+			action |= ATA_EH_HARDRESET;
+		}
@@ -1349,2 +1467,0 @@
-	DPRINTK(KERN_ERR "ata%u: port error; EDMA err cause: 0x%08x "
-		"SERR: 0x%08x\n", ap->print_id, edma_err_cause, serr);
@@ -1355,3 +1472,111 @@
-	/* check for fatal here and recover if needed */
-	if (reset_allowed && (EDMA_ERR_FATAL & edma_err_cause))
-		mv_stop_and_reset(ap);
+	if (!err_mask) {
+		err_mask = AC_ERR_OTHER;
+		action |= ATA_EH_HARDRESET;
+	}
+
+	ehi->serror |= serr;
+	ehi->action |= action;
+
+	if (qc)
+		qc->err_mask |= err_mask;
+	else
+		ehi->err_mask |= err_mask;
+
+	if (edma_err_cause & eh_freeze_mask)
+		ata_port_freeze(ap);
+	else
+		ata_port_abort(ap);
+}
+
+static void mv_intr_pio(struct ata_port *ap)
+{
+	struct ata_queued_cmd *qc;
+	u8 ata_status;
+
+	/* ignore spurious intr if drive still BUSY */
+	ata_status = readb(ap->ioaddr.status_addr);
+	if (unlikely(ata_status & ATA_BUSY))
+		return;
+
+	/* get active ATA command */
+	qc = ata_qc_from_tag(ap, ap->active_tag);
+	if (unlikely(!qc))			/* no active tag */
+		return;
+	if (qc->tf.flags & ATA_TFLAG_POLLING)	/* polling; we don't own qc */
+		return;
+
+	/* and finally, complete the ATA command */
+	qc->err_mask |= ac_err_mask(ata_status);
+	ata_qc_complete(qc);
+}
+
+static void mv_intr_edma(struct ata_port *ap)
+{
+	void __iomem *port_mmio = mv_ap_base(ap);
+	struct mv_host_priv *hpriv = ap->host->private_data;
+	struct mv_port_priv *pp = ap->private_data;
+	struct ata_queued_cmd *qc;
+	u32 out_index, in_index;
+	bool work_done = false;
+
+	/* get h/w response queue pointer */
+	in_index = (readl(port_mmio + EDMA_RSP_Q_IN_PTR_OFS)
+			>> EDMA_RSP_Q_PTR_SHIFT) & MV_MAX_Q_DEPTH_MASK;
+
+	while (1) {
+		u16 status;
+		unsigned int tag;
+
+		/* get s/w response queue last-read pointer, and compare */
+		out_index = pp->resp_idx & MV_MAX_Q_DEPTH_MASK;
+		if (in_index == out_index)
+			break;
+
+		/* 50xx: get active ATA command */
+		if (IS_GEN_I(hpriv))
+			tag = ap->active_tag;
+
+		/* Gen II/IIE: get active ATA command via tag, to enable
+		 * support for queueing.  this works transparently for
+		 * queued and non-queued modes.
+		 */
+		else if (IS_GEN_II(hpriv))
+			tag = (le16_to_cpu(pp->crpb[out_index].id)
+				>> CRPB_IOID_SHIFT_6) & 0x3f;
+
+		else /* IS_GEN_IIE */
+			tag = (le16_to_cpu(pp->crpb[out_index].id)
+				>> CRPB_IOID_SHIFT_7) & 0x3f;
+
+		qc = ata_qc_from_tag(ap, tag);
+
+		/* lower 8 bits of status are EDMA_ERR_IRQ_CAUSE_OFS
+		 * bits (WARNING: might not necessarily be associated
+		 * with this command), which -should- be clear
+		 * if all is well
+		 */
+		status = le16_to_cpu(pp->crpb[out_index].flags);
+		if (unlikely(status & 0xff)) {
+			mv_err_intr(ap, qc);
+			return;
+		}
+
+		/* and finally, complete the ATA command */
+		if (qc) {
+			qc->err_mask |=
+				ac_err_mask(status >> CRPB_FLAG_STATUS_SHIFT);
+			ata_qc_complete(qc);
+		}
+
+		/* advance software response queue pointer, to
+		 * indicate (after the loop completes) to hardware
+		 * that we have consumed a response queue entry.
+		 */
+		work_done = true;
+		pp->resp_idx++;
+	}
+
+	if (work_done)
+		writelfl((pp->crpb_dma & EDMA_RSP_Q_BASE_LO_MASK) |
+			 (out_index << EDMA_RSP_Q_PTR_SHIFT),
+			 port_mmio + EDMA_RSP_Q_OUT_PTR_OFS);
@@ -1380 +1604,0 @@
-	struct ata_queued_cmd *qc;
@@ -1382,2 +1606 @@
-	int shift, port, port0, hard_port, handled;
-	unsigned int err_mask;
+	int port, port0;
@@ -1392,2 +1615,4 @@
-	if (hc_irq_cause)
-		writelfl(~hc_irq_cause, hc_mmio + HC_IRQ_CAUSE_OFS);
+	if (!hc_irq_cause)
+		return;
+
+	writelfl(~hc_irq_cause, hc_mmio + HC_IRQ_CAUSE_OFS);
@@ -1399 +1623,0 @@
-		u8 ata_status = 0;
@@ -1401,0 +1626,21 @@
+		int have_err_bits, hard_port, shift;
+
+		if ((!ap) || (ap->flags & ATA_FLAG_DISABLED))
+			continue;
+
+		shift = port << 1;		/* (port * 2) */
+		if (port >= MV_PORTS_PER_HC) {
+			shift++;	/* skip bit 8 in the HC Main IRQ reg */
+		}
+		have_err_bits = ((PORT0_ERR << shift) & relevant);
+
+		if (unlikely(have_err_bits)) {
+			struct ata_queued_cmd *qc;
+
+			qc = ata_qc_from_tag(ap, ap->active_tag);
+			if (qc && (qc->tf.flags & ATA_TFLAG_POLLING))
+				continue;
+
+			mv_err_intr(ap, qc);
+			continue;
+		}
@@ -1404 +1648,0 @@
-		handled = 0;	/* ensure ata_status is set if handled++ */
@@ -1406,4 +1649,0 @@
-		/* Note that DEV_IRQ might happen spuriously during EDMA,
-		 * and should be ignored in such cases.
-		 * The cause of this is still under investigation.
-		 */
@@ -1411,5 +1651,2 @@
-			/* EDMA: check for response queue interrupt */
-			if ((CRPB_DMA_DONE << hard_port) & hc_irq_cause) {
-				ata_status = mv_get_crpb_status(ap);
-				handled = 1;
-			}
+			if ((CRPB_DMA_DONE << hard_port) & hc_irq_cause)
+				mv_intr_edma(ap);
@@ -1417,10 +1654,2 @@
-			/* PIO: check for device (drive) interrupt */
-			if ((DEV_IRQ << hard_port) & hc_irq_cause) {
-				ata_status = readb(ap->ioaddr.status_addr);
-				handled = 1;
-				/* ignore spurious intr if drive still BUSY */
-				if (ata_status & ATA_BUSY) {
-					ata_status = 0;
-					handled = 0;
-				}
-			}
+			if ((DEV_IRQ << hard_port) & hc_irq_cause)
+				mv_intr_pio(ap);
@@ -1427,0 +1657,3 @@
+	}
+	VPRINTK("EXIT\n");
+}
@@ -1429,2 +1661,7 @@
-		if (ap && (ap->flags & ATA_FLAG_DISABLED))
-			continue;
+static void mv_pci_error(struct ata_host *host, void __iomem *mmio)
+{
+	struct ata_port *ap;
+	struct ata_queued_cmd *qc;
+	struct ata_eh_info *ehi;
+	unsigned int i, err_mask, printed = 0;
+	u32 err_cause;
@@ -1432 +1669 @@
-		err_mask = ac_err_mask(ata_status);
+	err_cause = readl(mmio + PCI_IRQ_CAUSE_OFS);
@@ -1434,9 +1671,7 @@
-		shift = port << 1;		/* (port * 2) */
-		if (port >= MV_PORTS_PER_HC) {
-			shift++;	/* skip bit 8 in the HC Main IRQ reg */
-		}
-		if ((PORT0_ERR << shift) & relevant) {
-			mv_err_intr(ap, 1);
-			err_mask |= AC_ERR_OTHER;
-			handled = 1;
-		}
+	dev_printk(KERN_ERR, host->dev, "PCI ERROR; PCI IRQ cause=0x%08x\n",
+		   err_cause);
+
+	DPRINTK("All regs @ PCI error\n");
+	mv_dump_all_regs(mmio, -1, to_pci_dev(host->dev));
+
+	writelfl(0, mmio + PCI_IRQ_CAUSE_OFS);
@@ -1444 +1679,10 @@
-		if (handled) {
+	for (i = 0; i < host->n_ports; i++) {
+		ap = host->ports[i];
+		if (!ata_port_offline(ap)) {
+			ehi = &ap->eh_info;
+			ata_ehi_clear_desc(ehi);
+			if (!printed++)
+				ata_ehi_push_desc(ehi,
+					"PCI err cause 0x%08x", err_cause);
+			err_mask = AC_ERR_HOST_BUS;
+			ehi->action = ATA_EH_HARDRESET;
@@ -1446,9 +1690,6 @@
-			if (qc && (qc->flags & ATA_QCFLAG_ACTIVE)) {
-				VPRINTK("port %u IRQ found for qc, "
-					"ata_status 0x%x\n", port,ata_status);
-				/* mark qc status appropriately */
-				if (!(qc->tf.flags & ATA_TFLAG_POLLING)) {
-					qc->err_mask |= err_mask;
-					ata_qc_complete(qc);
-				}
-			}
+			if (qc)
+				qc->err_mask |= err_mask;
+			else
+				ehi->err_mask |= err_mask;
+
+			ata_port_freeze(ap);
@@ -1457 +1697,0 @@
-	VPRINTK("EXIT\n");
@@ -1461 +1701 @@
- *      mv_interrupt -
+ *      mv_interrupt - Main interrupt event handler
@@ -1464 +1703,0 @@
- *      @regs: unused
@@ -1480 +1718,0 @@
-	struct mv_host_priv *hpriv;
@@ -1493,0 +1732,6 @@
+	if (unlikely(irq_stat & PCI_ERR)) {
+		mv_pci_error(host, mmio);
+		handled = 1;
+		goto out_unlock;	/* skip all other HC irq handling */
+	}
+
@@ -1498,11 +1742 @@
-			handled++;
-		}
-	}
-
-	hpriv = host->private_data;
-	if (IS_60XX(hpriv)) {
-		/* deal with the interrupt coalescing bits */
-		if (irq_stat & (TRAN_LO_DONE | TRAN_HI_DONE | PORTS_0_7_COAL_DONE)) {
-			writelfl(0, mmio + MV_IRQ_COAL_CAUSE_LO);
-			writelfl(0, mmio + MV_IRQ_COAL_CAUSE_HI);
-			writelfl(0, mmio + MV_IRQ_COAL_CAUSE);
+			handled = 1;
@@ -1512,10 +1746 @@
-	if (PCI_ERR & irq_stat) {
-		printk(KERN_ERR DRV_NAME ": PCI ERROR; PCI IRQ cause=0x%08x\n",
-		       readl(mmio + PCI_IRQ_CAUSE_OFS));
-
-		DPRINTK("All regs @ PCI error\n");
-		mv_dump_all_regs(mmio, -1, to_pci_dev(host->dev));
-
-		writelfl(0, mmio + PCI_IRQ_CAUSE_OFS);
-		handled++;
-	}
+out_unlock:
@@ -1552 +1777 @@
-static u32 mv5_scr_read(struct ata_port *ap, unsigned int sc_reg_in)
+static int mv5_scr_read(struct ata_port *ap, unsigned int sc_reg_in, u32 *val)
@@ -1558,4 +1783,5 @@
-	if (ofs != 0xffffffffU)
-		return readl(addr + ofs);
-	else
-		return (u32) ofs;
+	if (ofs != 0xffffffffU) {
+		*val = readl(addr + ofs);
+		return 0;
+	} else
+		return -EINVAL;
@@ -1564 +1790 @@
-static void mv5_scr_write(struct ata_port *ap, unsigned int sc_reg_in, u32 val)
+static int mv5_scr_write(struct ata_port *ap, unsigned int sc_reg_in, u32 val)
@@ -1570 +1796 @@
-	if (ofs != 0xffffffffU)
+	if (ofs != 0xffffffffU) {
@@ -1571,0 +1798,3 @@
+		return 0;
+	} else
+		return -EINVAL;
@@ -1576 +1804,0 @@
-	u8 rev_id;
@@ -1579,3 +1807 @@
-	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
-
-	early_5080 = (pdev->device == 0x5080) && (rev_id == 0);
+	early_5080 = (pdev->device == 0x5080) && (pdev->revision == 0);
@@ -1910 +2136 @@
-	if (IS_60XX(hpriv)) {
+	if (IS_GEN_II(hpriv)) {
@@ -1926 +2152 @@
-	if (IS_50XX(hpriv))
+	if (IS_GEN_I(hpriv))
@@ -1930,20 +2155,0 @@
-static void mv_stop_and_reset(struct ata_port *ap)
-{
-	struct mv_host_priv *hpriv = ap->host->private_data;
-	void __iomem *mmio = ap->host->iomap[MV_PRIMARY_BAR];
-
-	mv_stop_dma(ap);
-
-	mv_channel_reset(hpriv, mmio, ap->port_no);
-
-	__mv_phy_reset(ap, 0);
-}
-
-static inline void __msleep(unsigned int msec, int can_sleep)
-{
-	if (can_sleep)
-		msleep(msec);
-	else
-		mdelay(msec);
-}
-
@@ -1951 +2157 @@
- *      __mv_phy_reset - Perform eDMA reset followed by COMRESET
+ *      mv_phy_reset - Perform eDMA reset followed by COMRESET
@@ -1961 +2167,2 @@
-static void __mv_phy_reset(struct ata_port *ap, int can_sleep)
+static void mv_phy_reset(struct ata_port *ap, unsigned int *class,
+			 unsigned long deadline)
@@ -1966,3 +2172,0 @@
-	struct ata_taskfile tf;
-	struct ata_device *dev = &ap->device[0];
-	unsigned long timeout;
@@ -1974,3 +2178,11 @@
-	DPRINTK("S-regs after ATA_RST: SStat 0x%08x SErr 0x%08x "
-		"SCtrl 0x%08x\n", mv_scr_read(ap, SCR_STATUS),
-		mv_scr_read(ap, SCR_ERROR), mv_scr_read(ap, SCR_CONTROL));
+#ifdef DEBUG
+	{
+		u32 sstatus, serror, scontrol;
+
+		mv_scr_read(ap, SCR_STATUS, &sstatus);
+		mv_scr_read(ap, SCR_ERROR, &serror);
+		mv_scr_read(ap, SCR_CONTROL, &scontrol);
+		DPRINTK("S-regs after ATA_RST: SStat 0x%08x SErr 0x%08x "
+			"SCtrl 0x%08x\n", status, serror, scontrol);
+	}
+#endif
@@ -1981 +2193 @@
-	__msleep(1, can_sleep);
+	msleep(1);
@@ -1984 +2196 @@
-	__msleep(20, can_sleep);
+	msleep(20);
@@ -1986 +2197,0 @@
-	timeout = jiffies + msecs_to_jiffies(200);
@@ -1992,2 +2203,2 @@
-		__msleep(1, can_sleep);
-	} while (time_before(jiffies, timeout));
+		msleep(1);
+	} while (time_before(jiffies, deadline));
@@ -1996 +2207 @@
-	if (IS_60XX(hpriv) &&
+	if (IS_GEN_II(hpriv) &&
@@ -2001,3 +2212,11 @@
-	DPRINTK("S-regs after PHY wake: SStat 0x%08x SErr 0x%08x "
-		"SCtrl 0x%08x\n", mv_scr_read(ap, SCR_STATUS),
-		mv_scr_read(ap, SCR_ERROR), mv_scr_read(ap, SCR_CONTROL));
+#ifdef DEBUG
+	{
+		u32 sstatus, serror, scontrol;
+
+		mv_scr_read(ap, SCR_STATUS, &sstatus);
+		mv_scr_read(ap, SCR_ERROR, &serror);
+		mv_scr_read(ap, SCR_CONTROL, &scontrol);
+		DPRINTK("S-regs after PHY wake: SStat 0x%08x SErr 0x%08x "
+			"SCtrl 0x%08x\n", sstatus, serror, scontrol);
+	}
+#endif
@@ -2005,7 +2224,2 @@
-	if (ata_port_online(ap)) {
-		ata_port_probe(ap);
-	} else {
-		sata_scr_read(ap, SCR_STATUS, &sstatus);
-		ata_port_printk(ap, KERN_INFO,
-				"no device found (phy stat %08x)\n", sstatus);
-		ata_port_disable(ap);
+	if (ata_port_offline(ap)) {
+		*class = ATA_DEV_NONE;
@@ -2025 +2239 @@
-		__msleep(500, can_sleep);
+		msleep(500);
@@ -2027,0 +2242,2 @@
+		if (time_after(jiffies, deadline))
+			break;
@@ -2030,10 +2246,6 @@
-	tf.lbah = readb(ap->ioaddr.lbah_addr);
-	tf.lbam = readb(ap->ioaddr.lbam_addr);
-	tf.lbal = readb(ap->ioaddr.lbal_addr);
-	tf.nsect = readb(ap->ioaddr.nsect_addr);
-
-	dev->class = ata_dev_classify(&tf);
-	if (!ata_dev_enabled(dev)) {
-		VPRINTK("Port disabled post-sig: No device present.\n");
-		ata_port_disable(ap);
-	}
+	/* FIXME: if we passed the deadline, the following
+	 * code probably produces an invalid result
+	 */
+
+	/* finally, read device signature from TF registers */
+	*class = ata_dev_try_classify(ap, 0, NULL);
@@ -2043 +2255 @@
-	pp->pp_flags &= ~MV_PP_FLAG_EDMA_EN;
+	WARN_ON(pp->pp_flags & MV_PP_FLAG_EDMA_EN);
@@ -2048 +2260 @@
-static void mv_phy_reset(struct ata_port *ap)
+static int mv_prereset(struct ata_port *ap, unsigned long deadline)
@@ -2050 +2262,23 @@
-	__mv_phy_reset(ap, 1);
+	struct mv_port_priv *pp	= ap->private_data;
+	struct ata_eh_context *ehc = &ap->eh_context;
+	int rc;
+
+	rc = mv_stop_dma(ap);
+	if (rc)
+		ehc->i.action |= ATA_EH_HARDRESET;
+
+	if (!(pp->pp_flags & MV_PP_FLAG_HAD_A_RESET)) {
+		pp->pp_flags |= MV_PP_FLAG_HAD_A_RESET;
+		ehc->i.action |= ATA_EH_HARDRESET;
+	}
+
+	/* if we're about to do hardreset, nothing more to do */
+	if (ehc->i.action & ATA_EH_HARDRESET)
+		return 0;
+
+	if (ata_port_online(ap))
+		rc = ata_wait_ready(ap, deadline);
+	else
+		rc = -ENODEV;
+
+	return rc;
@@ -2053,11 +2287,2 @@
-/**
- *      mv_eng_timeout - Routine called by libata when SCSI times out I/O
- *      @ap: ATA channel to manipulate
- *
- *      Intent is to clear all pending error conditions, reset the
- *      chip/bus, fail the command, and move on.
- *
- *      LOCKING:
- *      This routine holds the host lock while failing the command.
- */
-static void mv_eng_timeout(struct ata_port *ap)
+static int mv_hardreset(struct ata_port *ap, unsigned int *class,
+			unsigned long deadline)
@@ -2064,0 +2290 @@
+	struct mv_host_priv *hpriv = ap->host->private_data;
@@ -2066,2 +2291,0 @@
-	struct ata_queued_cmd *qc;
-	unsigned long flags;
@@ -2069,3 +2293,3 @@
-	ata_port_printk(ap, KERN_ERR, "Entering mv_eng_timeout\n");
-	DPRINTK("All regs @ start of eng_timeout\n");
-	mv_dump_all_regs(mmio, ap->port_no, to_pci_dev(ap->host->dev));
+	mv_stop_dma(ap);
+
+	mv_channel_reset(hpriv, mmio, ap->port_no);
@@ -2073,3 +2297 @@
-	qc = ata_qc_from_tag(ap, ap->active_tag);
-        printk(KERN_ERR "mmio_base %p ap %p qc %p scsi_cmnd %p &cmnd %p\n",
-	       mmio, ap, qc, qc->scsicmd, &qc->scsicmd->cmnd);
+	mv_phy_reset(ap, class, deadline);
@@ -2077,4 +2299,41 @@
-	spin_lock_irqsave(&ap->host->lock, flags);
-	mv_err_intr(ap, 0);
-	mv_stop_and_reset(ap);
-	spin_unlock_irqrestore(&ap->host->lock, flags);
+	return 0;
+}
+
+static void mv_postreset(struct ata_port *ap, unsigned int *classes)
+{
+	u32 serr;
+
+	/* print link status */
+	sata_print_link_status(ap);
+
+	/* clear SError */
+	sata_scr_read(ap, SCR_ERROR, &serr);
+	sata_scr_write_flush(ap, SCR_ERROR, serr);
+
+	/* bail out if no device is present */
+	if (classes[0] == ATA_DEV_NONE && classes[1] == ATA_DEV_NONE) {
+		DPRINTK("EXIT, no device\n");
+		return;
+	}
+
+	/* set up device control */
+	iowrite8(ap->ctl, ap->ioaddr.ctl_addr);
+}
+
+static void mv_error_handler(struct ata_port *ap)
+{
+	ata_do_eh(ap, mv_prereset, ata_std_softreset,
+		  mv_hardreset, mv_postreset);
+}
+
+static void mv_post_int_cmd(struct ata_queued_cmd *qc)
+{
+	mv_stop_dma(qc->ap);
+}
+
+static void mv_eh_freeze(struct ata_port *ap)
+{
+	void __iomem *mmio = ap->host->iomap[MV_PRIMARY_BAR];
+	unsigned int hc = (ap->port_no > 3) ? 1 : 0;
+	u32 tmp, mask;
+	unsigned int shift;
@@ -2082,4 +2341,28 @@
-	WARN_ON(!(qc->flags & ATA_QCFLAG_ACTIVE));
-	if (qc->flags & ATA_QCFLAG_ACTIVE) {
-		qc->err_mask |= AC_ERR_TIMEOUT;
-		ata_eh_qc_complete(qc);
+	/* FIXME: handle coalescing completion events properly */
+
+	shift = ap->port_no * 2;
+	if (hc > 0)
+		shift++;
+
+	mask = 0x3 << shift;
+
+	/* disable assertion of portN err, done events */
+	tmp = readl(mmio + HC_MAIN_IRQ_MASK_OFS);
+	writelfl(tmp & ~mask, mmio + HC_MAIN_IRQ_MASK_OFS);
+}
+
+static void mv_eh_thaw(struct ata_port *ap)
+{
+	void __iomem *mmio = ap->host->iomap[MV_PRIMARY_BAR];
+	unsigned int hc = (ap->port_no > 3) ? 1 : 0;
+	void __iomem *hc_mmio = mv_hc_base(mmio, hc);
+	void __iomem *port_mmio = mv_ap_base(ap);
+	u32 tmp, mask, hc_irq_cause;
+	unsigned int shift, hc_port_no = ap->port_no;
+
+	/* FIXME: handle coalescing completion events properly */
+
+	shift = ap->port_no * 2;
+	if (hc > 0) {
+		shift++;
+		hc_port_no -= 4;
@@ -2086,0 +2370,15 @@
+
+	mask = 0x3 << shift;
+
+	/* clear EDMA errors on this port */
+	writel(0, port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
+
+	/* clear pending irq events */
+	hc_irq_cause = readl(hc_mmio + HC_IRQ_CAUSE_OFS);
+	hc_irq_cause &= ~(1 << hc_port_no);	/* clear CRPB-done */
+	hc_irq_cause &= ~(1 << (hc_port_no + 8)); /* clear Device int */
+	writel(hc_irq_cause, hc_mmio + HC_IRQ_CAUSE_OFS);
+
+	/* enable assertion of portN err, done events */
+	tmp = readl(mmio + HC_MAIN_IRQ_MASK_OFS);
+	writelfl(tmp | mask, mmio + HC_MAIN_IRQ_MASK_OFS);
@@ -2142 +2439,0 @@
-	u8 rev_id;
@@ -2145,2 +2441,0 @@
-	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
-
@@ -2150 +2445 @@
-		hp_flags |= MV_HP_50XX;
+		hp_flags |= MV_HP_GEN_I;
@@ -2152 +2447 @@
-		switch (rev_id) {
+		switch (pdev->revision) {
@@ -2170 +2465 @@
-		hp_flags |= MV_HP_50XX;
+		hp_flags |= MV_HP_GEN_I;
@@ -2172 +2467 @@
-		switch (rev_id) {
+		switch (pdev->revision) {
@@ -2189,0 +2485 @@
+		hp_flags |= MV_HP_GEN_II;
@@ -2191 +2487 @@
-		switch (rev_id) {
+		switch (pdev->revision) {
@@ -2209 +2504,0 @@
-
@@ -2212 +2507 @@
-		switch (rev_id) {
+		switch (pdev->revision) {
@@ -2276 +2571 @@
-		if (IS_60XX(hpriv)) {
+		if (IS_GEN_II(hpriv)) {
@@ -2311 +2606 @@
-	if (IS_50XX(hpriv))
+	if (IS_GEN_I(hpriv))
@@ -2340,2 +2635,2 @@
-	u8 rev_id, scc;
-	const char *scc_s;
+	u8 scc;
+	const char *scc_s, *gen;
@@ -2346,2 +2640,0 @@
-	pci_read_config_byte(pdev, PCI_REVISION_ID, &rev_id);
-
@@ -2354 +2647,10 @@
-		scc_s = "unknown";
+		scc_s = "?";
+
+	if (IS_GEN_I(hpriv))
+		gen = "I";
+	else if (IS_GEN_II(hpriv))
+		gen = "II";
+	else if (IS_GEN_IIE(hpriv))
+		gen = "IIE";
+	else
+		gen = "?";
@@ -2357,2 +2659,2 @@
-	       "%u slots %u ports %s mode IRQ via %s\n",
-	       (unsigned)MV_MAX_Q_DEPTH, host->n_ports,
+	       "Gen-%s %u slots %u ports %s mode IRQ via %s\n",
+	       gen, (unsigned)MV_MAX_Q_DEPTH, host->n_ports,
@@ -2419,0 +2722 @@
+	pci_try_set_mwi(pdev);
@@ -2421 +2724 @@
-				 &mv_sht);
+				 IS_GEN_I(hpriv) ? &mv5_sht : &mv6_sht);
--- ./projects/linux/linux-2.6.23/drivers/ata/sata_mv.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/ata/sata_mv.c	2008-01-24 23:58:37.000000000 +0100
@@ -71,0 +72 @@
+#include <scsi/scsi_device.h>
@@ -75 +76 @@
-#define DRV_VERSION	"1.0"
+#define DRV_VERSION	"1.01"
@@ -166,2 +167,2 @@
-	PCI_IRQ_CAUSE_OFS		= 0x1d58,
-	PCI_IRQ_MASK_OFS		= 0x1d5c,
+	PCI_IRQ_CAUSE_OFS	= 0x1d58,
+	PCI_IRQ_MASK_OFS	= 0x1d5c,
@@ -169,0 +171,4 @@
+	PCIE_IRQ_CAUSE_OFS	= 0x1900,
+	PCIE_IRQ_MASK_OFS	= 0x1910,
+	PCIE_UNMASK_ALL_IRQS	= 0x70a,	/* assorted bits */
+
@@ -304,0 +310 @@
+	MV_HP_PCIE		= (1 << 9),	/* PCIe bus/regs: 7042 */
@@ -390 +396,9 @@
-struct mv_host_priv;
+struct mv_host_priv {
+	u32			hp_flags;
+	struct mv_port_signal	signal[8];
+	const struct mv_hw_ops	*ops;
+	u32			irq_cause_ofs;
+	u32			irq_mask_ofs;
+	u32			unmask_all_irqs;
+};
+
@@ -403,6 +416,0 @@
-struct mv_host_priv {
-	u32			hp_flags;
-	struct mv_port_signal	signal[8];
-	const struct mv_hw_ops	*ops;
-};
-
@@ -484,2 +491,0 @@
-	.port_disable		= ata_port_disable,
-
@@ -500 +505,0 @@
-	.irq_ack		= ata_irq_ack,
@@ -515,2 +519,0 @@
-	.port_disable		= ata_port_disable,
-
@@ -531 +533,0 @@
-	.irq_ack		= ata_irq_ack,
@@ -546,2 +547,0 @@
-	.port_disable		= ata_port_disable,
-
@@ -562 +561,0 @@
-	.irq_ack		= ata_irq_ack,
@@ -642,3 +641 @@
-	{ PCI_VDEVICE(TTI, 0x2310), chip_7042 },
-
-	/* add Marvell 7042 support */
+	/* Marvell 7042 support */
@@ -646,0 +644,4 @@
+	/* Highpoint RocketRAID PCIe series */
+	{ PCI_VDEVICE(TTI, 0x2300), chip_7042 },
+	{ PCI_VDEVICE(TTI, 0x2310), chip_7042 },
+
@@ -856 +857 @@
-  	}
+	}
@@ -894 +895 @@
-			printk("%08x ",readl(start + b));
+			printk("%08x ", readl(start + b));
@@ -910,2 +911,2 @@
-			(void) pci_read_config_dword(pdev,b,&dw);
-			printk("%08x ",dw);
+			(void) pci_read_config_dword(pdev, b, &dw);
+			printk("%08x ", dw);
@@ -955 +956 @@
-		DPRINTK("EDMA regs (port %i):\n",p);
+		DPRINTK("EDMA regs (port %i):\n", p);
@@ -957 +958 @@
-		DPRINTK("SATA regs (port %i):\n",p);
+		DPRINTK("SATA regs (port %i):\n", p);
@@ -1133 +1134 @@
-static unsigned int mv_fill_sg(struct ata_queued_cmd *qc)
+static void mv_fill_sg(struct ata_queued_cmd *qc)
@@ -1136 +1136,0 @@
-	unsigned int n_sg = 0;
@@ -1138 +1138 @@
-	struct mv_sg *mv_sg;
+	struct mv_sg *mv_sg, *last_sg = NULL;
@@ -1154 +1154 @@
-			mv_sg->flags_size = cpu_to_le32(len);
+			mv_sg->flags_size = cpu_to_le32(len & 0xffff);
@@ -1159,3 +1159 @@
-			if (!sg_len && ata_sg_is_last(sg, qc))
-				mv_sg->flags_size |= cpu_to_le32(EPRD_FLAG_END_OF_TBL);
-
+			last_sg = mv_sg;
@@ -1163 +1160,0 @@
-			n_sg++;
@@ -1165 +1161,0 @@
-
@@ -1168 +1164,2 @@
-	return n_sg;
+	if (likely(last_sg))
+		last_sg->flags_size |= cpu_to_le32(EPRD_FLAG_END_OF_TBL);
@@ -1171 +1168 @@
-static inline void mv_crqb_pack_cmd(__le16 *cmdw, u8 data, u8 addr, unsigned last)
+static void mv_crqb_pack_cmd(__le16 *cmdw, u8 data, u8 addr, unsigned last)
@@ -1199 +1196 @@
- 	if (qc->tf.protocol != ATA_PROT_DMA)
+	if (qc->tf.protocol != ATA_PROT_DMA)
@@ -1291 +1288 @@
- 	if (qc->tf.protocol != ATA_PROT_DMA)
+	if (qc->tf.protocol != ATA_PROT_DMA)
@@ -1409 +1406 @@
-	struct ata_eh_info *ehi = &ap->eh_info;
+	struct ata_eh_info *ehi = &ap->link.eh_info;
@@ -1417,2 +1414,2 @@
-		sata_scr_read(ap, SCR_ERROR, &serr);
-		sata_scr_write_flush(ap, SCR_ERROR, serr);
+		sata_scr_read(&ap->link, SCR_ERROR, &serr);
+		sata_scr_write_flush(&ap->link, SCR_ERROR, serr);
@@ -1462,2 +1459,2 @@
-			sata_scr_read(ap, SCR_ERROR, &serr);
-			sata_scr_write_flush(ap, SCR_ERROR, serr);
+			sata_scr_read(&ap->link, SCR_ERROR, &serr);
+			sata_scr_write_flush(&ap->link, SCR_ERROR, serr);
@@ -1502 +1499 @@
-	qc = ata_qc_from_tag(ap, ap->active_tag);
+	qc = ata_qc_from_tag(ap, ap->link.active_tag);
@@ -1537 +1534 @@
-			tag = ap->active_tag;
+			tag = ap->link.active_tag;
@@ -1621 +1618 @@
-		hc,relevant,hc_irq_cause);
+		hc, relevant, hc_irq_cause);
@@ -1640 +1637 @@
-			qc = ata_qc_from_tag(ap, ap->active_tag);
+			qc = ata_qc_from_tag(ap, ap->link.active_tag);
@@ -1662,0 +1660 @@
+	struct mv_host_priv *hpriv = host->private_data;
@@ -1669 +1667 @@
-	err_cause = readl(mmio + PCI_IRQ_CAUSE_OFS);
+	err_cause = readl(mmio + hpriv->irq_cause_ofs);
@@ -1677 +1675 @@
-	writelfl(0, mmio + PCI_IRQ_CAUSE_OFS);
+	writelfl(0, mmio + hpriv->irq_cause_ofs);
@@ -1681,2 +1679,2 @@
-		if (!ata_port_offline(ap)) {
-			ehi = &ap->eh_info;
+		if (!ata_link_offline(&ap->link)) {
+			ehi = &ap->link.eh_info;
@@ -1689 +1687 @@
-			qc = ata_qc_from_tag(ap, ap->active_tag);
+			qc = ata_qc_from_tag(ap, ap->link.active_tag);
@@ -1940,0 +1939,2 @@
+	struct ata_host     *host = dev_get_drvdata(&pdev->dev);
+	struct mv_host_priv *hpriv = host->private_data;
@@ -1952,2 +1952,2 @@
-	ZERO(PCI_IRQ_CAUSE_OFS);
-	ZERO(PCI_IRQ_MASK_OFS);
+	ZERO(hpriv->irq_cause_ofs);
+	ZERO(hpriv->irq_mask_ofs);
@@ -1998 +1998 @@
-		if (PCI_MASTER_EMPTY & t) {
+		if (PCI_MASTER_EMPTY & t)
@@ -2000 +1999,0 @@
-		}
@@ -2186 +2185 @@
-			"SCtrl 0x%08x\n", status, serror, scontrol);
+			"SCtrl 0x%08x\n", sstatus, serror, scontrol);
@@ -2192 +2191 @@
-	sata_scr_write_flush(ap, SCR_CONTROL, 0x301);
+	sata_scr_write_flush(&ap->link, SCR_CONTROL, 0x301);
@@ -2195 +2194 @@
-	sata_scr_write_flush(ap, SCR_CONTROL, 0x300);
+	sata_scr_write_flush(&ap->link, SCR_CONTROL, 0x300);
@@ -2199 +2198 @@
-		sata_scr_read(ap, SCR_STATUS, &sstatus);
+		sata_scr_read(&ap->link, SCR_STATUS, &sstatus);
@@ -2224 +2223 @@
-	if (ata_port_offline(ap)) {
+	if (ata_link_offline(&ap->link)) {
@@ -2251 +2250 @@
-	*class = ata_dev_try_classify(ap, 0, NULL);
+	*class = ata_dev_try_classify(ap->link.device, 1, NULL);
@@ -2260 +2259 @@
-static int mv_prereset(struct ata_port *ap, unsigned long deadline)
+static int mv_prereset(struct ata_link *link, unsigned long deadline)
@@ -2261,0 +2261 @@
+	struct ata_port *ap = link->ap;
@@ -2263 +2263 @@
-	struct ata_eh_context *ehc = &ap->eh_context;
+	struct ata_eh_context *ehc = &link->eh_context;
@@ -2279 +2279 @@
-	if (ata_port_online(ap))
+	if (ata_link_online(link))
@@ -2287 +2287 @@
-static int mv_hardreset(struct ata_port *ap, unsigned int *class,
+static int mv_hardreset(struct ata_link *link, unsigned int *class,
@@ -2289,0 +2290 @@
+	struct ata_port *ap = link->ap;
@@ -2302 +2303 @@
-static void mv_postreset(struct ata_port *ap, unsigned int *classes)
+static void mv_postreset(struct ata_link *link, unsigned int *classes)
@@ -2303,0 +2305 @@
+	struct ata_port *ap = link->ap;
@@ -2307 +2309 @@
-	sata_print_link_status(ap);
+	sata_print_link_status(link);
@@ -2310,2 +2312,2 @@
-	sata_scr_read(ap, SCR_ERROR, &serr);
-	sata_scr_write_flush(ap, SCR_ERROR, serr);
+	sata_scr_read(link, SCR_ERROR, &serr);
+	sata_scr_write_flush(link, SCR_ERROR, serr);
@@ -2442 +2444 @@
-	switch(board_idx) {
+	switch (board_idx) {
@@ -2502,0 +2505,30 @@
+		hp_flags |= MV_HP_PCIE;
+		if (pdev->vendor == PCI_VENDOR_ID_TTI &&
+		    (pdev->device == 0x2300 || pdev->device == 0x2310))
+		{
+			/*
+			 * Highpoint RocketRAID PCIe 23xx series cards:
+			 *
+			 * Unconfigured drives are treated as "Legacy"
+			 * by the BIOS, and it overwrites sector 8 with
+			 * a "Lgcy" metadata block prior to Linux boot.
+			 *
+			 * Configured drives (RAID or JBOD) leave sector 8
+			 * alone, but instead overwrite a high numbered
+			 * sector for the RAID metadata.  This sector can
+			 * be determined exactly, by truncating the physical
+			 * drive capacity to a nice even GB value.
+			 *
+			 * RAID metadata is at: (dev->n_sectors & ~0xfffff)
+			 *
+			 * Warn the user, lest they think we're just buggy.
+			 */
+			printk(KERN_WARNING DRV_NAME ": Highpoint RocketRAID"
+				" BIOS CORRUPTS DATA on all attached drives,"
+				" regardless of if/how they are configured."
+				" BEWARE!\n");
+			printk(KERN_WARNING DRV_NAME ": For data safety, do not"
+				" use sectors 8-9 on \"Legacy\" drives,"
+				" and avoid the final two gigabytes on"
+				" all RocketRAID BIOS initialized drives.\n");
+		}
@@ -2523 +2555,2 @@
-		printk(KERN_ERR DRV_NAME ": BUG: invalid board index %u\n", board_idx);
+		dev_printk(KERN_ERR, &pdev->dev,
+			   "BUG: invalid board index %u\n", board_idx);
@@ -2527,0 +2561,9 @@
+	if (hp_flags & MV_HP_PCIE) {
+		hpriv->irq_cause_ofs	= PCIE_IRQ_CAUSE_OFS;
+		hpriv->irq_mask_ofs	= PCIE_IRQ_MASK_OFS;
+		hpriv->unmask_all_irqs	= PCIE_UNMASK_ALL_IRQS;
+	} else {
+		hpriv->irq_cause_ofs	= PCI_IRQ_CAUSE_OFS;
+		hpriv->irq_mask_ofs	= PCI_IRQ_MASK_OFS;
+		hpriv->unmask_all_irqs	= PCI_UNMASK_ALL_IRQS;
+	}
@@ -2583,0 +2626 @@
+		struct ata_port *ap = host->ports[port];
@@ -2585 +2628,6 @@
-		mv_port_init(&host->ports[port]->ioaddr, port_mmio);
+		unsigned int offset = port_mmio - mmio;
+
+		mv_port_init(&ap->ioaddr, port_mmio);
+
+		ata_port_pbar_desc(ap, MV_PRIMARY_BAR, -1, "mmio");
+		ata_port_pbar_desc(ap, MV_PRIMARY_BAR, offset, "port");
@@ -2601 +2649 @@
-	writelfl(0, mmio + PCI_IRQ_CAUSE_OFS);
+	writelfl(0, mmio + hpriv->irq_cause_ofs);
@@ -2604 +2652 @@
-	writelfl(PCI_UNMASK_ALL_IRQS, mmio + PCI_IRQ_MASK_OFS);
+	writelfl(hpriv->unmask_all_irqs, mmio + hpriv->irq_mask_ofs);
@@ -2615,2 +2663,2 @@
-		readl(mmio + PCI_IRQ_CAUSE_OFS),
-		readl(mmio + PCI_IRQ_MASK_OFS));
+		readl(mmio + hpriv->irq_cause_ofs),
+		readl(mmio + hpriv->irq_mask_ofs));
@@ -2674 +2722 @@
-	static int printed_version = 0;
+	static int printed_version;
--- ./projects/linux/linux-2.6.24/drivers/ata/sata_mv.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/ata/sata_mv.c	2008-04-17 04:49:44.000000000 +0200
@@ -32 +32,7 @@
-  4) Add NCQ support (easy to intermediate, once new-EH support appears)
+  2) Improve/fix IRQ and error handling sequences.
+
+  3) ATAPI support (Marvell claims the 60xx/70xx chips can do it).
+
+  4) Think about TCQ support here, and for libata in general
+  with controllers that suppport it via host-queuing hardware
+  (a software-only implementation could be a nightmare).
@@ -56,2 +61,0 @@
-  13) Verify that 7042 is fully supported.  I only have a 6042.
-
@@ -67,0 +72 @@
+#include <linux/dmapool.h>
@@ -69,0 +75,2 @@
+#include <linux/platform_device.h>
+#include <linux/ata_platform.h>
@@ -76 +83 @@
-#define DRV_VERSION	"1.01"
+#define DRV_VERSION	"1.20"
@@ -110 +116,0 @@
-	 * SG count of 176 leads to MV_PORT_PRIV_DMA_SZ == 4KB
@@ -115 +121 @@
-	MV_MAX_SG_CT		= 176,
+	MV_MAX_SG_CT		= 256,
@@ -117 +122,0 @@
-	MV_PORT_PRIV_DMA_SZ	= (MV_CRQB_Q_SZ + MV_CRPB_Q_SZ + MV_SG_TBL_SZ),
@@ -127,0 +133,3 @@
+	/* SoC integrated controllers, no PCI interface */
+	MV_FLAG_SOC = (1 << 28),
+
@@ -173 +181 @@
-	PCIE_UNMASK_ALL_IRQS	= 0x70a,	/* assorted bits */
+	PCIE_UNMASK_ALL_IRQS	= 0x40a,	/* assorted bits */
@@ -176,0 +185,2 @@
+	HC_SOC_MAIN_IRQ_CAUSE_OFS = 0x20020,
+	HC_SOC_MAIN_IRQ_MASK_OFS = 0x20024,
@@ -191,0 +202 @@
+	HC_MAIN_RSVD_SOC 	= (0x3fffffb << 6),     /* bits 31-9, 7-6 */
@@ -196,0 +208 @@
+	HC_MAIN_MASKED_IRQS_SOC = (PORTS_0_3_COAL_DONE | HC_MAIN_RSVD_SOC),
@@ -212,0 +225 @@
+	SATA_FIS_IRQ_CAUSE_OFS	= 0x364,
@@ -225,5 +238,5 @@
-	EDMA_CFG_Q_DEPTH	= 0,			/* queueing disabled */
-	EDMA_CFG_NCQ		= (1 << 5),
-	EDMA_CFG_NCQ_GO_ON_ERR	= (1 << 14),		/* continue on error */
-	EDMA_CFG_RD_BRST_EXT	= (1 << 11),		/* read burst 512B */
-	EDMA_CFG_WR_BUFF_LEN	= (1 << 13),		/* write buffer 512B */
+	EDMA_CFG_Q_DEPTH	= 0x1f,		/* max device queue depth */
+	EDMA_CFG_NCQ		= (1 << 5),	/* for R/W FPDMA queued */
+	EDMA_CFG_NCQ_GO_ON_ERR	= (1 << 14),	/* continue on error */
+	EDMA_CFG_RD_BRST_EXT	= (1 << 11),	/* read burst 512B */
+	EDMA_CFG_WR_BUFF_LEN	= (1 << 13),	/* write buffer 512B */
@@ -246,0 +260 @@
+
@@ -248 +262,5 @@
-	EDMA_ERR_LNK_CTRL_RX_2	= (1 << 15),
+	EDMA_ERR_LNK_CTRL_RX_0	= (1 << 13),	/* transient: CRC err */
+	EDMA_ERR_LNK_CTRL_RX_1	= (1 << 14),	/* transient: FIFO err */
+	EDMA_ERR_LNK_CTRL_RX_2	= (1 << 15),	/* fatal: caught SYNC */
+	EDMA_ERR_LNK_CTRL_RX_3	= (1 << 16),	/* transient: FIS rx err */
+
@@ -249,0 +268 @@
+
@@ -250,0 +270,6 @@
+	EDMA_ERR_LNK_CTRL_TX_0	= (1 << 21),	/* transient: CRC err */
+	EDMA_ERR_LNK_CTRL_TX_1	= (1 << 22),	/* transient: FIFO err */
+	EDMA_ERR_LNK_CTRL_TX_2	= (1 << 23),	/* transient: caught SYNC */
+	EDMA_ERR_LNK_CTRL_TX_3	= (1 << 24),	/* transient: caught DMAT */
+	EDMA_ERR_LNK_CTRL_TX_4	= (1 << 25),	/* transient: FIS collision */
+
@@ -251,0 +277 @@
+
@@ -254,0 +281,6 @@
+
+	EDMA_ERR_IRQ_TRANSIENT  = EDMA_ERR_LNK_CTRL_RX_0 |
+				  EDMA_ERR_LNK_CTRL_RX_1 |
+				  EDMA_ERR_LNK_CTRL_RX_3 |
+				  EDMA_ERR_LNK_CTRL_TX,
+
@@ -313,0 +346 @@
+	MV_PP_FLAG_NCQ_EN	= (1 << 1),	/* is EDMA set up for NCQ? */
@@ -319,0 +353 @@
+#define HAS_PCI(host) (!((host)->ports[0]->flags & MV_FLAG_SOC))
@@ -343,0 +378 @@
+	chip_soc,
@@ -382,2 +417,2 @@
-	struct mv_sg		*sg_tbl;
-	dma_addr_t		sg_tbl_dma;
+	struct mv_sg		*sg_tbl[MV_MAX_Q_DEPTH];
+	dma_addr_t		sg_tbl_dma[MV_MAX_Q_DEPTH];
@@ -399,0 +435,4 @@
+	int			n_ports;
+	void __iomem		*base;
+	void __iomem		*main_cause_reg_addr;
+	void __iomem		*main_mask_reg_addr;
@@ -402,0 +442,8 @@
+	/*
+	 * These consistent DMA memory pools give us guaranteed
+	 * alignment for hardware-accessed data structures,
+	 * and less memory waste in accomplishing the alignment.
+	 */
+	struct dma_pool		*crqb_pool;
+	struct dma_pool		*crpb_pool;
+	struct dma_pool		*sg_tbl_pool;
@@ -414 +461 @@
-	void (*reset_bus)(struct pci_dev *pdev, void __iomem *mmio);
+	void (*reset_bus)(struct ata_host *host, void __iomem *mmio);
@@ -428 +474,0 @@
-static void mv_post_int_cmd(struct ata_queued_cmd *qc);
@@ -431 +477 @@
-static int mv_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);
+static void mv6_dev_config(struct ata_device *dev);
@@ -441 +487 @@
-static void mv5_reset_bus(struct pci_dev *pdev, void __iomem *mmio);
+static void mv5_reset_bus(struct ata_host *host, void __iomem *mmio);
@@ -451 +497,10 @@
-static void mv_reset_pci_bus(struct pci_dev *pdev, void __iomem *mmio);
+static void mv_soc_enable_leds(struct mv_host_priv *hpriv,
+				      void __iomem *mmio);
+static void mv_soc_read_preamp(struct mv_host_priv *hpriv, int idx,
+				      void __iomem *mmio);
+static int mv_soc_reset_hc(struct mv_host_priv *hpriv,
+				  void __iomem *mmio, unsigned int n_hc);
+static void mv_soc_reset_flash(struct mv_host_priv *hpriv,
+				      void __iomem *mmio);
+static void mv_soc_reset_bus(struct ata_host *host, void __iomem *mmio);
+static void mv_reset_pci_bus(struct ata_host *host, void __iomem *mmio);
@@ -454 +509,8 @@
-
+static void mv_edma_cfg(struct mv_port_priv *pp, struct mv_host_priv *hpriv,
+			void __iomem *port_mmio, int want_ncq);
+static int __mv_stop_dma(struct ata_port *ap);
+
+/* .sg_tablesize is (MV_MAX_SG_CT / 2) in the structures below
+ * because we have to allow room for worst case splitting of
+ * PRDs for 64K boundaries in mv_fill_sg().
+ */
@@ -478 +540,2 @@
-	.can_queue		= ATA_DEF_QUEUE,
+	.change_queue_depth	= ata_scsi_change_queue_depth,
+	.can_queue		= MV_MAX_Q_DEPTH - 1,
@@ -508 +570,0 @@
-	.post_internal_cmd	= mv_post_int_cmd,
@@ -519,0 +582 @@
+	.dev_config             = mv6_dev_config,
@@ -536 +598,0 @@
-	.post_internal_cmd	= mv_post_int_cmd,
@@ -538,0 +601 @@
+	.qc_defer		= ata_std_qc_defer,
@@ -564 +626,0 @@
-	.post_internal_cmd	= mv_post_int_cmd,
@@ -566,0 +629 @@
+	.qc_defer		= ata_std_qc_defer,
@@ -595 +658,2 @@
-		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS,
+		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS |
+				  ATA_FLAG_NCQ,
@@ -602 +666 @@
-				  MV_FLAG_DUAL_HC,
+				  ATA_FLAG_NCQ | MV_FLAG_DUAL_HC,
@@ -608 +672,2 @@
-		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS,
+		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS |
+				  ATA_FLAG_NCQ,
@@ -614 +679,2 @@
-		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS,
+		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS |
+				  ATA_FLAG_NCQ,
@@ -618,0 +685,6 @@
+	{  /* chip_soc */
+		.flags = MV_COMMON_FLAGS | MV_FLAG_SOC,
+		.pio_mask = 0x1f,      /* pio0-4 */
+		.udma_mask = ATA_UDMA6,
+		.port_ops = &mv_iie_ops,
+	},
@@ -651,7 +722,0 @@
-static struct pci_driver mv_pci_driver = {
-	.name			= DRV_NAME,
-	.id_table		= mv_pci_tbl,
-	.probe			= mv_init_one,
-	.remove			= ata_pci_remove_one,
-};
-
@@ -676,38 +741,8 @@
-/*
- * module options
- */
-static int msi;	      /* Use PCI msi; either zero (off, default) or non-zero */
-
-
-/* move to PCI layer or libata core? */
-static int pci_go_64(struct pci_dev *pdev)
-{
-	int rc;
-
-	if (!pci_set_dma_mask(pdev, DMA_64BIT_MASK)) {
-		rc = pci_set_consistent_dma_mask(pdev, DMA_64BIT_MASK);
-		if (rc) {
-			rc = pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK);
-			if (rc) {
-				dev_printk(KERN_ERR, &pdev->dev,
-					   "64-bit DMA enable failed\n");
-				return rc;
-			}
-		}
-	} else {
-		rc = pci_set_dma_mask(pdev, DMA_32BIT_MASK);
-		if (rc) {
-			dev_printk(KERN_ERR, &pdev->dev,
-				   "32-bit DMA enable failed\n");
-			return rc;
-		}
-		rc = pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK);
-		if (rc) {
-			dev_printk(KERN_ERR, &pdev->dev,
-				   "32-bit consistent DMA enable failed\n");
-			return rc;
-		}
-	}
-
-	return rc;
-}
+static const struct mv_hw_ops mv_soc_ops = {
+	.phy_errata		= mv6_phy_errata,
+	.enable_leds		= mv_soc_enable_leds,
+	.read_preamp		= mv_soc_read_preamp,
+	.reset_hc		= mv_soc_reset_hc,
+	.reset_flash		= mv_soc_reset_flash,
+	.reset_bus		= mv_soc_reset_bus,
+};
@@ -752,0 +788,6 @@
+static inline void __iomem *mv_host_base(struct ata_host *host)
+{
+	struct mv_host_priv *hpriv = host->private_data;
+	return hpriv->base;
+}
+
@@ -755 +796 @@
-	return mv_port_base(ap->host->iomap[MV_PRIMARY_BAR], ap->port_no);
+	return mv_port_base(mv_host_base(ap->host), ap->port_no);
@@ -818,2 +859,2 @@
-static void mv_start_dma(void __iomem *base, struct mv_host_priv *hpriv,
-			 struct mv_port_priv *pp)
+static void mv_start_dma(struct ata_port *ap, void __iomem *port_mmio,
+			 struct mv_port_priv *pp, u8 protocol)
@@ -820,0 +862,7 @@
+	int want_ncq = (protocol == ATA_PROT_NCQ);
+
+	if (pp->pp_flags & MV_PP_FLAG_EDMA_EN) {
+		int using_ncq = ((pp->pp_flags & MV_PP_FLAG_NCQ_EN) != 0);
+		if (want_ncq != using_ncq)
+			__mv_stop_dma(ap);
+	}
@@ -821,0 +870,6 @@
+		struct mv_host_priv *hpriv = ap->host->private_data;
+		int hard_port = mv_hardport_from_port(ap->port_no);
+		void __iomem *hc_mmio = mv_hc_base_from_port(
+					mv_host_base(ap->host), hard_port);
+		u32 hc_irq_cause, ipending;
+
@@ -823 +877,15 @@
-		writelfl(0, base + EDMA_ERR_IRQ_CAUSE_OFS);
+		writelfl(0, port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
+
+		/* clear EDMA interrupt indicator, if any */
+		hc_irq_cause = readl(hc_mmio + HC_IRQ_CAUSE_OFS);
+		ipending = (DEV_IRQ << hard_port) |
+				(CRPB_DMA_DONE << hard_port);
+		if (hc_irq_cause & ipending) {
+			writelfl(hc_irq_cause & ~ipending,
+				 hc_mmio + HC_IRQ_CAUSE_OFS);
+		}
+
+		mv_edma_cfg(pp, hpriv, port_mmio, want_ncq);
+
+		/* clear FIS IRQ Cause */
+		writelfl(0, port_mmio + SATA_FIS_IRQ_CAUSE_OFS);
@@ -825 +893 @@
-		mv_set_edma_ptrs(base, hpriv, pp);
+		mv_set_edma_ptrs(port_mmio, hpriv, pp);
@@ -827 +895 @@
-		writelfl(EDMA_EN, base + EDMA_CMD_OFS);
+		writelfl(EDMA_EN, port_mmio + EDMA_CMD_OFS);
@@ -830 +898 @@
-	WARN_ON(!(EDMA_EN & readl(base + EDMA_CMD_OFS)));
+	WARN_ON(!(EDMA_EN & readl(port_mmio + EDMA_CMD_OFS)));
@@ -1006,2 +1074,13 @@
-static void mv_edma_cfg(struct ata_port *ap, struct mv_host_priv *hpriv,
-			void __iomem *port_mmio)
+static void mv6_dev_config(struct ata_device *adev)
+{
+	/*
+	 * We don't have hob_nsect when doing NCQ commands on Gen-II.
+	 * See mv_qc_prep() for more info.
+	 */
+	if (adev->flags & ATA_DFLAG_NCQ)
+		if (adev->max_sectors > ATA_MAX_SECTORS)
+			adev->max_sectors = ATA_MAX_SECTORS;
+}
+
+static void mv_edma_cfg(struct mv_port_priv *pp, struct mv_host_priv *hpriv,
+			void __iomem *port_mmio, int want_ncq)
@@ -1009 +1088 @@
-	u32 cfg = readl(port_mmio + EDMA_CFG_OFS);
+	u32 cfg;
@@ -1012 +1091 @@
-	cfg &= ~(1 << 9);	/* disable eQue */
+	cfg = EDMA_CFG_Q_DEPTH;		/* always 0x1f for *all* chips */
@@ -1014,2 +1093 @@
-	if (IS_GEN_I(hpriv)) {
-		cfg &= ~0x1f;		/* clear queue depth */
+	if (IS_GEN_I(hpriv))
@@ -1017 +1094,0 @@
-	}
@@ -1019,2 +1096 @@
-	else if (IS_GEN_II(hpriv)) {
-		cfg &= ~0x1f;		/* clear queue depth */
+	else if (IS_GEN_II(hpriv))
@@ -1022,2 +1097,0 @@
-		cfg &= ~(EDMA_CFG_NCQ | EDMA_CFG_NCQ_GO_ON_ERR); /* clear NCQ */
-	}
@@ -1028 +1101,0 @@
-		cfg &= ~(1 << 19);	/* dis 128-entry queue (for now?) */
@@ -1031,2 +1103,0 @@
-		cfg &= ~(1 << 16);	/* dis FIS-based switching (for now) */
-		cfg &= ~(EDMA_CFG_NCQ);	/* clear NCQ */
@@ -1034,0 +1106,6 @@
+	if (want_ncq) {
+		cfg |= EDMA_CFG_NCQ;
+		pp->pp_flags |=  MV_PP_FLAG_NCQ_EN;
+	} else
+		pp->pp_flags &= ~MV_PP_FLAG_NCQ_EN;
+
@@ -1037,0 +1115,29 @@
+static void mv_port_free_dma_mem(struct ata_port *ap)
+{
+	struct mv_host_priv *hpriv = ap->host->private_data;
+	struct mv_port_priv *pp = ap->private_data;
+	int tag;
+
+	if (pp->crqb) {
+		dma_pool_free(hpriv->crqb_pool, pp->crqb, pp->crqb_dma);
+		pp->crqb = NULL;
+	}
+	if (pp->crpb) {
+		dma_pool_free(hpriv->crpb_pool, pp->crpb, pp->crpb_dma);
+		pp->crpb = NULL;
+	}
+	/*
+	 * For GEN_I, there's no NCQ, so we have only a single sg_tbl.
+	 * For later hardware, we have one unique sg_tbl per NCQ tag.
+	 */
+	for (tag = 0; tag < MV_MAX_Q_DEPTH; ++tag) {
+		if (pp->sg_tbl[tag]) {
+			if (tag == 0 || !IS_GEN_I(hpriv))
+				dma_pool_free(hpriv->sg_tbl_pool,
+					      pp->sg_tbl[tag],
+					      pp->sg_tbl_dma[tag]);
+			pp->sg_tbl[tag] = NULL;
+		}
+	}
+}
+
@@ -1054,2 +1159,0 @@
-	void *mem;
-	dma_addr_t mem_dma;
@@ -1057 +1161 @@
-	int rc;
+	int tag;
@@ -1061,0 +1166 @@
+	ap->private_data = pp;
@@ -1063,3 +1168,2 @@
-	mem = dmam_alloc_coherent(dev, MV_PORT_PRIV_DMA_SZ, &mem_dma,
-				  GFP_KERNEL);
-	if (!mem)
+	pp->crqb = dma_pool_alloc(hpriv->crqb_pool, GFP_KERNEL, &pp->crqb_dma);
+	if (!pp->crqb)
@@ -1067 +1171 @@
-	memset(mem, 0, MV_PORT_PRIV_DMA_SZ);
+	memset(pp->crqb, 0, MV_CRQB_Q_SZ);
@@ -1069,19 +1173,4 @@
-	rc = ata_pad_alloc(ap, dev);
-	if (rc)
-		return rc;
-
-	/* First item in chunk of DMA memory:
-	 * 32-slot command request table (CRQB), 32 bytes each in size
-	 */
-	pp->crqb = mem;
-	pp->crqb_dma = mem_dma;
-	mem += MV_CRQB_Q_SZ;
-	mem_dma += MV_CRQB_Q_SZ;
-
-	/* Second item:
-	 * 32-slot command response table (CRPB), 8 bytes each in size
-	 */
-	pp->crpb = mem;
-	pp->crpb_dma = mem_dma;
-	mem += MV_CRPB_Q_SZ;
-	mem_dma += MV_CRPB_Q_SZ;
+	pp->crpb = dma_pool_alloc(hpriv->crpb_pool, GFP_KERNEL, &pp->crpb_dma);
+	if (!pp->crpb)
+		goto out_port_free_dma_mem;
+	memset(pp->crpb, 0, MV_CRPB_Q_SZ);
@@ -1089,2 +1178,3 @@
-	/* Third item:
-	 * Table of scatter-gather descriptors (ePRD), 16 bytes each
+	/*
+	 * For GEN_I, there's no NCQ, so we only allocate a single sg_tbl.
+	 * For later hardware, we need one unique sg_tbl per NCQ tag.
@@ -1092,2 +1182,11 @@
-	pp->sg_tbl = mem;
-	pp->sg_tbl_dma = mem_dma;
+	for (tag = 0; tag < MV_MAX_Q_DEPTH; ++tag) {
+		if (tag == 0 || !IS_GEN_I(hpriv)) {
+			pp->sg_tbl[tag] = dma_pool_alloc(hpriv->sg_tbl_pool,
+					      GFP_KERNEL, &pp->sg_tbl_dma[tag]);
+			if (!pp->sg_tbl[tag])
+				goto out_port_free_dma_mem;
+		} else {
+			pp->sg_tbl[tag]     = pp->sg_tbl[0];
+			pp->sg_tbl_dma[tag] = pp->sg_tbl_dma[0];
+		}
+	}
@@ -1097,2 +1196 @@
-	mv_edma_cfg(ap, hpriv, port_mmio);
-
+	mv_edma_cfg(pp, hpriv, port_mmio, 0);
@@ -1107 +1204,0 @@
-	ap->private_data = pp;
@@ -1108,0 +1206,4 @@
+
+out_port_free_dma_mem:
+	mv_port_free_dma_mem(ap);
+	return -ENOMEM;
@@ -1122,0 +1224 @@
+	mv_port_free_dma_mem(ap);
@@ -1138,0 +1241 @@
+	unsigned int si;
@@ -1140,2 +1243,2 @@
-	mv_sg = pp->sg_tbl;
-	ata_for_each_sg(sg, qc) {
+	mv_sg = pp->sg_tbl[qc->tag];
+	for_each_sg(qc->sg, sg, qc->n_elem, si) {
@@ -1196 +1299,2 @@
-	if (qc->tf.protocol != ATA_PROT_DMA)
+	if ((qc->tf.protocol != ATA_PROT_DMA) &&
+	    (qc->tf.protocol != ATA_PROT_NCQ))
@@ -1205 +1308,0 @@
-	flags |= qc->tag << CRQB_IOID_SHIFT;	/* 50xx appears to ignore this*/
@@ -1211 +1314 @@
-		cpu_to_le32(pp->sg_tbl_dma & 0xffffffff);
+		cpu_to_le32(pp->sg_tbl_dma[qc->tag] & 0xffffffff);
@@ -1213 +1316 @@
-		cpu_to_le32((pp->sg_tbl_dma >> 16) >> 16);
+		cpu_to_le32((pp->sg_tbl_dma[qc->tag] >> 16) >> 16);
@@ -1233 +1335,0 @@
-#ifdef LIBATA_NCQ		/* FIXME: remove this line when NCQ added */
@@ -1239 +1340,0 @@
-#endif				/* FIXME: remove this line when NCQ added */
@@ -1288 +1389,2 @@
-	if (qc->tf.protocol != ATA_PROT_DMA)
+	if ((qc->tf.protocol != ATA_PROT_DMA) &&
+	    (qc->tf.protocol != ATA_PROT_NCQ))
@@ -1298,2 +1400 @@
-	flags |= qc->tag << CRQB_IOID_SHIFT;	/* "I/O Id" is -really-
-						   what we use as our tag */
+	flags |= qc->tag << CRQB_HOSTQ_SHIFT;
@@ -1305,2 +1406,2 @@
-	crqb->addr = cpu_to_le32(pp->sg_tbl_dma & 0xffffffff);
-	crqb->addr_hi = cpu_to_le32((pp->sg_tbl_dma >> 16) >> 16);
+	crqb->addr = cpu_to_le32(pp->sg_tbl_dma[qc->tag] & 0xffffffff);
+	crqb->addr_hi = cpu_to_le32((pp->sg_tbl_dma[qc->tag] >> 16) >> 16);
@@ -1353 +1453,0 @@
-	struct mv_host_priv *hpriv = ap->host->private_data;
@@ -1356 +1456,2 @@
-	if (qc->tf.protocol != ATA_PROT_DMA) {
+	if ((qc->tf.protocol != ATA_PROT_DMA) &&
+	    (qc->tf.protocol != ATA_PROT_NCQ)) {
@@ -1365,7 +1466 @@
-	mv_start_dma(port_mmio, hpriv, pp);
-
-	in_index = pp->req_idx & MV_MAX_Q_DEPTH_MASK;
-
-	/* until we do queuing, the queue should be empty at this point */
-	WARN_ON(in_index != ((readl(port_mmio + EDMA_REQ_Q_OUT_PTR_OFS)
-		>> EDMA_REQ_Q_PTR_SHIFT) & MV_MAX_Q_DEPTH_MASK));
+	mv_start_dma(ap, port_mmio, pp, qc->tf.protocol);
@@ -1438,0 +1534 @@
+		action |= ATA_EH_HARDRESET;
@@ -1445 +1541 @@
-			struct mv_port_priv *pp	= ap->private_data;
+			pp = ap->private_data;
@@ -1453 +1549 @@
-			struct mv_port_priv *pp	= ap->private_data;
+			pp = ap->private_data;
@@ -1467 +1563 @@
-	writelfl(0, port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
+	writelfl(~edma_err_cause, port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
@@ -1540,7 +1636,2 @@
-		else if (IS_GEN_II(hpriv))
-			tag = (le16_to_cpu(pp->crpb[out_index].id)
-				>> CRPB_IOID_SHIFT_6) & 0x3f;
-
-		else /* IS_GEN_IIE */
-			tag = (le16_to_cpu(pp->crpb[out_index].id)
-				>> CRPB_IOID_SHIFT_7) & 0x3f;
+		else
+			tag = le16_to_cpu(pp->crpb[out_index].id) & 0x1f;
@@ -1550,4 +1641,3 @@
-		/* lower 8 bits of status are EDMA_ERR_IRQ_CAUSE_OFS
-		 * bits (WARNING: might not necessarily be associated
-		 * with this command), which -should- be clear
-		 * if all is well
+		/* For non-NCQ mode, the lower 8 bits of status
+		 * are from EDMA_ERR_IRQ_CAUSE_OFS,
+		 * which should be zero if all went well.
@@ -1556 +1646 @@
-		if (unlikely(status & 0xff)) {
+		if ((status & 0xff) && !(pp->pp_flags & MV_PP_FLAG_NCQ_EN)) {
@@ -1600 +1690,2 @@
-	void __iomem *mmio = host->iomap[MV_PRIMARY_BAR];
+	struct mv_host_priv *hpriv = host->private_data;
+	void __iomem *mmio = hpriv->base;
@@ -1603 +1694 @@
-	int port, port0;
+	int port, port0, last_port;
@@ -1609,0 +1701,4 @@
+	if (HAS_PCI(host))
+		last_port = port0 + MV_PORTS_PER_HC;
+	else
+		last_port = port0 + hpriv->n_ports;
@@ -1620 +1715 @@
-	for (port = port0; port < port0 + MV_PORTS_PER_HC; port++) {
+	for (port = port0; port < last_port; port++) {
@@ -1622 +1717 @@
-		struct mv_port_priv *pp = ap->private_data;
+		struct mv_port_priv *pp;
@@ -1627,0 +1723,2 @@
+		pp = ap->private_data;
+
@@ -1714,0 +1812 @@
+	struct mv_host_priv *hpriv = host->private_data;
@@ -1716,2 +1814,2 @@
-	void __iomem *mmio = host->iomap[MV_PRIMARY_BAR];
-	u32 irq_stat;
+	void __iomem *mmio = hpriv->base;
+	u32 irq_stat, irq_mask;
@@ -1719 +1817,4 @@
-	irq_stat = readl(mmio + HC_MAIN_IRQ_CAUSE_OFS);
+	spin_lock(&host->lock);
+
+	irq_stat = readl(hpriv->main_cause_reg_addr);
+	irq_mask = readl(hpriv->main_mask_reg_addr);
@@ -1724,2 +1825,2 @@
-	if (!irq_stat || (0xffffffffU == irq_stat))
-		return IRQ_NONE;
+	if (!(irq_stat & irq_mask) || (0xffffffffU == irq_stat))
+		goto out_unlock;
@@ -1728 +1828,0 @@
-	spin_lock(&host->lock);
@@ -1730 +1830 @@
-	if (unlikely(irq_stat & PCI_ERR)) {
+	if (unlikely((irq_stat & PCI_ERR) && HAS_PCI(host))) {
@@ -1777 +1877,2 @@
-	void __iomem *mmio = ap->host->iomap[MV_PRIMARY_BAR];
+	struct mv_host_priv *hpriv = ap->host->private_data;
+	void __iomem *mmio = hpriv->base;
@@ -1790 +1891,2 @@
-	void __iomem *mmio = ap->host->iomap[MV_PRIMARY_BAR];
+	struct mv_host_priv *hpriv = ap->host->private_data;
+	void __iomem *mmio = hpriv->base;
@@ -1801 +1903 @@
-static void mv5_reset_bus(struct pci_dev *pdev, void __iomem *mmio)
+static void mv5_reset_bus(struct ata_host *host, void __iomem *mmio)
@@ -1802,0 +1905 @@
+	struct pci_dev *pdev = to_pci_dev(host->dev);
@@ -1813 +1916 @@
-	mv_reset_pci_bus(pdev, mmio);
+	mv_reset_pci_bus(host, mmio);
@@ -1937 +2040 @@
-static void mv_reset_pci_bus(struct pci_dev *pdev, void __iomem *mmio)
+static void mv_reset_pci_bus(struct ata_host *host, void __iomem *mmio)
@@ -1939 +2041,0 @@
-	struct ata_host     *host = dev_get_drvdata(&pdev->dev);
@@ -2127,0 +2230,87 @@
+/* TODO: use the generic LED interface to configure the SATA Presence */
+/* & Acitivy LEDs on the board */
+static void mv_soc_enable_leds(struct mv_host_priv *hpriv,
+				      void __iomem *mmio)
+{
+	return;
+}
+
+static void mv_soc_read_preamp(struct mv_host_priv *hpriv, int idx,
+			   void __iomem *mmio)
+{
+	void __iomem *port_mmio;
+	u32 tmp;
+
+	port_mmio = mv_port_base(mmio, idx);
+	tmp = readl(port_mmio + PHY_MODE2);
+
+	hpriv->signal[idx].amps = tmp & 0x700;	/* bits 10:8 */
+	hpriv->signal[idx].pre = tmp & 0xe0;	/* bits 7:5 */
+}
+
+#undef ZERO
+#define ZERO(reg) writel(0, port_mmio + (reg))
+static void mv_soc_reset_hc_port(struct mv_host_priv *hpriv,
+					void __iomem *mmio, unsigned int port)
+{
+	void __iomem *port_mmio = mv_port_base(mmio, port);
+
+	writelfl(EDMA_DS, port_mmio + EDMA_CMD_OFS);
+
+	mv_channel_reset(hpriv, mmio, port);
+
+	ZERO(0x028);		/* command */
+	writel(0x101f, port_mmio + EDMA_CFG_OFS);
+	ZERO(0x004);		/* timer */
+	ZERO(0x008);		/* irq err cause */
+	ZERO(0x00c);		/* irq err mask */
+	ZERO(0x010);		/* rq bah */
+	ZERO(0x014);		/* rq inp */
+	ZERO(0x018);		/* rq outp */
+	ZERO(0x01c);		/* respq bah */
+	ZERO(0x024);		/* respq outp */
+	ZERO(0x020);		/* respq inp */
+	ZERO(0x02c);		/* test control */
+	writel(0xbc, port_mmio + EDMA_IORDY_TMOUT);
+}
+
+#undef ZERO
+
+#define ZERO(reg) writel(0, hc_mmio + (reg))
+static void mv_soc_reset_one_hc(struct mv_host_priv *hpriv,
+				       void __iomem *mmio)
+{
+	void __iomem *hc_mmio = mv_hc_base(mmio, 0);
+
+	ZERO(0x00c);
+	ZERO(0x010);
+	ZERO(0x014);
+
+}
+
+#undef ZERO
+
+static int mv_soc_reset_hc(struct mv_host_priv *hpriv,
+				  void __iomem *mmio, unsigned int n_hc)
+{
+	unsigned int port;
+
+	for (port = 0; port < hpriv->n_ports; port++)
+		mv_soc_reset_hc_port(hpriv, mmio, port);
+
+	mv_soc_reset_one_hc(hpriv, mmio);
+
+	return 0;
+}
+
+static void mv_soc_reset_flash(struct mv_host_priv *hpriv,
+				      void __iomem *mmio)
+{
+	return;
+}
+
+static void mv_soc_reset_bus(struct ata_host *host, void __iomem *mmio)
+{
+	return;
+}
+
@@ -2292 +2481 @@
-	void __iomem *mmio = ap->host->iomap[MV_PRIMARY_BAR];
+	void __iomem *mmio = hpriv->base;
@@ -2331,5 +2519,0 @@
-static void mv_post_int_cmd(struct ata_queued_cmd *qc)
-{
-	mv_stop_dma(qc->ap);
-}
-
@@ -2338 +2522 @@
-	void __iomem *mmio = ap->host->iomap[MV_PRIMARY_BAR];
+	struct mv_host_priv *hpriv = ap->host->private_data;
@@ -2352,2 +2536,2 @@
-	tmp = readl(mmio + HC_MAIN_IRQ_MASK_OFS);
-	writelfl(tmp & ~mask, mmio + HC_MAIN_IRQ_MASK_OFS);
+	tmp = readl(hpriv->main_mask_reg_addr);
+	writelfl(tmp & ~mask, hpriv->main_mask_reg_addr);
@@ -2358 +2542,2 @@
-	void __iomem *mmio = ap->host->iomap[MV_PRIMARY_BAR];
+	struct mv_host_priv *hpriv = ap->host->private_data;
+	void __iomem *mmio = hpriv->base;
@@ -2385,2 +2570,2 @@
-	tmp = readl(mmio + HC_MAIN_IRQ_MASK_OFS);
-	writelfl(tmp | mask, mmio + HC_MAIN_IRQ_MASK_OFS);
+	tmp = readl(hpriv->main_mask_reg_addr);
+	writelfl(tmp | mask, hpriv->main_mask_reg_addr);
@@ -2429,2 +2614,2 @@
-	/* unmask all EDMA error interrupts */
-	writelfl(~0, port_mmio + EDMA_ERR_IRQ_MASK_OFS);
+	/* unmask all non-transient EDMA error interrupts */
+	writelfl(~EDMA_ERR_IRQ_TRANSIENT, port_mmio + EDMA_ERR_IRQ_MASK_OFS);
@@ -2552,0 +2738,4 @@
+	case chip_soc:
+		hpriv->ops = &mv_soc_ops;
+		hp_flags |= MV_HP_ERRATA_60X1C0;
+		break;
@@ -2555 +2744 @@
-		dev_printk(KERN_ERR, &pdev->dev,
+		dev_printk(KERN_ERR, host->dev,
@@ -2588,2 +2776,0 @@
-	struct pci_dev *pdev = to_pci_dev(host->dev);
-	void __iomem *mmio = host->iomap[MV_PRIMARY_BAR];
@@ -2591,3 +2778 @@
-
-	/* global interrupt mask */
-	writel(0, mmio + HC_MAIN_IRQ_MASK_OFS);
+	void __iomem *mmio = hpriv->base;
@@ -2597 +2782,14 @@
-		goto done;
+	goto done;
+
+	if (HAS_PCI(host)) {
+		hpriv->main_cause_reg_addr = hpriv->base +
+		  HC_MAIN_IRQ_CAUSE_OFS;
+		hpriv->main_mask_reg_addr = hpriv->base + HC_MAIN_IRQ_MASK_OFS;
+	} else {
+		hpriv->main_cause_reg_addr = hpriv->base +
+		  HC_SOC_MAIN_IRQ_CAUSE_OFS;
+		hpriv->main_mask_reg_addr = hpriv->base +
+		  HC_SOC_MAIN_IRQ_MASK_OFS;
+	}
+	/* global interrupt mask */
+	writel(0, hpriv->main_mask_reg_addr);
@@ -2609 +2807 @@
-	hpriv->ops->reset_bus(pdev, mmio);
+	hpriv->ops->reset_bus(host, mmio);
@@ -2628 +2825,0 @@
-		unsigned int offset = port_mmio - mmio;
@@ -2632,2 +2829,7 @@
-		ata_port_pbar_desc(ap, MV_PRIMARY_BAR, -1, "mmio");
-		ata_port_pbar_desc(ap, MV_PRIMARY_BAR, offset, "port");
+#ifdef CONFIG_PCI
+		if (HAS_PCI(host)) {
+			unsigned int offset = port_mmio - mmio;
+			ata_port_pbar_desc(ap, MV_PRIMARY_BAR, -1, "mmio");
+			ata_port_pbar_desc(ap, MV_PRIMARY_BAR, offset, "port");
+		}
+#endif
@@ -2648,2 +2850,29 @@
-	/* Clear any currently outstanding host interrupt conditions */
-	writelfl(0, mmio + hpriv->irq_cause_ofs);
+	if (HAS_PCI(host)) {
+		/* Clear any currently outstanding host interrupt conditions */
+		writelfl(0, mmio + hpriv->irq_cause_ofs);
+
+		/* and unmask interrupt generation for host regs */
+		writelfl(hpriv->unmask_all_irqs, mmio + hpriv->irq_mask_ofs);
+		if (IS_GEN_I(hpriv))
+			writelfl(~HC_MAIN_MASKED_IRQS_5,
+				 hpriv->main_mask_reg_addr);
+		else
+			writelfl(~HC_MAIN_MASKED_IRQS,
+				 hpriv->main_mask_reg_addr);
+
+		VPRINTK("HC MAIN IRQ cause/mask=0x%08x/0x%08x "
+			"PCI int cause/mask=0x%08x/0x%08x\n",
+			readl(hpriv->main_cause_reg_addr),
+			readl(hpriv->main_mask_reg_addr),
+			readl(mmio + hpriv->irq_cause_ofs),
+			readl(mmio + hpriv->irq_mask_ofs));
+	} else {
+		writelfl(~HC_MAIN_MASKED_IRQS_SOC,
+			 hpriv->main_mask_reg_addr);
+		VPRINTK("HC MAIN IRQ cause/mask=0x%08x/0x%08x\n",
+			readl(hpriv->main_cause_reg_addr),
+			readl(hpriv->main_mask_reg_addr));
+	}
+done:
+	return rc;
+}
@@ -2651,2 +2880,6 @@
-	/* and unmask interrupt generation for host regs */
-	writelfl(hpriv->unmask_all_irqs, mmio + hpriv->irq_mask_ofs);
+static int mv_create_dma_pools(struct mv_host_priv *hpriv, struct device *dev)
+{
+	hpriv->crqb_pool   = dmam_pool_create("crqb_q", dev, MV_CRQB_Q_SZ,
+							     MV_CRQB_Q_SZ, 0);
+	if (!hpriv->crqb_pool)
+		return -ENOMEM;
@@ -2654,4 +2887,4 @@
-	if (IS_GEN_I(hpriv))
-		writelfl(~HC_MAIN_MASKED_IRQS_5, mmio + HC_MAIN_IRQ_MASK_OFS);
-	else
-		writelfl(~HC_MAIN_MASKED_IRQS, mmio + HC_MAIN_IRQ_MASK_OFS);
+	hpriv->crpb_pool   = dmam_pool_create("crpb_q", dev, MV_CRPB_Q_SZ,
+							     MV_CRPB_Q_SZ, 0);
+	if (!hpriv->crpb_pool)
+		return -ENOMEM;
@@ -2659,6 +2892,153 @@
-	VPRINTK("HC MAIN IRQ cause/mask=0x%08x/0x%08x "
-		"PCI int cause/mask=0x%08x/0x%08x\n",
-		readl(mmio + HC_MAIN_IRQ_CAUSE_OFS),
-		readl(mmio + HC_MAIN_IRQ_MASK_OFS),
-		readl(mmio + hpriv->irq_cause_ofs),
-		readl(mmio + hpriv->irq_mask_ofs));
+	hpriv->sg_tbl_pool = dmam_pool_create("sg_tbl", dev, MV_SG_TBL_SZ,
+							     MV_SG_TBL_SZ, 0);
+	if (!hpriv->sg_tbl_pool)
+		return -ENOMEM;
+
+	return 0;
+}
+
+/**
+ *      mv_platform_probe - handle a positive probe of an soc Marvell
+ *      host
+ *      @pdev: platform device found
+ *
+ *      LOCKING:
+ *      Inherited from caller.
+ */
+static int mv_platform_probe(struct platform_device *pdev)
+{
+	static int printed_version;
+	const struct mv_sata_platform_data *mv_platform_data;
+	const struct ata_port_info *ppi[] =
+	    { &mv_port_info[chip_soc], NULL };
+	struct ata_host *host;
+	struct mv_host_priv *hpriv;
+	struct resource *res;
+	int n_ports, rc;
+
+	if (!printed_version++)
+		dev_printk(KERN_INFO, &pdev->dev, "version " DRV_VERSION "\n");
+
+	/*
+	 * Simple resource validation ..
+	 */
+	if (unlikely(pdev->num_resources != 2)) {
+		dev_err(&pdev->dev, "invalid number of resources\n");
+		return -EINVAL;
+	}
+
+	/*
+	 * Get the register base first
+	 */
+	res = platform_get_resource(pdev, IORESOURCE_MEM, 0);
+	if (res == NULL)
+		return -EINVAL;
+
+	/* allocate host */
+	mv_platform_data = pdev->dev.platform_data;
+	n_ports = mv_platform_data->n_ports;
+
+	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
+	hpriv = devm_kzalloc(&pdev->dev, sizeof(*hpriv), GFP_KERNEL);
+
+	if (!host || !hpriv)
+		return -ENOMEM;
+	host->private_data = hpriv;
+	hpriv->n_ports = n_ports;
+
+	host->iomap = NULL;
+	hpriv->base = devm_ioremap(&pdev->dev, res->start,
+				   res->end - res->start + 1);
+	hpriv->base -= MV_SATAHC0_REG_BASE;
+
+	rc = mv_create_dma_pools(hpriv, &pdev->dev);
+	if (rc)
+		return rc;
+
+	/* initialize adapter */
+	rc = mv_init_host(host, chip_soc);
+	if (rc)
+		return rc;
+
+	dev_printk(KERN_INFO, &pdev->dev,
+		   "slots %u ports %d\n", (unsigned)MV_MAX_Q_DEPTH,
+		   host->n_ports);
+
+	return ata_host_activate(host, platform_get_irq(pdev, 0), mv_interrupt,
+				 IRQF_SHARED, &mv6_sht);
+}
+
+/*
+ *
+ *      mv_platform_remove    -       unplug a platform interface
+ *      @pdev: platform device
+ *
+ *      A platform bus SATA device has been unplugged. Perform the needed
+ *      cleanup. Also called on module unload for any active devices.
+ */
+static int __devexit mv_platform_remove(struct platform_device *pdev)
+{
+	struct device *dev = &pdev->dev;
+	struct ata_host *host = dev_get_drvdata(dev);
+
+	ata_host_detach(host);
+	return 0;
+}
+
+static struct platform_driver mv_platform_driver = {
+	.probe			= mv_platform_probe,
+	.remove			= __devexit_p(mv_platform_remove),
+	.driver			= {
+				   .name = DRV_NAME,
+				   .owner = THIS_MODULE,
+				  },
+};
+
+
+#ifdef CONFIG_PCI
+static int mv_pci_init_one(struct pci_dev *pdev,
+			   const struct pci_device_id *ent);
+
+
+static struct pci_driver mv_pci_driver = {
+	.name			= DRV_NAME,
+	.id_table		= mv_pci_tbl,
+	.probe			= mv_pci_init_one,
+	.remove			= ata_pci_remove_one,
+};
+
+/*
+ * module options
+ */
+static int msi;	      /* Use PCI msi; either zero (off, default) or non-zero */
+
+
+/* move to PCI layer or libata core? */
+static int pci_go_64(struct pci_dev *pdev)
+{
+	int rc;
+
+	if (!pci_set_dma_mask(pdev, DMA_64BIT_MASK)) {
+		rc = pci_set_consistent_dma_mask(pdev, DMA_64BIT_MASK);
+		if (rc) {
+			rc = pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK);
+			if (rc) {
+				dev_printk(KERN_ERR, &pdev->dev,
+					   "64-bit DMA enable failed\n");
+				return rc;
+			}
+		}
+	} else {
+		rc = pci_set_dma_mask(pdev, DMA_32BIT_MASK);
+		if (rc) {
+			dev_printk(KERN_ERR, &pdev->dev,
+				   "32-bit DMA enable failed\n");
+			return rc;
+		}
+		rc = pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK);
+		if (rc) {
+			dev_printk(KERN_ERR, &pdev->dev,
+				   "32-bit consistent DMA enable failed\n");
+			return rc;
+		}
+	}
@@ -2666 +3045,0 @@
-done:
@@ -2713 +3092 @@
- *      mv_init_one - handle a positive probe of a Marvell host
+ *      mv_pci_init_one - handle a positive probe of a PCI Marvell host
@@ -2720 +3099,2 @@
-static int mv_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
+static int mv_pci_init_one(struct pci_dev *pdev,
+			   const struct pci_device_id *ent)
@@ -2739,0 +3120 @@
+	hpriv->n_ports = n_ports;
@@ -2751,0 +3133 @@
+	hpriv->base = host->iomap[MV_PRIMARY_BAR];
@@ -2756,0 +3139,4 @@
+	rc = mv_create_dma_pools(hpriv, &pdev->dev);
+	if (rc)
+		return rc;
+
@@ -2773,0 +3160,4 @@
+#endif
+
+static int mv_platform_probe(struct platform_device *pdev);
+static int __devexit mv_platform_remove(struct platform_device *pdev);
@@ -2777 +3167,13 @@
-	return pci_register_driver(&mv_pci_driver);
+	int rc = -ENODEV;
+#ifdef CONFIG_PCI
+	rc = pci_register_driver(&mv_pci_driver);
+	if (rc < 0)
+		return rc;
+#endif
+	rc = platform_driver_register(&mv_platform_driver);
+
+#ifdef CONFIG_PCI
+	if (rc < 0)
+		pci_unregister_driver(&mv_pci_driver);
+#endif
+	return rc;
@@ -2781,0 +3184 @@
+#ifdef CONFIG_PCI
@@ -2782,0 +3186,2 @@
+#endif
+	platform_driver_unregister(&mv_platform_driver);
@@ -2789,0 +3195 @@
+MODULE_ALIAS("platform:sata_mv");
@@ -2790,0 +3197 @@
+#ifdef CONFIG_PCI
@@ -2792,0 +3200 @@
+#endif
--- ./projects/linux/linux-2.6.25/drivers/ata/sata_mv.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/ata/sata_mv.c	2008-07-13 23:51:29.000000000 +0200
@@ -3,0 +4 @@
+ * Copyright 2008: Marvell Corporation, all rights reserved.
@@ -25,39 +26,28 @@
-  sata_mv TODO list:
-
-  1) Needs a full errata audit for all chipsets.  I implemented most
-  of the errata workarounds found in the Marvell vendor driver, but
-  I distinctly remember a couple workarounds (one related to PCI-X)
-  are still needed.
-
-  2) Improve/fix IRQ and error handling sequences.
-
-  3) ATAPI support (Marvell claims the 60xx/70xx chips can do it).
-
-  4) Think about TCQ support here, and for libata in general
-  with controllers that suppport it via host-queuing hardware
-  (a software-only implementation could be a nightmare).
-
-  5) Investigate problems with PCI Message Signalled Interrupts (MSI).
-
-  6) Add port multiplier support (intermediate)
-
-  8) Develop a low-power-consumption strategy, and implement it.
-
-  9) [Experiment, low priority] See if ATAPI can be supported using
-  "unknown FIS" or "vendor-specific FIS" support, or something creative
-  like that.
-
-  10) [Experiment, low priority] Investigate interrupt coalescing.
-  Quite often, especially with PCI Message Signalled Interrupts (MSI),
-  the overhead reduced by interrupt mitigation is quite often not
-  worth the latency cost.
-
-  11) [Experiment, Marvell value added] Is it possible to use target
-  mode to cross-connect two Linux boxes with Marvell cards?  If so,
-  creating LibATA target mode support would be very interesting.
-
-  Target mode, for those without docs, is the ability to directly
-  connect two SATA controllers.
-
-*/
-
+ * sata_mv TODO list:
+ *
+ * --> Errata workaround for NCQ device errors.
+ *
+ * --> More errata workarounds for PCI-X.
+ *
+ * --> Complete a full errata audit for all chipsets to identify others.
+ *
+ * --> ATAPI support (Marvell claims the 60xx/70xx chips can do it).
+ *
+ * --> Investigate problems with PCI Message Signalled Interrupts (MSI).
+ *
+ * --> Cache frequently-accessed registers in mv_port_priv to reduce overhead.
+ *
+ * --> Develop a low-power-consumption strategy, and implement it.
+ *
+ * --> [Experiment, low priority] Investigate interrupt coalescing.
+ *       Quite often, especially with PCI Message Signalled Interrupts (MSI),
+ *       the overhead reduced by interrupt mitigation is quite often not
+ *       worth the latency cost.
+ *
+ * --> [Experiment, Marvell value added] Is it possible to use target
+ *       mode to cross-connect two Linux boxes with Marvell cards?  If so,
+ *       creating LibATA target mode support would be very interesting.
+ *
+ *       Target mode, for those without docs, is the ability to directly
+ *       connect two SATA ports.
+ */
@@ -76,0 +67,2 @@
+#include <linux/mbus.h>
+#include <linux/bitops.h>
@@ -83 +75 @@
-#define DRV_VERSION	"1.20"
+#define DRV_VERSION	"1.24"
@@ -103,3 +95,3 @@
-	MV_FLASH_CTL		= 0x1046c,
-	MV_GPIO_PORT_CTL	= 0x104f0,
-	MV_RESET_CFG		= 0x180d8,
+	MV_FLASH_CTL_OFS	= 0x1046c,
+	MV_GPIO_PORT_CTL_OFS	= 0x104f0,
+	MV_RESET_CFG_OFS	= 0x180d8,
@@ -124,2 +116 @@
-	MV_PORTS_PER_HC		= 4,
-	/* == (port / MV_PORTS_PER_HC) to determine HC from 0-7 port */
+	/* Determine hc from 0-7 port: hc = port >> MV_PORT_HC_SHIFT */
@@ -127,2 +118,3 @@
-	/* == (port % MV_PORTS_PER_HC) to determine hard port from 0-7 port */
-	MV_PORT_MASK		= 3,
+	MV_PORTS_PER_HC		= (1 << MV_PORT_HC_SHIFT), /* 4 */
+	/* Determine hc port from 0-7 port: hardport = port & MV_PORT_MASK */
+	MV_PORT_MASK		= (MV_PORTS_PER_HC - 1),   /* 3 */
@@ -133,2 +124,0 @@
-	/* SoC integrated controllers, no PCI interface */
-	MV_FLAG_SOC = (1 << 28),
@@ -138,0 +129 @@
+
@@ -140,0 +132,4 @@
+	MV_GENIIE_FLAGS		= MV_COMMON_FLAGS | MV_6XXX_FLAGS |
+				  ATA_FLAG_PMP | ATA_FLAG_ACPI_SATA |
+				  ATA_FLAG_NCQ | ATA_FLAG_AN,
+
@@ -143,0 +139 @@
+	CRQB_PMP_SHIFT		= 12,	/* CRQB Gen-II/IIE PMP shift */
@@ -157,0 +154 @@
+	PCI_COMMAND_MRDTRIG	= (1 << 7),	/* PCI Master Read Trigger */
@@ -164 +161,3 @@
-	MV_PCI_MODE		= 0xd00,
+	MV_PCI_MODE_OFS		= 0xd00,
+	MV_PCI_MODE_MASK	= 0x30,
+
@@ -169 +168 @@
-	MV_PCI_XBAR_TMOUT	= 0x1d04,
+	MV_PCI_XBAR_TMOUT_OFS	= 0x1d04,
@@ -183,6 +182,7 @@
-	HC_MAIN_IRQ_CAUSE_OFS	= 0x1d60,
-	HC_MAIN_IRQ_MASK_OFS	= 0x1d64,
-	HC_SOC_MAIN_IRQ_CAUSE_OFS = 0x20020,
-	HC_SOC_MAIN_IRQ_MASK_OFS = 0x20024,
-	PORT0_ERR		= (1 << 0),	/* shift by port # */
-	PORT0_DONE		= (1 << 1),	/* shift by port # */
+	/* Host Controller Main Interrupt Cause/Mask registers (1 per-chip) */
+	PCI_HC_MAIN_IRQ_CAUSE_OFS = 0x1d60,
+	PCI_HC_MAIN_IRQ_MASK_OFS  = 0x1d64,
+	SOC_HC_MAIN_IRQ_CAUSE_OFS = 0x20020,
+	SOC_HC_MAIN_IRQ_MASK_OFS  = 0x20024,
+	ERR_IRQ			= (1 << 0),	/* shift by port # */
+	DONE_IRQ		= (1 << 1),	/* shift by port # */
@@ -202,7 +202 @@
-	HC_MAIN_RSVD_SOC 	= (0x3fffffb << 6),     /* bits 31-9, 7-6 */
-	HC_MAIN_MASKED_IRQS	= (TRAN_LO_DONE | TRAN_HI_DONE |
-				   PORTS_0_7_COAL_DONE | GPIO_INT | TWSI_INT |
-				   HC_MAIN_RSVD),
-	HC_MAIN_MASKED_IRQS_5	= (PORTS_0_3_COAL_DONE | PORTS_4_7_COAL_DONE |
-				   HC_MAIN_RSVD_5),
-	HC_MAIN_MASKED_IRQS_SOC = (PORTS_0_3_COAL_DONE | HC_MAIN_RSVD_SOC),
+	HC_MAIN_RSVD_SOC	= (0x3fffffb << 6),     /* bits 31-9, 7-6 */
@@ -214,2 +208,2 @@
-	CRPB_DMA_DONE		= (1 << 0),	/* shift by port # */
-	HC_IRQ_COAL		= (1 << 4),	/* IRQ coalescing */
+	DMA_IRQ			= (1 << 0),	/* shift by port # */
+	HC_COAL_IRQ		= (1 << 4),	/* IRQ coalescing */
@@ -225,0 +220,5 @@
+	SATA_FIS_IRQ_AN		= (1 << 9),	/* async notification */
+
+	LTMODE_OFS		= 0x30c,
+	LTMODE_BIT8		= (1 << 8),	/* unknown, but necessary */
+
@@ -227,0 +227,5 @@
+	PHY_MODE4_CFG_MASK	= 0x00000003,	/* phy internal config field */
+	PHY_MODE4_CFG_VALUE	= 0x00000001,	/* phy internal config field */
+	PHY_MODE4_RSVD_ZEROS	= 0x5de3fffa,	/* Gen2e always write zeros */
+	PHY_MODE4_RSVD_ONES	= 0x00000005,	/* Gen2e always write ones */
+
@@ -228,0 +233,9 @@
+	SATA_IFCTL_OFS		= 0x344,
+	SATA_TESTCTL_OFS	= 0x348,
+	SATA_IFSTAT_OFS		= 0x34c,
+	VENDOR_UNIQUE_FIS_OFS	= 0x35c,
+
+	FISCFG_OFS		= 0x360,
+	FISCFG_WAIT_DEV_ERR	= (1 << 8),	/* wait for host on DevErr */
+	FISCFG_SINGLE_SYNC	= (1 << 16),	/* SYNC on DMA activation */
+
@@ -230,3 +243,3 @@
-	MV5_LT_MODE		= 0x30,
-	MV5_PHY_CTL		= 0x0C,
-	SATA_INTERFACE_CTL	= 0x050,
+	MV5_LTMODE_OFS		= 0x30,
+	MV5_PHY_CTL_OFS		= 0x0C,
+	SATA_INTERFACE_CFG_OFS	= 0x050,
@@ -242,0 +256,2 @@
+	EDMA_CFG_EDMA_FBS	= (1 << 16),	/* EDMA FIS-Based Switching */
+	EDMA_CFG_FBS		= (1 << 26),	/* FIS-Based Switching */
@@ -300,0 +316 @@
+
@@ -327 +343 @@
-	ATA_RST			= (1 << 2),	/* reset trans/link/phy */
+	EDMA_RESET		= (1 << 2),	/* reset eng/trans/link/phy */
@@ -329,2 +345,10 @@
-	EDMA_IORDY_TMOUT	= 0x34,
-	EDMA_ARB_CFG		= 0x38,
+	EDMA_STATUS_OFS		= 0x30,		/* EDMA engine status */
+	EDMA_STATUS_CACHE_EMPTY	= (1 << 6),	/* GenIIe command cache empty */
+	EDMA_STATUS_IDLE	= (1 << 7),	/* GenIIe EDMA enabled/idle */
+
+	EDMA_IORDY_TMOUT_OFS	= 0x34,
+	EDMA_ARB_CFG_OFS	= 0x38,
+
+	EDMA_HALTCOND_OFS	= 0x60,		/* GenIIe halt conditions */
+
+	GEN_II_NCQ_MAX_SECTORS	= 256,		/* max sects/io on Gen2 w/NCQ */
@@ -338 +361,0 @@
-	MV_HP_ERRATA_XX42A0	= (1 << 5),
@@ -342,0 +366,2 @@
+	MV_HP_CUT_THROUGH	= (1 << 10),	/* can use EDMA cut-through */
+	MV_HP_FLAG_SOC		= (1 << 11),	/* SystemOnChip, no PCI */
@@ -347 +372,2 @@
-	MV_PP_FLAG_HAD_A_RESET	= (1 << 2),	/* 1st hard reset complete? */
+	MV_PP_FLAG_FBS_EN	= (1 << 2),	/* is EDMA set up for FBS? */
+	MV_PP_FLAG_DELAYED_EH	= (1 << 3),	/* delayed dev err handling */
@@ -353 +379,5 @@
-#define HAS_PCI(host) (!((host)->ports[0]->flags & MV_FLAG_SOC))
+#define IS_PCIE(hpriv) ((hpriv)->hp_flags & MV_HP_PCIE)
+#define IS_SOC(hpriv) ((hpriv)->hp_flags & MV_HP_FLAG_SOC)
+
+#define WINDOW_CTRL(i)		(0x20030 + ((i) << 4))
+#define WINDOW_BASE(i)		(0x20034 + ((i) << 4))
@@ -423,0 +454 @@
+	unsigned int		delayed_eh_pmp_map;
@@ -432,0 +464 @@
+	u32			main_irq_mask;
@@ -437,2 +469,2 @@
-	void __iomem		*main_cause_reg_addr;
-	void __iomem		*main_mask_reg_addr;
+	void __iomem		*main_irq_cause_addr;
+	void __iomem		*main_irq_mask_addr;
@@ -464 +495,0 @@
-static void mv_irq_clear(struct ata_port *ap);
@@ -470,0 +502 @@
+static int mv_qc_defer(struct ata_queued_cmd *qc);
@@ -474 +506,2 @@
-static void mv_error_handler(struct ata_port *ap);
+static int mv_hardreset(struct ata_link *link, unsigned int *class,
+			unsigned long deadline);
@@ -507 +540 @@
-static void mv_channel_reset(struct mv_host_priv *hpriv, void __iomem *mmio,
+static void mv_reset_channel(struct mv_host_priv *hpriv, void __iomem *mmio,
@@ -509,3 +542,12 @@
-static void mv_edma_cfg(struct mv_port_priv *pp, struct mv_host_priv *hpriv,
-			void __iomem *port_mmio, int want_ncq);
-static int __mv_stop_dma(struct ata_port *ap);
+static int mv_stop_edma(struct ata_port *ap);
+static int mv_stop_edma_engine(void __iomem *port_mmio);
+static void mv_edma_cfg(struct ata_port *ap, int want_ncq);
+
+static void mv_pmp_select(struct ata_port *ap, int pmp);
+static int mv_pmp_hardreset(struct ata_link *link, unsigned int *class,
+				unsigned long deadline);
+static int  mv_softreset(struct ata_link *link, unsigned int *class,
+				unsigned long deadline);
+static void mv_pmp_error_handler(struct ata_port *ap);
+static void mv_process_crpb_entries(struct ata_port *ap,
+					struct mv_port_priv *pp);
@@ -518,6 +560 @@
-	.module			= THIS_MODULE,
-	.name			= DRV_NAME,
-	.ioctl			= ata_scsi_ioctl,
-	.queuecommand		= ata_scsi_queuecmd,
-	.can_queue		= ATA_DEF_QUEUE,
-	.this_id		= ATA_SHT_THIS_ID,
+	ATA_BASE_SHT(DRV_NAME),
@@ -525,4 +561,0 @@
-	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
-	.emulated		= ATA_SHT_EMULATED,
-	.use_clustering		= 1,
-	.proc_name		= DRV_NAME,
@@ -530,3 +562,0 @@
-	.slave_configure	= ata_scsi_slave_config,
-	.slave_destroy		= ata_scsi_slave_destroy,
-	.bios_param		= ata_std_bios_param,
@@ -536,5 +566 @@
-	.module			= THIS_MODULE,
-	.name			= DRV_NAME,
-	.ioctl			= ata_scsi_ioctl,
-	.queuecommand		= ata_scsi_queuecmd,
-	.change_queue_depth	= ata_scsi_change_queue_depth,
+	ATA_NCQ_SHT(DRV_NAME),
@@ -542 +567,0 @@
-	.this_id		= ATA_SHT_THIS_ID,
@@ -544,4 +568,0 @@
-	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
-	.emulated		= ATA_SHT_EMULATED,
-	.use_clustering		= 1,
-	.proc_name		= DRV_NAME,
@@ -549,3 +569,0 @@
-	.slave_configure	= ata_scsi_slave_config,
-	.slave_destroy		= ata_scsi_slave_destroy,
-	.bios_param		= ata_std_bios_param,
@@ -554,8 +572,2 @@
-static const struct ata_port_operations mv5_ops = {
-	.tf_load		= ata_tf_load,
-	.tf_read		= ata_tf_read,
-	.check_status		= ata_check_status,
-	.exec_command		= ata_exec_command,
-	.dev_select		= ata_std_dev_select,
-
-	.cable_detect		= ata_cable_sata,
+static struct ata_port_operations mv5_ops = {
+	.inherits		= &ata_sff_port_ops,
@@ -562,0 +575 @@
+	.qc_defer		= mv_qc_defer,
@@ -565 +577,0 @@
-	.data_xfer		= ata_data_xfer,
@@ -567,4 +578,0 @@
-	.irq_clear		= mv_irq_clear,
-	.irq_on			= ata_irq_on,
-
-	.error_handler		= mv_error_handler,
@@ -572,0 +581,3 @@
+	.hardreset		= mv_hardreset,
+	.error_handler		= ata_std_error_handler, /* avoid SFF EH */
+	.post_internal_cmd	= ATA_OP_NULL,
@@ -581 +592,2 @@
-static const struct ata_port_operations mv6_ops = {
+static struct ata_port_operations mv6_ops = {
+	.inherits		= &mv5_ops,
@@ -583,20 +594,0 @@
-	.tf_load		= ata_tf_load,
-	.tf_read		= ata_tf_read,
-	.check_status		= ata_check_status,
-	.exec_command		= ata_exec_command,
-	.dev_select		= ata_std_dev_select,
-
-	.cable_detect		= ata_cable_sata,
-
-	.qc_prep		= mv_qc_prep,
-	.qc_issue		= mv_qc_issue,
-	.data_xfer		= ata_data_xfer,
-
-	.irq_clear		= mv_irq_clear,
-	.irq_on			= ata_irq_on,
-
-	.error_handler		= mv_error_handler,
-	.freeze			= mv_eh_freeze,
-	.thaw			= mv_eh_thaw,
-	.qc_defer		= ata_std_qc_defer,
-
@@ -606,2 +598,4 @@
-	.port_start		= mv_port_start,
-	.port_stop		= mv_port_stop,
+	.pmp_hardreset		= mv_pmp_hardreset,
+	.pmp_softreset		= mv_softreset,
+	.softreset		= mv_softreset,
+	.error_handler		= mv_pmp_error_handler,
@@ -610,9 +604,3 @@
-static const struct ata_port_operations mv_iie_ops = {
-	.tf_load		= ata_tf_load,
-	.tf_read		= ata_tf_read,
-	.check_status		= ata_check_status,
-	.exec_command		= ata_exec_command,
-	.dev_select		= ata_std_dev_select,
-
-	.cable_detect		= ata_cable_sata,
-
+static struct ata_port_operations mv_iie_ops = {
+	.inherits		= &mv6_ops,
+	.dev_config		= ATA_OP_NULL,
@@ -620,16 +607,0 @@
-	.qc_issue		= mv_qc_issue,
-	.data_xfer		= ata_data_xfer,
-
-	.irq_clear		= mv_irq_clear,
-	.irq_on			= ata_irq_on,
-
-	.error_handler		= mv_error_handler,
-	.freeze			= mv_eh_freeze,
-	.thaw			= mv_eh_thaw,
-	.qc_defer		= ata_std_qc_defer,
-
-	.scr_read		= mv_scr_read,
-	.scr_write		= mv_scr_write,
-
-	.port_start		= mv_port_start,
-	.port_stop		= mv_port_stop,
@@ -658,0 +631 @@
+				  ATA_FLAG_PMP | ATA_FLAG_ACPI_SATA |
@@ -665,0 +639 @@
+				  ATA_FLAG_PMP | ATA_FLAG_ACPI_SATA |
@@ -672,2 +646 @@
-		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS |
-				  ATA_FLAG_NCQ,
+		.flags		= MV_GENIIE_FLAGS,
@@ -679,2 +652 @@
-		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS |
-				  ATA_FLAG_NCQ,
+		.flags		= MV_GENIIE_FLAGS,
@@ -686,4 +658,4 @@
-		.flags = MV_COMMON_FLAGS | MV_FLAG_SOC,
-		.pio_mask = 0x1f,      /* pio0-4 */
-		.udma_mask = ATA_UDMA6,
-		.port_ops = &mv_iie_ops,
+		.flags		= MV_GENIIE_FLAGS,
+		.pio_mask	= 0x1f,	/* pio0-4 */
+		.udma_mask	= ATA_UDMA6,
+		.port_ops	= &mv_iie_ops,
@@ -760,5 +731,0 @@
-static inline void __iomem *mv_hc_base(void __iomem *base, unsigned int hc)
-{
-	return (base + MV_SATAHC0_REG_BASE + (hc * MV_SATAHC_REG_SZ));
-}
-
@@ -774,0 +742,23 @@
+/*
+ * Consolidate some rather tricky bit shift calculations.
+ * This is hot-path stuff, so not a function.
+ * Simple code, with two return values, so macro rather than inline.
+ *
+ * port is the sole input, in range 0..7.
+ * shift is one output, for use with main_irq_cause / main_irq_mask registers.
+ * hardport is the other output, in range 0..3.
+ *
+ * Note that port and hardport may be the same variable in some cases.
+ */
+#define MV_PORT_TO_SHIFT_AND_HARDPORT(port, shift, hardport)	\
+{								\
+	shift    = mv_hc_from_port(port) * HC_SHIFT;		\
+	hardport = mv_hardport_from_port(port);			\
+	shift   += hardport * 2;				\
+}
+
+static inline void __iomem *mv_hc_base(void __iomem *base, unsigned int hc)
+{
+	return (base + MV_SATAHC0_REG_BASE + (hc * MV_SATAHC_REG_SZ));
+}
+
@@ -787,0 +778,8 @@
+static void __iomem *mv5_phy_base(void __iomem *mmio, unsigned int port)
+{
+	void __iomem *hc_mmio = mv_hc_base_from_port(mmio, port);
+	unsigned long ofs = (mv_hardport_from_port(port) + 1) * 0x100UL;
+
+	return hc_mmio + ofs;
+}
+
@@ -804,4 +801,0 @@
-static void mv_irq_clear(struct ata_port *ap)
-{
-}
-
@@ -817 +811,2 @@
-	index = (pp->req_idx & MV_MAX_Q_DEPTH_MASK) << EDMA_REQ_Q_PTR_SHIFT;
+	pp->req_idx &= MV_MAX_Q_DEPTH_MASK;	/* paranoia */
+	index = pp->req_idx << EDMA_REQ_Q_PTR_SHIFT;
@@ -823,6 +818 @@
-
-	if (hpriv->hp_flags & MV_HP_ERRATA_XX42A0)
-		writelfl((pp->crqb_dma & 0xffffffff) | index,
-			 port_mmio + EDMA_REQ_Q_OUT_PTR_OFS);
-	else
-		writelfl(index, port_mmio + EDMA_REQ_Q_OUT_PTR_OFS);
+	writelfl(index, port_mmio + EDMA_REQ_Q_OUT_PTR_OFS);
@@ -833 +823,2 @@
-	index = (pp->resp_idx & MV_MAX_Q_DEPTH_MASK) << EDMA_RSP_Q_PTR_SHIFT;
+	pp->resp_idx &= MV_MAX_Q_DEPTH_MASK;	/* paranoia */
+	index = pp->resp_idx << EDMA_RSP_Q_PTR_SHIFT;
@@ -837,7 +828 @@
-
-	if (hpriv->hp_flags & MV_HP_ERRATA_XX42A0)
-		writelfl((pp->crpb_dma & 0xffffffff) | index,
-			 port_mmio + EDMA_RSP_Q_IN_PTR_OFS);
-	else
-		writelfl(index, port_mmio + EDMA_RSP_Q_IN_PTR_OFS);
-
+	writelfl(index, port_mmio + EDMA_RSP_Q_IN_PTR_OFS);
@@ -847,0 +833,27 @@
+static void mv_set_main_irq_mask(struct ata_host *host,
+				 u32 disable_bits, u32 enable_bits)
+{
+	struct mv_host_priv *hpriv = host->private_data;
+	u32 old_mask, new_mask;
+
+	old_mask = hpriv->main_irq_mask;
+	new_mask = (old_mask & ~disable_bits) | enable_bits;
+	if (new_mask != old_mask) {
+		hpriv->main_irq_mask = new_mask;
+		writelfl(new_mask, hpriv->main_irq_mask_addr);
+	}
+}
+
+static void mv_enable_port_irqs(struct ata_port *ap,
+				     unsigned int port_bits)
+{
+	unsigned int shift, hardport, port = ap->port_no;
+	u32 disable_bits, enable_bits;
+
+	MV_PORT_TO_SHIFT_AND_HARDPORT(port, shift, hardport);
+
+	disable_bits = (DONE_IRQ | ERR_IRQ) << shift;
+	enable_bits  = port_bits << shift;
+	mv_set_main_irq_mask(ap->host, disable_bits, enable_bits);
+}
+
@@ -867 +879 @@
-			__mv_stop_dma(ap);
+			mv_stop_edma(ap);
@@ -871 +883 @@
-		int hard_port = mv_hardport_from_port(ap->port_no);
+		int hardport = mv_hardport_from_port(ap->port_no);
@@ -873 +885 @@
-					mv_host_base(ap->host), hard_port);
+					mv_host_base(ap->host), hardport);
@@ -881,2 +893 @@
-		ipending = (DEV_IRQ << hard_port) |
-				(CRPB_DMA_DONE << hard_port);
+		ipending = (DEV_IRQ | DMA_IRQ) << hardport;
@@ -888 +899 @@
-		mv_edma_cfg(pp, hpriv, port_mmio, want_ncq);
+		mv_edma_cfg(ap, want_ncq);
@@ -891 +902,2 @@
-		writelfl(0, port_mmio + SATA_FIS_IRQ_CAUSE_OFS);
+		if (IS_GEN_IIE(hpriv))
+			writelfl(0, port_mmio + SATA_FIS_IRQ_CAUSE_OFS);
@@ -893,0 +906 @@
+		mv_enable_port_irqs(ap, DONE_IRQ|ERR_IRQ);
@@ -898 +911,23 @@
-	WARN_ON(!(EDMA_EN & readl(port_mmio + EDMA_CMD_OFS)));
+}
+
+static void mv_wait_for_edma_empty_idle(struct ata_port *ap)
+{
+	void __iomem *port_mmio = mv_ap_base(ap);
+	const u32 empty_idle = (EDMA_STATUS_CACHE_EMPTY | EDMA_STATUS_IDLE);
+	const int per_loop = 5, timeout = (15 * 1000 / per_loop);
+	int i;
+
+	/*
+	 * Wait for the EDMA engine to finish transactions in progress.
+	 * No idea what a good "timeout" value might be, but measurements
+	 * indicate that it often requires hundreds of microseconds
+	 * with two drives in-use.  So we use the 15msec value above
+	 * as a rough guess at what even more drives might require.
+	 */
+	for (i = 0; i < timeout; ++i) {
+		u32 edma_stat = readl(port_mmio + EDMA_STATUS_OFS);
+		if ((edma_stat & empty_idle) == empty_idle)
+			break;
+		udelay(per_loop);
+	}
+	/* ata_port_printk(ap, KERN_INFO, "%s: %u+ usecs\n", __func__, i); */
@@ -902,5 +937,2 @@
- *      __mv_stop_dma - Disable eDMA engine
- *      @ap: ATA channel to manipulate
- *
- *      Verify the local cache of the eDMA state is accurate with a
- *      WARN_ON.
+ *      mv_stop_edma_engine - Disable eDMA engine
+ *      @port_mmio: io base address
@@ -911 +943 @@
-static int __mv_stop_dma(struct ata_port *ap)
+static int mv_stop_edma_engine(void __iomem *port_mmio)
@@ -913,4 +945 @@
-	void __iomem *port_mmio = mv_ap_base(ap);
-	struct mv_port_priv *pp	= ap->private_data;
-	u32 reg;
-	int i, err = 0;
+	int i;
@@ -918,8 +947,2 @@
-	if (pp->pp_flags & MV_PP_FLAG_EDMA_EN) {
-		/* Disable EDMA if active.   The disable bit auto clears.
-		 */
-		writelfl(EDMA_DS, port_mmio + EDMA_CMD_OFS);
-		pp->pp_flags &= ~MV_PP_FLAG_EDMA_EN;
-	} else {
-		WARN_ON(EDMA_EN & readl(port_mmio + EDMA_CMD_OFS));
-	}
+	/* Disable eDMA.  The disable bit auto clears. */
+	writelfl(EDMA_DS, port_mmio + EDMA_CMD_OFS);
@@ -927,3 +950,3 @@
-	/* now properly wait for the eDMA to stop */
-	for (i = 1000; i > 0; i--) {
-		reg = readl(port_mmio + EDMA_CMD_OFS);
+	/* Wait for the chip to confirm eDMA is off. */
+	for (i = 10000; i > 0; i--) {
+		u32 reg = readl(port_mmio + EDMA_CMD_OFS);
@@ -931,8 +954,2 @@
-			break;
-
-		udelay(100);
-	}
-
-	if (reg & EDMA_EN) {
-		ata_port_printk(ap, KERN_ERR, "Unable to stop eDMA\n");
-		err = -EIO;
+			return 0;
+		udelay(10);
@@ -940,2 +957 @@
-
-	return err;
+	return -EIO;
@@ -944 +960 @@
-static int mv_stop_dma(struct ata_port *ap)
+static int mv_stop_edma(struct ata_port *ap)
@@ -946,6 +962,2 @@
-	unsigned long flags;
-	int rc;
-
-	spin_lock_irqsave(&ap->host->lock, flags);
-	rc = __mv_stop_dma(ap);
-	spin_unlock_irqrestore(&ap->host->lock, flags);
+	void __iomem *port_mmio = mv_ap_base(ap);
+	struct mv_port_priv *pp = ap->private_data;
@@ -953 +965,9 @@
-	return rc;
+	if (!(pp->pp_flags & MV_PP_FLAG_EDMA_EN))
+		return 0;
+	pp->pp_flags &= ~MV_PP_FLAG_EDMA_EN;
+	mv_wait_for_edma_empty_idle(ap);
+	if (mv_stop_edma_engine(port_mmio)) {
+		ata_port_printk(ap, KERN_ERR, "Unable to stop eDMA\n");
+		return -EIO;
+	}
+	return 0;
@@ -1076,0 +1097,5 @@
+	 * Deal with Gen-II ("mv6") hardware quirks/restrictions:
+	 *
+	 * Gen-II does not support NCQ over a port multiplier
+	 *  (no FIS-based switching).
+	 *
@@ -1080,3 +1105,103 @@
-	if (adev->flags & ATA_DFLAG_NCQ)
-		if (adev->max_sectors > ATA_MAX_SECTORS)
-			adev->max_sectors = ATA_MAX_SECTORS;
+	if (adev->flags & ATA_DFLAG_NCQ) {
+		if (sata_pmp_attached(adev->link->ap)) {
+			adev->flags &= ~ATA_DFLAG_NCQ;
+			ata_dev_printk(adev, KERN_INFO,
+				"NCQ disabled for command-based switching\n");
+		} else if (adev->max_sectors > GEN_II_NCQ_MAX_SECTORS) {
+			adev->max_sectors = GEN_II_NCQ_MAX_SECTORS;
+			ata_dev_printk(adev, KERN_INFO,
+				"max_sectors limited to %u for NCQ\n",
+				adev->max_sectors);
+		}
+	}
+}
+
+static int mv_qc_defer(struct ata_queued_cmd *qc)
+{
+	struct ata_link *link = qc->dev->link;
+	struct ata_port *ap = link->ap;
+	struct mv_port_priv *pp = ap->private_data;
+
+	/*
+	 * Don't allow new commands if we're in a delayed EH state
+	 * for NCQ and/or FIS-based switching.
+	 */
+	if (pp->pp_flags & MV_PP_FLAG_DELAYED_EH)
+		return ATA_DEFER_PORT;
+	/*
+	 * If the port is completely idle, then allow the new qc.
+	 */
+	if (ap->nr_active_links == 0)
+		return 0;
+
+	if (pp->pp_flags & MV_PP_FLAG_EDMA_EN) {
+		/*
+		 * The port is operating in host queuing mode (EDMA).
+		 * It can accomodate a new qc if the qc protocol
+		 * is compatible with the current host queue mode.
+		 */
+		if (pp->pp_flags & MV_PP_FLAG_NCQ_EN) {
+			/*
+			 * The host queue (EDMA) is in NCQ mode.
+			 * If the new qc is also an NCQ command,
+			 * then allow the new qc.
+			 */
+			if (qc->tf.protocol == ATA_PROT_NCQ)
+				return 0;
+		} else {
+			/*
+			 * The host queue (EDMA) is in non-NCQ, DMA mode.
+			 * If the new qc is also a non-NCQ, DMA command,
+			 * then allow the new qc.
+			 */
+			if (qc->tf.protocol == ATA_PROT_DMA)
+				return 0;
+		}
+	}
+	return ATA_DEFER_PORT;
+}
+
+static void mv_config_fbs(void __iomem *port_mmio, int want_ncq, int want_fbs)
+{
+	u32 new_fiscfg, old_fiscfg;
+	u32 new_ltmode, old_ltmode;
+	u32 new_haltcond, old_haltcond;
+
+	old_fiscfg   = readl(port_mmio + FISCFG_OFS);
+	old_ltmode   = readl(port_mmio + LTMODE_OFS);
+	old_haltcond = readl(port_mmio + EDMA_HALTCOND_OFS);
+
+	new_fiscfg   = old_fiscfg & ~(FISCFG_SINGLE_SYNC | FISCFG_WAIT_DEV_ERR);
+	new_ltmode   = old_ltmode & ~LTMODE_BIT8;
+	new_haltcond = old_haltcond | EDMA_ERR_DEV;
+
+	if (want_fbs) {
+		new_fiscfg = old_fiscfg | FISCFG_SINGLE_SYNC;
+		new_ltmode = old_ltmode | LTMODE_BIT8;
+		if (want_ncq)
+			new_haltcond &= ~EDMA_ERR_DEV;
+		else
+			new_fiscfg |=  FISCFG_WAIT_DEV_ERR;
+	}
+
+	if (new_fiscfg != old_fiscfg)
+		writelfl(new_fiscfg, port_mmio + FISCFG_OFS);
+	if (new_ltmode != old_ltmode)
+		writelfl(new_ltmode, port_mmio + LTMODE_OFS);
+	if (new_haltcond != old_haltcond)
+		writelfl(new_haltcond, port_mmio + EDMA_HALTCOND_OFS);
+}
+
+static void mv_60x1_errata_sata25(struct ata_port *ap, int want_ncq)
+{
+	struct mv_host_priv *hpriv = ap->host->private_data;
+	u32 old, new;
+
+	/* workaround for 88SX60x1 FEr SATA#25 (part 1) */
+	old = readl(hpriv->base + MV_GPIO_PORT_CTL_OFS);
+	if (want_ncq)
+		new = old | (1 << 22);
+	else
+		new = old & ~(1 << 22);
+	if (new != old)
+		writel(new, hpriv->base + MV_GPIO_PORT_CTL_OFS);
@@ -1085,2 +1210 @@
-static void mv_edma_cfg(struct mv_port_priv *pp, struct mv_host_priv *hpriv,
-			void __iomem *port_mmio, int want_ncq)
+static void mv_edma_cfg(struct ata_port *ap, int want_ncq)
@@ -1088,0 +1213,3 @@
+	struct mv_port_priv *pp    = ap->private_data;
+	struct mv_host_priv *hpriv = ap->host->private_data;
+	void __iomem *port_mmio    = mv_ap_base(ap);
@@ -1091,0 +1219 @@
+	pp->pp_flags &= ~MV_PP_FLAG_FBS_EN;
@@ -1096 +1224 @@
-	else if (IS_GEN_II(hpriv))
+	else if (IS_GEN_II(hpriv)) {
@@ -1097,0 +1226,20 @@
+		mv_60x1_errata_sata25(ap, want_ncq);
+
+	} else if (IS_GEN_IIE(hpriv)) {
+		int want_fbs = sata_pmp_attached(ap);
+		/*
+		 * Possible future enhancement:
+		 *
+		 * The chip can use FBS with non-NCQ, if we allow it,
+		 * But first we need to have the error handling in place
+		 * for this mode (datasheet section 7.3.15.4.2.3).
+		 * So disallow non-NCQ FBS for now.
+		 */
+		want_fbs &= want_ncq;
+
+		mv_config_fbs(port_mmio, want_ncq, want_fbs);
+
+		if (want_fbs) {
+			pp->pp_flags |= MV_PP_FLAG_FBS_EN;
+			cfg |= EDMA_CFG_EDMA_FBS; /* FIS-based switching */
+		}
@@ -1099 +1246,0 @@
-	else if (IS_GEN_IIE(hpriv)) {
@@ -1102,2 +1249,4 @@
-		cfg |= (1 << 18);	/* enab early completion */
-		cfg |= (1 << 17);	/* enab cut-through (dis stor&forwrd) */
+		if (!IS_SOC(hpriv))
+			cfg |= (1 << 18);	/* enab early completion */
+		if (hpriv->hp_flags & MV_HP_CUT_THROUGH)
+			cfg |= (1 << 17); /* enab cut-thru (dis stor&forwrd) */
@@ -1159,2 +1307,0 @@
-	void __iomem *port_mmio = mv_ap_base(ap);
-	unsigned long flags;
@@ -1177,0 +1325,3 @@
+	/* 6041/6081 Rev. "C0" (and newer) are okay with async notify */
+	if (hpriv->hp_flags & MV_HP_ERRATA_60X1C0)
+		ap->flags |= ATA_FLAG_AN;
@@ -1193,12 +1342,0 @@
-
-	spin_lock_irqsave(&ap->host->lock, flags);
-
-	mv_edma_cfg(pp, hpriv, port_mmio, 0);
-	mv_set_edma_ptrs(port_mmio, hpriv, pp);
-
-	spin_unlock_irqrestore(&ap->host->lock, flags);
-
-	/* Don't turn on EDMA here...do it before DMA commands only.  Else
-	 * we'll be unable to send non-data, PIO, etc due to restricted access
-	 * to shadow regs.
-	 */
@@ -1223 +1361,2 @@
-	mv_stop_dma(ap);
+	mv_stop_edma(ap);
+	mv_enable_port_irqs(ap, 0);
@@ -1308,0 +1448 @@
+	flags |= (qc->dev->link->pmp & 0xf) << CRQB_PMP_SHIFT;
@@ -1311 +1451 @@
-	in_index = pp->req_idx & MV_MAX_Q_DEPTH_MASK;
+	in_index = pp->req_idx;
@@ -1393,2 +1533 @@
-	/* Fill in Gen IIE command request block
-	 */
+	/* Fill in Gen IIE command request block */
@@ -1400,0 +1540 @@
+	flags |= (qc->dev->link->pmp & 0xf) << CRQB_PMP_SHIFT;
@@ -1403 +1543 @@
-	in_index = pp->req_idx & MV_MAX_Q_DEPTH_MASK;
+	in_index = pp->req_idx;
@@ -1458 +1598,20 @@
-		/* We're about to send a non-EDMA capable command to the
+		static int limit_warnings = 10;
+		/*
+		 * Errata SATA#16, SATA#24: warn if multiple DRQs expected.
+		 *
+		 * Someday, we might implement special polling workarounds
+		 * for these, but it all seems rather unnecessary since we
+		 * normally use only DMA for commands which transfer more
+		 * than a single block of data.
+		 *
+		 * Much of the time, this could just work regardless.
+		 * So for now, just log the incident, and allow the attempt.
+		 */
+		if (limit_warnings > 0 && (qc->nbytes / qc->sect_size) > 1) {
+			--limit_warnings;
+			ata_link_printk(qc->dev->link, KERN_WARNING, DRV_NAME
+					": attempting PIO w/multiple DRQ: "
+					"this may fail due to h/w errata\n");
+		}
+		/*
+		 * We're about to send a non-EDMA capable command to the
@@ -1462,2 +1621,4 @@
-		__mv_stop_dma(ap);
-		return ata_qc_issue_prot(qc);
+		mv_stop_edma(ap);
+		mv_enable_port_irqs(ap, ERR_IRQ);
+		mv_pmp_select(ap, qc->dev->link->pmp);
+		return ata_sff_qc_issue(qc);
@@ -1468,3 +1629,2 @@
-	pp->req_idx++;
-
-	in_index = (pp->req_idx & MV_MAX_Q_DEPTH_MASK) << EDMA_REQ_Q_PTR_SHIFT;
+	pp->req_idx = (pp->req_idx + 1) & MV_MAX_Q_DEPTH_MASK;
+	in_index = pp->req_idx << EDMA_REQ_Q_PTR_SHIFT;
@@ -1479,15 +1639 @@
-/**
- *      mv_err_intr - Handle error interrupts on the port
- *      @ap: ATA channel to manipulate
- *      @reset_allowed: bool: 0 == don't trigger from reset here
- *
- *      In most cases, just clear the interrupt and move on.  However,
- *      some cases require an eDMA reset, which is done right before
- *      the COMRESET in mv_phy_reset().  The SERR case requires a
- *      clear of pending errors in the SATA SERROR register.  Finally,
- *      if the port disabled DMA, update our cached copy to match.
- *
- *      LOCKING:
- *      Inherited from caller.
- */
-static void mv_err_intr(struct ata_port *ap, struct ata_queued_cmd *qc)
+static struct ata_queued_cmd *mv_get_active_qc(struct ata_port *ap)
@@ -1495,2 +1640,0 @@
-	void __iomem *port_mmio = mv_ap_base(ap);
-	u32 edma_err_cause, eh_freeze_mask, serr = 0;
@@ -1498,4 +1642 @@
-	struct mv_host_priv *hpriv = ap->host->private_data;
-	unsigned int edma_enabled = (pp->pp_flags & MV_PP_FLAG_EDMA_EN);
-	unsigned int action = 0, err_mask = 0;
-	struct ata_eh_info *ehi = &ap->link.eh_info;
+	struct ata_queued_cmd *qc;
@@ -1503 +1644,12 @@
-	ata_ehi_clear_desc(ehi);
+	if (pp->pp_flags & MV_PP_FLAG_NCQ_EN)
+		return NULL;
+	qc = ata_qc_from_tag(ap, ap->link.active_tag);
+	if (qc && (qc->tf.flags & ATA_TFLAG_POLLING))
+		qc = NULL;
+	return qc;
+}
+
+static void mv_pmp_error_handler(struct ata_port *ap)
+{
+	unsigned int pmp, pmp_map;
+	struct mv_port_priv *pp = ap->private_data;
@@ -1505,3 +1657,6 @@
-	if (!edma_enabled) {
-		/* just a guess: do we need to do this? should we
-		 * expand this, and do it in all cases?
+	if (pp->pp_flags & MV_PP_FLAG_DELAYED_EH) {
+		/*
+		 * Perform NCQ error analysis on failed PMPs
+		 * before we freeze the port entirely.
+		 *
+		 * The failed PMPs are marked earlier by mv_pmp_eh_prep().
@@ -1509,2 +1664,11 @@
-		sata_scr_read(&ap->link, SCR_ERROR, &serr);
-		sata_scr_write_flush(&ap->link, SCR_ERROR, serr);
+		pmp_map = pp->delayed_eh_pmp_map;
+		pp->pp_flags &= ~MV_PP_FLAG_DELAYED_EH;
+		for (pmp = 0; pmp_map != 0; pmp++) {
+			unsigned int this_pmp = (1 << pmp);
+			if (pmp_map & this_pmp) {
+				struct ata_link *link = &ap->pmp_link[pmp];
+				pmp_map &= ~this_pmp;
+				ata_eh_analyze_ncq_error(link);
+			}
+		}
+		ata_port_freeze(ap);
@@ -1511,0 +1676,2 @@
+	sata_pmp_error_handler(ap);
+}
@@ -1513 +1679,3 @@
-	edma_err_cause = readl(port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
+static unsigned int mv_get_err_pmp_map(struct ata_port *ap)
+{
+	void __iomem *port_mmio = mv_ap_base(ap);
@@ -1515 +1683,7 @@
-	ata_ehi_push_desc(ehi, "edma_err 0x%08x", edma_err_cause);
+	return readl(port_mmio + SATA_TESTCTL_OFS) >> 16;
+}
+
+static void mv_pmp_eh_prep(struct ata_port *ap, unsigned int pmp_map)
+{
+	struct ata_eh_info *ehi;
+	unsigned int pmp;
@@ -1518 +1692 @@
-	 * all generations share these EDMA error cause bits
+	 * Initialize EH info for PMPs which saw device errors
@@ -1519,0 +1694,5 @@
+	ehi = &ap->link.eh_info;
+	for (pmp = 0; pmp_map != 0; pmp++) {
+		unsigned int this_pmp = (1 << pmp);
+		if (pmp_map & this_pmp) {
+			struct ata_link *link = &ap->pmp_link[pmp];
@@ -1521,14 +1700,8 @@
-	if (edma_err_cause & EDMA_ERR_DEV)
-		err_mask |= AC_ERR_DEV;
-	if (edma_err_cause & (EDMA_ERR_D_PAR | EDMA_ERR_PRD_PAR |
-			EDMA_ERR_CRQB_PAR | EDMA_ERR_CRPB_PAR |
-			EDMA_ERR_INTRL_PAR)) {
-		err_mask |= AC_ERR_ATA_BUS;
-		action |= ATA_EH_HARDRESET;
-		ata_ehi_push_desc(ehi, "parity error");
-	}
-	if (edma_err_cause & (EDMA_ERR_DEV_DCON | EDMA_ERR_DEV_CON)) {
-		ata_ehi_hotplugged(ehi);
-		ata_ehi_push_desc(ehi, edma_err_cause & EDMA_ERR_DEV_DCON ?
-			"dev disconnect" : "dev connect");
-		action |= ATA_EH_HARDRESET;
+			pmp_map &= ~this_pmp;
+			ehi = &link->eh_info;
+			ata_ehi_clear_desc(ehi);
+			ata_ehi_push_desc(ehi, "dev err");
+			ehi->err_mask |= AC_ERR_DEV;
+			ehi->action |= ATA_EH_RESET;
+			ata_link_abort(link);
+		}
@@ -1535,0 +1709 @@
+}
@@ -1537,2 +1711,4 @@
-	if (IS_GEN_I(hpriv)) {
-		eh_freeze_mask = EDMA_EH_FREEZE_5;
+static int mv_req_q_empty(struct ata_port *ap)
+{
+	void __iomem *port_mmio = mv_ap_base(ap);
+	u32 in_ptr, out_ptr;
@@ -1540,3 +1716,227 @@
-		if (edma_err_cause & EDMA_ERR_SELF_DIS_5) {
-			pp = ap->private_data;
-			pp->pp_flags &= ~MV_PP_FLAG_EDMA_EN;
+	in_ptr  = (readl(port_mmio + EDMA_REQ_Q_IN_PTR_OFS)
+			>> EDMA_REQ_Q_PTR_SHIFT) & MV_MAX_Q_DEPTH_MASK;
+	out_ptr = (readl(port_mmio + EDMA_REQ_Q_OUT_PTR_OFS)
+			>> EDMA_REQ_Q_PTR_SHIFT) & MV_MAX_Q_DEPTH_MASK;
+	return (in_ptr == out_ptr);	/* 1 == queue_is_empty */
+}
+
+static int mv_handle_fbs_ncq_dev_err(struct ata_port *ap)
+{
+	struct mv_port_priv *pp = ap->private_data;
+	int failed_links;
+	unsigned int old_map, new_map;
+
+	/*
+	 * Device error during FBS+NCQ operation:
+	 *
+	 * Set a port flag to prevent further I/O being enqueued.
+	 * Leave the EDMA running to drain outstanding commands from this port.
+	 * Perform the post-mortem/EH only when all responses are complete.
+	 * Follow recovery sequence from 6042/7042 datasheet (7.3.15.4.2.2).
+	 */
+	if (!(pp->pp_flags & MV_PP_FLAG_DELAYED_EH)) {
+		pp->pp_flags |= MV_PP_FLAG_DELAYED_EH;
+		pp->delayed_eh_pmp_map = 0;
+	}
+	old_map = pp->delayed_eh_pmp_map;
+	new_map = old_map | mv_get_err_pmp_map(ap);
+
+	if (old_map != new_map) {
+		pp->delayed_eh_pmp_map = new_map;
+		mv_pmp_eh_prep(ap, new_map & ~old_map);
+	}
+	failed_links = hweight16(new_map);
+
+	ata_port_printk(ap, KERN_INFO, "%s: pmp_map=%04x qc_map=%04x "
+			"failed_links=%d nr_active_links=%d\n",
+			__func__, pp->delayed_eh_pmp_map,
+			ap->qc_active, failed_links,
+			ap->nr_active_links);
+
+	if (ap->nr_active_links <= failed_links && mv_req_q_empty(ap)) {
+		mv_process_crpb_entries(ap, pp);
+		mv_stop_edma(ap);
+		mv_eh_freeze(ap);
+		ata_port_printk(ap, KERN_INFO, "%s: done\n", __func__);
+		return 1;	/* handled */
+	}
+	ata_port_printk(ap, KERN_INFO, "%s: waiting\n", __func__);
+	return 1;	/* handled */
+}
+
+static int mv_handle_fbs_non_ncq_dev_err(struct ata_port *ap)
+{
+	/*
+	 * Possible future enhancement:
+	 *
+	 * FBS+non-NCQ operation is not yet implemented.
+	 * See related notes in mv_edma_cfg().
+	 *
+	 * Device error during FBS+non-NCQ operation:
+	 *
+	 * We need to snapshot the shadow registers for each failed command.
+	 * Follow recovery sequence from 6042/7042 datasheet (7.3.15.4.2.3).
+	 */
+	return 0;	/* not handled */
+}
+
+static int mv_handle_dev_err(struct ata_port *ap, u32 edma_err_cause)
+{
+	struct mv_port_priv *pp = ap->private_data;
+
+	if (!(pp->pp_flags & MV_PP_FLAG_EDMA_EN))
+		return 0;	/* EDMA was not active: not handled */
+	if (!(pp->pp_flags & MV_PP_FLAG_FBS_EN))
+		return 0;	/* FBS was not active: not handled */
+
+	if (!(edma_err_cause & EDMA_ERR_DEV))
+		return 0;	/* non DEV error: not handled */
+	edma_err_cause &= ~EDMA_ERR_IRQ_TRANSIENT;
+	if (edma_err_cause & ~(EDMA_ERR_DEV | EDMA_ERR_SELF_DIS))
+		return 0;	/* other problems: not handled */
+
+	if (pp->pp_flags & MV_PP_FLAG_NCQ_EN) {
+		/*
+		 * EDMA should NOT have self-disabled for this case.
+		 * If it did, then something is wrong elsewhere,
+		 * and we cannot handle it here.
+		 */
+		if (edma_err_cause & EDMA_ERR_SELF_DIS) {
+			ata_port_printk(ap, KERN_WARNING,
+				"%s: err_cause=0x%x pp_flags=0x%x\n",
+				__func__, edma_err_cause, pp->pp_flags);
+			return 0; /* not handled */
+		}
+		return mv_handle_fbs_ncq_dev_err(ap);
+	} else {
+		/*
+		 * EDMA should have self-disabled for this case.
+		 * If it did not, then something is wrong elsewhere,
+		 * and we cannot handle it here.
+		 */
+		if (!(edma_err_cause & EDMA_ERR_SELF_DIS)) {
+			ata_port_printk(ap, KERN_WARNING,
+				"%s: err_cause=0x%x pp_flags=0x%x\n",
+				__func__, edma_err_cause, pp->pp_flags);
+			return 0; /* not handled */
+		}
+		return mv_handle_fbs_non_ncq_dev_err(ap);
+	}
+	return 0;	/* not handled */
+}
+
+static void mv_unexpected_intr(struct ata_port *ap, int edma_was_enabled)
+{
+	struct ata_eh_info *ehi = &ap->link.eh_info;
+	char *when = "idle";
+
+	ata_ehi_clear_desc(ehi);
+	if (!ap || (ap->flags & ATA_FLAG_DISABLED)) {
+		when = "disabled";
+	} else if (edma_was_enabled) {
+		when = "EDMA enabled";
+	} else {
+		struct ata_queued_cmd *qc = ata_qc_from_tag(ap, ap->link.active_tag);
+		if (qc && (qc->tf.flags & ATA_TFLAG_POLLING))
+			when = "polling";
+	}
+	ata_ehi_push_desc(ehi, "unexpected device interrupt while %s", when);
+	ehi->err_mask |= AC_ERR_OTHER;
+	ehi->action   |= ATA_EH_RESET;
+	ata_port_freeze(ap);
+}
+
+/**
+ *      mv_err_intr - Handle error interrupts on the port
+ *      @ap: ATA channel to manipulate
+ *      @qc: affected command (non-NCQ), or NULL
+ *
+ *      Most cases require a full reset of the chip's state machine,
+ *      which also performs a COMRESET.
+ *      Also, if the port disabled DMA, update our cached copy to match.
+ *
+ *      LOCKING:
+ *      Inherited from caller.
+ */
+static void mv_err_intr(struct ata_port *ap)
+{
+	void __iomem *port_mmio = mv_ap_base(ap);
+	u32 edma_err_cause, eh_freeze_mask, serr = 0;
+	u32 fis_cause = 0;
+	struct mv_port_priv *pp = ap->private_data;
+	struct mv_host_priv *hpriv = ap->host->private_data;
+	unsigned int action = 0, err_mask = 0;
+	struct ata_eh_info *ehi = &ap->link.eh_info;
+	struct ata_queued_cmd *qc;
+	int abort = 0;
+
+	/*
+	 * Read and clear the SError and err_cause bits.
+	 * For GenIIe, if EDMA_ERR_TRANS_IRQ_7 is set, we also must read/clear
+	 * the FIS_IRQ_CAUSE register before clearing edma_err_cause.
+	 */
+	sata_scr_read(&ap->link, SCR_ERROR, &serr);
+	sata_scr_write_flush(&ap->link, SCR_ERROR, serr);
+
+	edma_err_cause = readl(port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
+	if (IS_GEN_IIE(hpriv) && (edma_err_cause & EDMA_ERR_TRANS_IRQ_7)) {
+		fis_cause = readl(port_mmio + SATA_FIS_IRQ_CAUSE_OFS);
+		writelfl(~fis_cause, port_mmio + SATA_FIS_IRQ_CAUSE_OFS);
+	}
+	writelfl(~edma_err_cause, port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
+
+	if (edma_err_cause & EDMA_ERR_DEV) {
+		/*
+		 * Device errors during FIS-based switching operation
+		 * require special handling.
+		 */
+		if (mv_handle_dev_err(ap, edma_err_cause))
+			return;
+	}
+
+	qc = mv_get_active_qc(ap);
+	ata_ehi_clear_desc(ehi);
+	ata_ehi_push_desc(ehi, "edma_err_cause=%08x pp_flags=%08x",
+			  edma_err_cause, pp->pp_flags);
+
+	if (IS_GEN_IIE(hpriv) && (edma_err_cause & EDMA_ERR_TRANS_IRQ_7)) {
+		ata_ehi_push_desc(ehi, "fis_cause=%08x", fis_cause);
+		if (fis_cause & SATA_FIS_IRQ_AN) {
+			u32 ec = edma_err_cause &
+			       ~(EDMA_ERR_TRANS_IRQ_7 | EDMA_ERR_IRQ_TRANSIENT);
+			sata_async_notification(ap);
+			if (!ec)
+				return; /* Just an AN; no need for the nukes */
+			ata_ehi_push_desc(ehi, "SDB notify");
+		}
+	}
+	/*
+	 * All generations share these EDMA error cause bits:
+	 */
+	if (edma_err_cause & EDMA_ERR_DEV) {
+		err_mask |= AC_ERR_DEV;
+		action |= ATA_EH_RESET;
+		ata_ehi_push_desc(ehi, "dev error");
+	}
+	if (edma_err_cause & (EDMA_ERR_D_PAR | EDMA_ERR_PRD_PAR |
+			EDMA_ERR_CRQB_PAR | EDMA_ERR_CRPB_PAR |
+			EDMA_ERR_INTRL_PAR)) {
+		err_mask |= AC_ERR_ATA_BUS;
+		action |= ATA_EH_RESET;
+		ata_ehi_push_desc(ehi, "parity error");
+	}
+	if (edma_err_cause & (EDMA_ERR_DEV_DCON | EDMA_ERR_DEV_CON)) {
+		ata_ehi_hotplugged(ehi);
+		ata_ehi_push_desc(ehi, edma_err_cause & EDMA_ERR_DEV_DCON ?
+			"dev disconnect" : "dev connect");
+		action |= ATA_EH_RESET;
+	}
+
+	/*
+	 * Gen-I has a different SELF_DIS bit,
+	 * different FREEZE bits, and no SERR bit:
+	 */
+	if (IS_GEN_I(hpriv)) {
+		eh_freeze_mask = EDMA_EH_FREEZE_5;
+		if (edma_err_cause & EDMA_ERR_SELF_DIS_5) {
+			pp->pp_flags &= ~MV_PP_FLAG_EDMA_EN;
@@ -1547 +1946,0 @@
-
@@ -1549 +1947,0 @@
-			pp = ap->private_data;
@@ -1553 +1950,0 @@
-
@@ -1555,4 +1952,3 @@
-			sata_scr_read(&ap->link, SCR_ERROR, &serr);
-			sata_scr_write_flush(&ap->link, SCR_ERROR, serr);
-			err_mask = AC_ERR_ATA_BUS;
-			action |= ATA_EH_HARDRESET;
+			ata_ehi_push_desc(ehi, "SError=%08x", serr);
+			err_mask |= AC_ERR_ATA_BUS;
+			action |= ATA_EH_RESET;
@@ -1562,3 +1957,0 @@
-	/* Clear EDMA now that SERR cleanup done */
-	writelfl(~edma_err_cause, port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
-
@@ -1567 +1960 @@
-		action |= ATA_EH_HARDRESET;
+		action |= ATA_EH_RESET;
@@ -1578 +1971,12 @@
-	if (edma_err_cause & eh_freeze_mask)
+	if (err_mask == AC_ERR_DEV) {
+		/*
+		 * Cannot do ata_port_freeze() here,
+		 * because it would kill PIO access,
+		 * which is needed for further diagnosis.
+		 */
+		mv_eh_freeze(ap);
+		abort = 1;
+	} else if (edma_err_cause & eh_freeze_mask) {
+		/*
+		 * Note to self: ata_port_freeze() calls ata_port_abort()
+		 */
@@ -1580,2 +1984,10 @@
-	else
-		ata_port_abort(ap);
+	} else {
+		abort = 1;
+	}
+
+	if (abort) {
+		if (qc)
+			ata_link_abort(qc->dev->link);
+		else
+			ata_port_abort(ap);
+	}
@@ -1584 +1996,2 @@
-static void mv_intr_pio(struct ata_port *ap)
+static void mv_process_crpb_response(struct ata_port *ap,
+		struct mv_crpb *response, unsigned int tag, int ncq_enabled)
@@ -1586,7 +1999 @@
-	struct ata_queued_cmd *qc;
-	u8 ata_status;
-
-	/* ignore spurious intr if drive still BUSY */
-	ata_status = readb(ap->ioaddr.status_addr);
-	if (unlikely(ata_status & ATA_BUSY))
-		return;
+	struct ata_queued_cmd *qc = ata_qc_from_tag(ap, tag);
@@ -1594,10 +2001,26 @@
-	/* get active ATA command */
-	qc = ata_qc_from_tag(ap, ap->link.active_tag);
-	if (unlikely(!qc))			/* no active tag */
-		return;
-	if (qc->tf.flags & ATA_TFLAG_POLLING)	/* polling; we don't own qc */
-		return;
-
-	/* and finally, complete the ATA command */
-	qc->err_mask |= ac_err_mask(ata_status);
-	ata_qc_complete(qc);
+	if (qc) {
+		u8 ata_status;
+		u16 edma_status = le16_to_cpu(response->flags);
+		/*
+		 * edma_status from a response queue entry:
+		 *   LSB is from EDMA_ERR_IRQ_CAUSE_OFS (non-NCQ only).
+		 *   MSB is saved ATA status from command completion.
+		 */
+		if (!ncq_enabled) {
+			u8 err_cause = edma_status & 0xff & ~EDMA_ERR_DEV;
+			if (err_cause) {
+				/*
+				 * Error will be seen/handled by mv_err_intr().
+				 * So do nothing at all here.
+				 */
+				return;
+			}
+		}
+		ata_status = edma_status >> CRPB_FLAG_STATUS_SHIFT;
+		if (!ac_err_mask(ata_status))
+			ata_qc_complete(qc);
+		/* else: leave it for mv_err_intr() */
+	} else {
+		ata_port_printk(ap, KERN_ERR, "%s: no qc for tag=%d\n",
+				__func__, tag);
+	}
@@ -1606 +2029 @@
-static void mv_intr_edma(struct ata_port *ap)
+static void mv_process_crpb_entries(struct ata_port *ap, struct mv_port_priv *pp)
@@ -1610,3 +2033 @@
-	struct mv_port_priv *pp = ap->private_data;
-	struct ata_queued_cmd *qc;
-	u32 out_index, in_index;
+	u32 in_index;
@@ -1613,0 +2035 @@
+	int ncq_enabled = (pp->pp_flags & MV_PP_FLAG_NCQ_EN);
@@ -1615 +2037 @@
-	/* get h/w response queue pointer */
+	/* Get the hardware queue position index */
@@ -1619,2 +2041,2 @@
-	while (1) {
-		u16 status;
+	/* Process new responses from since the last time we looked */
+	while (in_index != pp->resp_idx) {
@@ -1621,0 +2044 @@
+		struct mv_crpb *response = &pp->crpb[pp->resp_idx];
@@ -1623,4 +2046 @@
-		/* get s/w response queue last-read pointer, and compare */
-		out_index = pp->resp_idx & MV_MAX_Q_DEPTH_MASK;
-		if (in_index == out_index)
-			break;
+		pp->resp_idx = (pp->resp_idx + 1) & MV_MAX_Q_DEPTH_MASK;
@@ -1628,2 +2048,2 @@
-		/* 50xx: get active ATA command */
-		if (IS_GEN_I(hpriv))
+		if (IS_GEN_I(hpriv)) {
+			/* 50xx: no NCQ, only one command active at a time */
@@ -1631,25 +2051,3 @@
-
-		/* Gen II/IIE: get active ATA command via tag, to enable
-		 * support for queueing.  this works transparently for
-		 * queued and non-queued modes.
-		 */
-		else
-			tag = le16_to_cpu(pp->crpb[out_index].id) & 0x1f;
-
-		qc = ata_qc_from_tag(ap, tag);
-
-		/* For non-NCQ mode, the lower 8 bits of status
-		 * are from EDMA_ERR_IRQ_CAUSE_OFS,
-		 * which should be zero if all went well.
-		 */
-		status = le16_to_cpu(pp->crpb[out_index].flags);
-		if ((status & 0xff) && !(pp->pp_flags & MV_PP_FLAG_NCQ_EN)) {
-			mv_err_intr(ap, qc);
-			return;
-		}
-
-		/* and finally, complete the ATA command */
-		if (qc) {
-			qc->err_mask |=
-				ac_err_mask(status >> CRPB_FLAG_STATUS_SHIFT);
-			ata_qc_complete(qc);
+		} else {
+			/* Gen II/IIE: get command tag from CRPB entry */
+			tag = le16_to_cpu(response->id) & 0x1f;
@@ -1657,5 +2055 @@
-
-		/* advance software response queue pointer, to
-		 * indicate (after the loop completes) to hardware
-		 * that we have consumed a response queue entry.
-		 */
+		mv_process_crpb_response(ap, response, tag, ncq_enabled);
@@ -1663 +2056,0 @@
-		pp->resp_idx++;
@@ -1665,0 +2059 @@
+	/* Update the software queue position index in hardware */
@@ -1668 +2062 @@
-			 (out_index << EDMA_RSP_Q_PTR_SHIFT),
+			 (pp->resp_idx << EDMA_RSP_Q_PTR_SHIFT),
@@ -1671,0 +2066,38 @@
+static void mv_port_intr(struct ata_port *ap, u32 port_cause)
+{
+	struct mv_port_priv *pp;
+	int edma_was_enabled;
+
+	if (!ap || (ap->flags & ATA_FLAG_DISABLED)) {
+		mv_unexpected_intr(ap, 0);
+		return;
+	}
+	/*
+	 * Grab a snapshot of the EDMA_EN flag setting,
+	 * so that we have a consistent view for this port,
+	 * even if something we call of our routines changes it.
+	 */
+	pp = ap->private_data;
+	edma_was_enabled = (pp->pp_flags & MV_PP_FLAG_EDMA_EN);
+	/*
+	 * Process completed CRPB response(s) before other events.
+	 */
+	if (edma_was_enabled && (port_cause & DONE_IRQ)) {
+		mv_process_crpb_entries(ap, pp);
+		if (pp->pp_flags & MV_PP_FLAG_DELAYED_EH)
+			mv_handle_fbs_ncq_dev_err(ap);
+	}
+	/*
+	 * Handle chip-reported errors, or continue on to handle PIO.
+	 */
+	if (unlikely(port_cause & ERR_IRQ)) {
+		mv_err_intr(ap);
+	} else if (!edma_was_enabled) {
+		struct ata_queued_cmd *qc = mv_get_active_qc(ap);
+		if (qc)
+			ata_sff_host_intr(ap, qc);
+		else
+			mv_unexpected_intr(ap, edma_was_enabled);
+	}
+}
+
@@ -1675,9 +2107 @@
- *      @relevant: port error bits relevant to this host controller
- *      @hc: which host controller we're to look at
- *
- *      Read then write clear the HC interrupt status then walk each
- *      port connected to the HC and see if it needs servicing.  Port
- *      success ints are reported in the HC interrupt status reg, the
- *      port error ints are reported in the higher level main
- *      interrupt status register and thus are passed in via the
- *      'relevant' argument.
+ *      @main_irq_cause: Main interrupt cause register for the chip.
@@ -1688 +2112 @@
-static void mv_host_intr(struct ata_host *host, u32 relevant, unsigned int hc)
+static int mv_host_intr(struct ata_host *host, u32 main_irq_cause)
@@ -1691,4 +2115,2 @@
-	void __iomem *mmio = hpriv->base;
-	void __iomem *hc_mmio = mv_hc_base(mmio, hc);
-	u32 hc_irq_cause;
-	int port, port0, last_port;
+	void __iomem *mmio = hpriv->base, *hc_mmio;
+	unsigned int handled = 0, port;
@@ -1696,20 +2118 @@
-	if (hc == 0)
-		port0 = 0;
-	else
-		port0 = MV_PORTS_PER_HC;
-
-	if (HAS_PCI(host))
-		last_port = port0 + MV_PORTS_PER_HC;
-	else
-		last_port = port0 + hpriv->n_ports;
-	/* we'll need the HC success int register in most cases */
-	hc_irq_cause = readl(hc_mmio + HC_IRQ_CAUSE_OFS);
-	if (!hc_irq_cause)
-		return;
-
-	writelfl(~hc_irq_cause, hc_mmio + HC_IRQ_CAUSE_OFS);
-
-	VPRINTK("ENTER, hc%u relevant=0x%08x HC IRQ cause=0x%08x\n",
-		hc, relevant, hc_irq_cause);
-
-	for (port = port0; port < last_port; port++) {
+	for (port = 0; port < hpriv->n_ports; port++) {
@@ -1717,5 +2120 @@
-		struct mv_port_priv *pp;
-		int have_err_bits, hard_port, shift;
-
-		if ((!ap) || (ap->flags & ATA_FLAG_DISABLED))
-			continue;
+		unsigned int p, shift, hardport, port_cause;
@@ -1723,13 +2122,13 @@
-		pp = ap->private_data;
-
-		shift = port << 1;		/* (port * 2) */
-		if (port >= MV_PORTS_PER_HC) {
-			shift++;	/* skip bit 8 in the HC Main IRQ reg */
-		}
-		have_err_bits = ((PORT0_ERR << shift) & relevant);
-
-		if (unlikely(have_err_bits)) {
-			struct ata_queued_cmd *qc;
-
-			qc = ata_qc_from_tag(ap, ap->link.active_tag);
-			if (qc && (qc->tf.flags & ATA_TFLAG_POLLING))
+		MV_PORT_TO_SHIFT_AND_HARDPORT(port, shift, hardport);
+		/*
+		 * Each hc within the host has its own hc_irq_cause register,
+		 * where the interrupting ports bits get ack'd.
+		 */
+		if (hardport == 0) {	/* first port on this hc ? */
+			u32 hc_cause = (main_irq_cause >> shift) & HC0_IRQ_PEND;
+			u32 port_mask, ack_irqs;
+			/*
+			 * Skip this entire hc if nothing pending for any ports
+			 */
+			if (!hc_cause) {
+				port += MV_PORTS_PER_HC - 1;
@@ -1737,13 +2136,24 @@
-
-			mv_err_intr(ap, qc);
-			continue;
-		}
-
-		hard_port = mv_hardport_from_port(port); /* range 0..3 */
-
-		if (pp->pp_flags & MV_PP_FLAG_EDMA_EN) {
-			if ((CRPB_DMA_DONE << hard_port) & hc_irq_cause)
-				mv_intr_edma(ap);
-		} else {
-			if ((DEV_IRQ << hard_port) & hc_irq_cause)
-				mv_intr_pio(ap);
+			}
+			/*
+			 * We don't need/want to read the hc_irq_cause register,
+			 * because doing so hurts performance, and
+			 * main_irq_cause already gives us everything we need.
+			 *
+			 * But we do have to *write* to the hc_irq_cause to ack
+			 * the ports that we are handling this time through.
+			 *
+			 * This requires that we create a bitmap for those
+			 * ports which interrupted us, and use that bitmap
+			 * to ack (only) those ports via hc_irq_cause.
+			 */
+			ack_irqs = 0;
+			for (p = 0; p < MV_PORTS_PER_HC; ++p) {
+				if ((port + p) >= hpriv->n_ports)
+					break;
+				port_mask = (DONE_IRQ | ERR_IRQ) << (p * 2);
+				if (hc_cause & port_mask)
+					ack_irqs |= (DMA_IRQ | DEV_IRQ) << p;
+			}
+			hc_mmio = mv_hc_base_from_port(mmio, port);
+			writelfl(~ack_irqs, hc_mmio + HC_IRQ_CAUSE_OFS);
+			handled = 1;
@@ -1750,0 +2161,6 @@
+		/*
+		 * Handle interrupts signalled for this port:
+		 */
+		port_cause = (main_irq_cause >> shift) & (DONE_IRQ | ERR_IRQ);
+		if (port_cause)
+			mv_port_intr(ap, port_cause);
@@ -1752 +2168 @@
-	VPRINTK("EXIT\n");
+	return handled;
@@ -1755 +2171 @@
-static void mv_pci_error(struct ata_host *host, void __iomem *mmio)
+static int mv_pci_error(struct ata_host *host, void __iomem *mmio)
@@ -1783 +2199 @@
-			ehi->action = ATA_EH_HARDRESET;
+			ehi->action = ATA_EH_RESET;
@@ -1792,0 +2209 @@
+	return 1;	/* handled */
@@ -1813,3 +2230,2 @@
-	unsigned int hc, handled = 0, n_hcs;
-	void __iomem *mmio = hpriv->base;
-	u32 irq_stat, irq_mask;
+	unsigned int handled = 0;
+	u32 main_irq_cause, pending_irqs;
@@ -1818,6 +2234,5 @@
-
-	irq_stat = readl(hpriv->main_cause_reg_addr);
-	irq_mask = readl(hpriv->main_mask_reg_addr);
-
-	/* check the cases where we either have nothing pending or have read
-	 * a bogus register value which can indicate HW removal or PCI fault
+	main_irq_cause = readl(hpriv->main_irq_cause_addr);
+	pending_irqs   = main_irq_cause & hpriv->main_irq_mask;
+	/*
+	 * Deal with cases where we either have nothing pending, or have read
+	 * a bogus register value which can indicate HW removal or PCI fault.
@@ -1825,17 +2240,5 @@
-	if (!(irq_stat & irq_mask) || (0xffffffffU == irq_stat))
-		goto out_unlock;
-
-	n_hcs = mv_get_hc_count(host->ports[0]->flags);
-
-	if (unlikely((irq_stat & PCI_ERR) && HAS_PCI(host))) {
-		mv_pci_error(host, mmio);
-		handled = 1;
-		goto out_unlock;	/* skip all other HC irq handling */
-	}
-
-	for (hc = 0; hc < n_hcs; hc++) {
-		u32 relevant = irq_stat & (HC0_IRQ_PEND << (hc * HC_SHIFT));
-		if (relevant) {
-			mv_host_intr(host, relevant, hc);
-			handled = 1;
-		}
+	if (pending_irqs && main_irq_cause != 0xffffffffU) {
+		if (unlikely((pending_irqs & PCI_ERR) && !IS_SOC(hpriv)))
+			handled = mv_pci_error(host, hpriv->base);
+		else
+			handled = mv_host_intr(host, pending_irqs);
@@ -1843,2 +2245,0 @@
-
-out_unlock:
@@ -1846 +2246,0 @@
-
@@ -1850,8 +2249,0 @@
-static void __iomem *mv5_phy_base(void __iomem *mmio, unsigned int port)
-{
-	void __iomem *hc_mmio = mv_hc_base_from_port(mmio, port);
-	unsigned long ofs = (mv_hardport_from_port(port) + 1) * 0x100UL;
-
-	return hc_mmio + ofs;
-}
-
@@ -1921 +2313 @@
-	writel(0x0fcfffff, mmio + MV_FLASH_CTL);
+	writel(0x0fcfffff, mmio + MV_FLASH_CTL_OFS);
@@ -1940 +2332 @@
-	writel(0, mmio + MV_GPIO_PORT_CTL);
+	writel(0, mmio + MV_GPIO_PORT_CTL_OFS);
@@ -1958 +2350 @@
-		tmp = readl(phy_mmio + MV5_LT_MODE);
+		tmp = readl(phy_mmio + MV5_LTMODE_OFS);
@@ -1960 +2352 @@
-		writel(tmp, phy_mmio + MV5_LT_MODE);
+		writel(tmp, phy_mmio + MV5_LTMODE_OFS);
@@ -1962 +2354 @@
-		tmp = readl(phy_mmio + MV5_PHY_CTL);
+		tmp = readl(phy_mmio + MV5_PHY_CTL_OFS);
@@ -1965 +2357 @@
-		writel(tmp, phy_mmio + MV5_PHY_CTL);
+		writel(tmp, phy_mmio + MV5_PHY_CTL_OFS);
@@ -1983,3 +2375 @@
-	writelfl(EDMA_DS, port_mmio + EDMA_CMD_OFS);
-
-	mv_channel_reset(hpriv, mmio, port);
+	mv_reset_channel(hpriv, mmio, port);
@@ -1999 +2389 @@
-	writel(0xbc, port_mmio + EDMA_IORDY_TMOUT);
+	writel(0xbc, port_mmio + EDMA_IORDY_TMOUT_OFS);
@@ -2045 +2435 @@
-	tmp = readl(mmio + MV_PCI_MODE);
+	tmp = readl(mmio + MV_PCI_MODE_OFS);
@@ -2047 +2437 @@
-	writel(tmp, mmio + MV_PCI_MODE);
+	writel(tmp, mmio + MV_PCI_MODE_OFS);
@@ -2051,2 +2441 @@
-	writel(0x000100ff, mmio + MV_PCI_XBAR_TMOUT);
-	ZERO(HC_MAIN_IRQ_MASK_OFS);
+	writel(0x000100ff, mmio + MV_PCI_XBAR_TMOUT_OFS);
@@ -2069 +2458 @@
-	tmp = readl(mmio + MV_GPIO_PORT_CTL);
+	tmp = readl(mmio + MV_GPIO_PORT_CTL_OFS);
@@ -2072 +2461 @@
-	writel(tmp, mmio + MV_GPIO_PORT_CTL);
+	writel(tmp, mmio + MV_GPIO_PORT_CTL_OFS);
@@ -2145 +2534 @@
-	tmp = readl(mmio + MV_RESET_CFG);
+	tmp = readl(mmio + MV_RESET_CFG_OFS);
@@ -2161 +2550 @@
-	writel(0x00000060, mmio + MV_GPIO_PORT_CTL);
+	writel(0x00000060, mmio + MV_GPIO_PORT_CTL_OFS);
@@ -2174 +2563 @@
-	u32 m2, tmp;
+	u32 m2, m3;
@@ -2191,13 +2580,6 @@
-	/* who knows what this magic does */
-	tmp = readl(port_mmio + PHY_MODE3);
-	tmp &= ~0x7F800000;
-	tmp |= 0x2A800000;
-	writel(tmp, port_mmio + PHY_MODE3);
-
-	if (fix_phy_mode4) {
-		u32 m4;
-
-		m4 = readl(port_mmio + PHY_MODE4);
-
-		if (hp_flags & MV_HP_ERRATA_60X1B2)
-			tmp = readl(port_mmio + 0x310);
+	/*
+	 * Gen-II/IIe PHY_MODE3 errata RM#2:
+	 * Achieves better receiver noise performance than the h/w default:
+	 */
+	m3 = readl(port_mmio + PHY_MODE3);
+	m3 = (m3 & 0x1f) | (0x5555601 << 5);
@@ -2205 +2587,3 @@
-		m4 = (m4 & ~(1 << 1)) | (1 << 0);
+	/* Guideline 88F5182 (GL# SATA-S11) */
+	if (IS_SOC(hpriv))
+		m3 &= ~0x1c;
@@ -2206,0 +2591,11 @@
+	if (fix_phy_mode4) {
+		u32 m4 = readl(port_mmio + PHY_MODE4);
+		/*
+		 * Enforce reserved-bit restrictions on GenIIe devices only.
+		 * For earlier chipsets, force only the internal config field
+		 *  (workaround for errata FEr SATA#10 part 1).
+		 */
+		if (IS_GEN_IIE(hpriv))
+			m4 = (m4 & ~PHY_MODE4_RSVD_ZEROS) | PHY_MODE4_RSVD_ONES;
+		else
+			m4 = (m4 & ~PHY_MODE4_CFG_MASK) | PHY_MODE4_CFG_VALUE;
@@ -2208,3 +2602,0 @@
-
-		if (hp_flags & MV_HP_ERRATA_60X1B2)
-			writel(tmp, port_mmio + 0x310);
@@ -2211,0 +2604,6 @@
+	/*
+	 * Workaround for 60x1-B2 errata SATA#13:
+	 * Any write to PHY_MODE4 (above) may corrupt PHY_MODE3,
+	 * so we must always rewrite PHY_MODE3 after PHY_MODE4.
+	 */
+	writel(m3, port_mmio + PHY_MODE3);
@@ -2258,3 +2656 @@
-	writelfl(EDMA_DS, port_mmio + EDMA_CMD_OFS);
-
-	mv_channel_reset(hpriv, mmio, port);
+	mv_reset_channel(hpriv, mmio, port);
@@ -2274 +2670 @@
-	writel(0xbc, port_mmio + EDMA_IORDY_TMOUT);
+	writel(0xbc, port_mmio + EDMA_IORDY_TMOUT_OFS);
@@ -2317 +2713,11 @@
-static void mv_channel_reset(struct mv_host_priv *hpriv, void __iomem *mmio,
+static void mv_setup_ifcfg(void __iomem *port_mmio, int want_gen2i)
+{
+	u32 ifcfg = readl(port_mmio + SATA_INTERFACE_CFG_OFS);
+
+	ifcfg = (ifcfg & 0xf7f) | 0x9b1000;	/* from chip spec */
+	if (want_gen2i)
+		ifcfg |= (1 << 7);		/* enable gen2i speed */
+	writelfl(ifcfg, port_mmio + SATA_INTERFACE_CFG_OFS);
+}
+
+static void mv_reset_channel(struct mv_host_priv *hpriv, void __iomem *mmio,
@@ -2322,7 +2728,11 @@
-	writelfl(ATA_RST, port_mmio + EDMA_CMD_OFS);
-
-	if (IS_GEN_II(hpriv)) {
-		u32 ifctl = readl(port_mmio + SATA_INTERFACE_CTL);
-		ifctl |= (1 << 7);		/* enable gen2i speed */
-		ifctl = (ifctl & 0xfff) | 0x9b1000; /* from chip spec */
-		writelfl(ifctl, port_mmio + SATA_INTERFACE_CTL);
+	/*
+	 * The datasheet warns against setting EDMA_RESET when EDMA is active
+	 * (but doesn't say what the problem might be).  So we first try
+	 * to disable the EDMA engine before doing the EDMA_RESET operation.
+	 */
+	mv_stop_edma_engine(port_mmio);
+	writelfl(EDMA_RESET, port_mmio + EDMA_CMD_OFS);
+
+	if (!IS_GEN_I(hpriv)) {
+		/* Enable 3.0gb/s link speed: this survives EDMA_RESET */
+		mv_setup_ifcfg(port_mmio, 1);
@@ -2330,5 +2740,4 @@
-
-	udelay(25);		/* allow reset propagation */
-
-	/* Spec never mentions clearing the bit.  Marvell's driver does
-	 * clear the bit, however.
+	/*
+	 * Strobing EDMA_RESET here causes a hard reset of the SATA transport,
+	 * link, and physical layers.  It resets all SATA interface registers
+	 * (except for SATA_INTERFACE_CFG), and issues a COMRESET to the dev.
@@ -2335,0 +2745,2 @@
+	writelfl(EDMA_RESET, port_mmio + EDMA_CMD_OFS);
+	udelay(25);	/* allow reset propagation */
@@ -2344,13 +2755 @@
-/**
- *      mv_phy_reset - Perform eDMA reset followed by COMRESET
- *      @ap: ATA channel to manipulate
- *
- *      Part of this is taken from __sata_phy_reset and modified to
- *      not sleep since this routine gets called from interrupt level.
- *
- *      LOCKING:
- *      Inherited from caller.  This is coded to safe to call at
- *      interrupt level, i.e. it does not sleep.
- */
-static void mv_phy_reset(struct ata_port *ap, unsigned int *class,
-			 unsigned long deadline)
+static void mv_pmp_select(struct ata_port *ap, int pmp)
@@ -2358,24 +2757,4 @@
-	struct mv_port_priv *pp	= ap->private_data;
-	struct mv_host_priv *hpriv = ap->host->private_data;
-	void __iomem *port_mmio = mv_ap_base(ap);
-	int retry = 5;
-	u32 sstatus;
-
-	VPRINTK("ENTER, port %u, mmio 0x%p\n", ap->port_no, port_mmio);
-
-#ifdef DEBUG
-	{
-		u32 sstatus, serror, scontrol;
-
-		mv_scr_read(ap, SCR_STATUS, &sstatus);
-		mv_scr_read(ap, SCR_ERROR, &serror);
-		mv_scr_read(ap, SCR_CONTROL, &scontrol);
-		DPRINTK("S-regs after ATA_RST: SStat 0x%08x SErr 0x%08x "
-			"SCtrl 0x%08x\n", sstatus, serror, scontrol);
-	}
-#endif
-
-	/* Issue COMRESET via SControl */
-comreset_retry:
-	sata_scr_write_flush(&ap->link, SCR_CONTROL, 0x301);
-	msleep(1);
+	if (sata_pmp_supported(ap)) {
+		void __iomem *port_mmio = mv_ap_base(ap);
+		u32 reg = readl(port_mmio + SATA_IFCTL_OFS);
+		int old = reg & 0xf;
@@ -2383,49 +2762,4 @@
-	sata_scr_write_flush(&ap->link, SCR_CONTROL, 0x300);
-	msleep(20);
-
-	do {
-		sata_scr_read(&ap->link, SCR_STATUS, &sstatus);
-		if (((sstatus & 0x3) == 3) || ((sstatus & 0x3) == 0))
-			break;
-
-		msleep(1);
-	} while (time_before(jiffies, deadline));
-
-	/* work around errata */
-	if (IS_GEN_II(hpriv) &&
-	    (sstatus != 0x0) && (sstatus != 0x113) && (sstatus != 0x123) &&
-	    (retry-- > 0))
-		goto comreset_retry;
-
-#ifdef DEBUG
-	{
-		u32 sstatus, serror, scontrol;
-
-		mv_scr_read(ap, SCR_STATUS, &sstatus);
-		mv_scr_read(ap, SCR_ERROR, &serror);
-		mv_scr_read(ap, SCR_CONTROL, &scontrol);
-		DPRINTK("S-regs after PHY wake: SStat 0x%08x SErr 0x%08x "
-			"SCtrl 0x%08x\n", sstatus, serror, scontrol);
-	}
-#endif
-
-	if (ata_link_offline(&ap->link)) {
-		*class = ATA_DEV_NONE;
-		return;
-	}
-
-	/* even after SStatus reflects that device is ready,
-	 * it seems to take a while for link to be fully
-	 * established (and thus Status no longer 0x80/0x7F),
-	 * so we poll a bit for that, here.
-	 */
-	retry = 20;
-	while (1) {
-		u8 drv_stat = ata_check_status(ap);
-		if ((drv_stat != 0x80) && (drv_stat != 0x7f))
-			break;
-		msleep(500);
-		if (retry-- <= 0)
-			break;
-		if (time_after(jiffies, deadline))
-			break;
+		if (old != pmp) {
+			reg = (reg & ~0xf) | pmp;
+			writelfl(reg, port_mmio + SATA_IFCTL_OFS);
+		}
@@ -2433,13 +2766,0 @@
-
-	/* FIXME: if we passed the deadline, the following
-	 * code probably produces an invalid result
-	 */
-
-	/* finally, read device signature from TF registers */
-	*class = ata_dev_try_classify(ap->link.device, 1, NULL);
-
-	writelfl(0, port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
-
-	WARN_ON(pp->pp_flags & MV_PP_FLAG_EDMA_EN);
-
-	VPRINTK("EXIT\n");
@@ -2448 +2769,2 @@
-static int mv_prereset(struct ata_link *link, unsigned long deadline)
+static int mv_pmp_hardreset(struct ata_link *link, unsigned int *class,
+				unsigned long deadline)
@@ -2450,22 +2772,3 @@
-	struct ata_port *ap = link->ap;
-	struct mv_port_priv *pp	= ap->private_data;
-	struct ata_eh_context *ehc = &link->eh_context;
-	int rc;
-
-	rc = mv_stop_dma(ap);
-	if (rc)
-		ehc->i.action |= ATA_EH_HARDRESET;
-
-	if (!(pp->pp_flags & MV_PP_FLAG_HAD_A_RESET)) {
-		pp->pp_flags |= MV_PP_FLAG_HAD_A_RESET;
-		ehc->i.action |= ATA_EH_HARDRESET;
-	}
-
-	/* if we're about to do hardreset, nothing more to do */
-	if (ehc->i.action & ATA_EH_HARDRESET)
-		return 0;
-
-	if (ata_link_online(link))
-		rc = ata_wait_ready(ap, deadline);
-	else
-		rc = -ENODEV;
+	mv_pmp_select(link->ap, sata_srst_pmp(link));
+	return sata_std_hardreset(link, class, deadline);
+}
@@ -2473 +2776,5 @@
-	return rc;
+static int mv_softreset(struct ata_link *link, unsigned int *class,
+				unsigned long deadline)
+{
+	mv_pmp_select(link->ap, sata_srst_pmp(link));
+	return ata_sff_softreset(link, class, deadline);
@@ -2480,0 +2788 @@
+	struct mv_port_priv *pp = ap->private_data;
@@ -2481,0 +2790,3 @@
+	int rc, attempts = 0, extra = 0;
+	u32 sstatus;
+	bool online;
@@ -2483,16 +2794,2 @@
-	mv_stop_dma(ap);
-
-	mv_channel_reset(hpriv, mmio, ap->port_no);
-
-	mv_phy_reset(ap, class, deadline);
-
-	return 0;
-}
-
-static void mv_postreset(struct ata_link *link, unsigned int *classes)
-{
-	struct ata_port *ap = link->ap;
-	u32 serr;
-
-	/* print link status */
-	sata_print_link_status(link);
+	mv_reset_channel(hpriv, mmio, ap->port_no);
+	pp->pp_flags &= ~MV_PP_FLAG_EDMA_EN;
@@ -2500,9 +2797,4 @@
-	/* clear SError */
-	sata_scr_read(link, SCR_ERROR, &serr);
-	sata_scr_write_flush(link, SCR_ERROR, serr);
-
-	/* bail out if no device is present */
-	if (classes[0] == ATA_DEV_NONE && classes[1] == ATA_DEV_NONE) {
-		DPRINTK("EXIT, no device\n");
-		return;
-	}
+	/* Workaround for errata FEr SATA#10 (part 2) */
+	do {
+		const unsigned long *timing =
+				sata_ehc_deb_timing(&link->eh_context);
@@ -2510,3 +2802,13 @@
-	/* set up device control */
-	iowrite8(ap->ctl, ap->ioaddr.ctl_addr);
-}
+		rc = sata_link_hardreset(link, timing, deadline + extra,
+					 &online, NULL);
+		rc = online ? -EAGAIN : rc;
+		if (rc)
+			return rc;
+		sata_scr_read(link, SCR_STATUS, &sstatus);
+		if (!IS_GEN_I(hpriv) && ++attempts >= 5 && sstatus == 0x121) {
+			/* Force 1.5gb/s link speed and try again */
+			mv_setup_ifcfg(mv_ap_base(ap), 0);
+			if (time_after(jiffies + HZ, deadline))
+				extra = HZ; /* only extend it once, max */
+		}
+	} while (sstatus != 0x0 && sstatus != 0x113 && sstatus != 0x123);
@@ -2514,4 +2816 @@
-static void mv_error_handler(struct ata_port *ap)
-{
-	ata_do_eh(ap, mv_prereset, ata_std_softreset,
-		  mv_hardreset, mv_postreset);
+	return rc;
@@ -2522,16 +2821,2 @@
-	struct mv_host_priv *hpriv = ap->host->private_data;
-	unsigned int hc = (ap->port_no > 3) ? 1 : 0;
-	u32 tmp, mask;
-	unsigned int shift;
-
-	/* FIXME: handle coalescing completion events properly */
-
-	shift = ap->port_no * 2;
-	if (hc > 0)
-		shift++;
-
-	mask = 0x3 << shift;
-
-	/* disable assertion of portN err, done events */
-	tmp = readl(hpriv->main_mask_reg_addr);
-	writelfl(tmp & ~mask, hpriv->main_mask_reg_addr);
+	mv_stop_edma(ap);
+	mv_enable_port_irqs(ap, 0);
@@ -2543,3 +2828,3 @@
-	void __iomem *mmio = hpriv->base;
-	unsigned int hc = (ap->port_no > 3) ? 1 : 0;
-	void __iomem *hc_mmio = mv_hc_base(mmio, hc);
+	unsigned int port = ap->port_no;
+	unsigned int hardport = mv_hardport_from_port(port);
+	void __iomem *hc_mmio = mv_hc_base_from_port(hpriv->base, port);
@@ -2547,12 +2832 @@
-	u32 tmp, mask, hc_irq_cause;
-	unsigned int shift, hc_port_no = ap->port_no;
-
-	/* FIXME: handle coalescing completion events properly */
-
-	shift = ap->port_no * 2;
-	if (hc > 0) {
-		shift++;
-		hc_port_no -= 4;
-	}
-
-	mask = 0x3 << shift;
+	u32 hc_irq_cause;
@@ -2565,7 +2839,4 @@
-	hc_irq_cause &= ~(1 << hc_port_no);	/* clear CRPB-done */
-	hc_irq_cause &= ~(1 << (hc_port_no + 8)); /* clear Device int */
-	writel(hc_irq_cause, hc_mmio + HC_IRQ_CAUSE_OFS);
-
-	/* enable assertion of portN err, done events */
-	tmp = readl(hpriv->main_mask_reg_addr);
-	writelfl(tmp | mask, hpriv->main_mask_reg_addr);
+	hc_irq_cause &= ~((DEV_IRQ | DMA_IRQ) << hardport);
+	writelfl(hc_irq_cause, hc_mmio + HC_IRQ_CAUSE_OFS);
+
+	mv_enable_port_irqs(ap, ERR_IRQ);
@@ -2622,0 +2894,28 @@
+static unsigned int mv_in_pcix_mode(struct ata_host *host)
+{
+	struct mv_host_priv *hpriv = host->private_data;
+	void __iomem *mmio = hpriv->base;
+	u32 reg;
+
+	if (IS_SOC(hpriv) || !IS_PCIE(hpriv))
+		return 0;	/* not PCI-X capable */
+	reg = readl(mmio + MV_PCI_MODE_OFS);
+	if ((reg & MV_PCI_MODE_MASK) == 0)
+		return 0;	/* conventional PCI mode */
+	return 1;	/* chip is in PCI-X mode */
+}
+
+static int mv_pci_cut_through_okay(struct ata_host *host)
+{
+	struct mv_host_priv *hpriv = host->private_data;
+	void __iomem *mmio = hpriv->base;
+	u32 reg;
+
+	if (!mv_in_pcix_mode(host)) {
+		reg = readl(mmio + PCI_COMMAND_OFS);
+		if (reg & PCI_COMMAND_MRDTRIG)
+			return 0; /* not okay */
+	}
+	return 1; /* okay */
+}
+
@@ -2690 +2989 @@
-		hp_flags |= MV_HP_PCIE;
+		hp_flags |= MV_HP_PCIE | MV_HP_CUT_THROUGH;
@@ -2719,0 +3019 @@
+		/* drop through */
@@ -2722,0 +3023,2 @@
+		if (board_idx == chip_6042 && mv_pci_cut_through_okay(host))
+			hp_flags |= MV_HP_CUT_THROUGH;
@@ -2725,4 +3027 @@
-		case 0x0:
-			hp_flags |= MV_HP_ERRATA_XX42A0;
-			break;
-		case 0x1:
+		case 0x2: /* Rev.B0: the first/only public release */
@@ -2740 +3039 @@
-		hp_flags |= MV_HP_ERRATA_60X1C0;
+		hp_flags |= MV_HP_FLAG_SOC | MV_HP_ERRATA_60X1C0;
@@ -2782 +3081 @@
-	goto done;
+		goto done;
@@ -2784,4 +3083,3 @@
-	if (HAS_PCI(host)) {
-		hpriv->main_cause_reg_addr = hpriv->base +
-		  HC_MAIN_IRQ_CAUSE_OFS;
-		hpriv->main_mask_reg_addr = hpriv->base + HC_MAIN_IRQ_MASK_OFS;
+	if (IS_SOC(hpriv)) {
+		hpriv->main_irq_cause_addr = mmio + SOC_HC_MAIN_IRQ_CAUSE_OFS;
+		hpriv->main_irq_mask_addr  = mmio + SOC_HC_MAIN_IRQ_MASK_OFS;
@@ -2789,4 +3087,2 @@
-		hpriv->main_cause_reg_addr = hpriv->base +
-		  HC_SOC_MAIN_IRQ_CAUSE_OFS;
-		hpriv->main_mask_reg_addr = hpriv->base +
-		  HC_SOC_MAIN_IRQ_MASK_OFS;
+		hpriv->main_irq_cause_addr = mmio + PCI_HC_MAIN_IRQ_CAUSE_OFS;
+		hpriv->main_irq_mask_addr  = mmio + PCI_HC_MAIN_IRQ_MASK_OFS;
@@ -2794,2 +3090,3 @@
-	/* global interrupt mask */
-	writel(0, hpriv->main_mask_reg_addr);
+
+	/* global interrupt mask: 0 == mask everything */
+	mv_set_main_irq_mask(host, ~0, 0);
@@ -2811,13 +3107,0 @@
-		if (IS_GEN_II(hpriv)) {
-			void __iomem *port_mmio = mv_port_base(mmio, port);
-
-			u32 ifctl = readl(port_mmio + SATA_INTERFACE_CTL);
-			ifctl |= (1 << 7);		/* enable gen2i speed */
-			ifctl = (ifctl & 0xfff) | 0x9b1000; /* from chip spec */
-			writelfl(ifctl, port_mmio + SATA_INTERFACE_CTL);
-		}
-
-		hpriv->ops->phy_errata(hpriv, mmio, port);
-	}
-
-	for (port = 0; port < host->n_ports; port++) {
@@ -2830 +3114 @@
-		if (HAS_PCI(host)) {
+		if (!IS_SOC(hpriv)) {
@@ -2850 +3134 @@
-	if (HAS_PCI(host)) {
+	if (!IS_SOC(hpriv)) {
@@ -2856,6 +3139,0 @@
-		if (IS_GEN_I(hpriv))
-			writelfl(~HC_MAIN_MASKED_IRQS_5,
-				 hpriv->main_mask_reg_addr);
-		else
-			writelfl(~HC_MAIN_MASKED_IRQS,
-				 hpriv->main_mask_reg_addr);
@@ -2863,12 +3141,5 @@
-		VPRINTK("HC MAIN IRQ cause/mask=0x%08x/0x%08x "
-			"PCI int cause/mask=0x%08x/0x%08x\n",
-			readl(hpriv->main_cause_reg_addr),
-			readl(hpriv->main_mask_reg_addr),
-			readl(mmio + hpriv->irq_cause_ofs),
-			readl(mmio + hpriv->irq_mask_ofs));
-	} else {
-		writelfl(~HC_MAIN_MASKED_IRQS_SOC,
-			 hpriv->main_mask_reg_addr);
-		VPRINTK("HC MAIN IRQ cause/mask=0x%08x/0x%08x\n",
-			readl(hpriv->main_cause_reg_addr),
-			readl(hpriv->main_mask_reg_addr));
+		/*
+		 * enable only global host interrupts for now.
+		 * The per-port interrupts get done later as ports are set up.
+		 */
+		mv_set_main_irq_mask(host, 0, PCI_ERR);
@@ -2899,0 +3171,21 @@
+static void mv_conf_mbus_windows(struct mv_host_priv *hpriv,
+				 struct mbus_dram_target_info *dram)
+{
+	int i;
+
+	for (i = 0; i < 4; i++) {
+		writel(0, hpriv->base + WINDOW_CTRL(i));
+		writel(0, hpriv->base + WINDOW_BASE(i));
+	}
+
+	for (i = 0; i < dram->num_cs; i++) {
+		struct mbus_dram_window *cs = dram->cs + i;
+
+		writel(((cs->size - 1) & 0xffff0000) |
+			(cs->mbus_attr << 8) |
+			(dram->mbus_dram_target_id << 4) | 1,
+			hpriv->base + WINDOW_CTRL(i));
+		writel(cs->base, hpriv->base + WINDOW_BASE(i));
+	}
+}
+
@@ -2953,0 +3246,6 @@
+	/*
+	 * (Re-)program MBUS remapping windows if we are asked to.
+	 */
+	if (mv_platform_data->dram != NULL)
+		mv_conf_mbus_windows(hpriv, mv_platform_data->dram);
+
@@ -3195 +3493 @@
-MODULE_ALIAS("platform:sata_mv");
+MODULE_ALIAS("platform:" DRV_NAME);
--- ./projects/linux/linux-2.6.26/drivers/ata/sata_mv.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/ata/sata_mv.c	2008-10-10 00:13:53.000000000 +0200
@@ -670 +670,2 @@
-	/* RocketRAID 1740/174x have different identifiers */
+	/* RocketRAID 1720/174x have different identifiers */
+	{ PCI_VDEVICE(TTI, 0x1720), chip_6042 },
@@ -1137,24 +1138,10 @@
-	if (pp->pp_flags & MV_PP_FLAG_EDMA_EN) {
-		/*
-		 * The port is operating in host queuing mode (EDMA).
-		 * It can accomodate a new qc if the qc protocol
-		 * is compatible with the current host queue mode.
-		 */
-		if (pp->pp_flags & MV_PP_FLAG_NCQ_EN) {
-			/*
-			 * The host queue (EDMA) is in NCQ mode.
-			 * If the new qc is also an NCQ command,
-			 * then allow the new qc.
-			 */
-			if (qc->tf.protocol == ATA_PROT_NCQ)
-				return 0;
-		} else {
-			/*
-			 * The host queue (EDMA) is in non-NCQ, DMA mode.
-			 * If the new qc is also a non-NCQ, DMA command,
-			 * then allow the new qc.
-			 */
-			if (qc->tf.protocol == ATA_PROT_DMA)
-				return 0;
-		}
-	}
+	/*
+	 * The port is operating in host queuing mode (EDMA) with NCQ
+	 * enabled, allow multiple NCQ commands.  EDMA also allows
+	 * queueing multiple DMA commands but libata core currently
+	 * doesn't allow it.
+	 */
+	if ((pp->pp_flags & MV_PP_FLAG_EDMA_EN) &&
+	    (pp->pp_flags & MV_PP_FLAG_NCQ_EN) && ata_is_ncq(qc->tf.protocol))
+		return 0;
+
@@ -3039 +3026,2 @@
-		hp_flags |= MV_HP_FLAG_SOC | MV_HP_ERRATA_60X1C0;
+		hp_flags |= MV_HP_FLAG_SOC | MV_HP_GEN_IIE |
+			MV_HP_ERRATA_60X1C0;
--- ./projects/linux/linux-2.6.27/drivers/ata/sata_mv.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/ata/sata_mv.c	2008-12-25 00:26:37.000000000 +0100
@@ -496,4 +496,4 @@
-static int mv_scr_read(struct ata_port *ap, unsigned int sc_reg_in, u32 *val);
-static int mv_scr_write(struct ata_port *ap, unsigned int sc_reg_in, u32 val);
-static int mv5_scr_read(struct ata_port *ap, unsigned int sc_reg_in, u32 *val);
-static int mv5_scr_write(struct ata_port *ap, unsigned int sc_reg_in, u32 val);
+static int mv_scr_read(struct ata_link *link, unsigned int sc_reg_in, u32 *val);
+static int mv_scr_write(struct ata_link *link, unsigned int sc_reg_in, u32 val);
+static int mv5_scr_read(struct ata_link *link, unsigned int sc_reg_in, u32 *val);
+static int mv5_scr_write(struct ata_link *link, unsigned int sc_reg_in, u32 val);
@@ -1073 +1073 @@
-static int mv_scr_read(struct ata_port *ap, unsigned int sc_reg_in, u32 *val)
+static int mv_scr_read(struct ata_link *link, unsigned int sc_reg_in, u32 *val)
@@ -1078 +1078 @@
-		*val = readl(mv_ap_base(ap) + ofs);
+		*val = readl(mv_ap_base(link->ap) + ofs);
@@ -1084 +1084 @@
-static int mv_scr_write(struct ata_port *ap, unsigned int sc_reg_in, u32 val)
+static int mv_scr_write(struct ata_link *link, unsigned int sc_reg_in, u32 val)
@@ -1089 +1089 @@
-		writelfl(val, mv_ap_base(ap) + ofs);
+		writelfl(val, mv_ap_base(link->ap) + ofs);
@@ -2254 +2254 @@
-static int mv5_scr_read(struct ata_port *ap, unsigned int sc_reg_in, u32 *val)
+static int mv5_scr_read(struct ata_link *link, unsigned int sc_reg_in, u32 *val)
@@ -2256 +2256 @@
-	struct mv_host_priv *hpriv = ap->host->private_data;
+	struct mv_host_priv *hpriv = link->ap->host->private_data;
@@ -2258 +2258 @@
-	void __iomem *addr = mv5_phy_base(mmio, ap->port_no);
+	void __iomem *addr = mv5_phy_base(mmio, link->ap->port_no);
@@ -2268 +2268 @@
-static int mv5_scr_write(struct ata_port *ap, unsigned int sc_reg_in, u32 val)
+static int mv5_scr_write(struct ata_link *link, unsigned int sc_reg_in, u32 val)
@@ -2270 +2270 @@
-	struct mv_host_priv *hpriv = ap->host->private_data;
+	struct mv_host_priv *hpriv = link->ap->host->private_data;
@@ -2272 +2272 @@
-	void __iomem *addr = mv5_phy_base(mmio, ap->port_no);
+	void __iomem *addr = mv5_phy_base(mmio, link->ap->port_no);
--- ./projects/linux/linux-2.6.28/drivers/ata/sata_mv.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/ata/sata_mv.c	2009-03-24 00:12:14.000000000 +0100
@@ -36,4 +35,0 @@
- * --> Investigate problems with PCI Message Signalled Interrupts (MSI).
- *
- * --> Cache frequently-accessed registers in mv_port_priv to reduce overhead.
- *
@@ -75 +71 @@
-#define DRV_VERSION	"1.24"
+#define DRV_VERSION	"1.25"
@@ -354,2 +349,0 @@
-	GEN_II_NCQ_MAX_SECTORS	= 256,		/* max sects/io on Gen2 w/NCQ */
-
@@ -672,2 +666,2 @@
-	{ PCI_VDEVICE(TTI, 0x1740), chip_508x },
-	{ PCI_VDEVICE(TTI, 0x1742), chip_508x },
+	{ PCI_VDEVICE(TTI, 0x1740), chip_6042 },
+	{ PCI_VDEVICE(TTI, 0x1742), chip_6042 },
@@ -886,2 +880,2 @@
-					mv_host_base(ap->host), hardport);
-		u32 hc_irq_cause, ipending;
+					mv_host_base(ap->host), ap->port_no);
+		u32 hc_irq_cause;
@@ -892,7 +886,3 @@
-		/* clear EDMA interrupt indicator, if any */
-		hc_irq_cause = readl(hc_mmio + HC_IRQ_CAUSE_OFS);
-		ipending = (DEV_IRQ | DMA_IRQ) << hardport;
-		if (hc_irq_cause & ipending) {
-			writelfl(hc_irq_cause & ~ipending,
-				 hc_mmio + HC_IRQ_CAUSE_OFS);
-		}
+		/* clear pending irq events */
+		hc_irq_cause = ~((DEV_IRQ | DMA_IRQ) << hardport);
+		writelfl(hc_irq_cause, hc_mmio + HC_IRQ_CAUSE_OFS);
@@ -1102,3 +1091,0 @@
-	 *
-	 * We don't have hob_nsect when doing NCQ commands on Gen-II.
-	 * See mv_qc_prep() for more info.
@@ -1111,5 +1097,0 @@
-		} else if (adev->max_sectors > GEN_II_NCQ_MAX_SECTORS) {
-			adev->max_sectors = GEN_II_NCQ_MAX_SECTORS;
-			ata_dev_printk(adev, KERN_INFO,
-				"max_sectors limited to %u for NCQ\n",
-				adev->max_sectors);
@@ -1453 +1435,2 @@
-	 * NCQ.  NCQ will drop hob_nsect.
+	 * NCQ.  NCQ will drop hob_nsect, which is not needed there
+	 * (nsect is used only for the tag; feat/hob_feat hold true nsect).
@@ -1839 +1821,0 @@
- *      @qc: affected command (non-NCQ), or NULL
@@ -2217,0 +2200 @@
+	int using_msi = hpriv->hp_flags & MV_HP_FLAG_MSI;
@@ -2220,0 +2204,5 @@
+
+	/* for MSI:  block new interrupts while in here */
+	if (using_msi)
+		writel(0, hpriv->main_irq_mask_addr);
+
@@ -2232,0 +2221,5 @@
+
+	/* for MSI: unmask; interrupt cause bits will retrigger now */
+	if (using_msi)
+		writel(hpriv->main_irq_mask, hpriv->main_irq_mask_addr);
+
@@ -2233,0 +2227 @@
+
@@ -2825,2 +2819 @@
-	hc_irq_cause = readl(hc_mmio + HC_IRQ_CAUSE_OFS);
-	hc_irq_cause &= ~((DEV_IRQ | DMA_IRQ) << hardport);
+	hc_irq_cause = ~((DEV_IRQ | DMA_IRQ) << hardport);
@@ -3078,0 +3072,3 @@
+	/* initialize shadow irq mask with register's value */
+	hpriv->main_irq_mask = readl(hpriv->main_irq_mask_addr);
+
@@ -3122,3 +3118,2 @@
-	if (!IS_SOC(hpriv)) {
-		/* Clear any currently outstanding host interrupt conditions */
-		writelfl(0, mmio + hpriv->irq_cause_ofs);
+	/* Clear any currently outstanding host interrupt conditions */
+	writelfl(0, mmio + hpriv->irq_cause_ofs);
@@ -3126,2 +3121,2 @@
-		/* and unmask interrupt generation for host regs */
-		writelfl(hpriv->unmask_all_irqs, mmio + hpriv->irq_mask_ofs);
+	/* and unmask interrupt generation for host regs */
+	writelfl(hpriv->unmask_all_irqs, mmio + hpriv->irq_mask_ofs);
@@ -3129,6 +3124,5 @@
-		/*
-		 * enable only global host interrupts for now.
-		 * The per-port interrupts get done later as ports are set up.
-		 */
-		mv_set_main_irq_mask(host, 0, PCI_ERR);
-	}
+	/*
+	 * enable only global host interrupts for now.
+	 * The per-port interrupts get done later as ports are set up.
+	 */
+	mv_set_main_irq_mask(host, 0, PCI_ERR);
@@ -3434,3 +3428,3 @@
-	/* Enable interrupts */
-	if (msi && pci_enable_msi(pdev))
-		pci_intx(pdev, 1);
+	/* Enable message-switched interrupts, if requested */
+	if (msi && pci_enable_msi(pdev) == 0)
+		hpriv->hp_flags |= MV_HP_FLAG_MSI;
--- ./projects/linux/linux-2.6.29/drivers/ata/sata_mv.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/ata/sata_mv.c	2009-06-27 11:32:32.000000000 +0200
@@ -4 +4 @@
- * Copyright 2008: Marvell Corporation, all rights reserved.
+ * Copyright 2008-2009: Marvell Corporation, all rights reserved.
@@ -7,0 +8,3 @@
+ * Originally written by Brett Russ.
+ * Extensive overhaul and enhancement by Mark Lord <mlord@pobox.com>.
+ *
@@ -28,8 +30,0 @@
- * --> Errata workaround for NCQ device errors.
- *
- * --> More errata workarounds for PCI-X.
- *
- * --> Complete a full errata audit for all chipsets to identify others.
- *
- * --> ATAPI support (Marvell claims the 60xx/70xx chips can do it).
- *
@@ -38,4 +33 @@
- * --> [Experiment, low priority] Investigate interrupt coalescing.
- *       Quite often, especially with PCI Message Signalled Interrupts (MSI),
- *       the overhead reduced by interrupt mitigation is quite often not
- *       worth the latency cost.
+ * --> Add sysfs attributes for per-chip / per-HC IRQ coalescing thresholds.
@@ -50,0 +43,9 @@
+/*
+ * 80x1-B2 errata PCI#11:
+ *
+ * Users of the 6041/6081 Rev.B2 chips (current is C0)
+ * should be careful to insert those cards only onto PCI-X bus #0,
+ * and only in device slots 0..7, not higher.  The chips may not
+ * work correctly otherwise  (note: this is a pretty rare condition).
+ */
+
@@ -71 +72,21 @@
-#define DRV_VERSION	"1.25"
+#define DRV_VERSION	"1.28"
+
+/*
+ * module options
+ */
+
+static int msi;
+#ifdef CONFIG_PCI
+module_param(msi, int, S_IRUGO);
+MODULE_PARM_DESC(msi, "Enable use of PCI MSI (0=off, 1=on)");
+#endif
+
+static int irq_coalescing_io_count;
+module_param(irq_coalescing_io_count, int, S_IRUGO);
+MODULE_PARM_DESC(irq_coalescing_io_count,
+		 "IRQ coalescing I/O count threshold (0..255)");
+
+static int irq_coalescing_usecs;
+module_param(irq_coalescing_usecs, int, S_IRUGO);
+MODULE_PARM_DESC(irq_coalescing_usecs,
+		 "IRQ coalescing time threshold in usecs");
@@ -81,0 +103,5 @@
+	/* For use with both IRQ coalescing methods ("all ports" or "per-HC" */
+	COAL_CLOCKS_PER_USEC	= 150,		/* for calculating COAL_TIMEs */
+	MAX_COAL_TIME_THRESHOLD	= ((1 << 24) - 1), /* internal clocks count */
+	MAX_COAL_IO_COUNT	= 255,		/* completed I/O count */
+
@@ -83,11 +109,25 @@
-	MV_IRQ_COAL_REG_BASE	= 0x18000,	/* 6xxx part only */
-	MV_IRQ_COAL_CAUSE		= (MV_IRQ_COAL_REG_BASE + 0x08),
-	MV_IRQ_COAL_CAUSE_LO		= (MV_IRQ_COAL_REG_BASE + 0x88),
-	MV_IRQ_COAL_CAUSE_HI		= (MV_IRQ_COAL_REG_BASE + 0x8c),
-	MV_IRQ_COAL_THRESHOLD		= (MV_IRQ_COAL_REG_BASE + 0xcc),
-	MV_IRQ_COAL_TIME_THRESHOLD	= (MV_IRQ_COAL_REG_BASE + 0xd0),
-
-	MV_SATAHC0_REG_BASE	= 0x20000,
-	MV_FLASH_CTL_OFS	= 0x1046c,
-	MV_GPIO_PORT_CTL_OFS	= 0x104f0,
-	MV_RESET_CFG_OFS	= 0x180d8,
+
+	/*
+	 * Per-chip ("all ports") interrupt coalescing feature.
+	 * This is only for GEN_II / GEN_IIE hardware.
+	 *
+	 * Coalescing defers the interrupt until either the IO_THRESHOLD
+	 * (count of completed I/Os) is met, or the TIME_THRESHOLD is met.
+	 */
+	COAL_REG_BASE		= 0x18000,
+	IRQ_COAL_CAUSE		= (COAL_REG_BASE + 0x08),
+	ALL_PORTS_COAL_IRQ	= (1 << 4),	/* all ports irq event */
+
+	IRQ_COAL_IO_THRESHOLD   = (COAL_REG_BASE + 0xcc),
+	IRQ_COAL_TIME_THRESHOLD = (COAL_REG_BASE + 0xd0),
+
+	/*
+	 * Registers for the (unused here) transaction coalescing feature:
+	 */
+	TRAN_COAL_CAUSE_LO	= (COAL_REG_BASE + 0x88),
+	TRAN_COAL_CAUSE_HI	= (COAL_REG_BASE + 0x8c),
+
+	SATAHC0_REG_BASE	= 0x20000,
+	FLASH_CTL		= 0x1046c,
+	GPIO_PORT_CTL		= 0x104f0,
+	RESET_CFG		= 0x180d8,
@@ -120 +159,0 @@
-	MV_FLAG_IRQ_COALESCE	= (1 << 29),  /* IRQ coalescing capability */
@@ -123,2 +162 @@
-				  ATA_FLAG_MMIO | ATA_FLAG_NO_ATAPI |
-				  ATA_FLAG_PIO_POLLING,
+				  ATA_FLAG_MMIO | ATA_FLAG_PIO_POLLING,
@@ -126 +164 @@
-	MV_6XXX_FLAGS		= MV_FLAG_IRQ_COALESCE,
+	MV_GEN_I_FLAGS		= MV_COMMON_FLAGS | ATA_FLAG_NO_ATAPI,
@@ -128,3 +166,4 @@
-	MV_GENIIE_FLAGS		= MV_COMMON_FLAGS | MV_6XXX_FLAGS |
-				  ATA_FLAG_PMP | ATA_FLAG_ACPI_SATA |
-				  ATA_FLAG_NCQ | ATA_FLAG_AN,
+	MV_GEN_II_FLAGS		= MV_COMMON_FLAGS | ATA_FLAG_NCQ |
+				  ATA_FLAG_PMP | ATA_FLAG_ACPI_SATA,
+
+	MV_GEN_IIE_FLAGS	= MV_GEN_II_FLAGS | ATA_FLAG_AN,
@@ -149,2 +188,3 @@
-	PCI_COMMAND_OFS		= 0xc00,
-	PCI_COMMAND_MRDTRIG	= (1 << 7),	/* PCI Master Read Trigger */
+	MV_PCI_COMMAND		= 0xc00,
+	MV_PCI_COMMAND_MWRCOM	= (1 << 4),	/* PCI Master Write Combining */
+	MV_PCI_COMMAND_MRDTRIG	= (1 << 7),	/* PCI Master Read Trigger */
@@ -152 +192 @@
-	PCI_MAIN_CMD_STS_OFS	= 0xd30,
+	PCI_MAIN_CMD_STS	= 0xd30,
@@ -157 +197 @@
-	MV_PCI_MODE_OFS		= 0xd00,
+	MV_PCI_MODE		= 0xd00,
@@ -164 +204 @@
-	MV_PCI_XBAR_TMOUT_OFS	= 0x1d04,
+	MV_PCI_XBAR_TMOUT	= 0x1d04,
@@ -170,2 +210,2 @@
-	PCI_IRQ_CAUSE_OFS	= 0x1d58,
-	PCI_IRQ_MASK_OFS	= 0x1d5c,
+	PCI_IRQ_CAUSE		= 0x1d58,
+	PCI_IRQ_MASK		= 0x1d5c,
@@ -174,2 +214,2 @@
-	PCIE_IRQ_CAUSE_OFS	= 0x1900,
-	PCIE_IRQ_MASK_OFS	= 0x1910,
+	PCIE_IRQ_CAUSE		= 0x1900,
+	PCIE_IRQ_MASK		= 0x1910,
@@ -179,6 +219,6 @@
-	PCI_HC_MAIN_IRQ_CAUSE_OFS = 0x1d60,
-	PCI_HC_MAIN_IRQ_MASK_OFS  = 0x1d64,
-	SOC_HC_MAIN_IRQ_CAUSE_OFS = 0x20020,
-	SOC_HC_MAIN_IRQ_MASK_OFS  = 0x20024,
-	ERR_IRQ			= (1 << 0),	/* shift by port # */
-	DONE_IRQ		= (1 << 1),	/* shift by port # */
+	PCI_HC_MAIN_IRQ_CAUSE	= 0x1d60,
+	PCI_HC_MAIN_IRQ_MASK	= 0x1d64,
+	SOC_HC_MAIN_IRQ_CAUSE	= 0x20020,
+	SOC_HC_MAIN_IRQ_MASK	= 0x20024,
+	ERR_IRQ			= (1 << 0),	/* shift by (2 * port #) */
+	DONE_IRQ		= (1 << 1),	/* shift by (2 * port #) */
@@ -186,0 +227,2 @@
+	DONE_IRQ_0_3		= 0x000000aa,	/* DONE_IRQ ports 0,1,2,3 */
+	DONE_IRQ_4_7		= (DONE_IRQ_0_3 << HC_SHIFT),  /* 4,5,6,7 */
@@ -188,5 +230,5 @@
-	TRAN_LO_DONE		= (1 << 19),	/* 6xxx: IRQ coalescing */
-	TRAN_HI_DONE		= (1 << 20),	/* 6xxx: IRQ coalescing */
-	PORTS_0_3_COAL_DONE	= (1 << 8),
-	PORTS_4_7_COAL_DONE	= (1 << 17),
-	PORTS_0_7_COAL_DONE	= (1 << 21),	/* 6xxx: IRQ coalescing */
+	TRAN_COAL_LO_DONE	= (1 << 19),	/* transaction coalescing */
+	TRAN_COAL_HI_DONE	= (1 << 20),	/* transaction coalescing */
+	PORTS_0_3_COAL_DONE	= (1 << 8),	/* HC0 IRQ coalescing */
+	PORTS_4_7_COAL_DONE	= (1 << 17),	/* HC1 IRQ coalescing */
+	ALL_PORTS_COAL_DONE	= (1 << 21),	/* GEN_II(E) IRQ coalescing */
@@ -201 +243 @@
-	HC_CFG_OFS		= 0,
+	HC_CFG			= 0x00,
@@ -203 +245 @@
-	HC_IRQ_CAUSE_OFS	= 0x14,
+	HC_IRQ_CAUSE		= 0x14,
@@ -207,0 +250,15 @@
+	/*
+	 * Per-HC (Host-Controller) interrupt coalescing feature.
+	 * This is present on all chip generations.
+	 *
+	 * Coalescing defers the interrupt until either the IO_THRESHOLD
+	 * (count of completed I/Os) is met, or the TIME_THRESHOLD is met.
+	 */
+	HC_IRQ_COAL_IO_THRESHOLD	= 0x000c,
+	HC_IRQ_COAL_TIME_THRESHOLD	= 0x0010,
+
+	SOC_LED_CTRL		= 0x2c,
+	SOC_LED_CTRL_BLINK	= (1 << 0),	/* Active LED blink */
+	SOC_LED_CTRL_ACT_PRESENCE = (1 << 2),	/* Multiplex dev presence */
+						/*  with dev activity LED */
+
@@ -209,2 +266,2 @@
-	SHD_BLK_OFS		= 0x100,
-	SHD_CTL_AST_OFS		= 0x20,		/* ofs from SHD_BLK_OFS */
+	SHD_BLK			= 0x100,
+	SHD_CTL_AST		= 0x20,		/* ofs from SHD_BLK */
@@ -213,4 +270,4 @@
-	SATA_STATUS_OFS		= 0x300,  /* ctrl, err regs follow status */
-	SATA_ACTIVE_OFS		= 0x350,
-	SATA_FIS_IRQ_CAUSE_OFS	= 0x364,
-	SATA_FIS_IRQ_AN		= (1 << 9),	/* async notification */
+	SATA_STATUS		= 0x300,  /* ctrl, err regs follow status */
+	SATA_ACTIVE		= 0x350,
+	FIS_IRQ_CAUSE		= 0x364,
+	FIS_IRQ_CAUSE_AN	= (1 << 9),	/* async notification */
@@ -218 +275 @@
-	LTMODE_OFS		= 0x30c,
+	LTMODE			= 0x30c,	/* requires read-after-write */
@@ -220,0 +278 @@
+	PHY_MODE2		= 0x330,
@@ -222 +280,2 @@
-	PHY_MODE4		= 0x314,
+
+	PHY_MODE4		= 0x314,	/* requires read-after-write */
@@ -228,5 +287,4 @@
-	PHY_MODE2		= 0x330,
-	SATA_IFCTL_OFS		= 0x344,
-	SATA_TESTCTL_OFS	= 0x348,
-	SATA_IFSTAT_OFS		= 0x34c,
-	VENDOR_UNIQUE_FIS_OFS	= 0x35c,
+	SATA_IFCTL		= 0x344,
+	SATA_TESTCTL		= 0x348,
+	SATA_IFSTAT		= 0x34c,
+	VENDOR_UNIQUE_FIS	= 0x35c,
@@ -234 +292 @@
-	FISCFG_OFS		= 0x360,
+	FISCFG			= 0x360,
@@ -237,0 +296,4 @@
+	PHY_MODE9_GEN2		= 0x398,
+	PHY_MODE9_GEN1		= 0x39c,
+	PHYCFG_OFS		= 0x3a0,	/* only in 65n devices */
+
@@ -239,3 +301,3 @@
-	MV5_LTMODE_OFS		= 0x30,
-	MV5_PHY_CTL_OFS		= 0x0C,
-	SATA_INTERFACE_CFG_OFS	= 0x050,
+	MV5_LTMODE		= 0x30,
+	MV5_PHY_CTL		= 0x0C,
+	SATA_IFCFG		= 0x050,
@@ -246 +308 @@
-	EDMA_CFG_OFS		= 0,
+	EDMA_CFG		= 0,
@@ -255,2 +317,2 @@
-	EDMA_ERR_IRQ_CAUSE_OFS	= 0x8,
-	EDMA_ERR_IRQ_MASK_OFS	= 0xc,
+	EDMA_ERR_IRQ_CAUSE	= 0x8,
+	EDMA_ERR_IRQ_MASK	= 0xc,
@@ -325,2 +387,2 @@
-	EDMA_REQ_Q_BASE_HI_OFS	= 0x10,
-	EDMA_REQ_Q_IN_PTR_OFS	= 0x14,		/* also contains BASE_LO */
+	EDMA_REQ_Q_BASE_HI	= 0x10,
+	EDMA_REQ_Q_IN_PTR	= 0x14,		/* also contains BASE_LO */
@@ -328 +390 @@
-	EDMA_REQ_Q_OUT_PTR_OFS	= 0x18,
+	EDMA_REQ_Q_OUT_PTR	= 0x18,
@@ -331,3 +393,3 @@
-	EDMA_RSP_Q_BASE_HI_OFS	= 0x1c,
-	EDMA_RSP_Q_IN_PTR_OFS	= 0x20,
-	EDMA_RSP_Q_OUT_PTR_OFS	= 0x24,		/* also contains BASE_LO */
+	EDMA_RSP_Q_BASE_HI	= 0x1c,
+	EDMA_RSP_Q_IN_PTR	= 0x20,
+	EDMA_RSP_Q_OUT_PTR	= 0x24,		/* also contains BASE_LO */
@@ -336 +398 @@
-	EDMA_CMD_OFS		= 0x28,		/* EDMA command register */
+	EDMA_CMD		= 0x28,		/* EDMA command register */
@@ -341 +403 @@
-	EDMA_STATUS_OFS		= 0x30,		/* EDMA engine status */
+	EDMA_STATUS		= 0x30,		/* EDMA engine status */
@@ -345,2 +407,5 @@
-	EDMA_IORDY_TMOUT_OFS	= 0x34,
-	EDMA_ARB_CFG_OFS	= 0x38,
+	EDMA_IORDY_TMOUT	= 0x34,
+	EDMA_ARB_CFG		= 0x38,
+
+	EDMA_HALTCOND		= 0x60,		/* GenIIe halt conditions */
+	EDMA_UNKNOWN_RSVD	= 0x6C,		/* GenIIe unknown/reserved */
@@ -348 +413,4 @@
-	EDMA_HALTCOND_OFS	= 0x60,		/* GenIIe halt conditions */
+	BMDMA_CMD		= 0x224,	/* bmdma command register */
+	BMDMA_STATUS		= 0x228,	/* bmdma status register */
+	BMDMA_PRD_LOW		= 0x22c,	/* bmdma PRD addr 31:0 */
+	BMDMA_PRD_HIGH		= 0x230,	/* bmdma PRD addr 63:32 */
@@ -361,0 +430 @@
+	MV_HP_QUIRK_LED_BLINK_EN = (1 << 12),	/* is led blinking enabled? */
@@ -367,0 +437 @@
+	MV_PP_FLAG_FAKE_ATA_BUSY = (1 << 4),	/* ignore initial ATA_DRDY */
@@ -435,0 +506,12 @@
+/*
+ * We keep a local cache of a few frequently accessed port
+ * registers here, to avoid having to read them (very slow)
+ * when switching between EDMA and non-EDMA modes.
+ */
+struct mv_cached_regs {
+	u32			fiscfg;
+	u32			ltmode;
+	u32			haltcond;
+	u32			unknown_rsvd;
+};
+
@@ -447,0 +530 @@
+	struct mv_cached_regs	cached;
@@ -465,2 +548,2 @@
-	u32			irq_cause_ofs;
-	u32			irq_mask_ofs;
+	u32			irq_cause_offset;
+	u32			irq_mask_offset;
@@ -532,0 +616,2 @@
+static void mv_soc_65n_phy_errata(struct mv_host_priv *hpriv,
+				  void __iomem *mmio, unsigned int port);
@@ -538 +623 @@
-static void mv_edma_cfg(struct ata_port *ap, int want_ncq);
+static void mv_edma_cfg(struct ata_port *ap, int want_ncq, int want_edma);
@@ -548,0 +634,8 @@
+static void mv_sff_irq_clear(struct ata_port *ap);
+static int mv_check_atapi_dma(struct ata_queued_cmd *qc);
+static void mv_bmdma_setup(struct ata_queued_cmd *qc);
+static void mv_bmdma_start(struct ata_queued_cmd *qc);
+static void mv_bmdma_stop(struct ata_queued_cmd *qc);
+static u8   mv_bmdma_status(struct ata_port *ap);
+static u8 mv_sff_check_status(struct ata_port *ap);
+
@@ -568,0 +662,2 @@
+	.lost_interrupt		= ATA_OP_NULL,
+
@@ -595,0 +691,8 @@
+
+	.sff_check_status	= mv_sff_check_status,
+	.sff_irq_clear		= mv_sff_irq_clear,
+	.check_atapi_dma	= mv_check_atapi_dma,
+	.bmdma_setup		= mv_bmdma_setup,
+	.bmdma_start		= mv_bmdma_start,
+	.bmdma_stop		= mv_bmdma_stop,
+	.bmdma_status		= mv_bmdma_status,
@@ -606,2 +709,2 @@
-		.flags		= MV_COMMON_FLAGS,
-		.pio_mask	= 0x1f,	/* pio0-4 */
+		.flags		= MV_GEN_I_FLAGS,
+		.pio_mask	= ATA_PIO4,
@@ -612,2 +715,2 @@
-		.flags		= MV_COMMON_FLAGS | MV_FLAG_DUAL_HC,
-		.pio_mask	= 0x1f,	/* pio0-4 */
+		.flags		= MV_GEN_I_FLAGS | MV_FLAG_DUAL_HC,
+		.pio_mask	= ATA_PIO4,
@@ -618,2 +721,2 @@
-		.flags		= MV_COMMON_FLAGS | MV_FLAG_DUAL_HC,
-		.pio_mask	= 0x1f,	/* pio0-4 */
+		.flags		= MV_GEN_I_FLAGS | MV_FLAG_DUAL_HC,
+		.pio_mask	= ATA_PIO4,
@@ -624,4 +727,2 @@
-		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS |
-				  ATA_FLAG_PMP | ATA_FLAG_ACPI_SATA |
-				  ATA_FLAG_NCQ,
-		.pio_mask	= 0x1f,	/* pio0-4 */
+		.flags		= MV_GEN_II_FLAGS,
+		.pio_mask	= ATA_PIO4,
@@ -632,4 +733,2 @@
-		.flags		= MV_COMMON_FLAGS | MV_6XXX_FLAGS |
-				  ATA_FLAG_PMP | ATA_FLAG_ACPI_SATA |
-				  ATA_FLAG_NCQ | MV_FLAG_DUAL_HC,
-		.pio_mask	= 0x1f,	/* pio0-4 */
+		.flags		= MV_GEN_II_FLAGS | MV_FLAG_DUAL_HC,
+		.pio_mask	= ATA_PIO4,
@@ -640,2 +739,2 @@
-		.flags		= MV_GENIIE_FLAGS,
-		.pio_mask	= 0x1f,	/* pio0-4 */
+		.flags		= MV_GEN_IIE_FLAGS,
+		.pio_mask	= ATA_PIO4,
@@ -646,2 +745,2 @@
-		.flags		= MV_GENIIE_FLAGS,
-		.pio_mask	= 0x1f,	/* pio0-4 */
+		.flags		= MV_GEN_IIE_FLAGS,
+		.pio_mask	= ATA_PIO4,
@@ -652,2 +751,2 @@
-		.flags		= MV_GENIIE_FLAGS,
-		.pio_mask	= 0x1f,	/* pio0-4 */
+		.flags		= MV_GEN_IIE_FLAGS,
+		.pio_mask	= ATA_PIO4,
@@ -716,0 +816,8 @@
+static const struct mv_hw_ops mv_soc_65n_ops = {
+	.phy_errata		= mv_soc_65n_phy_errata,
+	.enable_leds		= mv_soc_enable_leds,
+	.reset_hc		= mv_soc_reset_hc,
+	.reset_flash		= mv_soc_reset_flash,
+	.reset_bus		= mv_soc_reset_bus,
+};
+
@@ -757 +864 @@
-	return (base + MV_SATAHC0_REG_BASE + (hc * MV_SATAHC_REG_SZ));
+	return (base + SATAHC0_REG_BASE + (hc * MV_SATAHC_REG_SZ));
@@ -796,0 +904,56 @@
+/**
+ *      mv_save_cached_regs - (re-)initialize cached port registers
+ *      @ap: the port whose registers we are caching
+ *
+ *	Initialize the local cache of port registers,
+ *	so that reading them over and over again can
+ *	be avoided on the hotter paths of this driver.
+ *	This saves a few microseconds each time we switch
+ *	to/from EDMA mode to perform (eg.) a drive cache flush.
+ */
+static void mv_save_cached_regs(struct ata_port *ap)
+{
+	void __iomem *port_mmio = mv_ap_base(ap);
+	struct mv_port_priv *pp = ap->private_data;
+
+	pp->cached.fiscfg = readl(port_mmio + FISCFG);
+	pp->cached.ltmode = readl(port_mmio + LTMODE);
+	pp->cached.haltcond = readl(port_mmio + EDMA_HALTCOND);
+	pp->cached.unknown_rsvd = readl(port_mmio + EDMA_UNKNOWN_RSVD);
+}
+
+/**
+ *      mv_write_cached_reg - write to a cached port register
+ *      @addr: hardware address of the register
+ *      @old: pointer to cached value of the register
+ *      @new: new value for the register
+ *
+ *	Write a new value to a cached register,
+ *	but only if the value is different from before.
+ */
+static inline void mv_write_cached_reg(void __iomem *addr, u32 *old, u32 new)
+{
+	if (new != *old) {
+		unsigned long laddr;
+		*old = new;
+		/*
+		 * Workaround for 88SX60x1-B2 FEr SATA#13:
+		 * Read-after-write is needed to prevent generating 64-bit
+		 * write cycles on the PCI bus for SATA interface registers
+		 * at offsets ending in 0x4 or 0xc.
+		 *
+		 * Looks like a lot of fuss, but it avoids an unnecessary
+		 * +1 usec read-after-write delay for unaffected registers.
+		 */
+		laddr = (long)addr & 0xffff;
+		if (laddr >= 0x300 && laddr <= 0x33c) {
+			laddr &= 0x000f;
+			if (laddr == 0x4 || laddr == 0xc) {
+				writelfl(new, addr); /* read after write */
+				return;
+			}
+		}
+		writel(new, addr); /* unaffected by the errata */
+	}
+}
+
@@ -810 +973 @@
-	writel((pp->crqb_dma >> 16) >> 16, port_mmio + EDMA_REQ_Q_BASE_HI_OFS);
+	writel((pp->crqb_dma >> 16) >> 16, port_mmio + EDMA_REQ_Q_BASE_HI);
@@ -812,2 +975,2 @@
-		 port_mmio + EDMA_REQ_Q_IN_PTR_OFS);
-	writelfl(index, port_mmio + EDMA_REQ_Q_OUT_PTR_OFS);
+		 port_mmio + EDMA_REQ_Q_IN_PTR);
+	writelfl(index, port_mmio + EDMA_REQ_Q_OUT_PTR);
@@ -822,2 +985,2 @@
-	writel((pp->crpb_dma >> 16) >> 16, port_mmio + EDMA_RSP_Q_BASE_HI_OFS);
-	writelfl(index, port_mmio + EDMA_RSP_Q_IN_PTR_OFS);
+	writel((pp->crpb_dma >> 16) >> 16, port_mmio + EDMA_RSP_Q_BASE_HI);
+	writelfl(index, port_mmio + EDMA_RSP_Q_IN_PTR);
@@ -825 +988,18 @@
-		 port_mmio + EDMA_RSP_Q_OUT_PTR_OFS);
+		 port_mmio + EDMA_RSP_Q_OUT_PTR);
+}
+
+static void mv_write_main_irq_mask(u32 mask, struct mv_host_priv *hpriv)
+{
+	/*
+	 * When writing to the main_irq_mask in hardware,
+	 * we must ensure exclusivity between the interrupt coalescing bits
+	 * and the corresponding individual port DONE_IRQ bits.
+	 *
+	 * Note that this register is really an "IRQ enable" register,
+	 * not an "IRQ mask" register as Marvell's naming might suggest.
+	 */
+	if (mask & (ALL_PORTS_COAL_DONE | PORTS_0_3_COAL_DONE))
+		mask &= ~DONE_IRQ_0_3;
+	if (mask & (ALL_PORTS_COAL_DONE | PORTS_4_7_COAL_DONE))
+		mask &= ~DONE_IRQ_4_7;
+	writelfl(mask, hpriv->main_irq_mask_addr);
@@ -838 +1018 @@
-		writelfl(new_mask, hpriv->main_irq_mask_addr);
+		mv_write_main_irq_mask(new_mask, hpriv);
@@ -854,0 +1035,86 @@
+static void mv_clear_and_enable_port_irqs(struct ata_port *ap,
+					  void __iomem *port_mmio,
+					  unsigned int port_irqs)
+{
+	struct mv_host_priv *hpriv = ap->host->private_data;
+	int hardport = mv_hardport_from_port(ap->port_no);
+	void __iomem *hc_mmio = mv_hc_base_from_port(
+				mv_host_base(ap->host), ap->port_no);
+	u32 hc_irq_cause;
+
+	/* clear EDMA event indicators, if any */
+	writelfl(0, port_mmio + EDMA_ERR_IRQ_CAUSE);
+
+	/* clear pending irq events */
+	hc_irq_cause = ~((DEV_IRQ | DMA_IRQ) << hardport);
+	writelfl(hc_irq_cause, hc_mmio + HC_IRQ_CAUSE);
+
+	/* clear FIS IRQ Cause */
+	if (IS_GEN_IIE(hpriv))
+		writelfl(0, port_mmio + FIS_IRQ_CAUSE);
+
+	mv_enable_port_irqs(ap, port_irqs);
+}
+
+static void mv_set_irq_coalescing(struct ata_host *host,
+				  unsigned int count, unsigned int usecs)
+{
+	struct mv_host_priv *hpriv = host->private_data;
+	void __iomem *mmio = hpriv->base, *hc_mmio;
+	u32 coal_enable = 0;
+	unsigned long flags;
+	unsigned int clks, is_dual_hc = hpriv->n_ports > MV_PORTS_PER_HC;
+	const u32 coal_disable = PORTS_0_3_COAL_DONE | PORTS_4_7_COAL_DONE |
+							ALL_PORTS_COAL_DONE;
+
+	/* Disable IRQ coalescing if either threshold is zero */
+	if (!usecs || !count) {
+		clks = count = 0;
+	} else {
+		/* Respect maximum limits of the hardware */
+		clks = usecs * COAL_CLOCKS_PER_USEC;
+		if (clks > MAX_COAL_TIME_THRESHOLD)
+			clks = MAX_COAL_TIME_THRESHOLD;
+		if (count > MAX_COAL_IO_COUNT)
+			count = MAX_COAL_IO_COUNT;
+	}
+
+	spin_lock_irqsave(&host->lock, flags);
+	mv_set_main_irq_mask(host, coal_disable, 0);
+
+	if (is_dual_hc && !IS_GEN_I(hpriv)) {
+		/*
+		 * GEN_II/GEN_IIE with dual host controllers:
+		 * one set of global thresholds for the entire chip.
+		 */
+		writel(clks,  mmio + IRQ_COAL_TIME_THRESHOLD);
+		writel(count, mmio + IRQ_COAL_IO_THRESHOLD);
+		/* clear leftover coal IRQ bit */
+		writel(~ALL_PORTS_COAL_IRQ, mmio + IRQ_COAL_CAUSE);
+		if (count)
+			coal_enable = ALL_PORTS_COAL_DONE;
+		clks = count = 0; /* force clearing of regular regs below */
+	}
+
+	/*
+	 * All chips: independent thresholds for each HC on the chip.
+	 */
+	hc_mmio = mv_hc_base_from_port(mmio, 0);
+	writel(clks,  hc_mmio + HC_IRQ_COAL_TIME_THRESHOLD);
+	writel(count, hc_mmio + HC_IRQ_COAL_IO_THRESHOLD);
+	writel(~HC_COAL_IRQ, hc_mmio + HC_IRQ_CAUSE);
+	if (count)
+		coal_enable |= PORTS_0_3_COAL_DONE;
+	if (is_dual_hc) {
+		hc_mmio = mv_hc_base_from_port(mmio, MV_PORTS_PER_HC);
+		writel(clks,  hc_mmio + HC_IRQ_COAL_TIME_THRESHOLD);
+		writel(count, hc_mmio + HC_IRQ_COAL_IO_THRESHOLD);
+		writel(~HC_COAL_IRQ, hc_mmio + HC_IRQ_CAUSE);
+		if (count)
+			coal_enable |= PORTS_4_7_COAL_DONE;
+	}
+
+	mv_set_main_irq_mask(host, 0, coal_enable);
+	spin_unlock_irqrestore(&host->lock, flags);
+}
+
@@ -856 +1122 @@
- *      mv_start_dma - Enable eDMA engine
+ *      mv_start_edma - Enable eDMA engine
@@ -866 +1132 @@
-static void mv_start_dma(struct ata_port *ap, void __iomem *port_mmio,
+static void mv_start_edma(struct ata_port *ap, void __iomem *port_mmio,
@@ -878,7 +1143,0 @@
-		int hardport = mv_hardport_from_port(ap->port_no);
-		void __iomem *hc_mmio = mv_hc_base_from_port(
-					mv_host_base(ap->host), ap->port_no);
-		u32 hc_irq_cause;
-
-		/* clear EDMA event indicators, if any */
-		writelfl(0, port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
@@ -886,9 +1145 @@
-		/* clear pending irq events */
-		hc_irq_cause = ~((DEV_IRQ | DMA_IRQ) << hardport);
-		writelfl(hc_irq_cause, hc_mmio + HC_IRQ_CAUSE_OFS);
-
-		mv_edma_cfg(ap, want_ncq);
-
-		/* clear FIS IRQ Cause */
-		if (IS_GEN_IIE(hpriv))
-			writelfl(0, port_mmio + SATA_FIS_IRQ_CAUSE_OFS);
+		mv_edma_cfg(ap, want_ncq, 1);
@@ -897 +1148 @@
-		mv_enable_port_irqs(ap, DONE_IRQ|ERR_IRQ);
+		mv_clear_and_enable_port_irqs(ap, port_mmio, DONE_IRQ|ERR_IRQ);
@@ -899 +1150 @@
-		writelfl(EDMA_EN, port_mmio + EDMA_CMD_OFS);
+		writelfl(EDMA_EN, port_mmio + EDMA_CMD);
@@ -919 +1170 @@
-		u32 edma_stat = readl(port_mmio + EDMA_STATUS_OFS);
+		u32 edma_stat = readl(port_mmio + EDMA_STATUS);
@@ -939 +1190 @@
-	writelfl(EDMA_DS, port_mmio + EDMA_CMD_OFS);
+	writelfl(EDMA_DS, port_mmio + EDMA_CMD);
@@ -943 +1194 @@
-		u32 reg = readl(port_mmio + EDMA_CMD_OFS);
+		u32 reg = readl(port_mmio + EDMA_CMD);
@@ -954,0 +1206 @@
+	int err = 0;
@@ -962 +1214 @@
-		return -EIO;
+		err = -EIO;
@@ -964 +1216,2 @@
-	return 0;
+	mv_edma_cfg(ap, 0, 0);
+	return err;
@@ -1051 +1304 @@
-		ofs = SATA_STATUS_OFS + (sc_reg_in * sizeof(u32));
+		ofs = SATA_STATUS + (sc_reg_in * sizeof(u32));
@@ -1054 +1307 @@
-		ofs = SATA_ACTIVE_OFS;   /* active is not with the others */
+		ofs = SATA_ACTIVE;   /* active is not with the others */
@@ -1079 +1332,19 @@
-		writelfl(val, mv_ap_base(link->ap) + ofs);
+		void __iomem *addr = mv_ap_base(link->ap) + ofs;
+		if (sc_reg_in == SCR_CONTROL) {
+			/*
+			 * Workaround for 88SX60x1 FEr SATA#26:
+			 *
+			 * COMRESETs have to take care not to accidently
+			 * put the drive to sleep when writing SCR_CONTROL.
+			 * Setting bits 12..15 prevents this problem.
+			 *
+			 * So if we see an outbound COMMRESET, set those bits.
+			 * Ditto for the followup write that clears the reset.
+			 *
+			 * The proprietary driver does this for
+			 * all chip versions, and so do we.
+			 */
+			if ((val & 0xf) == 1 || (readl(addr) & 0xf) == 1)
+				val |= 0xf000;
+		}
+		writelfl(val, addr);
@@ -1133 +1404 @@
-static void mv_config_fbs(void __iomem *port_mmio, int want_ncq, int want_fbs)
+static void mv_config_fbs(struct ata_port *ap, int want_ncq, int want_fbs)
@@ -1135,11 +1406,9 @@
-	u32 new_fiscfg, old_fiscfg;
-	u32 new_ltmode, old_ltmode;
-	u32 new_haltcond, old_haltcond;
-
-	old_fiscfg   = readl(port_mmio + FISCFG_OFS);
-	old_ltmode   = readl(port_mmio + LTMODE_OFS);
-	old_haltcond = readl(port_mmio + EDMA_HALTCOND_OFS);
-
-	new_fiscfg   = old_fiscfg & ~(FISCFG_SINGLE_SYNC | FISCFG_WAIT_DEV_ERR);
-	new_ltmode   = old_ltmode & ~LTMODE_BIT8;
-	new_haltcond = old_haltcond | EDMA_ERR_DEV;
+	struct mv_port_priv *pp = ap->private_data;
+	void __iomem *port_mmio;
+
+	u32 fiscfg,   *old_fiscfg   = &pp->cached.fiscfg;
+	u32 ltmode,   *old_ltmode   = &pp->cached.ltmode;
+	u32 haltcond, *old_haltcond = &pp->cached.haltcond;
+
+	ltmode   = *old_ltmode & ~LTMODE_BIT8;
+	haltcond = *old_haltcond | EDMA_ERR_DEV;
@@ -1148,2 +1417,2 @@
-		new_fiscfg = old_fiscfg | FISCFG_SINGLE_SYNC;
-		new_ltmode = old_ltmode | LTMODE_BIT8;
+		fiscfg = *old_fiscfg | FISCFG_SINGLE_SYNC;
+		ltmode = *old_ltmode | LTMODE_BIT8;
@@ -1151 +1420 @@
-			new_haltcond &= ~EDMA_ERR_DEV;
+			haltcond &= ~EDMA_ERR_DEV;
@@ -1153 +1422,3 @@
-			new_fiscfg |=  FISCFG_WAIT_DEV_ERR;
+			fiscfg |=  FISCFG_WAIT_DEV_ERR;
+	} else {
+		fiscfg = *old_fiscfg & ~(FISCFG_SINGLE_SYNC | FISCFG_WAIT_DEV_ERR);
@@ -1156,6 +1427,4 @@
-	if (new_fiscfg != old_fiscfg)
-		writelfl(new_fiscfg, port_mmio + FISCFG_OFS);
-	if (new_ltmode != old_ltmode)
-		writelfl(new_ltmode, port_mmio + LTMODE_OFS);
-	if (new_haltcond != old_haltcond)
-		writelfl(new_haltcond, port_mmio + EDMA_HALTCOND_OFS);
+	port_mmio = mv_ap_base(ap);
+	mv_write_cached_reg(port_mmio + FISCFG, old_fiscfg, fiscfg);
+	mv_write_cached_reg(port_mmio + LTMODE, old_ltmode, ltmode);
+	mv_write_cached_reg(port_mmio + EDMA_HALTCOND, old_haltcond, haltcond);
@@ -1170 +1439 @@
-	old = readl(hpriv->base + MV_GPIO_PORT_CTL_OFS);
+	old = readl(hpriv->base + GPIO_PORT_CTL);
@@ -1176 +1445,54 @@
-		writel(new, hpriv->base + MV_GPIO_PORT_CTL_OFS);
+		writel(new, hpriv->base + GPIO_PORT_CTL);
+}
+
+/**
+ *	mv_bmdma_enable - set a magic bit on GEN_IIE to allow bmdma
+ *	@ap: Port being initialized
+ *
+ *	There are two DMA modes on these chips:  basic DMA, and EDMA.
+ *
+ *	Bit-0 of the "EDMA RESERVED" register enables/disables use
+ *	of basic DMA on the GEN_IIE versions of the chips.
+ *
+ *	This bit survives EDMA resets, and must be set for basic DMA
+ *	to function, and should be cleared when EDMA is active.
+ */
+static void mv_bmdma_enable_iie(struct ata_port *ap, int enable_bmdma)
+{
+	struct mv_port_priv *pp = ap->private_data;
+	u32 new, *old = &pp->cached.unknown_rsvd;
+
+	if (enable_bmdma)
+		new = *old | 1;
+	else
+		new = *old & ~1;
+	mv_write_cached_reg(mv_ap_base(ap) + EDMA_UNKNOWN_RSVD, old, new);
+}
+
+/*
+ * SOC chips have an issue whereby the HDD LEDs don't always blink
+ * during I/O when NCQ is enabled. Enabling a special "LED blink" mode
+ * of the SOC takes care of it, generating a steady blink rate when
+ * any drive on the chip is active.
+ *
+ * Unfortunately, the blink mode is a global hardware setting for the SOC,
+ * so we must use it whenever at least one port on the SOC has NCQ enabled.
+ *
+ * We turn "LED blink" off when NCQ is not in use anywhere, because the normal
+ * LED operation works then, and provides better (more accurate) feedback.
+ *
+ * Note that this code assumes that an SOC never has more than one HC onboard.
+ */
+static void mv_soc_led_blink_enable(struct ata_port *ap)
+{
+	struct ata_host *host = ap->host;
+	struct mv_host_priv *hpriv = host->private_data;
+	void __iomem *hc_mmio;
+	u32 led_ctrl;
+
+	if (hpriv->hp_flags & MV_HP_QUIRK_LED_BLINK_EN)
+		return;
+	hpriv->hp_flags |= MV_HP_QUIRK_LED_BLINK_EN;
+	hc_mmio = mv_hc_base_from_port(mv_host_base(host), ap->port_no);
+	led_ctrl = readl(hc_mmio + SOC_LED_CTRL);
+	writel(led_ctrl | SOC_LED_CTRL_BLINK, hc_mmio + SOC_LED_CTRL);
@@ -1179 +1501,27 @@
-static void mv_edma_cfg(struct ata_port *ap, int want_ncq)
+static void mv_soc_led_blink_disable(struct ata_port *ap)
+{
+	struct ata_host *host = ap->host;
+	struct mv_host_priv *hpriv = host->private_data;
+	void __iomem *hc_mmio;
+	u32 led_ctrl;
+	unsigned int port;
+
+	if (!(hpriv->hp_flags & MV_HP_QUIRK_LED_BLINK_EN))
+		return;
+
+	/* disable led-blink only if no ports are using NCQ */
+	for (port = 0; port < hpriv->n_ports; port++) {
+		struct ata_port *this_ap = host->ports[port];
+		struct mv_port_priv *pp = this_ap->private_data;
+
+		if (pp->pp_flags & MV_PP_FLAG_NCQ_EN)
+			return;
+	}
+
+	hpriv->hp_flags &= ~MV_HP_QUIRK_LED_BLINK_EN;
+	hc_mmio = mv_hc_base_from_port(mv_host_base(host), ap->port_no);
+	led_ctrl = readl(hc_mmio + SOC_LED_CTRL);
+	writel(led_ctrl & ~SOC_LED_CTRL_BLINK, hc_mmio + SOC_LED_CTRL);
+}
+
+static void mv_edma_cfg(struct ata_port *ap, int want_ncq, int want_edma)
@@ -1188 +1536,2 @@
-	pp->pp_flags &= ~MV_PP_FLAG_FBS_EN;
+	pp->pp_flags &=
+	  ~(MV_PP_FLAG_FBS_EN | MV_PP_FLAG_NCQ_EN | MV_PP_FLAG_FAKE_ATA_BUSY);
@@ -1209 +1558 @@
-		mv_config_fbs(port_mmio, want_ncq, want_fbs);
+		mv_config_fbs(ap, want_ncq, want_fbs);
@@ -1217,3 +1566,5 @@
-		cfg |= (1 << 22);	/* enab 4-entry host queue cache */
-		if (!IS_SOC(hpriv))
-			cfg |= (1 << 18);	/* enab early completion */
+		if (want_edma) {
+			cfg |= (1 << 22); /* enab 4-entry host queue cache */
+			if (!IS_SOC(hpriv))
+				cfg |= (1 << 18); /* enab early completion */
+		}
@@ -1221,0 +1573,8 @@
+		mv_bmdma_enable_iie(ap, !want_edma);
+
+		if (IS_SOC(hpriv)) {
+			if (want_ncq)
+				mv_soc_led_blink_enable(ap);
+			else
+				mv_soc_led_blink_disable(ap);
+		}
@@ -1227,2 +1586 @@
-	} else
-		pp->pp_flags &= ~MV_PP_FLAG_NCQ_EN;
+	}
@@ -1230 +1588 @@
-	writelfl(cfg, port_mmio + EDMA_CFG_OFS);
+	writelfl(cfg, port_mmio + EDMA_CFG);
@@ -1276,0 +1635 @@
+	unsigned long flags;
@@ -1311,0 +1671,6 @@
+
+	spin_lock_irqsave(ap->lock, flags);
+	mv_save_cached_regs(ap);
+	mv_edma_cfg(ap, 0, 0);
+	spin_unlock_irqrestore(ap->lock, flags);
+
@@ -1329,0 +1695,3 @@
+	unsigned long flags;
+
+	spin_lock_irqsave(ap->lock, flags);
@@ -1331,0 +1700 @@
+	spin_unlock_irqrestore(ap->lock, flags);
@@ -1360 +1729 @@
-			if ((offset + sg_len > 0x10000))
+			if (offset + len > 0x10000)
@@ -1365,0 +1735 @@
+			mv_sg->reserved = 0;
@@ -1376,0 +1747 @@
+	mb(); /* ensure data structure is visible to the chipset */
@@ -1386,0 +1758,174 @@
+ *	mv_sff_irq_clear - Clear hardware interrupt after DMA.
+ *	@ap: Port associated with this ATA transaction.
+ *
+ *	We need this only for ATAPI bmdma transactions,
+ *	as otherwise we experience spurious interrupts
+ *	after libata-sff handles the bmdma interrupts.
+ */
+static void mv_sff_irq_clear(struct ata_port *ap)
+{
+	mv_clear_and_enable_port_irqs(ap, mv_ap_base(ap), ERR_IRQ);
+}
+
+/**
+ *	mv_check_atapi_dma - Filter ATAPI cmds which are unsuitable for DMA.
+ *	@qc: queued command to check for chipset/DMA compatibility.
+ *
+ *	The bmdma engines cannot handle speculative data sizes
+ *	(bytecount under/over flow).  So only allow DMA for
+ *	data transfer commands with known data sizes.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+static int mv_check_atapi_dma(struct ata_queued_cmd *qc)
+{
+	struct scsi_cmnd *scmd = qc->scsicmd;
+
+	if (scmd) {
+		switch (scmd->cmnd[0]) {
+		case READ_6:
+		case READ_10:
+		case READ_12:
+		case WRITE_6:
+		case WRITE_10:
+		case WRITE_12:
+		case GPCMD_READ_CD:
+		case GPCMD_SEND_DVD_STRUCTURE:
+		case GPCMD_SEND_CUE_SHEET:
+			return 0; /* DMA is safe */
+		}
+	}
+	return -EOPNOTSUPP; /* use PIO instead */
+}
+
+/**
+ *	mv_bmdma_setup - Set up BMDMA transaction
+ *	@qc: queued command to prepare DMA for.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+static void mv_bmdma_setup(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	void __iomem *port_mmio = mv_ap_base(ap);
+	struct mv_port_priv *pp = ap->private_data;
+
+	mv_fill_sg(qc);
+
+	/* clear all DMA cmd bits */
+	writel(0, port_mmio + BMDMA_CMD);
+
+	/* load PRD table addr. */
+	writel((pp->sg_tbl_dma[qc->tag] >> 16) >> 16,
+		port_mmio + BMDMA_PRD_HIGH);
+	writelfl(pp->sg_tbl_dma[qc->tag],
+		port_mmio + BMDMA_PRD_LOW);
+
+	/* issue r/w command */
+	ap->ops->sff_exec_command(ap, &qc->tf);
+}
+
+/**
+ *	mv_bmdma_start - Start a BMDMA transaction
+ *	@qc: queued command to start DMA on.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+static void mv_bmdma_start(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	void __iomem *port_mmio = mv_ap_base(ap);
+	unsigned int rw = (qc->tf.flags & ATA_TFLAG_WRITE);
+	u32 cmd = (rw ? 0 : ATA_DMA_WR) | ATA_DMA_START;
+
+	/* start host DMA transaction */
+	writelfl(cmd, port_mmio + BMDMA_CMD);
+}
+
+/**
+ *	mv_bmdma_stop - Stop BMDMA transfer
+ *	@qc: queued command to stop DMA on.
+ *
+ *	Clears the ATA_DMA_START flag in the bmdma control register
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+static void mv_bmdma_stop(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	void __iomem *port_mmio = mv_ap_base(ap);
+	u32 cmd;
+
+	/* clear start/stop bit */
+	cmd = readl(port_mmio + BMDMA_CMD);
+	cmd &= ~ATA_DMA_START;
+	writelfl(cmd, port_mmio + BMDMA_CMD);
+
+	/* one-PIO-cycle guaranteed wait, per spec, for HDMA1:0 transition */
+	ata_sff_dma_pause(ap);
+}
+
+/**
+ *	mv_bmdma_status - Read BMDMA status
+ *	@ap: port for which to retrieve DMA status.
+ *
+ *	Read and return equivalent of the sff BMDMA status register.
+ *
+ *	LOCKING:
+ *	Inherited from caller.
+ */
+static u8 mv_bmdma_status(struct ata_port *ap)
+{
+	void __iomem *port_mmio = mv_ap_base(ap);
+	u32 reg, status;
+
+	/*
+	 * Other bits are valid only if ATA_DMA_ACTIVE==0,
+	 * and the ATA_DMA_INTR bit doesn't exist.
+	 */
+	reg = readl(port_mmio + BMDMA_STATUS);
+	if (reg & ATA_DMA_ACTIVE)
+		status = ATA_DMA_ACTIVE;
+	else
+		status = (reg & ATA_DMA_ERR) | ATA_DMA_INTR;
+	return status;
+}
+
+static void mv_rw_multi_errata_sata24(struct ata_queued_cmd *qc)
+{
+	struct ata_taskfile *tf = &qc->tf;
+	/*
+	 * Workaround for 88SX60x1 FEr SATA#24.
+	 *
+	 * Chip may corrupt WRITEs if multi_count >= 4kB.
+	 * Note that READs are unaffected.
+	 *
+	 * It's not clear if this errata really means "4K bytes",
+	 * or if it always happens for multi_count > 7
+	 * regardless of device sector_size.
+	 *
+	 * So, for safety, any write with multi_count > 7
+	 * gets converted here into a regular PIO write instead:
+	 */
+	if ((tf->flags & ATA_TFLAG_WRITE) && is_multi_taskfile(tf)) {
+		if (qc->dev->multi_count > 7) {
+			switch (tf->command) {
+			case ATA_CMD_WRITE_MULTI:
+				tf->command = ATA_CMD_PIO_WRITE;
+				break;
+			case ATA_CMD_WRITE_MULTI_FUA_EXT:
+				tf->flags &= ~ATA_TFLAG_FUA; /* ugh */
+				/* fall through */
+			case ATA_CMD_WRITE_MULTI_EXT:
+				tf->command = ATA_CMD_PIO_WRITE_EXT;
+				break;
+			}
+		}
+	}
+}
+
+/**
@@ -1403 +1948 @@
-	struct ata_taskfile *tf;
+	struct ata_taskfile *tf = &qc->tf;
@@ -1407,2 +1952,6 @@
-	if ((qc->tf.protocol != ATA_PROT_DMA) &&
-	    (qc->tf.protocol != ATA_PROT_NCQ))
+	switch (tf->protocol) {
+	case ATA_PROT_DMA:
+	case ATA_PROT_NCQ:
+		break;	/* continue below */
+	case ATA_PROT_PIO:
+		mv_rw_multi_errata_sata24(qc);
@@ -1409,0 +1959,3 @@
+	default:
+		return;
+	}
@@ -1413 +1965 @@
-	if (!(qc->tf.flags & ATA_TFLAG_WRITE))
+	if (!(tf->flags & ATA_TFLAG_WRITE))
@@ -1429 +1980,0 @@
-	tf = &qc->tf;
@@ -1495 +2046 @@
-	struct ata_taskfile *tf;
+	struct ata_taskfile *tf = &qc->tf;
@@ -1499,2 +2050,2 @@
-	if ((qc->tf.protocol != ATA_PROT_DMA) &&
-	    (qc->tf.protocol != ATA_PROT_NCQ))
+	if ((tf->protocol != ATA_PROT_DMA) &&
+	    (tf->protocol != ATA_PROT_NCQ))
@@ -1504 +2055 @@
-	if (!(qc->tf.flags & ATA_TFLAG_WRITE))
+	if (!(tf->flags & ATA_TFLAG_WRITE))
@@ -1520 +2070,0 @@
-	tf = &qc->tf;
@@ -1547,0 +2098,126 @@
+ *	mv_sff_check_status - fetch device status, if valid
+ *	@ap: ATA port to fetch status from
+ *
+ *	When using command issue via mv_qc_issue_fis(),
+ *	the initial ATA_BUSY state does not show up in the
+ *	ATA status (shadow) register.  This can confuse libata!
+ *
+ *	So we have a hook here to fake ATA_BUSY for that situation,
+ *	until the first time a BUSY, DRQ, or ERR bit is seen.
+ *
+ *	The rest of the time, it simply returns the ATA status register.
+ */
+static u8 mv_sff_check_status(struct ata_port *ap)
+{
+	u8 stat = ioread8(ap->ioaddr.status_addr);
+	struct mv_port_priv *pp = ap->private_data;
+
+	if (pp->pp_flags & MV_PP_FLAG_FAKE_ATA_BUSY) {
+		if (stat & (ATA_BUSY | ATA_DRQ | ATA_ERR))
+			pp->pp_flags &= ~MV_PP_FLAG_FAKE_ATA_BUSY;
+		else
+			stat = ATA_BUSY;
+	}
+	return stat;
+}
+
+/**
+ *	mv_send_fis - Send a FIS, using the "Vendor-Unique FIS" register
+ *	@fis: fis to be sent
+ *	@nwords: number of 32-bit words in the fis
+ */
+static unsigned int mv_send_fis(struct ata_port *ap, u32 *fis, int nwords)
+{
+	void __iomem *port_mmio = mv_ap_base(ap);
+	u32 ifctl, old_ifctl, ifstat;
+	int i, timeout = 200, final_word = nwords - 1;
+
+	/* Initiate FIS transmission mode */
+	old_ifctl = readl(port_mmio + SATA_IFCTL);
+	ifctl = 0x100 | (old_ifctl & 0xf);
+	writelfl(ifctl, port_mmio + SATA_IFCTL);
+
+	/* Send all words of the FIS except for the final word */
+	for (i = 0; i < final_word; ++i)
+		writel(fis[i], port_mmio + VENDOR_UNIQUE_FIS);
+
+	/* Flag end-of-transmission, and then send the final word */
+	writelfl(ifctl | 0x200, port_mmio + SATA_IFCTL);
+	writelfl(fis[final_word], port_mmio + VENDOR_UNIQUE_FIS);
+
+	/*
+	 * Wait for FIS transmission to complete.
+	 * This typically takes just a single iteration.
+	 */
+	do {
+		ifstat = readl(port_mmio + SATA_IFSTAT);
+	} while (!(ifstat & 0x1000) && --timeout);
+
+	/* Restore original port configuration */
+	writelfl(old_ifctl, port_mmio + SATA_IFCTL);
+
+	/* See if it worked */
+	if ((ifstat & 0x3000) != 0x1000) {
+		ata_port_printk(ap, KERN_WARNING,
+				"%s transmission error, ifstat=%08x\n",
+				__func__, ifstat);
+		return AC_ERR_OTHER;
+	}
+	return 0;
+}
+
+/**
+ *	mv_qc_issue_fis - Issue a command directly as a FIS
+ *	@qc: queued command to start
+ *
+ *	Note that the ATA shadow registers are not updated
+ *	after command issue, so the device will appear "READY"
+ *	if polled, even while it is BUSY processing the command.
+ *
+ *	So we use a status hook to fake ATA_BUSY until the drive changes state.
+ *
+ *	Note: we don't get updated shadow regs on *completion*
+ *	of non-data commands. So avoid sending them via this function,
+ *	as they will appear to have completed immediately.
+ *
+ *	GEN_IIE has special registers that we could get the result tf from,
+ *	but earlier chipsets do not.  For now, we ignore those registers.
+ */
+static unsigned int mv_qc_issue_fis(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	struct mv_port_priv *pp = ap->private_data;
+	struct ata_link *link = qc->dev->link;
+	u32 fis[5];
+	int err = 0;
+
+	ata_tf_to_fis(&qc->tf, link->pmp, 1, (void *)fis);
+	err = mv_send_fis(ap, fis, sizeof(fis) / sizeof(fis[0]));
+	if (err)
+		return err;
+
+	switch (qc->tf.protocol) {
+	case ATAPI_PROT_PIO:
+		pp->pp_flags |= MV_PP_FLAG_FAKE_ATA_BUSY;
+		/* fall through */
+	case ATAPI_PROT_NODATA:
+		ap->hsm_task_state = HSM_ST_FIRST;
+		break;
+	case ATA_PROT_PIO:
+		pp->pp_flags |= MV_PP_FLAG_FAKE_ATA_BUSY;
+		if (qc->tf.flags & ATA_TFLAG_WRITE)
+			ap->hsm_task_state = HSM_ST_FIRST;
+		else
+			ap->hsm_task_state = HSM_ST;
+		break;
+	default:
+		ap->hsm_task_state = HSM_ST_LAST;
+		break;
+	}
+
+	if (qc->tf.flags & ATA_TFLAG_POLLING)
+		ata_pio_queue_task(ap, qc, 0);
+	return 0;
+}
+
+/**
@@ -1560,0 +2237 @@
+	static int limit_warnings = 10;
@@ -1564,0 +2242 @@
+	unsigned int port_irqs;
@@ -1566,3 +2244,15 @@
-	if ((qc->tf.protocol != ATA_PROT_DMA) &&
-	    (qc->tf.protocol != ATA_PROT_NCQ)) {
-		static int limit_warnings = 10;
+	pp->pp_flags &= ~MV_PP_FLAG_FAKE_ATA_BUSY; /* paranoia */
+
+	switch (qc->tf.protocol) {
+	case ATA_PROT_DMA:
+	case ATA_PROT_NCQ:
+		mv_start_edma(ap, port_mmio, pp, qc->tf.protocol);
+		pp->req_idx = (pp->req_idx + 1) & MV_MAX_Q_DEPTH_MASK;
+		in_index = pp->req_idx << EDMA_REQ_Q_PTR_SHIFT;
+
+		/* Write the request in pointer to kick the EDMA to life */
+		writelfl((pp->crqb_dma & EDMA_REQ_Q_BASE_LO_MASK) | in_index,
+					port_mmio + EDMA_REQ_Q_IN_PTR);
+		return 0;
+
+	case ATA_PROT_PIO:
@@ -1586,9 +2276,7 @@
-		/*
-		 * We're about to send a non-EDMA capable command to the
-		 * port.  Turn off EDMA so there won't be problems accessing
-		 * shadow block, etc registers.
-		 */
-		mv_stop_edma(ap);
-		mv_enable_port_irqs(ap, ERR_IRQ);
-		mv_pmp_select(ap, qc->dev->link->pmp);
-		return ata_sff_qc_issue(qc);
+		/* drop through */
+	case ATA_PROT_NODATA:
+	case ATAPI_PROT_PIO:
+	case ATAPI_PROT_NODATA:
+		if (ap->flags & ATA_FLAG_PIO_POLLING)
+			qc->tf.flags |= ATA_TFLAG_POLLING;
+		break;
@@ -1597,4 +2285,4 @@
-	mv_start_dma(ap, port_mmio, pp, qc->tf.protocol);
-
-	pp->req_idx = (pp->req_idx + 1) & MV_MAX_Q_DEPTH_MASK;
-	in_index = pp->req_idx << EDMA_REQ_Q_PTR_SHIFT;
+	if (qc->tf.flags & ATA_TFLAG_POLLING)
+		port_irqs = ERR_IRQ;	/* mask device interrupt when polling */
+	else
+		port_irqs = ERR_IRQ | DONE_IRQ;	/* unmask all interrupts */
@@ -1602,3 +2290,8 @@
-	/* and write the request in pointer to kick the EDMA to life */
-	writelfl((pp->crqb_dma & EDMA_REQ_Q_BASE_LO_MASK) | in_index,
-		 port_mmio + EDMA_REQ_Q_IN_PTR_OFS);
+	/*
+	 * We're about to send a non-EDMA capable command to the
+	 * port.  Turn off EDMA so there won't be problems accessing
+	 * shadow block, etc registers.
+	 */
+	mv_stop_edma(ap);
+	mv_clear_and_enable_port_irqs(ap, mv_ap_base(ap), port_irqs);
+	mv_pmp_select(ap, qc->dev->link->pmp);
@@ -1606 +2299,17 @@
-	return 0;
+	if (qc->tf.command == ATA_CMD_READ_LOG_EXT) {
+		struct mv_host_priv *hpriv = ap->host->private_data;
+		/*
+		 * Workaround for 88SX60x1 FEr SATA#25 (part 2).
+		 *
+		 * After any NCQ error, the READ_LOG_EXT command
+		 * from libata-eh *must* use mv_qc_issue_fis().
+		 * Otherwise it might fail, due to chip errata.
+		 *
+		 * Rather than special-case it, we'll just *always*
+		 * use this method here for READ_LOG_EXT, making for
+		 * easier testing.
+		 */
+		if (IS_GEN_II(hpriv))
+			return mv_qc_issue_fis(qc);
+	}
+	return ata_sff_qc_issue(qc);
@@ -1617,2 +2326,6 @@
-	if (qc && (qc->tf.flags & ATA_TFLAG_POLLING))
-		qc = NULL;
+	if (qc) {
+		if (qc->tf.flags & ATA_TFLAG_POLLING)
+			qc = NULL;
+		else if (!(qc->flags & ATA_QCFLAG_ACTIVE))
+			qc = NULL;
+	}
@@ -1653 +2366 @@
-	return readl(port_mmio + SATA_TESTCTL_OFS) >> 16;
+	return readl(port_mmio + SATA_TESTCTL) >> 16;
@@ -1686 +2399 @@
-	in_ptr  = (readl(port_mmio + EDMA_REQ_Q_IN_PTR_OFS)
+	in_ptr  = (readl(port_mmio + EDMA_REQ_Q_IN_PTR)
@@ -1688 +2401 @@
-	out_ptr = (readl(port_mmio + EDMA_REQ_Q_OUT_PTR_OFS)
+	out_ptr = (readl(port_mmio + EDMA_REQ_Q_OUT_PTR)
@@ -1850 +2563 @@
-	edma_err_cause = readl(port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
+	edma_err_cause = readl(port_mmio + EDMA_ERR_IRQ_CAUSE);
@@ -1852,2 +2565,2 @@
-		fis_cause = readl(port_mmio + SATA_FIS_IRQ_CAUSE_OFS);
-		writelfl(~fis_cause, port_mmio + SATA_FIS_IRQ_CAUSE_OFS);
+		fis_cause = readl(port_mmio + FIS_IRQ_CAUSE);
+		writelfl(~fis_cause, port_mmio + FIS_IRQ_CAUSE);
@@ -1855 +2568 @@
-	writelfl(~edma_err_cause, port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
+	writelfl(~edma_err_cause, port_mmio + EDMA_ERR_IRQ_CAUSE);
@@ -1873 +2586 @@
-		if (fis_cause & SATA_FIS_IRQ_AN) {
+		if (fis_cause & FIS_IRQ_CAUSE_AN) {
@@ -1975 +2688 @@
-		 *   LSB is from EDMA_ERR_IRQ_CAUSE_OFS (non-NCQ only).
+		 *   LSB is from EDMA_ERR_IRQ_CAUSE (non-NCQ only).
@@ -2007 +2720 @@
-	in_index = (readl(port_mmio + EDMA_RSP_Q_IN_PTR_OFS)
+	in_index = (readl(port_mmio + EDMA_RSP_Q_IN_PTR)
@@ -2032 +2745 @@
-			 port_mmio + EDMA_RSP_Q_OUT_PTR_OFS);
+			 port_mmio + EDMA_RSP_Q_OUT_PTR);
@@ -2086,0 +2800,4 @@
+	/* If asserted, clear the "all ports" IRQ coalescing bit */
+	if (main_irq_cause & ALL_PORTS_COAL_DONE)
+		writel(~ALL_PORTS_COAL_IRQ, mmio + IRQ_COAL_CAUSE);
+
@@ -2118,0 +2836,2 @@
+			if (hc_cause & PORTS_0_3_COAL_DONE)
+				ack_irqs = HC_COAL_IRQ;
@@ -2127 +2846 @@
-			writelfl(~ack_irqs, hc_mmio + HC_IRQ_CAUSE_OFS);
+			writelfl(~ack_irqs, hc_mmio + HC_IRQ_CAUSE);
@@ -2149 +2868 @@
-	err_cause = readl(mmio + hpriv->irq_cause_ofs);
+	err_cause = readl(mmio + hpriv->irq_cause_offset);
@@ -2157 +2876 @@
-	writelfl(0, mmio + hpriv->irq_cause_ofs);
+	writelfl(0, mmio + hpriv->irq_cause_offset);
@@ -2207 +2926 @@
-		writel(0, hpriv->main_irq_mask_addr);
+		mv_write_main_irq_mask(0, hpriv);
@@ -2224 +2943 @@
-		writel(hpriv->main_irq_mask, hpriv->main_irq_mask_addr);
+		mv_write_main_irq_mask(hpriv->main_irq_mask, hpriv);
@@ -2294 +3013 @@
-	writel(0x0fcfffff, mmio + MV_FLASH_CTL_OFS);
+	writel(0x0fcfffff, mmio + FLASH_CTL);
@@ -2313 +3032 @@
-	writel(0, mmio + MV_GPIO_PORT_CTL_OFS);
+	writel(0, mmio + GPIO_PORT_CTL);
@@ -2331 +3050 @@
-		tmp = readl(phy_mmio + MV5_LTMODE_OFS);
+		tmp = readl(phy_mmio + MV5_LTMODE);
@@ -2333 +3052 @@
-		writel(tmp, phy_mmio + MV5_LTMODE_OFS);
+		writel(tmp, phy_mmio + MV5_LTMODE);
@@ -2335 +3054 @@
-		tmp = readl(phy_mmio + MV5_PHY_CTL_OFS);
+		tmp = readl(phy_mmio + MV5_PHY_CTL);
@@ -2338 +3057 @@
-		writel(tmp, phy_mmio + MV5_PHY_CTL_OFS);
+		writel(tmp, phy_mmio + MV5_PHY_CTL);
@@ -2359 +3078 @@
-	writel(0x11f, port_mmio + EDMA_CFG_OFS);
+	writel(0x11f, port_mmio + EDMA_CFG);
@@ -2370 +3089 @@
-	writel(0xbc, port_mmio + EDMA_IORDY_TMOUT_OFS);
+	writel(0xbc, port_mmio + EDMA_IORDY_TMOUT);
@@ -2416 +3135 @@
-	tmp = readl(mmio + MV_PCI_MODE_OFS);
+	tmp = readl(mmio + MV_PCI_MODE);
@@ -2418 +3137 @@
-	writel(tmp, mmio + MV_PCI_MODE_OFS);
+	writel(tmp, mmio + MV_PCI_MODE);
@@ -2422 +3141 @@
-	writel(0x000100ff, mmio + MV_PCI_XBAR_TMOUT_OFS);
+	writel(0x000100ff, mmio + MV_PCI_XBAR_TMOUT);
@@ -2424,2 +3143,2 @@
-	ZERO(hpriv->irq_cause_ofs);
-	ZERO(hpriv->irq_mask_ofs);
+	ZERO(hpriv->irq_cause_offset);
+	ZERO(hpriv->irq_mask_offset);
@@ -2439 +3158 @@
-	tmp = readl(mmio + MV_GPIO_PORT_CTL_OFS);
+	tmp = readl(mmio + GPIO_PORT_CTL);
@@ -2442 +3161 @@
-	writel(tmp, mmio + MV_GPIO_PORT_CTL_OFS);
+	writel(tmp, mmio + GPIO_PORT_CTL);
@@ -2457 +3176 @@
-	void __iomem *reg = mmio + PCI_MAIN_CMD_STS_OFS;
+	void __iomem *reg = mmio + PCI_MAIN_CMD_STS;
@@ -2515 +3234 @@
-	tmp = readl(mmio + MV_RESET_CFG_OFS);
+	tmp = readl(mmio + RESET_CFG);
@@ -2531 +3250 @@
-	writel(0x00000060, mmio + MV_GPIO_PORT_CTL_OFS);
+	writel(0x00000060, mmio + GPIO_PORT_CTL);
@@ -2588,0 +3308 @@
+	 * Or ensure we use writelfl() when writing PHY_MODE4.
@@ -2640 +3360 @@
-	writel(0x101f, port_mmio + EDMA_CFG_OFS);
+	writel(0x101f, port_mmio + EDMA_CFG);
@@ -2651 +3371 @@
-	writel(0xbc, port_mmio + EDMA_IORDY_TMOUT_OFS);
+	writel(0xbc, port_mmio + EDMA_IORDY_TMOUT);
@@ -2693,0 +3414,47 @@
+static void mv_soc_65n_phy_errata(struct mv_host_priv *hpriv,
+				  void __iomem *mmio, unsigned int port)
+{
+	void __iomem *port_mmio = mv_port_base(mmio, port);
+	u32	reg;
+
+	reg = readl(port_mmio + PHY_MODE3);
+	reg &= ~(0x3 << 27);	/* SELMUPF (bits 28:27) to 1 */
+	reg |= (0x1 << 27);
+	reg &= ~(0x3 << 29);	/* SELMUPI (bits 30:29) to 1 */
+	reg |= (0x1 << 29);
+	writel(reg, port_mmio + PHY_MODE3);
+
+	reg = readl(port_mmio + PHY_MODE4);
+	reg &= ~0x1;	/* SATU_OD8 (bit 0) to 0, reserved bit 16 must be set */
+	reg |= (0x1 << 16);
+	writel(reg, port_mmio + PHY_MODE4);
+
+	reg = readl(port_mmio + PHY_MODE9_GEN2);
+	reg &= ~0xf;	/* TXAMP[3:0] (bits 3:0) to 8 */
+	reg |= 0x8;
+	reg &= ~(0x1 << 14);	/* TXAMP[4] (bit 14) to 0 */
+	writel(reg, port_mmio + PHY_MODE9_GEN2);
+
+	reg = readl(port_mmio + PHY_MODE9_GEN1);
+	reg &= ~0xf;	/* TXAMP[3:0] (bits 3:0) to 8 */
+	reg |= 0x8;
+	reg &= ~(0x1 << 14);	/* TXAMP[4] (bit 14) to 0 */
+	writel(reg, port_mmio + PHY_MODE9_GEN1);
+}
+
+/**
+ *	soc_is_65 - check if the soc is 65 nano device
+ *
+ *	Detect the type of the SoC, this is done by reading the PHYCFG_OFS
+ *	register, this register should contain non-zero value and it exists only
+ *	in the 65 nano devices, when reading it from older devices we get 0.
+ */
+static bool soc_is_65n(struct mv_host_priv *hpriv)
+{
+	void __iomem *port0_mmio = mv_port_base(hpriv->base, 0);
+
+	if (readl(port0_mmio + PHYCFG_OFS))
+		return true;
+	return false;
+}
+
@@ -2696 +3463 @@
-	u32 ifcfg = readl(port_mmio + SATA_INTERFACE_CFG_OFS);
+	u32 ifcfg = readl(port_mmio + SATA_IFCFG);
@@ -2701 +3468 @@
-	writelfl(ifcfg, port_mmio + SATA_INTERFACE_CFG_OFS);
+	writelfl(ifcfg, port_mmio + SATA_IFCFG);
@@ -2715 +3482 @@
-	writelfl(EDMA_RESET, port_mmio + EDMA_CMD_OFS);
+	writelfl(EDMA_RESET, port_mmio + EDMA_CMD);
@@ -2724 +3491 @@
-	 * (except for SATA_INTERFACE_CFG), and issues a COMRESET to the dev.
+	 * (except for SATA_IFCFG), and issues a COMRESET to the dev.
@@ -2726 +3493 @@
-	writelfl(EDMA_RESET, port_mmio + EDMA_CMD_OFS);
+	writelfl(EDMA_RESET, port_mmio + EDMA_CMD);
@@ -2728 +3495 @@
-	writelfl(0, port_mmio + EDMA_CMD_OFS);
+	writelfl(0, port_mmio + EDMA_CMD);
@@ -2740 +3507 @@
-		u32 reg = readl(port_mmio + SATA_IFCTL_OFS);
+		u32 reg = readl(port_mmio + SATA_IFCTL);
@@ -2745 +3512 @@
-			writelfl(reg, port_mmio + SATA_IFCTL_OFS);
+			writelfl(reg, port_mmio + SATA_IFCTL);
@@ -2776,0 +3544,2 @@
+	pp->pp_flags &=
+	  ~(MV_PP_FLAG_FBS_EN | MV_PP_FLAG_NCQ_EN | MV_PP_FLAG_FAKE_ATA_BUSY);
@@ -2795,0 +3565,2 @@
+	mv_save_cached_regs(ap);
+	mv_edma_cfg(ap, 0, 0);
@@ -2816 +3587 @@
-	writel(0, port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
+	writel(0, port_mmio + EDMA_ERR_IRQ_CAUSE);
@@ -2820 +3591 @@
-	writelfl(hc_irq_cause, hc_mmio + HC_IRQ_CAUSE_OFS);
+	writelfl(hc_irq_cause, hc_mmio + HC_IRQ_CAUSE);
@@ -2839,2 +3610 @@
-	void __iomem *shd_base = port_mmio + SHD_BLK_OFS;
-	unsigned serr_ofs;
+	void __iomem *serr, *shd_base = port_mmio + SHD_BLK;
@@ -2855 +3625 @@
-	port->altstatus_addr = port->ctl_addr = shd_base + SHD_CTL_AST_OFS;
+	port->altstatus_addr = port->ctl_addr = shd_base + SHD_CTL_AST;
@@ -2861,3 +3631,3 @@
-	serr_ofs = mv_scr_offset(SCR_ERROR);
-	writelfl(readl(port_mmio + serr_ofs), port_mmio + serr_ofs);
-	writelfl(0, port_mmio + EDMA_ERR_IRQ_CAUSE_OFS);
+	serr = port_mmio + mv_scr_offset(SCR_ERROR);
+	writelfl(readl(serr), serr);
+	writelfl(0, port_mmio + EDMA_ERR_IRQ_CAUSE);
@@ -2866 +3636 @@
-	writelfl(~EDMA_ERR_IRQ_TRANSIENT, port_mmio + EDMA_ERR_IRQ_MASK_OFS);
+	writelfl(~EDMA_ERR_IRQ_TRANSIENT, port_mmio + EDMA_ERR_IRQ_MASK);
@@ -2869,3 +3639,3 @@
-		readl(port_mmio + EDMA_CFG_OFS),
-		readl(port_mmio + EDMA_ERR_IRQ_CAUSE_OFS),
-		readl(port_mmio + EDMA_ERR_IRQ_MASK_OFS));
+		readl(port_mmio + EDMA_CFG),
+		readl(port_mmio + EDMA_ERR_IRQ_CAUSE),
+		readl(port_mmio + EDMA_ERR_IRQ_MASK));
@@ -2882 +3652 @@
-	reg = readl(mmio + MV_PCI_MODE_OFS);
+	reg = readl(mmio + MV_PCI_MODE);
@@ -2895,2 +3665,2 @@
-		reg = readl(mmio + PCI_COMMAND_OFS);
-		if (reg & PCI_COMMAND_MRDTRIG)
+		reg = readl(mmio + MV_PCI_COMMAND);
+		if (reg & MV_PCI_COMMAND_MRDTRIG)
@@ -2901,0 +3672,12 @@
+static void mv_60x1b2_errata_pci7(struct ata_host *host)
+{
+	struct mv_host_priv *hpriv = host->private_data;
+	void __iomem *mmio = hpriv->base;
+
+	/* workaround for 60x1-B2 errata PCI#7 */
+	if (mv_in_pcix_mode(host)) {
+		u32 reg = readl(mmio + MV_PCI_COMMAND);
+		writelfl(reg & ~MV_PCI_COMMAND_MWRCOM, mmio + MV_PCI_COMMAND);
+	}
+}
+
@@ -2954,0 +3737 @@
+			mv_60x1b2_errata_pci7(host);
@@ -3018 +3801,4 @@
-		hpriv->ops = &mv_soc_ops;
+		if (soc_is_65n(hpriv))
+			hpriv->ops = &mv_soc_65n_ops;
+		else
+			hpriv->ops = &mv_soc_ops;
@@ -3031,2 +3817,2 @@
-		hpriv->irq_cause_ofs	= PCIE_IRQ_CAUSE_OFS;
-		hpriv->irq_mask_ofs	= PCIE_IRQ_MASK_OFS;
+		hpriv->irq_cause_offset	= PCIE_IRQ_CAUSE;
+		hpriv->irq_mask_offset	= PCIE_IRQ_MASK;
@@ -3035,2 +3821,2 @@
-		hpriv->irq_cause_ofs	= PCI_IRQ_CAUSE_OFS;
-		hpriv->irq_mask_ofs	= PCI_IRQ_MASK_OFS;
+		hpriv->irq_cause_offset	= PCI_IRQ_CAUSE;
+		hpriv->irq_mask_offset	= PCI_IRQ_MASK;
@@ -3065,2 +3851,2 @@
-		hpriv->main_irq_cause_addr = mmio + SOC_HC_MAIN_IRQ_CAUSE_OFS;
-		hpriv->main_irq_mask_addr  = mmio + SOC_HC_MAIN_IRQ_MASK_OFS;
+		hpriv->main_irq_cause_addr = mmio + SOC_HC_MAIN_IRQ_CAUSE;
+		hpriv->main_irq_mask_addr  = mmio + SOC_HC_MAIN_IRQ_MASK;
@@ -3068,2 +3854,2 @@
-		hpriv->main_irq_cause_addr = mmio + PCI_HC_MAIN_IRQ_CAUSE_OFS;
-		hpriv->main_irq_mask_addr  = mmio + PCI_HC_MAIN_IRQ_MASK_OFS;
+		hpriv->main_irq_cause_addr = mmio + PCI_HC_MAIN_IRQ_CAUSE;
+		hpriv->main_irq_mask_addr  = mmio + PCI_HC_MAIN_IRQ_MASK;
@@ -3081 +3867,2 @@
-		hpriv->ops->read_preamp(hpriv, port, mmio);
+		if (hpriv->ops->read_preamp)
+			hpriv->ops->read_preamp(hpriv, port, mmio);
@@ -3111,2 +3898,2 @@
-			readl(hc_mmio + HC_CFG_OFS),
-			readl(hc_mmio + HC_IRQ_CAUSE_OFS));
+			readl(hc_mmio + HC_CFG),
+			readl(hc_mmio + HC_IRQ_CAUSE));
@@ -3115 +3902 @@
-		writelfl(0, hc_mmio + HC_IRQ_CAUSE_OFS);
+		writelfl(0, hc_mmio + HC_IRQ_CAUSE);
@@ -3118,2 +3905,3 @@
-	/* Clear any currently outstanding host interrupt conditions */
-	writelfl(0, mmio + hpriv->irq_cause_ofs);
+	if (!IS_SOC(hpriv)) {
+		/* Clear any currently outstanding host interrupt conditions */
+		writelfl(0, mmio + hpriv->irq_cause_offset);
@@ -3121,2 +3909,3 @@
-	/* and unmask interrupt generation for host regs */
-	writelfl(hpriv->unmask_all_irqs, mmio + hpriv->irq_mask_ofs);
+		/* and unmask interrupt generation for host regs */
+		writelfl(hpriv->unmask_all_irqs, mmio + hpriv->irq_mask_offset);
+	}
@@ -3128,0 +3918,2 @@
+	mv_set_irq_coalescing(host, irq_coalescing_io_count,
+				    irq_coalescing_usecs);
@@ -3226 +4017 @@
-	hpriv->base -= MV_SATAHC0_REG_BASE;
+	hpriv->base -= SATAHC0_REG_BASE;
@@ -3290,6 +4080,0 @@
-/*
- * module options
- */
-static int msi;	      /* Use PCI msi; either zero (off, default) or non-zero */
-
-
@@ -3301,2 +4086,2 @@
-	if (!pci_set_dma_mask(pdev, DMA_64BIT_MASK)) {
-		rc = pci_set_consistent_dma_mask(pdev, DMA_64BIT_MASK);
+	if (!pci_set_dma_mask(pdev, DMA_BIT_MASK(64))) {
+		rc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(64));
@@ -3304 +4089 @@
-			rc = pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK);
+			rc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));
@@ -3312 +4097 @@
-		rc = pci_set_dma_mask(pdev, DMA_32BIT_MASK);
+		rc = pci_set_dma_mask(pdev, DMA_BIT_MASK(32));
@@ -3318 +4103 @@
-		rc = pci_set_consistent_dma_mask(pdev, DMA_32BIT_MASK);
+		rc = pci_set_consistent_dma_mask(pdev, DMA_BIT_MASK(32));
@@ -3477,5 +4261,0 @@
-#ifdef CONFIG_PCI
-module_param(msi, int, 0444);
-MODULE_PARM_DESC(msi, "Enable use of PCI MSI (0=off, 1=on)");
-#endif
-
--- ./projects/linux/linux-2.6.19/drivers/ata/sata_sil.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/ata/sata_sil.c	2007-02-04 19:44:54.000000000 +0100
@@ -358,0 +359 @@
+	struct ata_eh_info *ehi = &ap->eh_info;
@@ -430,0 +432,4 @@
+	if (unlikely(qc->err_mask) && (qc->tf.protocol == ATA_PROT_DMA ||
+				       qc->tf.protocol == ATA_PROT_ATAPI_DMA))
+		ata_ehi_push_desc(ehi, "BMDMA2 stat 0x%x", bmdma2);
+
@@ -536,0 +542 @@
+	int print_info = ap->eh_context.i.flags & ATA_EHI_PRINTINFO;
@@ -552,2 +558,3 @@
-		ata_dev_printk(dev, KERN_INFO, "applying Seagate errata fix "
-			       "(mod15write workaround)\n");
+		if (print_info)
+			ata_dev_printk(dev, KERN_INFO, "applying Seagate "
+				       "errata fix (mod15write workaround)\n");
@@ -560,2 +567,3 @@
-		ata_dev_printk(dev, KERN_INFO,
-			       "applying Maxtor errata fix %s\n", model_num);
+		if (print_info)
+			ata_dev_printk(dev, KERN_INFO, "applying Maxtor "
+				       "errata fix %s\n", model_num);
--- ./projects/linux/linux-2.6.20/drivers/ata/sata_sil.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/ata/sata_sil.c	2007-04-26 05:08:32.000000000 +0200
@@ -49 +49 @@
-#define DRV_VERSION	"2.0"
+#define DRV_VERSION	"2.1"
@@ -51,0 +52,2 @@
+	SIL_MMIO_BAR		= 5,
+
@@ -183,0 +186 @@
+#ifdef CONFIG_PM
@@ -185,0 +189 @@
+#endif
@@ -203 +207 @@
-	.data_xfer		= ata_mmio_data_xfer,
+	.data_xfer		= ata_data_xfer,
@@ -209,0 +214,2 @@
+	.irq_on			= ata_irq_on,
+	.irq_ack		= ata_irq_ack,
@@ -213,2 +218,0 @@
-	.port_stop		= ata_port_stop,
-	.host_stop		= ata_pci_host_stop,
@@ -300 +304,2 @@
-	void __iomem *addr = host->mmio_base + sil_port[ap->port_no].xfer_mode;
+	void __iomem *mmio_base = host->iomap[SIL_MMIO_BAR];
+	void __iomem *addr = mmio_base + sil_port[ap->port_no].xfer_mode;
@@ -323 +328 @@
-static inline unsigned long sil_scr_addr(struct ata_port *ap, unsigned int sc_reg)
+static inline void __iomem *sil_scr_addr(struct ata_port *ap, unsigned int sc_reg)
@@ -325 +330 @@
-	unsigned long offset = ap->ioaddr.scr_addr;
+	void __iomem *offset = ap->ioaddr.scr_addr;
@@ -339 +344 @@
-	return 0;
+	return NULL;
@@ -344 +349 @@
-	void __iomem *mmio = (void __iomem *) sil_scr_addr(ap, sc_reg);
+	void __iomem *mmio = sil_scr_addr(ap, sc_reg);
@@ -352 +357 @@
-	void __iomem *mmio = (void __iomem *) sil_scr_addr(ap, sc_reg);
+	void __iomem *mmio = sil_scr_addr(ap, sc_reg);
@@ -386 +391 @@
-	if (unlikely(!qc || qc->tf.ctl & ATA_NIEN))
+	if (unlikely(!qc))
@@ -388,0 +394,6 @@
+	if (unlikely(qc->tf.flags & ATA_TFLAG_POLLING)) {
+		/* this sometimes happens, just clear IRQ */
+		ata_chk_status(ap);
+		return;
+	}
+
@@ -447 +458 @@
-	void __iomem *mmio_base = host->mmio_base;
+	void __iomem *mmio_base = host->iomap[SIL_MMIO_BAR];
@@ -479 +490 @@
-	void __iomem *mmio_base = ap->host->mmio_base;
+	void __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];
@@ -494 +505 @@
-	void __iomem *mmio_base = ap->host->mmio_base;
+	void __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];
@@ -544 +555 @@
-	unsigned char model_num[41];
+	unsigned char model_num[ATA_ID_PROD_LEN + 1];
@@ -546 +557 @@
-	ata_id_c_string(dev->id, model_num, ATA_ID_PROD_OFS, sizeof(model_num));
+	ata_id_c_string(dev->id, model_num, ATA_ID_PROD, sizeof(model_num));
@@ -624,2 +635,2 @@
-	struct ata_probe_ent *probe_ent = NULL;
-	unsigned long base;
+	struct device *dev = &pdev->dev;
+	struct ata_probe_ent *probe_ent;
@@ -629 +639,0 @@
-	int pci_dev_busy = 0;
@@ -634 +644 @@
-	rc = pci_enable_device(pdev);
+	rc = pcim_enable_device(pdev);
@@ -638,5 +648,5 @@
-	rc = pci_request_regions(pdev, DRV_NAME);
-	if (rc) {
-		pci_dev_busy = 1;
-		goto err_out;
-	}
+	rc = pcim_iomap_regions(pdev, 1 << SIL_MMIO_BAR, DRV_NAME);
+	if (rc == -EBUSY)
+		pcim_pin_device(pdev);
+	if (rc)
+		return rc;
@@ -646 +656 @@
-		goto err_out_regions;
+		return rc;
@@ -649 +659 @@
-		goto err_out_regions;
+		return rc;
@@ -651,5 +661,3 @@
-	probe_ent = kzalloc(sizeof(*probe_ent), GFP_KERNEL);
-	if (probe_ent == NULL) {
-		rc = -ENOMEM;
-		goto err_out_regions;
-	}
+	probe_ent = devm_kzalloc(dev, sizeof(*probe_ent), GFP_KERNEL);
+	if (probe_ent == NULL)
+		return -ENOMEM;
@@ -669,7 +677 @@
-	mmio_base = pci_iomap(pdev, 5, 0);
-	if (mmio_base == NULL) {
-		rc = -ENOMEM;
-		goto err_out_free_ent;
-	}
-
-	probe_ent->mmio_base = mmio_base;
+	probe_ent->iomap = pcim_iomap_table(pdev);
@@ -677 +679 @@
-	base = (unsigned long) mmio_base;
+	mmio_base = probe_ent->iomap[SIL_MMIO_BAR];
@@ -680 +682 @@
-		probe_ent->port[i].cmd_addr = base + sil_port[i].tf;
+		probe_ent->port[i].cmd_addr = mmio_base + sil_port[i].tf;
@@ -682,3 +684,3 @@
-		probe_ent->port[i].ctl_addr = base + sil_port[i].ctl;
-		probe_ent->port[i].bmdma_addr = base + sil_port[i].bmdma;
-		probe_ent->port[i].scr_addr = base + sil_port[i].scr;
+		probe_ent->port[i].ctl_addr = mmio_base + sil_port[i].ctl;
+		probe_ent->port[i].bmdma_addr = mmio_base + sil_port[i].bmdma;
+		probe_ent->port[i].scr_addr = mmio_base + sil_port[i].scr;
@@ -693,3 +695,2 @@
-	/* FIXME: check ata_device_add return value */
-	ata_device_add(probe_ent);
-	kfree(probe_ent);
+	if (!ata_device_add(probe_ent))
+		return -ENODEV;
@@ -696,0 +698 @@
+	devm_kfree(dev, probe_ent);
@@ -698,9 +699,0 @@
-
-err_out_free_ent:
-	kfree(probe_ent);
-err_out_regions:
-	pci_release_regions(pdev);
-err_out:
-	if (!pci_dev_busy)
-		pci_disable_device(pdev);
-	return rc;
@@ -712,0 +706,5 @@
+	int rc;
+
+	rc = ata_pci_device_do_resume(pdev);
+	if (rc)
+		return rc;
@@ -714 +711,0 @@
-	ata_pci_device_do_resume(pdev);
@@ -716 +713 @@
-			    host->mmio_base);
+			    host->iomap[SIL_MMIO_BAR]);
--- ./projects/linux/linux-2.6.21/drivers/ata/sata_sil.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/ata/sata_sil.c	2007-07-09 01:32:17.000000000 +0200
@@ -49 +49 @@
-#define DRV_VERSION	"2.1"
+#define DRV_VERSION	"2.2"
@@ -117 +117 @@
-static void sil_dev_config(struct ata_port *ap, struct ata_device *dev);
+static void sil_dev_config(struct ata_device *dev);
@@ -120,2 +120 @@
-static void sil_post_set_mode (struct ata_port *ap);
-static irqreturn_t sil_interrupt(int irq, void *dev_instance);
+static int sil_set_mode (struct ata_port *ap, struct ata_device **r_failed);
@@ -186,4 +184,0 @@
-#ifdef CONFIG_PM
-	.suspend		= ata_scsi_device_suspend,
-	.resume			= ata_scsi_device_resume,
-#endif
@@ -200 +195 @@
-	.post_set_mode		= sil_post_set_mode,
+	.set_mode		= sil_set_mode,
@@ -212 +206,0 @@
-	.irq_handler		= sil_interrupt,
@@ -224 +217,0 @@
-		.sht		= &sil_sht,
@@ -233 +225,0 @@
-		.sht		= &sil_sht,
@@ -243 +234,0 @@
-		.sht		= &sil_sht,
@@ -252 +242,0 @@
-		.sht		= &sil_sht,
@@ -300 +290,10 @@
-static void sil_post_set_mode (struct ata_port *ap)
+/**
+ *	sil_set_mode		-	wrap set_mode functions
+ *	@ap: port to set up
+ *	@r_failed: returned device when we fail
+ *
+ *	Wrap the libata method for device setup as after the setup we need
+ *	to inspect the results and do some configuration work
+ */
+
+static int sil_set_mode (struct ata_port *ap, struct ata_device **r_failed)
@@ -307,0 +307,5 @@
+	int rc;
+
+	rc = ata_do_set_mode(ap, r_failed);
+	if (rc)
+		return rc;
@@ -325,0 +330 @@
+	return 0;
@@ -524 +528,0 @@
- *	@ap: Port containing device to be examined
@@ -551 +555 @@
-static void sil_dev_config(struct ata_port *ap, struct ata_device *dev)
+static void sil_dev_config(struct ata_device *dev)
@@ -552,0 +557 @@
+	struct ata_port *ap = dev->ap;
@@ -586,3 +591 @@
-static void sil_init_controller(struct pci_dev *pdev,
-				int n_ports, unsigned long port_flags,
-				void __iomem *mmio_base)
+static void sil_init_controller(struct ata_host *host)
@@ -589,0 +593,2 @@
+	struct pci_dev *pdev = to_pci_dev(host->dev);
+	void __iomem *mmio_base = host->iomap[SIL_MMIO_BAR];
@@ -599 +604 @@
-		for (i = 0; i < n_ports; i++)
+		for (i = 0; i < host->n_ports; i++)
@@ -607 +612 @@
-	if (port_flags & SIL_FLAG_RERR_ON_DMA_ACT) {
+	if (host->ports[0]->flags & SIL_FLAG_RERR_ON_DMA_ACT) {
@@ -610 +615 @@
-		for (i = 0, cnt = 0; i < n_ports; i++) {
+		for (i = 0, cnt = 0; i < host->n_ports; i++) {
@@ -623 +628 @@
-	if (n_ports == 4) {
+	if (host->n_ports == 4) {
@@ -635,2 +640,3 @@
-	struct device *dev = &pdev->dev;
-	struct ata_probe_ent *probe_ent;
+	int board_id = ent->driver_data;
+	const struct ata_port_info *ppi[] = { &sil_port_info[board_id], NULL };
+	struct ata_host *host;
@@ -638 +644 @@
-	int rc;
+	int n_ports, rc;
@@ -643,0 +650,10 @@
+	/* allocate host */
+	n_ports = 2;
+	if (board_id == sil_3114)
+		n_ports = 4;
+
+	host = ata_host_alloc_pinfo(&pdev->dev, ppi, n_ports);
+	if (!host)
+		return -ENOMEM;
+
+	/* acquire resources and fill host */
@@ -652,0 +669 @@
+	host->iomap = pcim_iomap_table(pdev);
@@ -661,3 +678 @@
-	probe_ent = devm_kzalloc(dev, sizeof(*probe_ent), GFP_KERNEL);
-	if (probe_ent == NULL)
-		return -ENOMEM;
+	mmio_base = host->iomap[SIL_MMIO_BAR];
@@ -665,23 +680,9 @@
-	INIT_LIST_HEAD(&probe_ent->node);
-	probe_ent->dev = pci_dev_to_dev(pdev);
-	probe_ent->port_ops = sil_port_info[ent->driver_data].port_ops;
-	probe_ent->sht = sil_port_info[ent->driver_data].sht;
-	probe_ent->n_ports = (ent->driver_data == sil_3114) ? 4 : 2;
-	probe_ent->pio_mask = sil_port_info[ent->driver_data].pio_mask;
-	probe_ent->mwdma_mask = sil_port_info[ent->driver_data].mwdma_mask;
-	probe_ent->udma_mask = sil_port_info[ent->driver_data].udma_mask;
-       	probe_ent->irq = pdev->irq;
-       	probe_ent->irq_flags = IRQF_SHARED;
-	probe_ent->port_flags = sil_port_info[ent->driver_data].flags;
-
-	probe_ent->iomap = pcim_iomap_table(pdev);
-
-	mmio_base = probe_ent->iomap[SIL_MMIO_BAR];
-
-	for (i = 0; i < probe_ent->n_ports; i++) {
-		probe_ent->port[i].cmd_addr = mmio_base + sil_port[i].tf;
-		probe_ent->port[i].altstatus_addr =
-		probe_ent->port[i].ctl_addr = mmio_base + sil_port[i].ctl;
-		probe_ent->port[i].bmdma_addr = mmio_base + sil_port[i].bmdma;
-		probe_ent->port[i].scr_addr = mmio_base + sil_port[i].scr;
-		ata_std_ports(&probe_ent->port[i]);
+	for (i = 0; i < host->n_ports; i++) {
+		struct ata_ioports *ioaddr = &host->ports[i]->ioaddr;
+
+		ioaddr->cmd_addr = mmio_base + sil_port[i].tf;
+		ioaddr->altstatus_addr =
+		ioaddr->ctl_addr = mmio_base + sil_port[i].ctl;
+		ioaddr->bmdma_addr = mmio_base + sil_port[i].bmdma;
+		ioaddr->scr_addr = mmio_base + sil_port[i].scr;
+		ata_std_ports(ioaddr);
@@ -690,2 +691,2 @@
-	sil_init_controller(pdev, probe_ent->n_ports, probe_ent->port_flags,
-			    mmio_base);
+	/* initialize and activate */
+	sil_init_controller(host);
@@ -694,6 +695,2 @@
-
-	if (!ata_device_add(probe_ent))
-		return -ENODEV;
-
-	devm_kfree(dev, probe_ent);
-	return 0;
+	return ata_host_activate(host, pdev->irq, sil_interrupt, IRQF_SHARED,
+				 &sil_sht);
@@ -712,2 +709 @@
-	sil_init_controller(pdev, host->n_ports, host->ports[0]->flags,
-			    host->iomap[SIL_MMIO_BAR]);
+	sil_init_controller(host);
--- ./projects/linux/linux-2.6.22/drivers/ata/sata_sil.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/ata/sata_sil.c	2007-10-09 22:31:38.000000000 +0200
@@ -49 +49 @@
-#define DRV_VERSION	"2.2"
+#define DRV_VERSION	"2.3"
@@ -118,2 +118,2 @@
-static u32 sil_scr_read (struct ata_port *ap, unsigned int sc_reg);
-static void sil_scr_write (struct ata_port *ap, unsigned int sc_reg, u32 val);
+static int sil_scr_read(struct ata_port *ap, unsigned int sc_reg, u32 *val);
+static int sil_scr_write(struct ata_port *ap, unsigned int sc_reg, u32 val);
@@ -221 +221 @@
-		.udma_mask	= 0x3f,			/* udma0-5 */
+		.udma_mask	= ATA_UDMA5,
@@ -230 +230 @@
-		.udma_mask	= 0x3f,			/* udma0-5 */
+		.udma_mask	= ATA_UDMA5,
@@ -238 +238 @@
-		.udma_mask	= 0x3f,			/* udma0-5 */
+		.udma_mask	= ATA_UDMA5,
@@ -246 +246 @@
-		.udma_mask	= 0x3f,			/* udma0-5 */
+		.udma_mask	= ATA_UDMA5,
@@ -265,2 +265,3 @@
-	{ 0x80, 0x8A, 0x00, 0x10, 0x40, 0x100, 0x148, 0xb4, 0x14c },
-	{ 0xC0, 0xCA, 0x08, 0x18, 0x44, 0x180, 0x1c8, 0xf4, 0x1cc },
+	/*   tf    ctl  bmdma  bmdma2  fifo    scr   sien   mode   sfis */
+	{  0x80,  0x8A,   0x0,  0x10,  0x40, 0x100, 0x148,  0xb4, 0x14c },
+	{  0xC0,  0xCA,   0x8,  0x18,  0x44, 0x180, 0x1c8,  0xf4, 0x1cc },
@@ -352 +353 @@
-static u32 sil_scr_read (struct ata_port *ap, unsigned int sc_reg)
+static int sil_scr_read(struct ata_port *ap, unsigned int sc_reg, u32 *val)
@@ -355,3 +356,6 @@
-	if (mmio)
-		return readl(mmio);
-	return 0xffffffffU;
+
+	if (mmio) {
+		*val = readl(mmio);
+		return 0;
+	}
+	return -EINVAL;
@@ -360 +364 @@
-static void sil_scr_write (struct ata_port *ap, unsigned int sc_reg, u32 val)
+static int sil_scr_write(struct ata_port *ap, unsigned int sc_reg, u32 val)
@@ -363 +367,2 @@
-	if (mmio)
+
+	if (mmio) {
@@ -364,0 +370,3 @@
+		return 0;
+	}
+	return -EINVAL;
@@ -380 +388 @@
-		serror = sil_scr_read(ap, SCR_ERROR);
+		sil_scr_read(ap, SCR_ERROR, &serror);
--- ./projects/linux/linux-2.6.23/drivers/ata/sata_sil.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/ata/sata_sil.c	2008-01-24 23:58:37.000000000 +0100
@@ -62 +62,2 @@
-				  ATA_FLAG_MMIO | ATA_FLAG_HRST_TO_RESUME,
+				  ATA_FLAG_MMIO,
+	SIL_DFL_LINK_FLAGS	= ATA_LFLAG_HRST_TO_RESUME,
@@ -113 +114 @@
-static int sil_init_one (struct pci_dev *pdev, const struct pci_device_id *ent);
+static int sil_init_one(struct pci_dev *pdev, const struct pci_device_id *ent);
@@ -120 +121 @@
-static int sil_set_mode (struct ata_port *ap, struct ata_device **r_failed);
+static int sil_set_mode(struct ata_link *link, struct ata_device **r_failed);
@@ -140 +141 @@
-	const char * product;
+	const char *product;
@@ -188 +188,0 @@
-	.port_disable		= ata_port_disable,
@@ -209 +208,0 @@
-	.irq_ack		= ata_irq_ack,
@@ -218,0 +218 @@
+		.link_flags	= SIL_DFL_LINK_FLAGS,
@@ -227,0 +228 @@
+		.link_flags	= SIL_DFL_LINK_FLAGS,
@@ -235,0 +237 @@
+		.link_flags	= SIL_DFL_LINK_FLAGS,
@@ -243,0 +246 @@
+		.link_flags	= SIL_DFL_LINK_FLAGS,
@@ -279 +282 @@
-static int slow_down = 0;
+static int slow_down;
@@ -293 +296 @@
- *	@ap: port to set up
+ *	@link: link to set up
@@ -300 +303 @@
-static int sil_set_mode (struct ata_port *ap, struct ata_device **r_failed)
+static int sil_set_mode(struct ata_link *link, struct ata_device **r_failed)
@@ -302,3 +305,2 @@
-	struct ata_host *host = ap->host;
-	struct ata_device *dev;
-	void __iomem *mmio_base = host->iomap[SIL_MMIO_BAR];
+	struct ata_port *ap = link->ap;
+	void __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];
@@ -306,2 +308,2 @@
-	u32 tmp, dev_mode[2];
-	unsigned int i;
+	struct ata_device *dev;
+	u32 tmp, dev_mode[2] = { };
@@ -310 +312 @@
-	rc = ata_do_set_mode(ap, r_failed);
+	rc = ata_do_set_mode(link, r_failed);
@@ -314,2 +316 @@
-	for (i = 0; i < 2; i++) {
-		dev = &ap->device[i];
+	ata_link_for_each_dev(dev, link) {
@@ -317 +318 @@
-			dev_mode[i] = 0;	/* PIO0/1/2 */
+			dev_mode[dev->devno] = 0;	/* PIO0/1/2 */
@@ -319 +320 @@
-			dev_mode[i] = 1;	/* PIO3/4 */
+			dev_mode[dev->devno] = 1;	/* PIO3/4 */
@@ -321 +322 @@
-			dev_mode[i] = 3;	/* UDMA */
+			dev_mode[dev->devno] = 3;	/* UDMA */
@@ -334 +335,2 @@
-static inline void __iomem *sil_scr_addr(struct ata_port *ap, unsigned int sc_reg)
+static inline void __iomem *sil_scr_addr(struct ata_port *ap,
+					 unsigned int sc_reg)
@@ -377,2 +379,2 @@
-	struct ata_eh_info *ehi = &ap->eh_info;
-	struct ata_queued_cmd *qc = ata_qc_from_tag(ap, ap->active_tag);
+	struct ata_eh_info *ehi = &ap->link.eh_info;
+	struct ata_queued_cmd *qc = ata_qc_from_tag(ap, ap->link.active_tag);
@@ -391,4 +393,2 @@
-		/* Trigger hotplug and accumulate SError only if the
-		 * port isn't already frozen.  Otherwise, PHY events
-		 * during hardreset makes controllers with broken SIEN
-		 * repeat probing needlessly.
+		/* Sometimes spurious interrupts occur, double check
+		 * it's PHYRDY CHG.
@@ -396,3 +396,3 @@
-		if (!(ap->pflags & ATA_PFLAG_FROZEN)) {
-			ata_ehi_hotplugged(&ap->eh_info);
-			ap->eh_info.serror |= serror;
+		if (serror & SERR_PHYRDY_CHG) {
+			ap->link.eh_info.serror |= serror;
+			goto freeze;
@@ -401 +401,2 @@
-		goto freeze;
+		if (!(bmdma2 & SIL_DMA_COMPLETE))
+			return;
@@ -404,4 +405 @@
-	if (unlikely(!qc))
-		goto freeze;
-
-	if (unlikely(qc->tf.flags & ATA_TFLAG_POLLING)) {
+	if (unlikely(!qc || (qc->tf.flags & ATA_TFLAG_POLLING))) {
@@ -565,2 +563,2 @@
-	struct ata_port *ap = dev->ap;
-	int print_info = ap->eh_context.i.flags & ATA_EHI_PRINTINFO;
+	struct ata_port *ap = dev->link->ap;
+	int print_info = ap->link.eh_context.i.flags & ATA_EHI_PRINTINFO;
@@ -645 +643 @@
-static int sil_init_one (struct pci_dev *pdev, const struct pci_device_id *ent)
+static int sil_init_one(struct pci_dev *pdev, const struct pci_device_id *ent)
@@ -689 +687,2 @@
-		struct ata_ioports *ioaddr = &host->ports[i]->ioaddr;
+		struct ata_port *ap = host->ports[i];
+		struct ata_ioports *ioaddr = &ap->ioaddr;
@@ -696,0 +696,3 @@
+
+		ata_port_pbar_desc(ap, SIL_MMIO_BAR, -1, "mmio");
+		ata_port_pbar_desc(ap, SIL_MMIO_BAR, sil_port[i].tf, "tf");
--- ./projects/linux/linux-2.6.24/drivers/ata/sata_sil.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/ata/sata_sil.c	2008-04-17 04:49:44.000000000 +0200
@@ -419,2 +419,2 @@
-		 * The flag was turned on only for atapi devices.
-		 * No need to check is_atapi_taskfile(&qc->tf) again.
+		 * The flag was turned on only for atapi devices.  No
+		 * need to check ata_is_atapi(qc->tf.protocol) again.
@@ -426,2 +426 @@
-		if (qc->tf.protocol == ATA_PROT_DMA ||
-		    qc->tf.protocol == ATA_PROT_ATAPI_DMA) {
+		if (ata_is_dma(qc->tf.protocol)) {
@@ -454,2 +453 @@
-	if (unlikely(qc->err_mask) && (qc->tf.protocol == ATA_PROT_DMA ||
-				       qc->tf.protocol == ATA_PROT_ATAPI_DMA))
+	if (unlikely(qc->err_mask) && ata_is_dma(qc->tf.protocol))
--- ./projects/linux/linux-2.6.25/drivers/ata/sata_sil.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/ata/sata_sil.c	2008-07-13 23:51:29.000000000 +0200
@@ -63 +62,0 @@
-	SIL_DFL_LINK_FLAGS	= ATA_LFLAG_HRST_TO_RESUME,
@@ -171,15 +170 @@
-	.module			= THIS_MODULE,
-	.name			= DRV_NAME,
-	.ioctl			= ata_scsi_ioctl,
-	.queuecommand		= ata_scsi_queuecmd,
-	.can_queue		= ATA_DEF_QUEUE,
-	.this_id		= ATA_SHT_THIS_ID,
-	.sg_tablesize		= LIBATA_MAX_PRD,
-	.cmd_per_lun		= ATA_SHT_CMD_PER_LUN,
-	.emulated		= ATA_SHT_EMULATED,
-	.use_clustering		= ATA_SHT_USE_CLUSTERING,
-	.proc_name		= DRV_NAME,
-	.dma_boundary		= ATA_DMA_BOUNDARY,
-	.slave_configure	= ata_scsi_slave_config,
-	.slave_destroy		= ata_scsi_slave_destroy,
-	.bios_param		= ata_std_bios_param,
+	ATA_BMDMA_SHT(DRV_NAME),
@@ -188 +173,2 @@
-static const struct ata_port_operations sil_ops = {
+static struct ata_port_operations sil_ops = {
+	.inherits		= &ata_bmdma_port_ops,
@@ -190,5 +175,0 @@
-	.tf_load		= ata_tf_load,
-	.tf_read		= ata_tf_read,
-	.check_status		= ata_check_status,
-	.exec_command		= ata_exec_command,
-	.dev_select		= ata_std_dev_select,
@@ -196,7 +176,0 @@
-	.bmdma_setup            = ata_bmdma_setup,
-	.bmdma_start            = ata_bmdma_start,
-	.bmdma_stop		= ata_bmdma_stop,
-	.bmdma_status		= ata_bmdma_status,
-	.qc_prep		= ata_qc_prep,
-	.qc_issue		= ata_qc_issue_prot,
-	.data_xfer		= ata_data_xfer,
@@ -205,4 +178,0 @@
-	.error_handler		= ata_bmdma_error_handler,
-	.post_internal_cmd	= ata_bmdma_post_internal_cmd,
-	.irq_clear		= ata_bmdma_irq_clear,
-	.irq_on			= ata_irq_on,
@@ -211 +180,0 @@
-	.port_start		= ata_port_start,
@@ -218 +186,0 @@
-		.link_flags	= SIL_DFL_LINK_FLAGS,
@@ -228 +195,0 @@
-		.link_flags	= SIL_DFL_LINK_FLAGS,
@@ -237 +203,0 @@
-		.link_flags	= SIL_DFL_LINK_FLAGS,
@@ -246 +211,0 @@
-		.link_flags	= SIL_DFL_LINK_FLAGS,
@@ -407 +372 @@
-		ata_chk_status(ap);
+		ap->ops->sff_check_status(ap);
@@ -443 +408 @@
-	status = ata_chk_status(ap);
+	status = ap->ops->sff_check_status(ap);
@@ -448 +413 @@
-	ata_bmdma_irq_clear(ap);
+	ata_sff_irq_clear(ap);
@@ -451 +416 @@
-	ata_hsm_move(ap, qc, status, 0);
+	ata_sff_hsm_move(ap, qc, status, 0);
@@ -518,2 +483,2 @@
-	ata_chk_status(ap);
-	ata_bmdma_irq_clear(ap);
+	ap->ops->sff_check_status(ap);
+	ata_sff_irq_clear(ap);
@@ -693 +658 @@
-		ata_std_ports(ioaddr);
+		ata_sff_std_ports(ioaddr);
--- ./projects/linux/linux-2.6.27/drivers/ata/sata_sil.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/ata/sata_sil.c	2008-12-25 00:26:37.000000000 +0100
@@ -118,2 +118,2 @@
-static int sil_scr_read(struct ata_port *ap, unsigned int sc_reg, u32 *val);
-static int sil_scr_write(struct ata_port *ap, unsigned int sc_reg, u32 val);
+static int sil_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val);
+static int sil_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val);
@@ -320 +320 @@
-static int sil_scr_read(struct ata_port *ap, unsigned int sc_reg, u32 *val)
+static int sil_scr_read(struct ata_link *link, unsigned int sc_reg, u32 *val)
@@ -322 +322 @@
-	void __iomem *mmio = sil_scr_addr(ap, sc_reg);
+	void __iomem *mmio = sil_scr_addr(link->ap, sc_reg);
@@ -331 +331 @@
-static int sil_scr_write(struct ata_port *ap, unsigned int sc_reg, u32 val)
+static int sil_scr_write(struct ata_link *link, unsigned int sc_reg, u32 val)
@@ -333 +333 @@
-	void __iomem *mmio = sil_scr_addr(ap, sc_reg);
+	void __iomem *mmio = sil_scr_addr(link->ap, sc_reg);
@@ -355,2 +355,2 @@
-		sil_scr_read(ap, SCR_ERROR, &serror);
-		sil_scr_write(ap, SCR_ERROR, serror);
+		sil_scr_read(&ap->link, SCR_ERROR, &serror);
+		sil_scr_write(&ap->link, SCR_ERROR, serror);
--- ./projects/linux/linux-2.6.28/drivers/ata/sata_sil.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/ata/sata_sil.c	2009-03-24 00:12:14.000000000 +0100
@@ -46,0 +47 @@
+#include <linux/dmi.h>
@@ -49 +50,3 @@
-#define DRV_VERSION	"2.3"
+#define DRV_VERSION	"2.4"
+
+#define SIL_DMA_BOUNDARY	0x7fffffffUL
@@ -120,0 +124,4 @@
+static void sil_qc_prep(struct ata_queued_cmd *qc);
+static void sil_bmdma_setup(struct ata_queued_cmd *qc);
+static void sil_bmdma_start(struct ata_queued_cmd *qc);
+static void sil_bmdma_stop(struct ata_queued_cmd *qc);
@@ -170 +177,6 @@
-	ATA_BMDMA_SHT(DRV_NAME),
+	ATA_BASE_SHT(DRV_NAME),
+	/** These controllers support Large Block Transfer which allows
+	    transfer chunks up to 2GB and which cross 64KB boundaries,
+	    therefore the DMA limits are more relaxed than standard ATA SFF. */
+	.dma_boundary		= SIL_DMA_BOUNDARY,
+	.sg_tablesize		= ATA_MAX_PRD
@@ -176,0 +189,4 @@
+	.bmdma_setup            = sil_bmdma_setup,
+	.bmdma_start            = sil_bmdma_start,
+	.bmdma_stop		= sil_bmdma_stop,
+	.qc_prep		= sil_qc_prep,
@@ -251,0 +268,77 @@
+static void sil_bmdma_stop(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	void __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];
+	void __iomem *bmdma2 = mmio_base + sil_port[ap->port_no].bmdma2;
+
+	/* clear start/stop bit - can safely always write 0 */
+	iowrite8(0, bmdma2);
+
+	/* one-PIO-cycle guaranteed wait, per spec, for HDMA1:0 transition */
+	ata_sff_dma_pause(ap);
+}
+
+static void sil_bmdma_setup(struct ata_queued_cmd *qc)
+{
+	struct ata_port *ap = qc->ap;
+	void __iomem *bmdma = ap->ioaddr.bmdma_addr;
+
+	/* load PRD table addr. */
+	iowrite32(ap->prd_dma, bmdma + ATA_DMA_TABLE_OFS);
+
+	/* issue r/w command */
+	ap->ops->sff_exec_command(ap, &qc->tf);
+}
+
+static void sil_bmdma_start(struct ata_queued_cmd *qc)
+{
+	unsigned int rw = (qc->tf.flags & ATA_TFLAG_WRITE);
+	struct ata_port *ap = qc->ap;
+	void __iomem *mmio_base = ap->host->iomap[SIL_MMIO_BAR];
+	void __iomem *bmdma2 = mmio_base + sil_port[ap->port_no].bmdma2;
+	u8 dmactl = ATA_DMA_START;
+
+	/* set transfer direction, start host DMA transaction
+	   Note: For Large Block Transfer to work, the DMA must be started
+	   using the bmdma2 register. */
+	if (!rw)
+		dmactl |= ATA_DMA_WR;
+	iowrite8(dmactl, bmdma2);
+}
+
+/* The way God intended PCI IDE scatter/gather lists to look and behave... */
+static void sil_fill_sg(struct ata_queued_cmd *qc)
+{
+	struct scatterlist *sg;
+	struct ata_port *ap = qc->ap;
+	struct ata_prd *prd, *last_prd = NULL;
+	unsigned int si;
+
+	prd = &ap->prd[0];
+	for_each_sg(qc->sg, sg, qc->n_elem, si) {
+		/* Note h/w doesn't support 64-bit, so we unconditionally
+		 * truncate dma_addr_t to u32.
+		 */
+		u32 addr = (u32) sg_dma_address(sg);
+		u32 sg_len = sg_dma_len(sg);
+
+		prd->addr = cpu_to_le32(addr);
+		prd->flags_len = cpu_to_le32(sg_len);
+		VPRINTK("PRD[%u] = (0x%X, 0x%X)\n", si, addr, sg_len);
+
+		last_prd = prd;
+		prd++;
+	}
+
+	if (likely(last_prd))
+		last_prd->flags_len |= cpu_to_le32(ATA_PRD_EOT);
+}
+
+static void sil_qc_prep(struct ata_queued_cmd *qc)
+{
+	if (!(qc->flags & ATA_QCFLAG_DMAMAP))
+		return;
+
+	sil_fill_sg(qc);
+}
+
@@ -281 +374 @@
-	ata_link_for_each_dev(dev, link) {
+	ata_for_each_dev(dev, link, ALL) {
@@ -605,0 +699,26 @@
+static bool sil_broken_system_poweroff(struct pci_dev *pdev)
+{
+	static const struct dmi_system_id broken_systems[] = {
+		{
+			.ident = "HP Compaq nx6325",
+			.matches = {
+				DMI_MATCH(DMI_SYS_VENDOR, "Hewlett-Packard"),
+				DMI_MATCH(DMI_PRODUCT_NAME, "HP Compaq nx6325"),
+			},
+			/* PCI slot number of the controller */
+			.driver_data = (void *)0x12UL,
+		},
+
+		{ }	/* terminate list */
+	};
+	const struct dmi_system_id *dmi = dmi_first_match(broken_systems);
+
+	if (dmi) {
+		unsigned long slot = (unsigned long)dmi->driver_data;
+		/* apply the quirk only to on-board controllers */
+		return slot == PCI_SLOT(pdev->devfn);
+	}
+
+	return false;
+}
+
@@ -610 +729,2 @@
-	const struct ata_port_info *ppi[] = { &sil_port_info[board_id], NULL };
+	struct ata_port_info pi = sil_port_info[board_id];
+	const struct ata_port_info *ppi[] = { &pi, NULL };
@@ -623,0 +744,7 @@
+	if (sil_broken_system_poweroff(pdev)) {
+		pi.flags |= ATA_FLAG_NO_POWEROFF_SPINDOWN |
+					ATA_FLAG_NO_HIBERNATE_SPINDOWN;
+		dev_info(&pdev->dev, "quirky BIOS, skipping spindown "
+				"on poweroff and hibernation\n");
+	}
+
--- ./projects/linux/linux-2.6.29/drivers/ata/sata_sil.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/ata/sata_sil.c	2009-06-27 11:32:32.000000000 +0200
@@ -203,2 +203,2 @@
-		.pio_mask	= 0x1f,			/* pio0-4 */
-		.mwdma_mask	= 0x07,			/* mwdma0-2 */
+		.pio_mask	= ATA_PIO4,
+		.mwdma_mask	= ATA_MWDMA2,
@@ -212,2 +212,2 @@
-		.pio_mask	= 0x1f,			/* pio0-4 */
-		.mwdma_mask	= 0x07,			/* mwdma0-2 */
+		.pio_mask	= ATA_PIO4,
+		.mwdma_mask	= ATA_MWDMA2,
@@ -220,2 +220,2 @@
-		.pio_mask	= 0x1f,			/* pio0-4 */
-		.mwdma_mask	= 0x07,			/* mwdma0-2 */
+		.pio_mask	= ATA_PIO4,
+		.mwdma_mask	= ATA_MWDMA2,
@@ -228,2 +228,2 @@
-		.pio_mask	= 0x1f,			/* pio0-4 */
-		.mwdma_mask	= 0x07,			/* mwdma0-2 */
+		.pio_mask	= ATA_PIO4,
+		.mwdma_mask	= ATA_MWDMA2,
--- ./projects/linux/linux-2.6.13/drivers/atm/iphase.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/atm/iphase.c	2005-10-28 02:02:08.000000000 +0200
@@ -82 +82 @@
-static struct timer_list ia_timer = TIMER_INITIALIZER(ia_led_timer, 0, 0);
+static DEFINE_TIMER(ia_timer, ia_led_timer, 0, 0);
--- ./projects/linux/linux-2.6.17/drivers/atm/iphase.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/atm/iphase.c	2006-09-20 05:42:06.000000000 +0200
@@ -2287 +2287 @@
-static int __init ia_init(struct atm_dev *dev)
+static int __devinit ia_init(struct atm_dev *dev)
@@ -2483 +2483 @@
-static int __init ia_start(struct atm_dev *dev)
+static int __devinit ia_start(struct atm_dev *dev)
@@ -2491 +2491 @@
-        if (request_irq(iadev->irq, &ia_int, SA_SHIRQ, DEV_LABEL, dev)) {  
+        if (request_irq(iadev->irq, &ia_int, IRQF_SHARED, DEV_LABEL, dev)) {
--- ./projects/linux/linux-2.6.18/drivers/atm/iphase.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/atm/iphase.c	2006-11-29 22:57:37.000000000 +0100
@@ -2198 +2198 @@
-static irqreturn_t ia_int(int irq, void *dev_id, struct pt_regs *regs)  
+static irqreturn_t ia_int(int irq, void *dev_id)  
--- ./projects/linux/linux-2.6.19/drivers/atm/iphase.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/atm/iphase.c	2007-02-04 19:44:54.000000000 +0100
@@ -308 +308 @@
-**    R = reserverd (written as 0)
+**    R = reserved (written as 0)
--- ./projects/linux/linux-2.6.22/drivers/atm/iphase.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/atm/iphase.c	2007-10-09 22:31:38.000000000 +0200
@@ -1604,3 +1604,3 @@
-	iadev->rx_open = kmalloc(4*iadev->num_vc,GFP_KERNEL);
-	if (!iadev->rx_open)  
-	{  
+
+	iadev->rx_open = kzalloc(4 * iadev->num_vc, GFP_KERNEL);
+	if (!iadev->rx_open) {
@@ -1611 +1611 @@
-	memset(iadev->rx_open, 0, 4*iadev->num_vc);  
+
@@ -2293 +2292,0 @@
-	unsigned char revision;  
@@ -2308,4 +2307,2 @@
-	if ((error = pci_read_config_word(iadev->pci, PCI_COMMAND,&command))   
-		    || (error = pci_read_config_byte(iadev->pci,   
-				PCI_REVISION_ID,&revision)))   
-	{  
+	error = pci_read_config_word(iadev->pci, PCI_COMMAND, &command);
+	if (error) {
@@ -2317 +2314 @@
-			dev->number, revision, real_base, iadev->irq);)  
+			dev->number, iadev->pci->revision, real_base, iadev->irq);)
@@ -2356 +2353 @@
-			dev->number, revision, base, iadev->irq);)  
+			dev->number, iadev->pci->revision, base, iadev->irq);)
@@ -3177 +3174 @@
-	iadev = kmalloc(sizeof(*iadev), GFP_KERNEL); 
+	iadev = kzalloc(sizeof(*iadev), GFP_KERNEL);
@@ -3182 +3179 @@
-	memset(iadev, 0, sizeof(*iadev));
+
--- ./projects/linux/linux-2.6.24/drivers/atm/iphase.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/atm/iphase.c	2008-04-17 04:49:44.000000000 +0200
@@ -960,0 +961 @@
+#ifdef CONFIG_ATM_IA_DEBUG
@@ -994,0 +996 @@
+#endif /* CONFIG_ATM_IA_DEBUG */
--- ./projects/linux/linux-2.6.25/drivers/atm/iphase.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/atm/iphase.c	2008-07-13 23:51:29.000000000 +0200
@@ -63 +63,2 @@
-#include <linux/vmalloc.h>  
+#include <linux/vmalloc.h>
+#include <linux/jiffies.h>
@@ -192 +193 @@
-  if(((jiffies - timer)>50)||((dev->ffL.tcq_rd==dev->host_tcq_wr))){      
+  if((time_after(jiffies,timer+50)) || ((dev->ffL.tcq_rd==dev->host_tcq_wr))) {
@@ -1228 +1229 @@
-     else if (((jiffies - iadev->rx_tmp_jif) > 50) && 
+     else if ((time_after(jiffies, iadev->rx_tmp_jif + 50)) &&
@@ -2564,11 +2565,5 @@
-		/* 
-		 * Enable interrupt on loss of signal
-		 * SUNI_RSOP_CIE - 0x10
-		 * SUNI_RSOP_CIE_LOSE - 0x04
-		 */
-		ia_phy_put(dev, ia_phy_get(dev, 0x10) | 0x04, 0x10);
-#ifndef MODULE
-		error = dev->phy->start(dev);
-		if (error)
-			goto err_free_rx;
-#endif
+		if (dev->phy->start) {
+			error = dev->phy->start(dev);
+			if (error)
+				goto err_free_rx;
+		}
@@ -3199,0 +3195,2 @@
+	pci_set_drvdata(pdev, dev);
+
@@ -3221,2 +3217,0 @@
-	pci_set_drvdata(pdev, dev);
-
@@ -3240 +3235,3 @@
-	ia_phy_put(dev, ia_phy_get(dev,0x10) & ~(0x4), 0x10); 
+	/* Disable phy interrupts */
+	ia_phy_put(dev, ia_phy_get(dev, SUNI_RSOP_CIE) & ~(SUNI_RSOP_CIE_LOSE),
+				   SUNI_RSOP_CIE);
@@ -3242,0 +3240,3 @@
+	if (dev->phy && dev->phy->stop)
+		dev->phy->stop(dev);
+
--- ./projects/linux/linux-2.6.26/drivers/atm/iphase.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/atm/iphase.c	2008-10-10 00:13:53.000000000 +0200
@@ -68,6 +68 @@
-struct suni_priv {
-        struct k_sonet_stats sonet_stats; /* link diagnostics */
-        unsigned char loop_mode;        /* loopback mode */
-        struct atm_dev *dev;            /* device back-pointer */
-        struct suni_priv *next;         /* next SUNI */
-}; 
+
@@ -97,4 +91,0 @@
-#if BITS_PER_LONG != 32
-#  error FIXME: this driver only works on 32-bit platforms
-#endif
-
@@ -168,2 +159,2 @@
-        IF_EVENT(printk("ia_hack: return_q skb = 0x%x desc = %d\n", 
-                                   (u32)dev->desc_tbl[desc1 -1].txskb, desc1);)
+        IF_EVENT(printk("ia_hack: return_q skb = 0x%p desc = %d\n",
+                                   dev->desc_tbl[desc1 -1].txskb, desc1);)
@@ -539,2 +530,2 @@
-      IF_CBR(printk("CBR Testslot 0x%x AT Location 0x%x, NumToAssign=%d\n",
-                                testSlot, (u32)TstSchedTbl,toBeAssigned);) 
+      IF_CBR(printk("CBR Testslot 0x%x AT Location 0x%p, NumToAssign=%d\n",
+                                testSlot, TstSchedTbl,toBeAssigned);)
@@ -548,2 +539,2 @@
-             IF_CBR(printk("Testslot Wrap. STable Start=0x%x,Testslot=%d\n",
-                                                       (u32)SchedTbl,testSlot);)
+             IF_CBR(printk("Testslot Wrap. STable Start=0x%p,Testslot=%d\n",
+                                                       SchedTbl,testSlot);)
@@ -564,2 +555,2 @@
-          IF_CBR(printk("Reading CBR Tbl from 0x%x, CbrVal=0x%x Iteration %d\n",
-                          (u32)TstSchedTbl,cbrVC,inc);) 
+          IF_CBR(printk("Reading CBR Tbl from 0x%p, CbrVal=0x%x Iteration %d\n",
+                          TstSchedTbl,cbrVC,inc);)
@@ -1414 +1404,0 @@
-        u16 *ptr16;
@@ -1429 +1419 @@
-	iadev->rx_dle_q.start = (struct dle*)dle_addr;  
+	iadev->rx_dle_q.start = (struct dle *)dle_addr;
@@ -1432 +1422 @@
-	iadev->rx_dle_q.end = (struct dle*)((u32)dle_addr+sizeof(struct dle)*DLE_ENTRIES);  
+	iadev->rx_dle_q.end = (struct dle*)((unsigned long)dle_addr+sizeof(struct dle)*DLE_ENTRIES);
@@ -1436,0 +1427 @@
+	/* We know this is 32bit bus addressed so the following is safe */
@@ -1439,2 +1430,2 @@
-	IF_INIT(printk("Tx Dle list addr: 0x%08x value: 0x%0x\n", 
-                      (u32)(iadev->dma+IPHASE5575_TX_LIST_ADDR), 
+	IF_INIT(printk("Tx Dle list addr: 0x%p value: 0x%0x\n",
+                      iadev->dma+IPHASE5575_TX_LIST_ADDR,
@@ -1442,2 +1433,2 @@
-	printk("Rx Dle list addr: 0x%08x value: 0x%0x\n", 
-                      (u32)(iadev->dma+IPHASE5575_RX_LIST_ADDR), 
+	printk("Rx Dle list addr: 0x%p value: 0x%0x\n",
+                      iadev->dma+IPHASE5575_RX_LIST_ADDR,
@@ -1482 +1473 @@
-	IF_INIT(printk("Rx Buffer desc ptr: 0x%0x\n", (u32)(buf_desc_ptr));)  
+	IF_INIT(printk("Rx Buffer desc ptr: 0x%p\n", buf_desc_ptr);)
@@ -1499 +1490 @@
-	IF_INIT(printk("freeq_start: 0x%0x\n", (u32)freeq_start);)  
+	IF_INIT(printk("freeq_start: 0x%p\n", freeq_start);)
@@ -1590,4 +1581,4 @@
-        ptr16 = (u16*)j;
-        i = ((u32)ptr16 >> 6) & 0xff;
-	ptr16  += j - 1;
-	i |=(((u32)ptr16 << 2) & 0xff00);
+
+        i = (j >> 6) & 0xFF;
+        j += 2 * (j - 1);
+        i |= ((j << 2) & 0xFF00);
@@ -1594,0 +1586 @@
+
@@ -1724 +1716 @@
-            IF_EVENT(printk("tx_dle_intr: enque skb = 0x%x \n", (u32)skb);)
+            IF_EVENT(printk("tx_dle_intr: enque skb = 0x%p \n", skb);)
@@ -1917 +1909 @@
-	iadev->tx_dle_q.end = (struct dle*)((u32)dle_addr+sizeof(struct dle)*DLE_ENTRIES);  
+	iadev->tx_dle_q.end = (struct dle*)((unsigned long)dle_addr+sizeof(struct dle)*DLE_ENTRIES);
@@ -2055,2 +2047,2 @@
-        IF_INIT(printk("iadev->seg_reg = 0x%x CBR_PTR_BASE = 0x%x\n",
-               (u32)iadev->seg_reg, readw(iadev->seg_reg+CBR_PTR_BASE));)
+        IF_INIT(printk("iadev->seg_reg = 0x%p CBR_PTR_BASE = 0x%x\n",
+               iadev->seg_reg, readw(iadev->seg_reg+CBR_PTR_BASE));)
@@ -2910 +2902 @@
-        if ((u32)skb->data & 3) {
+        if ((unsigned long)skb->data & 3) {
@@ -2974,2 +2966,2 @@
-        IF_TX(printk("Sent: skb = 0x%x skb->data: 0x%x len: %d, desc: %d\n",
-                  (u32)skb, (u32)skb->data, skb->len, desc);)
+        IF_TX(printk("Sent: skb = 0x%p skb->data: 0x%p len: %d, desc: %d\n",
+                  skb, skb->data, skb->len, desc);)
@@ -3192 +3184 @@
-	IF_INIT(printk("dev_id = 0x%x iadev->LineRate = %d \n", (u32)dev,
+	IF_INIT(printk("dev_id = 0x%p iadev->LineRate = %d \n", dev,
--- ./projects/linux/linux-2.6.28/drivers/atm/iphase.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/atm/iphase.c	2009-03-24 00:12:14.000000000 +0100
@@ -67 +67 @@
-#define swap(x) (((x & 0xff) << 8) | ((x & 0xff00) >> 8))  
+#define swap_byte_order(x) (((x & 0xff) << 8) | ((x & 0xff00) >> 8))
@@ -1309 +1309 @@
-          length =  swap(trailer->length);
+	  length = swap_byte_order(trailer->length);
@@ -2998 +2998 @@
-	/* wr_ptr->bytes = swap(total_len);	didn't seem to affect ?? */  
+	/* wr_ptr->bytes = swap_byte_order(total_len); didn't seem to affect?? */
--- ./projects/linux/linux-2.6.29/drivers/atm/iphase.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/atm/iphase.c	2009-06-27 11:32:32.000000000 +0200
@@ -980,3 +980 @@
-        sprintf( pBuf, "\n" );
-        // SPrint(prntBuf);
-        printk(prntBuf);
+        printk("%s\n", prntBuf);
--- ./projects/linux/linux-2.6.13/drivers/block/ataflop.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/block/ataflop.c	2005-10-28 02:02:08.000000000 +0200
@@ -374,10 +374,4 @@
-static struct timer_list motor_off_timer =
-	TIMER_INITIALIZER(fd_motor_off_timer, 0, 0);
-static struct timer_list readtrack_timer =
-	TIMER_INITIALIZER(fd_readtrack_check, 0, 0);
-
-static struct timer_list timeout_timer =
-	TIMER_INITIALIZER(fd_times_out, 0, 0);
-
-static struct timer_list fd_timer =
-	TIMER_INITIALIZER(check_change, 0, 0);
+static DEFINE_TIMER(motor_off_timer, fd_motor_off_timer, 0, 0);
+static DEFINE_TIMER(readtrack_timer, fd_readtrack_check, 0, 0);
+static DEFINE_TIMER(timeout_timer, fd_times_out, 0, 0);
+static DEFINE_TIMER(fd_timer, check_change, 0, 0);
--- ./projects/linux/linux-2.6.15/drivers/block/ataflop.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/block/ataflop.c	2006-03-20 06:53:29.000000000 +0100
@@ -184 +184 @@
-#define NUM_DISK_MINORS (sizeof(minor2disktype)/sizeof(*minor2disktype))
+#define NUM_DISK_MINORS ARRAY_SIZE(minor2disktype)
@@ -1364 +1364 @@
-			UDT = 0;
+			UDT = NULL;
@@ -1497,0 +1498 @@
+	void __user *argp = (void __user *)param;
@@ -1524 +1525 @@
-		if (copy_to_user((void *)param, &getprm, sizeof(getprm)))
+		if (copy_to_user(argp, &getprm, sizeof(getprm)))
@@ -1543 +1544 @@
-		if (copy_from_user(&setprm, (void *) param, sizeof(setprm)))
+		if (copy_from_user(&setprm, argp, sizeof(setprm)))
@@ -1650 +1651 @@
-		if (copy_from_user(&fmt_desc, (void *) param, sizeof(fmt_desc)))
+		if (copy_from_user(&fmt_desc, argp, sizeof(fmt_desc)))
@@ -1953,2 +1954,2 @@
-
-void __init atari_floppy_setup( char *str, int *ints )
+#ifndef MODULE
+static int __init atari_floppy_setup(char *str)
@@ -1955,0 +1957 @@
+	int ints[3 + FD_MAX_UNITS];
@@ -1956,0 +1959,5 @@
+
+	if (!MACH_IS_ATARI)
+		return 0;
+
+	str = get_options(str, 3 + FD_MAX_UNITS, ints);
@@ -1960 +1967 @@
-		return;
+		return 0;
@@ -1979,0 +1987 @@
+	return 1;
@@ -1982 +1990,4 @@
-static void atari_floppy_exit(void)
+__setup("floppy=", atari_floppy_setup);
+#endif
+
+static void __exit atari_floppy_exit(void)
--- ./projects/linux/linux-2.6.16/drivers/block/ataflop.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/block/ataflop.c	2006-06-18 03:49:35.000000000 +0200
@@ -274 +274 @@
-MODULE_PARM(UseTrackbuffer, "i");
+module_param(UseTrackbuffer, int, 0);
@@ -299 +299 @@
-MODULE_PARM(UserSteprate, "1-" __MODULE_STRING(FD_MAX_UNITS) "i");
+module_param_array(UserSteprate, int, NULL, 0);
--- ./projects/linux/linux-2.6.18/drivers/block/ataflop.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/block/ataflop.c	2006-11-29 22:57:37.000000000 +0100
@@ -345 +345 @@
-static irqreturn_t floppy_irq (int irq, void *dummy, struct pt_regs *fp);
+static irqreturn_t floppy_irq (int irq, void *dummy);
@@ -576 +576 @@
-static irqreturn_t floppy_irq (int irq, void *dummy, struct pt_regs *fp)
+static irqreturn_t floppy_irq (int irq, void *dummy)
--- ./projects/linux/linux-2.6.22/drivers/block/ataflop.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/block/ataflop.c	2007-10-09 22:31:38.000000000 +0200
@@ -1469 +1469 @@
-void do_fd_request(request_queue_t * q)
+void do_fd_request(struct request_queue * q)
--- ./projects/linux/linux-2.6.24/drivers/block/ataflop.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/block/ataflop.c	2008-04-17 04:49:44.000000000 +0200
@@ -93 +93 @@
-} disk_type[] = {
+} atari_disk_type[] = {
@@ -661 +661 @@
-		UDT = &disk_type[type];
+		UDT = &atari_disk_type[type];
@@ -1067 +1067 @@
-			if (SUDT > disk_type) {
+			if (SUDT > atari_disk_type) {
@@ -1085 +1085 @@
-				SUDT = disk_type + StartDiskType[DriveType];
+				SUDT = atari_disk_type + StartDiskType[DriveType];
@@ -1424 +1424 @@
-			UDT = disk_type + StartDiskType[DriveType];
+			UDT = atari_disk_type + StartDiskType[DriveType];
@@ -1442 +1442 @@
-		UDT = &disk_type[type];
+		UDT = &atari_disk_type[type];
@@ -1508 +1508 @@
-			dtp = &disk_type[type];
+			dtp = &atari_disk_type[type];
@@ -1579 +1579 @@
-			dtp = &disk_type[setidx];
+			dtp = &atari_disk_type[setidx];
--- ./projects/linux/linux-2.6.26/drivers/block/ataflop.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/block/ataflop.c	2008-10-10 00:13:53.000000000 +0200
@@ -1883 +1883 @@
-		return -ENXIO;
+		return -ENODEV;
@@ -1887 +1887 @@
-		return -ENXIO;
+		return -ENODEV;
--- ./projects/linux/linux-2.6.27/drivers/block/ataflop.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/block/ataflop.c	2008-12-25 00:26:37.000000000 +0100
@@ -364 +364 @@
-static int fd_ioctl( struct inode *inode, struct file *filp, unsigned int
+static int fd_ioctl(struct block_device *bdev, fmode_t mode, unsigned int
@@ -369,2 +369,2 @@
-static int floppy_open( struct inode *inode, struct file *filp );
-static int floppy_release( struct inode * inode, struct file * filp );
+static int floppy_open(struct block_device *bdev, fmode_t mode);
+static int floppy_release(struct gendisk *disk, fmode_t mode);
@@ -1486 +1486 @@
-static int fd_ioctl(struct inode *inode, struct file *filp,
+static int fd_ioctl(struct block_device *bdev, fmode_t mode,
@@ -1489 +1489 @@
-	struct gendisk *disk = inode->i_bdev->bd_disk;
+	struct gendisk *disk = bdev->bd_disk;
@@ -1664 +1664 @@
-		check_disk_change(inode->i_bdev);
+		check_disk_change(bdev);
@@ -1807 +1807 @@
-static int floppy_open( struct inode *inode, struct file *filp )
+static int floppy_open(struct block_device *bdev, fmode_t mode)
@@ -1809,2 +1809,2 @@
-	struct atari_floppy_struct *p = inode->i_bdev->bd_disk->private_data;
-	int type  = iminor(inode) >> 2;
+	struct atari_floppy_struct *p = bdev->bd_disk->private_data;
+	int type  = MINOR(bdev->bd_dev) >> 2;
@@ -1816 +1816 @@
-	if (p->ref == -1 || (p->ref && filp->f_flags & O_EXCL))
+	if (p->ref == -1 || (p->ref && mode & FMODE_EXCL))
@@ -1819 +1819 @@
-	if (filp->f_flags & O_EXCL)
+	if (mode & FMODE_EXCL)
@@ -1826 +1826 @@
-	if (filp->f_flags & O_NDELAY)
+	if (mode & FMODE_NDELAY)
@@ -1829,3 +1829,3 @@
-	if (filp->f_mode & 3) {
-		check_disk_change(inode->i_bdev);
-		if (filp->f_mode & 2) {
+	if (mode & (FMODE_READ|FMODE_WRITE)) {
+		check_disk_change(bdev);
+		if (mode & FMODE_WRITE) {
@@ -1837 +1836,0 @@
-				floppy_release(inode, filp);
@@ -1846 +1845 @@
-static int floppy_release( struct inode * inode, struct file * filp )
+static int floppy_release(struct gendisk *disk, fmode_t mode)
@@ -1848 +1847 @@
-	struct atari_floppy_struct *p = inode->i_bdev->bd_disk->private_data;
+	struct atari_floppy_struct *p = disk->private_data;
@@ -1862 +1861 @@
-	.ioctl		= fd_ioctl,
+	.locked_ioctl	= fd_ioctl,
@@ -1885,4 +1883,0 @@
-	if (MACH_IS_HADES)
-		/* Hades doesn't have Atari-compatible floppy */
-		return -ENODEV;
-
--- ./projects/linux/linux-2.6.28/drivers/block/ataflop.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/block/ataflop.c	2009-03-24 00:12:14.000000000 +0100
@@ -1733 +1733 @@
-		if (!(mfp.par_dt_reg & 0x20))
+		if (!(st_mfp.par_dt_reg & 0x20))
@@ -1750 +1750 @@
-		while( mfp.par_dt_reg & 0x20 )
+		while( st_mfp.par_dt_reg & 0x20 )
--- ./projects/linux/linux-2.6.13/drivers/char/cyclades.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/char/cyclades.c	2005-10-28 02:02:08.000000000 +0200
@@ -868 +868 @@
-static struct timer_list cyz_timerlist = TIMER_INITIALIZER(cyz_poll, 0, 0);
+static DEFINE_TIMER(cyz_timerlist, cyz_poll, 0, 0);
--- ./projects/linux/linux-2.6.14/drivers/char/cyclades.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/char/cyclades.c	2006-01-03 04:21:10.000000000 +0100
@@ -284 +284 @@
- * fix race condition in -Z buffer management; only -Y needs to explictly
+ * fix race condition in -Z buffer management; only -Y needs to explicitly
--- ./projects/linux/linux-2.6.15/drivers/char/cyclades.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/cyclades.c	2006-03-20 06:53:29.000000000 +0100
@@ -643,0 +644 @@
+#include <linux/tty_flip.h>
@@ -726 +727 @@
-#define NR_ISA_ADDRS (sizeof(cy_isa_addresses)/sizeof(unsigned char*))
+#define NR_ISA_ADDRS ARRAY_SIZE(cy_isa_addresses)
@@ -1089 +1090 @@
-
+  int len;
@@ -1166,2 +1167 @@
-                            if (tty->flip.count < TTY_FLIPBUF_SIZE){
-                                tty->flip.count++;
+                            if (tty_buffer_request_room(tty, 1)) {
@@ -1170,4 +1170 @@
-                                        *tty->flip.flag_buf_ptr++ =
-	    						    TTY_BREAK;
-                                        *tty->flip.char_buf_ptr++ =
-					  cy_readb(base_addr+(CyRDSR<<index));
+                                        tty_insert_flip_char(tty, cy_readb(base_addr+(CyRDSR<<index)), TTY_BREAK);
@@ -1179,4 +1176 @@
-                                        *tty->flip.flag_buf_ptr++ =
-							    TTY_FRAME;
-                                        *tty->flip.char_buf_ptr++ =
-					  cy_readb(base_addr+(CyRDSR<<index));
+                                        tty_insert_flip_char(tty, cy_readb(base_addr+(CyRDSR<<index)), TTY_FRAME);
@@ -1186,4 +1180,2 @@
-                                        *tty->flip.flag_buf_ptr++ =
-							    TTY_PARITY;
-                                        *tty->flip.char_buf_ptr++ =
-					  cy_readb(base_addr+(CyRDSR<<index));
+					/* Pieces of seven... */
+                                        tty_insert_flip_char(tty, cy_readb(base_addr+(CyRDSR<<index)), TTY_PARITY);
@@ -1193,3 +1185 @@
-                                        *tty->flip.flag_buf_ptr++ =
-							    TTY_OVERRUN;
-                                        *tty->flip.char_buf_ptr++ = 0;
+                                        tty_insert_flip_char(tty, 0, TTY_OVERRUN);
@@ -1201,9 +1191,2 @@
-                                        if(tty->flip.count
-					           < TTY_FLIPBUF_SIZE){
-                                            tty->flip.count++;
-                                            *tty->flip.flag_buf_ptr++ =
-							     TTY_NORMAL;
-                                           *tty->flip.char_buf_ptr++ =
-					    cy_readb(base_addr+(CyRDSR<<index));
-					    info->icount.rx++;
-                                        }
+                                        tty_insert_flip_char(tty, cy_readb(base_addr+(CyRDSR<<index)), TTY_FRAME);
+				        info->icount.rx++;
@@ -1215,4 +1198,3 @@
-                                    }else{
-                                        *tty->flip.flag_buf_ptr++ = 0;
-                                        *tty->flip.char_buf_ptr++ = 0;
-					info->icount.rx++;
+                                    }else {
+					tty_insert_flip_char(tty, 0, TTY_NORMAL);
+				        info->icount.rx++;
@@ -1221,2 +1203 @@
-                                    *tty->flip.flag_buf_ptr++ = 0;
-                                    *tty->flip.char_buf_ptr++ = 0;
+				    tty_insert_flip_char(tty, 0, TTY_NORMAL);
@@ -1243,5 +1224,2 @@
-                            while(char_count--){
-                                if (tty->flip.count >= TTY_FLIPBUF_SIZE){
-                                        break;
-                                }
-                                tty->flip.count++;
+			    len = tty_buffer_request_room(tty, char_count);
+                            while(len--){
@@ -1249,2 +1227 @@
-                                *tty->flip.flag_buf_ptr++ = TTY_NORMAL;
-                                *tty->flip.char_buf_ptr++ = data;
+				tty_insert_flip_char(tty, data, TTY_NORMAL);
@@ -1259 +1236 @@
-                        schedule_delayed_work(&tty->flip.work, 1);
+			tty_schedule_flip(tty);
@@ -1553,0 +1531 @@
+  int len;
@@ -1609,7 +1587,2 @@
-	    while(char_count--){
-		if (tty->flip.count >= N_TTY_BUF_SIZE - tty->read_cnt)
-                    break;
-
-		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
-		    break;
-
+	    len = tty_buffer_request_room(tty, char_count);
+	    while(len--){
@@ -1618,3 +1591 @@
-		tty->flip.count++;
-		*tty->flip.flag_buf_ptr++ = TTY_NORMAL;
-		*tty->flip.char_buf_ptr++ = data;
+		tty_insert_flip_char(tty, data, TTY_NORMAL);
@@ -1638 +1609 @@
-	    schedule_delayed_work(&tty->flip.work, 1);
+	    tty_schedule_flip(tty);
@@ -1766,3 +1737 @@
-		tty->flip.count++;
-		*tty->flip.flag_buf_ptr++ = TTY_PARITY;
-		*tty->flip.char_buf_ptr++ = 0;
+		tty_insert_flip_char(tty, 0, TTY_PARITY);
@@ -1773,3 +1742 @@
-		tty->flip.count++;
-		*tty->flip.flag_buf_ptr++ = TTY_FRAME;
-		*tty->flip.char_buf_ptr++ = 0;
+		tty_insert_flip_char(tty, 0, TTY_FRAME);
@@ -1780,3 +1747 @@
-		tty->flip.count++;
-		*tty->flip.flag_buf_ptr++ = TTY_BREAK;
-		*tty->flip.char_buf_ptr++ = 0;
+		tty_insert_flip_char(tty, 0, TTY_BREAK);
@@ -1847 +1812 @@
-	    schedule_delayed_work(&tty->flip.work, 1);
+	    tty_schedule_flip(tty);
--- ./projects/linux/linux-2.6.17/drivers/char/cyclades.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/cyclades.c	2006-09-20 05:42:06.000000000 +0200
@@ -636 +635,0 @@
-#include <linux/config.h>
@@ -2836,3 +2835,2 @@
-    if (!tty || !info->xmit_buf || !tmp_buf){
-        return 0;
-    }
+    if (!info->xmit_buf || !tmp_buf)
+	return 0;
@@ -2887 +2885 @@
-    if (!tty || !info->xmit_buf)
+    if (!info->xmit_buf)
@@ -4617 +4615 @@
-				   SA_INTERRUPT, "Cyclom-Y", &cy_card[j]))
+				   IRQF_DISABLED, "Cyclom-Y", &cy_card[j]))
@@ -4790 +4788 @@
-		        SA_SHIRQ, "Cyclom-Y", &cy_card[j]))
+		        IRQF_SHARED, "Cyclom-Y", &cy_card[j]))
@@ -4970 +4968 @@
-			SA_SHIRQ, "Cyclades-Z", &cy_card[j]))
+			IRQF_SHARED, "Cyclades-Z", &cy_card[j]))
@@ -5064 +5062 @@
-			SA_SHIRQ, "Cyclades-Z", &cy_card[j]))
+			IRQF_SHARED, "Cyclades-Z", &cy_card[j]))
@@ -5254 +5251,0 @@
-    cy_serial_driver->devfs_name = "tts/C";
--- ./projects/linux/linux-2.6.18/drivers/char/cyclades.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/cyclades.c	2006-11-29 22:57:37.000000000 +0100
@@ -751,12 +750,0 @@
- * tmp_buf is used as a temporary buffer by serial_write.  We need to
- * lock it in case the copy_from_user blocks while swapping in a page,
- * and some other program tries to do a serial write at the same time.
- * Since the lock will only come under contention when the system is
- * swapping and available memory is low, it makes sense to share one
- * buffer across all the serial ports, since it significantly saves
- * memory if large numbers of serial ports are open.  This buffer is
- * allocated when the first cy_open occurs.
- */
-static unsigned char *tmp_buf;
-
-/*
@@ -1072 +1060 @@
-cyy_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+cyy_interrupt(int irq, void *dev_id)
@@ -1817 +1805 @@
-cyz_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+cyz_interrupt(int irq, void *dev_id)
@@ -2469 +2456,0 @@
-  unsigned long page;
@@ -2548,9 +2534,0 @@
-    if (!tmp_buf) {
-	page = get_zeroed_page(GFP_KERNEL);
-	if (!page)
-	    return -ENOMEM;
-	if (tmp_buf)
-	    free_page(page);
-	else
-	    tmp_buf = (unsigned char *) page;
-    }
@@ -2835 +2813 @@
-    if (!info->xmit_buf || !tmp_buf)
+    if (!info->xmit_buf)
@@ -5208 +5186 @@
-static struct tty_operations cy_ops = {
+static const struct tty_operations cy_ops = {
@@ -5493,4 +5470,0 @@
-    if (tmp_buf) {
-	free_page((unsigned long) tmp_buf);
-	tmp_buf = NULL;
-    }
--- ./projects/linux/linux-2.6.19/drivers/char/cyclades.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/cyclades.c	2007-02-04 19:44:54.000000000 +0100
@@ -4,2 +3,0 @@
-static char rcsid[] =
-"$Revision: 2.3.2.20 $$Date: 2004/02/25 18:14:16 $";
@@ -595,0 +594,2 @@
+#define CY_VERSION	"2.4"
+
@@ -600 +600 @@
-#define NR_CARDS        4
+#define NR_CARDS	4
@@ -607 +607 @@
-#define NR_PORTS        256
+#define NR_PORTS	256
@@ -628 +628 @@
-#define PAUSE __asm__("nop");
+#define PAUSE __asm__("nop")
@@ -630 +630 @@
-#define PAUSE ;
+#define PAUSE do {} while (0)
@@ -666 +666 @@
-		
+
@@ -679,2 +679,2 @@
-static void cy_throttle (struct tty_struct *tty);
-static void cy_send_xchar (struct tty_struct *tty, char ch);
+static void cy_throttle(struct tty_struct *tty);
+static void cy_send_xchar(struct tty_struct *tty, char ch);
@@ -685,2 +685,2 @@
-    ((cy_readl(&((struct RUNTIME_9060 __iomem *) \
-		 ((card).ctl_addr))->init_ctrl) & (1<<17)) != 0)
+	((cy_readl(&((struct RUNTIME_9060 __iomem *) \
+		((card).ctl_addr))->init_ctrl) & (1<<17)) != 0)
@@ -701,2 +700,0 @@
-#define	JIFFIES_DIFF(n, j)	((j) - (n))
-
@@ -716,9 +714,9 @@
-        0xD0000,
-        0xD2000,
-        0xD4000,
-        0xD6000,
-        0xD8000,
-        0xDA000,
-        0xDC000,
-        0xDE000,
-        0,0,0,0,0,0,0,0
+	0xD0000,
+	0xD2000,
+	0xD4000,
+	0xD6000,
+	0xD8000,
+	0xDA000,
+	0xDC000,
+	0xDE000,
+	0, 0, 0, 0, 0, 0, 0, 0
@@ -725,0 +724 @@
+
@@ -730 +729 @@
-static int irq[NR_CARDS]  = { 0, };
+static int irq[NR_CARDS] = { 0, };
@@ -736 +735 @@
-#endif /* CONFIG_ISA */
+#endif				/* CONFIG_ISA */
@@ -748 +747 @@
-static int cy_next_channel; /* next minor available */
+static int cy_next_channel;	/* next minor available */
@@ -760,30 +759,36 @@
-       0,    50,    75,   110,   134,   150,   200,   300,   600,  1200,
-    1800,  2400,  4800,  9600, 19200, 38400, 57600, 76800,115200,150000,
-  230400,     0};
-
-static char baud_co_25[] = {  /* 25 MHz clock option table */
-    /* value =>    00    01   02    03    04 */
-    /* divide by    8    32   128   512  2048 */
-    0x00,  0x04,  0x04,  0x04,  0x04,  0x04,  0x03,  0x03,  0x03,  0x02,
-    0x02,  0x02,  0x01,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00};
-
-static char baud_bpr_25[] = {  /* 25 MHz baud rate period table */
-    0x00,  0xf5,  0xa3,  0x6f,  0x5c,  0x51,  0xf5,  0xa3,  0x51,  0xa3,
-    0x6d,  0x51,  0xa3,  0x51,  0xa3,  0x51,  0x36,  0x29,  0x1b,  0x15};
-
-static char baud_co_60[] = {  /* 60 MHz clock option table (CD1400 J) */
-    /* value =>    00    01   02    03    04 */
-    /* divide by    8    32   128   512  2048 */
-    0x00,  0x00,  0x00,  0x04,  0x04,  0x04,  0x04,  0x04,  0x03,  0x03,
-    0x03,  0x02,  0x02,  0x01,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,
-    0x00};
-
-static char baud_bpr_60[] = {  /* 60 MHz baud rate period table (CD1400 J) */
-    0x00,  0x82,  0x21,  0xff,  0xdb,  0xc3,  0x92,  0x62,  0xc3,  0x62,
-    0x41,  0xc3,  0x62,  0xc3,  0x62,  0xc3,  0x82,  0x62,  0x41,  0x32,
-    0x21};
-
-static char baud_cor3[] = {  /* receive threshold */
-    0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,
-    0x0a,  0x0a,  0x0a,  0x09,  0x09,  0x08,  0x08,  0x08,  0x08,  0x07,
-    0x07};
+	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200,
+	1800, 2400, 4800, 9600, 19200, 38400, 57600, 76800, 115200, 150000,
+	230400, 0
+};
+
+static char baud_co_25[] = {	/* 25 MHz clock option table */
+	/* value =>    00    01   02    03    04 */
+	/* divide by    8    32   128   512  2048 */
+	0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x02,
+	0x02, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+static char baud_bpr_25[] = {	/* 25 MHz baud rate period table */
+	0x00, 0xf5, 0xa3, 0x6f, 0x5c, 0x51, 0xf5, 0xa3, 0x51, 0xa3,
+	0x6d, 0x51, 0xa3, 0x51, 0xa3, 0x51, 0x36, 0x29, 0x1b, 0x15
+};
+
+static char baud_co_60[] = {	/* 60 MHz clock option table (CD1400 J) */
+	/* value =>    00    01   02    03    04 */
+	/* divide by    8    32   128   512  2048 */
+	0x00, 0x00, 0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03,
+	0x03, 0x02, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00
+};
+
+static char baud_bpr_60[] = {	/* 60 MHz baud rate period table (CD1400 J) */
+	0x00, 0x82, 0x21, 0xff, 0xdb, 0xc3, 0x92, 0x62, 0xc3, 0x62,
+	0x41, 0xc3, 0x62, 0xc3, 0x62, 0xc3, 0x82, 0x62, 0x41, 0x32,
+	0x21
+};
+
+static char baud_cor3[] = {	/* receive threshold */
+	0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+	0x0a, 0x0a, 0x0a, 0x09, 0x09, 0x08, 0x08, 0x08, 0x08, 0x07,
+	0x07
+};
@@ -802,4 +807,5 @@
-static char rflow_thr[] = {  /* rflow threshold */
-    0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00,
-    0x00,  0x00,  0x00,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,
-    0x0a};
+static char rflow_thr[] = {	/* rflow threshold */
+	0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+	0x00, 0x00, 0x00, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+	0x0a
+};
@@ -810,10 +816,9 @@
-static int cy_chip_offset [] =
-    { 0x0000,
-      0x0400,
-      0x0800,
-      0x0C00,
-      0x0200,
-      0x0600,
-      0x0A00,
-      0x0E00
-    };
+static int cy_chip_offset[] = { 0x0000,
+	0x0400,
+	0x0800,
+	0x0C00,
+	0x0200,
+	0x0600,
+	0x0A00,
+	0x0E00
+};
@@ -823,3 +828,3 @@
-static unsigned short	cy_pci_nboard;
-static unsigned short	cy_isa_nboard;
-static unsigned short	cy_nboard;
+static unsigned short cy_pci_nboard;
+static unsigned short cy_isa_nboard;
+static unsigned short cy_nboard;
@@ -827,11 +832,11 @@
-static unsigned short	cy_pci_dev_id[] = {
-			    PCI_DEVICE_ID_CYCLOM_Y_Lo,	/* PCI < 1Mb */
-			    PCI_DEVICE_ID_CYCLOM_Y_Hi,	/* PCI > 1Mb */
-			    PCI_DEVICE_ID_CYCLOM_4Y_Lo,	/* 4Y PCI < 1Mb */
-			    PCI_DEVICE_ID_CYCLOM_4Y_Hi,	/* 4Y PCI > 1Mb */
-			    PCI_DEVICE_ID_CYCLOM_8Y_Lo,	/* 8Y PCI < 1Mb */
-			    PCI_DEVICE_ID_CYCLOM_8Y_Hi,	/* 8Y PCI > 1Mb */
-			    PCI_DEVICE_ID_CYCLOM_Z_Lo,	/* Z PCI < 1Mb */
-			    PCI_DEVICE_ID_CYCLOM_Z_Hi,	/* Z PCI > 1Mb */
-			    0				/* end of table */
-			};
+static unsigned short cy_pci_dev_id[] = {
+	PCI_DEVICE_ID_CYCLOM_Y_Lo,	/* PCI < 1Mb */
+	PCI_DEVICE_ID_CYCLOM_Y_Hi,	/* PCI > 1Mb */
+	PCI_DEVICE_ID_CYCLOM_4Y_Lo,	/* 4Y PCI < 1Mb */
+	PCI_DEVICE_ID_CYCLOM_4Y_Hi,	/* 4Y PCI > 1Mb */
+	PCI_DEVICE_ID_CYCLOM_8Y_Lo,	/* 8Y PCI < 1Mb */
+	PCI_DEVICE_ID_CYCLOM_8Y_Hi,	/* 8Y PCI > 1Mb */
+	PCI_DEVICE_ID_CYCLOM_Z_Lo,	/* Z PCI < 1Mb */
+	PCI_DEVICE_ID_CYCLOM_Z_Hi,	/* Z PCI > 1Mb */
+	0			/* end of table */
+};
@@ -845 +850 @@
-#endif /* CONFIG_ISA */
+#endif				/* CONFIG_ISA */
@@ -847 +852 @@
-static int cyclades_get_proc_info(char *, char **, off_t , int , int *, void *);
+static int cyclades_get_proc_info(char *, char **, off_t, int, int *, void *);
@@ -858 +863 @@
-#else /* CONFIG_CYZ_INTR */
+#else				/* CONFIG_CYZ_INTR */
@@ -861 +866 @@
-#endif /* CONFIG_CYZ_INTR */
+#endif				/* CONFIG_CYZ_INTR */
@@ -863,3 +868,2 @@
-static inline int
-serial_paranoia_check(struct cyclades_port *info,
-                        char *name, const char *routine)
+static inline int serial_paranoia_check(struct cyclades_port *info,
+		char *name, const char *routine)
@@ -868,22 +872,18 @@
-    static const char *badmagic =
-        "cyc Warning: bad magic number for serial struct (%s) in %s\n";
-    static const char *badinfo =
-        "cyc Warning: null cyclades_port for (%s) in %s\n";
-    static const char *badrange =
-        "cyc Warning: cyclades_port out of range for (%s) in %s\n";
-
-    if (!info) {
-        printk(badinfo, name, routine);
-        return 1;
-    }
-
-    if( (long)info < (long)(&cy_port[0])
-    || (long)(&cy_port[NR_PORTS]) < (long)info ){
-        printk(badrange, name, routine);
-        return 1;
-    }
-
-    if (info->magic != CYCLADES_MAGIC) {
-        printk(badmagic, name, routine);
-        return 1;
-    }
+	if (!info) {
+		printk("cyc Warning: null cyclades_port for (%s) in %s\n",
+				name, routine);
+		return 1;
+	}
+
+	if ((long)info < (long)(&cy_port[0]) ||
+			(long)(&cy_port[NR_PORTS]) < (long)info) {
+		printk("cyc Warning: cyclades_port out of range for (%s) in "
+				"%s\n", name, routine);
+		return 1;
+	}
+
+	if (info->magic != CYCLADES_MAGIC) {
+		printk("cyc Warning: bad magic number for serial struct (%s) "
+				"in %s\n", name, routine);
+		return 1;
+	}
@@ -891,2 +891,2 @@
-        return 0;
-} /* serial_paranoia_check */
+	return 0;
+}				/* serial_paranoia_check */
@@ -900,2 +900 @@
-static inline void
-cy_sched_event(struct cyclades_port *info, int event)
+static inline void cy_sched_event(struct cyclades_port *info, int event)
@@ -903,4 +902,3 @@
-    info->event |= 1 << event; /* remember what kind of event and who */
-    schedule_work(&info->tqueue);
-} /* cy_sched_event */
-
+	info->event |= 1 << event; /* remember what kind of event and who */
+	schedule_work(&info->tqueue);
+}				/* cy_sched_event */
@@ -929 +927 @@
-do_softint(void *private_)
+do_softint(struct work_struct *work)
@@ -931,2 +929,7 @@
-  struct cyclades_port *info = (struct cyclades_port *) private_;
-  struct tty_struct    *tty;
+	struct cyclades_port *info =
+		container_of(work, struct cyclades_port, tqueue);
+	struct tty_struct    *tty;
+
+	tty = info->tty;
+	if (!tty)
+		return;
@@ -934,12 +937,7 @@
-    tty = info->tty;
-    if (!tty)
-        return;
-
-    if (test_and_clear_bit(Cy_EVENT_HANGUP, &info->event)) {
-        tty_hangup(info->tty);
-        wake_up_interruptible(&info->open_wait);
-        info->flags &= ~ASYNC_NORMAL_ACTIVE;
-    }
-    if (test_and_clear_bit(Cy_EVENT_OPEN_WAKEUP, &info->event)) {
-        wake_up_interruptible(&info->open_wait);
-    }
+	if (test_and_clear_bit(Cy_EVENT_HANGUP, &info->event)) {
+		tty_hangup(info->tty);
+		wake_up_interruptible(&info->open_wait);
+		        info->flags &= ~ASYNC_NORMAL_ACTIVE;
+	}
+	if (test_and_clear_bit(Cy_EVENT_OPEN_WAKEUP, &info->event))
+		wake_up_interruptible(&info->open_wait);
@@ -947,16 +945,13 @@
-    if (test_and_clear_bit(Cy_EVENT_Z_RX_FULL, &info->event)) {
-	if (cyz_rx_full_timer[info->line].function == NULL) {
-	    cyz_rx_full_timer[info->line].expires = jiffies + 1;
-	    cyz_rx_full_timer[info->line].function = cyz_rx_restart;
-	    cyz_rx_full_timer[info->line].data = (unsigned long)info;
-	    add_timer(&cyz_rx_full_timer[info->line]);
-	}
-    }
-#endif
-    if (test_and_clear_bit(Cy_EVENT_DELTA_WAKEUP, &info->event)) {
-	wake_up_interruptible(&info->delta_msr_wait);
-    }
-    if (test_and_clear_bit(Cy_EVENT_WRITE_WAKEUP, &info->event)) {
-        tty_wakeup(tty);
-        wake_up_interruptible(&tty->write_wait);
-    }
+	if (test_and_clear_bit(Cy_EVENT_Z_RX_FULL, &info->event)) {
+		if (cyz_rx_full_timer[info->line].function == NULL) {
+			cyz_rx_full_timer[info->line].expires = jiffies + 1;
+			cyz_rx_full_timer[info->line].function = cyz_rx_restart;
+			cyz_rx_full_timer[info->line].data =
+						(unsigned long)info;
+			add_timer(&cyz_rx_full_timer[info->line]);
+		}
+	}
+#endif
+	if (test_and_clear_bit(Cy_EVENT_DELTA_WAKEUP, &info->event))
+		wake_up_interruptible(&info->delta_msr_wait);
+	tty_wakeup(tty);
@@ -964,3 +959,2 @@
-    if (test_and_clear_bit(Cy_EVENT_SHUTDOWN_WAKEUP, &info->event)) {
-        wake_up_interruptible(&info->shutdown_wait);
-    }
+	if (test_and_clear_bit(Cy_EVENT_SHUTDOWN_WAKEUP, &info->event))
+		wake_up_interruptible(&info->shutdown_wait);
@@ -981,2 +975 @@
-static int
-cyy_issue_cmd(void __iomem *base_addr, u_char cmd, int index)
+static int cyy_issue_cmd(void __iomem * base_addr, u_char cmd, int index)
@@ -984 +977 @@
-  volatile int  i;
+	volatile int i;
@@ -986,10 +979,11 @@
-    /* Check to see that the previous command has completed */
-    for(i = 0 ; i < 100 ; i++){
-	if (cy_readb(base_addr+(CyCCR<<index)) == 0){
-	    break;
-	}
-	udelay(10L);
-    }
-    /* if the CCR never cleared, the previous command
-       didn't finish within the "reasonable time" */
-    if (i == 100)	return (-1);
+	/* Check to see that the previous command has completed */
+	for (i = 0; i < 100; i++) {
+		if (cy_readb(base_addr + (CyCCR << index)) == 0) {
+			break;
+		}
+		udelay(10L);
+	}
+	/* if the CCR never cleared, the previous command
+	   didn't finish within the "reasonable time" */
+	if (i == 100)
+		return -1;
@@ -997,2 +991,2 @@
-    /* Issue the new command */
-    cy_writeb(base_addr+(CyCCR<<index), cmd);
+	/* Issue the new command */
+	cy_writeb(base_addr + (CyCCR << index), cmd);
@@ -1000,2 +994,2 @@
-    return(0);
-} /* cyy_issue_cmd */
+	return 0;
+}				/* cyy_issue_cmd */
@@ -1005,2 +999 @@
-static unsigned 
-detect_isa_irq(void __iomem *address)
+static unsigned detect_isa_irq(void __iomem * address)
@@ -1008,42 +1001,42 @@
-  int irq;
-  unsigned long irqs, flags;
-  int save_xir, save_car;
-  int index = 0; /* IRQ probing is only for ISA */
-
-    /* forget possible initially masked and pending IRQ */
-    irq = probe_irq_off(probe_irq_on());
-
-    /* Clear interrupts on the board first */
-    cy_writeb(address + (Cy_ClrIntr<<index), 0);
-			      /* Cy_ClrIntr is 0x1800 */
-
-    irqs = probe_irq_on();
-    /* Wait ... */
-    udelay(5000L);
-
-    /* Enable the Tx interrupts on the CD1400 */
-    local_irq_save(flags);
-	cy_writeb(address + (CyCAR<<index), 0);
-	cyy_issue_cmd(address, CyCHAN_CTL|CyENB_XMTR, index);
-
-	cy_writeb(address + (CyCAR<<index), 0);
-	cy_writeb(address + (CySRER<<index), 
-		cy_readb(address + (CySRER<<index)) | CyTxRdy);
-    local_irq_restore(flags);
-
-    /* Wait ... */
-    udelay(5000L);
-
-    /* Check which interrupt is in use */
-    irq = probe_irq_off(irqs);
-
-    /* Clean up */
-    save_xir = (u_char) cy_readb(address + (CyTIR<<index));
-    save_car = cy_readb(address + (CyCAR<<index));
-    cy_writeb(address + (CyCAR<<index), (save_xir & 0x3));
-    cy_writeb(address + (CySRER<<index),
-	cy_readb(address + (CySRER<<index)) & ~CyTxRdy);
-    cy_writeb(address + (CyTIR<<index), (save_xir & 0x3f));
-    cy_writeb(address + (CyCAR<<index), (save_car));
-    cy_writeb(address + (Cy_ClrIntr<<index), 0);
-			      /* Cy_ClrIntr is 0x1800 */
+	int irq;
+	unsigned long irqs, flags;
+	int save_xir, save_car;
+	int index = 0;		/* IRQ probing is only for ISA */
+
+	/* forget possible initially masked and pending IRQ */
+	irq = probe_irq_off(probe_irq_on());
+
+	/* Clear interrupts on the board first */
+	cy_writeb(address + (Cy_ClrIntr << index), 0);
+	/* Cy_ClrIntr is 0x1800 */
+
+	irqs = probe_irq_on();
+	/* Wait ... */
+	udelay(5000L);
+
+	/* Enable the Tx interrupts on the CD1400 */
+	local_irq_save(flags);
+	cy_writeb(address + (CyCAR << index), 0);
+	cyy_issue_cmd(address, CyCHAN_CTL | CyENB_XMTR, index);
+
+	cy_writeb(address + (CyCAR << index), 0);
+	cy_writeb(address + (CySRER << index),
+		  cy_readb(address + (CySRER << index)) | CyTxRdy);
+	local_irq_restore(flags);
+
+	/* Wait ... */
+	udelay(5000L);
+
+	/* Check which interrupt is in use */
+	irq = probe_irq_off(irqs);
+
+	/* Clean up */
+	save_xir = (u_char) cy_readb(address + (CyTIR << index));
+	save_car = cy_readb(address + (CyCAR << index));
+	cy_writeb(address + (CyCAR << index), (save_xir & 0x3));
+	cy_writeb(address + (CySRER << index),
+		  cy_readb(address + (CySRER << index)) & ~CyTxRdy);
+	cy_writeb(address + (CyTIR << index), (save_xir & 0x3f));
+	cy_writeb(address + (CyCAR << index), (save_car));
+	cy_writeb(address + (Cy_ClrIntr << index), 0);
+	/* Cy_ClrIntr is 0x1800 */
@@ -1051 +1044 @@
-    return (irq > 0)? irq : 0;
+	return (irq > 0) ? irq : 0;
@@ -1053 +1046 @@
-#endif /* CONFIG_ISA */
+#endif				/* CONFIG_ISA */
@@ -1055,6 +1048,2 @@
-/* The real interrupt service routine is called
-   whenever the card wants its hand held--chars
-   received, out buffer empty, modem change, etc.
- */
-static irqreturn_t
-cyy_interrupt(int irq, void *dev_id)
+static void cyy_intr_chip(struct cyclades_card *cinfo, int chip,
+			void __iomem * base_addr, int status, int index)
@@ -1062,25 +1051,6 @@
-  struct tty_struct *tty;
-  int status;
-  struct cyclades_card *cinfo;
-  struct cyclades_port *info;
-  void __iomem *base_addr, *card_base_addr;
-  int chip;
-  int save_xir, channel, save_car;
-  char data;
-  volatile int char_count;
-  int outch;
-  int i,j,index;
-  int too_many;
-  int had_work;
-  int mdm_change;
-  int mdm_status;
-  int len;
-    if((cinfo = (struct cyclades_card *)dev_id) == 0){
-#ifdef CY_DEBUG_INTERRUPTS
-	printk("cyy_interrupt: spurious interrupt %d\n\r", irq);
-#endif
-        return IRQ_NONE; /* spurious interrupt */
-    }
-
-    card_base_addr = cinfo->base_addr;
-    index = cinfo->bus_index;
+	struct cyclades_port *info;
+	struct tty_struct *tty;
+	volatile int char_count;
+	int i, j, len, mdm_change, mdm_status, outch;
+	int save_xir, channel, save_car;
+	char data;
@@ -1088,22 +1058 @@
-
-    /* This loop checks all chips in the card.  Make a note whenever
-       _any_ chip had some work to do, as this is considered an
-       indication that there will be more to do.  Only when no chip
-       has any work does this outermost loop exit.
-     */
-    do{
-        had_work = 0;
-        for ( chip = 0 ; chip < cinfo->num_chips ; chip ++) {
-            base_addr = cinfo->base_addr + (cy_chip_offset[chip]<<index);
-            too_many = 0;
-            while ( (status = cy_readb(base_addr+(CySVRR<<index))) != 0x00) {
-                had_work++;
-                /* The purpose of the following test is to ensure that
-                   no chip can monopolize the driver.  This forces the
-                   chips to be checked in a round-robin fashion (after
-                   draining each of a bunch (1000) of characters).
-                 */
-                if(1000<too_many++){
-                    break;
-                }
-                if (status & CySRReceive) { /* reception interrupt */
+	if (status & CySRReceive) {	/* reception interrupt */
@@ -1111 +1060 @@
-		    printk("cyy_interrupt: rcvd intr, chip %d\n\r", chip);
+		printk("cyy_interrupt: rcvd intr, chip %d\n\r", chip);
@@ -1113,36 +1062,40 @@
-                    /* determine the channel & change to that context */
-		    spin_lock(&cinfo->card_lock);
-                    save_xir = (u_char) cy_readb(base_addr+(CyRIR<<index));
-                    channel = (u_short ) (save_xir & CyIRChannel);
-                    i = channel + chip * 4 + cinfo->first_line;
-                    info = &cy_port[i];
-                    info->last_active = jiffies;
-                    save_car = cy_readb(base_addr+(CyCAR<<index));
-                    cy_writeb(base_addr+(CyCAR<<index), save_xir);
-
-                    /* if there is nowhere to put the data, discard it */
-                    if(info->tty == 0){
-                        j = (cy_readb(base_addr+(CyRIVR<<index)) & CyIVRMask);
-                        if ( j == CyIVRRxEx ) { /* exception */
-                            data = cy_readb(base_addr+(CyRDSR<<index));
-                        } else { /* normal character reception */
-                            char_count = cy_readb(base_addr+(CyRDCR<<index));
-                            while(char_count--){
-                                data = cy_readb(base_addr+(CyRDSR<<index));
-                            }
-                        }
-                    }else{ /* there is an open port for this data */
-                        tty = info->tty;
-                        j = (cy_readb(base_addr+(CyRIVR<<index)) & CyIVRMask);
-                        if ( j == CyIVRRxEx ) { /* exception */
-                            data = cy_readb(base_addr+(CyRDSR<<index));
-
-			    /* For statistics only */
-			    if (data & CyBREAK)
-				info->icount.brk++;
-			    else if(data & CyFRAME)
-				info->icount.frame++;
-			    else if(data & CyPARITY)
-				info->icount.parity++;
-			    else if(data & CyOVERRUN)
-				info->icount.overrun++;
+		/* determine the channel & change to that context */
+		spin_lock(&cinfo->card_lock);
+		save_xir = (u_char) cy_readb(base_addr + (CyRIR << index));
+		channel = (u_short) (save_xir & CyIRChannel);
+		i = channel + chip * 4 + cinfo->first_line;
+		info = &cy_port[i];
+		info->last_active = jiffies;
+		save_car = cy_readb(base_addr + (CyCAR << index));
+		cy_writeb(base_addr + (CyCAR << index), save_xir);
+
+		/* if there is nowhere to put the data, discard it */
+		if (info->tty == 0) {
+			j = (cy_readb(base_addr + (CyRIVR << index)) &
+				CyIVRMask);
+			if (j == CyIVRRxEx) {	/* exception */
+				data = cy_readb(base_addr + (CyRDSR << index));
+			} else {	/* normal character reception */
+				char_count = cy_readb(base_addr +
+						(CyRDCR << index));
+				while (char_count--) {
+					data = cy_readb(base_addr +
+						(CyRDSR << index));
+				}
+			}
+		} else {	/* there is an open port for this data */
+			tty = info->tty;
+			j = (cy_readb(base_addr + (CyRIVR << index)) &
+					CyIVRMask);
+			if (j == CyIVRRxEx) {	/* exception */
+				data = cy_readb(base_addr + (CyRDSR << index));
+
+				/* For statistics only */
+				if (data & CyBREAK)
+					info->icount.brk++;
+				else if (data & CyFRAME)
+					info->icount.frame++;
+				else if (data & CyPARITY)
+					info->icount.parity++;
+				else if (data & CyOVERRUN)
+					info->icount.overrun++;
@@ -1150,14 +1103 @@
-                            if(data & info->ignore_status_mask){
-				info->icount.rx++;
-                                continue;
-                            }
-                            if (tty_buffer_request_room(tty, 1)) {
-                                if (data & info->read_status_mask){
-                                    if(data & CyBREAK){
-                                        tty_insert_flip_char(tty, cy_readb(base_addr+(CyRDSR<<index)), TTY_BREAK);
-					info->icount.rx++;
-                                        if (info->flags & ASYNC_SAK){
-                                            do_SAK(tty);
-                                        }
-                                    }else if(data & CyFRAME){
-                                        tty_insert_flip_char(tty, cy_readb(base_addr+(CyRDSR<<index)), TTY_FRAME);
+				if (data & info->ignore_status_mask) {
@@ -1165,15 +1105,79 @@
-					info->idle_stats.frame_errs++;
-                                    }else if(data & CyPARITY){
-					/* Pieces of seven... */
-                                        tty_insert_flip_char(tty, cy_readb(base_addr+(CyRDSR<<index)), TTY_PARITY);
-					info->icount.rx++;
-					info->idle_stats.parity_errs++;
-                                    }else if(data & CyOVERRUN){
-                                        tty_insert_flip_char(tty, 0, TTY_OVERRUN);
-					info->icount.rx++;
-                                        /* If the flip buffer itself is
-                                           overflowing, we still lose
-                                           the next incoming character.
-                                         */
-                                        tty_insert_flip_char(tty, cy_readb(base_addr+(CyRDSR<<index)), TTY_FRAME);
-				        info->icount.rx++;
+					return;
+				}
+				if (tty_buffer_request_room(tty, 1)) {
+					if (data & info->read_status_mask) {
+						if (data & CyBREAK) {
+							tty_insert_flip_char(
+								tty,
+								cy_readb(
+								base_addr +
+								(CyRDSR <<
+									index)),
+								TTY_BREAK);
+							info->icount.rx++;
+							if (info->flags &
+							    ASYNC_SAK) {
+								do_SAK(tty);
+							}
+						} else if (data & CyFRAME) {
+							tty_insert_flip_char(
+								tty,
+								cy_readb(
+								base_addr +
+								(CyRDSR <<
+									index)),
+								TTY_FRAME);
+							info->icount.rx++;
+							info->idle_stats.
+								frame_errs++;
+						} else if (data & CyPARITY) {
+							/* Pieces of seven... */
+							tty_insert_flip_char(
+								tty,
+								cy_readb(
+								base_addr +
+								(CyRDSR <<
+									index)),
+								TTY_PARITY);
+							info->icount.rx++;
+							info->idle_stats.
+								parity_errs++;
+						} else if (data & CyOVERRUN) {
+							tty_insert_flip_char(
+								tty, 0,
+								TTY_OVERRUN);
+							info->icount.rx++;
+						/* If the flip buffer itself is
+						   overflowing, we still lose
+						   the next incoming character.
+						 */
+							tty_insert_flip_char(
+								tty,
+								cy_readb(
+								base_addr +
+								(CyRDSR <<
+									index)),
+								TTY_FRAME);
+							info->icount.rx++;
+							info->idle_stats.
+								overruns++;
+					/* These two conditions may imply */
+					/* a normal read should be done. */
+					/* }else if(data & CyTIMEOUT){ */
+					/* }else if(data & CySPECHAR){ */
+						} else {
+							tty_insert_flip_char(
+								tty, 0,
+								TTY_NORMAL);
+							info->icount.rx++;
+						}
+					} else {
+						tty_insert_flip_char(tty, 0,
+								TTY_NORMAL);
+						info->icount.rx++;
+					}
+				} else {
+					/* there was a software buffer
+					   overrun and nothing could be
+					   done about it!!! */
+					info->icount.buf_overrun++;
@@ -1181,22 +1185,5 @@
-                                    /* These two conditions may imply */
-                                    /* a normal read should be done. */
-                                    /* }else if(data & CyTIMEOUT){ */
-                                    /* }else if(data & CySPECHAR){ */
-                                    }else {
-					tty_insert_flip_char(tty, 0, TTY_NORMAL);
-				        info->icount.rx++;
-                                    }
-                                }else{
-				    tty_insert_flip_char(tty, 0, TTY_NORMAL);
-				    info->icount.rx++;
-                                }
-                            }else{
-                                /* there was a software buffer
-				   overrun and nothing could be
-				   done about it!!! */
-				info->icount.buf_overrun++;
-				info->idle_stats.overruns++;
-                            }
-                        } else { /* normal character reception */
-                            /* load # chars available from the chip */
-                            char_count = cy_readb(base_addr+(CyRDCR<<index));
+				}
+			} else {	/* normal character reception */
+				/* load # chars available from the chip */
+				char_count = cy_readb(base_addr +
+						(CyRDCR << index));
@@ -1205,12 +1192,14 @@
-                            ++info->mon.int_count;
-                            info->mon.char_count += char_count;
-                            if (char_count > info->mon.char_max)
-                               info->mon.char_max = char_count;
-                            info->mon.char_last = char_count;
-#endif
-			    len = tty_buffer_request_room(tty, char_count);
-                            while(len--){
-                                data = cy_readb(base_addr+(CyRDSR<<index));
-				tty_insert_flip_char(tty, data, TTY_NORMAL);
-				info->idle_stats.recv_bytes++;
-				info->icount.rx++;
+				++info->mon.int_count;
+				info->mon.char_count += char_count;
+				if (char_count > info->mon.char_max)
+					info->mon.char_max = char_count;
+				info->mon.char_last = char_count;
+#endif
+				len = tty_buffer_request_room(tty, char_count);
+				while (len--) {
+					data = cy_readb(base_addr +
+							(CyRDSR << index));
+					tty_insert_flip_char(tty, data,
+							TTY_NORMAL);
+					info->idle_stats.recv_bytes++;
+					info->icount.rx++;
@@ -1218 +1207 @@
-                                udelay(10L);
+					udelay(10L);
@@ -1220,3 +1209,3 @@
-                            }
-                             info->idle_stats.recv_idle = jiffies;
-                        }
+				}
+				info->idle_stats.recv_idle = jiffies;
+			}
@@ -1224,7 +1213,6 @@
-                    }
-                    /* end of service */
-                    cy_writeb(base_addr+(CyRIR<<index), (save_xir & 0x3f));
-                    cy_writeb(base_addr+(CyCAR<<index), (save_car));
-		    spin_unlock(&cinfo->card_lock);
-                }
-
+		}
+		/* end of service */
+		cy_writeb(base_addr + (CyRIR << index), (save_xir & 0x3f));
+		cy_writeb(base_addr + (CyCAR << index), (save_car));
+		spin_unlock(&cinfo->card_lock);
+	}
@@ -1232,4 +1220,4 @@
-                if (status & CySRTransmit) { /* transmission interrupt */
-                    /* Since we only get here when the transmit buffer
-                       is empty, we know we can always stuff a dozen
-                       characters. */
+	if (status & CySRTransmit) {	/* transmission interrupt */
+		/* Since we only get here when the transmit buffer
+		   is empty, we know we can always stuff a dozen
+		   characters. */
@@ -1237 +1225 @@
-		    printk("cyy_interrupt: xmit intr, chip %d\n\r", chip);
+		printk("cyy_interrupt: xmit intr, chip %d\n\r", chip);
@@ -1240,29 +1228,31 @@
-                    /* determine the channel & change to that context */
-		    spin_lock(&cinfo->card_lock);
-                    save_xir = (u_char) cy_readb(base_addr+(CyTIR<<index));
-                    channel = (u_short ) (save_xir & CyIRChannel);
-                    i = channel + chip * 4 + cinfo->first_line;
-                    save_car = cy_readb(base_addr+(CyCAR<<index));
-                    cy_writeb(base_addr+(CyCAR<<index), save_xir);
-
-                    /* validate the port# (as configured and open) */
-                    if( (i < 0) || (NR_PORTS <= i) ){
-                        cy_writeb(base_addr+(CySRER<<index),
-                             cy_readb(base_addr+(CySRER<<index)) & ~CyTxRdy);
-                        goto txend;
-                    }
-                    info = &cy_port[i];
-                    info->last_active = jiffies;
-                    if(info->tty == 0){
-                        cy_writeb(base_addr+(CySRER<<index),
-                             cy_readb(base_addr+(CySRER<<index)) & ~CyTxRdy);
-                        goto txdone;
-                    }
-
-                    /* load the on-chip space for outbound data */
-                    char_count = info->xmit_fifo_size;
-
-                    if(info->x_char) { /* send special char */
-                        outch = info->x_char;
-                        cy_writeb(base_addr+(CyTDR<<index), outch);
-                        char_count--;
+		/* determine the channel & change to that context */
+		spin_lock(&cinfo->card_lock);
+		save_xir = (u_char) cy_readb(base_addr + (CyTIR << index));
+		channel = (u_short) (save_xir & CyIRChannel);
+		i = channel + chip * 4 + cinfo->first_line;
+		save_car = cy_readb(base_addr + (CyCAR << index));
+		cy_writeb(base_addr + (CyCAR << index), save_xir);
+
+		/* validate the port# (as configured and open) */
+		if ((i < 0) || (NR_PORTS <= i)) {
+			cy_writeb(base_addr + (CySRER << index),
+				  cy_readb(base_addr + (CySRER << index)) &
+				  ~CyTxRdy);
+			goto txend;
+		}
+		info = &cy_port[i];
+		info->last_active = jiffies;
+		if (info->tty == 0) {
+			cy_writeb(base_addr + (CySRER << index),
+				  cy_readb(base_addr + (CySRER << index)) &
+				  ~CyTxRdy);
+			goto txdone;
+		}
+
+		/* load the on-chip space for outbound data */
+		char_count = info->xmit_fifo_size;
+
+		if (info->x_char) {	/* send special char */
+			outch = info->x_char;
+			cy_writeb(base_addr + (CyTDR << index), outch);
+			char_count--;
@@ -1270,2 +1260,2 @@
-                        info->x_char = 0;
-                    }
+			info->x_char = 0;
+		}
@@ -1273 +1263 @@
-                    if (info->breakon || info->breakoff) {
+		if (info->breakon || info->breakoff) {
@@ -1275,4 +1265,4 @@
-			    cy_writeb(base_addr + (CyTDR<<index), 0); 
-			    cy_writeb(base_addr + (CyTDR<<index), 0x81);
-			    info->breakon = 0;
-                            char_count -= 2;
+				cy_writeb(base_addr + (CyTDR << index), 0);
+				cy_writeb(base_addr + (CyTDR << index), 0x81);
+				info->breakon = 0;
+				char_count -= 2;
@@ -1281,24 +1271,26 @@
-			    cy_writeb(base_addr + (CyTDR<<index), 0); 
-			    cy_writeb(base_addr + (CyTDR<<index), 0x83);
-			    info->breakoff = 0;
-                            char_count -= 2;
-			}
-                    }
-
-                    while (char_count-- > 0){
-			if (!info->xmit_cnt){
-			    if (cy_readb(base_addr+(CySRER<<index))&CyTxMpty) {
-				cy_writeb(base_addr+(CySRER<<index),
-					  cy_readb(base_addr+(CySRER<<index)) &
-					  ~CyTxMpty);
-			    } else {
-				cy_writeb(base_addr+(CySRER<<index),
-					  ((cy_readb(base_addr+(CySRER<<index))
-					    & ~CyTxRdy)
-					   | CyTxMpty));
-			    }
-			    goto txdone;
-			}
-			if (info->xmit_buf == 0){
-                            cy_writeb(base_addr+(CySRER<<index),
-				cy_readb(base_addr+(CySRER<<index)) & 
+				cy_writeb(base_addr + (CyTDR << index), 0);
+				cy_writeb(base_addr + (CyTDR << index), 0x83);
+				info->breakoff = 0;
+				char_count -= 2;
+			}
+		}
+
+		while (char_count-- > 0) {
+			if (!info->xmit_cnt) {
+				if (cy_readb(base_addr + (CySRER << index)) &
+						CyTxMpty) {
+					cy_writeb(base_addr + (CySRER << index),
+						cy_readb(base_addr +
+							(CySRER << index)) &
+						~CyTxMpty);
+				} else {
+					cy_writeb(base_addr + (CySRER << index),
+						(cy_readb(base_addr +
+						  	(CySRER << index)) &
+						~CyTxRdy) | CyTxMpty);
+				}
+				goto txdone;
+			}
+			if (info->xmit_buf == 0) {
+				cy_writeb(base_addr + (CySRER << index),
+					cy_readb(base_addr + (CySRER << index))&
@@ -1306 +1298 @@
-                            goto txdone;
+				goto txdone;
@@ -1308,3 +1300,3 @@
-			if (info->tty->stopped || info->tty->hw_stopped){
-                            cy_writeb(base_addr+(CySRER<<index),
-				cy_readb(base_addr+(CySRER<<index)) & 
+			if (info->tty->stopped || info->tty->hw_stopped) {
+				cy_writeb(base_addr + (CySRER << index),
+					cy_readb(base_addr + (CySRER << index))&
@@ -1312 +1304 @@
-                            goto txdone;
+				goto txdone;
@@ -1314,2 +1306,2 @@
-                        /* Because the Embedded Transmit Commands have
-                           been enabled, we must check to see if the
+			/* Because the Embedded Transmit Commands have
+			   been enabled, we must check to see if the
@@ -1324,16 +1316,7 @@
-                         */
-                        outch = info->xmit_buf[info->xmit_tail];
-                        if( outch ){
-                            info->xmit_cnt--;
-                            info->xmit_tail = (info->xmit_tail + 1)
-                                                      & (SERIAL_XMIT_SIZE - 1);
-                            cy_writeb(base_addr+(CyTDR<<index), outch);
-			    info->icount.tx++;
-                        }else{
-                            if(char_count > 1){
-                                info->xmit_cnt--;
-                                info->xmit_tail = (info->xmit_tail + 1)
-						      & (SERIAL_XMIT_SIZE - 1);
-                                cy_writeb(base_addr+(CyTDR<<index), 
-					  outch);
-                                cy_writeb(base_addr+(CyTDR<<index), 0);
+			 */
+			outch = info->xmit_buf[info->xmit_tail];
+			if (outch) {
+				info->xmit_cnt--;
+				info->xmit_tail = (info->xmit_tail + 1) &
+						(SERIAL_XMIT_SIZE - 1);
+				cy_writeb(base_addr + (CyTDR << index), outch);
@@ -1341,36 +1324,44 @@
-                                char_count--;
-                            }else{
-                            }
-                        }
-                    }
-
-        txdone:
-                    if (info->xmit_cnt < WAKEUP_CHARS) {
-                        cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
-                    }
-        txend:
-                    /* end of service */
-                    cy_writeb(base_addr+(CyTIR<<index), 
-			      (save_xir & 0x3f));
-                    cy_writeb(base_addr+(CyCAR<<index), (save_car));
-		    spin_unlock(&cinfo->card_lock);
-                }
-
-                if (status & CySRModem) {        /* modem interrupt */
-
-                    /* determine the channel & change to that context */
-		    spin_lock(&cinfo->card_lock);
-                    save_xir = (u_char) cy_readb(base_addr+(CyMIR<<index));
-                    channel = (u_short ) (save_xir & CyIRChannel);
-                    info = &cy_port[channel + chip * 4
-		                           + cinfo->first_line];
-                    info->last_active = jiffies;
-                    save_car = cy_readb(base_addr+(CyCAR<<index));
-                    cy_writeb(base_addr+(CyCAR<<index), save_xir);
-
-                    mdm_change = cy_readb(base_addr+(CyMISR<<index));
-                    mdm_status = cy_readb(base_addr+(CyMSVR1<<index));
-
-                    if(info->tty == 0){/* no place for data, ignore it*/
-                        ;
-                    }else{
+			} else {
+				if (char_count > 1) {
+					info->xmit_cnt--;
+					info->xmit_tail = (info->xmit_tail + 1)&
+						(SERIAL_XMIT_SIZE - 1);
+					cy_writeb(base_addr + (CyTDR << index),
+						outch);
+					cy_writeb(base_addr + (CyTDR << index),
+						0);
+					info->icount.tx++;
+					char_count--;
+				} else {
+				}
+			}
+		}
+
+txdone:
+		if (info->xmit_cnt < WAKEUP_CHARS) {
+			cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
+		}
+txend:
+		/* end of service */
+		cy_writeb(base_addr + (CyTIR << index), (save_xir & 0x3f));
+		cy_writeb(base_addr + (CyCAR << index), (save_car));
+		spin_unlock(&cinfo->card_lock);
+	}
+
+	if (status & CySRModem) {	/* modem interrupt */
+
+		/* determine the channel & change to that context */
+		spin_lock(&cinfo->card_lock);
+		save_xir = (u_char) cy_readb(base_addr + (CyMIR << index));
+		channel = (u_short) (save_xir & CyIRChannel);
+		info = &cy_port[channel + chip * 4 + cinfo->first_line];
+		info->last_active = jiffies;
+		save_car = cy_readb(base_addr + (CyCAR << index));
+		cy_writeb(base_addr + (CyCAR << index), save_xir);
+
+		mdm_change = cy_readb(base_addr + (CyMISR << index));
+		mdm_status = cy_readb(base_addr + (CyMSVR1 << index));
+
+		if (info->tty == 0) {	/* no place for data, ignore it */
+			;
+		} else {
@@ -1378,65 +1369,123 @@
-			    /* For statistics only */
-			    if (mdm_change & CyDCD)	info->icount.dcd++;
-			    if (mdm_change & CyCTS)	info->icount.cts++;
-			    if (mdm_change & CyDSR)	info->icount.dsr++;
-			    if (mdm_change & CyRI)	info->icount.rng++;
-
-			    cy_sched_event(info, Cy_EVENT_DELTA_WAKEUP);
-			}
-
-                        if((mdm_change & CyDCD)
-                        && (info->flags & ASYNC_CHECK_CD)){
-                            if(mdm_status & CyDCD){
-                                cy_sched_event(info,
-				    Cy_EVENT_OPEN_WAKEUP);
-                            }else{
-                                cy_sched_event(info,
-				    Cy_EVENT_HANGUP);
-                            }
-                        }
-                        if((mdm_change & CyCTS)
-                        && (info->flags & ASYNC_CTS_FLOW)){
-                            if(info->tty->hw_stopped){
-                                if(mdm_status & CyCTS){
-                                    /* cy_start isn't used
-				         because... !!! */
-                                    info->tty->hw_stopped = 0;
-                                  cy_writeb(base_addr+(CySRER<<index),
-                                       cy_readb(base_addr+(CySRER<<index)) | 
-                                       CyTxRdy);
-                                    cy_sched_event(info,
-				        Cy_EVENT_WRITE_WAKEUP);
-                                }
-                            }else{
-                                if(!(mdm_status & CyCTS)){
-                                    /* cy_stop isn't used
-				         because ... !!! */
-                                    info->tty->hw_stopped = 1;
-                                  cy_writeb(base_addr+(CySRER<<index),
-                                       cy_readb(base_addr+(CySRER<<index)) & 
-                                       ~CyTxRdy);
-                                }
-                            }
-                        }
-                        if(mdm_change & CyDSR){
-                        }
-                        if(mdm_change & CyRI){
-                        }
-                    }
-                    /* end of service */
-                    cy_writeb(base_addr+(CyMIR<<index), 
-			      (save_xir & 0x3f));
-                    cy_writeb(base_addr+(CyCAR<<index), save_car);
-		    spin_unlock(&cinfo->card_lock);
-                }
-            }          /* end while status != 0 */
-        }            /* end loop for chips... */
-    } while(had_work);
-
-   /* clear interrupts */
-   spin_lock(&cinfo->card_lock);
-   cy_writeb(card_base_addr + (Cy_ClrIntr<<index), 0);
-                                /* Cy_ClrIntr is 0x1800 */
-   spin_unlock(&cinfo->card_lock);
-   return IRQ_HANDLED;
-} /* cyy_interrupt */
+				/* For statistics only */
+				if (mdm_change & CyDCD)
+					info->icount.dcd++;
+				if (mdm_change & CyCTS)
+					info->icount.cts++;
+				if (mdm_change & CyDSR)
+					info->icount.dsr++;
+				if (mdm_change & CyRI)
+					info->icount.rng++;
+
+				cy_sched_event(info, Cy_EVENT_DELTA_WAKEUP);
+			}
+
+			if ((mdm_change & CyDCD) &&
+					(info->flags & ASYNC_CHECK_CD)) {
+				if (mdm_status & CyDCD) {
+					cy_sched_event(info,
+							Cy_EVENT_OPEN_WAKEUP);
+				} else {
+					cy_sched_event(info, Cy_EVENT_HANGUP);
+				}
+			}
+			if ((mdm_change & CyCTS) &&
+					(info->flags & ASYNC_CTS_FLOW)) {
+				if (info->tty->hw_stopped) {
+					if (mdm_status & CyCTS) {
+						/* cy_start isn't used
+						   because... !!! */
+						info->tty->hw_stopped = 0;
+						cy_writeb(base_addr +
+							(CySRER << index),
+							cy_readb(base_addr +
+								(CySRER <<
+									index))|
+							CyTxRdy);
+						cy_sched_event(info,
+							Cy_EVENT_WRITE_WAKEUP);
+					}
+				} else {
+					if (!(mdm_status & CyCTS)) {
+						/* cy_stop isn't used
+						   because ... !!! */
+						info->tty->hw_stopped = 1;
+						cy_writeb(base_addr +
+							(CySRER << index),
+							cy_readb(base_addr +
+								(CySRER <<
+								index)) &
+							~CyTxRdy);
+					}
+				}
+			}
+			if (mdm_change & CyDSR) {
+			}
+			if (mdm_change & CyRI) {
+			}
+		}
+		/* end of service */
+		cy_writeb(base_addr + (CyMIR << index), (save_xir & 0x3f));
+		cy_writeb(base_addr + (CyCAR << index), save_car);
+		spin_unlock(&cinfo->card_lock);
+	}
+}
+
+/* The real interrupt service routine is called
+   whenever the card wants its hand held--chars
+   received, out buffer empty, modem change, etc.
+ */
+static irqreturn_t cyy_interrupt(int irq, void *dev_id)
+{
+	int status;
+	struct cyclades_card *cinfo;
+	void __iomem *base_addr, *card_base_addr;
+	int chip;
+	int index;
+	int too_many;
+	int had_work;
+
+	if ((cinfo = (struct cyclades_card *)dev_id) == 0) {
+#ifdef CY_DEBUG_INTERRUPTS
+		printk("cyy_interrupt: spurious interrupt %d\n\r", irq);
+#endif
+		return IRQ_NONE;	/* spurious interrupt */
+	}
+
+	card_base_addr = cinfo->base_addr;
+	index = cinfo->bus_index;
+
+	/* This loop checks all chips in the card.  Make a note whenever
+	   _any_ chip had some work to do, as this is considered an
+	   indication that there will be more to do.  Only when no chip
+	   has any work does this outermost loop exit.
+	 */
+	do {
+		had_work = 0;
+		for (chip = 0; chip < cinfo->num_chips; chip++) {
+			base_addr = cinfo->base_addr +
+					(cy_chip_offset[chip] << index);
+			too_many = 0;
+			while ((status = cy_readb(base_addr +
+						(CySVRR << index))) != 0x00) {
+				had_work++;
+			/* The purpose of the following test is to ensure that
+			   no chip can monopolize the driver.  This forces the
+			   chips to be checked in a round-robin fashion (after
+			   draining each of a bunch (1000) of characters).
+			 */
+				if (1000 < too_many++) {
+					break;
+				}
+				cyy_intr_chip(cinfo, chip, base_addr, status,
+						index);
+			}
+		}
+	} while (had_work);
+
+	/* clear interrupts */
+	spin_lock(&cinfo->card_lock);
+	cy_writeb(card_base_addr + (Cy_ClrIntr << index), 0);
+	/* Cy_ClrIntr is 0x1800 */
+	spin_unlock(&cinfo->card_lock);
+	return IRQ_HANDLED;
+}				/* cyy_interrupt */
@@ -1450,2 +1499,2 @@
-cyz_fetch_msg( struct cyclades_card *cinfo,
-	    uclong *channel, ucchar *cmd, uclong *param)
+cyz_fetch_msg(struct cyclades_card *cinfo,
+		uclong * channel, ucchar * cmd, uclong * param)
@@ -1453,24 +1502,25 @@
-  struct FIRM_ID __iomem *firm_id;
-  struct ZFW_CTRL __iomem *zfw_ctrl;
-  struct BOARD_CTRL __iomem *board_ctrl;
-  unsigned long loc_doorbell;
-
-    firm_id = cinfo->base_addr + ID_ADDRESS;
-    if (!ISZLOADED(*cinfo)){
-	return (-1);
-    }
-    zfw_ctrl = cinfo->base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
-    board_ctrl = &zfw_ctrl->board_ctrl;
-
-    loc_doorbell = cy_readl(&((struct RUNTIME_9060 __iomem *)
-                     (cinfo->ctl_addr))->loc_doorbell);
-    if (loc_doorbell){
-	*cmd = (char)(0xff & loc_doorbell);
-	*channel = cy_readl(&board_ctrl->fwcmd_channel);
-	*param = (uclong)cy_readl(&board_ctrl->fwcmd_param);
-	cy_writel(&((struct RUNTIME_9060 __iomem *)(cinfo->ctl_addr))->loc_doorbell, 
-                 0xffffffff);
-	return 1;
-    }
-    return 0;
-} /* cyz_fetch_msg */
+	struct FIRM_ID __iomem *firm_id;
+	struct ZFW_CTRL __iomem *zfw_ctrl;
+	struct BOARD_CTRL __iomem *board_ctrl;
+	unsigned long loc_doorbell;
+
+	firm_id = cinfo->base_addr + ID_ADDRESS;
+	if (!ISZLOADED(*cinfo)) {
+		return -1;
+	}
+	zfw_ctrl = cinfo->base_addr + (cy_readl(&firm_id->zfwctrl_addr) &
+			0xfffff);
+	board_ctrl = &zfw_ctrl->board_ctrl;
+
+	loc_doorbell = cy_readl(&((struct RUNTIME_9060 __iomem *)
+				  (cinfo->ctl_addr))->loc_doorbell);
+	if (loc_doorbell) {
+		*cmd = (char)(0xff & loc_doorbell);
+		*channel = cy_readl(&board_ctrl->fwcmd_channel);
+		*param = (uclong) cy_readl(&board_ctrl->fwcmd_param);
+		cy_writel(&((struct RUNTIME_9060 __iomem *)(cinfo->ctl_addr))->
+			  loc_doorbell, 0xffffffff);
+		return 1;
+	}
+	return 0;
+}				/* cyz_fetch_msg */
@@ -1479,2 +1529,2 @@
-cyz_issue_cmd( struct cyclades_card *cinfo,
-	    uclong channel, ucchar cmd, uclong param)
+cyz_issue_cmd(struct cyclades_card *cinfo,
+		uclong channel, ucchar cmd, uclong param)
@@ -1482,24 +1532,5 @@
-  struct FIRM_ID __iomem *firm_id;
-  struct ZFW_CTRL __iomem *zfw_ctrl;
-  struct BOARD_CTRL __iomem *board_ctrl;
-  unsigned long __iomem *pci_doorbell;
-  int index;
-
-    firm_id = cinfo->base_addr + ID_ADDRESS;
-    if (!ISZLOADED(*cinfo)){
-	return (-1);
-    }
-    zfw_ctrl = cinfo->base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
-    board_ctrl = &zfw_ctrl->board_ctrl;
-
-    index = 0;
-    pci_doorbell = &((struct RUNTIME_9060 __iomem *) (cinfo->ctl_addr))->pci_doorbell;
-    while( (cy_readl(pci_doorbell) & 0xff) != 0){
-        if (index++ == 1000){
-	    return((int)(cy_readl(pci_doorbell) & 0xff));
-        }
-	udelay(50L);
-    }
-    cy_writel(&board_ctrl->hcmd_channel, channel);
-    cy_writel(&board_ctrl->hcmd_param , param);
-    cy_writel(pci_doorbell, (long)cmd);
+	struct FIRM_ID __iomem *firm_id;
+	struct ZFW_CTRL __iomem *zfw_ctrl;
+	struct BOARD_CTRL __iomem *board_ctrl;
+	unsigned long __iomem *pci_doorbell;
+	int index;
@@ -1507,2 +1538,23 @@
-    return(0);
-} /* cyz_issue_cmd */
+	firm_id = cinfo->base_addr + ID_ADDRESS;
+	if (!ISZLOADED(*cinfo)) {
+		return -1;
+	}
+	zfw_ctrl = cinfo->base_addr + (cy_readl(&firm_id->zfwctrl_addr) &
+			0xfffff);
+	board_ctrl = &zfw_ctrl->board_ctrl;
+
+	index = 0;
+	pci_doorbell =
+	    &((struct RUNTIME_9060 __iomem *)(cinfo->ctl_addr))->pci_doorbell;
+	while ((cy_readl(pci_doorbell) & 0xff) != 0) {
+		if (index++ == 1000) {
+			return (int)(cy_readl(pci_doorbell) & 0xff);
+		}
+		udelay(50L);
+	}
+	cy_writel(&board_ctrl->hcmd_channel, channel);
+	cy_writel(&board_ctrl->hcmd_param, param);
+	cy_writel(pci_doorbell, (long)cmd);
+
+	return 0;
+}				/* cyz_issue_cmd */
@@ -1512,2 +1564,2 @@
-	      volatile struct CH_CTRL __iomem *ch_ctrl,
-	      volatile struct BUF_CTRL __iomem *buf_ctrl)
+		volatile struct CH_CTRL __iomem * ch_ctrl,
+		volatile struct BUF_CTRL __iomem * buf_ctrl)
@@ -1515,4 +1567,4 @@
-  struct cyclades_card *cinfo = &cy_card[info->card];
-  struct tty_struct *tty = info->tty;
-  volatile int char_count;
-  int len;
+	struct cyclades_card *cinfo = &cy_card[info->card];
+	struct tty_struct *tty = info->tty;
+	volatile int char_count;
+	int len;
@@ -1520 +1572 @@
-  int small_count;
+	int small_count;
@@ -1522 +1574 @@
-  char data;
+	char data;
@@ -1524 +1576,10 @@
-  volatile uclong rx_put, rx_get, new_rx_get, rx_bufsize, rx_bufaddr;
+	volatile uclong rx_put, rx_get, new_rx_get, rx_bufsize, rx_bufaddr;
+
+	rx_get = new_rx_get = cy_readl(&buf_ctrl->rx_get);
+	rx_put = cy_readl(&buf_ctrl->rx_put);
+	rx_bufsize = cy_readl(&buf_ctrl->rx_bufsize);
+	rx_bufaddr = cy_readl(&buf_ctrl->rx_bufaddr);
+	if (rx_put >= rx_get)
+		char_count = rx_put - rx_get;
+	else
+		char_count = rx_put - rx_get + rx_bufsize;
@@ -1526,12 +1587,3 @@
-    rx_get = new_rx_get = cy_readl(&buf_ctrl->rx_get);
-    rx_put = cy_readl(&buf_ctrl->rx_put);
-    rx_bufsize = cy_readl(&buf_ctrl->rx_bufsize);
-    rx_bufaddr = cy_readl(&buf_ctrl->rx_bufaddr);
-    if (rx_put >= rx_get)
-	char_count = rx_put - rx_get;
-    else
-	char_count = rx_put - rx_get + rx_bufsize;
-
-    if ( char_count ) {
-	info->last_active = jiffies;
-	info->jiffies[1] = jiffies;
+	if (char_count) {
+		info->last_active = jiffies;
+		info->jiffies[1] = jiffies;
@@ -1540,11 +1592,12 @@
-	info->mon.int_count++;
-	info->mon.char_count += char_count;
-	if (char_count > info->mon.char_max)
-	    info->mon.char_max = char_count;
-	info->mon.char_last = char_count;
-#endif
-	if(tty == 0){
-	    /* flush received characters */
-	    new_rx_get = (new_rx_get + char_count) & (rx_bufsize - 1);
-	    info->rflush_count++;
-	}else{
+		info->mon.int_count++;
+		info->mon.char_count += char_count;
+		if (char_count > info->mon.char_max)
+			info->mon.char_max = char_count;
+		info->mon.char_last = char_count;
+#endif
+		if (tty == 0) {
+			/* flush received characters */
+			new_rx_get = (new_rx_get + char_count) &
+					(rx_bufsize - 1);
+			info->rflush_count++;
+		} else {
@@ -1552,21 +1605,23 @@
-	    /* we'd like to use memcpy(t, f, n) and memset(s, c, count)
-	       for performance, but because of buffer boundaries, there
-	       may be several steps to the operation */
-	    while(0 < (small_count = 
-		       min_t(unsigned int, (rx_bufsize - new_rx_get),
-		       min_t(unsigned int, (TTY_FLIPBUF_SIZE - tty->flip.count), char_count))
-		 )) {
-		memcpy_fromio(tty->flip.char_buf_ptr,
-			      (char *)(cinfo->base_addr
-				       + rx_bufaddr + new_rx_get),
-			      small_count);
-
-		tty->flip.char_buf_ptr += small_count;
-		memset(tty->flip.flag_buf_ptr, TTY_NORMAL, small_count);
-		tty->flip.flag_buf_ptr += small_count;
-		new_rx_get = (new_rx_get + small_count) & (rx_bufsize - 1);
-		char_count -= small_count;
-		info->icount.rx += small_count;
-		info->idle_stats.recv_bytes += small_count;
-		tty->flip.count += small_count;
-	    }
+		/* we'd like to use memcpy(t, f, n) and memset(s, c, count)
+		   for performance, but because of buffer boundaries, there
+		   may be several steps to the operation */
+			while (0 < (small_count = min_t(unsigned int,
+					rx_bufsize - new_rx_get,
+					min_t(unsigned int, TTY_FLIPBUF_SIZE -
+						tty->flip.count, char_count)))){
+				memcpy_fromio(tty->flip.char_buf_ptr,
+					(char *)(cinfo->base_addr + rx_bufaddr +
+						new_rx_get),
+					small_count);
+
+				tty->flip.char_buf_ptr += small_count;
+				memset(tty->flip.flag_buf_ptr, TTY_NORMAL,
+					small_count);
+				tty->flip.flag_buf_ptr += small_count;
+				new_rx_get = (new_rx_get + small_count) &
+						(rx_bufsize - 1);
+				char_count -= small_count;
+				info->icount.rx += small_count;
+				info->idle_stats.recv_bytes += small_count;
+				tty->flip.count += small_count;
+			}
@@ -1574,8 +1629,9 @@
-	    len = tty_buffer_request_room(tty, char_count);
-	    while(len--){
-		data = cy_readb(cinfo->base_addr + rx_bufaddr + new_rx_get);
-		new_rx_get = (new_rx_get + 1) & (rx_bufsize - 1);
-		tty_insert_flip_char(tty, data, TTY_NORMAL);
-		info->idle_stats.recv_bytes++;
-		info->icount.rx++;
-	    }
+			len = tty_buffer_request_room(tty, char_count);
+			while (len--) {
+				data = cy_readb(cinfo->base_addr + rx_bufaddr +
+						new_rx_get);
+				new_rx_get = (new_rx_get + 1)& (rx_bufsize - 1);
+				tty_insert_flip_char(tty, data, TTY_NORMAL);
+				info->idle_stats.recv_bytes++;
+				info->icount.rx++;
+			}
@@ -1584,17 +1640,18 @@
-	    /* Recalculate the number of chars in the RX buffer and issue
-	       a cmd in case it's higher than the RX high water mark */
-	    rx_put = cy_readl(&buf_ctrl->rx_put);
-	    if (rx_put >= rx_get)
-		char_count = rx_put - rx_get;
-	    else
-		char_count = rx_put - rx_get + rx_bufsize;
-	    if(char_count >= cy_readl(&buf_ctrl->rx_threshold)) {
-		cy_sched_event(info, Cy_EVENT_Z_RX_FULL);
-	    }
-#endif
-	    info->idle_stats.recv_idle = jiffies;
-	    tty_schedule_flip(tty);
-	}
-	/* Update rx_get */
-	cy_writel(&buf_ctrl->rx_get, new_rx_get);
-    }
+		/* Recalculate the number of chars in the RX buffer and issue
+		   a cmd in case it's higher than the RX high water mark */
+			rx_put = cy_readl(&buf_ctrl->rx_put);
+			if (rx_put >= rx_get)
+				char_count = rx_put - rx_get;
+			else
+				char_count = rx_put - rx_get + rx_bufsize;
+			if (char_count >= (int)cy_readl(&buf_ctrl->
+					rx_threshold)) {
+				cy_sched_event(info, Cy_EVENT_Z_RX_FULL);
+			}
+#endif
+			info->idle_stats.recv_idle = jiffies;
+			tty_schedule_flip(tty);
+		}
+		/* Update rx_get */
+		cy_writel(&buf_ctrl->rx_get, new_rx_get);
+	}
@@ -1605,2 +1662,2 @@
-	      volatile struct CH_CTRL __iomem *ch_ctrl,
-	      volatile struct BUF_CTRL __iomem *buf_ctrl)
+		volatile struct CH_CTRL __iomem * ch_ctrl,
+		volatile struct BUF_CTRL __iomem * buf_ctrl)
@@ -1608,4 +1665,4 @@
-  struct cyclades_card *cinfo = &cy_card[info->card];
-  struct tty_struct *tty = info->tty;
-  char data;
-  volatile int char_count;
+	struct cyclades_card *cinfo = &cy_card[info->card];
+	struct tty_struct *tty = info->tty;
+	char data;
+	volatile int char_count;
@@ -1613 +1670 @@
-  int small_count;
+	int small_count;
@@ -1615 +1672 @@
-  volatile uclong tx_put, tx_get, tx_bufsize, tx_bufaddr;
+	volatile uclong tx_put, tx_get, tx_bufsize, tx_bufaddr;
@@ -1617,2 +1674,2 @@
-    if (info->xmit_cnt <= 0)	/* Nothing to transmit */
-	return;
+	if (info->xmit_cnt <= 0)	/* Nothing to transmit */
+		return;
@@ -1620,26 +1677,26 @@
-    tx_get = cy_readl(&buf_ctrl->tx_get);
-    tx_put = cy_readl(&buf_ctrl->tx_put);
-    tx_bufsize = cy_readl(&buf_ctrl->tx_bufsize);
-    tx_bufaddr = cy_readl(&buf_ctrl->tx_bufaddr);
-    if (tx_put >= tx_get)
-	char_count = tx_get - tx_put - 1 + tx_bufsize;
-    else
-	char_count = tx_get - tx_put - 1;
-
-    if ( char_count ) {
-
-	if( tty == 0 ){
-	    goto ztxdone;
-	}
-
-	if(info->x_char) { /* send special char */
-	    data = info->x_char;
-
-	    cy_writeb((cinfo->base_addr + tx_bufaddr + tx_put), data);
-	    tx_put = (tx_put + 1) & (tx_bufsize - 1);
-	    info->x_char = 0;
-	    char_count--;
-	    info->icount.tx++;
-	    info->last_active = jiffies;
-	    info->jiffies[2] = jiffies;
-	}
+	tx_get = cy_readl(&buf_ctrl->tx_get);
+	tx_put = cy_readl(&buf_ctrl->tx_put);
+	tx_bufsize = cy_readl(&buf_ctrl->tx_bufsize);
+	tx_bufaddr = cy_readl(&buf_ctrl->tx_bufaddr);
+	if (tx_put >= tx_get)
+		char_count = tx_get - tx_put - 1 + tx_bufsize;
+	else
+		char_count = tx_get - tx_put - 1;
+
+	if (char_count) {
+
+		if (tty == 0) {
+			goto ztxdone;
+		}
+
+		if (info->x_char) {	/* send special char */
+			data = info->x_char;
+
+			cy_writeb(cinfo->base_addr + tx_bufaddr + tx_put, data);
+			tx_put = (tx_put + 1) & (tx_bufsize - 1);
+			info->x_char = 0;
+			char_count--;
+			info->icount.tx++;
+			info->last_active = jiffies;
+			info->jiffies[2] = jiffies;
+		}
@@ -1647,18 +1704,20 @@
-	while(0 < (small_count = 
-		   min_t(unsigned int, (tx_bufsize - tx_put),
-		       min_t(unsigned int, (SERIAL_XMIT_SIZE - info->xmit_tail),
-			   min_t(unsigned int, info->xmit_cnt, char_count))))) {
-
-	    memcpy_toio((char *)(cinfo->base_addr + tx_bufaddr + tx_put),
-			&info->xmit_buf[info->xmit_tail],
-			small_count);
-
-	    tx_put = (tx_put + small_count) & (tx_bufsize - 1);
-	    char_count -= small_count;
-	    info->icount.tx += small_count;
-	    info->xmit_cnt -= small_count;
-	    info->xmit_tail = 
-		(info->xmit_tail + small_count) & (SERIAL_XMIT_SIZE - 1);
-	    info->last_active = jiffies;
-	    info->jiffies[2] = jiffies;
-	}
+		while (0 < (small_count = min_t(unsigned int,
+				tx_bufsize - tx_put, min_t(unsigned int,
+					(SERIAL_XMIT_SIZE - info->xmit_tail),
+					min_t(unsigned int, info->xmit_cnt,
+						char_count))))) {
+
+			memcpy_toio((char *)(cinfo->base_addr + tx_bufaddr +
+					tx_put),
+					&info->xmit_buf[info->xmit_tail],
+					small_count);
+
+			tx_put = (tx_put + small_count) & (tx_bufsize - 1);
+			char_count -= small_count;
+			info->icount.tx += small_count;
+			info->xmit_cnt -= small_count;
+			info->xmit_tail = (info->xmit_tail + small_count) &
+					(SERIAL_XMIT_SIZE - 1);
+			info->last_active = jiffies;
+			info->jiffies[2] = jiffies;
+		}
@@ -1666,20 +1725,21 @@
-	while (info->xmit_cnt && char_count){
-	    data = info->xmit_buf[info->xmit_tail];
-	    info->xmit_cnt--;
-	    info->xmit_tail = (info->xmit_tail + 1) & (SERIAL_XMIT_SIZE - 1);
-
-	    cy_writeb(cinfo->base_addr + tx_bufaddr + tx_put, data);
-	    tx_put = (tx_put + 1) & (tx_bufsize - 1);
-	    char_count--;
-	    info->icount.tx++;
-	    info->last_active = jiffies;
-	    info->jiffies[2] = jiffies;
-	}
-#endif
-    ztxdone:
-	if (info->xmit_cnt < WAKEUP_CHARS) {
-	    cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
-	}
-	/* Update tx_put */
-	cy_writel(&buf_ctrl->tx_put, tx_put);
-    }
+		while (info->xmit_cnt && char_count) {
+			data = info->xmit_buf[info->xmit_tail];
+			info->xmit_cnt--;
+			info->xmit_tail = (info->xmit_tail + 1) &
+					(SERIAL_XMIT_SIZE - 1);
+
+			cy_writeb(cinfo->base_addr + tx_bufaddr + tx_put, data);
+			tx_put = (tx_put + 1) & (tx_bufsize - 1);
+			char_count--;
+			info->icount.tx++;
+			info->last_active = jiffies;
+			info->jiffies[2] = jiffies;
+		}
+#endif
+ztxdone:
+		if (info->xmit_cnt < WAKEUP_CHARS) {
+			cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
+		}
+		/* Update tx_put */
+		cy_writel(&buf_ctrl->tx_put, tx_put);
+	}
@@ -1688,2 +1748 @@
-static void
-cyz_handle_cmd(struct cyclades_card *cinfo)
+static void cyz_handle_cmd(struct cyclades_card *cinfo)
@@ -1691,58 +1750,28 @@
-  struct tty_struct *tty;
-  struct cyclades_port *info;
-  static volatile struct FIRM_ID __iomem *firm_id;
-  static volatile struct ZFW_CTRL __iomem *zfw_ctrl;
-  static volatile struct BOARD_CTRL __iomem *board_ctrl;
-  static volatile struct CH_CTRL __iomem *ch_ctrl;
-  static volatile struct BUF_CTRL __iomem *buf_ctrl;
-  uclong channel;
-  ucchar cmd;
-  uclong param;
-  uclong hw_ver, fw_ver;
-  int special_count;
-  int delta_count;
-
-    firm_id = cinfo->base_addr + ID_ADDRESS;
-    zfw_ctrl = cinfo->base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
-    board_ctrl = &zfw_ctrl->board_ctrl;
-    fw_ver = cy_readl(&board_ctrl->fw_version);
-    hw_ver = cy_readl(&((struct RUNTIME_9060 __iomem *)(cinfo->ctl_addr))->mail_box_0);
-
-
-    while(cyz_fetch_msg(cinfo, &channel, &cmd, &param) == 1) {
-	special_count = 0;
-	delta_count = 0;
-	info = &cy_port[channel + cinfo->first_line];
-	if((tty = info->tty) == 0) {
-	    continue;
-	}
-	ch_ctrl = &(zfw_ctrl->ch_ctrl[channel]);
-	buf_ctrl = &(zfw_ctrl->buf_ctrl[channel]);
-
-	switch(cmd) {
-	    case C_CM_PR_ERROR:
-		tty_insert_flip_char(tty, 0, TTY_PARITY);
-		info->icount.rx++;
-		special_count++;
-		break;
-	    case C_CM_FR_ERROR:
-		tty_insert_flip_char(tty, 0, TTY_FRAME);
-		info->icount.rx++;
-		special_count++;
-		break;
-	    case C_CM_RXBRK:
-		tty_insert_flip_char(tty, 0, TTY_BREAK);
-		info->icount.rx++;
-		special_count++;
-		break;
-	    case C_CM_MDCD:
-		info->icount.dcd++;
-		delta_count++;
-		if (info->flags & ASYNC_CHECK_CD){
-		    if ((fw_ver > 241 ? 
-			  ((u_long)param) : 
-			  cy_readl(&ch_ctrl->rs_status)) & C_RS_DCD) {
-			cy_sched_event(info, Cy_EVENT_OPEN_WAKEUP);
-		    }else{
-			cy_sched_event(info, Cy_EVENT_HANGUP);
-		    }
+	struct tty_struct *tty;
+	struct cyclades_port *info;
+	static volatile struct FIRM_ID __iomem *firm_id;
+	static volatile struct ZFW_CTRL __iomem *zfw_ctrl;
+	static volatile struct BOARD_CTRL __iomem *board_ctrl;
+	static volatile struct CH_CTRL __iomem *ch_ctrl;
+	static volatile struct BUF_CTRL __iomem *buf_ctrl;
+	uclong channel;
+	ucchar cmd;
+	uclong param;
+	uclong hw_ver, fw_ver;
+	int special_count;
+	int delta_count;
+
+	firm_id = cinfo->base_addr + ID_ADDRESS;
+	zfw_ctrl = cinfo->base_addr + (cy_readl(&firm_id->zfwctrl_addr) &
+			0xfffff);
+	board_ctrl = &zfw_ctrl->board_ctrl;
+	fw_ver = cy_readl(&board_ctrl->fw_version);
+	hw_ver = cy_readl(&((struct RUNTIME_9060 __iomem *)(cinfo->ctl_addr))->
+			mail_box_0);
+
+	while (cyz_fetch_msg(cinfo, &channel, &cmd, &param) == 1) {
+		special_count = 0;
+		delta_count = 0;
+		info = &cy_port[channel + cinfo->first_line];
+		if ((tty = info->tty) == 0) {
+			continue;
@@ -1750,13 +1779,45 @@
-		break;
-	    case C_CM_MCTS:
-		info->icount.cts++;
-		delta_count++;
-		break;
-	    case C_CM_MRI:
-		info->icount.rng++;
-		delta_count++;
-		break;
-	    case C_CM_MDSR:
-		info->icount.dsr++;
-		delta_count++;
-		break;
+		ch_ctrl = &(zfw_ctrl->ch_ctrl[channel]);
+		buf_ctrl = &(zfw_ctrl->buf_ctrl[channel]);
+
+		switch (cmd) {
+		case C_CM_PR_ERROR:
+			tty_insert_flip_char(tty, 0, TTY_PARITY);
+			info->icount.rx++;
+			special_count++;
+			break;
+		case C_CM_FR_ERROR:
+			tty_insert_flip_char(tty, 0, TTY_FRAME);
+			info->icount.rx++;
+			special_count++;
+			break;
+		case C_CM_RXBRK:
+			tty_insert_flip_char(tty, 0, TTY_BREAK);
+			info->icount.rx++;
+			special_count++;
+			break;
+		case C_CM_MDCD:
+			info->icount.dcd++;
+			delta_count++;
+			if (info->flags & ASYNC_CHECK_CD) {
+				if ((fw_ver > 241 ? ((u_long) param) :
+						cy_readl(&ch_ctrl->rs_status)) &
+						C_RS_DCD) {
+					cy_sched_event(info,
+						 	Cy_EVENT_OPEN_WAKEUP);
+				} else {
+					cy_sched_event(info, Cy_EVENT_HANGUP);
+				}
+			}
+			break;
+		case C_CM_MCTS:
+			info->icount.cts++;
+			delta_count++;
+			break;
+		case C_CM_MRI:
+			info->icount.rng++;
+			delta_count++;
+			break;
+		case C_CM_MDSR:
+			info->icount.dsr++;
+			delta_count++;
+			break;
@@ -1764,3 +1825,3 @@
-	    case C_CM_IOCTLW:
-		cy_sched_event(info, Cy_EVENT_SHUTDOWN_WAKEUP);
-		break;
+		case C_CM_IOCTLW:
+			cy_sched_event(info, Cy_EVENT_SHUTDOWN_WAKEUP);
+			break;
@@ -1769,4 +1830,4 @@
-	    case C_CM_RXHIWM:
-	    case C_CM_RXNNDT:
-	    case C_CM_INTBACK2:
-		/* Reception Interrupt */
+		case C_CM_RXHIWM:
+		case C_CM_RXNNDT:
+		case C_CM_INTBACK2:
+			/* Reception Interrupt */
@@ -1774,2 +1835,2 @@
-		printk("cyz_interrupt: rcvd intr, card %d, port %ld\n\r", 
-			info->card, channel);
+			printk("cyz_interrupt: rcvd intr, card %d, "
+					"port %ld\n\r", info->card, channel);
@@ -1777,6 +1838,6 @@
-		cyz_handle_rx(info, ch_ctrl, buf_ctrl);
-		break;
-	    case C_CM_TXBEMPTY:
-	    case C_CM_TXLOWWM:
-	    case C_CM_INTBACK:
-		/* Transmission Interrupt */
+			cyz_handle_rx(info, ch_ctrl, buf_ctrl);
+			break;
+		case C_CM_TXBEMPTY:
+		case C_CM_TXLOWWM:
+		case C_CM_INTBACK:
+			/* Transmission Interrupt */
@@ -1784,2 +1845,2 @@
-		printk("cyz_interrupt: xmit intr, card %d, port %ld\n\r", 
-			info->card, channel);
+			printk("cyz_interrupt: xmit intr, card %d, "
+					"port %ld\n\r", info->card, channel);
@@ -1787,8 +1848,13 @@
-		cyz_handle_tx(info, ch_ctrl, buf_ctrl);
-		break;
-#endif /* CONFIG_CYZ_INTR */
-	    case C_CM_FATAL:
-		/* should do something with this !!! */
-		break;
-	    default:
-		break;
+			cyz_handle_tx(info, ch_ctrl, buf_ctrl);
+			break;
+#endif				/* CONFIG_CYZ_INTR */
+		case C_CM_FATAL:
+			/* should do something with this !!! */
+			break;
+		default:
+			break;
+		}
+		if (delta_count)
+			cy_sched_event(info, Cy_EVENT_DELTA_WAKEUP);
+		if (special_count)
+			tty_schedule_flip(tty);
@@ -1796,5 +1861,0 @@
-	if(delta_count)
-	    cy_sched_event(info, Cy_EVENT_DELTA_WAKEUP);
-	if(special_count)
-	    tty_schedule_flip(tty);
-    }
@@ -1804,2 +1865 @@
-static irqreturn_t
-cyz_interrupt(int irq, void *dev_id)
+static irqreturn_t cyz_interrupt(int irq, void *dev_id)
@@ -1807 +1867 @@
-  struct cyclades_card *cinfo;
+	struct cyclades_card *cinfo;
@@ -1809 +1869 @@
-    if((cinfo = (struct cyclades_card *)dev_id) == 0){
+	if ((cinfo = (struct cyclades_card *)dev_id) == 0) {
@@ -1811 +1871 @@
-	printk("cyz_interrupt: spurious interrupt %d\n\r", irq);
+		printk("cyz_interrupt: spurious interrupt %d\n\r", irq);
@@ -1813,2 +1873,2 @@
-        return IRQ_NONE; /* spurious interrupt */
-    }
+		return IRQ_NONE;	/* spurious interrupt */
+	}
@@ -1816 +1876 @@
-    if (!ISZLOADED(*cinfo)) {
+	if (!ISZLOADED(*cinfo)) {
@@ -1818 +1878 @@
-	printk("cyz_interrupt: board not yet loaded (IRQ%d).\n\r", irq);
+		printk("cyz_interrupt: board not yet loaded (IRQ%d).\n\r", irq);
@@ -1820,2 +1880,2 @@
-	return IRQ_NONE;
-    }
+		return IRQ_NONE;
+	}
@@ -1823,2 +1883,2 @@
-    /* Handle the interrupts */
-    cyz_handle_cmd(cinfo);
+	/* Handle the interrupts */
+	cyz_handle_cmd(cinfo);
@@ -1826,2 +1886,2 @@
-    return IRQ_HANDLED;
-} /* cyz_interrupt */
+	return IRQ_HANDLED;
+}				/* cyz_interrupt */
@@ -1829,2 +1889 @@
-static void
-cyz_rx_restart(unsigned long arg)
+static void cyz_rx_restart(unsigned long arg)
@@ -1832,14 +1891,14 @@
-    struct cyclades_port *info = (struct cyclades_port *)arg;
-    int retval;
-    int card = info->card;
-    uclong channel = (info->line) - (cy_card[card].first_line);
-    unsigned long flags;
-
-    CY_LOCK(info, flags);
-    retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_INTBACK2, 0L);
-    if (retval != 0){
-	printk("cyc:cyz_rx_restart retval on ttyC%d was %x\n", 
-	       info->line, retval);
-    }
-    cyz_rx_full_timer[info->line].function = NULL;
-    CY_UNLOCK(info, flags);
+	struct cyclades_port *info = (struct cyclades_port *)arg;
+	int retval;
+	int card = info->card;
+	uclong channel = (info->line) - (cy_card[card].first_line);
+	unsigned long flags;
+
+	CY_LOCK(info, flags);
+	retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_INTBACK2, 0L);
+	if (retval != 0) {
+		printk("cyc:cyz_rx_restart retval on ttyC%d was %x\n",
+			info->line, retval);
+	}
+	cyz_rx_full_timer[info->line].function = NULL;
+	CY_UNLOCK(info, flags);
@@ -1848 +1907 @@
-#else /* CONFIG_CYZ_INTR */
+#else				/* CONFIG_CYZ_INTR */
@@ -1850,2 +1909 @@
-static void
-cyz_poll(unsigned long arg)
+static void cyz_poll(unsigned long arg)
@@ -1853,13 +1911,9 @@
-  struct cyclades_card *cinfo;
-  struct cyclades_port *info;
-  struct tty_struct *tty;
-  static volatile struct FIRM_ID *firm_id;
-  static volatile struct ZFW_CTRL *zfw_ctrl;
-  static volatile struct BOARD_CTRL *board_ctrl;
-  static volatile struct CH_CTRL *ch_ctrl;
-  static volatile struct BUF_CTRL *buf_ctrl;
-  int card, port;
-
-    cyz_timerlist.expires = jiffies + (HZ);
-    for (card = 0 ; card < NR_CARDS ; card++){
-	cinfo = &cy_card[card];
+	struct cyclades_card *cinfo;
+	struct cyclades_port *info;
+	struct tty_struct *tty;
+	static volatile struct FIRM_ID *firm_id;
+	static volatile struct ZFW_CTRL *zfw_ctrl;
+	static volatile struct BOARD_CTRL *board_ctrl;
+	static volatile struct CH_CTRL *ch_ctrl;
+	static volatile struct BUF_CTRL *buf_ctrl;
+	int card, port;
@@ -1867,2 +1921,3 @@
-	if (!IS_CYC_Z(*cinfo)) continue;
-	if (!ISZLOADED(*cinfo)) continue;
+	cyz_timerlist.expires = jiffies + (HZ);
+	for (card = 0; card < NR_CARDS; card++) {
+		cinfo = &cy_card[card];
@@ -1870,3 +1925,4 @@
-	firm_id = cinfo->base_addr + ID_ADDRESS;
-	zfw_ctrl = cinfo->base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
-	board_ctrl = &(zfw_ctrl->board_ctrl);
+		if (!IS_CYC_Z(*cinfo))
+			continue;
+		if (!ISZLOADED(*cinfo))
+			continue;
@@ -1874,6 +1930,4 @@
-	/* Skip first polling cycle to avoid racing conditions with the FW */
-	if (!cinfo->intr_enabled) {
-	    cinfo->nports = (int) cy_readl(&board_ctrl->n_channel);
-	    cinfo->intr_enabled = 1;
-	    continue;
-	}
+		firm_id = cinfo->base_addr + ID_ADDRESS;
+		zfw_ctrl = cinfo->base_addr +
+				(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		board_ctrl = &(zfw_ctrl->board_ctrl);
@@ -1881 +1935,6 @@
-	cyz_handle_cmd(cinfo);
+	/* Skip first polling cycle to avoid racing conditions with the FW */
+		if (!cinfo->intr_enabled) {
+			cinfo->nports = (int)cy_readl(&board_ctrl->n_channel);
+			cinfo->intr_enabled = 1;
+			continue;
+		}
@@ -1883,14 +1942 @@
-	for (port = 0 ; port < cinfo->nports ; port++) {
-	    info = &cy_port[ port + cinfo->first_line ];
-            tty = info->tty;
-	    ch_ctrl = &(zfw_ctrl->ch_ctrl[port]);
-	    buf_ctrl = &(zfw_ctrl->buf_ctrl[port]);
-
-	    if (!info->throttle)
-	        cyz_handle_rx(info, ch_ctrl, buf_ctrl);
-	    cyz_handle_tx(info, ch_ctrl, buf_ctrl);
-	}
-	/* poll every 'cyz_polling_cycle' period */
-	cyz_timerlist.expires = jiffies + cyz_polling_cycle;
-    }
-    add_timer(&cyz_timerlist);
+		cyz_handle_cmd(cinfo);
@@ -1898,2 +1944,15 @@
-    return;
-} /* cyz_poll */
+		for (port = 0; port < cinfo->nports; port++) {
+			info = &cy_port[port + cinfo->first_line];
+			tty = info->tty;
+			ch_ctrl = &(zfw_ctrl->ch_ctrl[port]);
+			buf_ctrl = &(zfw_ctrl->buf_ctrl[port]);
+
+			if (!info->throttle)
+				cyz_handle_rx(info, ch_ctrl, buf_ctrl);
+			cyz_handle_tx(info, ch_ctrl, buf_ctrl);
+		}
+		/* poll every 'cyz_polling_cycle' period */
+		cyz_timerlist.expires = jiffies + cyz_polling_cycle;
+	}
+	add_timer(&cyz_timerlist);
+}				/* cyz_poll */
@@ -1901 +1960 @@
-#endif /* CONFIG_CYZ_INTR */
+#endif				/* CONFIG_CYZ_INTR */
@@ -1906 +1964,0 @@
-
@@ -1910,2 +1968 @@
-static int
-startup(struct cyclades_port * info)
+static int startup(struct cyclades_port *info)
@@ -1913,42 +1970,5 @@
-  unsigned long flags;
-  int retval = 0;
-  void __iomem *base_addr;
-  int card,chip,channel,index;
-  unsigned long page;
-
-    card = info->card;
-    channel = (info->line) - (cy_card[card].first_line);
-
-    page = get_zeroed_page(GFP_KERNEL);
-    if (!page)
-	return -ENOMEM;
-
-    CY_LOCK(info, flags);
-
-    if (info->flags & ASYNC_INITIALIZED){
-	free_page(page);
-	goto errout;
-    }
-
-    if (!info->type){
-        if (info->tty){
-            set_bit(TTY_IO_ERROR, &info->tty->flags);
-        }
-	free_page(page);
-	goto errout;
-    }
-
-    if (info->xmit_buf)
-	free_page(page);
-    else
-	info->xmit_buf = (unsigned char *) page;
-
-    CY_UNLOCK(info, flags);
-
-    set_line_char(info);
-
-    if (!IS_CYC_Z(cy_card[card])) {
-	chip = channel>>2;
-	channel &= 0x03;
-	index = cy_card[card].bus_index;
-	base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
+	unsigned long flags;
+	int retval = 0;
+	void __iomem *base_addr;
+	int card, chip, channel, index;
+	unsigned long page;
@@ -1956,4 +1976,6 @@
-#ifdef CY_DEBUG_OPEN
-	printk("cyc startup card %d, chip %d, channel %d, base_addr %lx\n",
-	     card, chip, channel, (long)base_addr);/**/
-#endif
+	card = info->card;
+	channel = (info->line) - (cy_card[card].first_line);
+
+	page = get_zeroed_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
@@ -1963 +1985,21 @@
-	cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
+	if (info->flags & ASYNC_INITIALIZED) {
+		free_page(page);
+		goto errout;
+	}
+
+	if (!info->type) {
+		if (info->tty) {
+			set_bit(TTY_IO_ERROR, &info->tty->flags);
+		}
+		free_page(page);
+		goto errout;
+	}
+
+	if (info->xmit_buf)
+		free_page(page);
+	else
+		info->xmit_buf = (unsigned char *)page;
+
+	CY_UNLOCK(info, flags);
+
+	set_line_char(info);
@@ -1965,2 +2007,14 @@
-	cy_writeb(base_addr+(CyRTPR<<index), (info->default_timeout
-		 ? info->default_timeout : 0x02)); /* 10ms rx timeout */
+	if (!IS_CYC_Z(cy_card[card])) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		index = cy_card[card].bus_index;
+		base_addr = cy_card[card].base_addr +
+				(cy_chip_offset[chip] << index);
+
+#ifdef CY_DEBUG_OPEN
+		printk("cyc startup card %d, chip %d, channel %d, "
+				"base_addr %lx\n",
+				card, chip, channel, (long)base_addr);
+		/**/
+#endif
+		CY_LOCK(info, flags);
@@ -1968 +2022 @@
-	cyy_issue_cmd(base_addr,CyCHAN_CTL|CyENB_RCVR|CyENB_XMTR,index);
+		cy_writeb(base_addr + (CyCAR << index), (u_char) channel);
@@ -1970,3 +2024,10 @@
-	cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
-	cy_writeb(base_addr+(CyMSVR1<<index), CyRTS);
-	cy_writeb(base_addr+(CyMSVR2<<index), CyDTR);
+		cy_writeb(base_addr + (CyRTPR << index),
+			(info->default_timeout ? info->default_timeout : 0x02));
+		/* 10ms rx timeout */
+
+		cyy_issue_cmd(base_addr, CyCHAN_CTL | CyENB_RCVR | CyENB_XMTR,
+				index);
+
+		cy_writeb(base_addr + (CyCAR << index), (u_char) channel);
+		cy_writeb(base_addr + (CyMSVR1 << index), CyRTS);
+		cy_writeb(base_addr + (CyMSVR2 << index), CyDTR);
@@ -1975,4 +2036,4 @@
-	printk("cyc:startup raising DTR\n");
-	printk("     status: 0x%x, 0x%x\n",
-		cy_readb(base_addr+(CyMSVR1<<index)), 
-                cy_readb(base_addr+(CyMSVR2<<index)));
+		printk("cyc:startup raising DTR\n");
+		printk("     status: 0x%x, 0x%x\n",
+			cy_readb(base_addr + (CyMSVR1 << index)),
+			cy_readb(base_addr + (CyMSVR2 << index)));
@@ -1981,3 +2042,3 @@
-	cy_writeb(base_addr+(CySRER<<index),
-		cy_readb(base_addr+(CySRER<<index)) | CyRxData);
-	info->flags |= ASYNC_INITIALIZED;
+		cy_writeb(base_addr + (CySRER << index),
+			cy_readb(base_addr + (CySRER << index)) | CyRxData);
+		info->flags |= ASYNC_INITIALIZED;
@@ -1985,9 +2046,9 @@
-	if (info->tty){
-	    clear_bit(TTY_IO_ERROR, &info->tty->flags);
-	}
-	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
-	info->breakon = info->breakoff = 0;
-	memset((char *)&info->idle_stats, 0, sizeof(info->idle_stats));
-	info->idle_stats.in_use    =
-	info->idle_stats.recv_idle =
-	info->idle_stats.xmit_idle = jiffies;
+		if (info->tty) {
+			clear_bit(TTY_IO_ERROR, &info->tty->flags);
+		}
+		info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
+		info->breakon = info->breakoff = 0;
+		memset((char *)&info->idle_stats, 0, sizeof(info->idle_stats));
+		info->idle_stats.in_use =
+		info->idle_stats.recv_idle =
+		info->idle_stats.xmit_idle = jiffies;
@@ -1995 +2056 @@
-	CY_UNLOCK(info, flags);
+		CY_UNLOCK(info, flags);
@@ -1997,6 +2058,6 @@
-    } else {
-      struct FIRM_ID __iomem *firm_id;
-      struct ZFW_CTRL __iomem *zfw_ctrl;
-      struct BOARD_CTRL __iomem *board_ctrl;
-      struct CH_CTRL __iomem *ch_ctrl;
-      int retval;
+	} else {
+		struct FIRM_ID __iomem *firm_id;
+		struct ZFW_CTRL __iomem *zfw_ctrl;
+		struct BOARD_CTRL __iomem *board_ctrl;
+		struct CH_CTRL __iomem *ch_ctrl;
+		int retval;
@@ -2004 +2065 @@
-	base_addr = cy_card[card].base_addr;
+		base_addr = cy_card[card].base_addr;
@@ -2006,4 +2067,4 @@
-        firm_id = base_addr + ID_ADDRESS;
-        if (!ISZLOADED(cy_card[card])){
-	    return -ENODEV;
-	}
+		firm_id = base_addr + ID_ADDRESS;
+		if (!ISZLOADED(cy_card[card])) {
+			return -ENODEV;
+		}
@@ -2011,3 +2072,4 @@
-	zfw_ctrl = cy_card[card].base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
-	board_ctrl = &zfw_ctrl->board_ctrl;
-	ch_ctrl = zfw_ctrl->ch_ctrl;
+		zfw_ctrl = cy_card[card].base_addr +
+				(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		board_ctrl = &zfw_ctrl->board_ctrl;
+		ch_ctrl = zfw_ctrl->ch_ctrl;
@@ -2016,2 +2078,3 @@
-	printk("cyc startup Z card %d, channel %d, base_addr %lx\n",
-	     card, channel, (long)base_addr);/**/
+		printk("cyc startup Z card %d, channel %d, base_addr %lx\n",
+			card, channel, (long)base_addr);
+		/**/
@@ -2018,0 +2082 @@
+		CY_LOCK(info, flags);
@@ -2020,3 +2084 @@
-	CY_LOCK(info, flags);
-
-	cy_writel(&ch_ctrl[channel].op_mode, C_CH_ENABLE);
+		cy_writel(&ch_ctrl[channel].op_mode, C_CH_ENABLE);
@@ -2025,4 +2087,3 @@
-	cy_writel(&ch_ctrl[channel].intr_enable, 
-		  C_IN_TXBEMPTY|C_IN_TXLOWWM|C_IN_RXHIWM|C_IN_RXNNDT|
-		  C_IN_IOCTLW|
-		  C_IN_MDCD);
+		cy_writel(&ch_ctrl[channel].intr_enable,
+			  C_IN_TXBEMPTY | C_IN_TXLOWWM | C_IN_RXHIWM |
+			  C_IN_RXNNDT | C_IN_IOCTLW | C_IN_MDCD);
@@ -2030,4 +2091,3 @@
-	cy_writel(&ch_ctrl[channel].intr_enable, 
-		  C_IN_IOCTLW|
-		  C_IN_MDCD);
-#endif /* CONFIG_CYZ_INTR */
+		cy_writel(&ch_ctrl[channel].intr_enable,
+			  C_IN_IOCTLW | C_IN_MDCD);
+#endif				/* CONFIG_CYZ_INTR */
@@ -2036,3 +2096,3 @@
-	cy_writel(&ch_ctrl[channel].intr_enable, 
-		  C_IN_TXBEMPTY|C_IN_TXLOWWM|C_IN_RXHIWM|C_IN_RXNNDT|
-		  C_IN_MDCD);
+		cy_writel(&ch_ctrl[channel].intr_enable,
+			  C_IN_TXBEMPTY | C_IN_TXLOWWM | C_IN_RXHIWM |
+			  C_IN_RXNNDT | C_IN_MDCD);
@@ -2040,4 +2100,9 @@
-	cy_writel(&ch_ctrl[channel].intr_enable, 
-		  C_IN_MDCD);
-#endif /* CONFIG_CYZ_INTR */
-#endif /* Z_WAKE */
+		cy_writel(&ch_ctrl[channel].intr_enable, C_IN_MDCD);
+#endif				/* CONFIG_CYZ_INTR */
+#endif				/* Z_WAKE */
+
+		retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_IOCTL, 0L);
+		if (retval != 0) {
+			printk("cyc:startup(1) retval on ttyC%d was %x\n",
+				info->line, retval);
+		}
@@ -2045,25 +2110,21 @@
-	retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_IOCTL, 0L);
-	if (retval != 0){
-	    printk("cyc:startup(1) retval on ttyC%d was %x\n",
-		   info->line, retval);
-	}
-
-	/* Flush RX buffers before raising DTR and RTS */
-	retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_FLUSH_RX, 0L);
-	if (retval != 0){
-	    printk("cyc:startup(2) retval on ttyC%d was %x\n",
-		   info->line, retval);
-	}
-
-	/* set timeout !!! */
-	/* set RTS and DTR !!! */
-	cy_writel(&ch_ctrl[channel].rs_control,
-             cy_readl(&ch_ctrl[channel].rs_control) | C_RS_RTS | C_RS_DTR) ;
-	retval = cyz_issue_cmd(&cy_card[info->card],
-	    channel, C_CM_IOCTLM, 0L);
-	if (retval != 0){
-	    printk("cyc:startup(3) retval on ttyC%d was %x\n",
-		   info->line, retval);
-	}
-#ifdef CY_DEBUG_DTR
-	    printk("cyc:startup raising Z DTR\n");
+		/* Flush RX buffers before raising DTR and RTS */
+		retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_FLUSH_RX,
+				0L);
+		if (retval != 0) {
+			printk("cyc:startup(2) retval on ttyC%d was %x\n",
+				info->line, retval);
+		}
+
+		/* set timeout !!! */
+		/* set RTS and DTR !!! */
+		cy_writel(&ch_ctrl[channel].rs_control,
+			cy_readl(&ch_ctrl[channel].rs_control) | C_RS_RTS |
+			C_RS_DTR);
+		retval = cyz_issue_cmd(&cy_card[info->card], channel,
+				C_CM_IOCTLM, 0L);
+		if (retval != 0) {
+			printk("cyc:startup(3) retval on ttyC%d was %x\n",
+				info->line, retval);
+		}
+#ifdef CY_DEBUG_DTR
+		printk("cyc:startup raising Z DTR\n");
@@ -2072 +2133 @@
-	/* enable send, recv, modem !!! */
+		/* enable send, recv, modem !!! */
@@ -2074,10 +2135,10 @@
-	info->flags |= ASYNC_INITIALIZED;
-	if (info->tty){
-	    clear_bit(TTY_IO_ERROR, &info->tty->flags);
-	}
-	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
-	info->breakon = info->breakoff = 0;
-	memset((char *)&info->idle_stats, 0, sizeof(info->idle_stats));
-	info->idle_stats.in_use    =
-	info->idle_stats.recv_idle =
-	info->idle_stats.xmit_idle = jiffies;
+		info->flags |= ASYNC_INITIALIZED;
+		if (info->tty) {
+			clear_bit(TTY_IO_ERROR, &info->tty->flags);
+		}
+		info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
+		info->breakon = info->breakoff = 0;
+		memset((char *)&info->idle_stats, 0, sizeof(info->idle_stats));
+		info->idle_stats.in_use =
+		info->idle_stats.recv_idle =
+		info->idle_stats.xmit_idle = jiffies;
@@ -2085,2 +2146,2 @@
-	CY_UNLOCK(info, flags);
-    }
+		CY_UNLOCK(info, flags);
+	}
@@ -2096 +2157 @@
-} /* startup */
+}				/* startup */
@@ -2098,3 +2159 @@
-
-static void
-start_xmit( struct cyclades_port *info )
+static void start_xmit(struct cyclades_port *info)
@@ -2102,11 +2161,3 @@
-  unsigned long flags;
-  void __iomem *base_addr;
-  int card,chip,channel,index;
-
-    card = info->card;
-    channel = (info->line) - (cy_card[card].first_line);
-    if (!IS_CYC_Z(cy_card[card])) {
-	chip = channel>>2;
-	channel &= 0x03;
-	index = cy_card[card].bus_index;
-	base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
+	unsigned long flags;
+	void __iomem *base_addr;
+	int card, chip, channel, index;
@@ -2114,6 +2165,15 @@
-	CY_LOCK(info, flags);
-	    cy_writeb(base_addr+(CyCAR<<index), channel);
-	    cy_writeb(base_addr+(CySRER<<index), 
-               cy_readb(base_addr+(CySRER<<index)) | CyTxRdy);
-	CY_UNLOCK(info, flags);
-    } else {
+	card = info->card;
+	channel = (info->line) - (cy_card[card].first_line);
+	if (!IS_CYC_Z(cy_card[card])) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		index = cy_card[card].bus_index;
+		base_addr = cy_card[card].base_addr +
+				(cy_chip_offset[chip] << index);
+
+		CY_LOCK(info, flags);
+		cy_writeb(base_addr + (CyCAR << index), channel);
+		cy_writeb(base_addr + (CySRER << index),
+			cy_readb(base_addr + (CySRER << index)) | CyTxRdy);
+		CY_UNLOCK(info, flags);
+	} else {
@@ -2121 +2181 @@
-      int retval;
+		int retval;
@@ -2123,12 +2183,13 @@
-	CY_LOCK(info, flags);
-	    retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_INTBACK, 0L);
-	    if (retval != 0){
-		printk("cyc:start_xmit retval on ttyC%d was %x\n",
-		       info->line, retval);
-	    }
-	CY_UNLOCK(info, flags);
-#else /* CONFIG_CYZ_INTR */
-	/* Don't have to do anything at this time */
-#endif /* CONFIG_CYZ_INTR */
-    }
-} /* start_xmit */
+		CY_LOCK(info, flags);
+		retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_INTBACK,
+				0L);
+		if (retval != 0) {
+			printk("cyc:start_xmit retval on ttyC%d was %x\n",
+				info->line, retval);
+		}
+		CY_UNLOCK(info, flags);
+#else				/* CONFIG_CYZ_INTR */
+		/* Don't have to do anything at this time */
+#endif				/* CONFIG_CYZ_INTR */
+	}
+}				/* start_xmit */
@@ -2140,2 +2201 @@
-static void
-shutdown(struct cyclades_port * info)
+static void shutdown(struct cyclades_port *info)
@@ -2143,15 +2203,16 @@
-  unsigned long flags;
-  void __iomem *base_addr;
-  int card,chip,channel,index;
-
-    if (!(info->flags & ASYNC_INITIALIZED)){
-        return;
-    }
-
-    card = info->card;
-    channel = info->line - cy_card[card].first_line;
-    if (!IS_CYC_Z(cy_card[card])) {
-	chip = channel>>2;
-	channel &= 0x03;
-	index = cy_card[card].bus_index;
-	base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
+	unsigned long flags;
+	void __iomem *base_addr;
+	int card, chip, channel, index;
+
+	if (!(info->flags & ASYNC_INITIALIZED)) {
+		return;
+	}
+
+	card = info->card;
+	channel = info->line - cy_card[card].first_line;
+	if (!IS_CYC_Z(cy_card[card])) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		index = cy_card[card].bus_index;
+		base_addr = cy_card[card].base_addr +
+				(cy_chip_offset[chip] << index);
@@ -2160,2 +2221,3 @@
-    printk("cyc shutdown Y card %d, chip %d, channel %d, base_addr %lx\n",
-		card, chip, channel, (long)base_addr);
+		printk("cyc shutdown Y card %d, chip %d, channel %d, "
+				"base_addr %lx\n",
+				card, chip, channel, (long)base_addr);
@@ -2164 +2226 @@
-	CY_LOCK(info, flags);
+		CY_LOCK(info, flags);
@@ -2166,2 +2228,2 @@
-	    /* Clear delta_msr_wait queue to avoid mem leaks. */
-	    wake_up_interruptible(&info->delta_msr_wait);
+		/* Clear delta_msr_wait queue to avoid mem leaks. */
+		wake_up_interruptible(&info->delta_msr_wait);
@@ -2169,10 +2231,10 @@
-	    if (info->xmit_buf){
-		unsigned char * temp;
-		temp = info->xmit_buf;
-		info->xmit_buf = NULL;
-		free_page((unsigned long) temp);
-	    }
-	    cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
-	    if (!info->tty || (info->tty->termios->c_cflag & HUPCL)) {
-		cy_writeb(base_addr+(CyMSVR1<<index), ~CyRTS);
-		cy_writeb(base_addr+(CyMSVR2<<index), ~CyDTR);
+		if (info->xmit_buf) {
+			unsigned char *temp;
+			temp = info->xmit_buf;
+			info->xmit_buf = NULL;
+			free_page((unsigned long)temp);
+		}
+		cy_writeb(base_addr + (CyCAR << index), (u_char) channel);
+		if (!info->tty || (info->tty->termios->c_cflag & HUPCL)) {
+			cy_writeb(base_addr + (CyMSVR1 << index), ~CyRTS);
+			cy_writeb(base_addr + (CyMSVR2 << index), ~CyDTR);
@@ -2180,4 +2242,4 @@
-		printk("cyc shutdown dropping DTR\n");
-		printk("     status: 0x%x, 0x%x\n",
-		    cy_readb(base_addr+(CyMSVR1<<index)), 
-                    cy_readb(base_addr+(CyMSVR2<<index)));
+			printk("cyc shutdown dropping DTR\n");
+			printk("     status: 0x%x, 0x%x\n",
+				cy_readb(base_addr + (CyMSVR1 << index)),
+				cy_readb(base_addr + (CyMSVR2 << index)));
@@ -2185,16 +2247,4 @@
-	    }
-	    cyy_issue_cmd(base_addr,CyCHAN_CTL|CyDIS_RCVR,index);
-	     /* it may be appropriate to clear _XMIT at
-	       some later date (after testing)!!! */
-
-	    if (info->tty){
-		set_bit(TTY_IO_ERROR, &info->tty->flags);
-	    }
-	    info->flags &= ~ASYNC_INITIALIZED;
-	CY_UNLOCK(info, flags);
-    } else {
-      struct FIRM_ID __iomem *firm_id;
-      struct ZFW_CTRL __iomem *zfw_ctrl;
-      struct BOARD_CTRL __iomem *board_ctrl;
-      struct CH_CTRL __iomem *ch_ctrl;
-      int retval;
+		}
+		cyy_issue_cmd(base_addr, CyCHAN_CTL | CyDIS_RCVR, index);
+		/* it may be appropriate to clear _XMIT at
+		   some later date (after testing)!!! */
@@ -2202 +2252,13 @@
-	base_addr = cy_card[card].base_addr;
+		if (info->tty) {
+			set_bit(TTY_IO_ERROR, &info->tty->flags);
+		}
+		info->flags &= ~ASYNC_INITIALIZED;
+		CY_UNLOCK(info, flags);
+	} else {
+		struct FIRM_ID __iomem *firm_id;
+		struct ZFW_CTRL __iomem *zfw_ctrl;
+		struct BOARD_CTRL __iomem *board_ctrl;
+		struct CH_CTRL __iomem *ch_ctrl;
+		int retval;
+
+		base_addr = cy_card[card].base_addr;
@@ -2204,2 +2266,2 @@
-    printk("cyc shutdown Z card %d, channel %d, base_addr %lx\n",
-		card, channel, (long)base_addr);
+		printk("cyc shutdown Z card %d, channel %d, base_addr %lx\n",
+			card, channel, (long)base_addr);
@@ -2208,4 +2270,4 @@
-        firm_id = base_addr + ID_ADDRESS;
-        if (!ISZLOADED(cy_card[card])) {
-	    return;
-	}
+		firm_id = base_addr + ID_ADDRESS;
+		if (!ISZLOADED(cy_card[card])) {
+			return;
+		}
@@ -2213,3 +2275,4 @@
-	zfw_ctrl = cy_card[card].base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
-	board_ctrl = &zfw_ctrl->board_ctrl;
-	ch_ctrl = zfw_ctrl->ch_ctrl;
+		zfw_ctrl = cy_card[card].base_addr +
+				(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		board_ctrl = &zfw_ctrl->board_ctrl;
+		ch_ctrl = zfw_ctrl->ch_ctrl;
@@ -2217 +2280 @@
-	CY_LOCK(info, flags);
+		CY_LOCK(info, flags);
@@ -2219,16 +2282,5 @@
-	    if (info->xmit_buf){
-		unsigned char * temp;
-		temp = info->xmit_buf;
-		info->xmit_buf = NULL;
-		free_page((unsigned long) temp);
-	    }
-	    
-	    if (!info->tty || (info->tty->termios->c_cflag & HUPCL)) {
-		cy_writel(&ch_ctrl[channel].rs_control,
-                   (uclong)(cy_readl(&ch_ctrl[channel].rs_control) & 
-                   ~(C_RS_RTS | C_RS_DTR)));
-		retval = cyz_issue_cmd(&cy_card[info->card],
-			channel, C_CM_IOCTLM, 0L);
-		if (retval != 0){
-		    printk("cyc:shutdown retval on ttyC%d was %x\n",
-			   info->line, retval);
+		if (info->xmit_buf) {
+			unsigned char *temp;
+			temp = info->xmit_buf;
+			info->xmit_buf = NULL;
+			free_page((unsigned long)temp);
@@ -2235,0 +2288,11 @@
+
+		if (!info->tty || (info->tty->termios->c_cflag & HUPCL)) {
+			cy_writel(&ch_ctrl[channel].rs_control,
+				(uclong)(cy_readl(&ch_ctrl[channel].rs_control)&
+					~(C_RS_RTS | C_RS_DTR)));
+			retval = cyz_issue_cmd(&cy_card[info->card], channel,
+					C_CM_IOCTLM, 0L);
+			if (retval != 0) {
+				printk("cyc:shutdown retval on ttyC%d was %x\n",
+					info->line, retval);
+			}
@@ -2237 +2300 @@
-		printk("cyc:shutdown dropping Z DTR\n");
+			printk("cyc:shutdown dropping Z DTR\n");
@@ -2239,6 +2302 @@
-	    }
-	    
-	    if (info->tty){
-		set_bit(TTY_IO_ERROR, &info->tty->flags);
-	    }
-	    info->flags &= ~ASYNC_INITIALIZED;
+		}
@@ -2246,2 +2304,7 @@
-	CY_UNLOCK(info, flags);
-    }
+		if (info->tty) {
+			set_bit(TTY_IO_ERROR, &info->tty->flags);
+		}
+		info->flags &= ~ASYNC_INITIALIZED;
+
+		CY_UNLOCK(info, flags);
+	}
@@ -2250 +2313 @@
-    printk(" cyc shutdown done\n");
+	printk(" cyc shutdown done\n");
@@ -2252,3 +2315 @@
-    return;
-} /* shutdown */
-
+}				/* shutdown */
@@ -2263,2 +2324,2 @@
-block_til_ready(struct tty_struct *tty, struct file * filp,
-                           struct cyclades_port *info)
+block_til_ready(struct tty_struct *tty, struct file *filp,
+		struct cyclades_port *info)
@@ -2266,40 +2327,39 @@
-  DECLARE_WAITQUEUE(wait, current);
-  struct cyclades_card *cinfo;
-  unsigned long flags;
-  int chip, channel,index;
-  int retval;
-  void __iomem *base_addr;
-
-    cinfo = &cy_card[info->card];
-    channel = info->line - cinfo->first_line;
-
-    /*
-     * If the device is in the middle of being closed, then block
-     * until it's done, and then try again.
-     */
-    if (tty_hung_up_p(filp) || (info->flags & ASYNC_CLOSING)) {
-	if (info->flags & ASYNC_CLOSING) {
-            interruptible_sleep_on(&info->close_wait);
-	}
-        return ((info->flags & ASYNC_HUP_NOTIFY) ? -EAGAIN : -ERESTARTSYS);
-    }
-
-    /*
-     * If non-blocking mode is set, then make the check up front
-     * and then exit.
-     */
-    if ((filp->f_flags & O_NONBLOCK) ||
-	(tty->flags & (1 << TTY_IO_ERROR))) {
-        info->flags |= ASYNC_NORMAL_ACTIVE;
-        return 0;
-    }
-
-    /*
-     * Block waiting for the carrier detect and the line to become
-     * free (i.e., not in use by the callout).  While we are in
-     * this loop, info->count is dropped by one, so that
-     * cy_close() knows when to free things.  We restore it upon
-     * exit, either normal or abnormal.
-     */
-    retval = 0;
-    add_wait_queue(&info->open_wait, &wait);
+	DECLARE_WAITQUEUE(wait, current);
+	struct cyclades_card *cinfo;
+	unsigned long flags;
+	int chip, channel, index;
+	int retval;
+	void __iomem *base_addr;
+
+	cinfo = &cy_card[info->card];
+	channel = info->line - cinfo->first_line;
+
+	/*
+	 * If the device is in the middle of being closed, then block
+	 * until it's done, and then try again.
+	 */
+	if (tty_hung_up_p(filp) || (info->flags & ASYNC_CLOSING)) {
+		if (info->flags & ASYNC_CLOSING) {
+			interruptible_sleep_on(&info->close_wait);
+		}
+		return (info->flags & ASYNC_HUP_NOTIFY) ? -EAGAIN: -ERESTARTSYS;
+	}
+
+	/*
+	 * If non-blocking mode is set, then make the check up front
+	 * and then exit.
+	 */
+	if ((filp->f_flags & O_NONBLOCK) || (tty->flags & (1 << TTY_IO_ERROR))) {
+		info->flags |= ASYNC_NORMAL_ACTIVE;
+		return 0;
+	}
+
+	/*
+	 * Block waiting for the carrier detect and the line to become
+	 * free (i.e., not in use by the callout).  While we are in
+	 * this loop, info->count is dropped by one, so that
+	 * cy_close() knows when to free things.  We restore it upon
+	 * exit, either normal or abnormal.
+	 */
+	retval = 0;
+	add_wait_queue(&info->open_wait, &wait);
@@ -2307,2 +2367,3 @@
-    printk("cyc block_til_ready before block: ttyC%d, count = %d\n",
-           info->line, info->count);/**/
+	printk("cyc block_til_ready before block: ttyC%d, count = %d\n",
+		info->line, info->count);
+	/**/
@@ -2310,4 +2371,4 @@
-    CY_LOCK(info, flags);
-    if (!tty_hung_up_p(filp))
-	info->count--;
-    CY_UNLOCK(info, flags);
+	CY_LOCK(info, flags);
+	if (!tty_hung_up_p(filp))
+		info->count--;
+	CY_UNLOCK(info, flags);
@@ -2315,2 +2376,2 @@
-    printk("cyc block_til_ready: (%d): decrementing count to %d\n",
-        current->pid, info->count);
+	printk("cyc block_til_ready: (%d): decrementing count to %d\n",
+		current->pid, info->count);
@@ -2318 +2379 @@
-    info->blocked_open++;
+	info->blocked_open++;
@@ -2320,12 +2381,15 @@
-    if (!IS_CYC_Z(*cinfo)) {
-	chip = channel>>2;
-	channel &= 0x03;
-	index = cinfo->bus_index;
-	base_addr = cinfo->base_addr + (cy_chip_offset[chip]<<index);
-
-	while (1) {
-	    CY_LOCK(info, flags);
-		if ((tty->termios->c_cflag & CBAUD)){
-		    cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
-		    cy_writeb(base_addr+(CyMSVR1<<index), CyRTS);
-		    cy_writeb(base_addr+(CyMSVR2<<index), CyDTR);
+	if (!IS_CYC_Z(*cinfo)) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		index = cinfo->bus_index;
+		base_addr = cinfo->base_addr + (cy_chip_offset[chip] << index);
+
+		while (1) {
+			CY_LOCK(info, flags);
+			if ((tty->termios->c_cflag & CBAUD)) {
+				cy_writeb(base_addr + (CyCAR << index),
+					  (u_char) channel);
+				cy_writeb(base_addr + (CyMSVR1 << index),
+					  CyRTS);
+				cy_writeb(base_addr + (CyMSVR2 << index),
+					  CyDTR);
@@ -2333,4 +2397,6 @@
-		    printk("cyc:block_til_ready raising DTR\n");
-		    printk("     status: 0x%x, 0x%x\n",
-			cy_readb(base_addr+(CyMSVR1<<index)), 
-                        cy_readb(base_addr+(CyMSVR2<<index)));
+				printk("cyc:block_til_ready raising DTR\n");
+				printk("     status: 0x%x, 0x%x\n",
+					cy_readb(base_addr +
+						(CyMSVR1 << index)),
+					cy_readb(base_addr +
+						(CyMSVR2 << index)));
@@ -2338,10 +2404,2 @@
-		}
-	    CY_UNLOCK(info, flags);
-
-	    set_current_state(TASK_INTERRUPTIBLE);
-	    if (tty_hung_up_p(filp)
-	    || !(info->flags & ASYNC_INITIALIZED) ){
-		retval = ((info->flags & ASYNC_HUP_NOTIFY) ? 
-		    -EAGAIN : -ERESTARTSYS);
-		break;
-	    }
+			}
+			CY_UNLOCK(info, flags);
@@ -2349,5 +2407,17 @@
-	    CY_LOCK(info, flags);
-		cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
-		if (!(info->flags & ASYNC_CLOSING)
-		&& (C_CLOCAL(tty)
-		    || (cy_readb(base_addr+(CyMSVR1<<index)) & CyDCD))) {
+			set_current_state(TASK_INTERRUPTIBLE);
+			if (tty_hung_up_p(filp) ||
+					!(info->flags & ASYNC_INITIALIZED)) {
+				retval = ((info->flags & ASYNC_HUP_NOTIFY) ?
+					  -EAGAIN : -ERESTARTSYS);
+				break;
+			}
+
+			CY_LOCK(info, flags);
+			cy_writeb(base_addr + (CyCAR << index),
+				  (u_char) channel);
+			if (!(info->flags & ASYNC_CLOSING) && (C_CLOCAL(tty) ||
+					(cy_readb(base_addr +
+						(CyMSVR1 << index)) & CyDCD))) {
+				CY_UNLOCK(info, flags);
+				break;
+			}
@@ -2355,3 +2424,0 @@
-			break;
-		}
-	    CY_UNLOCK(info, flags);
@@ -2359,4 +2426,4 @@
-	    if (signal_pending(current)) {
-		retval = -ERESTARTSYS;
-		break;
-	    }
+			if (signal_pending(current)) {
+				retval = -ERESTARTSYS;
+				break;
+			}
@@ -2364,2 +2431,4 @@
-	    printk("cyc block_til_ready blocking: ttyC%d, count = %d\n",
-		   info->line, info->count);/**/
+			printk("cyc block_til_ready blocking: ttyC%d, "
+					"count = %d\n",
+					info->line, info->count);
+			/**/
@@ -2367,20 +2436,8 @@
-	    schedule();
-	}
-    } else {
-      struct FIRM_ID __iomem *firm_id;
-      struct ZFW_CTRL __iomem *zfw_ctrl;
-      struct BOARD_CTRL __iomem *board_ctrl;
-      struct CH_CTRL __iomem *ch_ctrl;
-      int retval;
-
-	base_addr = cinfo->base_addr;
-	firm_id = base_addr + ID_ADDRESS;
-        if (!ISZLOADED(*cinfo)){
-            current->state = TASK_RUNNING;
-	    remove_wait_queue(&info->open_wait, &wait);
-	    return -EINVAL;
-	}
-
-	zfw_ctrl = base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
-	board_ctrl = &zfw_ctrl->board_ctrl;
-	ch_ctrl = zfw_ctrl->ch_ctrl;
+			schedule();
+		}
+	} else {
+		struct FIRM_ID __iomem *firm_id;
+		struct ZFW_CTRL __iomem *zfw_ctrl;
+		struct BOARD_CTRL __iomem *board_ctrl;
+		struct CH_CTRL __iomem *ch_ctrl;
+		int retval;
@@ -2388,10 +2445,6 @@
-	while (1) {
-	    if ((tty->termios->c_cflag & CBAUD)){
-		cy_writel(&ch_ctrl[channel].rs_control,
-			cy_readl(&ch_ctrl[channel].rs_control) |
-			(C_RS_RTS | C_RS_DTR));
-		retval = cyz_issue_cmd(&cy_card[info->card],
-				       channel, C_CM_IOCTLM, 0L);
-		if (retval != 0){
-		    printk("cyc:block_til_ready retval on ttyC%d was %x\n",
-			   info->line, retval);
+		base_addr = cinfo->base_addr;
+		firm_id = base_addr + ID_ADDRESS;
+		if (!ISZLOADED(*cinfo)) {
+			current->state = TASK_RUNNING;
+			remove_wait_queue(&info->open_wait, &wait);
+			return -EINVAL;
@@ -2398,0 +2452,19 @@
+
+		zfw_ctrl = base_addr + (cy_readl(&firm_id->zfwctrl_addr) &
+				0xfffff);
+		board_ctrl = &zfw_ctrl->board_ctrl;
+		ch_ctrl = zfw_ctrl->ch_ctrl;
+
+		while (1) {
+			if ((tty->termios->c_cflag & CBAUD)) {
+				cy_writel(&ch_ctrl[channel].rs_control,
+					  cy_readl(&ch_ctrl[channel].
+						   rs_control) | (C_RS_RTS |
+								  C_RS_DTR));
+				retval = cyz_issue_cmd(&cy_card[info->card],
+						channel, C_CM_IOCTLM, 0L);
+				if (retval != 0) {
+					printk("cyc:block_til_ready retval on "
+						"ttyC%d was %x\n",
+						info->line, retval);
+				}
@@ -2400 +2472 @@
-		printk("cyc:block_til_ready raising Z DTR\n");
+				printk("cyc:block_til_ready raising Z DTR\n");
@@ -2402 +2474 @@
-	    }
+			}
@@ -2404,16 +2476,16 @@
-	    set_current_state(TASK_INTERRUPTIBLE);
-	    if (tty_hung_up_p(filp)
-	    || !(info->flags & ASYNC_INITIALIZED) ){
-		retval = ((info->flags & ASYNC_HUP_NOTIFY) ?
-		    -EAGAIN : -ERESTARTSYS);
-		break;
-	    }
-	    if (!(info->flags & ASYNC_CLOSING)
-	    && (C_CLOCAL(tty)
-	      || (cy_readl(&ch_ctrl[channel].rs_status) & C_RS_DCD))) {
-		break;
-	    }
-	    if (signal_pending(current)) {
-		retval = -ERESTARTSYS;
-		break;
-	    }
+			set_current_state(TASK_INTERRUPTIBLE);
+			if (tty_hung_up_p(filp) ||
+					!(info->flags & ASYNC_INITIALIZED)) {
+				retval = ((info->flags & ASYNC_HUP_NOTIFY) ?
+					  -EAGAIN : -ERESTARTSYS);
+				break;
+			}
+			if (!(info->flags & ASYNC_CLOSING) && (C_CLOCAL(tty) ||
+					(cy_readl(&ch_ctrl[channel].rs_status) &
+						C_RS_DCD))) {
+				break;
+			}
+			if (signal_pending(current)) {
+				retval = -ERESTARTSYS;
+				break;
+			}
@@ -2421,2 +2493,4 @@
-	    printk("cyc block_til_ready blocking: ttyC%d, count = %d\n",
-		   info->line, info->count);/**/
+			printk("cyc block_til_ready blocking: ttyC%d, "
+					"count = %d\n",
+					info->line, info->count);
+			/**/
@@ -2424 +2498,2 @@
-	    schedule();
+			schedule();
+		}
@@ -2426,5 +2501,4 @@
-    }
-    current->state = TASK_RUNNING;
-    remove_wait_queue(&info->open_wait, &wait);
-    if (!tty_hung_up_p(filp)){
-	info->count++;
+	current->state = TASK_RUNNING;
+	remove_wait_queue(&info->open_wait, &wait);
+	if (!tty_hung_up_p(filp)) {
+		info->count++;
@@ -2432,2 +2506,2 @@
-	printk("cyc:block_til_ready (%d): incrementing count to %d\n",
-	    current->pid, info->count);
+		printk("cyc:block_til_ready (%d): incrementing count to %d\n",
+			current->pid, info->count);
@@ -2435,2 +2509,2 @@
-    }
-    info->blocked_open--;
+	}
+	info->blocked_open--;
@@ -2438,9 +2512,9 @@
-    printk("cyc:block_til_ready after blocking: ttyC%d, count = %d\n",
-	   info->line, info->count);/**/
-#endif
-    if (retval)
-	return retval;
-    info->flags |= ASYNC_NORMAL_ACTIVE;
-    return 0;
-} /* block_til_ready */
-
+	printk("cyc:block_til_ready after blocking: ttyC%d, count = %d\n",
+		info->line, info->count);
+	/**/
+#endif
+	if (retval)
+		return retval;
+	info->flags |= ASYNC_NORMAL_ACTIVE;
+	return 0;
+}				/* block_til_ready */
@@ -2452,2 +2526 @@
-static int
-cy_open(struct tty_struct *tty, struct file * filp)
+static int cy_open(struct tty_struct *tty, struct file *filp)
@@ -2455,2 +2528,2 @@
-  struct cyclades_port  *info;
-  int retval, line;
+	struct cyclades_port *info;
+	int retval, line;
@@ -2458,28 +2531,7 @@
-    line = tty->index;
-    if ((line < 0) || (NR_PORTS <= line)){
-        return -ENODEV;
-    }
-    info = &cy_port[line];
-    if (info->line < 0){
-        return -ENODEV;
-    }
-    
-    /* If the card's firmware hasn't been loaded,
-       treat it as absent from the system.  This
-       will make the user pay attention.
-    */
-    if (IS_CYC_Z(cy_card[info->card])) {
-	struct cyclades_card *cinfo = &cy_card[info->card];
-	struct FIRM_ID __iomem *firm_id = cinfo->base_addr + ID_ADDRESS;
-
-        if (!ISZLOADED(*cinfo)) {
-	    if (((ZE_V1 ==cy_readl(&((struct RUNTIME_9060 __iomem *)
-		(cinfo->ctl_addr))->mail_box_0)) &&
-		Z_FPGA_CHECK (*cinfo)) &&
-		(ZFIRM_HLT == cy_readl (&firm_id->signature)))
-	    {
-		printk ("cyc:Cyclades-Z Error: you need an external power supply for this number of ports.\n\rFirmware halted.\r\n");
-	    } else {
-		printk("cyc:Cyclades-Z firmware not yet loaded\n");
-	    }
-	    return -ENODEV;
+	line = tty->index;
+	if ((line < 0) || (NR_PORTS <= line)) {
+		return -ENODEV;
+	}
+	info = &cy_port[line];
+	if (info->line < 0) {
+		return -ENODEV;
@@ -2487,12 +2538,0 @@
-#ifdef CONFIG_CYZ_INTR
-	else {
-	    /* In case this Z board is operating in interrupt mode, its 
-	       interrupts should be enabled as soon as the first open happens 
-	       to one of its ports. */
-            if (!cinfo->intr_enabled) {
-		struct ZFW_CTRL __iomem *zfw_ctrl;
-		struct BOARD_CTRL __iomem *board_ctrl;
-
-		zfw_ctrl = cinfo->base_addr + (cy_readl (&firm_id->zfwctrl_addr) & 0xfffff);
-
-		board_ctrl = &zfw_ctrl->board_ctrl;
@@ -2500,12 +2540,59 @@
-		/* Enable interrupts on the PLX chip */
-		cy_writew(cinfo->ctl_addr+0x68,
-			cy_readw(cinfo->ctl_addr+0x68)|0x0900);
-		/* Enable interrupts on the FW */
-		retval = cyz_issue_cmd(cinfo,
-					0, C_CM_IRQ_ENBL, 0L);
-		if (retval != 0){
-		    printk("cyc:IRQ enable retval was %x\n", retval);
-		}
-		cinfo->nports = (int) cy_readl (&board_ctrl->n_channel);
-		cinfo->intr_enabled = 1;
-	    }
+	/* If the card's firmware hasn't been loaded,
+	   treat it as absent from the system.  This
+	   will make the user pay attention.
+	 */
+	if (IS_CYC_Z(cy_card[info->card])) {
+		struct cyclades_card *cinfo = &cy_card[info->card];
+		struct FIRM_ID __iomem *firm_id = cinfo->base_addr + ID_ADDRESS;
+
+		if (!ISZLOADED(*cinfo)) {
+			if (((ZE_V1 == cy_readl(
+					&((struct RUNTIME_9060 __iomem *)
+					 (cinfo->ctl_addr))->mail_box_0)) &&
+					Z_FPGA_CHECK(*cinfo)) &&
+					(ZFIRM_HLT == cy_readl(
+						&firm_id->signature))) {
+				printk("cyc:Cyclades-Z Error: you need an "
+					"external power supply for this number "
+					"of ports.\n\rFirmware halted.\r\n");
+			} else {
+				printk("cyc:Cyclades-Z firmware not yet "
+					"loaded\n");
+			}
+			return -ENODEV;
+		}
+#ifdef CONFIG_CYZ_INTR
+		else {
+		/* In case this Z board is operating in interrupt mode, its
+		   interrupts should be enabled as soon as the first open
+		   happens to one of its ports. */
+			if (!cinfo->intr_enabled) {
+				struct ZFW_CTRL __iomem *zfw_ctrl;
+				struct BOARD_CTRL __iomem *board_ctrl;
+
+				zfw_ctrl = cinfo->base_addr +
+					(cy_readl(&firm_id->zfwctrl_addr) &
+						0xfffff);
+
+				board_ctrl = &zfw_ctrl->board_ctrl;
+
+				/* Enable interrupts on the PLX chip */
+				cy_writew(cinfo->ctl_addr + 0x68,
+					  cy_readw(cinfo->ctl_addr +
+						   0x68) | 0x0900);
+				/* Enable interrupts on the FW */
+				retval = cyz_issue_cmd(cinfo, 0,
+						C_CM_IRQ_ENBL, 0L);
+				if (retval != 0) {
+					printk("cyc:IRQ enable retval was %x\n",
+						retval);
+				}
+				cinfo->nports =
+					(int)cy_readl(&board_ctrl->n_channel);
+				cinfo->intr_enabled = 1;
+			}
+		}
+#endif				/* CONFIG_CYZ_INTR */
+		/* Make sure this Z port really exists in hardware */
+		if (info->line > (cinfo->first_line + cinfo->nports - 1))
+			return -ENODEV;
@@ -2513,5 +2599,0 @@
-#endif /* CONFIG_CYZ_INTR */
-	/* Make sure this Z port really exists in hardware */
-	if (info->line > (cinfo->first_line + cinfo->nports - 1))
-		return -ENODEV;
-    }
@@ -2519 +2601 @@
-    printk("cyc:cy_open ttyC%d\n", info->line); /* */
+	printk("cyc:cy_open ttyC%d\n", info->line);	/* */
@@ -2521,5 +2603,5 @@
-    tty->driver_data = info;
-    info->tty = tty;
-    if (serial_paranoia_check(info, tty->name, "cy_open")){
-        return -ENODEV;
-    }
+	tty->driver_data = info;
+	info->tty = tty;
+	if (serial_paranoia_check(info, tty->name, "cy_open")) {
+		return -ENODEV;
+	}
@@ -2527,2 +2609,2 @@
-    printk("cyc:cy_open ttyC%d, count = %d\n",
-        info->line, info->count);/**/
+	printk("cyc:cy_open ttyC%d, count = %d\n", info->line, info->count);
+	/**/
@@ -2530 +2612 @@
-    info->count++;
+	info->count++;
@@ -2532,2 +2614,2 @@
-    printk("cyc:cy_open (%d): incrementing count to %d\n",
-        current->pid, info->count);
+	printk("cyc:cy_open (%d): incrementing count to %d\n",
+		current->pid, info->count);
@@ -2536,16 +2618,16 @@
-    /*
-     * If the port is the middle of closing, bail out now
-     */
-    if (tty_hung_up_p(filp) || (info->flags & ASYNC_CLOSING)) {
-	if (info->flags & ASYNC_CLOSING)
-	    interruptible_sleep_on(&info->close_wait);
-	return ((info->flags & ASYNC_HUP_NOTIFY) ? -EAGAIN : -ERESTARTSYS);
-    }
-
-    /*
-     * Start up serial port
-     */
-    retval = startup(info);
-    if (retval){
-        return retval;
-    }
+	/*
+	 * If the port is the middle of closing, bail out now
+	 */
+	if (tty_hung_up_p(filp) || (info->flags & ASYNC_CLOSING)) {
+		if (info->flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&info->close_wait);
+		return (info->flags & ASYNC_HUP_NOTIFY) ? -EAGAIN: -ERESTARTSYS;
+	}
+
+	/*
+	 * Start up serial port
+	 */
+	retval = startup(info);
+	if (retval) {
+		return retval;
+	}
@@ -2553,2 +2635,2 @@
-    retval = block_til_ready(tty, filp, info);
-    if (retval) {
+	retval = block_til_ready(tty, filp, info);
+	if (retval) {
@@ -2556,2 +2638,2 @@
-        printk("cyc:cy_open returning after block_til_ready with %d\n",
-               retval);
+		printk("cyc:cy_open returning after block_til_ready with %d\n",
+			retval);
@@ -2559,2 +2641,2 @@
-        return retval;
-    }
+		return retval;
+	}
@@ -2562 +2644 @@
-    info->throttle = 0;
+	info->throttle = 0;
@@ -2565 +2647,2 @@
-    printk(" cyc:cy_open done\n");/**/
+	printk(" cyc:cy_open done\n");
+	/**/
@@ -2567,4 +2650,2 @@
-
-    return 0;
-} /* cy_open */
-
+	return 0;
+}				/* cy_open */
@@ -2575,2 +2656 @@
-static void 
-cy_wait_until_sent(struct tty_struct *tty, int timeout)
+static void cy_wait_until_sent(struct tty_struct *tty, int timeout)
@@ -2578,41 +2658,40 @@
-  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
-  void __iomem *base_addr;
-  int card,chip,channel,index;
-  unsigned long orig_jiffies;
-  int char_time;
-	
-    if (serial_paranoia_check(info, tty->name, "cy_wait_until_sent"))
-	return;
-
-    if (info->xmit_fifo_size == 0)
-	return; /* Just in case.... */
-
-
-    orig_jiffies = jiffies;
-    /*
-     * Set the check interval to be 1/5 of the estimated time to
-     * send a single character, and make it at least 1.  The check
-     * interval should also be less than the timeout.
-     * 
-     * Note: we have to use pretty tight timings here to satisfy
-     * the NIST-PCTS.
-     */
-    char_time = (info->timeout - HZ/50) / info->xmit_fifo_size;
-    char_time = char_time / 5;
-    if (char_time <= 0)
-	char_time = 1;
-    if (timeout < 0)
-	timeout = 0;
-    if (timeout)
-	char_time = min(char_time, timeout);
-    /*
-     * If the transmitter hasn't cleared in twice the approximate
-     * amount of time to send the entire FIFO, it probably won't
-     * ever clear.  This assumes the UART isn't doing flow
-     * control, which is currently the case.  Hence, if it ever
-     * takes longer than info->timeout, this is probably due to a
-     * UART bug of some kind.  So, we clamp the timeout parameter at
-     * 2*info->timeout.
-     */
-    if (!timeout || timeout > 2*info->timeout)
-	timeout = 2*info->timeout;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	void __iomem *base_addr;
+	int card, chip, channel, index;
+	unsigned long orig_jiffies;
+	int char_time;
+
+	if (serial_paranoia_check(info, tty->name, "cy_wait_until_sent"))
+		return;
+
+	if (info->xmit_fifo_size == 0)
+		return;		/* Just in case.... */
+
+	orig_jiffies = jiffies;
+	/*
+	 * Set the check interval to be 1/5 of the estimated time to
+	 * send a single character, and make it at least 1.  The check
+	 * interval should also be less than the timeout.
+	 *
+	 * Note: we have to use pretty tight timings here to satisfy
+	 * the NIST-PCTS.
+	 */
+	char_time = (info->timeout - HZ / 50) / info->xmit_fifo_size;
+	char_time = char_time / 5;
+	if (char_time <= 0)
+		char_time = 1;
+	if (timeout < 0)
+		timeout = 0;
+	if (timeout)
+		char_time = min(char_time, timeout);
+	/*
+	 * If the transmitter hasn't cleared in twice the approximate
+	 * amount of time to send the entire FIFO, it probably won't
+	 * ever clear.  This assumes the UART isn't doing flow
+	 * control, which is currently the case.  Hence, if it ever
+	 * takes longer than info->timeout, this is probably due to a
+	 * UART bug of some kind.  So, we clamp the timeout parameter at
+	 * 2*info->timeout.
+	 */
+	if (!timeout || timeout > 2 * info->timeout)
+		timeout = 2 * info->timeout;
@@ -2620,2 +2699,2 @@
-    printk("In cy_wait_until_sent(%d) check=%lu...", timeout, char_time);
-    printk("jiff=%lu...", jiffies);
+	printk("In cy_wait_until_sent(%d) check=%lu...", timeout, char_time);
+	printk("jiff=%lu...", jiffies);
@@ -2623,8 +2702,9 @@
-    card = info->card;
-    channel = (info->line) - (cy_card[card].first_line);
-    if (!IS_CYC_Z(cy_card[card])) {
-	chip = channel>>2;
-	channel &= 0x03;
-	index = cy_card[card].bus_index;
-	base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
-	while (cy_readb(base_addr+(CySRER<<index)) & CyTxRdy) {
+	card = info->card;
+	channel = (info->line) - (cy_card[card].first_line);
+	if (!IS_CYC_Z(cy_card[card])) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		index = cy_card[card].bus_index;
+		base_addr =
+		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
+		while (cy_readb(base_addr + (CySRER << index)) & CyTxRdy) {
@@ -2632 +2712 @@
-	    printk("Not clean (jiff=%lu)...", jiffies);
+			printk("Not clean (jiff=%lu)...", jiffies);
@@ -2634,4 +2714,8 @@
-	    if (msleep_interruptible(jiffies_to_msecs(char_time)))
-		break;
-	    if (timeout && time_after(jiffies, orig_jiffies + timeout))
-		break;
+			if (msleep_interruptible(jiffies_to_msecs(char_time)))
+				break;
+			if (timeout && time_after(jiffies, orig_jiffies +
+					timeout))
+				break;
+		}
+	} else {
+		/* Nothing to do! */
@@ -2639,5 +2723,2 @@
-    } else {
-	// Nothing to do!
-    }
-    /* Run one more char cycle */
-    msleep_interruptible(jiffies_to_msecs(char_time * 5));
+	/* Run one more char cycle */
+	msleep_interruptible(jiffies_to_msecs(char_time * 5));
@@ -2645 +2726 @@
-    printk("Clean (jiff=%lu)...done\n", jiffies);
+	printk("Clean (jiff=%lu)...done\n", jiffies);
@@ -2652,2 +2733 @@
-static void
-cy_close(struct tty_struct *tty, struct file *filp)
+static void cy_close(struct tty_struct *tty, struct file *filp)
@@ -2655,2 +2735,2 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  unsigned long flags;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	unsigned long flags;
@@ -2659 +2739 @@
-    printk("cyc:cy_close ttyC%d\n", info->line);
+	printk("cyc:cy_close ttyC%d\n", info->line);
@@ -2662,3 +2742,3 @@
-    if (!info || serial_paranoia_check(info, tty->name, "cy_close")){
-        return;
-    }
+	if (!info || serial_paranoia_check(info, tty->name, "cy_close")) {
+		return;
+	}
@@ -2666,7 +2746,6 @@
-    CY_LOCK(info, flags);
-    /* If the TTY is being hung up, nothing to do */
-    if (tty_hung_up_p(filp)) {
-	CY_UNLOCK(info, flags);
-        return;
-    }
-        
+	CY_LOCK(info, flags);
+	/* If the TTY is being hung up, nothing to do */
+	if (tty_hung_up_p(filp)) {
+		CY_UNLOCK(info, flags);
+		return;
+	}
@@ -2674 +2753 @@
-    printk("cyc:cy_close ttyC%d, count = %d\n", info->line, info->count);
+	printk("cyc:cy_close ttyC%d, count = %d\n", info->line, info->count);
@@ -2676,12 +2755,12 @@
-    if ((tty->count == 1) && (info->count != 1)) {
-        /*
-         * Uh, oh.  tty->count is 1, which means that the tty
-         * structure will be freed.  Info->count should always
-         * be one in these conditions.  If it's greater than
-         * one, we've got real problems, since it means the
-         * serial port won't be shutdown.
-         */
-        printk("cyc:cy_close: bad serial port count; tty->count is 1, "
-           "info->count is %d\n", info->count);
-        info->count = 1;
-    }
+	if ((tty->count == 1) && (info->count != 1)) {
+		/*
+		 * Uh, oh.  tty->count is 1, which means that the tty
+		 * structure will be freed.  Info->count should always
+		 * be one in these conditions.  If it's greater than
+		 * one, we've got real problems, since it means the
+		 * serial port won't be shutdown.
+		 */
+		printk("cyc:cy_close: bad serial port count; tty->count is 1, "
+			"info->count is %d\n", info->count);
+		info->count = 1;
+	}
@@ -2689,2 +2768,2 @@
-    printk("cyc:cy_close at (%d): decrementing count to %d\n",
-        current->pid, info->count - 1);
+	printk("cyc:cy_close at (%d): decrementing count to %d\n",
+		current->pid, info->count - 1);
@@ -2692 +2771 @@
-    if (--info->count < 0) {
+	if (--info->count < 0) {
@@ -2694 +2773 @@
-    printk("cyc:cyc_close setting count to 0\n");
+		printk("cyc:cyc_close setting count to 0\n");
@@ -2696,3 +2775,13 @@
-        info->count = 0;
-    }
-    if (info->count) {
+		info->count = 0;
+	}
+	if (info->count) {
+		CY_UNLOCK(info, flags);
+		return;
+	}
+	info->flags |= ASYNC_CLOSING;
+
+	/*
+	 * Now we wait for the transmit buffer to clear; and we notify
+	 * the line discipline to only process XON/XOFF characters.
+	 */
+	tty->closing = 1;
@@ -2700,30 +2789,2 @@
-        return;
-    }
-    info->flags |= ASYNC_CLOSING;
-
-    /*
-    * Now we wait for the transmit buffer to clear; and we notify
-    * the line discipline to only process XON/XOFF characters.
-    */
-    tty->closing = 1;
-    CY_UNLOCK(info, flags);
-    if (info->closing_wait != CY_CLOSING_WAIT_NONE) {
-	tty_wait_until_sent(tty, info->closing_wait);
-    }
-    CY_LOCK(info, flags);
-
-    if (!IS_CYC_Z(cy_card[info->card])) {
-	int channel = info->line - cy_card[info->card].first_line;
-	int index = cy_card[info->card].bus_index;
-	void __iomem *base_addr = cy_card[info->card].base_addr + (cy_chip_offset[channel>>2] << index);
-	/* Stop accepting input */
-	channel &= 0x03;
-	cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
-	cy_writeb(base_addr+(CySRER<<index),
-			cy_readb(base_addr+(CySRER<<index)) & ~CyRxData);
-	if (info->flags & ASYNC_INITIALIZED) {
-	    /* Waiting for on-board buffers to be empty before closing 
-	       the port */
-	    CY_UNLOCK(info, flags);
-	    cy_wait_until_sent(tty, info->timeout);
-	    CY_LOCK(info, flags);
+	if (info->closing_wait != CY_CLOSING_WAIT_NONE) {
+		tty_wait_until_sent(tty, info->closing_wait);
@@ -2731 +2792,20 @@
-    } else {
+	CY_LOCK(info, flags);
+
+	if (!IS_CYC_Z(cy_card[info->card])) {
+		int channel = info->line - cy_card[info->card].first_line;
+		int index = cy_card[info->card].bus_index;
+		void __iomem *base_addr = cy_card[info->card].base_addr +
+			(cy_chip_offset[channel >> 2] << index);
+		/* Stop accepting input */
+		channel &= 0x03;
+		cy_writeb(base_addr + (CyCAR << index), (u_char) channel);
+		cy_writeb(base_addr + (CySRER << index),
+			  cy_readb(base_addr + (CySRER << index)) & ~CyRxData);
+		if (info->flags & ASYNC_INITIALIZED) {
+			/* Waiting for on-board buffers to be empty before closing
+			   the port */
+			CY_UNLOCK(info, flags);
+			cy_wait_until_sent(tty, info->timeout);
+			CY_LOCK(info, flags);
+		}
+	} else {
@@ -2733,7 +2813,22 @@
-	/* Waiting for on-board buffers to be empty before closing the port */
-	void __iomem *base_addr = cy_card[info->card].base_addr;
-	struct FIRM_ID __iomem *firm_id = base_addr + ID_ADDRESS;
-	struct ZFW_CTRL __iomem *zfw_ctrl = base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
-	struct CH_CTRL __iomem *ch_ctrl = zfw_ctrl->ch_ctrl;
-	int channel = info->line - cy_card[info->card].first_line;
-	int retval;
+		/* Waiting for on-board buffers to be empty before closing the port */
+		void __iomem *base_addr = cy_card[info->card].base_addr;
+		struct FIRM_ID __iomem *firm_id = base_addr + ID_ADDRESS;
+		struct ZFW_CTRL __iomem *zfw_ctrl =
+		    base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		struct CH_CTRL __iomem *ch_ctrl = zfw_ctrl->ch_ctrl;
+		int channel = info->line - cy_card[info->card].first_line;
+		int retval;
+
+		if (cy_readl(&ch_ctrl[channel].flow_status) != C_FS_TXIDLE) {
+			retval = cyz_issue_cmd(&cy_card[info->card], channel,
+						C_CM_IOCTLW, 0L);
+			if (retval != 0) {
+				printk("cyc:cy_close retval on ttyC%d was %x\n",
+					info->line, retval);
+			}
+			CY_UNLOCK(info, flags);
+			interruptible_sleep_on(&info->shutdown_wait);
+			CY_LOCK(info, flags);
+		}
+#endif
+	}
@@ -2741,25 +2835,0 @@
-	if (cy_readl(&ch_ctrl[channel].flow_status) != C_FS_TXIDLE) {
-	    retval = cyz_issue_cmd(&cy_card[info->card], channel, 
-				   C_CM_IOCTLW, 0L);
-	    if (retval != 0){
-		printk("cyc:cy_close retval on ttyC%d was %x\n",
-		       info->line, retval);
-	    }
-	    CY_UNLOCK(info, flags);
-	    interruptible_sleep_on(&info->shutdown_wait);
-	    CY_LOCK(info, flags);
-	}
-#endif
-    }
-
-    CY_UNLOCK(info, flags);
-    shutdown(info);
-    if (tty->driver->flush_buffer)
-        tty->driver->flush_buffer(tty);
-    tty_ldisc_flush(tty);        
-    CY_LOCK(info, flags);
-
-    tty->closing = 0;
-    info->event = 0;
-    info->tty = NULL;
-    if (info->blocked_open) {
@@ -2767,4 +2837,4 @@
-        if (info->close_delay) {
-            msleep_interruptible(jiffies_to_msecs(info->close_delay));
-        }
-        wake_up_interruptible(&info->open_wait);
+	shutdown(info);
+	if (tty->driver->flush_buffer)
+		tty->driver->flush_buffer(tty);
+	tty_ldisc_flush(tty);
@@ -2772,3 +2842,15 @@
-    }
-    info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-    wake_up_interruptible(&info->close_wait);
+
+	tty->closing = 0;
+	info->event = 0;
+	info->tty = NULL;
+	if (info->blocked_open) {
+		CY_UNLOCK(info, flags);
+		if (info->close_delay) {
+			msleep_interruptible(jiffies_to_msecs
+						(info->close_delay));
+		}
+		wake_up_interruptible(&info->open_wait);
+		CY_LOCK(info, flags);
+	}
+	info->flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
+	wake_up_interruptible(&info->close_wait);
@@ -2777 +2859 @@
-    printk(" cyc:cy_close done\n");
+	printk(" cyc:cy_close done\n");
@@ -2780,4 +2862,2 @@
-    CY_UNLOCK(info, flags);
-    return;
-} /* cy_close */
-
+	CY_UNLOCK(info, flags);
+}				/* cy_close */
@@ -2798,2 +2878 @@
-static int
-cy_write(struct tty_struct * tty, const unsigned char *buf, int count)
+static int cy_write(struct tty_struct *tty, const unsigned char *buf, int count)
@@ -2801,3 +2880,3 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  unsigned long flags;
-  int c, ret = 0;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	unsigned long flags;
+	int c, ret = 0;
@@ -2806 +2885 @@
-    printk("cyc:cy_write ttyC%d\n", info->line); /* */
+	printk("cyc:cy_write ttyC%d\n", info->line);	/* */
@@ -2809,6 +2888,14 @@
-    if (serial_paranoia_check(info, tty->name, "cy_write")){
-        return 0;
-    }
-        
-    if (!info->xmit_buf)
-	return 0;
+	if (serial_paranoia_check(info, tty->name, "cy_write")) {
+		return 0;
+	}
+
+	if (!info->xmit_buf)
+		return 0;
+
+	CY_LOCK(info, flags);
+	while (1) {
+		c = min(count, min((int)(SERIAL_XMIT_SIZE - info->xmit_cnt - 1),
+				   (int)(SERIAL_XMIT_SIZE - info->xmit_head)));
+
+		if (c <= 0)
+			break;
@@ -2816,25 +2903,12 @@
-    CY_LOCK(info, flags);
-    while (1) {
-	c = min(count, min((int)(SERIAL_XMIT_SIZE - info->xmit_cnt - 1),
-			(int)(SERIAL_XMIT_SIZE - info->xmit_head)));
-	        
-	if (c <= 0)
-	    break;
-
-	memcpy(info->xmit_buf + info->xmit_head, buf, c);
-	info->xmit_head = (info->xmit_head + c) & (SERIAL_XMIT_SIZE-1);
-	info->xmit_cnt += c;
-	buf += c;
-	count -= c;
-	ret += c;
-    }
-    CY_UNLOCK(info, flags);
-
-    info->idle_stats.xmit_bytes += ret;
-    info->idle_stats.xmit_idle   = jiffies;
-
-    if (info->xmit_cnt && !tty->stopped && !tty->hw_stopped) {
-        start_xmit(info);
-    }
-    return ret;
-} /* cy_write */
+		memcpy(info->xmit_buf + info->xmit_head, buf, c);
+		info->xmit_head = (info->xmit_head + c) &
+			(SERIAL_XMIT_SIZE - 1);
+		info->xmit_cnt += c;
+		buf += c;
+		count -= c;
+		ret += c;
+	}
+	CY_UNLOCK(info, flags);
+
+	info->idle_stats.xmit_bytes += ret;
+	info->idle_stats.xmit_idle = jiffies;
@@ -2841,0 +2916,5 @@
+	if (info->xmit_cnt && !tty->stopped && !tty->hw_stopped) {
+		start_xmit(info);
+	}
+	return ret;
+}				/* cy_write */
@@ -2850,2 +2929 @@
-static void
-cy_put_char(struct tty_struct *tty, unsigned char ch)
+static void cy_put_char(struct tty_struct *tty, unsigned char ch)
@@ -2853,2 +2931,2 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  unsigned long flags;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	unsigned long flags;
@@ -2857 +2935 @@
-    printk("cyc:cy_put_char ttyC%d\n", info->line);
+	printk("cyc:cy_put_char ttyC%d\n", info->line);
@@ -2860,2 +2938,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_put_char"))
-        return;
+	if (serial_paranoia_check(info, tty->name, "cy_put_char"))
+		return;
@@ -2863,2 +2941,2 @@
-    if (!info->xmit_buf)
-        return;
+	if (!info->xmit_buf)
+		return;
@@ -2866,5 +2944,5 @@
-    CY_LOCK(info, flags);
-        if (info->xmit_cnt >= SERIAL_XMIT_SIZE - 1) {
-	    CY_UNLOCK(info, flags);
-            return;
-        }
+	CY_LOCK(info, flags);
+	if (info->xmit_cnt >= (int)(SERIAL_XMIT_SIZE - 1)) {
+		CY_UNLOCK(info, flags);
+		return;
+	}
@@ -2872,3 +2950,3 @@
-        info->xmit_buf[info->xmit_head++] = ch;
-        info->xmit_head &= SERIAL_XMIT_SIZE - 1;
-        info->xmit_cnt++;
+	info->xmit_buf[info->xmit_head++] = ch;
+	info->xmit_head &= SERIAL_XMIT_SIZE - 1;
+	info->xmit_cnt++;
@@ -2877,3 +2955,2 @@
-    CY_UNLOCK(info, flags);
-} /* cy_put_char */
-
+	CY_UNLOCK(info, flags);
+}				/* cy_put_char */
@@ -2885,2 +2962 @@
-static void
-cy_flush_chars(struct tty_struct *tty)
+static void cy_flush_chars(struct tty_struct *tty)
@@ -2888,2 +2964,2 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-                                
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+
@@ -2891 +2967 @@
-    printk("cyc:cy_flush_chars ttyC%d\n", info->line); /* */
+	printk("cyc:cy_flush_chars ttyC%d\n", info->line);	/* */
@@ -2894,6 +2970,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_flush_chars"))
-        return;
-
-    if (info->xmit_cnt <= 0 || tty->stopped
-    || tty->hw_stopped || !info->xmit_buf)
-        return;
+	if (serial_paranoia_check(info, tty->name, "cy_flush_chars"))
+		return;
@@ -2901,2 +2973,3 @@
-    start_xmit(info);
-} /* cy_flush_chars */
+	if (info->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||
+			!info->xmit_buf)
+		return;
@@ -2903,0 +2977,2 @@
+	start_xmit(info);
+}				/* cy_flush_chars */
@@ -2911,2 +2986 @@
-static int
-cy_write_room(struct tty_struct *tty)
+static int cy_write_room(struct tty_struct *tty)
@@ -2914,3 +2988,3 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  int   ret;
-                                
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	int ret;
+
@@ -2918 +2992 @@
-    printk("cyc:cy_write_room ttyC%d\n", info->line); /* */
+	printk("cyc:cy_write_room ttyC%d\n", info->line);	/* */
@@ -2921,8 +2995,7 @@
-    if (serial_paranoia_check(info, tty->name, "cy_write_room"))
-        return 0;
-    ret = SERIAL_XMIT_SIZE - info->xmit_cnt - 1;
-    if (ret < 0)
-        ret = 0;
-    return ret;
-} /* cy_write_room */
-
+	if (serial_paranoia_check(info, tty->name, "cy_write_room"))
+		return 0;
+	ret = SERIAL_XMIT_SIZE - info->xmit_cnt - 1;
+	if (ret < 0)
+		ret = 0;
+	return ret;
+}				/* cy_write_room */
@@ -2930,2 +3003 @@
-static int
-cy_chars_in_buffer(struct tty_struct *tty)
+static int cy_chars_in_buffer(struct tty_struct *tty)
@@ -2933,5 +3005,2 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  int card, channel;
-                                
-    if (serial_paranoia_check(info, tty->name, "cy_chars_in_buffer"))
-        return 0;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	int card, channel;
@@ -2939,2 +3008,5 @@
-    card = info->card;
-    channel = (info->line) - (cy_card[card].first_line);
+	if (serial_paranoia_check(info, tty->name, "cy_chars_in_buffer"))
+		return 0;
+
+	card = info->card;
+	channel = (info->line) - (cy_card[card].first_line);
@@ -2943,2 +3015,2 @@
-    if (!IS_CYC_Z(cy_card[card])) {
-#endif /* Z_EXT_CHARS_IN_BUFFER */
+	if (!IS_CYC_Z(cy_card[card])) {
+#endif				/* Z_EXT_CHARS_IN_BUFFER */
@@ -2946,2 +3018 @@
-	printk("cyc:cy_chars_in_buffer ttyC%d %d\n",
-		info->line, info->xmit_cnt); /* */
+		printk("cyc:cy_chars_in_buffer ttyC%d %d\n", info->line, info->xmit_cnt);	/* */
@@ -2949 +3020 @@
-	return info->xmit_cnt;
+		return info->xmit_cnt;
@@ -2951,20 +3022,21 @@
-    } else {
-	static volatile struct FIRM_ID *firm_id;
-	static volatile struct ZFW_CTRL *zfw_ctrl;
-	static volatile struct CH_CTRL *ch_ctrl;
-	static volatile struct BUF_CTRL *buf_ctrl;
-	int char_count;
-	volatile uclong tx_put, tx_get, tx_bufsize;
-
-	firm_id = cy_card[card].base_addr + ID_ADDRESS;
-	zfw_ctrl = cy_card[card].base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
-	ch_ctrl = &(zfw_ctrl->ch_ctrl[channel]);
-	buf_ctrl = &(zfw_ctrl->buf_ctrl[channel]);
-
-	tx_get = cy_readl(&buf_ctrl->tx_get);
-	tx_put = cy_readl(&buf_ctrl->tx_put);
-	tx_bufsize = cy_readl(&buf_ctrl->tx_bufsize);
-	if (tx_put >= tx_get)
-	    char_count = tx_put - tx_get;
-	else
-	    char_count = tx_put - tx_get + tx_bufsize;
+	} else {
+		static volatile struct FIRM_ID *firm_id;
+		static volatile struct ZFW_CTRL *zfw_ctrl;
+		static volatile struct CH_CTRL *ch_ctrl;
+		static volatile struct BUF_CTRL *buf_ctrl;
+		int char_count;
+		volatile uclong tx_put, tx_get, tx_bufsize;
+
+		firm_id = cy_card[card].base_addr + ID_ADDRESS;
+		zfw_ctrl = cy_card[card].base_addr +
+			(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		ch_ctrl = &(zfw_ctrl->ch_ctrl[channel]);
+		buf_ctrl = &(zfw_ctrl->buf_ctrl[channel]);
+
+		tx_get = cy_readl(&buf_ctrl->tx_get);
+		tx_put = cy_readl(&buf_ctrl->tx_put);
+		tx_bufsize = cy_readl(&buf_ctrl->tx_bufsize);
+		if (tx_put >= tx_get)
+			char_count = tx_put - tx_get;
+		else
+			char_count = tx_put - tx_get + tx_bufsize;
@@ -2972,2 +3044 @@
-	printk("cyc:cy_chars_in_buffer ttyC%d %d\n",
-		info->line, info->xmit_cnt + char_count); /* */
+		printk("cyc:cy_chars_in_buffer ttyC%d %d\n", info->line, info->xmit_cnt + char_count);	/* */
@@ -2975,5 +3046,4 @@
-	return (info->xmit_cnt + char_count);
-    }
-#endif /* Z_EXT_CHARS_IN_BUFFER */
-} /* cy_chars_in_buffer */
-
+		return info->xmit_cnt + char_count;
+	}
+#endif				/* Z_EXT_CHARS_IN_BUFFER */
+}				/* cy_chars_in_buffer */
@@ -2987,2 +3057 @@
-static void
-cyy_baud_calc(struct cyclades_port *info, uclong baud)
+static void cyy_baud_calc(struct cyclades_port *info, uclong baud)
@@ -2990,2 +3059,14 @@
-    int co, co_val, bpr;
-    uclong cy_clock = ((info->chip_rev >= CD1400_REV_J) ? 60000000 : 25000000);
+	int co, co_val, bpr;
+	uclong cy_clock = ((info->chip_rev >= CD1400_REV_J) ? 60000000 :
+			25000000);
+
+	if (baud == 0) {
+		info->tbpr = info->tco = info->rbpr = info->rco = 0;
+		return;
+	}
+
+	/* determine which prescaler to use */
+	for (co = 4, co_val = 2048; co; co--, co_val >>= 2) {
+		if (cy_clock / co_val / baud > 63)
+			break;
+	}
@@ -2993,14 +3074,3 @@
-    if (baud == 0) {
-	info->tbpr = info->tco = info->rbpr = info->rco = 0;
-	return;
-    }
-
-    /* determine which prescaler to use */
-    for (co = 4, co_val = 2048; co; co--, co_val >>= 2) {
-	if (cy_clock / co_val / baud > 63)
-	    break;
-    }
-
-    bpr = (cy_clock / co_val * 2 / baud + 1) / 2;
-    if (bpr > 255)
-	bpr = 255;
+	bpr = (cy_clock / co_val * 2 / baud + 1) / 2;
+	if (bpr > 255)
+		bpr = 255;
@@ -3008,2 +3078,2 @@
-    info->tbpr = info->rbpr = bpr;
-    info->tco = info->rco = co;
+	info->tbpr = info->rbpr = bpr;
+	info->tco = info->rco = co;
@@ -3016,2 +3086 @@
-static void
-set_line_char(struct cyclades_port * info)
+static void set_line_char(struct cyclades_port *info)
@@ -3019,56 +3088,10 @@
-  unsigned long flags;
-  void __iomem *base_addr;
-  int card,chip,channel,index;
-  unsigned cflag, iflag;
-  unsigned short chip_number;
-  int baud, baud_rate = 0;
-  int   i;
-
-
-    if (!info->tty || !info->tty->termios){
-        return;
-    }
-    if (info->line == -1){
-        return;
-    }
-    cflag = info->tty->termios->c_cflag;
-    iflag = info->tty->termios->c_iflag;
-
-    /*
-     * Set up the tty->alt_speed kludge
-     */
-    if (info->tty) {
-	if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
-	    info->tty->alt_speed = 57600;
-	if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
-	    info->tty->alt_speed = 115200;
-	if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
-	    info->tty->alt_speed = 230400;
-	if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
-	    info->tty->alt_speed = 460800;
-    }
-
-    card = info->card;
-    channel = (info->line) - (cy_card[card].first_line);
-    chip_number = channel / 4;
-
-    if (!IS_CYC_Z(cy_card[card])) {
-
-	index = cy_card[card].bus_index;
-
-	/* baud rate */
-	baud = tty_get_baud_rate(info->tty);
-	if ((baud == 38400) &&
-	    ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)) {
-	    if (info->custom_divisor)
-		baud_rate = info->baud / info->custom_divisor;
-	    else
-		baud_rate = info->baud;
-	} else if (baud > CD1400_MAX_SPEED) {
-	    baud = CD1400_MAX_SPEED;
-	}
-	/* find the baud index */
-	for (i = 0; i < 20; i++) {
-	    if (baud == baud_table[i]) {
-		break;
-	    }
+	unsigned long flags;
+	void __iomem *base_addr;
+	int card, chip, channel, index;
+	unsigned cflag, iflag;
+	unsigned short chip_number;
+	int baud, baud_rate = 0;
+	int i;
+
+	if (!info->tty || !info->tty->termios) {
+		return;
@@ -3076,32 +3099,2 @@
-	if (i == 20) {
-	    i = 19; /* CD1400_MAX_SPEED */
-	} 
-
-	if ((baud == 38400) &&
-	    ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)) {
-	    cyy_baud_calc(info, baud_rate);
-	} else {
-	    if(info->chip_rev >= CD1400_REV_J) {
-		/* It is a CD1400 rev. J or later */
-		info->tbpr = baud_bpr_60[i]; /* Tx BPR */
-		info->tco = baud_co_60[i]; /* Tx CO */
-		info->rbpr = baud_bpr_60[i]; /* Rx BPR */
-		info->rco = baud_co_60[i]; /* Rx CO */
-	    } else {
-		info->tbpr = baud_bpr_25[i]; /* Tx BPR */
-		info->tco = baud_co_25[i]; /* Tx CO */
-		info->rbpr = baud_bpr_25[i]; /* Rx BPR */
-		info->rco = baud_co_25[i]; /* Rx CO */
-	    }
-	}
-	if (baud_table[i] == 134) {
-	    /* get it right for 134.5 baud */
-	    info->timeout = (info->xmit_fifo_size*HZ*30/269) + 2;
-	} else if ((baud == 38400) &&
-		   ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)) {
-	    info->timeout = (info->xmit_fifo_size*HZ*15/baud_rate) + 2;
-	} else if (baud_table[i]) {
-	    info->timeout = (info->xmit_fifo_size*HZ*15/baud_table[i]) + 2;
-	    /* this needs to be propagated into the card info */
-	} else {
-	    info->timeout = 0;
+	if (info->line == -1) {
+		return;
@@ -3109,45 +3102,15 @@
-	/* By tradition (is it a standard?) a baud rate of zero
-	   implies the line should be/has been closed.  A bit
-	   later in this routine such a test is performed. */
-
-	/* byte size and parity */
-	info->cor5 = 0;
-	info->cor4 = 0;
-	info->cor3 = (info->default_threshold
-		      ? info->default_threshold
-		      : baud_cor3[i]); /* receive threshold */
-	info->cor2 = CyETC;
-	switch(cflag & CSIZE){
-	case CS5:
-	    info->cor1 = Cy_5_BITS;
-	    break;
-	case CS6:
-	    info->cor1 = Cy_6_BITS;
-	    break;
-	case CS7:
-	    info->cor1 = Cy_7_BITS;
-	    break;
-	case CS8:
-	    info->cor1 = Cy_8_BITS;
-	    break;
-	}
-	if(cflag & CSTOPB){
-	    info->cor1 |= Cy_2_STOP;
-	}
-	if (cflag & PARENB){
-	    if (cflag & PARODD){
-		info->cor1 |= CyPARITY_O;
-	    }else{
-		info->cor1 |= CyPARITY_E;
-	    }
-	}else{
-	    info->cor1 |= CyPARITY_NONE;
-	}
-	    
-	/* CTS flow control flag */
-	if (cflag & CRTSCTS){
-	    info->flags |= ASYNC_CTS_FLOW;
-	    info->cor2 |= CyCtsAE;
-	}else{
-	    info->flags &= ~ASYNC_CTS_FLOW;
-	    info->cor2 &= ~CyCtsAE;
+	cflag = info->tty->termios->c_cflag;
+	iflag = info->tty->termios->c_iflag;
+
+	/*
+	 * Set up the tty->alt_speed kludge
+	 */
+	if (info->tty) {
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+			info->tty->alt_speed = 57600;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+			info->tty->alt_speed = 115200;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+			info->tty->alt_speed = 230400;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+			info->tty->alt_speed = 460800;
@@ -3155,4 +3118,112 @@
-	if (cflag & CLOCAL)
-	    info->flags &= ~ASYNC_CHECK_CD;
-	else
-	    info->flags |= ASYNC_CHECK_CD;
+
+	card = info->card;
+	channel = (info->line) - (cy_card[card].first_line);
+	chip_number = channel / 4;
+
+	if (!IS_CYC_Z(cy_card[card])) {
+
+		index = cy_card[card].bus_index;
+
+		/* baud rate */
+		baud = tty_get_baud_rate(info->tty);
+		if (baud == 38400 && (info->flags & ASYNC_SPD_MASK) ==
+				ASYNC_SPD_CUST) {
+			if (info->custom_divisor)
+				baud_rate = info->baud / info->custom_divisor;
+			else
+				baud_rate = info->baud;
+		} else if (baud > CD1400_MAX_SPEED) {
+			baud = CD1400_MAX_SPEED;
+		}
+		/* find the baud index */
+		for (i = 0; i < 20; i++) {
+			if (baud == baud_table[i]) {
+				break;
+			}
+		}
+		if (i == 20) {
+			i = 19;	/* CD1400_MAX_SPEED */
+		}
+
+		if (baud == 38400 && (info->flags & ASYNC_SPD_MASK) ==
+				ASYNC_SPD_CUST) {
+			cyy_baud_calc(info, baud_rate);
+		} else {
+			if (info->chip_rev >= CD1400_REV_J) {
+				/* It is a CD1400 rev. J or later */
+				info->tbpr = baud_bpr_60[i];	/* Tx BPR */
+				info->tco = baud_co_60[i];	/* Tx CO */
+				info->rbpr = baud_bpr_60[i];	/* Rx BPR */
+				info->rco = baud_co_60[i];	/* Rx CO */
+			} else {
+				info->tbpr = baud_bpr_25[i];	/* Tx BPR */
+				info->tco = baud_co_25[i];	/* Tx CO */
+				info->rbpr = baud_bpr_25[i];	/* Rx BPR */
+				info->rco = baud_co_25[i];	/* Rx CO */
+			}
+		}
+		if (baud_table[i] == 134) {
+			/* get it right for 134.5 baud */
+			info->timeout = (info->xmit_fifo_size * HZ * 30 / 269) +
+					2;
+		} else if (baud == 38400 && (info->flags & ASYNC_SPD_MASK) ==
+				ASYNC_SPD_CUST) {
+			info->timeout = (info->xmit_fifo_size * HZ * 15 /
+					baud_rate) + 2;
+		} else if (baud_table[i]) {
+			info->timeout = (info->xmit_fifo_size * HZ * 15 /
+					baud_table[i]) + 2;
+			/* this needs to be propagated into the card info */
+		} else {
+			info->timeout = 0;
+		}
+		/* By tradition (is it a standard?) a baud rate of zero
+		   implies the line should be/has been closed.  A bit
+		   later in this routine such a test is performed. */
+
+		/* byte size and parity */
+		info->cor5 = 0;
+		info->cor4 = 0;
+		/* receive threshold */
+		info->cor3 = (info->default_threshold ?
+				info->default_threshold : baud_cor3[i]);
+		info->cor2 = CyETC;
+		switch (cflag & CSIZE) {
+		case CS5:
+			info->cor1 = Cy_5_BITS;
+			break;
+		case CS6:
+			info->cor1 = Cy_6_BITS;
+			break;
+		case CS7:
+			info->cor1 = Cy_7_BITS;
+			break;
+		case CS8:
+			info->cor1 = Cy_8_BITS;
+			break;
+		}
+		if (cflag & CSTOPB) {
+			info->cor1 |= Cy_2_STOP;
+		}
+		if (cflag & PARENB) {
+			if (cflag & PARODD) {
+				info->cor1 |= CyPARITY_O;
+			} else {
+				info->cor1 |= CyPARITY_E;
+			}
+		} else {
+			info->cor1 |= CyPARITY_NONE;
+		}
+
+		/* CTS flow control flag */
+		if (cflag & CRTSCTS) {
+			info->flags |= ASYNC_CTS_FLOW;
+			info->cor2 |= CyCtsAE;
+		} else {
+			info->flags &= ~ASYNC_CTS_FLOW;
+			info->cor2 &= ~CyCtsAE;
+		}
+		if (cflag & CLOCAL)
+			info->flags &= ~ASYNC_CHECK_CD;
+		else
+			info->flags |= ASYNC_CHECK_CD;
@@ -3170,3 +3241,4 @@
-	chip = channel>>2;
-	channel &= 0x03;
-	base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
+		chip = channel >> 2;
+		channel &= 0x03;
+		base_addr = cy_card[card].base_addr +
+			(cy_chip_offset[chip] << index);
@@ -3174,2 +3246,2 @@
-	CY_LOCK(info, flags);
-	    cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
+		CY_LOCK(info, flags);
+		cy_writeb(base_addr + (CyCAR << index), (u_char) channel);
@@ -3177 +3249 @@
-	   /* tx and rx baud rate */
+		/* tx and rx baud rate */
@@ -3179,59 +3251,39 @@
-	    cy_writeb(base_addr+(CyTCOR<<index), info->tco);
-	    cy_writeb(base_addr+(CyTBPR<<index), info->tbpr);
-	    cy_writeb(base_addr+(CyRCOR<<index), info->rco);
-	    cy_writeb(base_addr+(CyRBPR<<index), info->rbpr);
-
-	    /* set line characteristics  according configuration */
-
-	    cy_writeb(base_addr+(CySCHR1<<index), 
-		      START_CHAR(info->tty));
-	    cy_writeb(base_addr+(CySCHR2<<index), 
-		      STOP_CHAR(info->tty));
-	    cy_writeb(base_addr+(CyCOR1<<index), info->cor1);
-	    cy_writeb(base_addr+(CyCOR2<<index), info->cor2);
-	    cy_writeb(base_addr+(CyCOR3<<index), info->cor3);
-	    cy_writeb(base_addr+(CyCOR4<<index), info->cor4);
-	    cy_writeb(base_addr+(CyCOR5<<index), info->cor5);
-
-	    cyy_issue_cmd(base_addr,
-		     CyCOR_CHANGE|CyCOR1ch|CyCOR2ch|CyCOR3ch,index);
-
-	    cy_writeb(base_addr+(CyCAR<<index), 
-		      (u_char)channel); /* !!! Is this needed? */
-	    cy_writeb(base_addr+(CyRTPR<<index), (info->default_timeout
-					         ? info->default_timeout
-					         : 0x02)); /* 10ms rx timeout */
-
-	    if (C_CLOCAL(info->tty)) {
-		/* without modem intr */
-		cy_writeb(base_addr+(CySRER<<index),
-                   cy_readb(base_addr+(CySRER<<index)) | CyMdmCh); 
-					/* act on 1->0 modem transitions */
-                if ((cflag & CRTSCTS) && info->rflow) {
-                        cy_writeb(base_addr+(CyMCOR1<<index), 
-                                  (CyCTS|rflow_thr[i]));
-                } else {
-                        cy_writeb(base_addr+(CyMCOR1<<index), CyCTS);
-                }
-					/* act on 0->1 modem transitions */
-		cy_writeb(base_addr+(CyMCOR2<<index), CyCTS);
-	    } else {
-		/* without modem intr */
-		cy_writeb(base_addr+(CySRER<<index),
-                   cy_readb(base_addr+(CySRER<<index)) | CyMdmCh); 
-					/* act on 1->0 modem transitions */
-                if ((cflag & CRTSCTS) && info->rflow) {
-			cy_writeb(base_addr+(CyMCOR1<<index), 
-        	                  (CyDSR|CyCTS|CyRI|CyDCD|rflow_thr[i]));
-                } else {
-			cy_writeb(base_addr+(CyMCOR1<<index), 
-                                  CyDSR|CyCTS|CyRI|CyDCD);
-                }
-					/* act on 0->1 modem transitions */
-		cy_writeb(base_addr+(CyMCOR2<<index), 
-			  CyDSR|CyCTS|CyRI|CyDCD);
-	    }
-
-	    if(i == 0){ /* baud rate is zero, turn off line */
-	        if (info->rtsdtr_inv) {
-			cy_writeb(base_addr+(CyMSVR1<<index), ~CyRTS);
+		cy_writeb(base_addr + (CyTCOR << index), info->tco);
+		cy_writeb(base_addr + (CyTBPR << index), info->tbpr);
+		cy_writeb(base_addr + (CyRCOR << index), info->rco);
+		cy_writeb(base_addr + (CyRBPR << index), info->rbpr);
+
+		/* set line characteristics  according configuration */
+
+		cy_writeb(base_addr + (CySCHR1 << index),
+			  START_CHAR(info->tty));
+		cy_writeb(base_addr + (CySCHR2 << index), STOP_CHAR(info->tty));
+		cy_writeb(base_addr + (CyCOR1 << index), info->cor1);
+		cy_writeb(base_addr + (CyCOR2 << index), info->cor2);
+		cy_writeb(base_addr + (CyCOR3 << index), info->cor3);
+		cy_writeb(base_addr + (CyCOR4 << index), info->cor4);
+		cy_writeb(base_addr + (CyCOR5 << index), info->cor5);
+
+		cyy_issue_cmd(base_addr, CyCOR_CHANGE | CyCOR1ch | CyCOR2ch |
+				CyCOR3ch, index);
+
+		cy_writeb(base_addr + (CyCAR << index), (u_char) channel);	/* !!! Is this needed? */
+		cy_writeb(base_addr + (CyRTPR << index),
+			(info->default_timeout ? info->default_timeout : 0x02));
+		/* 10ms rx timeout */
+
+		if (C_CLOCAL(info->tty)) {
+			/* without modem intr */
+			cy_writeb(base_addr + (CySRER << index),
+				  cy_readb(base_addr +
+					   (CySRER << index)) | CyMdmCh);
+			/* act on 1->0 modem transitions */
+			if ((cflag & CRTSCTS) && info->rflow) {
+				cy_writeb(base_addr + (CyMCOR1 << index),
+					  (CyCTS | rflow_thr[i]));
+			} else {
+				cy_writeb(base_addr + (CyMCOR1 << index),
+					  CyCTS);
+			}
+			/* act on 0->1 modem transitions */
+			cy_writeb(base_addr + (CyMCOR2 << index), CyCTS);
@@ -3239 +3291,16 @@
-                        cy_writeb(base_addr+(CyMSVR2<<index), ~CyDTR);
+			/* without modem intr */
+			cy_writeb(base_addr + (CySRER << index),
+				  cy_readb(base_addr +
+					   (CySRER << index)) | CyMdmCh);
+			/* act on 1->0 modem transitions */
+			if ((cflag & CRTSCTS) && info->rflow) {
+				cy_writeb(base_addr + (CyMCOR1 << index),
+					  (CyDSR | CyCTS | CyRI | CyDCD |
+					   rflow_thr[i]));
+			} else {
+				cy_writeb(base_addr + (CyMCOR1 << index),
+					  CyDSR | CyCTS | CyRI | CyDCD);
+			}
+			/* act on 0->1 modem transitions */
+			cy_writeb(base_addr + (CyMCOR2 << index),
+				  CyDSR | CyCTS | CyRI | CyDCD);
@@ -3240,0 +3308,9 @@
+
+		if (i == 0) {	/* baud rate is zero, turn off line */
+			if (info->rtsdtr_inv) {
+				cy_writeb(base_addr + (CyMSVR1 << index),
+					  ~CyRTS);
+			} else {
+				cy_writeb(base_addr + (CyMSVR2 << index),
+					  ~CyDTR);
+			}
@@ -3242,11 +3318,13 @@
-		printk("cyc:set_line_char dropping DTR\n");
-		printk("     status: 0x%x, 0x%x\n", 
-		    cy_readb(base_addr+(CyMSVR1<<index)),
-		    cy_readb(base_addr+(CyMSVR2<<index)));
-#endif
-	    }else{
-                if (info->rtsdtr_inv) {
-			cy_writeb(base_addr+(CyMSVR1<<index), CyRTS);
-                } else {
-			cy_writeb(base_addr+(CyMSVR2<<index), CyDTR);
-                }
+			printk("cyc:set_line_char dropping DTR\n");
+			printk("     status: 0x%x, 0x%x\n",
+				cy_readb(base_addr + (CyMSVR1 << index)),
+				cy_readb(base_addr + (CyMSVR2 << index)));
+#endif
+		} else {
+			if (info->rtsdtr_inv) {
+				cy_writeb(base_addr + (CyMSVR1 << index),
+					  CyRTS);
+			} else {
+				cy_writeb(base_addr + (CyMSVR2 << index),
+					  CyDTR);
+			}
@@ -3254,4 +3332,4 @@
-		printk("cyc:set_line_char raising DTR\n");
-		printk("     status: 0x%x, 0x%x\n",
-		    cy_readb(base_addr+(CyMSVR1<<index)),
-		    cy_readb(base_addr+(CyMSVR2<<index)));
+			printk("cyc:set_line_char raising DTR\n");
+			printk("     status: 0x%x, 0x%x\n",
+				cy_readb(base_addr + (CyMSVR1 << index)),
+				cy_readb(base_addr + (CyMSVR2 << index)));
@@ -3259 +3337 @@
-	    }
+		}
@@ -3261,4 +3339,4 @@
-	    if (info->tty){
-		clear_bit(TTY_IO_ERROR, &info->tty->flags);
-	    }
-	CY_UNLOCK(info, flags);
+		if (info->tty) {
+			clear_bit(TTY_IO_ERROR, &info->tty->flags);
+		}
+		CY_UNLOCK(info, flags);
@@ -3266,13 +3344,13 @@
-    } else {
-      struct FIRM_ID __iomem *firm_id;
-      struct ZFW_CTRL __iomem *zfw_ctrl;
-      struct BOARD_CTRL __iomem *board_ctrl;
-      struct CH_CTRL __iomem *ch_ctrl;
-      struct BUF_CTRL __iomem *buf_ctrl;
-      uclong sw_flow;
-      int retval;
-
-        firm_id = cy_card[card].base_addr + ID_ADDRESS;
-        if (!ISZLOADED(cy_card[card])) {
-	    return;
-	}
+	} else {
+		struct FIRM_ID __iomem *firm_id;
+		struct ZFW_CTRL __iomem *zfw_ctrl;
+		struct BOARD_CTRL __iomem *board_ctrl;
+		struct CH_CTRL __iomem *ch_ctrl;
+		struct BUF_CTRL __iomem *buf_ctrl;
+		uclong sw_flow;
+		int retval;
+
+		firm_id = cy_card[card].base_addr + ID_ADDRESS;
+		if (!ISZLOADED(cy_card[card])) {
+			return;
+		}
@@ -3280,4 +3358,5 @@
-	zfw_ctrl = cy_card[card].base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
-	board_ctrl = &zfw_ctrl->board_ctrl;
-	ch_ctrl = &(zfw_ctrl->ch_ctrl[channel]);
-	buf_ctrl = &zfw_ctrl->buf_ctrl[channel];
+		zfw_ctrl = cy_card[card].base_addr +
+			(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		board_ctrl = &zfw_ctrl->board_ctrl;
+		ch_ctrl = &(zfw_ctrl->ch_ctrl[channel]);
+		buf_ctrl = &zfw_ctrl->buf_ctrl[channel];
@@ -3285,25 +3364,96 @@
-	/* baud rate */
-	baud = tty_get_baud_rate(info->tty);
-	if ((baud == 38400) &&
-	    ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)) {
-	    if (info->custom_divisor)
-		baud_rate = info->baud / info->custom_divisor;
-	    else
-		baud_rate = info->baud;
-	} else if (baud > CYZ_MAX_SPEED) {
-	    baud = CYZ_MAX_SPEED;
-	}
-	cy_writel(&ch_ctrl->comm_baud , baud);
-
-	if (baud == 134) {
-	    /* get it right for 134.5 baud */
-	    info->timeout = (info->xmit_fifo_size*HZ*30/269) + 2;
-	} else if ((baud == 38400) &&
-		   ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST)) {
-	    info->timeout = (info->xmit_fifo_size*HZ*15/baud_rate) + 2;
-	} else if (baud) {
-	    info->timeout = (info->xmit_fifo_size*HZ*15/baud) + 2;
-	    /* this needs to be propagated into the card info */
-	} else {
-	    info->timeout = 0;
-	}
+		/* baud rate */
+		baud = tty_get_baud_rate(info->tty);
+		if (baud == 38400 && (info->flags & ASYNC_SPD_MASK) ==
+				ASYNC_SPD_CUST) {
+			if (info->custom_divisor)
+				baud_rate = info->baud / info->custom_divisor;
+			else
+				baud_rate = info->baud;
+		} else if (baud > CYZ_MAX_SPEED) {
+			baud = CYZ_MAX_SPEED;
+		}
+		cy_writel(&ch_ctrl->comm_baud, baud);
+
+		if (baud == 134) {
+			/* get it right for 134.5 baud */
+			info->timeout = (info->xmit_fifo_size * HZ * 30 / 269) +
+					2;
+		} else if (baud == 38400 && (info->flags & ASYNC_SPD_MASK) ==
+				ASYNC_SPD_CUST) {
+			info->timeout = (info->xmit_fifo_size * HZ * 15 /
+					baud_rate) + 2;
+		} else if (baud) {
+			info->timeout = (info->xmit_fifo_size * HZ * 15 /
+					baud) + 2;
+			/* this needs to be propagated into the card info */
+		} else {
+			info->timeout = 0;
+		}
+
+		/* byte size and parity */
+		switch (cflag & CSIZE) {
+		case CS5:
+			cy_writel(&ch_ctrl->comm_data_l, C_DL_CS5);
+			break;
+		case CS6:
+			cy_writel(&ch_ctrl->comm_data_l, C_DL_CS6);
+			break;
+		case CS7:
+			cy_writel(&ch_ctrl->comm_data_l, C_DL_CS7);
+			break;
+		case CS8:
+			cy_writel(&ch_ctrl->comm_data_l, C_DL_CS8);
+			break;
+		}
+		if (cflag & CSTOPB) {
+			cy_writel(&ch_ctrl->comm_data_l,
+				  cy_readl(&ch_ctrl->comm_data_l) | C_DL_2STOP);
+		} else {
+			cy_writel(&ch_ctrl->comm_data_l,
+				  cy_readl(&ch_ctrl->comm_data_l) | C_DL_1STOP);
+		}
+		if (cflag & PARENB) {
+			if (cflag & PARODD) {
+				cy_writel(&ch_ctrl->comm_parity, C_PR_ODD);
+			} else {
+				cy_writel(&ch_ctrl->comm_parity, C_PR_EVEN);
+			}
+		} else {
+			cy_writel(&ch_ctrl->comm_parity, C_PR_NONE);
+		}
+
+		/* CTS flow control flag */
+		if (cflag & CRTSCTS) {
+			cy_writel(&ch_ctrl->hw_flow,
+				  cy_readl(&ch_ctrl->
+					   hw_flow) | C_RS_CTS | C_RS_RTS);
+		} else {
+			cy_writel(&ch_ctrl->hw_flow,
+				  cy_readl(&ch_ctrl->
+					   hw_flow) & ~(C_RS_CTS | C_RS_RTS));
+		}
+		/* As the HW flow control is done in firmware, the driver
+		   doesn't need to care about it */
+		info->flags &= ~ASYNC_CTS_FLOW;
+
+		/* XON/XOFF/XANY flow control flags */
+		sw_flow = 0;
+		if (iflag & IXON) {
+			sw_flow |= C_FL_OXX;
+			if (iflag & IXANY)
+				sw_flow |= C_FL_OIXANY;
+		}
+		cy_writel(&ch_ctrl->sw_flow, sw_flow);
+
+		retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_IOCTL, 0L);
+		if (retval != 0) {
+			printk("cyc:set_line_char retval on ttyC%d was %x\n",
+				info->line, retval);
+		}
+
+		/* CD sensitivity */
+		if (cflag & CLOCAL) {
+			info->flags &= ~ASYNC_CHECK_CD;
+		} else {
+			info->flags |= ASYNC_CHECK_CD;
+		}
@@ -3311,61 +3461,3 @@
-	/* byte size and parity */
-	switch(cflag & CSIZE){
-	case CS5: cy_writel(&ch_ctrl->comm_data_l , C_DL_CS5); break;
-	case CS6: cy_writel(&ch_ctrl->comm_data_l , C_DL_CS6); break;
-	case CS7: cy_writel(&ch_ctrl->comm_data_l , C_DL_CS7); break;
-	case CS8: cy_writel(&ch_ctrl->comm_data_l , C_DL_CS8); break;
-	}
-	if(cflag & CSTOPB){
-	    cy_writel(&ch_ctrl->comm_data_l,
-               cy_readl(&ch_ctrl->comm_data_l) | C_DL_2STOP);
-	}else{
-	    cy_writel(&ch_ctrl->comm_data_l,
-               cy_readl(&ch_ctrl->comm_data_l) | C_DL_1STOP);
-	}
-	if (cflag & PARENB){
-	    if (cflag & PARODD){
-		cy_writel(&ch_ctrl->comm_parity , C_PR_ODD);
-	    }else{
-		cy_writel(&ch_ctrl->comm_parity , C_PR_EVEN);
-	    }
-	}else{
-	    cy_writel(&ch_ctrl->comm_parity , C_PR_NONE);
-	}
-
-	/* CTS flow control flag */
-	if (cflag & CRTSCTS){
-	    cy_writel(&ch_ctrl->hw_flow,
-               cy_readl(&ch_ctrl->hw_flow) | C_RS_CTS | C_RS_RTS);
-	}else{
-	    cy_writel(&ch_ctrl->hw_flow,
-               cy_readl(&ch_ctrl->hw_flow) & ~(C_RS_CTS | C_RS_RTS));
-	}
-	/* As the HW flow control is done in firmware, the driver doesn't
-	   need to care about it */
-	info->flags &= ~ASYNC_CTS_FLOW;
-
-	/* XON/XOFF/XANY flow control flags */
-	sw_flow = 0;
-	if (iflag & IXON){
-	    sw_flow |= C_FL_OXX;
-	    if (iflag & IXANY)
-		sw_flow |= C_FL_OIXANY;
-	}
-	cy_writel(&ch_ctrl->sw_flow, sw_flow);
-
-	retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_IOCTL, 0L);
-	if (retval != 0){
-	    printk("cyc:set_line_char retval on ttyC%d was %x\n",
-		   info->line, retval);
-	}
-
-	/* CD sensitivity */
-	if (cflag & CLOCAL){
-	    info->flags &= ~ASYNC_CHECK_CD;
-	}else{
-	    info->flags |= ASYNC_CHECK_CD;
-	}
-
-	if(baud == 0){ /* baud rate is zero, turn off line */
-	    cy_writel(&ch_ctrl->rs_control,
-               cy_readl(&ch_ctrl->rs_control) & ~C_RS_DTR);
+		if (baud == 0) {	/* baud rate is zero, turn off line */
+			cy_writel(&ch_ctrl->rs_control,
+				  cy_readl(&ch_ctrl->rs_control) & ~C_RS_DTR);
@@ -3373 +3465 @@
-	    printk("cyc:set_line_char dropping Z DTR\n");
+			printk("cyc:set_line_char dropping Z DTR\n");
@@ -3375,3 +3467,3 @@
-	}else{
-	    cy_writel(&ch_ctrl->rs_control,
-               cy_readl(&ch_ctrl->rs_control) | C_RS_DTR);
+		} else {
+			cy_writel(&ch_ctrl->rs_control,
+				  cy_readl(&ch_ctrl->rs_control) | C_RS_DTR);
@@ -3379 +3471 @@
-	    printk("cyc:set_line_char raising Z DTR\n");
+			printk("cyc:set_line_char raising Z DTR\n");
@@ -3381 +3473 @@
-	}
+		}
@@ -3383,5 +3475,5 @@
-	retval = cyz_issue_cmd( &cy_card[card], channel, C_CM_IOCTLM, 0L);
-	if (retval != 0){
-	    printk("cyc:set_line_char(2) retval on ttyC%d was %x\n",
-		   info->line, retval);
-	}
+		retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_IOCTLM,0L);
+		if (retval != 0) {
+			printk("cyc:set_line_char(2) retval on ttyC%d was %x\n",
+				info->line, retval);
+		}
@@ -3389,2 +3481,3 @@
-	if (info->tty){
-	    clear_bit(TTY_IO_ERROR, &info->tty->flags);
+		if (info->tty) {
+			clear_bit(TTY_IO_ERROR, &info->tty->flags);
+		}
@@ -3392,3 +3485 @@
-    }
-} /* set_line_char */
-
+}				/* set_line_char */
@@ -3397,2 +3488,2 @@
-get_serial_info(struct cyclades_port * info,
-                           struct serial_struct __user * retinfo)
+get_serial_info(struct cyclades_port *info,
+		struct serial_struct __user * retinfo)
@@ -3400,17 +3491,2 @@
-  struct serial_struct tmp;
-  struct cyclades_card *cinfo = &cy_card[info->card];
-
-    if (!retinfo)
-            return -EFAULT;
-    memset(&tmp, 0, sizeof(tmp));
-    tmp.type = info->type;
-    tmp.line = info->line;
-    tmp.port = info->card * 0x100 + info->line - cinfo->first_line;
-    tmp.irq = cinfo->irq;
-    tmp.flags = info->flags;
-    tmp.close_delay = info->close_delay;
-    tmp.baud_base = info->baud;
-    tmp.custom_divisor = info->custom_divisor;
-    tmp.hub6 = 0;               /*!!!*/
-    return copy_to_user(retinfo,&tmp,sizeof(*retinfo))?-EFAULT:0;
-} /* get_serial_info */
+	struct serial_struct tmp;
+	struct cyclades_card *cinfo = &cy_card[info->card];
@@ -3417,0 +3494,14 @@
+	if (!retinfo)
+		return -EFAULT;
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.type = info->type;
+	tmp.line = info->line;
+	tmp.port = info->card * 0x100 + info->line - cinfo->first_line;
+	tmp.irq = cinfo->irq;
+	tmp.flags = info->flags;
+	tmp.close_delay = info->close_delay;
+	tmp.baud_base = info->baud;
+	tmp.custom_divisor = info->custom_divisor;
+	tmp.hub6 = 0;		/*!!! */
+	return copy_to_user(retinfo, &tmp, sizeof(*retinfo)) ? -EFAULT : 0;
+}				/* get_serial_info */
@@ -3420,2 +3510,2 @@
-set_serial_info(struct cyclades_port * info,
-                           struct serial_struct __user * new_info)
+set_serial_info(struct cyclades_port *info,
+		struct serial_struct __user * new_info)
@@ -3423,2 +3513,25 @@
-  struct serial_struct new_serial;
-  struct cyclades_port old_info;
+	struct serial_struct new_serial;
+	struct cyclades_port old_info;
+
+	if (copy_from_user(&new_serial, new_info, sizeof(new_serial)))
+		return -EFAULT;
+	old_info = *info;
+
+	if (!capable(CAP_SYS_ADMIN)) {
+		if (new_serial.close_delay != info->close_delay ||
+				new_serial.baud_base != info->baud ||
+				(new_serial.flags & ASYNC_FLAGS &
+					~ASYNC_USR_MASK) !=
+				(info->flags & ASYNC_FLAGS & ~ASYNC_USR_MASK))
+			return -EPERM;
+		info->flags = (info->flags & ~ASYNC_USR_MASK) |
+				(new_serial.flags & ASYNC_USR_MASK);
+		info->baud = new_serial.baud_base;
+		info->custom_divisor = new_serial.custom_divisor;
+		goto check_and_exit;
+	}
+
+	/*
+	 * OK, past this point, all the error checking has been done.
+	 * At this point, we start making changes.....
+	 */
@@ -3426,29 +3539,6 @@
-    if (copy_from_user(&new_serial,new_info,sizeof(new_serial)))
-	return -EFAULT;
-    old_info = *info;
-
-    if (!capable(CAP_SYS_ADMIN)) {
-            if ((new_serial.close_delay != info->close_delay) ||
-		(new_serial.baud_base != info->baud) ||
-		((new_serial.flags & ASYNC_FLAGS & ~ASYNC_USR_MASK) !=
-		 (info->flags & ASYNC_FLAGS & ~ASYNC_USR_MASK)))
-                    return -EPERM;
-            info->flags = ((info->flags & ~ASYNC_USR_MASK) |
-                           (new_serial.flags & ASYNC_USR_MASK));
-            info->baud = new_serial.baud_base;
-	    info->custom_divisor = new_serial.custom_divisor;
-            goto check_and_exit;
-    }
-
-
-    /*
-     * OK, past this point, all the error checking has been done.
-     * At this point, we start making changes.....
-     */
-
-    info->baud = new_serial.baud_base;
-    info->custom_divisor = new_serial.custom_divisor;
-    info->flags = ((info->flags & ~ASYNC_FLAGS) |
-                    (new_serial.flags & ASYNC_FLAGS));
-    info->close_delay = new_serial.close_delay * HZ/100;
-    info->closing_wait = new_serial.closing_wait * HZ/100;
+	info->baud = new_serial.baud_base;
+	info->custom_divisor = new_serial.custom_divisor;
+	info->flags = (info->flags & ~ASYNC_FLAGS) |
+			(new_serial.flags & ASYNC_FLAGS);
+	info->close_delay = new_serial.close_delay * HZ / 100;
+	info->closing_wait = new_serial.closing_wait * HZ / 100;
@@ -3457,7 +3547,7 @@
-    if (info->flags & ASYNC_INITIALIZED){
-        set_line_char(info);
-        return 0;
-    }else{
-        return startup(info);
-    }
-} /* set_serial_info */
+	if (info->flags & ASYNC_INITIALIZED) {
+		set_line_char(info);
+		return 0;
+	} else {
+		return startup(info);
+	}
+}				/* set_serial_info */
@@ -3475 +3565 @@
-static int get_lsr_info(struct cyclades_port *info, unsigned int __user *value)
+static int get_lsr_info(struct cyclades_port *info, unsigned int __user * value)
@@ -3477,13 +3567,5 @@
-    int card, chip, channel, index;
-    unsigned char status;
-    unsigned int result;
-    unsigned long flags;
-    void __iomem *base_addr;
-
-    card = info->card;
-    channel = (info->line) - (cy_card[card].first_line);
-    if (!IS_CYC_Z(cy_card[card])) {
-	chip = channel>>2;
-	channel &= 0x03;
-	index = cy_card[card].bus_index;
-	base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
+	int card, chip, channel, index;
+	unsigned char status;
+	unsigned int result;
+	unsigned long flags;
+	void __iomem *base_addr;
@@ -3491,9 +3573,19 @@
-	CY_LOCK(info, flags);
-	status = cy_readb(base_addr+(CySRER<<index)) & (CyTxRdy|CyTxMpty);
-	CY_UNLOCK(info, flags);
-	result = (status ? 0 : TIOCSER_TEMT);
-    } else {
-	/* Not supported yet */
-	return -EINVAL;
-    }
-    return put_user(result, (unsigned long __user *) value);
+	card = info->card;
+	channel = (info->line) - (cy_card[card].first_line);
+	if (!IS_CYC_Z(cy_card[card])) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		index = cy_card[card].bus_index;
+		base_addr =
+		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
+
+		CY_LOCK(info, flags);
+		status = cy_readb(base_addr + (CySRER << index)) &
+				(CyTxRdy | CyTxMpty);
+		CY_UNLOCK(info, flags);
+		result = (status ? 0 : TIOCSER_TEMT);
+	} else {
+		/* Not supported yet */
+		return -EINVAL;
+	}
+	return put_user(result, (unsigned long __user *)value);
@@ -3502,2 +3594 @@
-static int
-cy_tiocmget(struct tty_struct *tty, struct file *file)
+static int cy_tiocmget(struct tty_struct *tty, struct file *file)
@@ -3505,22 +3596,11 @@
-  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
-  int card,chip,channel,index;
-  void __iomem *base_addr;
-  unsigned long flags;
-  unsigned char status;
-  unsigned long lstatus;
-  unsigned int result;
-  struct FIRM_ID __iomem *firm_id;
-  struct ZFW_CTRL __iomem *zfw_ctrl;
-  struct BOARD_CTRL __iomem *board_ctrl;
-  struct CH_CTRL __iomem *ch_ctrl;
-
-    if (serial_paranoia_check(info, tty->name, __FUNCTION__))
-	return -ENODEV;
-
-    card = info->card;
-    channel = (info->line) - (cy_card[card].first_line);
-    if (!IS_CYC_Z(cy_card[card])) {
-	chip = channel>>2;
-	channel &= 0x03;
-	index = cy_card[card].bus_index;
-	base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	int card, chip, channel, index;
+	void __iomem *base_addr;
+	unsigned long flags;
+	unsigned char status;
+	unsigned long lstatus;
+	unsigned int result;
+	struct FIRM_ID __iomem *firm_id;
+	struct ZFW_CTRL __iomem *zfw_ctrl;
+	struct BOARD_CTRL __iomem *board_ctrl;
+	struct CH_CTRL __iomem *ch_ctrl;
@@ -3528,5 +3608,17 @@
-	CY_LOCK(info, flags);
-	    cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
-	    status = cy_readb(base_addr+(CyMSVR1<<index));
-	    status |= cy_readb(base_addr+(CyMSVR2<<index));
-	CY_UNLOCK(info, flags);
+	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+		return -ENODEV;
+
+	card = info->card;
+	channel = (info->line) - (cy_card[card].first_line);
+	if (!IS_CYC_Z(cy_card[card])) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		index = cy_card[card].bus_index;
+		base_addr =
+		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
+
+		CY_LOCK(info, flags);
+		cy_writeb(base_addr + (CyCAR << index), (u_char) channel);
+		status = cy_readb(base_addr + (CyMSVR1 << index));
+		status |= cy_readb(base_addr + (CyMSVR2 << index));
+		CY_UNLOCK(info, flags);
@@ -3534,3 +3626,11 @@
-        if (info->rtsdtr_inv) {
-	    result =  ((status  & CyRTS) ? TIOCM_DTR : 0)
-		    | ((status  & CyDTR) ? TIOCM_RTS : 0);
+		if (info->rtsdtr_inv) {
+			result = ((status & CyRTS) ? TIOCM_DTR : 0) |
+				((status & CyDTR) ? TIOCM_RTS : 0);
+		} else {
+			result = ((status & CyRTS) ? TIOCM_RTS : 0) |
+				((status & CyDTR) ? TIOCM_DTR : 0);
+		}
+		result |= ((status & CyDCD) ? TIOCM_CAR : 0) |
+			((status & CyRI) ? TIOCM_RNG : 0) |
+			((status & CyDSR) ? TIOCM_DSR : 0) |
+			((status & CyCTS) ? TIOCM_CTS : 0);
@@ -3538,34 +3638,5 @@
-	    result =  ((status  & CyRTS) ? TIOCM_RTS : 0)
-		    | ((status  & CyDTR) ? TIOCM_DTR : 0);
-	}
-	result |=  ((status  & CyDCD) ? TIOCM_CAR : 0)
-		 | ((status  & CyRI) ? TIOCM_RNG : 0)
-		 | ((status  & CyDSR) ? TIOCM_DSR : 0)
-		 | ((status  & CyCTS) ? TIOCM_CTS : 0);
-    } else {
-	base_addr = cy_card[card].base_addr;
-
-        if (cy_card[card].num_chips != -1){
-	    return -EINVAL;
-	}
-
-	firm_id = cy_card[card].base_addr + ID_ADDRESS;
-        if (ISZLOADED(cy_card[card])) {
-	    zfw_ctrl = cy_card[card].base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
-	    board_ctrl = &zfw_ctrl->board_ctrl;
-	    ch_ctrl = zfw_ctrl->ch_ctrl;
-	    lstatus = cy_readl(&ch_ctrl[channel].rs_status);
-	    result =  ((lstatus  & C_RS_RTS) ? TIOCM_RTS : 0)
-		    | ((lstatus  & C_RS_DTR) ? TIOCM_DTR : 0)
-	            | ((lstatus  & C_RS_DCD) ? TIOCM_CAR : 0)
-		    | ((lstatus  & C_RS_RI) ? TIOCM_RNG : 0)
-		    | ((lstatus  & C_RS_DSR) ? TIOCM_DSR : 0)
-		    | ((lstatus  & C_RS_CTS) ? TIOCM_CTS : 0);
-	}else{
-	    result = 0;
-	    return -ENODEV;
-	}
-
-    }
-    return result;
-} /* cy_tiomget */
+		base_addr = cy_card[card].base_addr;
+
+		if (cy_card[card].num_chips != -1) {
+			return -EINVAL;
+		}
@@ -3572,0 +3644,21 @@
+		firm_id = cy_card[card].base_addr + ID_ADDRESS;
+		if (ISZLOADED(cy_card[card])) {
+			zfw_ctrl = cy_card[card].base_addr +
+				(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+			board_ctrl = &zfw_ctrl->board_ctrl;
+			ch_ctrl = zfw_ctrl->ch_ctrl;
+			lstatus = cy_readl(&ch_ctrl[channel].rs_status);
+			result = ((lstatus & C_RS_RTS) ? TIOCM_RTS : 0) |
+				((lstatus & C_RS_DTR) ? TIOCM_DTR : 0) |
+				((lstatus & C_RS_DCD) ? TIOCM_CAR : 0) |
+				((lstatus & C_RS_RI) ? TIOCM_RNG : 0) |
+				((lstatus & C_RS_DSR) ? TIOCM_DSR : 0) |
+				((lstatus & C_RS_CTS) ? TIOCM_CTS : 0);
+		} else {
+			result = 0;
+			return -ENODEV;
+		}
+
+	}
+	return result;
+}				/* cy_tiomget */
@@ -3576 +3668 @@
-            unsigned int set, unsigned int clear)
+		unsigned int set, unsigned int clear)
@@ -3578,20 +3670,9 @@
-  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
-  int card,chip,channel,index;
-  void __iomem *base_addr;
-  unsigned long flags;
-  struct FIRM_ID __iomem *firm_id;
-  struct ZFW_CTRL __iomem *zfw_ctrl;
-  struct BOARD_CTRL __iomem *board_ctrl;
-  struct CH_CTRL __iomem *ch_ctrl;
-  int retval;
-
-    if (serial_paranoia_check(info, tty->name, __FUNCTION__))
-	return -ENODEV;
-
-    card = info->card;
-    channel = (info->line) - (cy_card[card].first_line);
-    if (!IS_CYC_Z(cy_card[card])) {
-	chip = channel>>2;
-	channel &= 0x03;
-	index = cy_card[card].bus_index;
-	base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	int card, chip, channel, index;
+	void __iomem *base_addr;
+	unsigned long flags;
+	struct FIRM_ID __iomem *firm_id;
+	struct ZFW_CTRL __iomem *zfw_ctrl;
+	struct BOARD_CTRL __iomem *board_ctrl;
+	struct CH_CTRL __iomem *ch_ctrl;
+	int retval;
@@ -3599,28 +3680,49 @@
-	if (set & TIOCM_RTS){
-		CY_LOCK(info, flags);
-	        cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
-                if (info->rtsdtr_inv) {
-			cy_writeb(base_addr+(CyMSVR2<<index), CyDTR);
-                } else {
-			cy_writeb(base_addr+(CyMSVR1<<index), CyRTS);
-                }
-		CY_UNLOCK(info, flags);
-	}
-	if (clear & TIOCM_RTS) {
-		CY_LOCK(info, flags);
-		cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
-                if (info->rtsdtr_inv) {
-			cy_writeb(base_addr+(CyMSVR2<<index), ~CyDTR);
-                } else {
-			cy_writeb(base_addr+(CyMSVR1<<index), ~CyRTS);
-                }
-		CY_UNLOCK(info, flags);
-	}
-	if (set & TIOCM_DTR){
-		CY_LOCK(info, flags);
-		cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
-                if (info->rtsdtr_inv) {
-			cy_writeb(base_addr+(CyMSVR1<<index), CyRTS);
-                } else {
-			cy_writeb(base_addr+(CyMSVR2<<index), CyDTR);
-                }
+	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+		return -ENODEV;
+
+	card = info->card;
+	channel = (info->line) - (cy_card[card].first_line);
+	if (!IS_CYC_Z(cy_card[card])) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		index = cy_card[card].bus_index;
+		base_addr =
+		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
+
+		if (set & TIOCM_RTS) {
+			CY_LOCK(info, flags);
+			cy_writeb(base_addr + (CyCAR << index),
+				  (u_char) channel);
+			if (info->rtsdtr_inv) {
+				cy_writeb(base_addr + (CyMSVR2 << index),
+					  CyDTR);
+			} else {
+				cy_writeb(base_addr + (CyMSVR1 << index),
+					  CyRTS);
+			}
+			CY_UNLOCK(info, flags);
+		}
+		if (clear & TIOCM_RTS) {
+			CY_LOCK(info, flags);
+			cy_writeb(base_addr + (CyCAR << index),
+				  (u_char) channel);
+			if (info->rtsdtr_inv) {
+				cy_writeb(base_addr + (CyMSVR2 << index),
+					  ~CyDTR);
+			} else {
+				cy_writeb(base_addr + (CyMSVR1 << index),
+					  ~CyRTS);
+			}
+			CY_UNLOCK(info, flags);
+		}
+		if (set & TIOCM_DTR) {
+			CY_LOCK(info, flags);
+			cy_writeb(base_addr + (CyCAR << index),
+				  (u_char) channel);
+			if (info->rtsdtr_inv) {
+				cy_writeb(base_addr + (CyMSVR1 << index),
+					  CyRTS);
+			} else {
+				cy_writeb(base_addr + (CyMSVR2 << index),
+					  CyDTR);
+			}
@@ -3628,4 +3730,4 @@
-		printk("cyc:set_modem_info raising DTR\n");
-		printk("     status: 0x%x, 0x%x\n",
-		    cy_readb(base_addr+(CyMSVR1<<index)), 
-                    cy_readb(base_addr+(CyMSVR2<<index)));
+			printk("cyc:set_modem_info raising DTR\n");
+			printk("     status: 0x%x, 0x%x\n",
+				cy_readb(base_addr + (CyMSVR1 << index)),
+				cy_readb(base_addr + (CyMSVR2 << index)));
@@ -3633,10 +3735,13 @@
-		CY_UNLOCK(info, flags);
-	}
-	if (clear & TIOCM_DTR) {
-		CY_LOCK(info, flags);
-		cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
-                if (info->rtsdtr_inv) {
-			cy_writeb(base_addr+(CyMSVR1<<index), ~CyRTS);
-                } else {
-			cy_writeb(base_addr+(CyMSVR2<<index), ~CyDTR);
-                }
+			CY_UNLOCK(info, flags);
+		}
+		if (clear & TIOCM_DTR) {
+			CY_LOCK(info, flags);
+			cy_writeb(base_addr + (CyCAR << index),
+				  (u_char) channel);
+			if (info->rtsdtr_inv) {
+				cy_writeb(base_addr + (CyMSVR1 << index),
+					  ~CyRTS);
+			} else {
+				cy_writeb(base_addr + (CyMSVR2 << index),
+					  ~CyDTR);
+			}
@@ -3645,4 +3750,4 @@
-		printk("cyc:set_modem_info dropping DTR\n");
-		printk("     status: 0x%x, 0x%x\n",
-		    cy_readb(base_addr+(CyMSVR1<<index)), 
-                    cy_readb(base_addr+(CyMSVR2<<index)));
+			printk("cyc:set_modem_info dropping DTR\n");
+			printk("     status: 0x%x, 0x%x\n",
+				cy_readb(base_addr + (CyMSVR1 << index)),
+				cy_readb(base_addr + (CyMSVR2 << index)));
@@ -3650,4 +3755,4 @@
-		CY_UNLOCK(info, flags);
-	}
-    } else {
-	base_addr = cy_card[card].base_addr;
+			CY_UNLOCK(info, flags);
+		}
+	} else {
+		base_addr = cy_card[card].base_addr;
@@ -3655,22 +3760,26 @@
-	firm_id = cy_card[card].base_addr + ID_ADDRESS;
-        if (ISZLOADED(cy_card[card])) {
-	    zfw_ctrl = cy_card[card].base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
-	    board_ctrl = &zfw_ctrl->board_ctrl;
-	    ch_ctrl = zfw_ctrl->ch_ctrl;
-
-	    if (set & TIOCM_RTS){
-		    CY_LOCK(info, flags);
-		    cy_writel(&ch_ctrl[channel].rs_control,
-                       cy_readl(&ch_ctrl[channel].rs_control) | C_RS_RTS);
-		    CY_UNLOCK(info, flags);
-	    }
-	    if (clear & TIOCM_RTS) {
-		    CY_LOCK(info, flags);
-		    cy_writel(&ch_ctrl[channel].rs_control,
-                       cy_readl(&ch_ctrl[channel].rs_control) & ~C_RS_RTS);
-		    CY_UNLOCK(info, flags);
-	    }
-	    if (set & TIOCM_DTR){
-		    CY_LOCK(info, flags);
-		    cy_writel(&ch_ctrl[channel].rs_control,
-                       cy_readl(&ch_ctrl[channel].rs_control) | C_RS_DTR);
+		firm_id = cy_card[card].base_addr + ID_ADDRESS;
+		if (ISZLOADED(cy_card[card])) {
+			zfw_ctrl = cy_card[card].base_addr +
+				(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+			board_ctrl = &zfw_ctrl->board_ctrl;
+			ch_ctrl = zfw_ctrl->ch_ctrl;
+
+			if (set & TIOCM_RTS) {
+				CY_LOCK(info, flags);
+				cy_writel(&ch_ctrl[channel].rs_control,
+					  cy_readl(&ch_ctrl[channel].
+						   rs_control) | C_RS_RTS);
+				CY_UNLOCK(info, flags);
+			}
+			if (clear & TIOCM_RTS) {
+				CY_LOCK(info, flags);
+				cy_writel(&ch_ctrl[channel].rs_control,
+					  cy_readl(&ch_ctrl[channel].
+						   rs_control) & ~C_RS_RTS);
+				CY_UNLOCK(info, flags);
+			}
+			if (set & TIOCM_DTR) {
+				CY_LOCK(info, flags);
+				cy_writel(&ch_ctrl[channel].rs_control,
+					  cy_readl(&ch_ctrl[channel].
+						   rs_control) | C_RS_DTR);
@@ -3678 +3787 @@
-		    printk("cyc:set_modem_info raising Z DTR\n");
+				printk("cyc:set_modem_info raising Z DTR\n");
@@ -3680,6 +3789,7 @@
-		    CY_UNLOCK(info, flags);
-	    }
-	    if (clear & TIOCM_DTR) {
-		    CY_LOCK(info, flags);
-		    cy_writel(&ch_ctrl[channel].rs_control,
-                       cy_readl(&ch_ctrl[channel].rs_control) & ~C_RS_DTR);
+				CY_UNLOCK(info, flags);
+			}
+			if (clear & TIOCM_DTR) {
+				CY_LOCK(info, flags);
+				cy_writel(&ch_ctrl[channel].rs_control,
+					  cy_readl(&ch_ctrl[channel].
+						   rs_control) & ~C_RS_DTR);
@@ -3687 +3797 @@
-		    printk("cyc:set_modem_info clearing Z DTR\n");
+				printk("cyc:set_modem_info clearing Z DTR\n");
@@ -3689,11 +3799,13 @@
-		    CY_UNLOCK(info, flags);
-	    }
-	}else{
-	    return -ENODEV;
-	}
-	CY_LOCK(info, flags);
-        retval = cyz_issue_cmd(&cy_card[info->card],
-				    channel, C_CM_IOCTLM,0L);
-	if (retval != 0){
-	    printk("cyc:set_modem_info retval on ttyC%d was %x\n",
-		   info->line, retval);
+				CY_UNLOCK(info, flags);
+			}
+		} else {
+			return -ENODEV;
+		}
+		CY_LOCK(info, flags);
+		retval = cyz_issue_cmd(&cy_card[info->card],
+					channel, C_CM_IOCTLM, 0L);
+		if (retval != 0) {
+			printk("cyc:set_modem_info retval on ttyC%d was %x\n",
+				info->line, retval);
+		}
+		CY_UNLOCK(info, flags);
@@ -3701,4 +3813,2 @@
-	CY_UNLOCK(info, flags);
-    }
-    return 0;
-} /* cy_tiocmset */
+	return 0;
+}				/* cy_tiocmset */
@@ -3709,2 +3819 @@
-static void
-cy_break(struct tty_struct *tty, int break_state)
+static void cy_break(struct tty_struct *tty, int break_state)
@@ -3712,2 +3821,2 @@
-    struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
-    unsigned long flags;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	unsigned long flags;
@@ -3715,2 +3824,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_break"))
-	return;
+	if (serial_paranoia_check(info, tty->name, "cy_break"))
+		return;
@@ -3718,12 +3827,23 @@
-    CY_LOCK(info, flags);
-    if (!IS_CYC_Z(cy_card[info->card])) {
-        /* Let the transmit ISR take care of this (since it
-	   requires stuffing characters into the output stream).
-        */
-	if (break_state == -1) {
-	    if (!info->breakon) {
-		info->breakon = 1;
-		if (!info->xmit_cnt) {
-		    CY_UNLOCK(info, flags);
-		    start_xmit(info);
-		    CY_LOCK(info, flags);
+	CY_LOCK(info, flags);
+	if (!IS_CYC_Z(cy_card[info->card])) {
+		/* Let the transmit ISR take care of this (since it
+		   requires stuffing characters into the output stream).
+		 */
+		if (break_state == -1) {
+			if (!info->breakon) {
+				info->breakon = 1;
+				if (!info->xmit_cnt) {
+					CY_UNLOCK(info, flags);
+					start_xmit(info);
+					CY_LOCK(info, flags);
+				}
+			}
+		} else {
+			if (!info->breakoff) {
+				info->breakoff = 1;
+				if (!info->xmit_cnt) {
+					CY_UNLOCK(info, flags);
+					start_xmit(info);
+					CY_LOCK(info, flags);
+				}
+			}
@@ -3731 +3850,0 @@
-	    }
@@ -3733,6 +3852,18 @@
-	    if (!info->breakoff) {
-		info->breakoff = 1;
-		if (!info->xmit_cnt) {
-		    CY_UNLOCK(info, flags);
-		    start_xmit(info);
-		    CY_LOCK(info, flags);
+		int retval;
+
+		if (break_state == -1) {
+			retval = cyz_issue_cmd(&cy_card[info->card],
+				info->line - cy_card[info->card].first_line,
+				C_CM_SET_BREAK, 0L);
+			if (retval != 0) {
+				printk("cyc:cy_break (set) retval on ttyC%d "
+					"was %x\n", info->line, retval);
+			}
+		} else {
+			retval = cyz_issue_cmd(&cy_card[info->card],
+				info->line - cy_card[info->card].first_line,
+				C_CM_CLR_BREAK, 0L);
+			if (retval != 0) {
+				printk("cyc:cy_break (clr) retval on ttyC%d "
+					"was %x\n", info->line, retval);
+			}
@@ -3740 +3870,0 @@
-	    }
@@ -3742,23 +3872,2 @@
-    } else {
-	int retval;
-
-	if (break_state == -1) {
-	    retval = cyz_issue_cmd(&cy_card[info->card],
-		(info->line) - (cy_card[info->card].first_line),
-		C_CM_SET_BREAK, 0L);
-	    if (retval != 0) {
-		printk("cyc:cy_break (set) retval on ttyC%d was %x\n",
-		       info->line, retval);
-	    }
-	} else {
-	    retval = cyz_issue_cmd(&cy_card[info->card],
-		(info->line) - (cy_card[info->card].first_line),
-		C_CM_CLR_BREAK, 0L);
-	    if (retval != 0) {
-		printk("cyc:cy_break (clr) retval on ttyC%d was %x\n",
-		       info->line, retval);
-	    }
-	}
-    }
-    CY_UNLOCK(info, flags);
-} /* cy_break */
+	CY_UNLOCK(info, flags);
+}				/* cy_break */
@@ -3767 +3876 @@
-get_mon_info(struct cyclades_port * info, struct cyclades_monitor __user * mon)
+get_mon_info(struct cyclades_port *info, struct cyclades_monitor __user * mon)
@@ -3770,8 +3879,26 @@
-    if(copy_to_user(mon, &info->mon, sizeof(struct cyclades_monitor)))
-    	return -EFAULT;
-    info->mon.int_count  = 0;
-    info->mon.char_count = 0;
-    info->mon.char_max   = 0;
-    info->mon.char_last  = 0;
-    return 0;
-}/* get_mon_info */
+	if (copy_to_user(mon, &info->mon, sizeof(struct cyclades_monitor)))
+		return -EFAULT;
+	info->mon.int_count = 0;
+	info->mon.char_count = 0;
+	info->mon.char_max = 0;
+	info->mon.char_last = 0;
+	return 0;
+}				/* get_mon_info */
+
+static int set_threshold(struct cyclades_port *info, unsigned long value)
+{
+	void __iomem *base_addr;
+	int card, channel, chip, index;
+	unsigned long flags;
+
+	card = info->card;
+	channel = info->line - cy_card[card].first_line;
+	if (!IS_CYC_Z(cy_card[card])) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		index = cy_card[card].bus_index;
+		base_addr =
+		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
+
+		info->cor3 &= ~CyREC_FIFO;
+		info->cor3 |= value & CyREC_FIFO;
@@ -3778,0 +3906,9 @@
+		CY_LOCK(info, flags);
+		cy_writeb(base_addr + (CyCOR3 << index), info->cor3);
+		cyy_issue_cmd(base_addr, CyCOR_CHANGE | CyCOR3ch, index);
+		CY_UNLOCK(info, flags);
+	} else {
+		/* Nothing to do! */
+	}
+	return 0;
+}				/* set_threshold */
@@ -3781 +3917 @@
-set_threshold(struct cyclades_port * info, unsigned long value)
+get_threshold(struct cyclades_port *info, unsigned long __user * value)
@@ -3783,11 +3919,3 @@
-  void __iomem *base_addr;
-  int card,channel,chip,index;
-  unsigned long flags;
-   
-    card = info->card;
-    channel = info->line - cy_card[card].first_line;
-    if (!IS_CYC_Z(cy_card[card])) {
-	chip = channel>>2;
-	channel &= 0x03;
-	index = cy_card[card].bus_index;
-	base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
+	void __iomem *base_addr;
+	int card, channel, chip, index;
+	unsigned long tmp;
@@ -3795,12 +3923,8 @@
-	info->cor3 &= ~CyREC_FIFO;
-	info->cor3 |= value & CyREC_FIFO;
-
-	CY_LOCK(info, flags);
-	    cy_writeb(base_addr+(CyCOR3<<index), info->cor3);
-	    cyy_issue_cmd(base_addr,CyCOR_CHANGE|CyCOR3ch,index);
-	CY_UNLOCK(info, flags);
-    } else {
-	// Nothing to do!
-    }
-    return 0;
-}/* set_threshold */
+	card = info->card;
+	channel = info->line - cy_card[card].first_line;
+	if (!IS_CYC_Z(cy_card[card])) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		index = cy_card[card].bus_index;
+		base_addr =
+		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
@@ -3807,0 +3932,7 @@
+		tmp = cy_readb(base_addr + (CyCOR3 << index)) & CyREC_FIFO;
+		return put_user(tmp, value);
+	} else {
+		/* Nothing to do! */
+		return 0;
+	}
+}				/* get_threshold */
@@ -3810 +3941 @@
-get_threshold(struct cyclades_port * info, unsigned long __user *value)
+set_default_threshold(struct cyclades_port *info, unsigned long value)
@@ -3812,16 +3943 @@
-  void __iomem *base_addr;
-  int card,channel,chip,index;
-  unsigned long tmp;
-   
-    card = info->card;
-    channel = info->line - cy_card[card].first_line;
-    if (!IS_CYC_Z(cy_card[card])) {
-	chip = channel>>2;
-	channel &= 0x03;
-	index = cy_card[card].bus_index;
-	base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
-
-	tmp = cy_readb(base_addr+(CyCOR3<<index)) & CyREC_FIFO;
-	return put_user(tmp,value);
-    } else {
-	// Nothing to do!
+	info->default_threshold = value & 0x0f;
@@ -3829,3 +3945 @@
-    }
-}/* get_threshold */
-
+}				/* set_default_threshold */
@@ -3834 +3948 @@
-set_default_threshold(struct cyclades_port * info, unsigned long value)
+get_default_threshold(struct cyclades_port *info, unsigned long __user * value)
@@ -3836,3 +3950,2 @@
-    info->default_threshold = value & 0x0f;
-    return 0;
-}/* set_default_threshold */
+	return put_user(info->default_threshold, value);
+}				/* get_default_threshold */
@@ -3840,3 +3953 @@
-
-static int
-get_default_threshold(struct cyclades_port * info, unsigned long __user *value)
+static int set_timeout(struct cyclades_port *info, unsigned long value)
@@ -3844,2 +3955,3 @@
-    return put_user(info->default_threshold,value);
-}/* get_default_threshold */
+	void __iomem *base_addr;
+	int card, channel, chip, index;
+	unsigned long flags;
@@ -3846,0 +3959,8 @@
+	card = info->card;
+	channel = info->line - cy_card[card].first_line;
+	if (!IS_CYC_Z(cy_card[card])) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		index = cy_card[card].bus_index;
+		base_addr =
+		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
@@ -3848,2 +3968,10 @@
-static int
-set_timeout(struct cyclades_port * info, unsigned long value)
+		CY_LOCK(info, flags);
+		cy_writeb(base_addr + (CyRTPR << index), value & 0xff);
+		CY_UNLOCK(info, flags);
+	} else {
+		/* Nothing to do! */
+	}
+	return 0;
+}				/* set_timeout */
+
+static int get_timeout(struct cyclades_port *info, unsigned long __user * value)
@@ -3851,11 +3979,3 @@
-  void __iomem *base_addr;
-  int card,channel,chip,index;
-  unsigned long flags;
-   
-    card = info->card;
-    channel = info->line - cy_card[card].first_line;
-    if (!IS_CYC_Z(cy_card[card])) {
-	chip = channel>>2;
-	channel &= 0x03;
-	index = cy_card[card].bus_index;
-	base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
+	void __iomem *base_addr;
+	int card, channel, chip, index;
+	unsigned long tmp;
@@ -3863,8 +3983,8 @@
-	CY_LOCK(info, flags);
-	    cy_writeb(base_addr+(CyRTPR<<index), value & 0xff);
-	CY_UNLOCK(info, flags);
-    } else {
-	// Nothing to do!
-    }
-    return 0;
-}/* set_timeout */
+	card = info->card;
+	channel = info->line - cy_card[card].first_line;
+	if (!IS_CYC_Z(cy_card[card])) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		index = cy_card[card].bus_index;
+		base_addr =
+		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
@@ -3871,0 +3992,7 @@
+		tmp = cy_readb(base_addr + (CyRTPR << index));
+		return put_user(tmp, value);
+	} else {
+		/* Nothing to do! */
+		return 0;
+	}
+}				/* get_timeout */
@@ -3873,2 +4000 @@
-static int
-get_timeout(struct cyclades_port * info, unsigned long __user *value)
+static int set_default_timeout(struct cyclades_port *info, unsigned long value)
@@ -3876,16 +4002 @@
-  void __iomem *base_addr;
-  int card,channel,chip,index;
-  unsigned long tmp;
-   
-    card = info->card;
-    channel = info->line - cy_card[card].first_line;
-    if (!IS_CYC_Z(cy_card[card])) {
-	chip = channel>>2;
-	channel &= 0x03;
-	index = cy_card[card].bus_index;
-	base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
-
-	tmp = cy_readb(base_addr+(CyRTPR<<index));
-	return put_user(tmp,value);
-    } else {
-	// Nothing to do!
+	info->default_timeout = value & 0xff;
@@ -3893,11 +4004 @@
-    }
-}/* get_timeout */
-
-
-static int
-set_default_timeout(struct cyclades_port * info, unsigned long value)
-{
-    info->default_timeout = value & 0xff;
-    return 0;
-}/* set_default_timeout */
-
+}				/* set_default_timeout */
@@ -3906 +4007 @@
-get_default_timeout(struct cyclades_port * info, unsigned long __user *value)
+get_default_timeout(struct cyclades_port *info, unsigned long __user * value)
@@ -3908,2 +4009,2 @@
-    return put_user(info->default_timeout,value);
-}/* get_default_timeout */
+	return put_user(info->default_timeout, value);
+}				/* get_default_timeout */
@@ -3917,2 +4018,2 @@
-cy_ioctl(struct tty_struct *tty, struct file * file,
-            unsigned int cmd, unsigned long arg)
+cy_ioctl(struct tty_struct *tty, struct file *file,
+	 unsigned int cmd, unsigned long arg)
@@ -3920,6 +4021,6 @@
-  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
-  struct cyclades_icount cprev, cnow;		/* kernel counter temps */
-  struct serial_icounter_struct __user *p_cuser;	/* user space */
-  int ret_val = 0;
-  unsigned long flags;
-  void __user *argp = (void __user *)arg;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_icount cprev, cnow;	/* kernel counter temps */
+	struct serial_icounter_struct __user *p_cuser;	/* user space */
+	int ret_val = 0;
+	unsigned long flags;
+	void __user *argp = (void __user *)arg;
@@ -3927,2 +4028,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_ioctl"))
-	return -ENODEV;
+	if (serial_paranoia_check(info, tty->name, "cy_ioctl"))
+		return -ENODEV;
@@ -3931,2 +4032 @@
-    printk("cyc:cy_ioctl ttyC%d, cmd = %x arg = %lx\n",
-        info->line, cmd, arg); /* */
+	printk("cyc:cy_ioctl ttyC%d, cmd = %x arg = %lx\n", info->line, cmd, arg);	/* */
@@ -3935,28 +4035,28 @@
-    switch (cmd) {
-        case CYGETMON:
-            ret_val = get_mon_info(info, argp);
-            break;
-        case CYGETTHRESH:
-            ret_val = get_threshold(info, argp);
-            break;
-        case CYSETTHRESH:
-            ret_val = set_threshold(info, arg);
-            break;
-        case CYGETDEFTHRESH:
-            ret_val = get_default_threshold(info, argp);
-            break;
-        case CYSETDEFTHRESH:
-            ret_val = set_default_threshold(info, arg);
-            break;
-        case CYGETTIMEOUT:
-            ret_val = get_timeout(info, argp);
-            break;
-        case CYSETTIMEOUT:
-            ret_val = set_timeout(info, arg);
-            break;
-        case CYGETDEFTIMEOUT:
-            ret_val = get_default_timeout(info, argp);
-            break;
-        case CYSETDEFTIMEOUT:
-            ret_val = set_default_timeout(info, arg);
-            break;
+	switch (cmd) {
+	case CYGETMON:
+		ret_val = get_mon_info(info, argp);
+		break;
+	case CYGETTHRESH:
+		ret_val = get_threshold(info, argp);
+		break;
+	case CYSETTHRESH:
+		ret_val = set_threshold(info, arg);
+		break;
+	case CYGETDEFTHRESH:
+		ret_val = get_default_threshold(info, argp);
+		break;
+	case CYSETDEFTHRESH:
+		ret_val = set_default_threshold(info, arg);
+		break;
+	case CYGETTIMEOUT:
+		ret_val = get_timeout(info, argp);
+		break;
+	case CYSETTIMEOUT:
+		ret_val = set_timeout(info, arg);
+		break;
+	case CYGETDEFTIMEOUT:
+		ret_val = get_default_timeout(info, argp);
+		break;
+	case CYSETDEFTIMEOUT:
+		ret_val = set_default_timeout(info, arg);
+		break;
@@ -3964,3 +4064,3 @@
-    	    info->rflow = (int)arg;
-	    ret_val = 0;
-	    break;
+		info->rflow = (int)arg;
+		ret_val = 0;
+		break;
@@ -3968,2 +4068,2 @@
-	    ret_val = info->rflow;
-	    break;
+		ret_val = info->rflow;
+		break;
@@ -3971,3 +4071,3 @@
-    	    info->rtsdtr_inv = (int)arg;
-	    ret_val = 0;
-	    break;
+		info->rtsdtr_inv = (int)arg;
+		ret_val = 0;
+		break;
@@ -3975,2 +4075,2 @@
-	    ret_val = info->rtsdtr_inv;
-	    break;
+		ret_val = info->rtsdtr_inv;
+		break;
@@ -3978,3 +4078,6 @@
-            if (copy_to_user(argp, &cy_card[info->card], 
-			sizeof (struct cyclades_card))) {
-		ret_val = -EFAULT;
+		if (copy_to_user(argp, &cy_card[info->card],
+				 sizeof(struct cyclades_card))) {
+			ret_val = -EFAULT;
+			break;
+		}
+		ret_val = 0;
@@ -3982,3 +4084,0 @@
-	    }
-	    ret_val = 0;
-            break;
@@ -3986,2 +4086,2 @@
-	    ret_val = info->chip_rev;
-	    break;
+		ret_val = info->chip_rev;
+		break;
@@ -3990,3 +4090,3 @@
-            cyz_polling_cycle = (arg * HZ) / 1000;
-	    ret_val = 0;
-	    break;
+		cyz_polling_cycle = (arg * HZ) / 1000;
+		ret_val = 0;
+		break;
@@ -3994,3 +4094,3 @@
-            ret_val = (cyz_polling_cycle * 1000) / HZ;
-	    break;
-#endif /* CONFIG_CYZ_INTR */
+		ret_val = (cyz_polling_cycle * 1000) / HZ;
+		break;
+#endif				/* CONFIG_CYZ_INTR */
@@ -3998,3 +4098,3 @@
-    	    info->closing_wait = (unsigned short)arg * HZ/100;
-	    ret_val = 0;
-	    break;
+		info->closing_wait = (unsigned short)arg *HZ / 100;
+		ret_val = 0;
+		break;
@@ -4002,17 +4102,17 @@
-	    ret_val = info->closing_wait / (HZ/100);
-	    break;
-        case TIOCGSERIAL:
-            ret_val = get_serial_info(info, argp);
-            break;
-        case TIOCSSERIAL:
-            ret_val = set_serial_info(info, argp);
-            break;
-	case TIOCSERGETLSR: /* Get line status register */
-	    ret_val = get_lsr_info(info, argp);
-	    break;
-	/*
-	 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change 
-	 * - mask passed in arg for lines of interest
-	 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
-	 * Caller should use TIOCGICOUNT to see which one it was
-	 */
+		ret_val = info->closing_wait / (HZ / 100);
+		break;
+	case TIOCGSERIAL:
+		ret_val = get_serial_info(info, argp);
+		break;
+	case TIOCSSERIAL:
+		ret_val = set_serial_info(info, argp);
+		break;
+	case TIOCSERGETLSR:	/* Get line status register */
+		ret_val = get_lsr_info(info, argp);
+		break;
+		/*
+		 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change
+		 * - mask passed in arg for lines of interest
+		 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
+		 * Caller should use TIOCGICOUNT to see which one it was
+		 */
@@ -4020,11 +4119,0 @@
-	    CY_LOCK(info, flags);
-	    /* note the counters on entry */
-	    cprev = info->icount;
-	    CY_UNLOCK(info, flags);
-	    while (1) {
-		interruptible_sleep_on(&info->delta_msr_wait);
-		/* see if a signal did it */
-		if (signal_pending(current)) {
-		    return -ERESTARTSYS;
-		}
-
@@ -4032 +4121,2 @@
-		cnow = info->icount; /* atomic copy */
+		/* note the counters on entry */
+		cprev = info->icount;
@@ -4033,0 +4124,6 @@
+		while (1) {
+			interruptible_sleep_on(&info->delta_msr_wait);
+			/* see if a signal did it */
+			if (signal_pending(current)) {
+				return -ERESTARTSYS;
+			}
@@ -4035,13 +4131,3 @@
-		if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr && 
-		    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {
-		    return -EIO; /* no change => error */
-		}
-		if ( ((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) || 
-		     ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) || 
-		     ((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) || 
-		     ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts)) ) {
-		    return 0;
-		}
-		cprev = cnow;
-	    }
-	    /* NOTREACHED */
+			CY_LOCK(info, flags);
+			cnow = info->icount;	/* atomic copy */
+			CY_UNLOCK(info, flags);
@@ -4049,6 +4135,20 @@
-	/*
-	 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
-	 * Return: write counters to the user passed counter struct
-	 * NB: both 1->0 and 0->1 transitions are counted except for
-	 *     RI where only 0->1 is counted.
-	 */
+			if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&
+			    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {
+				return -EIO;	/* no change => error */
+			}
+			if (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
+			    ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
+			    ((arg & TIOCM_CD) && (cnow.dcd != cprev.dcd)) ||
+			    ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {
+				return 0;
+			}
+			cprev = cnow;
+		}
+		/* NOTREACHED */
+
+		/*
+		 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
+		 * Return: write counters to the user passed counter struct
+		 * NB: both 1->0 and 0->1 transitions are counted except for
+		 *     RI where only 0->1 is counted.
+		 */
@@ -4056,31 +4156,42 @@
-	    CY_LOCK(info, flags);
-	    cnow = info->icount;
-	    CY_UNLOCK(info, flags);
-	    p_cuser = argp;
-	    ret_val = put_user(cnow.cts, &p_cuser->cts);
-	    if (ret_val) return ret_val;
-	    ret_val = put_user(cnow.dsr, &p_cuser->dsr);
-	    if (ret_val) return ret_val;
-	    ret_val = put_user(cnow.rng, &p_cuser->rng);
-	    if (ret_val) return ret_val;
-	    ret_val = put_user(cnow.dcd, &p_cuser->dcd);
-	    if (ret_val) return ret_val;
-	    ret_val = put_user(cnow.rx, &p_cuser->rx);
-	    if (ret_val) return ret_val;
-	    ret_val = put_user(cnow.tx, &p_cuser->tx);
-	    if (ret_val) return ret_val;
-	    ret_val = put_user(cnow.frame, &p_cuser->frame);
-	    if (ret_val) return ret_val;
-	    ret_val = put_user(cnow.overrun, &p_cuser->overrun);
-	    if (ret_val) return ret_val;
-	    ret_val = put_user(cnow.parity, &p_cuser->parity);
-	    if (ret_val) return ret_val;
-	    ret_val = put_user(cnow.brk, &p_cuser->brk);
-	    if (ret_val) return ret_val;
-	    ret_val = put_user(cnow.buf_overrun, &p_cuser->buf_overrun);
-	    if (ret_val) return ret_val;
-	    ret_val = 0;
-	    break;
-        default:
-            ret_val = -ENOIOCTLCMD;
-    }
+		CY_LOCK(info, flags);
+		cnow = info->icount;
+		CY_UNLOCK(info, flags);
+		p_cuser = argp;
+		ret_val = put_user(cnow.cts, &p_cuser->cts);
+		if (ret_val)
+			return ret_val;
+		ret_val = put_user(cnow.dsr, &p_cuser->dsr);
+		if (ret_val)
+			return ret_val;
+		ret_val = put_user(cnow.rng, &p_cuser->rng);
+		if (ret_val)
+			return ret_val;
+		ret_val = put_user(cnow.dcd, &p_cuser->dcd);
+		if (ret_val)
+			return ret_val;
+		ret_val = put_user(cnow.rx, &p_cuser->rx);
+		if (ret_val)
+			return ret_val;
+		ret_val = put_user(cnow.tx, &p_cuser->tx);
+		if (ret_val)
+			return ret_val;
+		ret_val = put_user(cnow.frame, &p_cuser->frame);
+		if (ret_val)
+			return ret_val;
+		ret_val = put_user(cnow.overrun, &p_cuser->overrun);
+		if (ret_val)
+			return ret_val;
+		ret_val = put_user(cnow.parity, &p_cuser->parity);
+		if (ret_val)
+			return ret_val;
+		ret_val = put_user(cnow.brk, &p_cuser->brk);
+		if (ret_val)
+			return ret_val;
+		ret_val = put_user(cnow.buf_overrun, &p_cuser->buf_overrun);
+		if (ret_val)
+			return ret_val;
+		ret_val = 0;
+		break;
+	default:
+		ret_val = -ENOIOCTLCMD;
+	}
@@ -4089 +4200 @@
-    printk(" cyc:cy_ioctl done\n");
+	printk(" cyc:cy_ioctl done\n");
@@ -4092,3 +4203,2 @@
-    return ret_val;
-} /* cy_ioctl */
-
+	return ret_val;
+}				/* cy_ioctl */
@@ -4102,2 +4212 @@
-static void
-cy_set_termios(struct tty_struct *tty, struct termios * old_termios)
+static void cy_set_termios(struct tty_struct *tty, struct ktermios *old_termios)
@@ -4105 +4214 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
@@ -4108 +4217 @@
-    printk("cyc:cy_set_termios ttyC%d\n", info->line);
+	printk("cyc:cy_set_termios ttyC%d\n", info->line);
@@ -4111,11 +4220,11 @@
-    if ((tty->termios->c_cflag == old_termios->c_cflag) &&
-	((tty->termios->c_iflag & (IXON|IXANY)) == 
-	 (old_termios->c_iflag & (IXON|IXANY))))
-        return;
-    set_line_char(info);
-
-    if ((old_termios->c_cflag & CRTSCTS) &&
-        !(tty->termios->c_cflag & CRTSCTS)) {
-            tty->hw_stopped = 0;
-            cy_start(tty);
-    }
+	if (tty->termios->c_cflag == old_termios->c_cflag &&
+			(tty->termios->c_iflag & (IXON | IXANY)) ==
+			(old_termios->c_iflag & (IXON | IXANY)))
+		return;
+	set_line_char(info);
+
+	if ((old_termios->c_cflag & CRTSCTS) &&
+			!(tty->termios->c_cflag & CRTSCTS)) {
+		tty->hw_stopped = 0;
+		cy_start(tty);
+	}
@@ -4123,9 +4232,9 @@
-    /*
-     * No need to wake up processes in open wait, since they
-     * sample the CLOCAL flag once, and don't recheck it.
-     * XXX  It's not clear whether the current behavior is correct
-     * or not.  Hence, this may change.....
-     */
-    if (!(old_termios->c_cflag & CLOCAL) &&
-        (tty->termios->c_cflag & CLOCAL))
-            wake_up_interruptible(&info->open_wait);
+	/*
+	 * No need to wake up processes in open wait, since they
+	 * sample the CLOCAL flag once, and don't recheck it.
+	 * XXX  It's not clear whether the current behavior is correct
+	 * or not.  Hence, this may change.....
+	 */
+	if (!(old_termios->c_cflag & CLOCAL) &&
+	    (tty->termios->c_cflag & CLOCAL))
+		wake_up_interruptible(&info->open_wait);
@@ -4133,3 +4242 @@
-
-    return;
-} /* cy_set_termios */
+}				/* cy_set_termios */
@@ -4140,2 +4247 @@
-static void
-cy_send_xchar (struct tty_struct *tty, char ch)
+static void cy_send_xchar(struct tty_struct *tty, char ch)
@@ -4143 +4249 @@
-	struct cyclades_port *info = (struct cyclades_port *) tty->driver_data;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
@@ -4146 +4252 @@
-	if (serial_paranoia_check (info, tty->name, "cy_send_xchar"))
+	if (serial_paranoia_check(info, tty->name, "cy_send_xchar"))
@@ -4149 +4255 @@
-  	info->x_char = ch;
+	info->x_char = ch;
@@ -4152 +4258 @@
-		cy_start (tty);
+		cy_start(tty);
@@ -4157,5 +4263,7 @@
-	if (IS_CYC_Z (cy_card[card])) {
-		if (ch == STOP_CHAR (tty))
-	  		cyz_issue_cmd (&cy_card[card], channel, C_CM_SENDXOFF, 0L);
-		else if (ch == START_CHAR (tty))
-			cyz_issue_cmd (&cy_card[card], channel, C_CM_SENDXON, 0L);
+	if (IS_CYC_Z(cy_card[card])) {
+		if (ch == STOP_CHAR(tty))
+			cyz_issue_cmd(&cy_card[card], channel, C_CM_SENDXOFF,
+					0L);
+		else if (ch == START_CHAR(tty))
+			cyz_issue_cmd(&cy_card[card], channel, C_CM_SENDXON,
+					0L);
@@ -4169,2 +4277 @@
-static void
-cy_throttle(struct tty_struct * tty)
+static void cy_throttle(struct tty_struct *tty)
@@ -4172,4 +4279,4 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  unsigned long flags;
-  void __iomem *base_addr;
-  int card,chip,channel,index;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	unsigned long flags;
+	void __iomem *base_addr;
+	int card, chip, channel, index;
@@ -4178 +4285 @@
-  char buf[64];
+	char buf[64];
@@ -4180,38 +4287,9 @@
-    printk("cyc:throttle %s: %d....ttyC%d\n", 
-	   tty_name(tty, buf),
-           tty->ldisc.chars_in_buffer(tty), info->line);
-#endif
-
-    if (serial_paranoia_check(info, tty->name, "cy_throttle")){
-            return;
-    }
-
-    card = info->card;
-
-    if (I_IXOFF(tty)) {
-        if (!IS_CYC_Z (cy_card[card]))
-            cy_send_xchar (tty, STOP_CHAR (tty));
-        else
-            info->throttle = 1;
-    }
-
-    if (tty->termios->c_cflag & CRTSCTS) {
-        channel = info->line - cy_card[card].first_line;
-        if (!IS_CYC_Z(cy_card[card])) {
-            chip = channel>>2;
-            channel &= 0x03;
-            index = cy_card[card].bus_index;
-            base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
-
-            CY_LOCK(info, flags);
-            cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
-            if (info->rtsdtr_inv) {
-                cy_writeb(base_addr+(CyMSVR2<<index), ~CyDTR);
-             } else {
-                cy_writeb(base_addr+(CyMSVR1<<index), ~CyRTS);
-	     }
-	    CY_UNLOCK(info, flags);
-	} else {
-	    info->throttle = 1;
-        }
-    }
+	printk("cyc:throttle %s: %d....ttyC%d\n", tty_name(tty, buf),
+			tty->ldisc.chars_in_buffer(tty), info->line);
+#endif
+
+	if (serial_paranoia_check(info, tty->name, "cy_throttle")) {
+		return;
+	}
+
+	card = info->card;
@@ -4219,2 +4297,6 @@
-    return;
-} /* cy_throttle */
+	if (I_IXOFF(tty)) {
+		if (!IS_CYC_Z(cy_card[card]))
+			cy_send_xchar(tty, STOP_CHAR(tty));
+		else
+			info->throttle = 1;
+	}
@@ -4221,0 +4304,25 @@
+	if (tty->termios->c_cflag & CRTSCTS) {
+		channel = info->line - cy_card[card].first_line;
+		if (!IS_CYC_Z(cy_card[card])) {
+			chip = channel >> 2;
+			channel &= 0x03;
+			index = cy_card[card].bus_index;
+			base_addr = cy_card[card].base_addr +
+				(cy_chip_offset[chip] << index);
+
+			CY_LOCK(info, flags);
+			cy_writeb(base_addr + (CyCAR << index),
+				  (u_char) channel);
+			if (info->rtsdtr_inv) {
+				cy_writeb(base_addr + (CyMSVR2 << index),
+					  ~CyDTR);
+			} else {
+				cy_writeb(base_addr + (CyMSVR1 << index),
+					  ~CyRTS);
+			}
+			CY_UNLOCK(info, flags);
+		} else {
+			info->throttle = 1;
+		}
+	}
+}				/* cy_throttle */
@@ -4228,2 +4335 @@
-static void
-cy_unthrottle(struct tty_struct * tty)
+static void cy_unthrottle(struct tty_struct *tty)
@@ -4231,4 +4337,4 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  unsigned long flags;
-  void __iomem *base_addr;
-  int card,chip,channel,index;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	unsigned long flags;
+	void __iomem *base_addr;
+	int card, chip, channel, index;
@@ -4237,6 +4343 @@
-  char buf[64];
-        
-    printk("cyc:unthrottle %s: %d....ttyC%d\n", 
-	   tty_name(tty, buf),
-           tty->ldisc.chars_in_buffer(tty), info->line);
-#endif
+	char buf[64];
@@ -4244,10 +4345,3 @@
-    if (serial_paranoia_check(info, tty->name, "cy_unthrottle")){
-            return;
-    }
-
-    if (I_IXOFF(tty)) {
-	if (info->x_char)
-	    info->x_char = 0;
-	else
-	    cy_send_xchar (tty, START_CHAR (tty));
-    }
+	printk("cyc:unthrottle %s: %d....ttyC%d\n", tty_name(tty, buf),
+		tty->ldisc.chars_in_buffer(tty), info->line);
+#endif
@@ -4255,19 +4349,2 @@
-    if (tty->termios->c_cflag & CRTSCTS) {
-        card = info->card;
-        channel = info->line - cy_card[card].first_line;
-        if (!IS_CYC_Z(cy_card[card])) {
-	    chip = channel>>2;
-	    channel &= 0x03;
-	    index = cy_card[card].bus_index;
-	    base_addr = cy_card[card].base_addr + (cy_chip_offset[chip]<<index);
-
-	    CY_LOCK(info, flags);
-	    cy_writeb(base_addr+(CyCAR<<index), (u_char)channel);
-	    if (info->rtsdtr_inv) {
-		    cy_writeb(base_addr+(CyMSVR2<<index), CyDTR);
-	    } else {
-		    cy_writeb(base_addr+(CyMSVR1<<index), CyRTS);
-	    }
-	    CY_UNLOCK(info, flags);
-        } else {
-	    info->throttle = 0;
+	if (serial_paranoia_check(info, tty->name, "cy_unthrottle")) {
+		return;
@@ -4275 +4351,0 @@
-    }
@@ -4277,2 +4353,6 @@
-    return;
-} /* cy_unthrottle */
+	if (I_IXOFF(tty)) {
+		if (info->x_char)
+			info->x_char = 0;
+		else
+			cy_send_xchar(tty, START_CHAR(tty));
+	}
@@ -4279,0 +4360,26 @@
+	if (tty->termios->c_cflag & CRTSCTS) {
+		card = info->card;
+		channel = info->line - cy_card[card].first_line;
+		if (!IS_CYC_Z(cy_card[card])) {
+			chip = channel >> 2;
+			channel &= 0x03;
+			index = cy_card[card].bus_index;
+			base_addr = cy_card[card].base_addr +
+				(cy_chip_offset[chip] << index);
+
+			CY_LOCK(info, flags);
+			cy_writeb(base_addr + (CyCAR << index),
+				  (u_char) channel);
+			if (info->rtsdtr_inv) {
+				cy_writeb(base_addr + (CyMSVR2 << index),
+					  CyDTR);
+			} else {
+				cy_writeb(base_addr + (CyMSVR1 << index),
+					  CyRTS);
+			}
+			CY_UNLOCK(info, flags);
+		} else {
+			info->throttle = 0;
+		}
+	}
+}				/* cy_unthrottle */
@@ -4284,2 +4390 @@
-static void
-cy_stop(struct tty_struct *tty)
+static void cy_stop(struct tty_struct *tty)
@@ -4287,5 +4392,5 @@
-  struct cyclades_card *cinfo;
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  void __iomem *base_addr;
-  int chip,channel,index;
-  unsigned long flags;
+	struct cyclades_card *cinfo;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	void __iomem *base_addr;
+	int chip, channel, index;
+	unsigned long flags;
@@ -4294 +4399 @@
-    printk("cyc:cy_stop ttyC%d\n", info->line); /* */
+	printk("cyc:cy_stop ttyC%d\n", info->line);	/* */
@@ -4297,20 +4402,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_stop"))
-        return;
-        
-    cinfo = &cy_card[info->card];
-    channel = info->line - cinfo->first_line;
-    if (!IS_CYC_Z(*cinfo)) {
-        index = cinfo->bus_index;
-        chip = channel>>2;
-        channel &= 0x03;
-        base_addr = cy_card[info->card].base_addr + (cy_chip_offset[chip]<<index);
-
-	CY_LOCK(info, flags);
-            cy_writeb(base_addr+(CyCAR<<index),
-	       (u_char)(channel & 0x0003)); /* index channel */
-            cy_writeb(base_addr+(CySRER<<index), 
-               cy_readb(base_addr+(CySRER<<index)) & ~CyTxRdy);
-	CY_UNLOCK(info, flags);
-    } else {
-	// Nothing to do!
-    }
+	if (serial_paranoia_check(info, tty->name, "cy_stop"))
+		return;
@@ -4318,2 +4405,8 @@
-    return;
-} /* cy_stop */
+	cinfo = &cy_card[info->card];
+	channel = info->line - cinfo->first_line;
+	if (!IS_CYC_Z(*cinfo)) {
+		index = cinfo->bus_index;
+		chip = channel >> 2;
+		channel &= 0x03;
+		base_addr = cy_card[info->card].base_addr +
+			(cy_chip_offset[chip] << index);
@@ -4320,0 +4414,10 @@
+		CY_LOCK(info, flags);
+		cy_writeb(base_addr + (CyCAR << index),
+			(u_char)(channel & 0x0003)); /* index channel */
+		cy_writeb(base_addr + (CySRER << index),
+			  cy_readb(base_addr + (CySRER << index)) & ~CyTxRdy);
+		CY_UNLOCK(info, flags);
+	} else {
+		/* Nothing to do! */
+	}
+}				/* cy_stop */
@@ -4322,2 +4425 @@
-static void
-cy_start(struct tty_struct *tty)
+static void cy_start(struct tty_struct *tty)
@@ -4325,5 +4427,5 @@
-  struct cyclades_card *cinfo;
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  void __iomem *base_addr;
-  int chip,channel,index;
-  unsigned long flags;
+	struct cyclades_card *cinfo;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	void __iomem *base_addr;
+	int chip, channel, index;
+	unsigned long flags;
@@ -4332 +4434 @@
-    printk("cyc:cy_start ttyC%d\n", info->line); /* */
+	printk("cyc:cy_start ttyC%d\n", info->line);	/* */
@@ -4335,20 +4437,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_start"))
-        return;
-        
-    cinfo = &cy_card[info->card];
-    channel = info->line - cinfo->first_line;
-    index = cinfo->bus_index;
-    if (!IS_CYC_Z(*cinfo)) {
-        chip = channel>>2;
-        channel &= 0x03;
-        base_addr = cy_card[info->card].base_addr + (cy_chip_offset[chip]<<index);
-
-	CY_LOCK(info, flags);
-            cy_writeb(base_addr+(CyCAR<<index),
-	       (u_char)(channel & 0x0003)); /* index channel */
-            cy_writeb(base_addr+(CySRER<<index), 
-               cy_readb(base_addr+(CySRER<<index)) | CyTxRdy);
-	CY_UNLOCK(info, flags);
-    } else {
-	// Nothing to do!
-    }
+	if (serial_paranoia_check(info, tty->name, "cy_start"))
+		return;
@@ -4356,2 +4440,8 @@
-    return;
-} /* cy_start */
+	cinfo = &cy_card[info->card];
+	channel = info->line - cinfo->first_line;
+	index = cinfo->bus_index;
+	if (!IS_CYC_Z(*cinfo)) {
+		chip = channel >> 2;
+		channel &= 0x03;
+		base_addr = cy_card[info->card].base_addr +
+			(cy_chip_offset[chip] << index);
@@ -4358,0 +4449,9 @@
+		CY_LOCK(info, flags);
+		cy_writeb(base_addr + (CyCAR << index), (u_char) (channel & 0x0003));	/* index channel */
+		cy_writeb(base_addr + (CySRER << index),
+			  cy_readb(base_addr + (CySRER << index)) | CyTxRdy);
+		CY_UNLOCK(info, flags);
+	} else {
+		/* Nothing to do! */
+	}
+}				/* cy_start */
@@ -4360,2 +4459 @@
-static void
-cy_flush_buffer(struct tty_struct *tty)
+static void cy_flush_buffer(struct tty_struct *tty)
@@ -4363,4 +4461,4 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  int card, channel, retval;
-  unsigned long flags;
-                                
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	int card, channel, retval;
+	unsigned long flags;
+
@@ -4368 +4466 @@
-    printk("cyc:cy_flush_buffer ttyC%d\n", info->line); /* */
+	printk("cyc:cy_flush_buffer ttyC%d\n", info->line);	/* */
@@ -4371,5 +4469,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_flush_buffer"))
-        return;
-
-    card = info->card;
-    channel = (info->line) - (cy_card[card].first_line);
+	if (serial_paranoia_check(info, tty->name, "cy_flush_buffer"))
+		return;
@@ -4377,3 +4472,2 @@
-    CY_LOCK(info, flags);
-    info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
-    CY_UNLOCK(info, flags);
+	card = info->card;
+	channel = (info->line) - (cy_card[card].first_line);
@@ -4381,2 +4474,0 @@
-    if (IS_CYC_Z(cy_card[card])) { /* If it is a Z card, flush the on-board 
-				      buffers as well */
@@ -4384,5 +4476 @@
-	retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_FLUSH_TX, 0L);
-	if (retval != 0) {
-	    printk("cyc: flush_buffer retval on ttyC%d was %x\n",
-		   info->line, retval);
-	}
+	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
@@ -4390,4 +4477,0 @@
-    }
-    tty_wakeup(tty);
-    wake_up_interruptible(&tty->write_wait);
-} /* cy_flush_buffer */
@@ -4394,0 +4479,14 @@
+	if (IS_CYC_Z(cy_card[card])) {	/* If it is a Z card, flush the on-board
+					   buffers as well */
+		CY_LOCK(info, flags);
+		retval =
+		    cyz_issue_cmd(&cy_card[card], channel, C_CM_FLUSH_TX, 0L);
+		if (retval != 0) {
+			printk("cyc: flush_buffer retval on ttyC%d was %x\n",
+				info->line, retval);
+		}
+		CY_UNLOCK(info, flags);
+	}
+	tty_wakeup(tty);
+	wake_up_interruptible(&tty->write_wait);
+}				/* cy_flush_buffer */
@@ -4399,2 +4497 @@
-static void
-cy_hangup(struct tty_struct *tty)
+static void cy_hangup(struct tty_struct *tty)
@@ -4402,2 +4499,2 @@
-  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
-        
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+
@@ -4405 +4502 @@
-    printk("cyc:cy_hangup ttyC%d\n", info->line); /* */
+	printk("cyc:cy_hangup ttyC%d\n", info->line);	/* */
@@ -4408,2 +4505,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_hangup"))
-        return;
+	if (serial_paranoia_check(info, tty->name, "cy_hangup"))
+		return;
@@ -4411,4 +4508,4 @@
-    cy_flush_buffer(tty);
-    shutdown(info);
-    info->event = 0;
-    info->count = 0;
+	cy_flush_buffer(tty);
+	shutdown(info);
+	info->event = 0;
+	info->count = 0;
@@ -4416 +4513 @@
-    printk("cyc:cy_hangup (%d): setting count to 0\n", current->pid);
+	printk("cyc:cy_hangup (%d): setting count to 0\n", current->pid);
@@ -4418,5 +4515,4 @@
-    info->tty = NULL;
-    info->flags &= ~ASYNC_NORMAL_ACTIVE;
-    wake_up_interruptible(&info->open_wait);
-} /* cy_hangup */
-
+	info->tty = NULL;
+	info->flags &= ~ASYNC_NORMAL_ACTIVE;
+	wake_up_interruptible(&info->open_wait);
+}				/* cy_hangup */
@@ -4435 +4531 @@
-cyy_init_card(void __iomem *true_base_addr,int index)
+cyy_init_card(void __iomem * true_base_addr, int index)
@@ -4437,2 +4533,2 @@
-  unsigned int chip_number;
-  void __iomem *base_addr;
+	unsigned int chip_number;
+	void __iomem *base_addr;
@@ -4440,62 +4536,64 @@
-    cy_writeb(true_base_addr+(Cy_HwReset<<index), 0); 
-						/* Cy_HwReset is 0x1400 */
-    cy_writeb(true_base_addr+(Cy_ClrIntr<<index), 0); 
-						/* Cy_ClrIntr is 0x1800 */
-    udelay(500L);
-
-    for(chip_number=0; chip_number<CyMAX_CHIPS_PER_CARD; chip_number++){
-        base_addr = true_base_addr + (cy_chip_offset[chip_number]<<index);
-        mdelay(1);
-        if(cy_readb(base_addr+(CyCCR<<index)) != 0x00){
-            /*************
-            printk(" chip #%d at %#6lx is never idle (CCR != 0)\n",
-               chip_number, (unsigned long)base_addr);
-            *************/
-            return chip_number;
-        }
-
-        cy_writeb(base_addr+(CyGFRCR<<index), 0);
-        udelay(10L);
-
-        /* The Cyclom-16Y does not decode address bit 9 and therefore
-           cannot distinguish between references to chip 0 and a non-
-           existent chip 4.  If the preceding clearing of the supposed
-           chip 4 GFRCR register appears at chip 0, there is no chip 4
-           and this must be a Cyclom-16Y, not a Cyclom-32Ye.
-        */
-        if (chip_number == 4
-        && cy_readb(true_base_addr
-	    + (cy_chip_offset[0]<<index)
-	    + (CyGFRCR<<index)) == 0){
-            return chip_number;
-        }
-
-        cy_writeb(base_addr+(CyCCR<<index), CyCHIP_RESET);
-        mdelay(1);
-
-        if(cy_readb(base_addr+(CyGFRCR<<index)) == 0x00){
-            /*
-            printk(" chip #%d at %#6lx is not responding ",
-               chip_number, (unsigned long)base_addr);
-            printk("(GFRCR stayed 0)\n",
-            */
-            return chip_number;
-        }
-        if((0xf0 & (cy_readb(base_addr+(CyGFRCR<<index)))) != 0x40){
-            /*
-            printk(" chip #%d at %#6lx is not valid (GFRCR == %#2x)\n",
-               chip_number, (unsigned long)base_addr,
-	       base_addr[CyGFRCR<<index]);
-            */
-            return chip_number;
-        }
-        cy_writeb(base_addr+(CyGCR<<index), CyCH0_SERIAL);
-        if (cy_readb(base_addr+(CyGFRCR<<index)) >= CD1400_REV_J){
-	    /* It is a CD1400 rev. J or later */
-	    /* Impossible to reach 5ms with this chip. 
-	       Changed to 2ms instead (f = 500 Hz). */
-	    cy_writeb(base_addr+(CyPPR<<index), CyCLOCK_60_2MS);
-	} else {
-	    /* f = 200 Hz */
-	    cy_writeb(base_addr+(CyPPR<<index), CyCLOCK_25_5MS);
-	}
+	cy_writeb(true_base_addr + (Cy_HwReset << index), 0);
+	/* Cy_HwReset is 0x1400 */
+	cy_writeb(true_base_addr + (Cy_ClrIntr << index), 0);
+	/* Cy_ClrIntr is 0x1800 */
+	udelay(500L);
+
+	for (chip_number = 0; chip_number < CyMAX_CHIPS_PER_CARD; chip_number++) {
+		base_addr =
+		    true_base_addr + (cy_chip_offset[chip_number] << index);
+		mdelay(1);
+		if (cy_readb(base_addr + (CyCCR << index)) != 0x00) {
+			/*************
+			printk(" chip #%d at %#6lx is never idle (CCR != 0)\n",
+			chip_number, (unsigned long)base_addr);
+			*************/
+			return chip_number;
+		}
+
+		cy_writeb(base_addr + (CyGFRCR << index), 0);
+		udelay(10L);
+
+		/* The Cyclom-16Y does not decode address bit 9 and therefore
+		   cannot distinguish between references to chip 0 and a non-
+		   existent chip 4.  If the preceding clearing of the supposed
+		   chip 4 GFRCR register appears at chip 0, there is no chip 4
+		   and this must be a Cyclom-16Y, not a Cyclom-32Ye.
+		 */
+		if (chip_number == 4 && cy_readb(true_base_addr +
+				(cy_chip_offset[0] << index) +
+				(CyGFRCR << index)) == 0) {
+			return chip_number;
+		}
+
+		cy_writeb(base_addr + (CyCCR << index), CyCHIP_RESET);
+		mdelay(1);
+
+		if (cy_readb(base_addr + (CyGFRCR << index)) == 0x00) {
+			/*
+			   printk(" chip #%d at %#6lx is not responding ",
+			   chip_number, (unsigned long)base_addr);
+			   printk("(GFRCR stayed 0)\n",
+			 */
+			return chip_number;
+		}
+		if ((0xf0 & (cy_readb(base_addr + (CyGFRCR << index)))) !=
+				0x40) {
+			/*
+			printk(" chip #%d at %#6lx is not valid (GFRCR == "
+					"%#2x)\n",
+					chip_number, (unsigned long)base_addr,
+					base_addr[CyGFRCR<<index]);
+			 */
+			return chip_number;
+		}
+		cy_writeb(base_addr + (CyGCR << index), CyCH0_SERIAL);
+		if (cy_readb(base_addr + (CyGFRCR << index)) >= CD1400_REV_J) {
+			/* It is a CD1400 rev. J or later */
+			/* Impossible to reach 5ms with this chip.
+			   Changed to 2ms instead (f = 500 Hz). */
+			cy_writeb(base_addr + (CyPPR << index), CyCLOCK_60_2MS);
+		} else {
+			/* f = 200 Hz */
+			cy_writeb(base_addr + (CyPPR << index), CyCLOCK_25_5MS);
+		}
@@ -4503,8 +4601,8 @@
-    /*
-        printk(" chip #%d at %#6lx is rev 0x%2x\n",
-               chip_number, (unsigned long)base_addr,
-	       cy_readb(base_addr+(CyGFRCR<<index)));
-    */
-    }
-    return chip_number;
-} /* cyy_init_card */
+		/*
+		   printk(" chip #%d at %#6lx is rev 0x%2x\n",
+		   chip_number, (unsigned long)base_addr,
+		   cy_readb(base_addr+(CyGFRCR<<index)));
+		 */
+	}
+	return chip_number;
+}				/* cyy_init_card */
@@ -4518,2 +4616 @@
-static int __init
-cy_detect_isa(void)
+static int __init cy_detect_isa(void)
@@ -4522,3 +4619,3 @@
-  unsigned short	cy_isa_irq,nboard;
-  void __iomem		*cy_isa_address;
-  unsigned short	i,j,cy_isa_nchan;
+	unsigned short cy_isa_irq, nboard;
+	void __iomem *cy_isa_address;
+	unsigned short i, j, cy_isa_nchan;
@@ -4526 +4623 @@
-  int isparam = 0;
+	int isparam = 0;
@@ -4529 +4626 @@
-        nboard = 0;
+	nboard = 0;
@@ -4533,7 +4630,7 @@
-	for(i = 0 ; i < NR_CARDS; i++) {
-	    if (maddr[i] || i) {
-		isparam = 1;
-		cy_isa_addresses[i] = maddr[i];
-	    }
-	    if (!maddr[i])
-		break;
+	for (i = 0; i < NR_CARDS; i++) {
+		if (maddr[i] || i) {
+			isparam = 1;
+			cy_isa_addresses[i] = maddr[i];
+		}
+		if (!maddr[i])
+			break;
@@ -4543,6 +4640,6 @@
-        /* scan the address table probing for Cyclom-Y/ISA boards */
-        for (i = 0 ; i < NR_ISA_ADDRS ; i++) {
-        	unsigned int isa_address = cy_isa_addresses[i];
-                if (isa_address  == 0x0000) {
-                        return(nboard);
-                }
+	/* scan the address table probing for Cyclom-Y/ISA boards */
+	for (i = 0; i < NR_ISA_ADDRS; i++) {
+		unsigned int isa_address = cy_isa_addresses[i];
+		if (isa_address == 0x0000) {
+			return nboard;
+		}
@@ -4550 +4647 @@
-                /* probe for CD1400... */
+		/* probe for CD1400... */
@@ -4552,6 +4649,5 @@
-                cy_isa_nchan = CyPORTS_PER_CHIP * 
-                     cyy_init_card(cy_isa_address,0);
-                if (cy_isa_nchan == 0) {
-                        continue;
-                }
-
+		cy_isa_nchan = CyPORTS_PER_CHIP *
+			cyy_init_card(cy_isa_address, 0);
+		if (cy_isa_nchan == 0) {
+			continue;
+		}
@@ -4560 +4656 @@
-		    cy_isa_irq = irq[i];
+			cy_isa_irq = irq[i];
@@ -4563,58 +4659,59 @@
-                /* find out the board's irq by probing */
-                cy_isa_irq = detect_isa_irq(cy_isa_address);
-                if (cy_isa_irq == 0) {
-                        printk("Cyclom-Y/ISA found at 0x%lx ",
-                                (unsigned long) cy_isa_address);
-                        printk("but the IRQ could not be detected.\n");
-                        continue;
-                }
-
-                if((cy_next_channel+cy_isa_nchan) > NR_PORTS) {
-                        printk("Cyclom-Y/ISA found at 0x%lx ",
-                                (unsigned long) cy_isa_address);
-                        printk("but no more channels are available.\n");
-                        printk("Change NR_PORTS in cyclades.c and recompile kernel.\n");
-                        return(nboard);
-                }
-                /* fill the next cy_card structure available */
-                for (j = 0 ; j < NR_CARDS ; j++) {
-                        if (cy_card[j].base_addr == 0)  break;
-                }
-                if (j == NR_CARDS) {    /* no more cy_cards available */
-                        printk("Cyclom-Y/ISA found at 0x%lx ",
-                                (unsigned long) cy_isa_address);
-                        printk("but no more cards can be used .\n");
-                        printk("Change NR_CARDS in cyclades.c and recompile kernel.\n");
-                        return(nboard);
-                }
-
-                /* allocate IRQ */
-                if(request_irq(cy_isa_irq, cyy_interrupt,
-				   IRQF_DISABLED, "Cyclom-Y", &cy_card[j]))
-                {
-                        printk("Cyclom-Y/ISA found at 0x%lx ",
-                                (unsigned long) cy_isa_address);
-                        printk("but could not allocate IRQ#%d.\n",
-                                cy_isa_irq);
-                        return(nboard);
-                }
-
-                /* set cy_card */
-                cy_card[j].base_addr = cy_isa_address;
-                cy_card[j].ctl_addr = NULL;
-                cy_card[j].irq = (int) cy_isa_irq;
-                cy_card[j].bus_index = 0;
-                cy_card[j].first_line = cy_next_channel;
-                cy_card[j].num_chips = cy_isa_nchan/4;
-                nboard++;
-                        
-                /* print message */
-                printk("Cyclom-Y/ISA #%d: 0x%lx-0x%lx, IRQ%d, ",
-                    j+1, (unsigned long) cy_isa_address,
-                    (unsigned long)(cy_isa_address + (CyISA_Ywin - 1)),
-		    cy_isa_irq);
-                printk("%d channels starting from port %d.\n",
-                        cy_isa_nchan, cy_next_channel);
-                cy_next_channel += cy_isa_nchan;
-        }
-        return(nboard);
+			/* find out the board's irq by probing */
+			cy_isa_irq = detect_isa_irq(cy_isa_address);
+		if (cy_isa_irq == 0) {
+			printk("Cyclom-Y/ISA found at 0x%lx ",
+				(unsigned long)cy_isa_address);
+			printk("but the IRQ could not be detected.\n");
+			continue;
+		}
+
+		if ((cy_next_channel + cy_isa_nchan) > NR_PORTS) {
+			printk("Cyclom-Y/ISA found at 0x%lx ",
+				(unsigned long)cy_isa_address);
+			printk("but no more channels are available.\n");
+			printk("Change NR_PORTS in cyclades.c and recompile "
+					"kernel.\n");
+			return nboard;
+		}
+		/* fill the next cy_card structure available */
+		for (j = 0; j < NR_CARDS; j++) {
+			if (cy_card[j].base_addr == 0)
+				break;
+		}
+		if (j == NR_CARDS) {	/* no more cy_cards available */
+			printk("Cyclom-Y/ISA found at 0x%lx ",
+				(unsigned long)cy_isa_address);
+			printk("but no more cards can be used .\n");
+			printk("Change NR_CARDS in cyclades.c and recompile "
+					"kernel.\n");
+			return nboard;
+		}
+
+		/* allocate IRQ */
+		if (request_irq(cy_isa_irq, cyy_interrupt,
+				IRQF_DISABLED, "Cyclom-Y", &cy_card[j])) {
+			printk("Cyclom-Y/ISA found at 0x%lx ",
+				(unsigned long)cy_isa_address);
+			printk("but could not allocate IRQ#%d.\n", cy_isa_irq);
+			return nboard;
+		}
+
+		/* set cy_card */
+		cy_card[j].base_addr = cy_isa_address;
+		cy_card[j].ctl_addr = NULL;
+		cy_card[j].irq = (int)cy_isa_irq;
+		cy_card[j].bus_index = 0;
+		cy_card[j].first_line = cy_next_channel;
+		cy_card[j].num_chips = cy_isa_nchan / 4;
+		nboard++;
+
+		/* print message */
+		printk("Cyclom-Y/ISA #%d: 0x%lx-0x%lx, IRQ%d, ",
+			j + 1, (unsigned long)cy_isa_address,
+			(unsigned long)(cy_isa_address + (CyISA_Ywin - 1)),
+			cy_isa_irq);
+		printk("%d channels starting from port %d.\n",
+			cy_isa_nchan, cy_next_channel);
+		cy_next_channel += cy_isa_nchan;
+	}
+	return nboard;
@@ -4622,16 +4719,15 @@
-        return(0);
-#endif /* CONFIG_ISA */
-} /* cy_detect_isa */
-
-static void 
-plx_init(void __iomem *addr, uclong initctl)
-{
-    /* Reset PLX */
-    cy_writel(addr + initctl, cy_readl(addr + initctl) | 0x40000000);
-    udelay(100L);
-    cy_writel(addr + initctl, cy_readl(addr + initctl) & ~0x40000000);
-
-    /* Reload Config. Registers from EEPROM */
-    cy_writel(addr + initctl, cy_readl(addr + initctl) | 0x20000000);
-    udelay(100L);
-    cy_writel(addr + initctl, cy_readl(addr + initctl) & ~0x20000000);
+	return 0;
+#endif				/* CONFIG_ISA */
+}				/* cy_detect_isa */
+
+static void plx_init(void __iomem * addr, uclong initctl)
+{
+	/* Reset PLX */
+	cy_writel(addr + initctl, cy_readl(addr + initctl) | 0x40000000);
+	udelay(100L);
+	cy_writel(addr + initctl, cy_readl(addr + initctl) & ~0x40000000);
+
+	/* Reload Config. Registers from EEPROM */
+	cy_writel(addr + initctl, cy_readl(addr + initctl) | 0x20000000);
+	udelay(100L);
+	cy_writel(addr + initctl, cy_readl(addr + initctl) & ~0x20000000);
@@ -4646,2 +4742 @@
-static int __init
-cy_detect_pci(void)
+static int __init cy_detect_pci(void)
@@ -4651,24 +4746,24 @@
-  struct pci_dev	*pdev = NULL;
-  unsigned char		cyy_rev_id;
-  unsigned char		cy_pci_irq = 0;
-  uclong		cy_pci_phys0, cy_pci_phys2;
-  void __iomem		*cy_pci_addr0, *cy_pci_addr2;
-  unsigned short	i,j,cy_pci_nchan, plx_ver;
-  unsigned short	device_id,dev_index = 0;
-  uclong		mailbox;
-  uclong		ZeIndex = 0;
-  void __iomem		*Ze_addr0[NR_CARDS], *Ze_addr2[NR_CARDS];
-  uclong		Ze_phys0[NR_CARDS], Ze_phys2[NR_CARDS];
-  unsigned char		Ze_irq[NR_CARDS];
-  struct pci_dev	*Ze_pdev[NR_CARDS];
-
-        for (i = 0; i < NR_CARDS; i++) {
-                /* look for a Cyclades card by vendor and device id */
-                while((device_id = cy_pci_dev_id[dev_index]) != 0) {
-                        if((pdev = pci_get_device(PCI_VENDOR_ID_CYCLADES,
-                                        device_id, pdev)) == NULL) {
-                                dev_index++;    /* try next device id */
-                        } else {
-                                break;          /* found a board */
-                        }
-                }
+	struct pci_dev *pdev = NULL;
+	unsigned char cyy_rev_id;
+	unsigned char cy_pci_irq = 0;
+	uclong cy_pci_phys0, cy_pci_phys2;
+	void __iomem *cy_pci_addr0, *cy_pci_addr2;
+	unsigned short i, j, cy_pci_nchan, plx_ver;
+	unsigned short device_id, dev_index = 0;
+	uclong mailbox;
+	uclong ZeIndex = 0;
+	void __iomem *Ze_addr0[NR_CARDS], *Ze_addr2[NR_CARDS];
+	uclong Ze_phys0[NR_CARDS], Ze_phys2[NR_CARDS];
+	unsigned char Ze_irq[NR_CARDS];
+	struct pci_dev *Ze_pdev[NR_CARDS];
+
+	for (i = 0; i < NR_CARDS; i++) {
+		/* look for a Cyclades card by vendor and device id */
+		while ((device_id = cy_pci_dev_id[dev_index]) != 0) {
+			if ((pdev = pci_get_device(PCI_VENDOR_ID_CYCLADES,
+						   device_id, pdev)) == NULL) {
+				dev_index++;	/* try next device id */
+			} else {
+				break;	/* found a board */
+			}
+		}
@@ -4677 +4772 @@
-		    break;
+			break;
@@ -4680 +4775 @@
-		    continue;
+			continue;
@@ -4682 +4777 @@
-                /* read PCI configuration area */
+		/* read PCI configuration area */
@@ -4690,2 +4785,2 @@
-    if ((device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo)
-	   || (device_id == PCI_DEVICE_ID_CYCLOM_Y_Hi)){
+		if (device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo ||
+				device_id == PCI_DEVICE_ID_CYCLOM_Y_Hi) {
@@ -4693,21 +4788,14 @@
-            printk("Cyclom-Y/PCI (bus=0x0%x, pci_id=0x%x, ",
-		pdev->bus->number, pdev->devfn);
-            printk("rev_id=%d) IRQ%d\n",
-		cyy_rev_id, (int)cy_pci_irq);
-            printk("Cyclom-Y/PCI:found  winaddr=0x%lx ctladdr=0x%lx\n",
-		(ulong)cy_pci_phys2, (ulong)cy_pci_phys0);
-#endif
-
-		if (pci_resource_flags(pdev, 2) & IORESOURCE_IO) {
-		    printk("  Warning: PCI I/O bit incorrectly set. "
-			   "Ignoring it...\n");
-		    pdev->resource[2].flags &= ~IORESOURCE_IO;
-		}
-
-		/* Although we don't use this I/O region, we should
-		   request it from the kernel anyway, to avoid problems
-		   with other drivers accessing it. */
-		if (pci_request_regions(pdev, "Cyclom-Y") != 0) {
-			printk(KERN_ERR "cyclades: failed to reserve PCI resources\n");
-			continue;
-		}
+			printk("Cyclom-Y/PCI (bus=0x0%x, pci_id=0x%x, ",
+				pdev->bus->number, pdev->devfn);
+			printk("rev_id=%d) IRQ%d\n",
+				cyy_rev_id, (int)cy_pci_irq);
+			printk("Cyclom-Y/PCI:found  winaddr=0x%lx "
+				"ctladdr=0x%lx\n",
+				(ulong)cy_pci_phys2, (ulong)cy_pci_phys0);
+#endif
+
+			if (pci_resource_flags(pdev, 2) & IORESOURCE_IO) {
+				printk("  Warning: PCI I/O bit incorrectly "
+					"set. Ignoring it...\n");
+				pdev->resource[2].flags &= ~IORESOURCE_IO;
+			}
@@ -4714,0 +4803,8 @@
+			/* Although we don't use this I/O region, we should
+			   request it from the kernel anyway, to avoid problems
+			   with other drivers accessing it. */
+			if (pci_request_regions(pdev, "Cyclom-Y") != 0) {
+				printk(KERN_ERR "cyclades: failed to reserve "
+						"PCI resources\n");
+				continue;
+			}
@@ -4716,12 +4812,14 @@
-                if (device_id  == PCI_DEVICE_ID_CYCLOM_Y_Lo) { /* below 1M? */
-		    printk("Cyclom-Y/PCI (bus=0x0%x, pci_id=0x%x, ",
-			pdev->bus->number, pdev->devfn);
-		    printk("rev_id=%d) IRQ%d\n",
-		        cyy_rev_id, (int)cy_pci_irq);
-                    printk("Cyclom-Y/PCI:found  winaddr=0x%lx ctladdr=0x%lx\n",
-		        (ulong)cy_pci_phys2, (ulong)cy_pci_phys0);
-	            printk("Cyclom-Y/PCI not supported for low addresses in "
-                           "Alpha systems.\n");
-		    i--;
-	            continue;
-                }
+			if (device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo) {	/* below 1M? */
+				printk("Cyclom-Y/PCI (bus=0x0%x, pci_id=0x%x, ",
+					pdev->bus->number, pdev->devfn);
+				printk("rev_id=%d) IRQ%d\n",
+					cyy_rev_id, (int)cy_pci_irq);
+				printk("Cyclom-Y/PCI:found  winaddr=0x%lx "
+					"ctladdr=0x%lx\n",
+					(ulong)cy_pci_phys2,
+					(ulong)cy_pci_phys0);
+				printk("Cyclom-Y/PCI not supported for low "
+					"addresses in Alpha systems.\n");
+				i--;
+				continue;
+			}
@@ -4729,2 +4827,2 @@
-		cy_pci_addr0 = ioremap(cy_pci_phys0, CyPCI_Yctl);
-		cy_pci_addr2 = ioremap(cy_pci_phys2, CyPCI_Ywin);
+			cy_pci_addr0 = ioremap(cy_pci_phys0, CyPCI_Yctl);
+			cy_pci_addr2 = ioremap(cy_pci_phys2, CyPCI_Ywin);
@@ -4733,98 +4831,105 @@
-            printk("Cyclom-Y/PCI: relocate winaddr=0x%lx ctladdr=0x%lx\n",
-		(u_long)cy_pci_addr2, (u_long)cy_pci_addr0);
-#endif
-                cy_pci_nchan = (unsigned short)(CyPORTS_PER_CHIP * 
-                       cyy_init_card(cy_pci_addr2, 1));
-                if(cy_pci_nchan == 0) {
-                        printk("Cyclom-Y PCI host card with ");
-                        printk("no Serial-Modules at 0x%lx.\n",
-			    (ulong) cy_pci_phys2);
-                        i--;
-                        continue;
-                }
-                if((cy_next_channel+cy_pci_nchan) > NR_PORTS) {
-                        printk("Cyclom-Y/PCI found at 0x%lx ",
-			    (ulong) cy_pci_phys2);
-                        printk("but no channels are available.\n");
-                        printk("Change NR_PORTS in cyclades.c and recompile kernel.\n");
-                        return(i);
-                }
-                /* fill the next cy_card structure available */
-                for (j = 0 ; j < NR_CARDS ; j++) {
-                        if (cy_card[j].base_addr == 0)  break;
-                }
-                if (j == NR_CARDS) {    /* no more cy_cards available */
-                        printk("Cyclom-Y/PCI found at 0x%lx ",
-			    (ulong) cy_pci_phys2);
-                        printk("but no more cards can be used.\n");
-                        printk("Change NR_CARDS in cyclades.c and recompile kernel.\n");
-                        return(i);
-                }
-
-                /* allocate IRQ */
-                if(request_irq(cy_pci_irq, cyy_interrupt,
-		        IRQF_SHARED, "Cyclom-Y", &cy_card[j]))
-                {
-                        printk("Cyclom-Y/PCI found at 0x%lx ",
-			    (ulong) cy_pci_phys2);
-                        printk("but could not allocate IRQ%d.\n",
-			    cy_pci_irq);
-                        return(i);
-                }
-
-                /* set cy_card */
-                cy_card[j].base_phys = (ulong)cy_pci_phys2;
-                cy_card[j].ctl_phys = (ulong)cy_pci_phys0;
-                cy_card[j].base_addr = cy_pci_addr2;
-                cy_card[j].ctl_addr = cy_pci_addr0;
-                cy_card[j].irq = (int) cy_pci_irq;
-                cy_card[j].bus_index = 1;
-                cy_card[j].first_line = cy_next_channel;
-                cy_card[j].num_chips = cy_pci_nchan/4;
-		cy_card[j].pdev = pdev;
-	
-                /* enable interrupts in the PCI interface */
-		plx_ver = cy_readb(cy_pci_addr2 + CyPLX_VER) & 0x0f;
-		switch (plx_ver) {
-		    case PLX_9050:
-
-		    cy_writeb(cy_pci_addr0+0x4c, 0x43);
-		    break;
-
-		    case PLX_9060:
-		    case PLX_9080:
-		    default: /* Old boards, use PLX_9060 */
-
-		    plx_init(cy_pci_addr0, 0x6c);
-		    /* For some yet unknown reason, once the PLX9060 reloads
-		       the EEPROM, the IRQ is lost and, thus, we have to
-		       re-write it to the PCI config. registers.
-		       This will remain here until we find a permanent fix. */
-		    pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, cy_pci_irq);
-
-		    cy_writew(cy_pci_addr0+0x68, 
-			cy_readw(cy_pci_addr0+0x68)|0x0900);
-		    break;
-		}
-
-                /* print message */
-                printk("Cyclom-Y/PCI #%d: 0x%lx-0x%lx, IRQ%d, ",
-		       j+1, 
-		       (ulong)cy_pci_phys2, 
-		       (ulong)(cy_pci_phys2 + CyPCI_Ywin - 1),
-		       (int)cy_pci_irq);
-                printk("%d channels starting from port %d.\n",
-		    cy_pci_nchan, cy_next_channel);
-
-                cy_next_channel += cy_pci_nchan;
-    }else if (device_id == PCI_DEVICE_ID_CYCLOM_Z_Lo){
-	    /* print message */
-		printk("Cyclades-Z/PCI (bus=0x0%x, pci_id=0x%x, ",
-		    pdev->bus->number, pdev->devfn);
-		printk("rev_id=%d) IRQ%d\n",
-		    cyy_rev_id, (int)cy_pci_irq);
-		printk("Cyclades-Z/PCI: found winaddr=0x%lx ctladdr=0x%lx\n",
-		    (ulong)cy_pci_phys2, (ulong)cy_pci_phys0);
-	    printk("Cyclades-Z/PCI not supported for low addresses\n");
-	    break;
-    }else if (device_id == PCI_DEVICE_ID_CYCLOM_Z_Hi){
+			printk("Cyclom-Y/PCI: relocate winaddr=0x%lx "
+				"ctladdr=0x%lx\n",
+				(u_long)cy_pci_addr2, (u_long)cy_pci_addr0);
+#endif
+			cy_pci_nchan = (unsigned short)(CyPORTS_PER_CHIP *
+					cyy_init_card(cy_pci_addr2, 1));
+			if (cy_pci_nchan == 0) {
+				printk("Cyclom-Y PCI host card with ");
+				printk("no Serial-Modules at 0x%lx.\n",
+					(ulong) cy_pci_phys2);
+				i--;
+				continue;
+			}
+			if ((cy_next_channel + cy_pci_nchan) > NR_PORTS) {
+				printk("Cyclom-Y/PCI found at 0x%lx ",
+					(ulong) cy_pci_phys2);
+				printk("but no channels are available.\n");
+				printk("Change NR_PORTS in cyclades.c and "
+						"recompile kernel.\n");
+				return i;
+			}
+			/* fill the next cy_card structure available */
+			for (j = 0; j < NR_CARDS; j++) {
+				if (cy_card[j].base_addr == 0)
+					break;
+			}
+			if (j == NR_CARDS) {	/* no more cy_cards available */
+				printk("Cyclom-Y/PCI found at 0x%lx ",
+					(ulong) cy_pci_phys2);
+				printk("but no more cards can be used.\n");
+				printk("Change NR_CARDS in cyclades.c and "
+						"recompile kernel.\n");
+				return i;
+			}
+
+			/* allocate IRQ */
+			if (request_irq(cy_pci_irq, cyy_interrupt,
+					IRQF_SHARED, "Cyclom-Y", &cy_card[j])) {
+				printk("Cyclom-Y/PCI found at 0x%lx ",
+					(ulong) cy_pci_phys2);
+				printk("but could not allocate IRQ%d.\n",
+					cy_pci_irq);
+				return i;
+			}
+
+			/* set cy_card */
+			cy_card[j].base_phys = (ulong) cy_pci_phys2;
+			cy_card[j].ctl_phys = (ulong) cy_pci_phys0;
+			cy_card[j].base_addr = cy_pci_addr2;
+			cy_card[j].ctl_addr = cy_pci_addr0;
+			cy_card[j].irq = (int)cy_pci_irq;
+			cy_card[j].bus_index = 1;
+			cy_card[j].first_line = cy_next_channel;
+			cy_card[j].num_chips = cy_pci_nchan / 4;
+			cy_card[j].pdev = pdev;
+
+			/* enable interrupts in the PCI interface */
+			plx_ver = cy_readb(cy_pci_addr2 + CyPLX_VER) & 0x0f;
+			switch (plx_ver) {
+			case PLX_9050:
+
+				cy_writeb(cy_pci_addr0 + 0x4c, 0x43);
+				break;
+
+			case PLX_9060:
+			case PLX_9080:
+			default:	/* Old boards, use PLX_9060 */
+
+				plx_init(cy_pci_addr0, 0x6c);
+			/* For some yet unknown reason, once the PLX9060 reloads
+			   the EEPROM, the IRQ is lost and, thus, we have to
+			   re-write it to the PCI config. registers.
+			   This will remain here until we find a permanent
+			   fix. */
+				pci_write_config_byte(pdev, PCI_INTERRUPT_LINE,
+						cy_pci_irq);
+
+				cy_writew(cy_pci_addr0 + 0x68,
+					  cy_readw(cy_pci_addr0 +
+						   0x68) | 0x0900);
+				break;
+			}
+
+			/* print message */
+			printk("Cyclom-Y/PCI #%d: 0x%lx-0x%lx, IRQ%d, ",
+				j + 1, (ulong)cy_pci_phys2,
+				(ulong) (cy_pci_phys2 + CyPCI_Ywin - 1),
+				(int)cy_pci_irq);
+			printk("%d channels starting from port %d.\n",
+				cy_pci_nchan, cy_next_channel);
+
+			cy_next_channel += cy_pci_nchan;
+		} else if (device_id == PCI_DEVICE_ID_CYCLOM_Z_Lo) {
+			/* print message */
+			printk("Cyclades-Z/PCI (bus=0x0%x, pci_id=0x%x, ",
+				pdev->bus->number, pdev->devfn);
+			printk("rev_id=%d) IRQ%d\n",
+				cyy_rev_id, (int)cy_pci_irq);
+			printk("Cyclades-Z/PCI: found winaddr=0x%lx "
+				"ctladdr=0x%lx\n",
+				(ulong)cy_pci_phys2, (ulong)cy_pci_phys0);
+			printk("Cyclades-Z/PCI not supported for low "
+				"addresses\n");
+			break;
+		} else if (device_id == PCI_DEVICE_ID_CYCLOM_Z_Hi) {
@@ -4832,58 +4937,66 @@
-            printk("Cyclades-Z/PCI (bus=0x0%x, pci_id=0x%x, ",
-	        pdev->bus->number, pdev->devfn);
-            printk("rev_id=%d) IRQ%d\n",
-		cyy_rev_id, (int)cy_pci_irq);
-            printk("Cyclades-Z/PCI: found winaddr=0x%lx ctladdr=0x%lx\n",
-                (ulong)cy_pci_phys2, (ulong)cy_pci_phys0);
-#endif
-		cy_pci_addr0 = ioremap(cy_pci_phys0, CyPCI_Zctl);
-
-		/* Disable interrupts on the PLX before resetting it */
-		cy_writew(cy_pci_addr0+0x68,
-			cy_readw(cy_pci_addr0+0x68) & ~0x0900);
-
-		plx_init(cy_pci_addr0, 0x6c);
-		/* For some yet unknown reason, once the PLX9060 reloads
-		   the EEPROM, the IRQ is lost and, thus, we have to
-		   re-write it to the PCI config. registers.
-		   This will remain here until we find a permanent fix. */
-		pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, cy_pci_irq);
-
-		mailbox = (uclong)cy_readl(&((struct RUNTIME_9060 __iomem *) 
-			   cy_pci_addr0)->mail_box_0);
-
-		if (pci_resource_flags(pdev, 2) & IORESOURCE_IO) {
-		    printk("  Warning: PCI I/O bit incorrectly set. "
-			   "Ignoring it...\n");
-		    pdev->resource[2].flags &= ~IORESOURCE_IO;
-		}
-
-		/* Although we don't use this I/O region, we should
-		   request it from the kernel anyway, to avoid problems
-		   with other drivers accessing it. */
-		if (pci_request_regions(pdev, "Cyclades-Z") != 0) {
-			printk(KERN_ERR "cyclades: failed to reserve PCI resources\n");
-			continue;
-		}
-	
-		if (mailbox == ZE_V1) {
-		    cy_pci_addr2 = ioremap(cy_pci_phys2, CyPCI_Ze_win);
-		    if (ZeIndex == NR_CARDS) {
-			printk("Cyclades-Ze/PCI found at 0x%lx ",
-				(ulong)cy_pci_phys2);
-			printk("but no more cards can be used.\n");
-                        printk("Change NR_CARDS in cyclades.c and recompile kernel.\n");
-		    } else {
-			Ze_phys0[ZeIndex] = cy_pci_phys0;
-			Ze_phys2[ZeIndex] = cy_pci_phys2;
-			Ze_addr0[ZeIndex] = cy_pci_addr0;
-			Ze_addr2[ZeIndex] = cy_pci_addr2;
-			Ze_irq[ZeIndex] = cy_pci_irq;
-			Ze_pdev[ZeIndex] = pdev;
-			ZeIndex++;
-		    }
-		    i--;
-		    continue;
-		} else {
-		    cy_pci_addr2 = ioremap(cy_pci_phys2, CyPCI_Zwin);
-		}
+			printk("Cyclades-Z/PCI (bus=0x0%x, pci_id=0x%x, ",
+				pdev->bus->number, pdev->devfn);
+			printk("rev_id=%d) IRQ%d\n",
+				cyy_rev_id, (int)cy_pci_irq);
+			printk("Cyclades-Z/PCI: found winaddr=0x%lx "
+				"ctladdr=0x%lx\n",
+				(ulong) cy_pci_phys2, (ulong) cy_pci_phys0);
+#endif
+			cy_pci_addr0 = ioremap(cy_pci_phys0, CyPCI_Zctl);
+
+			/* Disable interrupts on the PLX before resetting it */
+			cy_writew(cy_pci_addr0 + 0x68,
+				cy_readw(cy_pci_addr0 + 0x68) & ~0x0900);
+
+			plx_init(cy_pci_addr0, 0x6c);
+			/* For some yet unknown reason, once the PLX9060 reloads
+			   the EEPROM, the IRQ is lost and, thus, we have to
+			   re-write it to the PCI config. registers.
+			   This will remain here until we find a permanent
+			   fix. */
+			pci_write_config_byte(pdev, PCI_INTERRUPT_LINE,
+						cy_pci_irq);
+
+			mailbox =
+			    (uclong)cy_readl(&((struct RUNTIME_9060 __iomem *)
+						cy_pci_addr0)->mail_box_0);
+
+			if (pci_resource_flags(pdev, 2) & IORESOURCE_IO) {
+				printk("  Warning: PCI I/O bit incorrectly "
+					"set. Ignoring it...\n");
+				pdev->resource[2].flags &= ~IORESOURCE_IO;
+			}
+
+			/* Although we don't use this I/O region, we should
+			   request it from the kernel anyway, to avoid problems
+			   with other drivers accessing it. */
+			if (pci_request_regions(pdev, "Cyclades-Z") != 0) {
+				printk(KERN_ERR "cyclades: failed to reserve "
+					"PCI resources\n");
+				continue;
+			}
+
+			if (mailbox == ZE_V1) {
+				cy_pci_addr2 = ioremap(cy_pci_phys2,
+						CyPCI_Ze_win);
+				if (ZeIndex == NR_CARDS) {
+					printk("Cyclades-Ze/PCI found at "
+						"0x%lx but no more cards can "
+						"be used.\nChange NR_CARDS in "
+						"cyclades.c and recompile "
+						"kernel.\n",
+						(ulong)cy_pci_phys2);
+				} else {
+					Ze_phys0[ZeIndex] = cy_pci_phys0;
+					Ze_phys2[ZeIndex] = cy_pci_phys2;
+					Ze_addr0[ZeIndex] = cy_pci_addr0;
+					Ze_addr2[ZeIndex] = cy_pci_addr2;
+					Ze_irq[ZeIndex] = cy_pci_irq;
+					Ze_pdev[ZeIndex] = pdev;
+					ZeIndex++;
+				}
+				i--;
+				continue;
+			} else {
+				cy_pci_addr2 = ioremap(cy_pci_phys2,CyPCI_Zwin);
+			}
@@ -4892,49 +5005,44 @@
-            printk("Cyclades-Z/PCI: relocate winaddr=0x%lx ctladdr=0x%lx\n",
-                (ulong)cy_pci_addr2, (ulong)cy_pci_addr0);
-	    if (mailbox == ZO_V1) {
-		cy_writel(&((struct RUNTIME_9060 *)
-			  (cy_pci_addr0))->loc_addr_base, WIN_CREG);
-		PAUSE
-		printk("Cyclades-8Zo/PCI: FPGA id %lx, ver %lx\n",
-		       (ulong)(0xff & cy_readl(&((struct CUSTOM_REG *)
-		        (cy_pci_addr2))->fpga_id)),
-		       (ulong)(0xff & cy_readl(&((struct CUSTOM_REG *)
-		        (cy_pci_addr2))->fpga_version)));
-		cy_writel(&((struct RUNTIME_9060 *)
-			  (cy_pci_addr0))->loc_addr_base, WIN_RAM);
-	    } else {
-		printk("Cyclades-Z/PCI: New Cyclades-Z board.  FPGA not loaded\n");
-	    }
-#endif
-	    /* The following clears the firmware id word.  This ensures
-	       that the driver will not attempt to talk to the board
-	       until it has been properly initialized.
-	     */
-		PAUSE
-		if ((mailbox == ZO_V1) || (mailbox == ZO_V2))
-		    cy_writel(cy_pci_addr2 + ID_ADDRESS, 0L);
-
-                /* This must be a Cyclades-8Zo/PCI.  The extendable
-                   version will have a different device_id and will
-                   be allocated its maximum number of ports. */
-                cy_pci_nchan = 8;
-
-                if((cy_next_channel+cy_pci_nchan) > NR_PORTS) {
-                        printk("Cyclades-8Zo/PCI found at 0x%lx ",
-			    (ulong)cy_pci_phys2);
-                        printk("but no channels are available.\n");
-                        printk("Change NR_PORTS in cyclades.c and recompile kernel.\n");
-                        return(i);
-                }
-
-                /* fill the next cy_card structure available */
-                for (j = 0 ; j < NR_CARDS ; j++) {
-                        if (cy_card[j].base_addr == 0)  break;
-                }
-                if (j == NR_CARDS) {    /* no more cy_cards available */
-		    printk("Cyclades-8Zo/PCI found at 0x%lx ",
-			(ulong)cy_pci_phys2);
-		    printk("but no more cards can be used.\n");
-                    printk("Change NR_CARDS in cyclades.c and recompile kernel.\n");
-		    return(i);
-                }
+			printk("Cyclades-Z/PCI: relocate winaddr=0x%lx "
+				"ctladdr=0x%lx\n",
+				(ulong) cy_pci_addr2, (ulong) cy_pci_addr0);
+			if (mailbox == ZO_V1) {
+				cy_writel(&((struct RUNTIME_9060 *)
+					(cy_pci_addr0))->loc_addr_base,
+					WIN_CREG);
+				PAUSE;
+				printk("Cyclades-8Zo/PCI: FPGA id %lx, ver "
+					"%lx\n", (ulong) (0xff &
+					cy_readl(&((struct CUSTOM_REG *)
+						(cy_pci_addr2))->fpga_id)),
+					(ulong)(0xff &
+					cy_readl(&((struct CUSTOM_REG *)
+						(cy_pci_addr2))->
+							fpga_version)));
+				cy_writel(&((struct RUNTIME_9060 *)
+					(cy_pci_addr0))->loc_addr_base,
+					WIN_RAM);
+			} else {
+				printk("Cyclades-Z/PCI: New Cyclades-Z board.  "
+						"FPGA not loaded\n");
+			}
+#endif
+			/* The following clears the firmware id word.  This
+			   ensures that the driver will not attempt to talk to
+			   the board until it has been properly initialized.
+			 */
+			PAUSE;
+			if ((mailbox == ZO_V1) || (mailbox == ZO_V2))
+				cy_writel(cy_pci_addr2 + ID_ADDRESS, 0L);
+
+			/* This must be a Cyclades-8Zo/PCI.  The extendable
+			   version will have a different device_id and will
+			   be allocated its maximum number of ports. */
+			cy_pci_nchan = 8;
+
+			if ((cy_next_channel + cy_pci_nchan) > NR_PORTS) {
+				printk("Cyclades-8Zo/PCI found at 0x%lx but"
+					"no channels are available.\nChange "
+					"NR_PORTS in cyclades.c and recompile "
+					"kernel.\n", (ulong)cy_pci_phys2);
+				return i;
+			}
@@ -4941,0 +5050,12 @@
+			/* fill the next cy_card structure available */
+			for (j = 0; j < NR_CARDS; j++) {
+				if (cy_card[j].base_addr == 0)
+					break;
+			}
+			if (j == NR_CARDS) {	/* no more cy_cards available */
+				printk("Cyclades-8Zo/PCI found at 0x%lx but"
+					"no more cards can be used.\nChange "
+					"NR_CARDS in cyclades.c and recompile "
+					"kernel.\n", (ulong)cy_pci_phys2);
+				return i;
+			}
@@ -4943,14 +5063,13 @@
-                /* allocate IRQ only if board has an IRQ */
-		if( (cy_pci_irq != 0) && (cy_pci_irq != 255) ) {
-		    if(request_irq(cy_pci_irq, cyz_interrupt,
-			IRQF_SHARED, "Cyclades-Z", &cy_card[j]))
-		    {
-                        printk("Cyclom-8Zo/PCI found at 0x%lx ",
-			    (ulong) cy_pci_phys2);
-                        printk("but could not allocate IRQ%d.\n",
-			    cy_pci_irq);
-			return(i);
-		    }
-		}
-#endif /* CONFIG_CYZ_INTR */
-
+			/* allocate IRQ only if board has an IRQ */
+			if ((cy_pci_irq != 0) && (cy_pci_irq != 255)) {
+				if (request_irq(cy_pci_irq, cyz_interrupt,
+						IRQF_SHARED, "Cyclades-Z",
+						&cy_card[j])) {
+					printk("Cyclom-8Zo/PCI found at 0x%lx "
+						"but could not allocate "
+						"IRQ%d.\n", (ulong)cy_pci_phys2,
+						cy_pci_irq);
+					return i;
+				}
+			}
+#endif				/* CONFIG_CYZ_INTR */
@@ -4958,10 +5077,10 @@
-                /* set cy_card */
-                cy_card[j].base_phys = cy_pci_phys2;
-                cy_card[j].ctl_phys = cy_pci_phys0;
-                cy_card[j].base_addr = cy_pci_addr2;
-                cy_card[j].ctl_addr = cy_pci_addr0;
-                cy_card[j].irq = (int) cy_pci_irq;
-                cy_card[j].bus_index = 1;
-                cy_card[j].first_line = cy_next_channel;
-                cy_card[j].num_chips = -1;
-		cy_card[j].pdev = pdev;
+			/* set cy_card */
+			cy_card[j].base_phys = cy_pci_phys2;
+			cy_card[j].ctl_phys = cy_pci_phys0;
+			cy_card[j].base_addr = cy_pci_addr2;
+			cy_card[j].ctl_addr = cy_pci_addr0;
+			cy_card[j].irq = (int)cy_pci_irq;
+			cy_card[j].bus_index = 1;
+			cy_card[j].first_line = cy_next_channel;
+			cy_card[j].num_chips = -1;
+			cy_card[j].pdev = pdev;
@@ -4969 +5088 @@
-                /* print message */
+			/* print message */
@@ -4971,36 +5090,36 @@
-		/* don't report IRQ if board is no IRQ */
-		if( (cy_pci_irq != 0) && (cy_pci_irq != 255) )
-		    printk("Cyclades-8Zo/PCI #%d: 0x%lx-0x%lx, IRQ%d, ",
-			j+1,(ulong)cy_pci_phys2,
-			(ulong)(cy_pci_phys2 + CyPCI_Zwin - 1),
-			(int)cy_pci_irq);
-		else
-#endif /* CONFIG_CYZ_INTR */
-		    printk("Cyclades-8Zo/PCI #%d: 0x%lx-0x%lx, ",
-			j+1,(ulong)cy_pci_phys2,
-			(ulong)(cy_pci_phys2 + CyPCI_Zwin - 1));
-
-                printk("%d channels starting from port %d.\n",
-		    cy_pci_nchan,cy_next_channel);
-                cy_next_channel += cy_pci_nchan;
-	    }
-        }
-
-        for (; ZeIndex != 0 && i < NR_CARDS; i++) {
-	    cy_pci_phys0 = Ze_phys0[0];
-	    cy_pci_phys2 = Ze_phys2[0];
-	    cy_pci_addr0 = Ze_addr0[0];
-	    cy_pci_addr2 = Ze_addr2[0];
-	    cy_pci_irq = Ze_irq[0];
-	    pdev = Ze_pdev[0];
-	    for (j = 0 ; j < ZeIndex-1 ; j++) {
-		Ze_phys0[j] = Ze_phys0[j+1];
-		Ze_phys2[j] = Ze_phys2[j+1];
-		Ze_addr0[j] = Ze_addr0[j+1];
-		Ze_addr2[j] = Ze_addr2[j+1];
-		Ze_irq[j] = Ze_irq[j+1];
-		Ze_pdev[j] = Ze_pdev[j+1];
-	    }
-	    ZeIndex--;
-		mailbox = (uclong)cy_readl(&((struct RUNTIME_9060 __iomem *) 
-					   cy_pci_addr0)->mail_box_0);
+			/* don't report IRQ if board is no IRQ */
+			if ((cy_pci_irq != 0) && (cy_pci_irq != 255))
+				printk("Cyclades-8Zo/PCI #%d: 0x%lx-0x%lx, "
+					"IRQ%d, ", j + 1, (ulong)cy_pci_phys2,
+					(ulong) (cy_pci_phys2 + CyPCI_Zwin - 1),
+					(int)cy_pci_irq);
+			else
+#endif				/* CONFIG_CYZ_INTR */
+				printk("Cyclades-8Zo/PCI #%d: 0x%lx-0x%lx, ",
+					j + 1, (ulong)cy_pci_phys2,
+					(ulong)(cy_pci_phys2 + CyPCI_Zwin - 1));
+
+			printk("%d channels starting from port %d.\n",
+					cy_pci_nchan, cy_next_channel);
+			cy_next_channel += cy_pci_nchan;
+		}
+	}
+
+	for (; ZeIndex != 0 && i < NR_CARDS; i++) {
+		cy_pci_phys0 = Ze_phys0[0];
+		cy_pci_phys2 = Ze_phys2[0];
+		cy_pci_addr0 = Ze_addr0[0];
+		cy_pci_addr2 = Ze_addr2[0];
+		cy_pci_irq = Ze_irq[0];
+		pdev = Ze_pdev[0];
+		for (j = 0; j < ZeIndex - 1; j++) {
+			Ze_phys0[j] = Ze_phys0[j + 1];
+			Ze_phys2[j] = Ze_phys2[j + 1];
+			Ze_addr0[j] = Ze_addr0[j + 1];
+			Ze_addr2[j] = Ze_addr2[j + 1];
+			Ze_irq[j] = Ze_irq[j + 1];
+			Ze_pdev[j] = Ze_pdev[j + 1];
+		}
+		ZeIndex--;
+		mailbox = (uclong)cy_readl(&((struct RUNTIME_9060 __iomem *)
+						cy_pci_addr0)->mail_box_0);
@@ -5008,27 +5127,16 @@
-            printk("Cyclades-Z/PCI: relocate winaddr=0x%lx ctladdr=0x%lx\n",
-                (ulong)cy_pci_addr2, (ulong)cy_pci_addr0);
-	    printk("Cyclades-Z/PCI: New Cyclades-Z board.  FPGA not loaded\n");
-#endif
-		PAUSE
-                /* This must be the new Cyclades-Ze/PCI. */
-                cy_pci_nchan = ZE_V1_NPORTS;
-
-                if((cy_next_channel+cy_pci_nchan) > NR_PORTS) {
-                        printk("Cyclades-Ze/PCI found at 0x%lx ",
-			    (ulong)cy_pci_phys2);
-                        printk("but no channels are available.\n");
-                        printk("Change NR_PORTS in cyclades.c and recompile kernel.\n");
-                        return(i);
-                }
-
-                /* fill the next cy_card structure available */
-                for (j = 0 ; j < NR_CARDS ; j++) {
-                        if (cy_card[j].base_addr == 0)  break;
-                }
-                if (j == NR_CARDS) {    /* no more cy_cards available */
-		    printk("Cyclades-Ze/PCI found at 0x%lx ",
-			(ulong)cy_pci_phys2);
-		    printk("but no more cards can be used.\n");
-                    printk("Change NR_CARDS in cyclades.c and recompile kernel.\n");
-		    return(i);
-                }
+		printk("Cyclades-Z/PCI: relocate winaddr=0x%lx ctladdr=0x%lx\n",
+			(ulong)cy_pci_addr2, (ulong)cy_pci_addr0);
+		printk("Cyclades-Z/PCI: New Cyclades-Z board.  FPGA not "
+				"loaded\n");
+#endif
+		PAUSE;
+		/* This must be the new Cyclades-Ze/PCI. */
+		cy_pci_nchan = ZE_V1_NPORTS;
+
+		if ((cy_next_channel + cy_pci_nchan) > NR_PORTS) {
+			printk("Cyclades-Ze/PCI found at 0x%lx but no channels "
+				"are available.\nChange NR_PORTS in cyclades.c "
+				"and recompile kernel.\n",
+				(ulong) cy_pci_phys2);
+			return i;
+		}
@@ -5035,0 +5144,12 @@
+		/* fill the next cy_card structure available */
+		for (j = 0; j < NR_CARDS; j++) {
+			if (cy_card[j].base_addr == 0)
+				break;
+		}
+		if (j == NR_CARDS) {	/* no more cy_cards available */
+			printk("Cyclades-Ze/PCI found at 0x%lx but no more "
+				"cards can be used.\nChange NR_CARDS in "
+				"cyclades.c and recompile kernel.\n",
+				(ulong) cy_pci_phys2);
+			return i;
+		}
@@ -5037,11 +5157,11 @@
-                /* allocate IRQ only if board has an IRQ */
-		if( (cy_pci_irq != 0) && (cy_pci_irq != 255) ) {
-		    if(request_irq(cy_pci_irq, cyz_interrupt,
-			IRQF_SHARED, "Cyclades-Z", &cy_card[j]))
-		    {
-                        printk("Cyclom-Ze/PCI found at 0x%lx ",
-			    (ulong) cy_pci_phys2);
-                        printk("but could not allocate IRQ%d.\n",
-			    cy_pci_irq);
-			return(i);
-		    }
+		/* allocate IRQ only if board has an IRQ */
+		if ((cy_pci_irq != 0) && (cy_pci_irq != 255)) {
+			if (request_irq(cy_pci_irq, cyz_interrupt,
+					IRQF_SHARED, "Cyclades-Z",
+					&cy_card[j])) {
+				printk("Cyclom-Ze/PCI found at 0x%lx ",
+					(ulong) cy_pci_phys2);
+				printk("but could not allocate IRQ%d.\n",
+					cy_pci_irq);
+				return i;
+			}
@@ -5049 +5169 @@
-#endif /* CONFIG_CYZ_INTR */
+#endif				/* CONFIG_CYZ_INTR */
@@ -5051,9 +5171,9 @@
-                /* set cy_card */
-                cy_card[j].base_phys = cy_pci_phys2;
-                cy_card[j].ctl_phys = cy_pci_phys0;
-                cy_card[j].base_addr = cy_pci_addr2;
-                cy_card[j].ctl_addr = cy_pci_addr0;
-                cy_card[j].irq = (int) cy_pci_irq;
-                cy_card[j].bus_index = 1;
-                cy_card[j].first_line = cy_next_channel;
-                cy_card[j].num_chips = -1;
+		/* set cy_card */
+		cy_card[j].base_phys = cy_pci_phys2;
+		cy_card[j].ctl_phys = cy_pci_phys0;
+		cy_card[j].base_addr = cy_pci_addr2;
+		cy_card[j].ctl_addr = cy_pci_addr0;
+		cy_card[j].irq = (int)cy_pci_irq;
+		cy_card[j].bus_index = 1;
+		cy_card[j].first_line = cy_next_channel;
+		cy_card[j].num_chips = -1;
@@ -5062 +5182 @@
-                /* print message */
+		/* print message */
@@ -5065,5 +5185,5 @@
-		if( (cy_pci_irq != 0) && (cy_pci_irq != 255) )
-		    printk("Cyclades-Ze/PCI #%d: 0x%lx-0x%lx, IRQ%d, ",
-			j+1,(ulong)cy_pci_phys2,
-			(ulong)(cy_pci_phys2 + CyPCI_Ze_win - 1),
-			(int)cy_pci_irq);
+		if ((cy_pci_irq != 0) && (cy_pci_irq != 255))
+			printk("Cyclades-Ze/PCI #%d: 0x%lx-0x%lx, IRQ%d, ",
+				j + 1, (ulong) cy_pci_phys2,
+				(ulong) (cy_pci_phys2 + CyPCI_Ze_win - 1),
+				(int)cy_pci_irq);
@@ -5071,9 +5191,9 @@
-#endif /* CONFIG_CYZ_INTR */
-		    printk("Cyclades-Ze/PCI #%d: 0x%lx-0x%lx, ",
-			j+1,(ulong)cy_pci_phys2,
-			(ulong)(cy_pci_phys2 + CyPCI_Ze_win - 1));
-
-                printk("%d channels starting from port %d.\n",
-		    cy_pci_nchan,cy_next_channel);
-                cy_next_channel += cy_pci_nchan;
-        }
+#endif				/* CONFIG_CYZ_INTR */
+			printk("Cyclades-Ze/PCI #%d: 0x%lx-0x%lx, ",
+				j + 1, (ulong) cy_pci_phys2,
+				(ulong) (cy_pci_phys2 + CyPCI_Ze_win - 1));
+
+		printk("%d channels starting from port %d.\n",
+			cy_pci_nchan, cy_next_channel);
+		cy_next_channel += cy_pci_nchan;
+	}
@@ -5081,4 +5201,3 @@
-	    printk("Cyclades-Ze/PCI found at 0x%x ",
-		(unsigned int) Ze_phys2[0]);
-	    printk("but no more cards can be used.\n");
-            printk("Change NR_CARDS in cyclades.c and recompile kernel.\n");
+		printk("Cyclades-Ze/PCI found at 0x%x but no more cards can be "
+			"used.\nChange NR_CARDS in cyclades.c and recompile "
+			"kernel.\n", (unsigned int)Ze_phys2[0]);
@@ -5086 +5205 @@
-        return(i);
+	return i;
@@ -5088,4 +5207,3 @@
-        return(0);
-#endif /* ifdef CONFIG_PCI */
-} /* cy_detect_pci */
-
+	return 0;
+#endif				/* ifdef CONFIG_PCI */
+}				/* cy_detect_pci */
@@ -5097,2 +5215 @@
-static inline void
-show_version(void)
+static inline void show_version(void)
@@ -5100,10 +5217,3 @@
-  char *rcsvers, *rcsdate, *tmp;
-    rcsvers = strchr(rcsid, ' '); rcsvers++;
-    tmp = strchr(rcsvers, ' '); *tmp++ = '\0';
-    rcsdate = strchr(tmp, ' '); rcsdate++;
-    tmp = strrchr(rcsdate, ' '); *tmp = '\0';
-    printk("Cyclades driver %s %s\n",
-        rcsvers, rcsdate);
-    printk("        built %s %s\n",
-	__DATE__, __TIME__);
-} /* show_version */
+	printk("Cyclades driver " CY_VERSION "\n");
+	printk("        built %s %s\n", __DATE__, __TIME__);
+}				/* show_version */
@@ -5111 +5221 @@
-static int 
+static int
@@ -5113 +5223 @@
-		       int *eof, void *data)
+		int *eof, void *data)
@@ -5115,32 +5225,12 @@
-    struct cyclades_port  *info;
-    int i;
-    int len=0;
-    off_t begin=0;
-    off_t pos=0;
-    int size;
-    __u32 cur_jifs = jiffies;
-
-    size = sprintf(buf, "Dev TimeOpen   BytesOut  IdleOut    BytesIn   IdleIn  Overruns  Ldisc\n");
-
-    pos += size;
-    len += size;
-
-    /* Output one line for each known port */
-    for (i = 0; i < NR_PORTS && cy_port[i].line >= 0; i++) {
-	info = &cy_port[i];
-
-	if (info->count)
-	    size = sprintf(buf+len,
-			"%3d %8lu %10lu %8lu %10lu %8lu %9lu %6ld\n",
-			info->line,
-			JIFFIES_DIFF(info->idle_stats.in_use, cur_jifs) / HZ,
-			info->idle_stats.xmit_bytes,
-			JIFFIES_DIFF(info->idle_stats.xmit_idle, cur_jifs) / HZ,
-			info->idle_stats.recv_bytes,
-			JIFFIES_DIFF(info->idle_stats.recv_idle, cur_jifs) / HZ,
-			info->idle_stats.overruns,
-			(long) info->tty->ldisc.num);
-	else
-	    size = sprintf(buf+len,
-			"%3d %8lu %10lu %8lu %10lu %8lu %9lu %6ld\n",
-			info->line, 0L, 0L, 0L, 0L, 0L, 0L, 0L);
+	struct cyclades_port *info;
+	int i;
+	int len = 0;
+	off_t begin = 0;
+	off_t pos = 0;
+	int size;
+	__u32 cur_jifs = jiffies;
+
+	size = sprintf(buf, "Dev TimeOpen   BytesOut  IdleOut    BytesIn   "
+			"IdleIn  Overruns  Ldisc\n");
+
+	pos += size;
@@ -5148 +5237,0 @@
-	pos = begin + len;
@@ -5150,8 +5239,29 @@
-	if (pos < offset) {
-	    len   = 0;
-	    begin = pos;
-	}
-	if (pos > offset + length)
-	    goto done;
-    }
-    *eof = 1;
+	/* Output one line for each known port */
+	for (i = 0; i < NR_PORTS && cy_port[i].line >= 0; i++) {
+		info = &cy_port[i];
+
+		if (info->count)
+			size = sprintf(buf + len, "%3d %8lu %10lu %8lu %10lu "
+				"%8lu %9lu %6ld\n", info->line,
+				(cur_jifs - info->idle_stats.in_use) / HZ,
+				info->idle_stats.xmit_bytes,
+				(cur_jifs - info->idle_stats.xmit_idle) / HZ,
+				info->idle_stats.recv_bytes,
+				(cur_jifs - info->idle_stats.recv_idle) / HZ,
+				info->idle_stats.overruns,
+				(long)info->tty->ldisc.num);
+		else
+			size = sprintf(buf + len, "%3d %8lu %10lu %8lu %10lu "
+				"%8lu %9lu %6ld\n",
+				info->line, 0L, 0L, 0L, 0L, 0L, 0L, 0L);
+		len += size;
+		pos = begin + len;
+
+		if (pos < offset) {
+			len = 0;
+			begin = pos;
+		}
+		if (pos > offset + length)
+			goto done;
+	}
+	*eof = 1;
@@ -5159,7 +5269,7 @@
-    *start = buf + (offset - begin);	/* Start of wanted data */
-    len -= (offset - begin);		/* Start slop */
-    if (len > length)
-	len = length;			/* Ending slop */
-    if (len < 0)
-	len = 0;
-    return len;
+	*start = buf + (offset - begin);	/* Start of wanted data */
+	len -= (offset - begin);	/* Start slop */
+	if (len > length)
+		len = length;	/* Ending slop */
+	if (len < 0)
+		len = 0;
+	return len;
@@ -5187,20 +5297,20 @@
-    .open = cy_open,
-    .close = cy_close,
-    .write = cy_write,
-    .put_char = cy_put_char,
-    .flush_chars = cy_flush_chars,
-    .write_room = cy_write_room,
-    .chars_in_buffer = cy_chars_in_buffer,
-    .flush_buffer = cy_flush_buffer,
-    .ioctl = cy_ioctl,
-    .throttle = cy_throttle,
-    .unthrottle = cy_unthrottle,
-    .set_termios = cy_set_termios,
-    .stop = cy_stop,
-    .start = cy_start,
-    .hangup = cy_hangup,
-    .break_ctl = cy_break,
-    .wait_until_sent = cy_wait_until_sent,
-    .read_proc = cyclades_get_proc_info,
-    .tiocmget = cy_tiocmget,
-    .tiocmset = cy_tiocmset,
+	.open = cy_open,
+	.close = cy_close,
+	.write = cy_write,
+	.put_char = cy_put_char,
+	.flush_chars = cy_flush_chars,
+	.write_room = cy_write_room,
+	.chars_in_buffer = cy_chars_in_buffer,
+	.flush_buffer = cy_flush_buffer,
+	.ioctl = cy_ioctl,
+	.throttle = cy_throttle,
+	.unthrottle = cy_unthrottle,
+	.set_termios = cy_set_termios,
+	.stop = cy_stop,
+	.start = cy_start,
+	.hangup = cy_hangup,
+	.break_ctl = cy_break,
+	.wait_until_sent = cy_wait_until_sent,
+	.read_proc = cyclades_get_proc_info,
+	.tiocmget = cy_tiocmget,
+	.tiocmset = cy_tiocmset,
@@ -5209,2 +5319 @@
-static int __init
-cy_init(void)
+static int __init cy_init(void)
@@ -5212,133 +5321,133 @@
-  struct cyclades_port  *info;
-  struct cyclades_card *cinfo;
-  int number_z_boards = 0;
-  int board,port,i,index;
-  unsigned long mailbox;
-  unsigned short chip_number;
-  int nports;
-
-    cy_serial_driver = alloc_tty_driver(NR_PORTS);
-    if (!cy_serial_driver)
-	return -ENOMEM;
-    show_version();
-
-    /* Initialize the tty_driver structure */
-    
-    cy_serial_driver->owner = THIS_MODULE;
-    cy_serial_driver->driver_name = "cyclades";
-    cy_serial_driver->name = "ttyC";
-    cy_serial_driver->major = CYCLADES_MAJOR;
-    cy_serial_driver->minor_start = 0;
-    cy_serial_driver->type = TTY_DRIVER_TYPE_SERIAL;
-    cy_serial_driver->subtype = SERIAL_TYPE_NORMAL;
-    cy_serial_driver->init_termios = tty_std_termios;
-    cy_serial_driver->init_termios.c_cflag =
-            B9600 | CS8 | CREAD | HUPCL | CLOCAL;
-    cy_serial_driver->flags = TTY_DRIVER_REAL_RAW;
-    tty_set_operations(cy_serial_driver, &cy_ops);
-
-    if (tty_register_driver(cy_serial_driver))
-            panic("Couldn't register Cyclades serial driver\n");
-
-    for (i = 0; i < NR_CARDS; i++) {
-            /* base_addr=0 indicates board not found */
-            cy_card[i].base_addr = NULL;
-    }
-
-    /* the code below is responsible to find the boards. Each different
-       type of board has its own detection routine. If a board is found,
-       the next cy_card structure available is set by the detection
-       routine. These functions are responsible for checking the
-       availability of cy_card and cy_port data structures and updating
-       the cy_next_channel. */
-
-    /* look for isa boards */
-    cy_isa_nboard = cy_detect_isa();
-
-    /* look for pci boards */
-    cy_pci_nboard = cy_detect_pci();
-
-    cy_nboard = cy_isa_nboard + cy_pci_nboard;
-
-    /* invalidate remaining cy_card structures */
-    for (i = 0 ; i < NR_CARDS ; i++) {
-        if (cy_card[i].base_addr == 0) {
-                cy_card[i].first_line = -1;
-                cy_card[i].ctl_addr = NULL;
-                cy_card[i].irq = 0;
-                cy_card[i].bus_index = 0;
-                cy_card[i].first_line = 0;
-                cy_card[i].num_chips = 0;
-        }
-    }
-    /* invalidate remaining cy_port structures */
-    for (i = cy_next_channel ; i < NR_PORTS ; i++) {
-        cy_port[i].line = -1;
-        cy_port[i].magic = -1;
-    }
-
-    /* initialize per-port data structures for each valid board found */
-    for (board = 0 ; board < cy_nboard ; board++) {
-            cinfo = &cy_card[board];
-            if (cinfo->num_chips == -1) { /* Cyclades-Z */
-		number_z_boards++;
-		mailbox = cy_readl(&((struct RUNTIME_9060 __iomem *)
-			     cy_card[board].ctl_addr)->mail_box_0);
-		nports = (mailbox == ZE_V1) ? ZE_V1_NPORTS : 8;
-		cinfo->intr_enabled = 0;
-		cinfo->nports = 0; /* Will be correctly set later, after 
-				      Z FW is loaded */
-		spin_lock_init(&cinfo->card_lock);
-                for (port = cinfo->first_line ;
-                     port < cinfo->first_line + nports;
-                     port++)
-                {
-                    info = &cy_port[port];
-                    info->magic = CYCLADES_MAGIC;
-                    info->type = PORT_STARTECH;
-                    info->card = board;
-                    info->line = port;
-		    info->chip_rev = 0;
-                    info->flags = STD_COM_FLAGS;
-                    info->tty = NULL;
-		    if (mailbox == ZO_V1)
-			info->xmit_fifo_size = CYZ_FIFO_SIZE;
-		    else
-			info->xmit_fifo_size = 4 * CYZ_FIFO_SIZE;
-                    info->cor1 = 0;
-                    info->cor2 = 0;
-                    info->cor3 = 0;
-                    info->cor4 = 0;
-                    info->cor5 = 0;
-                    info->tbpr = 0;
-                    info->tco = 0;
-                    info->rbpr = 0;
-                    info->rco = 0;
-		    info->custom_divisor = 0;
-                    info->close_delay = 5*HZ/10;
-		    info->closing_wait = CLOSING_WAIT_DELAY;
-		    info->icount.cts = info->icount.dsr = 
-			info->icount.rng = info->icount.dcd = 0;
-		    info->icount.rx = info->icount.tx = 0;
-		    info->icount.frame = info->icount.parity = 0;
-		    info->icount.overrun = info->icount.brk = 0;
-                    info->x_char = 0;
-                    info->event = 0;
-                    info->count = 0;
-                    info->blocked_open = 0;
-                    info->default_threshold = 0;
-                    info->default_timeout = 0;
-		    INIT_WORK(&info->tqueue, do_softint, info);
-		    init_waitqueue_head(&info->open_wait);
-		    init_waitqueue_head(&info->close_wait);
-		    init_waitqueue_head(&info->shutdown_wait);
-		    init_waitqueue_head(&info->delta_msr_wait);
-                    /* info->session */
-                    /* info->pgrp */
-                    info->read_status_mask = 0;
-                    /* info->timeout */
-		    /* Bentson's vars */
-                    info->jiffies[0] = 0;
-                    info->jiffies[1] = 0;
-                    info->jiffies[2] = 0;
-                    info->rflush_count = 0;
+	struct cyclades_port *info;
+	struct cyclades_card *cinfo;
+	int number_z_boards = 0;
+	int board, port, i, index;
+	unsigned long mailbox;
+	unsigned short chip_number;
+	int nports;
+
+	cy_serial_driver = alloc_tty_driver(NR_PORTS);
+	if (!cy_serial_driver)
+		return -ENOMEM;
+	show_version();
+
+	/* Initialize the tty_driver structure */
+
+	cy_serial_driver->owner = THIS_MODULE;
+	cy_serial_driver->driver_name = "cyclades";
+	cy_serial_driver->name = "ttyC";
+	cy_serial_driver->major = CYCLADES_MAJOR;
+	cy_serial_driver->minor_start = 0;
+	cy_serial_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	cy_serial_driver->subtype = SERIAL_TYPE_NORMAL;
+	cy_serial_driver->init_termios = tty_std_termios;
+	cy_serial_driver->init_termios.c_cflag =
+	    B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	cy_serial_driver->flags = TTY_DRIVER_REAL_RAW;
+	tty_set_operations(cy_serial_driver, &cy_ops);
+
+	if (tty_register_driver(cy_serial_driver))
+		panic("Couldn't register Cyclades serial driver\n");
+
+	for (i = 0; i < NR_CARDS; i++) {
+		/* base_addr=0 indicates board not found */
+		cy_card[i].base_addr = NULL;
+	}
+
+	/* the code below is responsible to find the boards. Each different
+	   type of board has its own detection routine. If a board is found,
+	   the next cy_card structure available is set by the detection
+	   routine. These functions are responsible for checking the
+	   availability of cy_card and cy_port data structures and updating
+	   the cy_next_channel. */
+
+	/* look for isa boards */
+	cy_isa_nboard = cy_detect_isa();
+
+	/* look for pci boards */
+	cy_pci_nboard = cy_detect_pci();
+
+	cy_nboard = cy_isa_nboard + cy_pci_nboard;
+
+	/* invalidate remaining cy_card structures */
+	for (i = 0; i < NR_CARDS; i++) {
+		if (cy_card[i].base_addr == 0) {
+			cy_card[i].first_line = -1;
+			cy_card[i].ctl_addr = NULL;
+			cy_card[i].irq = 0;
+			cy_card[i].bus_index = 0;
+			cy_card[i].first_line = 0;
+			cy_card[i].num_chips = 0;
+		}
+	}
+	/* invalidate remaining cy_port structures */
+	for (i = cy_next_channel; i < NR_PORTS; i++) {
+		cy_port[i].line = -1;
+		cy_port[i].magic = -1;
+	}
+
+	/* initialize per-port data structures for each valid board found */
+	for (board = 0; board < cy_nboard; board++) {
+		cinfo = &cy_card[board];
+		if (cinfo->num_chips == -1) {	/* Cyclades-Z */
+			number_z_boards++;
+			mailbox = cy_readl(&((struct RUNTIME_9060 __iomem *)
+					     cy_card[board].ctl_addr)->
+					   mail_box_0);
+			nports = (mailbox == ZE_V1) ? ZE_V1_NPORTS : 8;
+			cinfo->intr_enabled = 0;
+			cinfo->nports = 0;	/* Will be correctly set later, after 
+						   Z FW is loaded */
+			spin_lock_init(&cinfo->card_lock);
+			for (port = cinfo->first_line;
+			     port < cinfo->first_line + nports; port++) {
+				info = &cy_port[port];
+				info->magic = CYCLADES_MAGIC;
+				info->type = PORT_STARTECH;
+				info->card = board;
+				info->line = port;
+				info->chip_rev = 0;
+				info->flags = STD_COM_FLAGS;
+				info->tty = NULL;
+				if (mailbox == ZO_V1)
+					info->xmit_fifo_size = CYZ_FIFO_SIZE;
+				else
+					info->xmit_fifo_size =
+					    4 * CYZ_FIFO_SIZE;
+				info->cor1 = 0;
+				info->cor2 = 0;
+				info->cor3 = 0;
+				info->cor4 = 0;
+				info->cor5 = 0;
+				info->tbpr = 0;
+				info->tco = 0;
+				info->rbpr = 0;
+				info->rco = 0;
+				info->custom_divisor = 0;
+				info->close_delay = 5 * HZ / 10;
+				info->closing_wait = CLOSING_WAIT_DELAY;
+				info->icount.cts = info->icount.dsr =
+				    info->icount.rng = info->icount.dcd = 0;
+				info->icount.rx = info->icount.tx = 0;
+				info->icount.frame = info->icount.parity = 0;
+				info->icount.overrun = info->icount.brk = 0;
+				info->x_char = 0;
+				info->event = 0;
+				info->count = 0;
+				info->blocked_open = 0;
+				info->default_threshold = 0;
+				info->default_timeout = 0;
+				INIT_WORK(&info->tqueue, do_softint);
+				init_waitqueue_head(&info->open_wait);
+				init_waitqueue_head(&info->close_wait);
+				init_waitqueue_head(&info->shutdown_wait);
+				init_waitqueue_head(&info->delta_msr_wait);
+				/* info->session */
+				/* info->pgrp */
+				info->read_status_mask = 0;
+				/* info->timeout */
+				/* Bentson's vars */
+				info->jiffies[0] = 0;
+				info->jiffies[1] = 0;
+				info->jiffies[2] = 0;
+				info->rflush_count = 0;
@@ -5346,2 +5455,2 @@
-		    init_timer(&cyz_rx_full_timer[port]);
-		    cyz_rx_full_timer[port].function = NULL;
+				init_timer(&cyz_rx_full_timer[port]);
+				cyz_rx_full_timer[port].function = NULL;
@@ -5349,71 +5458,71 @@
-                }
-                continue;
-            }else{ /* Cyclom-Y of some kind*/
-                index = cinfo->bus_index;
-		spin_lock_init(&cinfo->card_lock);
-		cinfo->nports = CyPORTS_PER_CHIP * cinfo->num_chips;
-                for (port = cinfo->first_line ;
-                     port < cinfo->first_line + cinfo->nports ;
-                     port++)
-                {
-                    info = &cy_port[port];
-                    info->magic = CYCLADES_MAGIC;
-                    info->type = PORT_CIRRUS;
-                    info->card = board;
-                    info->line = port;
-                    info->flags = STD_COM_FLAGS;
-                    info->tty = NULL;
-                    info->xmit_fifo_size = CyMAX_CHAR_FIFO;
-                    info->cor1 = CyPARITY_NONE|Cy_1_STOP|Cy_8_BITS;
-                    info->cor2 = CyETC;
-                    info->cor3 = 0x08; /* _very_ small rcv threshold */
-                    info->cor4 = 0;
-                    info->cor5 = 0;
-		    info->custom_divisor = 0;
-                    info->close_delay = 5*HZ/10;
-		    info->closing_wait = CLOSING_WAIT_DELAY;
-		    info->icount.cts = info->icount.dsr = 
-			info->icount.rng = info->icount.dcd = 0;
-		    info->icount.rx = info->icount.tx = 0;
-		    info->icount.frame = info->icount.parity = 0;
-		    info->icount.overrun = info->icount.brk = 0;
-		    chip_number = (port - cinfo->first_line) / 4;
-		    if ((info->chip_rev =
-			 cy_readb(cinfo->base_addr +
-				  (cy_chip_offset[chip_number]<<index) +
-				  (CyGFRCR<<index))) >= CD1400_REV_J) {
-                        /* It is a CD1400 rev. J or later */
-                        info->tbpr = baud_bpr_60[13]; /* Tx BPR */
-                        info->tco = baud_co_60[13]; /* Tx CO */
-                        info->rbpr = baud_bpr_60[13]; /* Rx BPR */
-                        info->rco = baud_co_60[13]; /* Rx CO */
-                        info->rflow = 0;
-                        info->rtsdtr_inv = 1;
-                    } else {
-                        info->tbpr = baud_bpr_25[13]; /* Tx BPR */
-                        info->tco = baud_co_25[13]; /* Tx CO */
-                        info->rbpr = baud_bpr_25[13]; /* Rx BPR */
-                        info->rco = baud_co_25[13]; /* Rx CO */
-                        info->rflow = 0;
-                        info->rtsdtr_inv = 0;
-                    }
-                    info->x_char = 0;
-                    info->event = 0;
-                    info->count = 0;
-                    info->blocked_open = 0;
-                    info->default_threshold = 0;
-                    info->default_timeout = 0;
-		    INIT_WORK(&info->tqueue, do_softint, info);
-		    init_waitqueue_head(&info->open_wait);
-		    init_waitqueue_head(&info->close_wait);
-		    init_waitqueue_head(&info->shutdown_wait);
-		    init_waitqueue_head(&info->delta_msr_wait);
-                    /* info->session */
-                    /* info->pgrp */
-                    info->read_status_mask =
-		                  CyTIMEOUT| CySPECHAR| CyBREAK
-                                  | CyPARITY| CyFRAME| CyOVERRUN;
-                    /* info->timeout */
-                }
-            }
-    }
+			}
+			continue;
+		} else {	/* Cyclom-Y of some kind */
+			index = cinfo->bus_index;
+			spin_lock_init(&cinfo->card_lock);
+			cinfo->nports = CyPORTS_PER_CHIP * cinfo->num_chips;
+			for (port = cinfo->first_line;
+			     port < cinfo->first_line + cinfo->nports; port++) {
+				info = &cy_port[port];
+				info->magic = CYCLADES_MAGIC;
+				info->type = PORT_CIRRUS;
+				info->card = board;
+				info->line = port;
+				info->flags = STD_COM_FLAGS;
+				info->tty = NULL;
+				info->xmit_fifo_size = CyMAX_CHAR_FIFO;
+				info->cor1 =
+				    CyPARITY_NONE | Cy_1_STOP | Cy_8_BITS;
+				info->cor2 = CyETC;
+				info->cor3 = 0x08;	/* _very_ small rcv threshold */
+				info->cor4 = 0;
+				info->cor5 = 0;
+				info->custom_divisor = 0;
+				info->close_delay = 5 * HZ / 10;
+				info->closing_wait = CLOSING_WAIT_DELAY;
+				info->icount.cts = info->icount.dsr =
+				    info->icount.rng = info->icount.dcd = 0;
+				info->icount.rx = info->icount.tx = 0;
+				info->icount.frame = info->icount.parity = 0;
+				info->icount.overrun = info->icount.brk = 0;
+				chip_number = (port - cinfo->first_line) / 4;
+				if ((info->chip_rev =
+				     cy_readb(cinfo->base_addr +
+					      (cy_chip_offset[chip_number] <<
+					       index) + (CyGFRCR << index))) >=
+				    CD1400_REV_J) {
+					/* It is a CD1400 rev. J or later */
+					info->tbpr = baud_bpr_60[13];	/* Tx BPR */
+					info->tco = baud_co_60[13];	/* Tx CO */
+					info->rbpr = baud_bpr_60[13];	/* Rx BPR */
+					info->rco = baud_co_60[13];	/* Rx CO */
+					info->rflow = 0;
+					info->rtsdtr_inv = 1;
+				} else {
+					info->tbpr = baud_bpr_25[13];	/* Tx BPR */
+					info->tco = baud_co_25[13];	/* Tx CO */
+					info->rbpr = baud_bpr_25[13];	/* Rx BPR */
+					info->rco = baud_co_25[13];	/* Rx CO */
+					info->rflow = 0;
+					info->rtsdtr_inv = 0;
+				}
+				info->x_char = 0;
+				info->event = 0;
+				info->count = 0;
+				info->blocked_open = 0;
+				info->default_threshold = 0;
+				info->default_timeout = 0;
+				INIT_WORK(&info->tqueue, do_softint);
+				init_waitqueue_head(&info->open_wait);
+				init_waitqueue_head(&info->close_wait);
+				init_waitqueue_head(&info->shutdown_wait);
+				init_waitqueue_head(&info->delta_msr_wait);
+				/* info->session */
+				/* info->pgrp */
+				info->read_status_mask =
+				    CyTIMEOUT | CySPECHAR | CyBREAK
+				    | CyPARITY | CyFRAME | CyOVERRUN;
+				/* info->timeout */
+			}
+		}
+	}
@@ -5422,4 +5531,4 @@
-    if (number_z_boards && !cyz_timeron){
-	cyz_timeron++;
-	cyz_timerlist.expires = jiffies + 1;
-	add_timer(&cyz_timerlist);
+	if (number_z_boards && !cyz_timeron) {
+		cyz_timeron++;
+		cyz_timerlist.expires = jiffies + 1;
+		add_timer(&cyz_timerlist);
@@ -5427 +5536 @@
-	printk("Cyclades-Z polling initialized\n");
+		printk("Cyclades-Z polling initialized\n");
@@ -5429,2 +5538,4 @@
-    }
-#endif /* CONFIG_CYZ_INTR */
+	}
+#endif				/* CONFIG_CYZ_INTR */
+
+	return 0;
@@ -5432,3 +5543 @@
-    return 0;
-    
-} /* cy_init */
+}				/* cy_init */
@@ -5436,2 +5545 @@
-static void __exit
-cy_cleanup_module(void)
+static void __exit cy_cleanup_module(void)
@@ -5439 +5547 @@
-    int i, e1;
+	int i, e1;
@@ -5442,4 +5550,4 @@
-    if (cyz_timeron){
-	cyz_timeron = 0;
-	del_timer(&cyz_timerlist);
-    }
+	if (cyz_timeron){
+		cyz_timeron = 0;
+		del_timer(&cyz_timerlist);
+	}
@@ -5448,12 +5556,12 @@
-    if ((e1 = tty_unregister_driver(cy_serial_driver)))
-            printk("cyc: failed to unregister Cyclades serial driver(%d)\n",
-		e1);
-
-    put_tty_driver(cy_serial_driver);
-
-    for (i = 0; i < NR_CARDS; i++) {
-        if (cy_card[i].base_addr) {
-	    iounmap(cy_card[i].base_addr);
-	    if (cy_card[i].ctl_addr)
-		iounmap(cy_card[i].ctl_addr);
-	    if (cy_card[i].irq
+	if ((e1 = tty_unregister_driver(cy_serial_driver)))
+		printk("cyc: failed to unregister Cyclades serial driver(%d)\n",
+			e1);
+
+	put_tty_driver(cy_serial_driver);
+
+	for (i = 0; i < NR_CARDS; i++) {
+		if (cy_card[i].base_addr) {
+			iounmap(cy_card[i].base_addr);
+			if (cy_card[i].ctl_addr)
+				iounmap(cy_card[i].ctl_addr);
+			if (cy_card[i].irq
@@ -5461 +5569 @@
-		&& cy_card[i].num_chips != -1 /* not a Z card */
+				&& cy_card[i].num_chips != -1 /* not a Z card */
@@ -5463,2 +5571,2 @@
-	    )
-		free_irq(cy_card[i].irq, &cy_card[i]);
+				)
+				free_irq(cy_card[i].irq, &cy_card[i]);
@@ -5466,2 +5574,2 @@
-		if (cy_card[i].pdev)
-			pci_release_regions(cy_card[i].pdev);
+			if (cy_card[i].pdev)
+				pci_release_regions(cy_card[i].pdev);
@@ -5469,2 +5577,2 @@
-        }
-    }
+		}
+	}
--- ./projects/linux/linux-2.6.20/drivers/char/cyclades.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/cyclades.c	2007-04-26 05:08:32.000000000 +0200
@@ -832,10 +832,10 @@
-static unsigned short cy_pci_dev_id[] = {
-	PCI_DEVICE_ID_CYCLOM_Y_Lo,	/* PCI < 1Mb */
-	PCI_DEVICE_ID_CYCLOM_Y_Hi,	/* PCI > 1Mb */
-	PCI_DEVICE_ID_CYCLOM_4Y_Lo,	/* 4Y PCI < 1Mb */
-	PCI_DEVICE_ID_CYCLOM_4Y_Hi,	/* 4Y PCI > 1Mb */
-	PCI_DEVICE_ID_CYCLOM_8Y_Lo,	/* 8Y PCI < 1Mb */
-	PCI_DEVICE_ID_CYCLOM_8Y_Hi,	/* 8Y PCI > 1Mb */
-	PCI_DEVICE_ID_CYCLOM_Z_Lo,	/* Z PCI < 1Mb */
-	PCI_DEVICE_ID_CYCLOM_Z_Hi,	/* Z PCI > 1Mb */
-	0			/* end of table */
+static struct pci_device_id cy_pci_dev_id[] __devinitdata = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_Y_Lo) },	/* PCI < 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_Y_Hi) },	/* PCI > 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_4Y_Lo) },	/* 4Y PCI < 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_4Y_Hi) },	/* 4Y PCI > 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_8Y_Lo) },	/* 8Y PCI < 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_8Y_Hi) },	/* 8Y PCI > 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_Z_Lo) },	/* Z PCI < 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_Z_Hi) },	/* Z PCI > 1Mb */
+	{ }			/* end of table */
@@ -842,0 +843 @@
+MODULE_DEVICE_TABLE(pci, cy_pci_dev_id);
@@ -3502,0 +3504 @@
+	tmp.closing_wait = info->closing_wait;
@@ -4491 +4492,0 @@
-	wake_up_interruptible(&tty->write_wait);
@@ -4762 +4763 @@
-		while ((device_id = cy_pci_dev_id[dev_index]) != 0) {
+		while ((device_id = cy_pci_dev_id[dev_index].device) != 0) {
--- ./projects/linux/linux-2.6.21/drivers/char/cyclades.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/char/cyclades.c	2007-07-09 01:32:17.000000000 +0200
@@ -13 +12,0 @@
- * Currently maintained by Cyclades team <async@cyclades.com>.
@@ -15,2 +14 @@
- * For Technical support and installation problems, please send e-mail
- * to support@cyclades.com.
+ * Copyright (C) 2007 Jiri Slaby <jirislaby@gmail.com>
@@ -21,0 +20 @@
+ * Converted to pci probing and cleaned up by Jiri Slaby.
@@ -594 +593 @@
-#define CY_VERSION	"2.4"
+#define CY_VERSION	"2.5"
@@ -627,6 +625,0 @@
-#if 0
-#define PAUSE __asm__("nop")
-#else
-#define PAUSE do {} while (0)
-#endif
-
@@ -662,11 +654,0 @@
-#define	CY_LOCK(info,flags)					\
-		do {						\
-		spin_lock_irqsave(&cy_card[info->card].card_lock, flags); \
-		} while (0)
-
-#define	CY_UNLOCK(info,flags)					\
-		do {						\
-		spin_unlock_irqrestore(&cy_card[info->card].card_lock, flags); \
-		} while (0)
-
-#include <linux/types.h>
@@ -685 +667 @@
-	((cy_readl(&((struct RUNTIME_9060 __iomem *) \
+	((readl(&((struct RUNTIME_9060 __iomem *) \
@@ -688 +670 @@
-#define ISZLOADED(card)	(((ZO_V1==cy_readl(&((struct RUNTIME_9060 __iomem *) \
+#define ISZLOADED(card)	(((ZO_V1==readl(&((struct RUNTIME_9060 __iomem *) \
@@ -691 +673 @@
-			(ZFIRM_ID==cy_readl(&((struct FIRM_ID __iomem *) \
+			(ZFIRM_ID==readl(&((struct FIRM_ID __iomem *) \
@@ -728,2 +710,2 @@
-static long maddr[NR_CARDS] = { 0, };
-static int irq[NR_CARDS] = { 0, };
+static long maddr[NR_CARDS];
+static int irq[NR_CARDS];
@@ -742,5 +723,0 @@
-/* This is the per-channel data structure containing pointers, flags
- and variables for the port. This driver supports a maximum of NR_PORTS.
-*/
-static struct cyclades_port cy_port[NR_PORTS];
-
@@ -828,3 +804,0 @@
-static unsigned short cy_pci_nboard;
-static unsigned short cy_isa_nboard;
-static unsigned short cy_nboard;
@@ -848 +822 @@
-static int cyz_issue_cmd(struct cyclades_card *, uclong, ucchar, uclong);
+static int cyz_issue_cmd(struct cyclades_card *, __u32, __u8, __u32);
@@ -861 +834,0 @@
-static int cyz_timeron = 0;
@@ -874,9 +847,2 @@
-		printk("cyc Warning: null cyclades_port for (%s) in %s\n",
-				name, routine);
-		return 1;
-	}
-
-	if ((long)info < (long)(&cy_port[0]) ||
-			(long)(&cy_port[NR_PORTS]) < (long)info) {
-		printk("cyc Warning: cyclades_port out of range for (%s) in "
-				"%s\n", name, routine);
+		printk(KERN_WARNING "cyc Warning: null cyclades_port for (%s) "
+				"in %s\n", name, routine);
@@ -887,2 +853,2 @@
-		printk("cyc Warning: bad magic number for serial struct (%s) "
-				"in %s\n", name, routine);
+		printk(KERN_WARNING "cyc Warning: bad magic number for serial "
+				"struct (%s) in %s\n", name, routine);
@@ -946,9 +912,3 @@
-	if (test_and_clear_bit(Cy_EVENT_Z_RX_FULL, &info->event)) {
-		if (cyz_rx_full_timer[info->line].function == NULL) {
-			cyz_rx_full_timer[info->line].expires = jiffies + 1;
-			cyz_rx_full_timer[info->line].function = cyz_rx_restart;
-			cyz_rx_full_timer[info->line].data =
-						(unsigned long)info;
-			add_timer(&cyz_rx_full_timer[info->line]);
-		}
-	}
+	if (test_and_clear_bit(Cy_EVENT_Z_RX_FULL, &info->event) &&
+			!timer_pending(&cyz_rx_full_timer[info->line]))
+		mod_timer(&cyz_rx_full_timer[info->line], jiffies + 1);
@@ -961 +921 @@
-		wake_up_interruptible(&info->shutdown_wait);
+		complete(&info->shutdown_wait);
@@ -978 +938 @@
-	volatile int i;
+	unsigned int i;
@@ -982 +942 @@
-		if (cy_readb(base_addr + (CyCCR << index)) == 0) {
+		if (readb(base_addr + (CyCCR << index)) == 0) {
@@ -1025 +985 @@
-		  cy_readb(address + (CySRER << index)) | CyTxRdy);
+		  readb(address + (CySRER << index)) | CyTxRdy);
@@ -1035,2 +995,2 @@
-	save_xir = (u_char) cy_readb(address + (CyTIR << index));
-	save_car = cy_readb(address + (CyCAR << index));
+	save_xir = (u_char) readb(address + (CyTIR << index));
+	save_car = readb(address + (CyCAR << index));
@@ -1039 +999 @@
-		  cy_readb(address + (CySRER << index)) & ~CyTxRdy);
+		  readb(address + (CySRER << index)) & ~CyTxRdy);
@@ -1054,2 +1014,2 @@
-	volatile int char_count;
-	int i, j, len, mdm_change, mdm_status, outch;
+	int char_count;
+	int j, len, mdm_change, mdm_status, outch;
@@ -1061 +1021 @@
-		printk("cyy_interrupt: rcvd intr, chip %d\n\r", chip);
+		printk(KERN_DEBUG "cyy_interrupt: rcvd intr, chip %d\n", chip);
@@ -1065 +1025 @@
-		save_xir = (u_char) cy_readb(base_addr + (CyRIR << index));
+		save_xir = (u_char) readb(base_addr + (CyRIR << index));
@@ -1067,4 +1027,2 @@
-		i = channel + chip * 4 + cinfo->first_line;
-		info = &cy_port[i];
-		info->last_active = jiffies;
-		save_car = cy_readb(base_addr + (CyCAR << index));
+		info = &cinfo->ports[channel + chip * 4];
+		save_car = readb(base_addr + (CyCAR << index));
@@ -1074,2 +1032,2 @@
-		if (info->tty == 0) {
-			j = (cy_readb(base_addr + (CyRIVR << index)) &
+		if (info->tty == NULL) {
+			j = (readb(base_addr + (CyRIVR << index)) &
@@ -1078 +1036 @@
-				data = cy_readb(base_addr + (CyRDSR << index));
+				data = readb(base_addr + (CyRDSR << index));
@@ -1080 +1038 @@
-				char_count = cy_readb(base_addr +
+				char_count = readb(base_addr +
@@ -1083 +1041 @@
-					data = cy_readb(base_addr +
+					data = readb(base_addr +
@@ -1089 +1047 @@
-			j = (cy_readb(base_addr + (CyRIVR << index)) &
+			j = (readb(base_addr + (CyRIVR << index)) &
@@ -1092 +1050 @@
-				data = cy_readb(base_addr + (CyRDSR << index));
+				data = readb(base_addr + (CyRDSR << index));
@@ -1105,0 +1064 @@
+					spin_unlock(&cinfo->card_lock);
@@ -1113 +1072 @@
-								cy_readb(
+								readb(
@@ -1126 +1085 @@
-								cy_readb(
+								readb(
@@ -1138 +1097 @@
-								cy_readb(
+								readb(
@@ -1157 +1116 @@
-								cy_readb(
+								readb(
@@ -1189 +1148 @@
-				char_count = cy_readb(base_addr +
+				char_count = readb(base_addr +
@@ -1201 +1160 @@
-					data = cy_readb(base_addr +
+					data = readb(base_addr +
@@ -1226 +1185 @@
-		printk("cyy_interrupt: xmit intr, chip %d\n\r", chip);
+		printk(KERN_DEBUG "cyy_interrupt: xmit intr, chip %d\n", chip);
@@ -1231 +1190 @@
-		save_xir = (u_char) cy_readb(base_addr + (CyTIR << index));
+		save_xir = (u_char) readb(base_addr + (CyTIR << index));
@@ -1233,2 +1192 @@
-		i = channel + chip * 4 + cinfo->first_line;
-		save_car = cy_readb(base_addr + (CyCAR << index));
+		save_car = readb(base_addr + (CyCAR << index));
@@ -1238 +1196 @@
-		if ((i < 0) || (NR_PORTS <= i)) {
+		if (channel + chip * 4 >= cinfo->nports) {
@@ -1240 +1198 @@
-				  cy_readb(base_addr + (CySRER << index)) &
+				  readb(base_addr + (CySRER << index)) &
@@ -1244,3 +1202,2 @@
-		info = &cy_port[i];
-		info->last_active = jiffies;
-		if (info->tty == 0) {
+		info = &cinfo->ports[channel + chip * 4];
+		if (info->tty == NULL) {
@@ -1248 +1205 @@
-				  cy_readb(base_addr + (CySRER << index)) &
+				  readb(base_addr + (CySRER << index)) &
@@ -1281 +1238 @@
-				if (cy_readb(base_addr + (CySRER << index)) &
+				if (readb(base_addr + (CySRER << index)) &
@@ -1284 +1241 @@
-						cy_readb(base_addr +
+						readb(base_addr +
@@ -1289 +1246 @@
-						(cy_readb(base_addr +
+						(readb(base_addr +
@@ -1295 +1252 @@
-			if (info->xmit_buf == 0) {
+			if (info->xmit_buf == NULL) {
@@ -1297 +1254 @@
-					cy_readb(base_addr + (CySRER << index))&
+					readb(base_addr + (CySRER << index)) &
@@ -1303 +1260 @@
-					cy_readb(base_addr + (CySRER << index))&
+					readb(base_addr + (CySRER << index)) &
@@ -1336 +1292,0 @@
-				} else {
@@ -1356 +1312 @@
-		save_xir = (u_char) cy_readb(base_addr + (CyMIR << index));
+		save_xir = (u_char) readb(base_addr + (CyMIR << index));
@@ -1358,3 +1314,2 @@
-		info = &cy_port[channel + chip * 4 + cinfo->first_line];
-		info->last_active = jiffies;
-		save_car = cy_readb(base_addr + (CyCAR << index));
+		info = &cinfo->ports[channel + chip * 4];
+		save_car = readb(base_addr + (CyCAR << index));
@@ -1363,2 +1318,2 @@
-		mdm_change = cy_readb(base_addr + (CyMISR << index));
-		mdm_status = cy_readb(base_addr + (CyMSVR1 << index));
+		mdm_change = readb(base_addr + (CyMISR << index));
+		mdm_status = readb(base_addr + (CyMSVR1 << index));
@@ -1366,3 +1321 @@
-		if (info->tty == 0) {	/* no place for data, ignore it */
-			;
-		} else {
+		if (info->tty) {
@@ -1401 +1354 @@
-							cy_readb(base_addr +
+							readb(base_addr +
@@ -1415 +1368 @@
-							cy_readb(base_addr +
+							readb(base_addr +
@@ -1422 +1375 @@
-			if (mdm_change & CyDSR) {
+/*			if (mdm_change & CyDSR) {
@@ -1425 +1378 @@
-			}
+			}*/
@@ -1441 +1394 @@
-	struct cyclades_card *cinfo;
+	struct cyclades_card *cinfo = dev_id;
@@ -1448 +1401 @@
-	if ((cinfo = (struct cyclades_card *)dev_id) == 0) {
+	if (unlikely(cinfo == NULL)) {
@@ -1450 +1403 @@
-		printk("cyy_interrupt: spurious interrupt %d\n\r", irq);
+		printk(KERN_DEBUG "cyy_interrupt: spurious interrupt %d\n",irq);
@@ -1457,0 +1411,4 @@
+	/* card was not initialized yet (e.g. DEBUG_SHIRQ) */
+	if (unlikely(card_base_addr == NULL))
+		return IRQ_HANDLED;
+
@@ -1469 +1426 @@
-			while ((status = cy_readb(base_addr +
+			while ((status = readb(base_addr +
@@ -1501 +1458 @@
-		uclong * channel, ucchar * cmd, uclong * param)
+		__u32 * channel, __u8 * cmd, __u32 * param)
@@ -1512,2 +1469 @@
-	zfw_ctrl = cinfo->base_addr + (cy_readl(&firm_id->zfwctrl_addr) &
-			0xfffff);
+	zfw_ctrl = cinfo->base_addr + (readl(&firm_id->zfwctrl_addr) & 0xfffff);
@@ -1516 +1472 @@
-	loc_doorbell = cy_readl(&((struct RUNTIME_9060 __iomem *)
+	loc_doorbell = readl(&((struct RUNTIME_9060 __iomem *)
@@ -1520,2 +1476,2 @@
-		*channel = cy_readl(&board_ctrl->fwcmd_channel);
-		*param = (uclong) cy_readl(&board_ctrl->fwcmd_param);
+		*channel = readl(&board_ctrl->fwcmd_channel);
+		*param = (__u32) readl(&board_ctrl->fwcmd_param);
@@ -1531 +1487 @@
-		uclong channel, ucchar cmd, uclong param)
+		__u32 channel, __u8 cmd, __u32 param)
@@ -1536 +1492 @@
-	unsigned long __iomem *pci_doorbell;
+	__u32 __iomem *pci_doorbell;
@@ -1543,2 +1499 @@
-	zfw_ctrl = cinfo->base_addr + (cy_readl(&firm_id->zfwctrl_addr) &
-			0xfffff);
+	zfw_ctrl = cinfo->base_addr + (readl(&firm_id->zfwctrl_addr) & 0xfffff);
@@ -1550 +1505 @@
-	while ((cy_readl(pci_doorbell) & 0xff) != 0) {
+	while ((readl(pci_doorbell) & 0xff) != 0) {
@@ -1552 +1507 @@
-			return (int)(cy_readl(pci_doorbell) & 0xff);
+			return (int)(readl(pci_doorbell) & 0xff);
@@ -1564,3 +1519,2 @@
-cyz_handle_rx(struct cyclades_port *info,
-		volatile struct CH_CTRL __iomem * ch_ctrl,
-		volatile struct BUF_CTRL __iomem * buf_ctrl)
+cyz_handle_rx(struct cyclades_port *info, struct CH_CTRL __iomem *ch_ctrl,
+		struct BUF_CTRL __iomem *buf_ctrl)
@@ -1568 +1522 @@
-	struct cyclades_card *cinfo = &cy_card[info->card];
+	struct cyclades_card *cinfo = info->card;
@@ -1570 +1524 @@
-	volatile int char_count;
+	int char_count;
@@ -1573 +1527 @@
-	int small_count;
+	unsigned char *buf;
@@ -1577 +1531 @@
-	volatile uclong rx_put, rx_get, new_rx_get, rx_bufsize, rx_bufaddr;
+	__u32 rx_put, rx_get, new_rx_get, rx_bufsize, rx_bufaddr;
@@ -1579,4 +1533,4 @@
-	rx_get = new_rx_get = cy_readl(&buf_ctrl->rx_get);
-	rx_put = cy_readl(&buf_ctrl->rx_put);
-	rx_bufsize = cy_readl(&buf_ctrl->rx_bufsize);
-	rx_bufaddr = cy_readl(&buf_ctrl->rx_bufaddr);
+	rx_get = new_rx_get = readl(&buf_ctrl->rx_get);
+	rx_put = readl(&buf_ctrl->rx_put);
+	rx_bufsize = readl(&buf_ctrl->rx_bufsize);
+	rx_bufaddr = readl(&buf_ctrl->rx_bufaddr);
@@ -1589,3 +1542,0 @@
-		info->last_active = jiffies;
-		info->jiffies[1] = jiffies;
-
@@ -1599 +1550 @@
-		if (tty == 0) {
+		if (tty == NULL) {
@@ -1609,8 +1560,5 @@
-			while (0 < (small_count = min_t(unsigned int,
-					rx_bufsize - new_rx_get,
-					min_t(unsigned int, TTY_FLIPBUF_SIZE -
-						tty->flip.count, char_count)))){
-				memcpy_fromio(tty->flip.char_buf_ptr,
-					(char *)(cinfo->base_addr + rx_bufaddr +
-						new_rx_get),
-					small_count);
+			while (1) {
+				len = tty_prepare_flip_string(tty, &buf,
+						char_count);
+				if (!len)
+					break;
@@ -1618,5 +1566,7 @@
-				tty->flip.char_buf_ptr += small_count;
-				memset(tty->flip.flag_buf_ptr, TTY_NORMAL,
-					small_count);
-				tty->flip.flag_buf_ptr += small_count;
-				new_rx_get = (new_rx_get + small_count) &
+				len = min_t(unsigned int, min(len, char_count),
+						rx_bufsize - new_rx_get);
+
+				memcpy_fromio(buf, cinfo->base_addr +
+						rx_bufaddr + new_rx_get, len);
+
+				new_rx_get = (new_rx_get + len) &
@@ -1624,4 +1574,3 @@
-				char_count -= small_count;
-				info->icount.rx += small_count;
-				info->idle_stats.recv_bytes += small_count;
-				tty->flip.count += small_count;
+				char_count -= len;
+				info->icount.rx += len;
+				info->idle_stats.recv_bytes += len;
@@ -1632 +1581 @@
-				data = cy_readb(cinfo->base_addr + rx_bufaddr +
+				data = readb(cinfo->base_addr + rx_bufaddr +
@@ -1643 +1592 @@
-			rx_put = cy_readl(&buf_ctrl->rx_put);
+			rx_put = readl(&buf_ctrl->rx_put);
@@ -1648,2 +1597 @@
-			if (char_count >= (int)cy_readl(&buf_ctrl->
-					rx_threshold)) {
+			if (char_count >= (int)readl(&buf_ctrl->rx_threshold)) {
@@ -1662,3 +1610,2 @@
-cyz_handle_tx(struct cyclades_port *info,
-		volatile struct CH_CTRL __iomem * ch_ctrl,
-		volatile struct BUF_CTRL __iomem * buf_ctrl)
+cyz_handle_tx(struct cyclades_port *info, struct CH_CTRL __iomem *ch_ctrl,
+		struct BUF_CTRL __iomem *buf_ctrl)
@@ -1666 +1613 @@
-	struct cyclades_card *cinfo = &cy_card[info->card];
+	struct cyclades_card *cinfo = info->card;
@@ -1669 +1616 @@
-	volatile int char_count;
+	int char_count;
@@ -1673 +1620 @@
-	volatile uclong tx_put, tx_get, tx_bufsize, tx_bufaddr;
+	__u32 tx_put, tx_get, tx_bufsize, tx_bufaddr;
@@ -1678,4 +1625,4 @@
-	tx_get = cy_readl(&buf_ctrl->tx_get);
-	tx_put = cy_readl(&buf_ctrl->tx_put);
-	tx_bufsize = cy_readl(&buf_ctrl->tx_bufsize);
-	tx_bufaddr = cy_readl(&buf_ctrl->tx_bufaddr);
+	tx_get = readl(&buf_ctrl->tx_get);
+	tx_put = readl(&buf_ctrl->tx_put);
+	tx_bufsize = readl(&buf_ctrl->tx_bufsize);
+	tx_bufaddr = readl(&buf_ctrl->tx_bufaddr);
@@ -1689 +1636 @@
-		if (tty == 0) {
+		if (tty == NULL)
@@ -1691 +1637,0 @@
-		}
@@ -1701,2 +1646,0 @@
-			info->last_active = jiffies;
-			info->jiffies[2] = jiffies;
@@ -1722,2 +1665,0 @@
-			info->last_active = jiffies;
-			info->jiffies[2] = jiffies;
@@ -1736,2 +1677,0 @@
-			info->last_active = jiffies;
-			info->jiffies[2] = jiffies;
@@ -1753,9 +1693,9 @@
-	static volatile struct FIRM_ID __iomem *firm_id;
-	static volatile struct ZFW_CTRL __iomem *zfw_ctrl;
-	static volatile struct BOARD_CTRL __iomem *board_ctrl;
-	static volatile struct CH_CTRL __iomem *ch_ctrl;
-	static volatile struct BUF_CTRL __iomem *buf_ctrl;
-	uclong channel;
-	ucchar cmd;
-	uclong param;
-	uclong hw_ver, fw_ver;
+	static struct FIRM_ID __iomem *firm_id;
+	static struct ZFW_CTRL __iomem *zfw_ctrl;
+	static struct BOARD_CTRL __iomem *board_ctrl;
+	static struct CH_CTRL __iomem *ch_ctrl;
+	static struct BUF_CTRL __iomem *buf_ctrl;
+	__u32 channel;
+	__u8 cmd;
+	__u32 param;
+	__u32 hw_ver, fw_ver;
@@ -1766,2 +1706 @@
-	zfw_ctrl = cinfo->base_addr + (cy_readl(&firm_id->zfwctrl_addr) &
-			0xfffff);
+	zfw_ctrl = cinfo->base_addr + (readl(&firm_id->zfwctrl_addr) & 0xfffff);
@@ -1769,2 +1708,2 @@
-	fw_ver = cy_readl(&board_ctrl->fw_version);
-	hw_ver = cy_readl(&((struct RUNTIME_9060 __iomem *)(cinfo->ctl_addr))->
+	fw_ver = readl(&board_ctrl->fw_version);
+	hw_ver = readl(&((struct RUNTIME_9060 __iomem *)(cinfo->ctl_addr))->
@@ -1776,2 +1715,2 @@
-		info = &cy_port[channel + cinfo->first_line];
-		if ((tty = info->tty) == 0) {
+		info = &cinfo->ports[channel];
+		if ((tty = info->tty) == NULL)
@@ -1779 +1718 @@
-		}
+
@@ -1804 +1743 @@
-						cy_readl(&ch_ctrl->rs_status)) &
+						readl(&ch_ctrl->rs_status)) &
@@ -1836,2 +1775,2 @@
-			printk("cyz_interrupt: rcvd intr, card %d, "
-					"port %ld\n\r", info->card, channel);
+			printk(KERN_DEBUG "cyz_interrupt: rcvd intr, card %d, "
+					"port %ld\n", info->card, channel);
@@ -1846,2 +1785,2 @@
-			printk("cyz_interrupt: xmit intr, card %d, "
-					"port %ld\n\r", info->card, channel);
+			printk(KERN_DEBUG "cyz_interrupt: xmit intr, card %d, "
+					"port %ld\n", info->card, channel);
@@ -1868 +1807 @@
-	struct cyclades_card *cinfo;
+	struct cyclades_card *cinfo = dev_id;
@@ -1870 +1809 @@
-	if ((cinfo = (struct cyclades_card *)dev_id) == 0) {
+	if (unlikely(cinfo == NULL)) {
@@ -1872 +1811 @@
-		printk("cyz_interrupt: spurious interrupt %d\n\r", irq);
+		printk(KERN_DEBUG "cyz_interrupt: spurious interrupt %d\n",irq);
@@ -1877 +1816 @@
-	if (!ISZLOADED(*cinfo)) {
+	if (unlikely(!ISZLOADED(*cinfo))) {
@@ -1879 +1818,2 @@
-		printk("cyz_interrupt: board not yet loaded (IRQ%d).\n\r", irq);
+		printk(KERN_DEBUG "cyz_interrupt: board not yet loaded "
+				"(IRQ%d).\n", irq);
@@ -1892,0 +1833 @@
+	struct cyclades_card *card = info->card;
@@ -1894,2 +1835 @@
-	int card = info->card;
-	uclong channel = (info->line) - (cy_card[card].first_line);
+	__u32 channel = info->line - card->first_line;
@@ -1898,2 +1838,2 @@
-	CY_LOCK(info, flags);
-	retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_INTBACK2, 0L);
+	spin_lock_irqsave(&card->card_lock, flags);
+	retval = cyz_issue_cmd(card, channel, C_CM_INTBACK2, 0L);
@@ -1901 +1841 @@
-		printk("cyc:cyz_rx_restart retval on ttyC%d was %x\n",
+		printk(KERN_ERR "cyc:cyz_rx_restart retval on ttyC%d was %x\n",
@@ -1904,2 +1844 @@
-	cyz_rx_full_timer[info->line].function = NULL;
-	CY_UNLOCK(info, flags);
+	spin_unlock_irqrestore(&card->card_lock, flags);
@@ -1915,5 +1854,6 @@
-	static volatile struct FIRM_ID *firm_id;
-	static volatile struct ZFW_CTRL *zfw_ctrl;
-	static volatile struct BOARD_CTRL *board_ctrl;
-	static volatile struct CH_CTRL *ch_ctrl;
-	static volatile struct BUF_CTRL *buf_ctrl;
+	static struct FIRM_ID *firm_id;
+	static struct ZFW_CTRL *zfw_ctrl;
+	static struct BOARD_CTRL *board_ctrl;
+	static struct CH_CTRL *ch_ctrl;
+	static struct BUF_CTRL *buf_ctrl;
+	unsigned long expires = jiffies + HZ;
@@ -1922 +1861,0 @@
-	cyz_timerlist.expires = jiffies + (HZ);
@@ -1933 +1872 @@
-				(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+				(readl(&firm_id->zfwctrl_addr) & 0xfffff);
@@ -1938 +1877 @@
-			cinfo->nports = (int)cy_readl(&board_ctrl->n_channel);
+			cinfo->nports = (int)readl(&board_ctrl->n_channel);
@@ -1946 +1885 @@
-			info = &cy_port[port + cinfo->first_line];
+			info = &cinfo->ports[port];
@@ -1956 +1895 @@
-		cyz_timerlist.expires = jiffies + cyz_polling_cycle;
+		expires = jiffies + cyz_polling_cycle;
@@ -1958 +1897 @@
-	add_timer(&cyz_timerlist);
+	mod_timer(&cyz_timerlist, expires);
@@ -1970,0 +1910 @@
+	struct cyclades_card *card;
@@ -1974 +1914 @@
-	int card, chip, channel, index;
+	int chip, channel, index;
@@ -1978 +1918 @@
-	channel = (info->line) - (cy_card[card].first_line);
+	channel = info->line - card->first_line;
@@ -1984 +1924 @@
-	CY_LOCK(info, flags);
+	spin_lock_irqsave(&card->card_lock, flags);
@@ -2004 +1944 @@
-	CY_UNLOCK(info, flags);
+	spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2008 +1948 @@
-	if (!IS_CYC_Z(cy_card[card])) {
+	if (!IS_CYC_Z(*card)) {
@@ -2011,3 +1951,2 @@
-		index = cy_card[card].bus_index;
-		base_addr = cy_card[card].base_addr +
-				(cy_chip_offset[chip] << index);
+		index = card->bus_index;
+		base_addr = card->base_addr + (cy_chip_offset[chip] << index);
@@ -2016,4 +1955,3 @@
-		printk("cyc startup card %d, chip %d, channel %d, "
-				"base_addr %lx\n",
-				card, chip, channel, (long)base_addr);
-		/**/
+		printk(KERN_DEBUG "cyc startup card %d, chip %d, channel %d, "
+				"base_addr %p\n",
+				card, chip, channel, base_addr);
@@ -2021 +1959 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&card->card_lock, flags);
@@ -2037,4 +1975,4 @@
-		printk("cyc:startup raising DTR\n");
-		printk("     status: 0x%x, 0x%x\n",
-			cy_readb(base_addr + (CyMSVR1 << index)),
-			cy_readb(base_addr + (CyMSVR2 << index)));
+		printk(KERN_DEBUG "cyc:startup raising DTR\n");
+		printk(KERN_DEBUG "     status: 0x%x, 0x%x\n",
+			readb(base_addr + (CyMSVR1 << index)),
+			readb(base_addr + (CyMSVR2 << index)));
@@ -2044 +1982 @@
-			cy_readb(base_addr + (CySRER << index)) | CyRxData);
+			readb(base_addr + (CySRER << index)) | CyRxData);
@@ -2057 +1995 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2066 +2004 @@
-		base_addr = cy_card[card].base_addr;
+		base_addr = card->base_addr;
@@ -2069 +2007 @@
-		if (!ISZLOADED(cy_card[card])) {
+		if (!ISZLOADED(*card)) {
@@ -2073,2 +2011,2 @@
-		zfw_ctrl = cy_card[card].base_addr +
-				(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		zfw_ctrl = card->base_addr +
+				(readl(&firm_id->zfwctrl_addr) & 0xfffff);
@@ -2079,3 +2017,2 @@
-		printk("cyc startup Z card %d, channel %d, base_addr %lx\n",
-			card, channel, (long)base_addr);
-		/**/
+		printk(KERN_DEBUG "cyc startup Z card %d, channel %d, "
+			"base_addr %p\n", card, channel, base_addr);
@@ -2083 +2020 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&card->card_lock, flags);
@@ -2105 +2042 @@
-		retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_IOCTL, 0L);
+		retval = cyz_issue_cmd(card, channel, C_CM_IOCTL, 0L);
@@ -2107,2 +2044,2 @@
-			printk("cyc:startup(1) retval on ttyC%d was %x\n",
-				info->line, retval);
+			printk(KERN_ERR "cyc:startup(1) retval on ttyC%d was "
+				"%x\n", info->line, retval);
@@ -2112,2 +2049 @@
-		retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_FLUSH_RX,
-				0L);
+		retval = cyz_issue_cmd(card, channel, C_CM_FLUSH_RX, 0L);
@@ -2115,2 +2051,2 @@
-			printk("cyc:startup(2) retval on ttyC%d was %x\n",
-				info->line, retval);
+			printk(KERN_ERR "cyc:startup(2) retval on ttyC%d was "
+				"%x\n", info->line, retval);
@@ -2122 +2058 @@
-			cy_readl(&ch_ctrl[channel].rs_control) | C_RS_RTS |
+			readl(&ch_ctrl[channel].rs_control) | C_RS_RTS |
@@ -2124,2 +2060 @@
-		retval = cyz_issue_cmd(&cy_card[info->card], channel,
-				C_CM_IOCTLM, 0L);
+		retval = cyz_issue_cmd(card, channel, C_CM_IOCTLM, 0L);
@@ -2127,2 +2062,2 @@
-			printk("cyc:startup(3) retval on ttyC%d was %x\n",
-				info->line, retval);
+			printk(KERN_ERR "cyc:startup(3) retval on ttyC%d was "
+				"%x\n", info->line, retval);
@@ -2131 +2066 @@
-		printk("cyc:startup raising Z DTR\n");
+		printk(KERN_DEBUG "cyc:startup raising Z DTR\n");
@@ -2147 +2082 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2151 +2086 @@
-	printk(" cyc startup done\n");
+	printk(KERN_DEBUG "cyc startup done\n");
@@ -2156 +2091 @@
-	CY_UNLOCK(info, flags);
+	spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2161,0 +2097 @@
+	struct cyclades_card *card;
@@ -2164 +2100 @@
-	int card, chip, channel, index;
+	int chip, channel, index;
@@ -2167,2 +2103,2 @@
-	channel = (info->line) - (cy_card[card].first_line);
-	if (!IS_CYC_Z(cy_card[card])) {
+	channel = info->line - card->first_line;
+	if (!IS_CYC_Z(*card)) {
@@ -2171,3 +2107,2 @@
-		index = cy_card[card].bus_index;
-		base_addr = cy_card[card].base_addr +
-				(cy_chip_offset[chip] << index);
+		index = card->bus_index;
+		base_addr = card->base_addr + (cy_chip_offset[chip] << index);
@@ -2175 +2110 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&card->card_lock, flags);
@@ -2178,2 +2113,2 @@
-			cy_readb(base_addr + (CySRER << index)) | CyTxRdy);
-		CY_UNLOCK(info, flags);
+			readb(base_addr + (CySRER << index)) | CyTxRdy);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2184,3 +2119,2 @@
-		CY_LOCK(info, flags);
-		retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_INTBACK,
-				0L);
+		spin_lock_irqsave(&card->card_lock, flags);
+		retval = cyz_issue_cmd(card, channel, C_CM_INTBACK, 0L);
@@ -2188,2 +2122,2 @@
-			printk("cyc:start_xmit retval on ttyC%d was %x\n",
-				info->line, retval);
+			printk(KERN_ERR "cyc:start_xmit retval on ttyC%d was "
+				"%x\n", info->line, retval);
@@ -2191 +2125 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2203,0 +2138 @@
+	struct cyclades_card *card;
@@ -2206 +2141 @@
-	int card, chip, channel, index;
+	int chip, channel, index;
@@ -2213,2 +2148,2 @@
-	channel = info->line - cy_card[card].first_line;
-	if (!IS_CYC_Z(cy_card[card])) {
+	channel = info->line - card->first_line;
+	if (!IS_CYC_Z(*card)) {
@@ -2217,3 +2152,2 @@
-		index = cy_card[card].bus_index;
-		base_addr = cy_card[card].base_addr +
-				(cy_chip_offset[chip] << index);
+		index = card->bus_index;
+		base_addr = card->base_addr + (cy_chip_offset[chip] << index);
@@ -2222,3 +2156,3 @@
-		printk("cyc shutdown Y card %d, chip %d, channel %d, "
-				"base_addr %lx\n",
-				card, chip, channel, (long)base_addr);
+		printk(KERN_DEBUG "cyc shutdown Y card %d, chip %d, "
+				"channel %d, base_addr %p\n",
+				card, chip, channel, base_addr);
@@ -2227 +2161 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&card->card_lock, flags);
@@ -2243,4 +2177,4 @@
-			printk("cyc shutdown dropping DTR\n");
-			printk("     status: 0x%x, 0x%x\n",
-				cy_readb(base_addr + (CyMSVR1 << index)),
-				cy_readb(base_addr + (CyMSVR2 << index)));
+			printk(KERN_DEBUG "cyc shutdown dropping DTR\n");
+			printk(KERN_DEBUG "     status: 0x%x, 0x%x\n",
+				readb(base_addr + (CyMSVR1 << index)),
+				readb(base_addr + (CyMSVR2 << index)));
@@ -2257 +2191 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2265 +2199 @@
-		base_addr = cy_card[card].base_addr;
+		base_addr = card->base_addr;
@@ -2267,2 +2201,2 @@
-		printk("cyc shutdown Z card %d, channel %d, base_addr %lx\n",
-			card, channel, (long)base_addr);
+		printk(KERN_DEBUG "cyc shutdown Z card %d, channel %d, "
+			"base_addr %p\n", card, channel, base_addr);
@@ -2272 +2206 @@
-		if (!ISZLOADED(cy_card[card])) {
+		if (!ISZLOADED(*card)) {
@@ -2276,2 +2210,2 @@
-		zfw_ctrl = cy_card[card].base_addr +
-				(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		zfw_ctrl = card->base_addr +
+				(readl(&firm_id->zfwctrl_addr) & 0xfffff);
@@ -2281 +2215 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&card->card_lock, flags);
@@ -2292 +2226 @@
-				(uclong)(cy_readl(&ch_ctrl[channel].rs_control)&
+				(__u32)(readl(&ch_ctrl[channel].rs_control) &
@@ -2294 +2228 @@
-			retval = cyz_issue_cmd(&cy_card[info->card], channel,
+			retval = cyz_issue_cmd(info->card, channel,
@@ -2297,2 +2231,2 @@
-				printk("cyc:shutdown retval on ttyC%d was %x\n",
-					info->line, retval);
+				printk(KERN_ERR"cyc:shutdown retval on ttyC%d "
+					"was %x\n", info->line, retval);
@@ -2301 +2235 @@
-			printk("cyc:shutdown dropping Z DTR\n");
+			printk(KERN_DEBUG "cyc:shutdown dropping Z DTR\n");
@@ -2310 +2244 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2314 +2248 @@
-	printk(" cyc shutdown done\n");
+	printk(KERN_DEBUG "cyc shutdown done\n");
@@ -2335 +2269 @@
-	cinfo = &cy_card[info->card];
+	cinfo = info->card;
@@ -2343,3 +2277,2 @@
-		if (info->flags & ASYNC_CLOSING) {
-			interruptible_sleep_on(&info->close_wait);
-		}
+		wait_event_interruptible(info->close_wait,
+				!(info->flags & ASYNC_CLOSING));
@@ -2368,3 +2301,2 @@
-	printk("cyc block_til_ready before block: ttyC%d, count = %d\n",
-		info->line, info->count);
-	/**/
+	printk(KERN_DEBUG "cyc block_til_ready before block: ttyC%d, "
+		"count = %d\n", info->line, info->count);
@@ -2372 +2304 @@
-	CY_LOCK(info, flags);
+	spin_lock_irqsave(&cinfo->card_lock, flags);
@@ -2375 +2307 @@
-	CY_UNLOCK(info, flags);
+	spin_unlock_irqrestore(&cinfo->card_lock, flags);
@@ -2377,2 +2309,2 @@
-	printk("cyc block_til_ready: (%d): decrementing count to %d\n",
-		current->pid, info->count);
+	printk(KERN_DEBUG "cyc block_til_ready: (%d): decrementing count to "
+		"%d\n", current->pid, info->count);
@@ -2389 +2321 @@
-			CY_LOCK(info, flags);
+			spin_lock_irqsave(&cinfo->card_lock, flags);
@@ -2398,6 +2330,5 @@
-				printk("cyc:block_til_ready raising DTR\n");
-				printk("     status: 0x%x, 0x%x\n",
-					cy_readb(base_addr +
-						(CyMSVR1 << index)),
-					cy_readb(base_addr +
-						(CyMSVR2 << index)));
+				printk(KERN_DEBUG "cyc:block_til_ready raising "
+					"DTR\n");
+				printk(KERN_DEBUG "     status: 0x%x, 0x%x\n",
+					readb(base_addr + (CyMSVR1 << index)),
+					readb(base_addr + (CyMSVR2 << index)));
@@ -2406 +2337 @@
-			CY_UNLOCK(info, flags);
+			spin_unlock_irqrestore(&cinfo->card_lock, flags);
@@ -2416 +2347 @@
-			CY_LOCK(info, flags);
+			spin_lock_irqsave(&cinfo->card_lock, flags);
@@ -2420 +2351 @@
-					(cy_readb(base_addr +
+					(readb(base_addr +
@@ -2422 +2353 @@
-				CY_UNLOCK(info, flags);
+				spin_unlock_irqrestore(&cinfo->card_lock, flags);
@@ -2425 +2356 @@
-			CY_UNLOCK(info, flags);
+			spin_unlock_irqrestore(&cinfo->card_lock, flags);
@@ -2432,4 +2363,3 @@
-			printk("cyc block_til_ready blocking: ttyC%d, "
-					"count = %d\n",
-					info->line, info->count);
-			/**/
+			printk(KERN_DEBUG "cyc block_til_ready blocking: "
+				"ttyC%d, count = %d\n",
+				info->line, info->count);
@@ -2449 +2379 @@
-			current->state = TASK_RUNNING;
+			__set_current_state(TASK_RUNNING);
@@ -2454,2 +2384 @@
-		zfw_ctrl = base_addr + (cy_readl(&firm_id->zfwctrl_addr) &
-				0xfffff);
+		zfw_ctrl = base_addr + (readl(&firm_id->zfwctrl_addr)& 0xfffff);
@@ -2462,5 +2391,4 @@
-					  cy_readl(&ch_ctrl[channel].
-						   rs_control) | (C_RS_RTS |
-								  C_RS_DTR));
-				retval = cyz_issue_cmd(&cy_card[info->card],
-						channel, C_CM_IOCTLM, 0L);
+					readl(&ch_ctrl[channel].rs_control) |
+					C_RS_RTS | C_RS_DTR);
+				retval = cyz_issue_cmd(cinfo,
+					channel, C_CM_IOCTLM, 0L);
@@ -2468,2 +2396,2 @@
-					printk("cyc:block_til_ready retval on "
-						"ttyC%d was %x\n",
+					printk(KERN_ERR "cyc:block_til_ready "
+						"retval on ttyC%d was %x\n",
@@ -2473 +2401,2 @@
-				printk("cyc:block_til_ready raising Z DTR\n");
+				printk(KERN_DEBUG "cyc:block_til_ready raising "
+					"Z DTR\n");
@@ -2485 +2414 @@
-					(cy_readl(&ch_ctrl[channel].rs_status) &
+					(readl(&ch_ctrl[channel].rs_status) &
@@ -2494,4 +2423,3 @@
-			printk("cyc block_til_ready blocking: ttyC%d, "
-					"count = %d\n",
-					info->line, info->count);
-			/**/
+			printk(KERN_DEBUG "cyc block_til_ready blocking: "
+				"ttyC%d, count = %d\n",
+				info->line, info->count);
@@ -2502 +2430 @@
-	current->state = TASK_RUNNING;
+	__set_current_state(TASK_RUNNING);
@@ -2507,2 +2435,2 @@
-		printk("cyc:block_til_ready (%d): incrementing count to %d\n",
-			current->pid, info->count);
+		printk(KERN_DEBUG "cyc:block_til_ready (%d): incrementing "
+			"count to %d\n", current->pid, info->count);
@@ -2513,3 +2441,2 @@
-	printk("cyc:block_til_ready after blocking: ttyC%d, count = %d\n",
-		info->line, info->count);
-	/**/
+	printk(KERN_DEBUG "cyc:block_til_ready after blocking: ttyC%d, "
+		"count = %d\n", info->line, info->count);
@@ -2529,0 +2457 @@
+	unsigned int i;
@@ -2536 +2464,7 @@
-	info = &cy_port[line];
+	for (i = 0; i < NR_CARDS; i++)
+		if (line < cy_card[i].first_line + cy_card[i].nports &&
+				line >= cy_card[i].first_line)
+			break;
+	if (i >= NR_CARDS)
+		return -ENODEV;
+	info = &cy_card[i].ports[line - cy_card[i].first_line];
@@ -2545,2 +2479,2 @@
-	if (IS_CYC_Z(cy_card[info->card])) {
-		struct cyclades_card *cinfo = &cy_card[info->card];
+	if (IS_CYC_Z(*info->card)) {
+		struct cyclades_card *cinfo = info->card;
@@ -2550,2 +2484 @@
-			if (((ZE_V1 == cy_readl(
-					&((struct RUNTIME_9060 __iomem *)
+			if (((ZE_V1 == readl(&((struct RUNTIME_9060 __iomem *)
@@ -2554 +2487 @@
-					(ZFIRM_HLT == cy_readl(
+					(ZFIRM_HLT == readl(
@@ -2556,3 +2489,4 @@
-				printk("cyc:Cyclades-Z Error: you need an "
-					"external power supply for this number "
-					"of ports.\n\rFirmware halted.\r\n");
+				printk(KERN_ERR "cyc:Cyclades-Z Error: you "
+					"need an external power supply for "
+					"this number of ports.\nFirmware "
+					"halted.\n");
@@ -2560,2 +2494,2 @@
-				printk("cyc:Cyclades-Z firmware not yet "
-					"loaded\n");
+				printk(KERN_ERR "cyc:Cyclades-Z firmware not "
+					"yet loaded\n");
@@ -2575,2 +2509,2 @@
-					(cy_readl(&firm_id->zfwctrl_addr) &
-						0xfffff);
+					(readl(&firm_id->zfwctrl_addr) &
+					 0xfffff);
@@ -2582,2 +2516 @@
-					  cy_readw(cinfo->ctl_addr +
-						   0x68) | 0x0900);
+					readw(cinfo->ctl_addr + 0x68) | 0x0900);
@@ -2588,2 +2521,2 @@
-					printk("cyc:IRQ enable retval was %x\n",
-						retval);
+					printk(KERN_ERR "cyc:IRQ enable retval "
+						"was %x\n", retval);
@@ -2592 +2525 @@
-					(int)cy_readl(&board_ctrl->n_channel);
+					(int)readl(&board_ctrl->n_channel);
@@ -2602 +2535 @@
-	printk("cyc:cy_open ttyC%d\n", info->line);	/* */
+	printk(KERN_DEBUG "cyc:cy_open ttyC%d\n", info->line);
@@ -2610,2 +2543,2 @@
-	printk("cyc:cy_open ttyC%d, count = %d\n", info->line, info->count);
-	/**/
+	printk(KERN_DEBUG "cyc:cy_open ttyC%d, count = %d\n", info->line,
+			info->count);
@@ -2615 +2548 @@
-	printk("cyc:cy_open (%d): incrementing count to %d\n",
+	printk(KERN_DEBUG "cyc:cy_open (%d): incrementing count to %d\n",
@@ -2623,2 +2556,2 @@
-		if (info->flags & ASYNC_CLOSING)
-			interruptible_sleep_on(&info->close_wait);
+		wait_event_interruptible(info->close_wait,
+				!(info->flags & ASYNC_CLOSING));
@@ -2639,2 +2572,2 @@
-		printk("cyc:cy_open returning after block_til_ready with %d\n",
-			retval);
+		printk(KERN_DEBUG "cyc:cy_open returning after block_til_ready "
+			"with %d\n", retval);
@@ -2648,2 +2581 @@
-	printk(" cyc:cy_open done\n");
-	/**/
+	printk(KERN_DEBUG "cyc:cy_open done\n");
@@ -2659 +2591,2 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_card *card;
+	struct cyclades_port *info = tty->driver_data;
@@ -2661 +2594 @@
-	int card, chip, channel, index;
+	int chip, channel, index;
@@ -2700,2 +2633,2 @@
-	printk("In cy_wait_until_sent(%d) check=%lu...", timeout, char_time);
-	printk("jiff=%lu...", jiffies);
+	printk(KERN_DEBUG "In cy_wait_until_sent(%d) check=%d, jiff=%lu...",
+		timeout, char_time, jiffies);
@@ -2704,2 +2637,2 @@
-	channel = (info->line) - (cy_card[card].first_line);
-	if (!IS_CYC_Z(cy_card[card])) {
+	channel = (info->line) - (card->first_line);
+	if (!IS_CYC_Z(*card)) {
@@ -2708,4 +2641,3 @@
-		index = cy_card[card].bus_index;
-		base_addr =
-		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
-		while (cy_readb(base_addr + (CySRER << index)) & CyTxRdy) {
+		index = card->bus_index;
+		base_addr = card->base_addr + (cy_chip_offset[chip] << index);
+		while (readb(base_addr + (CySRER << index)) & CyTxRdy) {
@@ -2713 +2645 @@
-			printk("Not clean (jiff=%lu)...", jiffies);
+			printk(KERN_DEBUG "Not clean (jiff=%lu)...", jiffies);
@@ -2721,2 +2652,0 @@
-	} else {
-		/* Nothing to do! */
@@ -2727 +2657 @@
-	printk("Clean (jiff=%lu)...done\n", jiffies);
+	printk(KERN_DEBUG "Clean (jiff=%lu)...done\n", jiffies);
@@ -2736 +2666,2 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
+	struct cyclades_card *card;
@@ -2740 +2671 @@
-	printk("cyc:cy_close ttyC%d\n", info->line);
+	printk(KERN_DEBUG "cyc:cy_close ttyC%d\n", info->line);
@@ -2747 +2678,3 @@
-	CY_LOCK(info, flags);
+	card = info->card;
+
+	spin_lock_irqsave(&card->card_lock, flags);
@@ -2750 +2683 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2754 +2687,2 @@
-	printk("cyc:cy_close ttyC%d, count = %d\n", info->line, info->count);
+	printk(KERN_DEBUG "cyc:cy_close ttyC%d, count = %d\n", info->line,
+		info->count);
@@ -2764,2 +2698,2 @@
-		printk("cyc:cy_close: bad serial port count; tty->count is 1, "
-			"info->count is %d\n", info->count);
+		printk(KERN_ERR "cyc:cy_close: bad serial port count; "
+			"tty->count is 1, info->count is %d\n", info->count);
@@ -2769 +2703 @@
-	printk("cyc:cy_close at (%d): decrementing count to %d\n",
+	printk(KERN_DEBUG  "cyc:cy_close at (%d): decrementing count to %d\n",
@@ -2774 +2708 @@
-		printk("cyc:cyc_close setting count to 0\n");
+		printk(KERN_DEBUG "cyc:cyc_close setting count to 0\n");
@@ -2779 +2713 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2789 +2723 @@
-	CY_UNLOCK(info, flags);
+	spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2793 +2727 @@
-	CY_LOCK(info, flags);
+	spin_lock_irqsave(&card->card_lock, flags);
@@ -2795,4 +2729,4 @@
-	if (!IS_CYC_Z(cy_card[info->card])) {
-		int channel = info->line - cy_card[info->card].first_line;
-		int index = cy_card[info->card].bus_index;
-		void __iomem *base_addr = cy_card[info->card].base_addr +
+	if (!IS_CYC_Z(*card)) {
+		int channel = info->line - card->first_line;
+		int index = card->bus_index;
+		void __iomem *base_addr = card->base_addr +
@@ -2804 +2738 @@
-			  cy_readb(base_addr + (CySRER << index)) & ~CyRxData);
+			  readb(base_addr + (CySRER << index)) & ~CyRxData);
@@ -2808 +2742 @@
-			CY_UNLOCK(info, flags);
+			spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2810 +2744 @@
-			CY_LOCK(info, flags);
+			spin_lock_irqsave(&card->card_lock, flags);
@@ -2815 +2749 @@
-		void __iomem *base_addr = cy_card[info->card].base_addr;
+		void __iomem *base_addr = card->base_addr;
@@ -2818 +2752 @@
-		    base_addr + (cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		    base_addr + (readl(&firm_id->zfwctrl_addr) & 0xfffff);
@@ -2820 +2754 @@
-		int channel = info->line - cy_card[info->card].first_line;
+		int channel = info->line - card->first_line;
@@ -2823,3 +2757,2 @@
-		if (cy_readl(&ch_ctrl[channel].flow_status) != C_FS_TXIDLE) {
-			retval = cyz_issue_cmd(&cy_card[info->card], channel,
-						C_CM_IOCTLW, 0L);
+		if (readl(&ch_ctrl[channel].flow_status) != C_FS_TXIDLE) {
+			retval = cyz_issue_cmd(card, channel, C_CM_IOCTLW, 0L);
@@ -2827,2 +2760,2 @@
-				printk("cyc:cy_close retval on ttyC%d was %x\n",
-					info->line, retval);
+				printk(KERN_DEBUG "cyc:cy_close retval on "
+					"ttyC%d was %x\n", info->line, retval);
@@ -2830,3 +2763,3 @@
-			CY_UNLOCK(info, flags);
-			interruptible_sleep_on(&info->shutdown_wait);
-			CY_LOCK(info, flags);
+			spin_unlock_irqrestore(&card->card_lock, flags);
+			wait_for_completion_interruptible(&info->shutdown_wait);
+			spin_lock_irqsave(&card->card_lock, flags);
@@ -2837 +2770 @@
-	CY_UNLOCK(info, flags);
+	spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2842 +2775 @@
-	CY_LOCK(info, flags);
+	spin_lock_irqsave(&card->card_lock, flags);
@@ -2848 +2781 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2854 +2787 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&card->card_lock, flags);
@@ -2860 +2793 @@
-	printk(" cyc:cy_close done\n");
+	printk(KERN_DEBUG "cyc:cy_close done\n");
@@ -2863 +2796 @@
-	CY_UNLOCK(info, flags);
+	spin_unlock_irqrestore(&card->card_lock, flags);
@@ -2881 +2814 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -2886 +2819 @@
-	printk("cyc:cy_write ttyC%d\n", info->line);	/* */
+	printk(KERN_DEBUG "cyc:cy_write ttyC%d\n", info->line);
@@ -2896 +2829 @@
-	CY_LOCK(info, flags);
+	spin_lock_irqsave(&info->card->card_lock, flags);
@@ -2912 +2845 @@
-	CY_UNLOCK(info, flags);
+	spin_unlock_irqrestore(&info->card->card_lock, flags);
@@ -2932 +2865 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -2936 +2869 @@
-	printk("cyc:cy_put_char ttyC%d\n", info->line);
+	printk(KERN_DEBUG "cyc:cy_put_char ttyC%d\n", info->line);
@@ -2945 +2878 @@
-	CY_LOCK(info, flags);
+	spin_lock_irqsave(&info->card->card_lock, flags);
@@ -2947 +2880 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&info->card->card_lock, flags);
@@ -2956 +2889 @@
-	CY_UNLOCK(info, flags);
+	spin_unlock_irqrestore(&info->card->card_lock, flags);
@@ -2965 +2898 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -2968 +2901 @@
-	printk("cyc:cy_flush_chars ttyC%d\n", info->line);	/* */
+	printk(KERN_DEBUG "cyc:cy_flush_chars ttyC%d\n", info->line);
@@ -2989 +2922 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -2993 +2926 @@
-	printk("cyc:cy_write_room ttyC%d\n", info->line);	/* */
+	printk(KERN_DEBUG "cyc:cy_write_room ttyC%d\n", info->line);
@@ -3006,2 +2939,3 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-	int card, channel;
+	struct cyclades_card *card;
+	struct cyclades_port *info = tty->driver_data;
+	int channel;
@@ -3013 +2947 @@
-	channel = (info->line) - (cy_card[card].first_line);
+	channel = (info->line) - (card->first_line);
@@ -3019 +2953,2 @@
-		printk("cyc:cy_chars_in_buffer ttyC%d %d\n", info->line, info->xmit_cnt);	/* */
+		printk(KERN_DEBUG "cyc:cy_chars_in_buffer ttyC%d %d\n",
+			info->line, info->xmit_cnt);
@@ -3024,4 +2959,4 @@
-		static volatile struct FIRM_ID *firm_id;
-		static volatile struct ZFW_CTRL *zfw_ctrl;
-		static volatile struct CH_CTRL *ch_ctrl;
-		static volatile struct BUF_CTRL *buf_ctrl;
+		static struct FIRM_ID *firm_id;
+		static struct ZFW_CTRL *zfw_ctrl;
+		static struct CH_CTRL *ch_ctrl;
+		static struct BUF_CTRL *buf_ctrl;
@@ -3029 +2964 @@
-		volatile uclong tx_put, tx_get, tx_bufsize;
+		__u32 tx_put, tx_get, tx_bufsize;
@@ -3031,3 +2966,3 @@
-		firm_id = cy_card[card].base_addr + ID_ADDRESS;
-		zfw_ctrl = cy_card[card].base_addr +
-			(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		firm_id = card->base_addr + ID_ADDRESS;
+		zfw_ctrl = card->base_addr +
+			(readl(&firm_id->zfwctrl_addr) & 0xfffff);
@@ -3037,3 +2972,3 @@
-		tx_get = cy_readl(&buf_ctrl->tx_get);
-		tx_put = cy_readl(&buf_ctrl->tx_put);
-		tx_bufsize = cy_readl(&buf_ctrl->tx_bufsize);
+		tx_get = readl(&buf_ctrl->tx_get);
+		tx_put = readl(&buf_ctrl->tx_put);
+		tx_bufsize = readl(&buf_ctrl->tx_bufsize);
@@ -3045 +2980,2 @@
-		printk("cyc:cy_chars_in_buffer ttyC%d %d\n", info->line, info->xmit_cnt + char_count);	/* */
+		printk(KERN_DEBUG "cyc:cy_chars_in_buffer ttyC%d %d\n",
+			info->line, info->xmit_cnt + char_count);
@@ -3058 +2994 @@
-static void cyy_baud_calc(struct cyclades_port *info, uclong baud)
+static void cyy_baud_calc(struct cyclades_port *info, __u32 baud)
@@ -3061 +2997 @@
-	uclong cy_clock = ((info->chip_rev >= CD1400_REV_J) ? 60000000 :
+	__u32 cy_clock = ((info->chip_rev >= CD1400_REV_J) ? 60000000 :
@@ -3088,0 +3025 @@
+	struct cyclades_card *card;
@@ -3091 +3028 @@
-	int card, chip, channel, index;
+	int chip, channel, index;
@@ -3121 +3058 @@
-	channel = (info->line) - (cy_card[card].first_line);
+	channel = info->line - card->first_line;
@@ -3124 +3061 @@
-	if (!IS_CYC_Z(cy_card[card])) {
+	if (!IS_CYC_Z(*card)) {
@@ -3126 +3063 @@
-		index = cy_card[card].bus_index;
+		index = card->bus_index;
@@ -3244,2 +3181 @@
-		base_addr = cy_card[card].base_addr +
-			(cy_chip_offset[chip] << index);
+		base_addr = card->base_addr + (cy_chip_offset[chip] << index);
@@ -3247 +3183 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&card->card_lock, flags);
@@ -3279,2 +3215 @@
-				  cy_readb(base_addr +
-					   (CySRER << index)) | CyMdmCh);
+				readb(base_addr + (CySRER << index)) | CyMdmCh);
@@ -3294 +3229 @@
-				  cy_readb(base_addr +
+				  readb(base_addr +
@@ -3319,4 +3254,4 @@
-			printk("cyc:set_line_char dropping DTR\n");
-			printk("     status: 0x%x, 0x%x\n",
-				cy_readb(base_addr + (CyMSVR1 << index)),
-				cy_readb(base_addr + (CyMSVR2 << index)));
+			printk(KERN_DEBUG "cyc:set_line_char dropping DTR\n");
+			printk(KERN_DEBUG "     status: 0x%x, 0x%x\n",
+				readb(base_addr + (CyMSVR1 << index)),
+				readb(base_addr + (CyMSVR2 << index)));
@@ -3333,4 +3268,4 @@
-			printk("cyc:set_line_char raising DTR\n");
-			printk("     status: 0x%x, 0x%x\n",
-				cy_readb(base_addr + (CyMSVR1 << index)),
-				cy_readb(base_addr + (CyMSVR2 << index)));
+			printk(KERN_DEBUG "cyc:set_line_char raising DTR\n");
+			printk(KERN_DEBUG "     status: 0x%x, 0x%x\n",
+				readb(base_addr + (CyMSVR1 << index)),
+				readb(base_addr + (CyMSVR2 << index)));
@@ -3343 +3278 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3351 +3286 @@
-		uclong sw_flow;
+		__u32 sw_flow;
@@ -3354,2 +3289,2 @@
-		firm_id = cy_card[card].base_addr + ID_ADDRESS;
-		if (!ISZLOADED(cy_card[card])) {
+		firm_id = card->base_addr + ID_ADDRESS;
+		if (!ISZLOADED(*card)) {
@@ -3359,2 +3294,2 @@
-		zfw_ctrl = cy_card[card].base_addr +
-			(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		zfw_ctrl = card->base_addr +
+			(readl(&firm_id->zfwctrl_addr) & 0xfffff);
@@ -3411 +3346 @@
-				  cy_readl(&ch_ctrl->comm_data_l) | C_DL_2STOP);
+				  readl(&ch_ctrl->comm_data_l) | C_DL_2STOP);
@@ -3414 +3349 @@
-				  cy_readl(&ch_ctrl->comm_data_l) | C_DL_1STOP);
+				  readl(&ch_ctrl->comm_data_l) | C_DL_1STOP);
@@ -3429,2 +3364 @@
-				  cy_readl(&ch_ctrl->
-					   hw_flow) | C_RS_CTS | C_RS_RTS);
+				readl(&ch_ctrl->hw_flow) | C_RS_CTS | C_RS_RTS);
@@ -3432,3 +3366,2 @@
-			cy_writel(&ch_ctrl->hw_flow,
-				  cy_readl(&ch_ctrl->
-					   hw_flow) & ~(C_RS_CTS | C_RS_RTS));
+			cy_writel(&ch_ctrl->hw_flow, readl(&ch_ctrl->hw_flow) &
+					~(C_RS_CTS | C_RS_RTS));
@@ -3449 +3382 @@
-		retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_IOCTL, 0L);
+		retval = cyz_issue_cmd(card, channel, C_CM_IOCTL, 0L);
@@ -3451,2 +3384,2 @@
-			printk("cyc:set_line_char retval on ttyC%d was %x\n",
-				info->line, retval);
+			printk(KERN_ERR "cyc:set_line_char retval on ttyC%d "
+				"was %x\n", info->line, retval);
@@ -3464 +3397 @@
-				  cy_readl(&ch_ctrl->rs_control) & ~C_RS_DTR);
+				  readl(&ch_ctrl->rs_control) & ~C_RS_DTR);
@@ -3466 +3399 @@
-			printk("cyc:set_line_char dropping Z DTR\n");
+			printk(KERN_DEBUG "cyc:set_line_char dropping Z DTR\n");
@@ -3470 +3403 @@
-				  cy_readl(&ch_ctrl->rs_control) | C_RS_DTR);
+				  readl(&ch_ctrl->rs_control) | C_RS_DTR);
@@ -3472 +3405 @@
-			printk("cyc:set_line_char raising Z DTR\n");
+			printk(KERN_DEBUG "cyc:set_line_char raising Z DTR\n");
@@ -3476 +3409 @@
-		retval = cyz_issue_cmd(&cy_card[card], channel, C_CM_IOCTLM,0L);
+		retval = cyz_issue_cmd(card, channel, C_CM_IOCTLM,0L);
@@ -3478,2 +3411,2 @@
-			printk("cyc:set_line_char(2) retval on ttyC%d was %x\n",
-				info->line, retval);
+			printk(KERN_ERR "cyc:set_line_char(2) retval on ttyC%d "
+				"was %x\n", info->line, retval);
@@ -3493 +3426 @@
-	struct cyclades_card *cinfo = &cy_card[info->card];
+	struct cyclades_card *cinfo = info->card;
@@ -3500 +3433,2 @@
-	tmp.port = info->card * 0x100 + info->line - cinfo->first_line;
+	tmp.port = (info->card - cy_card) * 0x100 + info->line -
+		cinfo->first_line;
@@ -3569 +3503,2 @@
-	int card, chip, channel, index;
+	struct cyclades_card *card;
+	int chip, channel, index;
@@ -3576,2 +3511,2 @@
-	channel = (info->line) - (cy_card[card].first_line);
-	if (!IS_CYC_Z(cy_card[card])) {
+	channel = (info->line) - (card->first_line);
+	if (!IS_CYC_Z(*card)) {
@@ -3580,3 +3515,2 @@
-		index = cy_card[card].bus_index;
-		base_addr =
-		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
+		index = card->bus_index;
+		base_addr = card->base_addr + (cy_chip_offset[chip] << index);
@@ -3584,2 +3518,2 @@
-		CY_LOCK(info, flags);
-		status = cy_readb(base_addr + (CySRER << index)) &
+		spin_lock_irqsave(&card->card_lock, flags);
+		status = readb(base_addr + (CySRER << index)) &
@@ -3587 +3521 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3598,2 +3532,3 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-	int card, chip, channel, index;
+	struct cyclades_port *info = tty->driver_data;
+	struct cyclades_card *card;
+	int chip, channel, index;
@@ -3614,2 +3549,2 @@
-	channel = (info->line) - (cy_card[card].first_line);
-	if (!IS_CYC_Z(cy_card[card])) {
+	channel = info->line - card->first_line;
+	if (!IS_CYC_Z(*card)) {
@@ -3618,3 +3553,2 @@
-		index = cy_card[card].bus_index;
-		base_addr =
-		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
+		index = card->bus_index;
+		base_addr = card->base_addr + (cy_chip_offset[chip] << index);
@@ -3622 +3556 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&card->card_lock, flags);
@@ -3624,3 +3558,3 @@
-		status = cy_readb(base_addr + (CyMSVR1 << index));
-		status |= cy_readb(base_addr + (CyMSVR2 << index));
-		CY_UNLOCK(info, flags);
+		status = readb(base_addr + (CyMSVR1 << index));
+		status |= readb(base_addr + (CyMSVR2 << index));
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3640,10 +3574,5 @@
-		base_addr = cy_card[card].base_addr;
-
-		if (cy_card[card].num_chips != -1) {
-			return -EINVAL;
-		}
-
-		firm_id = cy_card[card].base_addr + ID_ADDRESS;
-		if (ISZLOADED(cy_card[card])) {
-			zfw_ctrl = cy_card[card].base_addr +
-				(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		base_addr = card->base_addr;
+		firm_id = card->base_addr + ID_ADDRESS;
+		if (ISZLOADED(*card)) {
+			zfw_ctrl = card->base_addr +
+				(readl(&firm_id->zfwctrl_addr) & 0xfffff);
@@ -3652 +3581 @@
-			lstatus = cy_readl(&ch_ctrl[channel].rs_status);
+			lstatus = readl(&ch_ctrl[channel].rs_status);
@@ -3672,2 +3601,3 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-	int card, chip, channel, index;
+	struct cyclades_port *info = tty->driver_data;
+	struct cyclades_card *card;
+	int chip, channel, index;
@@ -3686,2 +3616,2 @@
-	channel = (info->line) - (cy_card[card].first_line);
-	if (!IS_CYC_Z(cy_card[card])) {
+	channel = (info->line) - (card->first_line);
+	if (!IS_CYC_Z(*card)) {
@@ -3690,3 +3620,2 @@
-		index = cy_card[card].bus_index;
-		base_addr =
-		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
+		index = card->bus_index;
+		base_addr = card->base_addr + (cy_chip_offset[chip] << index);
@@ -3695 +3624 @@
-			CY_LOCK(info, flags);
+			spin_lock_irqsave(&card->card_lock, flags);
@@ -3705 +3634 @@
-			CY_UNLOCK(info, flags);
+			spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3708 +3637 @@
-			CY_LOCK(info, flags);
+			spin_lock_irqsave(&card->card_lock, flags);
@@ -3718 +3647 @@
-			CY_UNLOCK(info, flags);
+			spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3721 +3650 @@
-			CY_LOCK(info, flags);
+			spin_lock_irqsave(&card->card_lock, flags);
@@ -3732,4 +3661,4 @@
-			printk("cyc:set_modem_info raising DTR\n");
-			printk("     status: 0x%x, 0x%x\n",
-				cy_readb(base_addr + (CyMSVR1 << index)),
-				cy_readb(base_addr + (CyMSVR2 << index)));
+			printk(KERN_DEBUG "cyc:set_modem_info raising DTR\n");
+			printk(KERN_DEBUG "     status: 0x%x, 0x%x\n",
+				readb(base_addr + (CyMSVR1 << index)),
+				readb(base_addr + (CyMSVR2 << index)));
@@ -3737 +3666 @@
-			CY_UNLOCK(info, flags);
+			spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3740 +3669 @@
-			CY_LOCK(info, flags);
+			spin_lock_irqsave(&card->card_lock, flags);
@@ -3752,4 +3681,4 @@
-			printk("cyc:set_modem_info dropping DTR\n");
-			printk("     status: 0x%x, 0x%x\n",
-				cy_readb(base_addr + (CyMSVR1 << index)),
-				cy_readb(base_addr + (CyMSVR2 << index)));
+			printk(KERN_DEBUG "cyc:set_modem_info dropping DTR\n");
+			printk(KERN_DEBUG "     status: 0x%x, 0x%x\n",
+				readb(base_addr + (CyMSVR1 << index)),
+				readb(base_addr + (CyMSVR2 << index)));
@@ -3757 +3686 @@
-			CY_UNLOCK(info, flags);
+			spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3760 +3689 @@
-		base_addr = cy_card[card].base_addr;
+		base_addr = card->base_addr;
@@ -3762,4 +3691,4 @@
-		firm_id = cy_card[card].base_addr + ID_ADDRESS;
-		if (ISZLOADED(cy_card[card])) {
-			zfw_ctrl = cy_card[card].base_addr +
-				(cy_readl(&firm_id->zfwctrl_addr) & 0xfffff);
+		firm_id = card->base_addr + ID_ADDRESS;
+		if (ISZLOADED(*card)) {
+			zfw_ctrl = card->base_addr +
+				(readl(&firm_id->zfwctrl_addr) & 0xfffff);
@@ -3770 +3699 @@
-				CY_LOCK(info, flags);
+				spin_lock_irqsave(&card->card_lock, flags);
@@ -3772,3 +3701,3 @@
-					  cy_readl(&ch_ctrl[channel].
-						   rs_control) | C_RS_RTS);
-				CY_UNLOCK(info, flags);
+					readl(&ch_ctrl[channel].rs_control) |
+					C_RS_RTS);
+				spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3777 +3706 @@
-				CY_LOCK(info, flags);
+				spin_lock_irqsave(&card->card_lock, flags);
@@ -3779,3 +3708,3 @@
-					  cy_readl(&ch_ctrl[channel].
-						   rs_control) & ~C_RS_RTS);
-				CY_UNLOCK(info, flags);
+					readl(&ch_ctrl[channel].rs_control) &
+					~C_RS_RTS);
+				spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3784 +3713 @@
-				CY_LOCK(info, flags);
+				spin_lock_irqsave(&card->card_lock, flags);
@@ -3786,2 +3715,2 @@
-					  cy_readl(&ch_ctrl[channel].
-						   rs_control) | C_RS_DTR);
+					readl(&ch_ctrl[channel].rs_control) |
+					C_RS_DTR);
@@ -3789 +3718,2 @@
-				printk("cyc:set_modem_info raising Z DTR\n");
+				printk(KERN_DEBUG "cyc:set_modem_info raising "
+					"Z DTR\n");
@@ -3791 +3721 @@
-				CY_UNLOCK(info, flags);
+				spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3794 +3724 @@
-				CY_LOCK(info, flags);
+				spin_lock_irqsave(&card->card_lock, flags);
@@ -3796,2 +3726,2 @@
-					  cy_readl(&ch_ctrl[channel].
-						   rs_control) & ~C_RS_DTR);
+					readl(&ch_ctrl[channel].rs_control) &
+					~C_RS_DTR);
@@ -3799 +3729,2 @@
-				printk("cyc:set_modem_info clearing Z DTR\n");
+				printk(KERN_DEBUG "cyc:set_modem_info clearing "
+					"Z DTR\n");
@@ -3801 +3732 @@
-				CY_UNLOCK(info, flags);
+				spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3806,3 +3737,2 @@
-		CY_LOCK(info, flags);
-		retval = cyz_issue_cmd(&cy_card[info->card],
-					channel, C_CM_IOCTLM, 0L);
+		spin_lock_irqsave(&card->card_lock, flags);
+		retval = cyz_issue_cmd(card, channel, C_CM_IOCTLM, 0L);
@@ -3810,2 +3740,2 @@
-			printk("cyc:set_modem_info retval on ttyC%d was %x\n",
-				info->line, retval);
+			printk(KERN_ERR "cyc:set_modem_info retval on ttyC%d "
+				"was %x\n", info->line, retval);
@@ -3813 +3743 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3823 +3753,2 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
+	struct cyclades_card *card;
@@ -3829,2 +3760,4 @@
-	CY_LOCK(info, flags);
-	if (!IS_CYC_Z(cy_card[info->card])) {
+	card = info->card;
+
+	spin_lock_irqsave(&card->card_lock, flags);
+	if (!IS_CYC_Z(*card)) {
@@ -3838 +3771 @@
-					CY_UNLOCK(info, flags);
+					spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3840 +3773 @@
-					CY_LOCK(info, flags);
+					spin_lock_irqsave(&card->card_lock, flags);
@@ -3847 +3780 @@
-					CY_UNLOCK(info, flags);
+					spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3849 +3782 @@
-					CY_LOCK(info, flags);
+					spin_lock_irqsave(&card->card_lock, flags);
@@ -3857,2 +3790,2 @@
-			retval = cyz_issue_cmd(&cy_card[info->card],
-				info->line - cy_card[info->card].first_line,
+			retval = cyz_issue_cmd(card,
+				info->line - card->first_line,
@@ -3861,2 +3794,2 @@
-				printk("cyc:cy_break (set) retval on ttyC%d "
-					"was %x\n", info->line, retval);
+				printk(KERN_ERR "cyc:cy_break (set) retval on "
+					"ttyC%d was %x\n", info->line, retval);
@@ -3865,2 +3798,2 @@
-			retval = cyz_issue_cmd(&cy_card[info->card],
-				info->line - cy_card[info->card].first_line,
+			retval = cyz_issue_cmd(card,
+				info->line - card->first_line,
@@ -3869,2 +3802,3 @@
-				printk("cyc:cy_break (clr) retval on ttyC%d "
-					"was %x\n", info->line, retval);
+				printk(KERN_DEBUG "cyc:cy_break (clr) retval "
+					"on ttyC%d was %x\n", info->line,
+					retval);
@@ -3874 +3808 @@
-	CY_UNLOCK(info, flags);
+	spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3891,0 +3826 @@
+	struct cyclades_card *card;
@@ -3893 +3828 @@
-	int card, channel, chip, index;
+	int channel, chip, index;
@@ -3897,2 +3832,2 @@
-	channel = info->line - cy_card[card].first_line;
-	if (!IS_CYC_Z(cy_card[card])) {
+	channel = info->line - card->first_line;
+	if (!IS_CYC_Z(*card)) {
@@ -3901 +3836 @@
-		index = cy_card[card].bus_index;
+		index = card->bus_index;
@@ -3903 +3838 @@
-		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
+		    card->base_addr + (cy_chip_offset[chip] << index);
@@ -3908 +3843 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&card->card_lock, flags);
@@ -3911,3 +3846 @@
-		CY_UNLOCK(info, flags);
-	} else {
-		/* Nothing to do! */
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3920,0 +3854 @@
+	struct cyclades_card *card;
@@ -3922 +3856 @@
-	int card, channel, chip, index;
+	int channel, chip, index;
@@ -3926,2 +3860,2 @@
-	channel = info->line - cy_card[card].first_line;
-	if (!IS_CYC_Z(cy_card[card])) {
+	channel = info->line - card->first_line;
+	if (!IS_CYC_Z(*card)) {
@@ -3930,3 +3864,2 @@
-		index = cy_card[card].bus_index;
-		base_addr =
-		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
+		index = card->bus_index;
+		base_addr = card->base_addr + (cy_chip_offset[chip] << index);
@@ -3934 +3867 @@
-		tmp = cy_readb(base_addr + (CyCOR3 << index)) & CyREC_FIFO;
+		tmp = readb(base_addr + (CyCOR3 << index)) & CyREC_FIFO;
@@ -3936,3 +3868,0 @@
-	} else {
-		/* Nothing to do! */
-		return 0;
@@ -3939,0 +3870 @@
+	return 0;
@@ -3956,0 +3888 @@
+	struct cyclades_card *card;
@@ -3958 +3890 @@
-	int card, channel, chip, index;
+	int channel, chip, index;
@@ -3962,2 +3894,2 @@
-	channel = info->line - cy_card[card].first_line;
-	if (!IS_CYC_Z(cy_card[card])) {
+	channel = info->line - card->first_line;
+	if (!IS_CYC_Z(*card)) {
@@ -3966,3 +3898,2 @@
-		index = cy_card[card].bus_index;
-		base_addr =
-		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
+		index = card->bus_index;
+		base_addr = card->base_addr + (cy_chip_offset[chip] << index);
@@ -3970 +3901 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&card->card_lock, flags);
@@ -3972,3 +3903 @@
-		CY_UNLOCK(info, flags);
-	} else {
-		/* Nothing to do! */
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -3980,0 +3910 @@
+	struct cyclades_card *card;
@@ -3982 +3912 @@
-	int card, channel, chip, index;
+	int channel, chip, index;
@@ -3986,2 +3916,2 @@
-	channel = info->line - cy_card[card].first_line;
-	if (!IS_CYC_Z(cy_card[card])) {
+	channel = info->line - card->first_line;
+	if (!IS_CYC_Z(*card)) {
@@ -3990,3 +3920,2 @@
-		index = cy_card[card].bus_index;
-		base_addr =
-		    cy_card[card].base_addr + (cy_chip_offset[chip] << index);
+		index = card->bus_index;
+		base_addr = card->base_addr + (cy_chip_offset[chip] << index);
@@ -3994 +3923 @@
-		tmp = cy_readb(base_addr + (CyRTPR << index));
+		tmp = readb(base_addr + (CyRTPR << index));
@@ -3996,3 +3924,0 @@
-	} else {
-		/* Nothing to do! */
-		return 0;
@@ -3999,0 +3926 @@
+	return 0;
@@ -4023 +3950 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -4034 +3961,2 @@
-	printk("cyc:cy_ioctl ttyC%d, cmd = %x arg = %lx\n", info->line, cmd, arg);	/* */
+	printk(KERN_DEBUG "cyc:cy_ioctl ttyC%d, cmd = %x arg = %lx\n",
+		info->line, cmd, arg);
@@ -4079,8 +4006,0 @@
-	case CYGETCARDINFO:
-		if (copy_to_user(argp, &cy_card[info->card],
-				 sizeof(struct cyclades_card))) {
-			ret_val = -EFAULT;
-			break;
-		}
-		ret_val = 0;
-		break;
@@ -4122 +4042 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&info->card->card_lock, flags);
@@ -4124,10 +4044,5 @@
-		cprev = info->icount;
-		CY_UNLOCK(info, flags);
-		while (1) {
-			interruptible_sleep_on(&info->delta_msr_wait);
-			/* see if a signal did it */
-			if (signal_pending(current)) {
-				return -ERESTARTSYS;
-			}
-
-			CY_LOCK(info, flags);
+		cnow = info->icount;
+		spin_unlock_irqrestore(&info->card->card_lock, flags);
+		ret_val = wait_event_interruptible(info->delta_msr_wait, ({
+			cprev = cnow;
+			spin_lock_irqsave(&info->card->card_lock, flags);
@@ -4135 +4050 @@
-			CY_UNLOCK(info, flags);
+			spin_unlock_irqrestore(&info->card->card_lock, flags);
@@ -4137,13 +4052,6 @@
-			if (cnow.rng == cprev.rng && cnow.dsr == cprev.dsr &&
-			    cnow.dcd == cprev.dcd && cnow.cts == cprev.cts) {
-				return -EIO;	/* no change => error */
-			}
-			if (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
-			    ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
-			    ((arg & TIOCM_CD) && (cnow.dcd != cprev.dcd)) ||
-			    ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {
-				return 0;
-			}
-			cprev = cnow;
-		}
-		/* NOTREACHED */
+			((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
+			((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
+			((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||
+			((arg & TIOCM_CTS) && (cnow.cts != cprev.cts));
+		}));
+		break;
@@ -4158 +4066 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&info->card->card_lock, flags);
@@ -4160 +4068 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&info->card->card_lock, flags);
@@ -4202 +4110 @@
-	printk(" cyc:cy_ioctl done\n");
+	printk(KERN_DEBUG "cyc:cy_ioctl done\n");
@@ -4216 +4124 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -4219 +4127 @@
-	printk("cyc:cy_set_termios ttyC%d\n", info->line);
+	printk(KERN_DEBUG "cyc:cy_set_termios ttyC%d\n", info->line);
@@ -4251,2 +4159,3 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-	int card, channel;
+	struct cyclades_port *info = tty->driver_data;
+	struct cyclades_card *card;
+	int channel;
@@ -4263 +4172 @@
-	channel = info->line - cy_card[card].first_line;
+	channel = info->line - card->first_line;
@@ -4265 +4174 @@
-	if (IS_CYC_Z(cy_card[card])) {
+	if (IS_CYC_Z(*card)) {
@@ -4267,2 +4176 @@
-			cyz_issue_cmd(&cy_card[card], channel, C_CM_SENDXOFF,
-					0L);
+			cyz_issue_cmd(card, channel, C_CM_SENDXOFF, 0L);
@@ -4270,2 +4178 @@
-			cyz_issue_cmd(&cy_card[card], channel, C_CM_SENDXON,
-					0L);
+			cyz_issue_cmd(card, channel, C_CM_SENDXON, 0L);
@@ -4281 +4188,2 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
+	struct cyclades_card *card;
@@ -4284 +4192 @@
-	int card, chip, channel, index;
+	int chip, channel, index;
@@ -4289 +4197 @@
-	printk("cyc:throttle %s: %d....ttyC%d\n", tty_name(tty, buf),
+	printk(KERN_DEBUG "cyc:throttle %s: %ld...ttyC%d\n", tty_name(tty, buf),
@@ -4300 +4208 @@
-		if (!IS_CYC_Z(cy_card[card]))
+		if (!IS_CYC_Z(*card))
@@ -4307,2 +4215,2 @@
-		channel = info->line - cy_card[card].first_line;
-		if (!IS_CYC_Z(cy_card[card])) {
+		channel = info->line - card->first_line;
+		if (!IS_CYC_Z(*card)) {
@@ -4311,2 +4219,2 @@
-			index = cy_card[card].bus_index;
-			base_addr = cy_card[card].base_addr +
+			index = card->bus_index;
+			base_addr = card->base_addr +
@@ -4315 +4223 @@
-			CY_LOCK(info, flags);
+			spin_lock_irqsave(&card->card_lock, flags);
@@ -4325 +4233 @@
-			CY_UNLOCK(info, flags);
+			spin_unlock_irqrestore(&card->card_lock, flags);
@@ -4339 +4247,2 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
+	struct cyclades_card *card;
@@ -4342 +4251 @@
-	int card, chip, channel, index;
+	int chip, channel, index;
@@ -4347,2 +4256,2 @@
-	printk("cyc:unthrottle %s: %d....ttyC%d\n", tty_name(tty, buf),
-		tty->ldisc.chars_in_buffer(tty), info->line);
+	printk(KERN_DEBUG "cyc:unthrottle %s: %ld...ttyC%d\n",
+		tty_name(tty, buf), tty->ldisc.chars_in_buffer(tty),info->line);
@@ -4364,2 +4273,2 @@
-		channel = info->line - cy_card[card].first_line;
-		if (!IS_CYC_Z(cy_card[card])) {
+		channel = info->line - card->first_line;
+		if (!IS_CYC_Z(*card)) {
@@ -4368,2 +4277,2 @@
-			index = cy_card[card].bus_index;
-			base_addr = cy_card[card].base_addr +
+			index = card->bus_index;
+			base_addr = card->base_addr +
@@ -4372 +4281 @@
-			CY_LOCK(info, flags);
+			spin_lock_irqsave(&card->card_lock, flags);
@@ -4382 +4291 @@
-			CY_UNLOCK(info, flags);
+			spin_unlock_irqrestore(&card->card_lock, flags);
@@ -4395 +4304 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -4401 +4310 @@
-	printk("cyc:cy_stop ttyC%d\n", info->line);	/* */
+	printk(KERN_DEBUG "cyc:cy_stop ttyC%d\n", info->line);
@@ -4407 +4316 @@
-	cinfo = &cy_card[info->card];
+	cinfo = info->card;
@@ -4413,2 +4322 @@
-		base_addr = cy_card[info->card].base_addr +
-			(cy_chip_offset[chip] << index);
+		base_addr = cinfo->base_addr + (cy_chip_offset[chip] << index);
@@ -4416 +4324 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&cinfo->card_lock, flags);
@@ -4420,4 +4328,2 @@
-			  cy_readb(base_addr + (CySRER << index)) & ~CyTxRdy);
-		CY_UNLOCK(info, flags);
-	} else {
-		/* Nothing to do! */
+			  readb(base_addr + (CySRER << index)) & ~CyTxRdy);
+		spin_unlock_irqrestore(&cinfo->card_lock, flags);
@@ -4430 +4336 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -4436 +4342 @@
-	printk("cyc:cy_start ttyC%d\n", info->line);	/* */
+	printk(KERN_DEBUG "cyc:cy_start ttyC%d\n", info->line);
@@ -4442 +4348 @@
-	cinfo = &cy_card[info->card];
+	cinfo = info->card;
@@ -4448,2 +4354 @@
-		base_addr = cy_card[info->card].base_addr +
-			(cy_chip_offset[chip] << index);
+		base_addr = cinfo->base_addr + (cy_chip_offset[chip] << index);
@@ -4451 +4356 @@
-		CY_LOCK(info, flags);
+		spin_lock_irqsave(&cinfo->card_lock, flags);
@@ -4454,4 +4359,2 @@
-			  cy_readb(base_addr + (CySRER << index)) | CyTxRdy);
-		CY_UNLOCK(info, flags);
-	} else {
-		/* Nothing to do! */
+			  readb(base_addr + (CySRER << index)) | CyTxRdy);
+		spin_unlock_irqrestore(&cinfo->card_lock, flags);
@@ -4463,2 +4366,3 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-	int card, channel, retval;
+	struct cyclades_port *info = tty->driver_data;
+	struct cyclades_card *card;
+	int channel, retval;
@@ -4468 +4372 @@
-	printk("cyc:cy_flush_buffer ttyC%d\n", info->line);	/* */
+	printk(KERN_DEBUG "cyc:cy_flush_buffer ttyC%d\n", info->line);
@@ -4475 +4379 @@
-	channel = (info->line) - (cy_card[card].first_line);
+	channel = info->line - card->first_line;
@@ -4477 +4381 @@
-	CY_LOCK(info, flags);
+	spin_lock_irqsave(&card->card_lock, flags);
@@ -4479 +4383 @@
-	CY_UNLOCK(info, flags);
+	spin_unlock_irqrestore(&card->card_lock, flags);
@@ -4481 +4385 @@
-	if (IS_CYC_Z(cy_card[card])) {	/* If it is a Z card, flush the on-board
+	if (IS_CYC_Z(*card)) {	/* If it is a Z card, flush the on-board
@@ -4483,3 +4387,2 @@
-		CY_LOCK(info, flags);
-		retval =
-		    cyz_issue_cmd(&cy_card[card], channel, C_CM_FLUSH_TX, 0L);
+		spin_lock_irqsave(&card->card_lock, flags);
+		retval = cyz_issue_cmd(card, channel, C_CM_FLUSH_TX, 0L);
@@ -4487,2 +4390,2 @@
-			printk("cyc: flush_buffer retval on ttyC%d was %x\n",
-				info->line, retval);
+			printk(KERN_ERR "cyc: flush_buffer retval on ttyC%d "
+				"was %x\n", info->line, retval);
@@ -4490 +4393 @@
-		CY_UNLOCK(info, flags);
+		spin_unlock_irqrestore(&card->card_lock, flags);
@@ -4500 +4403 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -4503 +4406 @@
-	printk("cyc:cy_hangup ttyC%d\n", info->line);	/* */
+	printk(KERN_DEBUG "cyc:cy_hangup ttyC%d\n", info->line);
@@ -4514 +4417,2 @@
-	printk("cyc:cy_hangup (%d): setting count to 0\n", current->pid);
+	printk(KERN_DEBUG "cyc:cy_hangup (%d): setting count to 0\n",
+		current->pid);
@@ -4528,0 +4433,97 @@
+static int __devinit cy_init_card(struct cyclades_card *cinfo)
+{
+	struct cyclades_port *info;
+	u32 mailbox;
+	unsigned int nports;
+	unsigned short chip_number;
+	int index, port;
+
+	spin_lock_init(&cinfo->card_lock);
+
+	if (IS_CYC_Z(*cinfo)) {	/* Cyclades-Z */
+		mailbox = readl(&((struct RUNTIME_9060 __iomem *)
+				     cinfo->ctl_addr)->mail_box_0);
+		nports = (mailbox == ZE_V1) ? ZE_V1_NPORTS : 8;
+		cinfo->intr_enabled = 0;
+		cinfo->nports = 0;	/* Will be correctly set later, after
+					   Z FW is loaded */
+	} else {
+		index = cinfo->bus_index;
+		nports = cinfo->nports = CyPORTS_PER_CHIP * cinfo->num_chips;
+	}
+
+	cinfo->ports = kzalloc(sizeof(*cinfo->ports) * nports, GFP_KERNEL);
+	if (cinfo->ports == NULL) {
+		printk(KERN_ERR "Cyclades: cannot allocate ports\n");
+		cinfo->nports = 0;
+		return -ENOMEM;
+	}
+
+	for (port = cinfo->first_line; port < cinfo->first_line + nports;
+			port++) {
+		info = &cinfo->ports[port - cinfo->first_line];
+		info->magic = CYCLADES_MAGIC;
+		info->card = cinfo;
+		info->line = port;
+		info->flags = STD_COM_FLAGS;
+		info->closing_wait = CLOSING_WAIT_DELAY;
+		info->close_delay = 5 * HZ / 10;
+
+		INIT_WORK(&info->tqueue, do_softint);
+		init_waitqueue_head(&info->open_wait);
+		init_waitqueue_head(&info->close_wait);
+		init_completion(&info->shutdown_wait);
+		init_waitqueue_head(&info->delta_msr_wait);
+
+		if (IS_CYC_Z(*cinfo)) {
+			info->type = PORT_STARTECH;
+			if (mailbox == ZO_V1)
+				info->xmit_fifo_size = CYZ_FIFO_SIZE;
+			else
+				info->xmit_fifo_size = 4 * CYZ_FIFO_SIZE;
+#ifdef CONFIG_CYZ_INTR
+			setup_timer(&cyz_rx_full_timer[port],
+				cyz_rx_restart, (unsigned long)info);
+#endif
+		} else {
+			info->type = PORT_CIRRUS;
+			info->xmit_fifo_size = CyMAX_CHAR_FIFO;
+			info->cor1 = CyPARITY_NONE | Cy_1_STOP | Cy_8_BITS;
+			info->cor2 = CyETC;
+			info->cor3 = 0x08;	/* _very_ small rcv threshold */
+
+			chip_number = (port - cinfo->first_line) / 4;
+			if ((info->chip_rev = readb(cinfo->base_addr +
+				      (cy_chip_offset[chip_number] <<
+				       index) + (CyGFRCR << index))) >=
+			    CD1400_REV_J) {
+				/* It is a CD1400 rev. J or later */
+				info->tbpr = baud_bpr_60[13];	/* Tx BPR */
+				info->tco = baud_co_60[13];	/* Tx CO */
+				info->rbpr = baud_bpr_60[13];	/* Rx BPR */
+				info->rco = baud_co_60[13];	/* Rx CO */
+				info->rtsdtr_inv = 1;
+			} else {
+				info->tbpr = baud_bpr_25[13];	/* Tx BPR */
+				info->tco = baud_co_25[13];	/* Tx CO */
+				info->rbpr = baud_bpr_25[13];	/* Rx BPR */
+				info->rco = baud_co_25[13];	/* Rx CO */
+				info->rtsdtr_inv = 0;
+			}
+			info->read_status_mask = CyTIMEOUT | CySPECHAR |
+				CyBREAK | CyPARITY | CyFRAME | CyOVERRUN;
+		}
+
+	}
+
+#ifndef CONFIG_CYZ_INTR
+	if (IS_CYC_Z(*cinfo) && !timer_pending(&cyz_timerlist)) {
+		mod_timer(&cyz_timerlist, jiffies + 1);
+#ifdef CY_PCI_DEBUG
+		printk(KERN_DEBUG "Cyclades-Z polling initialized\n");
+#endif
+	}
+#endif
+	return 0;
+}
+
@@ -4531,2 +4532,2 @@
-static unsigned short __init
-cyy_init_card(void __iomem * true_base_addr, int index)
+static unsigned short __devinit cyy_init_card(void __iomem *true_base_addr,
+		int index)
@@ -4547 +4548 @@
-		if (cy_readb(base_addr + (CyCCR << index)) != 0x00) {
+		if (readb(base_addr + (CyCCR << index)) != 0x00) {
@@ -4564 +4565 @@
-		if (chip_number == 4 && cy_readb(true_base_addr +
+		if (chip_number == 4 && readb(true_base_addr +
@@ -4573 +4574 @@
-		if (cy_readb(base_addr + (CyGFRCR << index)) == 0x00) {
+		if (readb(base_addr + (CyGFRCR << index)) == 0x00) {
@@ -4581 +4582 @@
-		if ((0xf0 & (cy_readb(base_addr + (CyGFRCR << index)))) !=
+		if ((0xf0 & (readb(base_addr + (CyGFRCR << index)))) !=
@@ -4592 +4593 @@
-		if (cy_readb(base_addr + (CyGFRCR << index)) >= CD1400_REV_J) {
+		if (readb(base_addr + (CyGFRCR << index)) >= CD1400_REV_J) {
@@ -4605 +4606 @@
-		   cy_readb(base_addr+(CyGFRCR<<index)));
+		   readb(base_addr+(CyGFRCR<<index)));
@@ -4649,0 +4651,5 @@
+		if (cy_isa_address == NULL) {
+			printk(KERN_ERR "Cyclom-Y/ISA: can't remap base "
+					"address\n");
+			continue;
+		}
@@ -4652,0 +4659 @@
+			iounmap(cy_isa_address);
@@ -4663 +4670,2 @@
-			printk("Cyclom-Y/ISA found at 0x%lx ",
+			printk(KERN_ERR "Cyclom-Y/ISA found at 0x%lx, but the "
+				"IRQ could not be detected.\n",
@@ -4665 +4673 @@
-			printk("but the IRQ could not be detected.\n");
+			iounmap(cy_isa_address);
@@ -4670 +4678,3 @@
-			printk("Cyclom-Y/ISA found at 0x%lx ",
+			printk(KERN_ERR "Cyclom-Y/ISA found at 0x%lx, but no "
+				"more channels are available. Change NR_PORTS "
+				"in cyclades.c and recompile kernel.\n",
@@ -4672,3 +4682 @@
-			printk("but no more channels are available.\n");
-			printk("Change NR_PORTS in cyclades.c and recompile "
-					"kernel.\n");
+			iounmap(cy_isa_address);
@@ -4679 +4687 @@
-			if (cy_card[j].base_addr == 0)
+			if (cy_card[j].base_addr == NULL)
@@ -4683 +4691,3 @@
-			printk("Cyclom-Y/ISA found at 0x%lx ",
+			printk(KERN_ERR "Cyclom-Y/ISA found at 0x%lx, but no "
+				"more cards can be used. Change NR_CARDS in "
+				"cyclades.c and recompile kernel.\n",
@@ -4685,3 +4695 @@
-			printk("but no more cards can be used .\n");
-			printk("Change NR_CARDS in cyclades.c and recompile "
-					"kernel.\n");
+			iounmap(cy_isa_address);
@@ -4694,3 +4702,4 @@
-			printk("Cyclom-Y/ISA found at 0x%lx ",
-				(unsigned long)cy_isa_address);
-			printk("but could not allocate IRQ#%d.\n", cy_isa_irq);
+			printk(KERN_ERR "Cyclom-Y/ISA found at 0x%lx, but "
+				"could not allocate IRQ#%d.\n",
+				(unsigned long)cy_isa_address, cy_isa_irq);
+			iounmap(cy_isa_address);
@@ -4706,0 +4716,6 @@
+		if (cy_init_card(&cy_card[j])) {
+			cy_card[j].base_addr = NULL;
+			free_irq(cy_isa_irq, &cy_card[j]);
+			iounmap(cy_isa_address);
+			continue;
+		}
@@ -4709,2 +4724,2 @@
-		/* print message */
-		printk("Cyclom-Y/ISA #%d: 0x%lx-0x%lx, IRQ%d, ",
+		printk(KERN_INFO "Cyclom-Y/ISA #%d: 0x%lx-0x%lx, IRQ%d found: "
+			"%d channels starting from port %d\n",
@@ -4713,3 +4728,5 @@
-			cy_isa_irq);
-		printk("%d channels starting from port %d.\n",
-			cy_isa_nchan, cy_next_channel);
+			cy_isa_irq, cy_isa_nchan, cy_next_channel);
+
+		for (j = cy_next_channel;
+				j < cy_next_channel + cy_isa_nchan; j++)
+			tty_register_device(cy_serial_driver, j, NULL);
@@ -4724 +4741,2 @@
-static void plx_init(void __iomem * addr, uclong initctl)
+#ifdef CONFIG_PCI
+static void __devinit plx_init(void __iomem * addr, __u32 initctl)
@@ -4727 +4745 @@
-	cy_writel(addr + initctl, cy_readl(addr + initctl) | 0x40000000);
+	cy_writel(addr + initctl, readl(addr + initctl) | 0x40000000);
@@ -4729 +4747 @@
-	cy_writel(addr + initctl, cy_readl(addr + initctl) & ~0x40000000);
+	cy_writel(addr + initctl, readl(addr + initctl) & ~0x40000000);
@@ -4732 +4750 @@
-	cy_writel(addr + initctl, cy_readl(addr + initctl) | 0x20000000);
+	cy_writel(addr + initctl, readl(addr + initctl) | 0x20000000);
@@ -4734 +4752 @@
-	cy_writel(addr + initctl, cy_readl(addr + initctl) & ~0x20000000);
+	cy_writel(addr + initctl, readl(addr + initctl) & ~0x20000000);
@@ -4737,7 +4755,2 @@
-/*
- * ---------------------------------------------------------------------
- * cy_detect_pci() - Test PCI bus presence and Cyclom-Ye/PCI.
- * sets global variables and return the number of PCI boards found.
- * ---------------------------------------------------------------------
- */
-static int __init cy_detect_pci(void)
+static int __devinit cy_pci_probe(struct pci_dev *pdev,
+		const struct pci_device_id *ent)
@@ -4745 +4758,6 @@
-#ifdef CONFIG_PCI
+	void __iomem *addr0 = NULL, *addr2 = NULL;
+	char *card_name = NULL;
+	u32 mailbox;
+	unsigned int device_id, nchan = 0, card_no, i;
+	unsigned char plx_ver;
+	int retval, irq;
@@ -4747,13 +4765,5 @@
-	struct pci_dev *pdev = NULL;
-	unsigned char cyy_rev_id;
-	unsigned char cy_pci_irq = 0;
-	uclong cy_pci_phys0, cy_pci_phys2;
-	void __iomem *cy_pci_addr0, *cy_pci_addr2;
-	unsigned short i, j, cy_pci_nchan, plx_ver;
-	unsigned short device_id, dev_index = 0;
-	uclong mailbox;
-	uclong ZeIndex = 0;
-	void __iomem *Ze_addr0[NR_CARDS], *Ze_addr2[NR_CARDS];
-	uclong Ze_phys0[NR_CARDS], Ze_phys2[NR_CARDS];
-	unsigned char Ze_irq[NR_CARDS];
-	struct pci_dev *Ze_pdev[NR_CARDS];
+	retval = pci_enable_device(pdev);
+	if (retval) {
+		dev_err(&pdev->dev, "cannot enable device\n");
+		goto err;
+	}
@@ -4761,10 +4771,3 @@
-	for (i = 0; i < NR_CARDS; i++) {
-		/* look for a Cyclades card by vendor and device id */
-		while ((device_id = cy_pci_dev_id[dev_index].device) != 0) {
-			if ((pdev = pci_get_device(PCI_VENDOR_ID_CYCLADES,
-						   device_id, pdev)) == NULL) {
-				dev_index++;	/* try next device id */
-			} else {
-				break;	/* found a board */
-			}
-		}
+	/* read PCI configuration area */
+	irq = pdev->irq;
+	device_id = pdev->device & ~PCI_DEVICE_ID_MASK;
@@ -4772,2 +4775,14 @@
-		if (device_id == 0)
-			break;
+#if defined(__alpha__)
+	if (device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo) {	/* below 1M? */
+		dev_err(&pdev->dev, "Cyclom-Y/PCI not supported for low "
+			"addresses on Alpha systems.\n");
+		retval = -EIO;
+		goto err_dis;
+	}
+#endif
+	if (device_id == PCI_DEVICE_ID_CYCLOM_Z_Lo) {
+		dev_err(&pdev->dev, "Cyclades-Z/PCI not supported for low "
+			"addresses\n");
+		retval = -EIO;
+		goto err_dis;
+	}
@@ -4775,2 +4790,5 @@
-		if (pci_enable_device(pdev))
-			continue;
+	if (pci_resource_flags(pdev, 2) & IORESOURCE_IO) {
+		dev_warn(&pdev->dev, "PCI I/O bit incorrectly set. Ignoring "
+				"it...\n");
+		pdev->resource[2].flags &= ~IORESOURCE_IO;
+	}
@@ -4778,5 +4796,5 @@
-		/* read PCI configuration area */
-		cy_pci_irq = pdev->irq;
-		cy_pci_phys0 = pci_resource_start(pdev, 0);
-		cy_pci_phys2 = pci_resource_start(pdev, 2);
-		pci_read_config_byte(pdev, PCI_REVISION_ID, &cyy_rev_id);
+	retval = pci_request_regions(pdev, "cyclades");
+	if (retval) {
+		dev_err(&pdev->dev, "failed to reserve resources\n");
+		goto err_dis;
+	}
@@ -4784 +4802,4 @@
-		device_id &= ~PCI_DEVICE_ID_MASK;
+	retval = -EIO;
+	if (device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo ||
+			device_id == PCI_DEVICE_ID_CYCLOM_Y_Hi) {
+		card_name = "Cyclom-Y";
@@ -4786,44 +4807,10 @@
-		if (device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo ||
-				device_id == PCI_DEVICE_ID_CYCLOM_Y_Hi) {
-#ifdef CY_PCI_DEBUG
-			printk("Cyclom-Y/PCI (bus=0x0%x, pci_id=0x%x, ",
-				pdev->bus->number, pdev->devfn);
-			printk("rev_id=%d) IRQ%d\n",
-				cyy_rev_id, (int)cy_pci_irq);
-			printk("Cyclom-Y/PCI:found  winaddr=0x%lx "
-				"ctladdr=0x%lx\n",
-				(ulong)cy_pci_phys2, (ulong)cy_pci_phys0);
-#endif
-
-			if (pci_resource_flags(pdev, 2) & IORESOURCE_IO) {
-				printk("  Warning: PCI I/O bit incorrectly "
-					"set. Ignoring it...\n");
-				pdev->resource[2].flags &= ~IORESOURCE_IO;
-			}
-
-			/* Although we don't use this I/O region, we should
-			   request it from the kernel anyway, to avoid problems
-			   with other drivers accessing it. */
-			if (pci_request_regions(pdev, "Cyclom-Y") != 0) {
-				printk(KERN_ERR "cyclades: failed to reserve "
-						"PCI resources\n");
-				continue;
-			}
-#if defined(__alpha__)
-			if (device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo) {	/* below 1M? */
-				printk("Cyclom-Y/PCI (bus=0x0%x, pci_id=0x%x, ",
-					pdev->bus->number, pdev->devfn);
-				printk("rev_id=%d) IRQ%d\n",
-					cyy_rev_id, (int)cy_pci_irq);
-				printk("Cyclom-Y/PCI:found  winaddr=0x%lx "
-					"ctladdr=0x%lx\n",
-					(ulong)cy_pci_phys2,
-					(ulong)cy_pci_phys0);
-				printk("Cyclom-Y/PCI not supported for low "
-					"addresses in Alpha systems.\n");
-				i--;
-				continue;
-			}
-#endif
-			cy_pci_addr0 = ioremap(cy_pci_phys0, CyPCI_Yctl);
-			cy_pci_addr2 = ioremap(cy_pci_phys2, CyPCI_Ywin);
+		addr0 = pci_iomap(pdev, 0, CyPCI_Yctl);
+		if (addr0 == NULL) {
+			dev_err(&pdev->dev, "can't remap ctl region\n");
+			goto err_reg;
+		}
+		addr2 = pci_iomap(pdev, 2, CyPCI_Ywin);
+		if (addr2 == NULL) {
+			dev_err(&pdev->dev, "can't remap base region\n");
+			goto err_unmap;
+		}
@@ -4831,61 +4818,8 @@
-#ifdef CY_PCI_DEBUG
-			printk("Cyclom-Y/PCI: relocate winaddr=0x%lx "
-				"ctladdr=0x%lx\n",
-				(u_long)cy_pci_addr2, (u_long)cy_pci_addr0);
-#endif
-			cy_pci_nchan = (unsigned short)(CyPORTS_PER_CHIP *
-					cyy_init_card(cy_pci_addr2, 1));
-			if (cy_pci_nchan == 0) {
-				printk("Cyclom-Y PCI host card with ");
-				printk("no Serial-Modules at 0x%lx.\n",
-					(ulong) cy_pci_phys2);
-				i--;
-				continue;
-			}
-			if ((cy_next_channel + cy_pci_nchan) > NR_PORTS) {
-				printk("Cyclom-Y/PCI found at 0x%lx ",
-					(ulong) cy_pci_phys2);
-				printk("but no channels are available.\n");
-				printk("Change NR_PORTS in cyclades.c and "
-						"recompile kernel.\n");
-				return i;
-			}
-			/* fill the next cy_card structure available */
-			for (j = 0; j < NR_CARDS; j++) {
-				if (cy_card[j].base_addr == 0)
-					break;
-			}
-			if (j == NR_CARDS) {	/* no more cy_cards available */
-				printk("Cyclom-Y/PCI found at 0x%lx ",
-					(ulong) cy_pci_phys2);
-				printk("but no more cards can be used.\n");
-				printk("Change NR_CARDS in cyclades.c and "
-						"recompile kernel.\n");
-				return i;
-			}
-
-			/* allocate IRQ */
-			if (request_irq(cy_pci_irq, cyy_interrupt,
-					IRQF_SHARED, "Cyclom-Y", &cy_card[j])) {
-				printk("Cyclom-Y/PCI found at 0x%lx ",
-					(ulong) cy_pci_phys2);
-				printk("but could not allocate IRQ%d.\n",
-					cy_pci_irq);
-				return i;
-			}
-
-			/* set cy_card */
-			cy_card[j].base_phys = (ulong) cy_pci_phys2;
-			cy_card[j].ctl_phys = (ulong) cy_pci_phys0;
-			cy_card[j].base_addr = cy_pci_addr2;
-			cy_card[j].ctl_addr = cy_pci_addr0;
-			cy_card[j].irq = (int)cy_pci_irq;
-			cy_card[j].bus_index = 1;
-			cy_card[j].first_line = cy_next_channel;
-			cy_card[j].num_chips = cy_pci_nchan / 4;
-			cy_card[j].pdev = pdev;
-
-			/* enable interrupts in the PCI interface */
-			plx_ver = cy_readb(cy_pci_addr2 + CyPLX_VER) & 0x0f;
-			switch (plx_ver) {
-			case PLX_9050:
+		nchan = CyPORTS_PER_CHIP * cyy_init_card(addr2, 1);
+		if (nchan == 0) {
+			dev_err(&pdev->dev, "Cyclom-Y PCI host card with no "
+					"Serial-Modules\n");
+			return -EIO;
+		}
+	} else if (device_id == PCI_DEVICE_ID_CYCLOM_Z_Hi) {
+		struct RUNTIME_9060 __iomem *ctl_addr;
@@ -4893,2 +4827,5 @@
-				cy_writeb(cy_pci_addr0 + 0x4c, 0x43);
-				break;
+		ctl_addr = addr0 = pci_iomap(pdev, 0, CyPCI_Zctl);
+		if (addr0 == NULL) {
+			dev_err(&pdev->dev, "can't remap ctl region\n");
+			goto err_reg;
+		}
@@ -4896,18 +4833,3 @@
-			case PLX_9060:
-			case PLX_9080:
-			default:	/* Old boards, use PLX_9060 */
-
-				plx_init(cy_pci_addr0, 0x6c);
-			/* For some yet unknown reason, once the PLX9060 reloads
-			   the EEPROM, the IRQ is lost and, thus, we have to
-			   re-write it to the PCI config. registers.
-			   This will remain here until we find a permanent
-			   fix. */
-				pci_write_config_byte(pdev, PCI_INTERRUPT_LINE,
-						cy_pci_irq);
-
-				cy_writew(cy_pci_addr0 + 0x68,
-					  cy_readw(cy_pci_addr0 +
-						   0x68) | 0x0900);
-				break;
-			}
+		/* Disable interrupts on the PLX before resetting it */
+		cy_writew(addr0 + 0x68,
+			readw(addr0 + 0x68) & ~0x0900);
@@ -4915,89 +4837,24 @@
-			/* print message */
-			printk("Cyclom-Y/PCI #%d: 0x%lx-0x%lx, IRQ%d, ",
-				j + 1, (ulong)cy_pci_phys2,
-				(ulong) (cy_pci_phys2 + CyPCI_Ywin - 1),
-				(int)cy_pci_irq);
-			printk("%d channels starting from port %d.\n",
-				cy_pci_nchan, cy_next_channel);
-
-			cy_next_channel += cy_pci_nchan;
-		} else if (device_id == PCI_DEVICE_ID_CYCLOM_Z_Lo) {
-			/* print message */
-			printk("Cyclades-Z/PCI (bus=0x0%x, pci_id=0x%x, ",
-				pdev->bus->number, pdev->devfn);
-			printk("rev_id=%d) IRQ%d\n",
-				cyy_rev_id, (int)cy_pci_irq);
-			printk("Cyclades-Z/PCI: found winaddr=0x%lx "
-				"ctladdr=0x%lx\n",
-				(ulong)cy_pci_phys2, (ulong)cy_pci_phys0);
-			printk("Cyclades-Z/PCI not supported for low "
-				"addresses\n");
-			break;
-		} else if (device_id == PCI_DEVICE_ID_CYCLOM_Z_Hi) {
-#ifdef CY_PCI_DEBUG
-			printk("Cyclades-Z/PCI (bus=0x0%x, pci_id=0x%x, ",
-				pdev->bus->number, pdev->devfn);
-			printk("rev_id=%d) IRQ%d\n",
-				cyy_rev_id, (int)cy_pci_irq);
-			printk("Cyclades-Z/PCI: found winaddr=0x%lx "
-				"ctladdr=0x%lx\n",
-				(ulong) cy_pci_phys2, (ulong) cy_pci_phys0);
-#endif
-			cy_pci_addr0 = ioremap(cy_pci_phys0, CyPCI_Zctl);
-
-			/* Disable interrupts on the PLX before resetting it */
-			cy_writew(cy_pci_addr0 + 0x68,
-				cy_readw(cy_pci_addr0 + 0x68) & ~0x0900);
-
-			plx_init(cy_pci_addr0, 0x6c);
-			/* For some yet unknown reason, once the PLX9060 reloads
-			   the EEPROM, the IRQ is lost and, thus, we have to
-			   re-write it to the PCI config. registers.
-			   This will remain here until we find a permanent
-			   fix. */
-			pci_write_config_byte(pdev, PCI_INTERRUPT_LINE,
-						cy_pci_irq);
-
-			mailbox =
-			    (uclong)cy_readl(&((struct RUNTIME_9060 __iomem *)
-						cy_pci_addr0)->mail_box_0);
-
-			if (pci_resource_flags(pdev, 2) & IORESOURCE_IO) {
-				printk("  Warning: PCI I/O bit incorrectly "
-					"set. Ignoring it...\n");
-				pdev->resource[2].flags &= ~IORESOURCE_IO;
-			}
-
-			/* Although we don't use this I/O region, we should
-			   request it from the kernel anyway, to avoid problems
-			   with other drivers accessing it. */
-			if (pci_request_regions(pdev, "Cyclades-Z") != 0) {
-				printk(KERN_ERR "cyclades: failed to reserve "
-					"PCI resources\n");
-				continue;
-			}
-
-			if (mailbox == ZE_V1) {
-				cy_pci_addr2 = ioremap(cy_pci_phys2,
-						CyPCI_Ze_win);
-				if (ZeIndex == NR_CARDS) {
-					printk("Cyclades-Ze/PCI found at "
-						"0x%lx but no more cards can "
-						"be used.\nChange NR_CARDS in "
-						"cyclades.c and recompile "
-						"kernel.\n",
-						(ulong)cy_pci_phys2);
-				} else {
-					Ze_phys0[ZeIndex] = cy_pci_phys0;
-					Ze_phys2[ZeIndex] = cy_pci_phys2;
-					Ze_addr0[ZeIndex] = cy_pci_addr0;
-					Ze_addr2[ZeIndex] = cy_pci_addr2;
-					Ze_irq[ZeIndex] = cy_pci_irq;
-					Ze_pdev[ZeIndex] = pdev;
-					ZeIndex++;
-				}
-				i--;
-				continue;
-			} else {
-				cy_pci_addr2 = ioremap(cy_pci_phys2,CyPCI_Zwin);
-			}
+		plx_init(addr0, 0x6c);
+		/* For some yet unknown reason, once the PLX9060 reloads
+		   the EEPROM, the IRQ is lost and, thus, we have to
+		   re-write it to the PCI config. registers.
+		   This will remain here until we find a permanent
+		   fix. */
+		pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, irq);
+
+		mailbox = (u32)readl(&ctl_addr->mail_box_0);
+
+		addr2 = pci_iomap(pdev, 2, mailbox == ZE_V1 ?
+				CyPCI_Ze_win : CyPCI_Zwin);
+		if (addr2 == NULL) {
+			dev_err(&pdev->dev, "can't remap base region\n");
+			goto err_unmap;
+		}
+
+		if (mailbox == ZE_V1) {
+			card_name = "Cyclades-Ze";
+
+			readl(&ctl_addr->mail_box_0);
+			nchan = ZE_V1_NPORTS;
+		} else {
+			card_name = "Cyclades-8Zo";
@@ -5006,3 +4862,0 @@
-			printk("Cyclades-Z/PCI: relocate winaddr=0x%lx "
-				"ctladdr=0x%lx\n",
-				(ulong) cy_pci_addr2, (ulong) cy_pci_addr0);
@@ -5010,15 +4864,8 @@
-				cy_writel(&((struct RUNTIME_9060 *)
-					(cy_pci_addr0))->loc_addr_base,
-					WIN_CREG);
-				PAUSE;
-				printk("Cyclades-8Zo/PCI: FPGA id %lx, ver "
-					"%lx\n", (ulong) (0xff &
-					cy_readl(&((struct CUSTOM_REG *)
-						(cy_pci_addr2))->fpga_id)),
-					(ulong)(0xff &
-					cy_readl(&((struct CUSTOM_REG *)
-						(cy_pci_addr2))->
-							fpga_version)));
-				cy_writel(&((struct RUNTIME_9060 *)
-					(cy_pci_addr0))->loc_addr_base,
-					WIN_RAM);
+				cy_writel(&ctl_addr->loc_addr_base, WIN_CREG);
+				dev_info(&pdev->dev, "Cyclades-8Zo/PCI: FPGA "
+					"id %lx, ver %lx\n", (ulong)(0xff &
+					readl(&((struct CUSTOM_REG *)addr2)->
+						fpga_id)), (ulong)(0xff &
+					readl(&((struct CUSTOM_REG *)addr2)->
+						fpga_version)));
+				cy_writel(&ctl_addr->loc_addr_base, WIN_RAM);
@@ -5026,2 +4873,2 @@
-				printk("Cyclades-Z/PCI: New Cyclades-Z board.  "
-						"FPGA not loaded\n");
+				dev_info(&pdev->dev, "Cyclades-Z/PCI: New "
+					"Cyclades-Z board.  FPGA not loaded\n");
@@ -5034 +4880,0 @@
-			PAUSE;
@@ -5036 +4882 @@
-				cy_writel(cy_pci_addr2 + ID_ADDRESS, 0L);
+				cy_writel(addr2 + ID_ADDRESS, 0L);
@@ -5041,65 +4887 @@
-			cy_pci_nchan = 8;
-
-			if ((cy_next_channel + cy_pci_nchan) > NR_PORTS) {
-				printk("Cyclades-8Zo/PCI found at 0x%lx but"
-					"no channels are available.\nChange "
-					"NR_PORTS in cyclades.c and recompile "
-					"kernel.\n", (ulong)cy_pci_phys2);
-				return i;
-			}
-
-			/* fill the next cy_card structure available */
-			for (j = 0; j < NR_CARDS; j++) {
-				if (cy_card[j].base_addr == 0)
-					break;
-			}
-			if (j == NR_CARDS) {	/* no more cy_cards available */
-				printk("Cyclades-8Zo/PCI found at 0x%lx but"
-					"no more cards can be used.\nChange "
-					"NR_CARDS in cyclades.c and recompile "
-					"kernel.\n", (ulong)cy_pci_phys2);
-				return i;
-			}
-#ifdef CONFIG_CYZ_INTR
-			/* allocate IRQ only if board has an IRQ */
-			if ((cy_pci_irq != 0) && (cy_pci_irq != 255)) {
-				if (request_irq(cy_pci_irq, cyz_interrupt,
-						IRQF_SHARED, "Cyclades-Z",
-						&cy_card[j])) {
-					printk("Cyclom-8Zo/PCI found at 0x%lx "
-						"but could not allocate "
-						"IRQ%d.\n", (ulong)cy_pci_phys2,
-						cy_pci_irq);
-					return i;
-				}
-			}
-#endif				/* CONFIG_CYZ_INTR */
-
-			/* set cy_card */
-			cy_card[j].base_phys = cy_pci_phys2;
-			cy_card[j].ctl_phys = cy_pci_phys0;
-			cy_card[j].base_addr = cy_pci_addr2;
-			cy_card[j].ctl_addr = cy_pci_addr0;
-			cy_card[j].irq = (int)cy_pci_irq;
-			cy_card[j].bus_index = 1;
-			cy_card[j].first_line = cy_next_channel;
-			cy_card[j].num_chips = -1;
-			cy_card[j].pdev = pdev;
-
-			/* print message */
-#ifdef CONFIG_CYZ_INTR
-			/* don't report IRQ if board is no IRQ */
-			if ((cy_pci_irq != 0) && (cy_pci_irq != 255))
-				printk("Cyclades-8Zo/PCI #%d: 0x%lx-0x%lx, "
-					"IRQ%d, ", j + 1, (ulong)cy_pci_phys2,
-					(ulong) (cy_pci_phys2 + CyPCI_Zwin - 1),
-					(int)cy_pci_irq);
-			else
-#endif				/* CONFIG_CYZ_INTR */
-				printk("Cyclades-8Zo/PCI #%d: 0x%lx-0x%lx, ",
-					j + 1, (ulong)cy_pci_phys2,
-					(ulong)(cy_pci_phys2 + CyPCI_Zwin - 1));
-
-			printk("%d channels starting from port %d.\n",
-					cy_pci_nchan, cy_next_channel);
-			cy_next_channel += cy_pci_nchan;
+			nchan = 8;
@@ -5109,35 +4891,17 @@
-	for (; ZeIndex != 0 && i < NR_CARDS; i++) {
-		cy_pci_phys0 = Ze_phys0[0];
-		cy_pci_phys2 = Ze_phys2[0];
-		cy_pci_addr0 = Ze_addr0[0];
-		cy_pci_addr2 = Ze_addr2[0];
-		cy_pci_irq = Ze_irq[0];
-		pdev = Ze_pdev[0];
-		for (j = 0; j < ZeIndex - 1; j++) {
-			Ze_phys0[j] = Ze_phys0[j + 1];
-			Ze_phys2[j] = Ze_phys2[j + 1];
-			Ze_addr0[j] = Ze_addr0[j + 1];
-			Ze_addr2[j] = Ze_addr2[j + 1];
-			Ze_irq[j] = Ze_irq[j + 1];
-			Ze_pdev[j] = Ze_pdev[j + 1];
-		}
-		ZeIndex--;
-		mailbox = (uclong)cy_readl(&((struct RUNTIME_9060 __iomem *)
-						cy_pci_addr0)->mail_box_0);
-#ifdef CY_PCI_DEBUG
-		printk("Cyclades-Z/PCI: relocate winaddr=0x%lx ctladdr=0x%lx\n",
-			(ulong)cy_pci_addr2, (ulong)cy_pci_addr0);
-		printk("Cyclades-Z/PCI: New Cyclades-Z board.  FPGA not "
-				"loaded\n");
-#endif
-		PAUSE;
-		/* This must be the new Cyclades-Ze/PCI. */
-		cy_pci_nchan = ZE_V1_NPORTS;
-
-		if ((cy_next_channel + cy_pci_nchan) > NR_PORTS) {
-			printk("Cyclades-Ze/PCI found at 0x%lx but no channels "
-				"are available.\nChange NR_PORTS in cyclades.c "
-				"and recompile kernel.\n",
-				(ulong) cy_pci_phys2);
-			return i;
-		}
+	if ((cy_next_channel + nchan) > NR_PORTS) {
+		dev_err(&pdev->dev, "Cyclades-8Zo/PCI found, but no "
+			"channels are available. Change NR_PORTS in "
+			"cyclades.c and recompile kernel.\n");
+		goto err_unmap;
+	}
+	/* fill the next cy_card structure available */
+	for (card_no = 0; card_no < NR_CARDS; card_no++) {
+		if (cy_card[card_no].base_addr == NULL)
+			break;
+	}
+	if (card_no == NR_CARDS) {	/* no more cy_cards available */
+		dev_err(&pdev->dev, "Cyclades-8Zo/PCI found, but no "
+			"more cards can be used. Change NR_CARDS in "
+			"cyclades.c and recompile kernel.\n");
+		goto err_unmap;
+	}
@@ -5145,11 +4909,8 @@
-		/* fill the next cy_card structure available */
-		for (j = 0; j < NR_CARDS; j++) {
-			if (cy_card[j].base_addr == 0)
-				break;
-		}
-		if (j == NR_CARDS) {	/* no more cy_cards available */
-			printk("Cyclades-Ze/PCI found at 0x%lx but no more "
-				"cards can be used.\nChange NR_CARDS in "
-				"cyclades.c and recompile kernel.\n",
-				(ulong) cy_pci_phys2);
-			return i;
+	if (device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo ||
+			device_id == PCI_DEVICE_ID_CYCLOM_Y_Hi) {
+		/* allocate IRQ */
+		retval = request_irq(irq, cyy_interrupt,
+				IRQF_SHARED, "Cyclom-Y", &cy_card[card_no]);
+		if (retval) {
+			dev_err(&pdev->dev, "could not allocate IRQ\n");
+			goto err_unmap;
@@ -5156,0 +4918,2 @@
+		cy_card[card_no].num_chips = nchan / 4;
+	} else {
@@ -5159,2 +4922,2 @@
-		if ((cy_pci_irq != 0) && (cy_pci_irq != 255)) {
-			if (request_irq(cy_pci_irq, cyz_interrupt,
+		if (irq != 0 && irq != 255) {
+			retval = request_irq(irq, cyz_interrupt,
@@ -5162,6 +4925,4 @@
-					&cy_card[j])) {
-				printk("Cyclom-Ze/PCI found at 0x%lx ",
-					(ulong) cy_pci_phys2);
-				printk("but could not allocate IRQ%d.\n",
-					cy_pci_irq);
-				return i;
+					&cy_card[card_no]);
+			if (retval) {
+				dev_err(&pdev->dev, "could not allocate IRQ\n");
+				goto err_unmap;
@@ -5170,0 +4932,2 @@
+		cy_card[card_no].num_chips = -1;
+	}
@@ -5172,10 +4935,9 @@
-		/* set cy_card */
-		cy_card[j].base_phys = cy_pci_phys2;
-		cy_card[j].ctl_phys = cy_pci_phys0;
-		cy_card[j].base_addr = cy_pci_addr2;
-		cy_card[j].ctl_addr = cy_pci_addr0;
-		cy_card[j].irq = (int)cy_pci_irq;
-		cy_card[j].bus_index = 1;
-		cy_card[j].first_line = cy_next_channel;
-		cy_card[j].num_chips = -1;
-		cy_card[j].pdev = pdev;
+	/* set cy_card */
+	cy_card[card_no].base_addr = addr2;
+	cy_card[card_no].ctl_addr = addr0;
+	cy_card[card_no].irq = irq;
+	cy_card[card_no].bus_index = 1;
+	cy_card[card_no].first_line = cy_next_channel;
+	retval = cy_init_card(&cy_card[card_no]);
+	if (retval)
+		goto err_null;
@@ -5183,22 +4945,27 @@
-		/* print message */
-#ifdef CONFIG_CYZ_INTR
-		/* don't report IRQ if board is no IRQ */
-		if ((cy_pci_irq != 0) && (cy_pci_irq != 255))
-			printk("Cyclades-Ze/PCI #%d: 0x%lx-0x%lx, IRQ%d, ",
-				j + 1, (ulong) cy_pci_phys2,
-				(ulong) (cy_pci_phys2 + CyPCI_Ze_win - 1),
-				(int)cy_pci_irq);
-		else
-#endif				/* CONFIG_CYZ_INTR */
-			printk("Cyclades-Ze/PCI #%d: 0x%lx-0x%lx, ",
-				j + 1, (ulong) cy_pci_phys2,
-				(ulong) (cy_pci_phys2 + CyPCI_Ze_win - 1));
-
-		printk("%d channels starting from port %d.\n",
-			cy_pci_nchan, cy_next_channel);
-		cy_next_channel += cy_pci_nchan;
-	}
-	if (ZeIndex != 0) {
-		printk("Cyclades-Ze/PCI found at 0x%x but no more cards can be "
-			"used.\nChange NR_CARDS in cyclades.c and recompile "
-			"kernel.\n", (unsigned int)Ze_phys2[0]);
+	pci_set_drvdata(pdev, &cy_card[card_no]);
+
+	if (device_id == PCI_DEVICE_ID_CYCLOM_Y_Lo ||
+			device_id == PCI_DEVICE_ID_CYCLOM_Y_Hi) {
+		/* enable interrupts in the PCI interface */
+		plx_ver = readb(addr2 + CyPLX_VER) & 0x0f;
+		switch (plx_ver) {
+		case PLX_9050:
+
+			cy_writeb(addr0 + 0x4c, 0x43);
+			break;
+
+		case PLX_9060:
+		case PLX_9080:
+		default:	/* Old boards, use PLX_9060 */
+
+			plx_init(addr0, 0x6c);
+		/* For some yet unknown reason, once the PLX9060 reloads
+		   the EEPROM, the IRQ is lost and, thus, we have to
+		   re-write it to the PCI config. registers.
+		   This will remain here until we find a permanent
+		   fix. */
+			pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, irq);
+
+			cy_writew(addr0 + 0x68, readw(addr0 + 0x68) | 0x0900);
+			break;
+		}
@@ -5206,2 +4973,7 @@
-	return i;
-#else
+
+	dev_info(&pdev->dev, "%s/PCI #%d found: %d channels starting from "
+		"port %d.\n", card_name, card_no + 1, nchan, cy_next_channel);
+	for (i = cy_next_channel; i < cy_next_channel + nchan; i++)
+		tty_register_device(cy_serial_driver, i, &pdev->dev);
+	cy_next_channel += nchan;
+
@@ -5209,2 +4981,14 @@
-#endif				/* ifdef CONFIG_PCI */
-}				/* cy_detect_pci */
+err_null:
+	cy_card[card_no].base_addr = NULL;
+	free_irq(irq, &cy_card[card_no]);
+err_unmap:
+	pci_iounmap(pdev, addr0);
+	if (addr2)
+		pci_iounmap(pdev, addr2);
+err_reg:
+	pci_release_regions(pdev);
+err_dis:
+	pci_disable_device(pdev);
+err:
+	return retval;
+}
@@ -5212,5 +4996 @@
-/*
- * This routine prints out the appropriate serial driver version number
- * and identifies which options were configured into this driver.
- */
-static inline void show_version(void)
+static void __devexit cy_pci_remove(struct pci_dev *pdev)
@@ -5218,3 +4998,40 @@
-	printk("Cyclades driver " CY_VERSION "\n");
-	printk("        built %s %s\n", __DATE__, __TIME__);
-}				/* show_version */
+	struct cyclades_card *cinfo = pci_get_drvdata(pdev);
+	unsigned int i;
+
+	/* non-Z with old PLX */
+	if (!IS_CYC_Z(*cinfo) && (readb(cinfo->base_addr + CyPLX_VER) & 0x0f) ==
+			PLX_9050)
+		cy_writeb(cinfo->ctl_addr + 0x4c, 0);
+	else
+#ifndef CONFIG_CYZ_INTR
+		if (!IS_CYC_Z(*cinfo))
+#endif
+		cy_writew(cinfo->ctl_addr + 0x68,
+				readw(cinfo->ctl_addr + 0x68) & ~0x0900);
+
+	pci_iounmap(pdev, cinfo->base_addr);
+	if (cinfo->ctl_addr)
+		pci_iounmap(pdev, cinfo->ctl_addr);
+	if (cinfo->irq
+#ifndef CONFIG_CYZ_INTR
+		&& !IS_CYC_Z(*cinfo)
+#endif /* CONFIG_CYZ_INTR */
+		)
+		free_irq(cinfo->irq, cinfo);
+	pci_release_regions(pdev);
+
+	cinfo->base_addr = NULL;
+	for (i = cinfo->first_line; i < cinfo->first_line +
+			cinfo->nports; i++)
+		tty_unregister_device(cy_serial_driver, i);
+	cinfo->nports = 0;
+	kfree(cinfo->ports);
+}
+
+static struct pci_driver cy_pci_driver = {
+	.name = "cyclades",
+	.id_table = cy_pci_dev_id,
+	.probe = cy_pci_probe,
+	.remove = __devexit_p(cy_pci_remove)
+};
+#endif
@@ -5227 +5044 @@
-	int i;
+	unsigned int i, j;
@@ -5241,23 +5058,27 @@
-	for (i = 0; i < NR_PORTS && cy_port[i].line >= 0; i++) {
-		info = &cy_port[i];
-
-		if (info->count)
-			size = sprintf(buf + len, "%3d %8lu %10lu %8lu %10lu "
-				"%8lu %9lu %6ld\n", info->line,
-				(cur_jifs - info->idle_stats.in_use) / HZ,
-				info->idle_stats.xmit_bytes,
-				(cur_jifs - info->idle_stats.xmit_idle) / HZ,
-				info->idle_stats.recv_bytes,
-				(cur_jifs - info->idle_stats.recv_idle) / HZ,
-				info->idle_stats.overruns,
-				(long)info->tty->ldisc.num);
-		else
-			size = sprintf(buf + len, "%3d %8lu %10lu %8lu %10lu "
-				"%8lu %9lu %6ld\n",
-				info->line, 0L, 0L, 0L, 0L, 0L, 0L, 0L);
-		len += size;
-		pos = begin + len;
-
-		if (pos < offset) {
-			len = 0;
-			begin = pos;
+	for (i = 0; i < NR_CARDS; i++)
+		for (j = 0; j < cy_card[i].nports; j++) {
+			info = &cy_card[i].ports[j];
+
+			if (info->count)
+				size = sprintf(buf + len, "%3d %8lu %10lu %8lu "
+					"%10lu %8lu %9lu %6ld\n", info->line,
+					(cur_jifs - info->idle_stats.in_use) /
+					HZ, info->idle_stats.xmit_bytes,
+					(cur_jifs - info->idle_stats.xmit_idle)/
+					HZ, info->idle_stats.recv_bytes,
+					(cur_jifs - info->idle_stats.recv_idle)/
+					HZ, info->idle_stats.overruns,
+					(long)info->tty->ldisc.num);
+			else
+				size = sprintf(buf + len, "%3d %8lu %10lu %8lu "
+					"%10lu %8lu %9lu %6ld\n",
+					info->line, 0L, 0L, 0L, 0L, 0L, 0L, 0L);
+			len += size;
+			pos = begin + len;
+
+			if (pos < offset) {
+				len = 0;
+				begin = pos;
+			}
+			if (pos > offset + length)
+				goto done;
@@ -5265,3 +5085,0 @@
-		if (pos > offset + length)
-			goto done;
-	}
@@ -5322,7 +5140,2 @@
-	struct cyclades_port *info;
-	struct cyclades_card *cinfo;
-	int number_z_boards = 0;
-	int board, port, i, index;
-	unsigned long mailbox;
-	unsigned short chip_number;
-	int nports;
+	unsigned int nboards;
+	int retval = -ENOMEM;
@@ -5332,2 +5145,4 @@
-		return -ENOMEM;
-	show_version();
+		goto err;
+
+	printk(KERN_INFO "Cyclades driver " CY_VERSION " (built %s %s)\n",
+			__DATE__, __TIME__);
@@ -5347 +5162 @@
-	cy_serial_driver->flags = TTY_DRIVER_REAL_RAW;
+	cy_serial_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
@@ -5350,6 +5165,4 @@
-	if (tty_register_driver(cy_serial_driver))
-		panic("Couldn't register Cyclades serial driver\n");
-
-	for (i = 0; i < NR_CARDS; i++) {
-		/* base_addr=0 indicates board not found */
-		cy_card[i].base_addr = NULL;
+	retval = tty_register_driver(cy_serial_driver);
+	if (retval) {
+		printk(KERN_ERR "Couldn't register Cyclades serial driver\n");
+		goto err_frtty;
@@ -5366 +5179 @@
-	cy_isa_nboard = cy_detect_isa();
+	nboards = cy_detect_isa();
@@ -5367,0 +5181 @@
+#ifdef CONFIG_PCI
@@ -5369,89 +5183,3 @@
-	cy_pci_nboard = cy_detect_pci();
-
-	cy_nboard = cy_isa_nboard + cy_pci_nboard;
-
-	/* invalidate remaining cy_card structures */
-	for (i = 0; i < NR_CARDS; i++) {
-		if (cy_card[i].base_addr == 0) {
-			cy_card[i].first_line = -1;
-			cy_card[i].ctl_addr = NULL;
-			cy_card[i].irq = 0;
-			cy_card[i].bus_index = 0;
-			cy_card[i].first_line = 0;
-			cy_card[i].num_chips = 0;
-		}
-	}
-	/* invalidate remaining cy_port structures */
-	for (i = cy_next_channel; i < NR_PORTS; i++) {
-		cy_port[i].line = -1;
-		cy_port[i].magic = -1;
-	}
-
-	/* initialize per-port data structures for each valid board found */
-	for (board = 0; board < cy_nboard; board++) {
-		cinfo = &cy_card[board];
-		if (cinfo->num_chips == -1) {	/* Cyclades-Z */
-			number_z_boards++;
-			mailbox = cy_readl(&((struct RUNTIME_9060 __iomem *)
-					     cy_card[board].ctl_addr)->
-					   mail_box_0);
-			nports = (mailbox == ZE_V1) ? ZE_V1_NPORTS : 8;
-			cinfo->intr_enabled = 0;
-			cinfo->nports = 0;	/* Will be correctly set later, after 
-						   Z FW is loaded */
-			spin_lock_init(&cinfo->card_lock);
-			for (port = cinfo->first_line;
-			     port < cinfo->first_line + nports; port++) {
-				info = &cy_port[port];
-				info->magic = CYCLADES_MAGIC;
-				info->type = PORT_STARTECH;
-				info->card = board;
-				info->line = port;
-				info->chip_rev = 0;
-				info->flags = STD_COM_FLAGS;
-				info->tty = NULL;
-				if (mailbox == ZO_V1)
-					info->xmit_fifo_size = CYZ_FIFO_SIZE;
-				else
-					info->xmit_fifo_size =
-					    4 * CYZ_FIFO_SIZE;
-				info->cor1 = 0;
-				info->cor2 = 0;
-				info->cor3 = 0;
-				info->cor4 = 0;
-				info->cor5 = 0;
-				info->tbpr = 0;
-				info->tco = 0;
-				info->rbpr = 0;
-				info->rco = 0;
-				info->custom_divisor = 0;
-				info->close_delay = 5 * HZ / 10;
-				info->closing_wait = CLOSING_WAIT_DELAY;
-				info->icount.cts = info->icount.dsr =
-				    info->icount.rng = info->icount.dcd = 0;
-				info->icount.rx = info->icount.tx = 0;
-				info->icount.frame = info->icount.parity = 0;
-				info->icount.overrun = info->icount.brk = 0;
-				info->x_char = 0;
-				info->event = 0;
-				info->count = 0;
-				info->blocked_open = 0;
-				info->default_threshold = 0;
-				info->default_timeout = 0;
-				INIT_WORK(&info->tqueue, do_softint);
-				init_waitqueue_head(&info->open_wait);
-				init_waitqueue_head(&info->close_wait);
-				init_waitqueue_head(&info->shutdown_wait);
-				init_waitqueue_head(&info->delta_msr_wait);
-				/* info->session */
-				/* info->pgrp */
-				info->read_status_mask = 0;
-				/* info->timeout */
-				/* Bentson's vars */
-				info->jiffies[0] = 0;
-				info->jiffies[1] = 0;
-				info->jiffies[2] = 0;
-				info->rflush_count = 0;
-#ifdef CONFIG_CYZ_INTR
-				init_timer(&cyz_rx_full_timer[port]);
-				cyz_rx_full_timer[port].function = NULL;
+	retval = pci_register_driver(&cy_pci_driver);
+	if (retval && !nboards)
+		goto err_unr;
@@ -5459,82 +5186,0 @@
-			}
-			continue;
-		} else {	/* Cyclom-Y of some kind */
-			index = cinfo->bus_index;
-			spin_lock_init(&cinfo->card_lock);
-			cinfo->nports = CyPORTS_PER_CHIP * cinfo->num_chips;
-			for (port = cinfo->first_line;
-			     port < cinfo->first_line + cinfo->nports; port++) {
-				info = &cy_port[port];
-				info->magic = CYCLADES_MAGIC;
-				info->type = PORT_CIRRUS;
-				info->card = board;
-				info->line = port;
-				info->flags = STD_COM_FLAGS;
-				info->tty = NULL;
-				info->xmit_fifo_size = CyMAX_CHAR_FIFO;
-				info->cor1 =
-				    CyPARITY_NONE | Cy_1_STOP | Cy_8_BITS;
-				info->cor2 = CyETC;
-				info->cor3 = 0x08;	/* _very_ small rcv threshold */
-				info->cor4 = 0;
-				info->cor5 = 0;
-				info->custom_divisor = 0;
-				info->close_delay = 5 * HZ / 10;
-				info->closing_wait = CLOSING_WAIT_DELAY;
-				info->icount.cts = info->icount.dsr =
-				    info->icount.rng = info->icount.dcd = 0;
-				info->icount.rx = info->icount.tx = 0;
-				info->icount.frame = info->icount.parity = 0;
-				info->icount.overrun = info->icount.brk = 0;
-				chip_number = (port - cinfo->first_line) / 4;
-				if ((info->chip_rev =
-				     cy_readb(cinfo->base_addr +
-					      (cy_chip_offset[chip_number] <<
-					       index) + (CyGFRCR << index))) >=
-				    CD1400_REV_J) {
-					/* It is a CD1400 rev. J or later */
-					info->tbpr = baud_bpr_60[13];	/* Tx BPR */
-					info->tco = baud_co_60[13];	/* Tx CO */
-					info->rbpr = baud_bpr_60[13];	/* Rx BPR */
-					info->rco = baud_co_60[13];	/* Rx CO */
-					info->rflow = 0;
-					info->rtsdtr_inv = 1;
-				} else {
-					info->tbpr = baud_bpr_25[13];	/* Tx BPR */
-					info->tco = baud_co_25[13];	/* Tx CO */
-					info->rbpr = baud_bpr_25[13];	/* Rx BPR */
-					info->rco = baud_co_25[13];	/* Rx CO */
-					info->rflow = 0;
-					info->rtsdtr_inv = 0;
-				}
-				info->x_char = 0;
-				info->event = 0;
-				info->count = 0;
-				info->blocked_open = 0;
-				info->default_threshold = 0;
-				info->default_timeout = 0;
-				INIT_WORK(&info->tqueue, do_softint);
-				init_waitqueue_head(&info->open_wait);
-				init_waitqueue_head(&info->close_wait);
-				init_waitqueue_head(&info->shutdown_wait);
-				init_waitqueue_head(&info->delta_msr_wait);
-				/* info->session */
-				/* info->pgrp */
-				info->read_status_mask =
-				    CyTIMEOUT | CySPECHAR | CyBREAK
-				    | CyPARITY | CyFRAME | CyOVERRUN;
-				/* info->timeout */
-			}
-		}
-	}
-
-#ifndef CONFIG_CYZ_INTR
-	if (number_z_boards && !cyz_timeron) {
-		cyz_timeron++;
-		cyz_timerlist.expires = jiffies + 1;
-		add_timer(&cyz_timerlist);
-#ifdef CY_PCI_DEBUG
-		printk("Cyclades-Z polling initialized\n");
-#endif
-	}
-#endif				/* CONFIG_CYZ_INTR */
@@ -5543 +5189,6 @@
-
+err_unr:
+	tty_unregister_driver(cy_serial_driver);
+err_frtty:
+	put_tty_driver(cy_serial_driver);
+err:
+	return retval;
@@ -5547,0 +5199 @@
+	struct cyclades_card *card;
@@ -5551,4 +5203 @@
-	if (cyz_timeron){
-		cyz_timeron = 0;
-		del_timer(&cyz_timerlist);
-	}
+	del_timer_sync(&cyz_timerlist);
@@ -5558,2 +5207,2 @@
-		printk("cyc: failed to unregister Cyclades serial driver(%d)\n",
-			e1);
+		printk(KERN_ERR "failed to unregister Cyclades serial "
+				"driver(%d)\n", e1);
@@ -5561 +5210,3 @@
-	put_tty_driver(cy_serial_driver);
+#ifdef CONFIG_PCI
+	pci_unregister_driver(&cy_pci_driver);
+#endif
@@ -5564,5 +5215,8 @@
-		if (cy_card[i].base_addr) {
-			iounmap(cy_card[i].base_addr);
-			if (cy_card[i].ctl_addr)
-				iounmap(cy_card[i].ctl_addr);
-			if (cy_card[i].irq
+		card = &cy_card[i];
+		if (card->base_addr) {
+			/* clear interrupt */
+			cy_writeb(card->base_addr + Cy_ClrIntr, 0);
+			iounmap(card->base_addr);
+			if (card->ctl_addr)
+				iounmap(card->ctl_addr);
+			if (card->irq
@@ -5570 +5224 @@
-				&& cy_card[i].num_chips != -1 /* not a Z card */
+				&& !IS_CYC_Z(*card)
@@ -5573,5 +5227,6 @@
-				free_irq(cy_card[i].irq, &cy_card[i]);
-#ifdef CONFIG_PCI
-			if (cy_card[i].pdev)
-				pci_release_regions(cy_card[i].pdev);
-#endif
+				free_irq(card->irq, card);
+			for (e1 = card->first_line;
+					e1 < card->first_line +
+					card->nports; e1++)
+				tty_unregister_device(cy_serial_driver, e1);
+			kfree(card->ports);
@@ -5579,0 +5235,2 @@
+
+	put_tty_driver(cy_serial_driver);
@@ -5585,0 +5243 @@
+MODULE_VERSION(CY_VERSION);
--- ./projects/linux/linux-2.6.22/drivers/char/cyclades.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/cyclades.c	2007-10-09 22:31:38.000000000 +0200
@@ -648,0 +649 @@
+#include <linux/firmware.h>
@@ -682,0 +684,38 @@
+/* firmware stuff */
+#define ZL_MAX_BLOCKS	16
+#define DRIVER_VERSION	0x02010203
+#define RAM_SIZE 0x80000
+
+#define Z_FPGA_LOADED(X)	((readl(&(X)->init_ctrl) & (1<<17)) != 0)
+
+enum zblock_type {
+	ZBLOCK_PRG = 0,
+	ZBLOCK_FPGA = 1
+};
+
+struct zfile_header {
+	char name[64];
+	char date[32];
+	char aux[32];
+	u32 n_config;
+	u32 config_offset;
+	u32 n_blocks;
+	u32 block_offset;
+	u32 reserved[9];
+} __attribute__ ((packed));
+
+struct zfile_config {
+	char name[64];
+	u32 mailbox;
+	u32 function;
+	u32 n_blocks;
+	u32 block_list[ZL_MAX_BLOCKS];
+} __attribute__ ((packed));
+
+struct zfile_block {
+	u32 type;
+	u32 file_offset;
+	u32 ram_offset;
+	u32 size;
+} __attribute__ ((packed));
+
@@ -1854,5 +1893,5 @@
-	static struct FIRM_ID *firm_id;
-	static struct ZFW_CTRL *zfw_ctrl;
-	static struct BOARD_CTRL *board_ctrl;
-	static struct CH_CTRL *ch_ctrl;
-	static struct BUF_CTRL *buf_ctrl;
+	struct FIRM_ID __iomem *firm_id;
+	struct ZFW_CTRL __iomem *zfw_ctrl;
+	struct BOARD_CTRL __iomem *board_ctrl;
+	struct CH_CTRL __iomem *ch_ctrl;
+	struct BUF_CTRL __iomem *buf_ctrl;
@@ -2002 +2040,0 @@
-		int retval;
@@ -2374 +2411,0 @@
-		int retval;
@@ -4130,4 +4166,0 @@
-	if (tty->termios->c_cflag == old_termios->c_cflag &&
-			(tty->termios->c_iflag & (IXON | IXANY)) ==
-			(old_termios->c_iflag & (IXON | IXANY)))
-		return;
@@ -4436 +4469 @@
-	u32 mailbox;
+	u32 uninitialized_var(mailbox);
@@ -4439 +4472 @@
-	int index, port;
+	int uninitialized_var(index), port;
@@ -4742 +4775,26 @@
-static void __devinit plx_init(void __iomem * addr, __u32 initctl)
+static inline int __devinit cyc_isfwstr(const char *str, unsigned int size)
+{
+	unsigned int a;
+
+	for (a = 0; a < size && *str; a++, str++)
+		if (*str & 0x80)
+			return -EINVAL;
+
+	for (; a < size; a++, str++)
+		if (*str)
+			return -EINVAL;
+
+	return 0;
+}
+
+static inline void __devinit cyz_fpga_copy(void __iomem *fpga, u8 *data,
+		unsigned int size)
+{
+	for (; size > 0; size--) {
+		cy_writel(fpga, *data++);
+		udelay(10);
+	}
+}
+
+static void __devinit plx_init(struct pci_dev *pdev, int irq,
+		struct RUNTIME_9060 __iomem *addr)
@@ -4745 +4803 @@
-	cy_writel(addr + initctl, readl(addr + initctl) | 0x40000000);
+	cy_writel(&addr->init_ctrl, readl(&addr->init_ctrl) | 0x40000000);
@@ -4747 +4805 @@
-	cy_writel(addr + initctl, readl(addr + initctl) & ~0x40000000);
+	cy_writel(&addr->init_ctrl, readl(&addr->init_ctrl) & ~0x40000000);
@@ -4750 +4808 @@
-	cy_writel(addr + initctl, readl(addr + initctl) | 0x20000000);
+	cy_writel(&addr->init_ctrl, readl(&addr->init_ctrl) | 0x20000000);
@@ -4752 +4810,254 @@
-	cy_writel(addr + initctl, readl(addr + initctl) & ~0x20000000);
+	cy_writel(&addr->init_ctrl, readl(&addr->init_ctrl) & ~0x20000000);
+
+	/* For some yet unknown reason, once the PLX9060 reloads the EEPROM,
+	 * the IRQ is lost and, thus, we have to re-write it to the PCI config.
+	 * registers. This will remain here until we find a permanent fix.
+	 */
+	pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, irq);
+}
+
+static int __devinit __cyz_load_fw(const struct firmware *fw,
+		const char *name, const u32 mailbox, void __iomem *base,
+		void __iomem *fpga)
+{
+	void *ptr = fw->data;
+	struct zfile_header *h = ptr;
+	struct zfile_config *c, *cs;
+	struct zfile_block *b, *bs;
+	unsigned int a, tmp, len = fw->size;
+#define BAD_FW KERN_ERR "Bad firmware: "
+	if (len < sizeof(*h)) {
+		printk(BAD_FW "too short: %u<%zu\n", len, sizeof(*h));
+		return -EINVAL;
+	}
+
+	cs = ptr + h->config_offset;
+	bs = ptr + h->block_offset;
+
+	if ((void *)(cs + h->n_config) > ptr + len ||
+			(void *)(bs + h->n_blocks) > ptr + len) {
+		printk(BAD_FW "too short");
+		return  -EINVAL;
+	}
+
+	if (cyc_isfwstr(h->name, sizeof(h->name)) ||
+			cyc_isfwstr(h->date, sizeof(h->date))) {
+		printk(BAD_FW "bad formatted header string\n");
+		return -EINVAL;
+	}
+
+	if (strncmp(name, h->name, sizeof(h->name))) {
+		printk(BAD_FW "bad name '%s' (expected '%s')\n", h->name, name);
+		return -EINVAL;
+	}
+
+	tmp = 0;
+	for (c = cs; c < cs + h->n_config; c++) {
+		for (a = 0; a < c->n_blocks; a++)
+			if (c->block_list[a] > h->n_blocks) {
+				printk(BAD_FW "bad block ref number in cfgs\n");
+				return -EINVAL;
+			}
+		if (c->mailbox == mailbox && c->function == 0) /* 0 is normal */
+			tmp++;
+	}
+	if (!tmp) {
+		printk(BAD_FW "nothing appropriate\n");
+		return -EINVAL;
+	}
+
+	for (b = bs; b < bs + h->n_blocks; b++)
+		if (b->file_offset + b->size > len) {
+			printk(BAD_FW "bad block data offset\n");
+			return -EINVAL;
+		}
+
+	/* everything is OK, let's seek'n'load it */
+	for (c = cs; c < cs + h->n_config; c++)
+		if (c->mailbox == mailbox && c->function == 0)
+			break;
+
+	for (a = 0; a < c->n_blocks; a++) {
+		b = &bs[c->block_list[a]];
+		if (b->type == ZBLOCK_FPGA) {
+			if (fpga != NULL)
+				cyz_fpga_copy(fpga, ptr + b->file_offset,
+						b->size);
+		} else {
+			if (base != NULL)
+				memcpy_toio(base + b->ram_offset,
+					       ptr + b->file_offset, b->size);
+		}
+	}
+#undef BAD_FW
+	return 0;
+}
+
+static int __devinit cyz_load_fw(struct pci_dev *pdev, void __iomem *base_addr,
+		struct RUNTIME_9060 __iomem *ctl_addr, int irq)
+{
+	const struct firmware *fw;
+	struct FIRM_ID __iomem *fid = base_addr + ID_ADDRESS;
+	struct CUSTOM_REG __iomem *cust = base_addr;
+	struct ZFW_CTRL __iomem *pt_zfwctrl;
+	void __iomem *tmp;
+	u32 mailbox, status;
+	unsigned int i;
+	int retval;
+
+	retval = request_firmware(&fw, "cyzfirm.bin", &pdev->dev);
+	if (retval) {
+		dev_err(&pdev->dev, "can't get firmware\n");
+		goto err;
+	}
+
+	/* Check whether the firmware is already loaded and running. If
+	   positive, skip this board */
+	if (Z_FPGA_LOADED(ctl_addr) && readl(&fid->signature) == ZFIRM_ID) {
+		u32 cntval = readl(base_addr + 0x190);
+
+		udelay(100);
+		if (cntval != readl(base_addr + 0x190)) {
+			/* FW counter is working, FW is running */
+			dev_dbg(&pdev->dev, "Cyclades-Z FW already loaded. "
+					"Skipping board.\n");
+			retval = 0;
+			goto err_rel;
+		}
+	}
+
+	/* start boot */
+	cy_writel(&ctl_addr->intr_ctrl_stat, readl(&ctl_addr->intr_ctrl_stat) &
+			~0x00030800UL);
+
+	mailbox = readl(&ctl_addr->mail_box_0);
+
+	if (mailbox == 0 || Z_FPGA_LOADED(ctl_addr)) {
+		/* stops CPU and set window to beginning of RAM */
+		cy_writel(&ctl_addr->loc_addr_base, WIN_CREG);
+		cy_writel(&cust->cpu_stop, 0);
+		cy_writel(&ctl_addr->loc_addr_base, WIN_RAM);
+		udelay(100);
+	}
+
+	plx_init(pdev, irq, ctl_addr);
+
+	if (mailbox != 0) {
+		/* load FPGA */
+		retval = __cyz_load_fw(fw, "Cyclom-Z", mailbox, NULL,
+				base_addr);
+		if (retval)
+			goto err_rel;
+		if (!Z_FPGA_LOADED(ctl_addr)) {
+			dev_err(&pdev->dev, "fw upload successful, but fw is "
+					"not loaded\n");
+			goto err_rel;
+		}
+	}
+
+	/* stops CPU and set window to beginning of RAM */
+	cy_writel(&ctl_addr->loc_addr_base, WIN_CREG);
+	cy_writel(&cust->cpu_stop, 0);
+	cy_writel(&ctl_addr->loc_addr_base, WIN_RAM);
+	udelay(100);
+
+	/* clear memory */
+	for (tmp = base_addr; tmp < base_addr + RAM_SIZE; tmp++)
+		cy_writeb(tmp, 255);
+	if (mailbox != 0) {
+		/* set window to last 512K of RAM */
+		cy_writel(&ctl_addr->loc_addr_base, WIN_RAM + RAM_SIZE);
+		//sleep(1);
+		for (tmp = base_addr; tmp < base_addr + RAM_SIZE; tmp++)
+			cy_writeb(tmp, 255);
+		/* set window to beginning of RAM */
+		cy_writel(&ctl_addr->loc_addr_base, WIN_RAM);
+		//sleep(1);
+	}
+
+	retval = __cyz_load_fw(fw, "Cyclom-Z", mailbox, base_addr, NULL);
+	release_firmware(fw);
+	if (retval)
+		goto err;
+
+	/* finish boot and start boards */
+	cy_writel(&ctl_addr->loc_addr_base, WIN_CREG);
+	cy_writel(&cust->cpu_start, 0);
+	cy_writel(&ctl_addr->loc_addr_base, WIN_RAM);
+	i = 0;
+	while ((status = readl(&fid->signature)) != ZFIRM_ID && i++ < 40)
+		msleep(100);
+	if (status != ZFIRM_ID) {
+		if (status == ZFIRM_HLT) {
+			dev_err(&pdev->dev, "you need an external power supply "
+				"for this number of ports. Firmware halted and "
+				"board reset.\n");
+			retval = -EIO;
+			goto err;
+		}
+		dev_warn(&pdev->dev, "fid->signature = 0x%x... Waiting "
+				"some more time\n", status);
+		while ((status = readl(&fid->signature)) != ZFIRM_ID &&
+				i++ < 200)
+			msleep(100);
+		if (status != ZFIRM_ID) {
+			dev_err(&pdev->dev, "Board not started in 20 seconds! "
+					"Giving up. (fid->signature = 0x%x)\n",
+					status);
+			dev_info(&pdev->dev, "*** Warning ***: if you are "
+				"upgrading the FW, please power cycle the "
+				"system before loading the new FW to the "
+				"Cyclades-Z.\n");
+
+			if (Z_FPGA_LOADED(ctl_addr))
+				plx_init(pdev, irq, ctl_addr);
+
+			retval = -EIO;
+			goto err;
+		}
+		dev_dbg(&pdev->dev, "Firmware started after %d seconds.\n",
+				i / 10);
+	}
+	pt_zfwctrl = base_addr + readl(&fid->zfwctrl_addr);
+
+	dev_dbg(&pdev->dev, "fid=> %p, zfwctrl_addr=> %x, npt_zfwctrl=> %p\n",
+			base_addr + ID_ADDRESS, readl(&fid->zfwctrl_addr),
+			base_addr + readl(&fid->zfwctrl_addr));
+
+	dev_info(&pdev->dev, "Cyclades-Z FW loaded: version = %x, ports = %u\n",
+		readl(&pt_zfwctrl->board_ctrl.fw_version),
+		readl(&pt_zfwctrl->board_ctrl.n_channel));
+
+	if (readl(&pt_zfwctrl->board_ctrl.n_channel) == 0) {
+		dev_warn(&pdev->dev, "no Cyclades-Z ports were found. Please "
+			"check the connection between the Z host card and the "
+			"serial expanders.\n");
+
+		if (Z_FPGA_LOADED(ctl_addr))
+			plx_init(pdev, irq, ctl_addr);
+
+		dev_info(&pdev->dev, "Null number of ports detected. Board "
+				"reset.\n");
+		retval = 0;
+		goto err;
+	}
+
+	cy_writel(&pt_zfwctrl->board_ctrl.op_system, C_OS_LINUX);
+	cy_writel(&pt_zfwctrl->board_ctrl.dr_version, DRIVER_VERSION);
+
+	/*
+	   Early firmware failed to start looking for commands.
+	   This enables firmware interrupts for those commands.
+	 */
+	cy_writel(&ctl_addr->intr_ctrl_stat, readl(&ctl_addr->intr_ctrl_stat) |
+			(1 << 17));
+	cy_writel(&ctl_addr->intr_ctrl_stat, readl(&ctl_addr->intr_ctrl_stat) |
+			0x00030800UL);
+
+	plx_init(pdev, irq, ctl_addr);
+
+	return 0;
+err_rel:
+	release_firmware(fw);
+err:
+	return retval;
@@ -4834,2 +5145 @@
-		cy_writew(addr0 + 0x68,
-			readw(addr0 + 0x68) & ~0x0900);
+		cy_writew(addr0 + 0x68, readw(addr0 + 0x68) & ~0x0900);
@@ -4837,7 +5147 @@
-		plx_init(addr0, 0x6c);
-		/* For some yet unknown reason, once the PLX9060 reloads
-		   the EEPROM, the IRQ is lost and, thus, we have to
-		   re-write it to the PCI config. registers.
-		   This will remain here until we find a permanent
-		   fix. */
-		pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, irq);
+		plx_init(pdev, irq, addr0);
@@ -4883,0 +5188,3 @@
+			retval = cyz_load_fw(pdev, addr2, addr0, irq);
+			if (retval)
+				goto err_unmap;
@@ -4960,9 +5267 @@
-
-			plx_init(addr0, 0x6c);
-		/* For some yet unknown reason, once the PLX9060 reloads
-		   the EEPROM, the IRQ is lost and, thus, we have to
-		   re-write it to the PCI config. registers.
-		   This will remain here until we find a permanent
-		   fix. */
-			pci_write_config_byte(pdev, PCI_INTERRUPT_LINE, irq);
-
+			plx_init(pdev, irq, addr0);
--- ./projects/linux/linux-2.6.23/drivers/char/cyclades.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/cyclades.c	2008-01-24 23:58:37.000000000 +0100
@@ -362 +362 @@
- * as noted by Heiko Eissfeldt <heiko@colossus.escape.de>
+ * as noted by Heiko Eifeldt <heiko@colossus.escape.de>
@@ -665 +665 @@
-#define IS_CYC_Z(card) ((card).num_chips == -1)
+#define IS_CYC_Z(card) ((card).num_chips == (unsigned int)-1)
@@ -730,2 +729,0 @@
-   The cy_setup function extracts additional addresses from the
-   boot options line.  The form is "cyclades=address,address..."
@@ -900,65 +897,0 @@
-/*
- * This routine is used by the interrupt handler to schedule
- * processing in the software interrupt portion of the driver
- * (also known as the "bottom half").  This can be called any
- * number of times for any channel without harm.
- */
-static inline void cy_sched_event(struct cyclades_port *info, int event)
-{
-	info->event |= 1 << event; /* remember what kind of event and who */
-	schedule_work(&info->tqueue);
-}				/* cy_sched_event */
-
-/*
- * This routine is used to handle the "bottom half" processing for the
- * serial driver, known also the "software interrupt" processing.
- * This processing is done at the kernel interrupt level, after the
- * cy#/_interrupt() has returned, BUT WITH INTERRUPTS TURNED ON.  This
- * is where time-consuming activities which can not be done in the
- * interrupt driver proper are done; the interrupt driver schedules
- * them using cy_sched_event(), and they get done here.
- *
- * This is done through one level of indirection--the task queue.
- * When a hardware interrupt service routine wants service by the
- * driver's bottom half, it enqueues the appropriate tq_struct (one
- * per port) to the keventd work queue and sets a request flag
- * that the work queue be processed.
- *
- * Although this may seem unwieldy, it gives the system a way to
- * pass an argument (in this case the pointer to the cyclades_port
- * structure) to the bottom half of the driver.  Previous kernels
- * had to poll every port to see if that port needed servicing.
- */
-static void
-do_softint(struct work_struct *work)
-{
-	struct cyclades_port *info =
-		container_of(work, struct cyclades_port, tqueue);
-	struct tty_struct    *tty;
-
-	tty = info->tty;
-	if (!tty)
-		return;
-
-	if (test_and_clear_bit(Cy_EVENT_HANGUP, &info->event)) {
-		tty_hangup(info->tty);
-		wake_up_interruptible(&info->open_wait);
-		        info->flags &= ~ASYNC_NORMAL_ACTIVE;
-	}
-	if (test_and_clear_bit(Cy_EVENT_OPEN_WAKEUP, &info->event))
-		wake_up_interruptible(&info->open_wait);
-#ifdef CONFIG_CYZ_INTR
-	if (test_and_clear_bit(Cy_EVENT_Z_RX_FULL, &info->event) &&
-			!timer_pending(&cyz_rx_full_timer[info->line]))
-		mod_timer(&cyz_rx_full_timer[info->line], jiffies + 1);
-#endif
-	if (test_and_clear_bit(Cy_EVENT_DELTA_WAKEUP, &info->event))
-		wake_up_interruptible(&info->delta_msr_wait);
-	tty_wakeup(tty);
-#ifdef Z_WAKE
-	if (test_and_clear_bit(Cy_EVENT_SHUTDOWN_WAKEUP, &info->event))
-		complete(&info->shutdown_wait);
-#endif
-} /* do_softint */
-
-
@@ -1048,2 +981,2 @@
-static void cyy_intr_chip(struct cyclades_card *cinfo, int chip,
-			void __iomem * base_addr, int status, int index)
+static void cyy_chip_rx(struct cyclades_card *cinfo, int chip,
+		void __iomem *base_addr)
@@ -1053,4 +986,2 @@
-	int char_count;
-	int j, len, mdm_change, mdm_status, outch;
-	int save_xir, channel, save_car;
-	char data;
+	int len, index = cinfo->bus_index;
+	u8 save_xir, channel, save_car, data, char_count;
@@ -1058 +988,0 @@
-	if (status & CySRReceive) {	/* reception interrupt */
@@ -1060 +990 @@
-		printk(KERN_DEBUG "cyy_interrupt: rcvd intr, chip %d\n", chip);
+	printk(KERN_DEBUG "cyy_interrupt: rcvd intr, chip %d\n", chip);
@@ -1062,27 +992,15 @@
-		/* determine the channel & change to that context */
-		spin_lock(&cinfo->card_lock);
-		save_xir = (u_char) readb(base_addr + (CyRIR << index));
-		channel = (u_short) (save_xir & CyIRChannel);
-		info = &cinfo->ports[channel + chip * 4];
-		save_car = readb(base_addr + (CyCAR << index));
-		cy_writeb(base_addr + (CyCAR << index), save_xir);
-
-		/* if there is nowhere to put the data, discard it */
-		if (info->tty == NULL) {
-			j = (readb(base_addr + (CyRIVR << index)) &
-				CyIVRMask);
-			if (j == CyIVRRxEx) {	/* exception */
-				data = readb(base_addr + (CyRDSR << index));
-			} else {	/* normal character reception */
-				char_count = readb(base_addr +
-						(CyRDCR << index));
-				while (char_count--) {
-					data = readb(base_addr +
-						(CyRDSR << index));
-				}
-			}
-		} else {	/* there is an open port for this data */
-			tty = info->tty;
-			j = (readb(base_addr + (CyRIVR << index)) &
-					CyIVRMask);
-			if (j == CyIVRRxEx) {	/* exception */
+	/* determine the channel & change to that context */
+	save_xir = readb(base_addr + (CyRIR << index));
+	channel = save_xir & CyIRChannel;
+	info = &cinfo->ports[channel + chip * 4];
+	save_car = readb(base_addr + (CyCAR << index));
+	cy_writeb(base_addr + (CyCAR << index), save_xir);
+
+	/* if there is nowhere to put the data, discard it */
+	if (info->tty == NULL) {
+		if ((readb(base_addr + (CyRIVR << index)) & CyIVRMask) ==
+				CyIVRRxEx) {	/* exception */
+			data = readb(base_addr + (CyRDSR << index));
+		} else {	/* normal character reception */
+			char_count = readb(base_addr + (CyRDCR << index));
+			while (char_count--)
@@ -1089,0 +1008,18 @@
+		}
+		goto end;
+	}
+	/* there is an open port for this data */
+	tty = info->tty;
+	if ((readb(base_addr + (CyRIVR << index)) & CyIVRMask) ==
+			CyIVRRxEx) {	/* exception */
+		data = readb(base_addr + (CyRDSR << index));
+
+		/* For statistics only */
+		if (data & CyBREAK)
+			info->icount.brk++;
+		else if (data & CyFRAME)
+			info->icount.frame++;
+		else if (data & CyPARITY)
+			info->icount.parity++;
+		else if (data & CyOVERRUN)
+			info->icount.overrun++;
@@ -1091,11 +1027,37 @@
-				/* For statistics only */
-				if (data & CyBREAK)
-					info->icount.brk++;
-				else if (data & CyFRAME)
-					info->icount.frame++;
-				else if (data & CyPARITY)
-					info->icount.parity++;
-				else if (data & CyOVERRUN)
-					info->icount.overrun++;
-
-				if (data & info->ignore_status_mask) {
+		if (data & info->ignore_status_mask) {
+			info->icount.rx++;
+			return;
+		}
+		if (tty_buffer_request_room(tty, 1)) {
+			if (data & info->read_status_mask) {
+				if (data & CyBREAK) {
+					tty_insert_flip_char(tty,
+						readb(base_addr + (CyRDSR <<
+							index)), TTY_BREAK);
+					info->icount.rx++;
+					if (info->flags & ASYNC_SAK)
+						do_SAK(tty);
+				} else if (data & CyFRAME) {
+					tty_insert_flip_char( tty,
+						readb(base_addr + (CyRDSR <<
+							index)), TTY_FRAME);
+					info->icount.rx++;
+					info->idle_stats.frame_errs++;
+				} else if (data & CyPARITY) {
+					/* Pieces of seven... */
+					tty_insert_flip_char(tty,
+						readb(base_addr + (CyRDSR <<
+							index)), TTY_PARITY);
+					info->icount.rx++;
+					info->idle_stats.parity_errs++;
+				} else if (data & CyOVERRUN) {
+					tty_insert_flip_char(tty, 0,
+							TTY_OVERRUN);
+					info->icount.rx++;
+					/* If the flip buffer itself is
+					   overflowing, we still lose
+					   the next incoming character.
+					 */
+					tty_insert_flip_char(tty,
+						readb(base_addr + (CyRDSR <<
+							index)), TTY_FRAME);
@@ -1103,80 +1064,0 @@
-					spin_unlock(&cinfo->card_lock);
-					return;
-				}
-				if (tty_buffer_request_room(tty, 1)) {
-					if (data & info->read_status_mask) {
-						if (data & CyBREAK) {
-							tty_insert_flip_char(
-								tty,
-								readb(
-								base_addr +
-								(CyRDSR <<
-									index)),
-								TTY_BREAK);
-							info->icount.rx++;
-							if (info->flags &
-							    ASYNC_SAK) {
-								do_SAK(tty);
-							}
-						} else if (data & CyFRAME) {
-							tty_insert_flip_char(
-								tty,
-								readb(
-								base_addr +
-								(CyRDSR <<
-									index)),
-								TTY_FRAME);
-							info->icount.rx++;
-							info->idle_stats.
-								frame_errs++;
-						} else if (data & CyPARITY) {
-							/* Pieces of seven... */
-							tty_insert_flip_char(
-								tty,
-								readb(
-								base_addr +
-								(CyRDSR <<
-									index)),
-								TTY_PARITY);
-							info->icount.rx++;
-							info->idle_stats.
-								parity_errs++;
-						} else if (data & CyOVERRUN) {
-							tty_insert_flip_char(
-								tty, 0,
-								TTY_OVERRUN);
-							info->icount.rx++;
-						/* If the flip buffer itself is
-						   overflowing, we still lose
-						   the next incoming character.
-						 */
-							tty_insert_flip_char(
-								tty,
-								readb(
-								base_addr +
-								(CyRDSR <<
-									index)),
-								TTY_FRAME);
-							info->icount.rx++;
-							info->idle_stats.
-								overruns++;
-					/* These two conditions may imply */
-					/* a normal read should be done. */
-					/* }else if(data & CyTIMEOUT){ */
-					/* }else if(data & CySPECHAR){ */
-						} else {
-							tty_insert_flip_char(
-								tty, 0,
-								TTY_NORMAL);
-							info->icount.rx++;
-						}
-					} else {
-						tty_insert_flip_char(tty, 0,
-								TTY_NORMAL);
-						info->icount.rx++;
-					}
-				} else {
-					/* there was a software buffer
-					   overrun and nothing could be
-					   done about it!!! */
-					info->icount.buf_overrun++;
@@ -1183,0 +1066,8 @@
+				/* These two conditions may imply */
+				/* a normal read should be done. */
+				/* } else if(data & CyTIMEOUT) { */
+				/* } else if(data & CySPECHAR) { */
+				} else {
+					tty_insert_flip_char(tty, 0,
+							TTY_NORMAL);
+					info->icount.rx++;
@@ -1185,4 +1075,13 @@
-			} else {	/* normal character reception */
-				/* load # chars available from the chip */
-				char_count = readb(base_addr +
-						(CyRDCR << index));
+			} else {
+				tty_insert_flip_char(tty, 0, TTY_NORMAL);
+				info->icount.rx++;
+			}
+		} else {
+			/* there was a software buffer overrun and nothing
+			 * could be done about it!!! */
+			info->icount.buf_overrun++;
+			info->idle_stats.overruns++;
+		}
+	} else {	/* normal character reception */
+		/* load # chars available from the chip */
+		char_count = readb(base_addr + (CyRDCR << index));
@@ -1191,14 +1090,12 @@
-				++info->mon.int_count;
-				info->mon.char_count += char_count;
-				if (char_count > info->mon.char_max)
-					info->mon.char_max = char_count;
-				info->mon.char_last = char_count;
-#endif
-				len = tty_buffer_request_room(tty, char_count);
-				while (len--) {
-					data = readb(base_addr +
-							(CyRDSR << index));
-					tty_insert_flip_char(tty, data,
-							TTY_NORMAL);
-					info->idle_stats.recv_bytes++;
-					info->icount.rx++;
+		++info->mon.int_count;
+		info->mon.char_count += char_count;
+		if (char_count > info->mon.char_max)
+			info->mon.char_max = char_count;
+		info->mon.char_last = char_count;
+#endif
+		len = tty_buffer_request_room(tty, char_count);
+		while (len--) {
+			data = readb(base_addr + (CyRDSR << index));
+			tty_insert_flip_char(tty, data, TTY_NORMAL);
+			info->idle_stats.recv_bytes++;
+			info->icount.rx++;
@@ -1206 +1103 @@
-					udelay(10L);
+			udelay(10L);
@@ -1208,4 +1104,0 @@
-				}
-				info->idle_stats.recv_idle = jiffies;
-			}
-			tty_schedule_flip(tty);
@@ -1213,4 +1106 @@
-		/* end of service */
-		cy_writeb(base_addr + (CyRIR << index), (save_xir & 0x3f));
-		cy_writeb(base_addr + (CyCAR << index), (save_car));
-		spin_unlock(&cinfo->card_lock);
+		info->idle_stats.recv_idle = jiffies;
@@ -1217,0 +1108,13 @@
+	tty_schedule_flip(tty);
+end:
+	/* end of service */
+	cy_writeb(base_addr + (CyRIR << index), save_xir & 0x3f);
+	cy_writeb(base_addr + (CyCAR << index), save_car);
+}
+
+static void cyy_chip_tx(struct cyclades_card *cinfo, unsigned int chip,
+		void __iomem *base_addr)
+{
+	struct cyclades_port *info;
+	int char_count, index = cinfo->bus_index;
+	u8 save_xir, channel, save_car, outch;
@@ -1219,4 +1122,3 @@
-	if (status & CySRTransmit) {	/* transmission interrupt */
-		/* Since we only get here when the transmit buffer
-		   is empty, we know we can always stuff a dozen
-		   characters. */
+	/* Since we only get here when the transmit buffer
+	   is empty, we know we can always stuff a dozen
+	   characters. */
@@ -1224 +1126 @@
-		printk(KERN_DEBUG "cyy_interrupt: xmit intr, chip %d\n", chip);
+	printk(KERN_DEBUG "cyy_interrupt: xmit intr, chip %d\n", chip);
@@ -1227,6 +1129,5 @@
-		/* determine the channel & change to that context */
-		spin_lock(&cinfo->card_lock);
-		save_xir = (u_char) readb(base_addr + (CyTIR << index));
-		channel = (u_short) (save_xir & CyIRChannel);
-		save_car = readb(base_addr + (CyCAR << index));
-		cy_writeb(base_addr + (CyCAR << index), save_xir);
+	/* determine the channel & change to that context */
+	save_xir = readb(base_addr + (CyTIR << index));
+	channel = save_xir & CyIRChannel;
+	save_car = readb(base_addr + (CyCAR << index));
+	cy_writeb(base_addr + (CyCAR << index), save_xir);
@@ -1234,14 +1135,12 @@
-		/* validate the port# (as configured and open) */
-		if (channel + chip * 4 >= cinfo->nports) {
-			cy_writeb(base_addr + (CySRER << index),
-				  readb(base_addr + (CySRER << index)) &
-				  ~CyTxRdy);
-			goto txend;
-		}
-		info = &cinfo->ports[channel + chip * 4];
-		if (info->tty == NULL) {
-			cy_writeb(base_addr + (CySRER << index),
-				  readb(base_addr + (CySRER << index)) &
-				  ~CyTxRdy);
-			goto txdone;
-		}
+	/* validate the port# (as configured and open) */
+	if (channel + chip * 4 >= cinfo->nports) {
+		cy_writeb(base_addr + (CySRER << index),
+			  readb(base_addr + (CySRER << index)) & ~CyTxRdy);
+		goto end;
+	}
+	info = &cinfo->ports[channel + chip * 4];
+	if (info->tty == NULL) {
+		cy_writeb(base_addr + (CySRER << index),
+			  readb(base_addr + (CySRER << index)) & ~CyTxRdy);
+		goto end;
+	}
@@ -1249,2 +1148,2 @@
-		/* load the on-chip space for outbound data */
-		char_count = info->xmit_fifo_size;
+	/* load the on-chip space for outbound data */
+	char_count = info->xmit_fifo_size;
@@ -1252,7 +1151,7 @@
-		if (info->x_char) {	/* send special char */
-			outch = info->x_char;
-			cy_writeb(base_addr + (CyTDR << index), outch);
-			char_count--;
-			info->icount.tx++;
-			info->x_char = 0;
-		}
+	if (info->x_char) {	/* send special char */
+		outch = info->x_char;
+		cy_writeb(base_addr + (CyTDR << index), outch);
+		char_count--;
+		info->icount.tx++;
+		info->x_char = 0;
+	}
@@ -1260,13 +1159,12 @@
-		if (info->breakon || info->breakoff) {
-			if (info->breakon) {
-				cy_writeb(base_addr + (CyTDR << index), 0);
-				cy_writeb(base_addr + (CyTDR << index), 0x81);
-				info->breakon = 0;
-				char_count -= 2;
-			}
-			if (info->breakoff) {
-				cy_writeb(base_addr + (CyTDR << index), 0);
-				cy_writeb(base_addr + (CyTDR << index), 0x83);
-				info->breakoff = 0;
-				char_count -= 2;
-			}
+	if (info->breakon || info->breakoff) {
+		if (info->breakon) {
+			cy_writeb(base_addr + (CyTDR << index), 0);
+			cy_writeb(base_addr + (CyTDR << index), 0x81);
+			info->breakon = 0;
+			char_count -= 2;
+		}
+		if (info->breakoff) {
+			cy_writeb(base_addr + (CyTDR << index), 0);
+			cy_writeb(base_addr + (CyTDR << index), 0x83);
+			info->breakoff = 0;
+			char_count -= 2;
@@ -1273,0 +1172 @@
+	}
@@ -1275,7 +1174,5 @@
-		while (char_count-- > 0) {
-			if (!info->xmit_cnt) {
-				if (readb(base_addr + (CySRER << index)) &
-						CyTxMpty) {
-					cy_writeb(base_addr + (CySRER << index),
-						readb(base_addr +
-							(CySRER << index)) &
+	while (char_count-- > 0) {
+		if (!info->xmit_cnt) {
+			if (readb(base_addr + (CySRER << index)) & CyTxMpty) {
+				cy_writeb(base_addr + (CySRER << index),
+					readb(base_addr + (CySRER << index)) &
@@ -1283,4 +1180,3 @@
-				} else {
-					cy_writeb(base_addr + (CySRER << index),
-						(readb(base_addr +
-						  	(CySRER << index)) &
+			} else {
+				cy_writeb(base_addr + (CySRER << index),
+					(readb(base_addr + (CySRER << index)) &
@@ -1288,2 +1183,0 @@
-				}
-				goto txdone;
@@ -1291,3 +1185,5 @@
-			if (info->xmit_buf == NULL) {
-				cy_writeb(base_addr + (CySRER << index),
-					readb(base_addr + (CySRER << index)) &
+			goto done;
+		}
+		if (info->xmit_buf == NULL) {
+			cy_writeb(base_addr + (CySRER << index),
+				readb(base_addr + (CySRER << index)) &
@@ -1295,5 +1191,5 @@
-				goto txdone;
-			}
-			if (info->tty->stopped || info->tty->hw_stopped) {
-				cy_writeb(base_addr + (CySRER << index),
-					readb(base_addr + (CySRER << index)) &
+			goto done;
+		}
+		if (info->tty->stopped || info->tty->hw_stopped) {
+			cy_writeb(base_addr + (CySRER << index),
+				readb(base_addr + (CySRER << index)) &
@@ -1301,15 +1197,20 @@
-				goto txdone;
-			}
-			/* Because the Embedded Transmit Commands have
-			   been enabled, we must check to see if the
-			   escape character, NULL, is being sent.  If it
-			   is, we must ensure that there is room for it
-			   to be doubled in the output stream.  Therefore
-			   we no longer advance the pointer when the
-			   character is fetched, but rather wait until
-			   after the check for a NULL output character.
-			   This is necessary because there may not be
-			   room for the two chars needed to send a NULL.)
-			 */
-			outch = info->xmit_buf[info->xmit_tail];
-			if (outch) {
+			goto done;
+		}
+		/* Because the Embedded Transmit Commands have been enabled,
+		 * we must check to see if the escape character, NULL, is being
+		 * sent. If it is, we must ensure that there is room for it to
+		 * be doubled in the output stream.  Therefore we no longer
+		 * advance the pointer when the character is fetched, but
+		 * rather wait until after the check for a NULL output
+		 * character. This is necessary because there may not be room
+		 * for the two chars needed to send a NULL.)
+		 */
+		outch = info->xmit_buf[info->xmit_tail];
+		if (outch) {
+			info->xmit_cnt--;
+			info->xmit_tail = (info->xmit_tail + 1) &
+					(SERIAL_XMIT_SIZE - 1);
+			cy_writeb(base_addr + (CyTDR << index), outch);
+			info->icount.tx++;
+		} else {
+			if (char_count > 1) {
@@ -1318 +1219 @@
-						(SERIAL_XMIT_SIZE - 1);
+					(SERIAL_XMIT_SIZE - 1);
@@ -1319,0 +1221 @@
+				cy_writeb(base_addr + (CyTDR << index), 0);
@@ -1321,12 +1223 @@
-			} else {
-				if (char_count > 1) {
-					info->xmit_cnt--;
-					info->xmit_tail = (info->xmit_tail + 1)&
-						(SERIAL_XMIT_SIZE - 1);
-					cy_writeb(base_addr + (CyTDR << index),
-						outch);
-					cy_writeb(base_addr + (CyTDR << index),
-						0);
-					info->icount.tx++;
-					char_count--;
-				}
+				char_count--;
@@ -1334,0 +1226 @@
+	}
@@ -1336,20 +1228,7 @@
-txdone:
-		if (info->xmit_cnt < WAKEUP_CHARS) {
-			cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
-		}
-txend:
-		/* end of service */
-		cy_writeb(base_addr + (CyTIR << index), (save_xir & 0x3f));
-		cy_writeb(base_addr + (CyCAR << index), (save_car));
-		spin_unlock(&cinfo->card_lock);
-	}
-
-	if (status & CySRModem) {	/* modem interrupt */
-
-		/* determine the channel & change to that context */
-		spin_lock(&cinfo->card_lock);
-		save_xir = (u_char) readb(base_addr + (CyMIR << index));
-		channel = (u_short) (save_xir & CyIRChannel);
-		info = &cinfo->ports[channel + chip * 4];
-		save_car = readb(base_addr + (CyCAR << index));
-		cy_writeb(base_addr + (CyCAR << index), save_xir);
+done:
+	tty_wakeup(info->tty);
+end:
+	/* end of service */
+	cy_writeb(base_addr + (CyTIR << index), save_xir & 0x3f);
+	cy_writeb(base_addr + (CyCAR << index), save_car);
+}
@@ -1357,2 +1236,6 @@
-		mdm_change = readb(base_addr + (CyMISR << index));
-		mdm_status = readb(base_addr + (CyMSVR1 << index));
+static void cyy_chip_modem(struct cyclades_card *cinfo, int chip,
+		void __iomem *base_addr)
+{
+	struct cyclades_port *info;
+	int index = cinfo->bus_index;
+	u8 save_xir, channel, save_car, mdm_change, mdm_status;
@@ -1360,53 +1243,44 @@
-		if (info->tty) {
-			if (mdm_change & CyANY_DELTA) {
-				/* For statistics only */
-				if (mdm_change & CyDCD)
-					info->icount.dcd++;
-				if (mdm_change & CyCTS)
-					info->icount.cts++;
-				if (mdm_change & CyDSR)
-					info->icount.dsr++;
-				if (mdm_change & CyRI)
-					info->icount.rng++;
-
-				cy_sched_event(info, Cy_EVENT_DELTA_WAKEUP);
-			}
-
-			if ((mdm_change & CyDCD) &&
-					(info->flags & ASYNC_CHECK_CD)) {
-				if (mdm_status & CyDCD) {
-					cy_sched_event(info,
-							Cy_EVENT_OPEN_WAKEUP);
-				} else {
-					cy_sched_event(info, Cy_EVENT_HANGUP);
-				}
-			}
-			if ((mdm_change & CyCTS) &&
-					(info->flags & ASYNC_CTS_FLOW)) {
-				if (info->tty->hw_stopped) {
-					if (mdm_status & CyCTS) {
-						/* cy_start isn't used
-						   because... !!! */
-						info->tty->hw_stopped = 0;
-						cy_writeb(base_addr +
-							(CySRER << index),
-							readb(base_addr +
-								(CySRER <<
-									index))|
-							CyTxRdy);
-						cy_sched_event(info,
-							Cy_EVENT_WRITE_WAKEUP);
-					}
-				} else {
-					if (!(mdm_status & CyCTS)) {
-						/* cy_stop isn't used
-						   because ... !!! */
-						info->tty->hw_stopped = 1;
-						cy_writeb(base_addr +
-							(CySRER << index),
-							readb(base_addr +
-								(CySRER <<
-								index)) &
-							~CyTxRdy);
-					}
-				}
+	/* determine the channel & change to that context */
+	save_xir = readb(base_addr + (CyMIR << index));
+	channel = save_xir & CyIRChannel;
+	info = &cinfo->ports[channel + chip * 4];
+	save_car = readb(base_addr + (CyCAR << index));
+	cy_writeb(base_addr + (CyCAR << index), save_xir);
+
+	mdm_change = readb(base_addr + (CyMISR << index));
+	mdm_status = readb(base_addr + (CyMSVR1 << index));
+
+	if (!info->tty)
+		goto end;
+
+	if (mdm_change & CyANY_DELTA) {
+		/* For statistics only */
+		if (mdm_change & CyDCD)
+			info->icount.dcd++;
+		if (mdm_change & CyCTS)
+			info->icount.cts++;
+		if (mdm_change & CyDSR)
+			info->icount.dsr++;
+		if (mdm_change & CyRI)
+			info->icount.rng++;
+
+		wake_up_interruptible(&info->delta_msr_wait);
+	}
+
+	if ((mdm_change & CyDCD) && (info->flags & ASYNC_CHECK_CD)) {
+		if (!(mdm_status & CyDCD)) {
+			tty_hangup(info->tty);
+			info->flags &= ~ASYNC_NORMAL_ACTIVE;
+		}
+		wake_up_interruptible(&info->open_wait);
+	}
+	if ((mdm_change & CyCTS) && (info->flags & ASYNC_CTS_FLOW)) {
+		if (info->tty->hw_stopped) {
+			if (mdm_status & CyCTS) {
+				/* cy_start isn't used
+				   because... !!! */
+				info->tty->hw_stopped = 0;
+				cy_writeb(base_addr + (CySRER << index),
+					readb(base_addr + (CySRER << index)) |
+						CyTxRdy);
+				tty_wakeup(info->tty);
@@ -1414 +1288,8 @@
-/*			if (mdm_change & CyDSR) {
+		} else {
+			if (!(mdm_status & CyCTS)) {
+				/* cy_stop isn't used
+				   because ... !!! */
+				info->tty->hw_stopped = 1;
+				cy_writeb(base_addr + (CySRER << index),
+					readb(base_addr + (CySRER << index)) &
+						~CyTxRdy);
@@ -1416,2 +1296,0 @@
-			if (mdm_change & CyRI) {
-			}*/
@@ -1419,4 +1297,0 @@
-		/* end of service */
-		cy_writeb(base_addr + (CyMIR << index), (save_xir & 0x3f));
-		cy_writeb(base_addr + (CyCAR << index), save_car);
-		spin_unlock(&cinfo->card_lock);
@@ -1423,0 +1299,8 @@
+/*	if (mdm_change & CyDSR) {
+	}
+	if (mdm_change & CyRI) {
+	}*/
+end:
+	/* end of service */
+	cy_writeb(base_addr + (CyMIR << index), save_xir & 0x3f);
+	cy_writeb(base_addr + (CyCAR << index), save_car);
@@ -1435 +1318 @@
-	int chip;
+	unsigned int chip, too_many, had_work;
@@ -1437,2 +1319,0 @@
-	int too_many;
-	int had_work;
@@ -1473 +1354 @@
-				if (1000 < too_many++) {
+				if (1000 < too_many++)
@@ -1475,3 +1356,8 @@
-				}
-				cyy_intr_chip(cinfo, chip, base_addr, status,
-						index);
+				spin_lock(&cinfo->card_lock);
+				if (status & CySRReceive) /* rx intr */
+					cyy_chip_rx(cinfo, chip, base_addr);
+				if (status & CySRTransmit) /* tx intr */
+					cyy_chip_tx(cinfo, chip, base_addr);
+				if (status & CySRModem) /* modem intr */
+					cyy_chip_modem(cinfo, chip, base_addr);
+				spin_unlock(&cinfo->card_lock);
@@ -1532 +1418 @@
-	int index;
+	unsigned int index;
@@ -1557,2 +1443 @@
-static void
-cyz_handle_rx(struct cyclades_port *info, struct CH_CTRL __iomem *ch_ctrl,
+static void cyz_handle_rx(struct cyclades_port *info,
@@ -1563 +1448 @@
-	int char_count;
+	unsigned int char_count;
@@ -1636,3 +1521,5 @@
-			if (char_count >= (int)readl(&buf_ctrl->rx_threshold)) {
-				cy_sched_event(info, Cy_EVENT_Z_RX_FULL);
-			}
+			if (char_count >= readl(&buf_ctrl->rx_threshold) &&
+					!timer_pending(&cyz_rx_full_timer[
+							info->line]))
+				mod_timer(&cyz_rx_full_timer[info->line],
+						jiffies + 1);
@@ -1648,2 +1535 @@
-static void
-cyz_handle_tx(struct cyclades_port *info, struct CH_CTRL __iomem *ch_ctrl,
+static void cyz_handle_tx(struct cyclades_port *info,
@@ -1654,2 +1540,2 @@
-	char data;
-	int char_count;
+	u8 data;
+	unsigned int char_count;
@@ -1718,0 +1605 @@
+		tty_wakeup(tty);
@@ -1720,3 +1606,0 @@
-		if (info->xmit_cnt < WAKEUP_CHARS) {
-			cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
-		}
@@ -1784,2 +1668 @@
-					cy_sched_event(info,
-						 	Cy_EVENT_OPEN_WAKEUP);
+					wake_up_interruptible(&info->open_wait);
@@ -1787 +1670,3 @@
-					cy_sched_event(info, Cy_EVENT_HANGUP);
+					tty_hangup(info->tty);
+					wake_up_interruptible(&info->open_wait);
+					info->flags &= ~ASYNC_NORMAL_ACTIVE;
@@ -1805 +1690 @@
-			cy_sched_event(info, Cy_EVENT_SHUTDOWN_WAKEUP);
+			complete(&info->shutdown_wait);
@@ -1817 +1702 @@
-			cyz_handle_rx(info, ch_ctrl, buf_ctrl);
+			cyz_handle_rx(info, buf_ctrl);
@@ -1827 +1712 @@
-			cyz_handle_tx(info, ch_ctrl, buf_ctrl);
+			cyz_handle_tx(info, buf_ctrl);
@@ -1837 +1722 @@
-			cy_sched_event(info, Cy_EVENT_DELTA_WAKEUP);
+			wake_up_interruptible(&info->delta_msr_wait);
@@ -1896 +1780,0 @@
-	struct CH_CTRL __iomem *ch_ctrl;
@@ -1899 +1783 @@
-	int card, port;
+	unsigned int port, card;
@@ -1926 +1809,0 @@
-			ch_ctrl = &(zfw_ctrl->ch_ctrl[port]);
@@ -1930,2 +1813,2 @@
-				cyz_handle_rx(info, ch_ctrl, buf_ctrl);
-			cyz_handle_tx(info, ch_ctrl, buf_ctrl);
+				cyz_handle_rx(info, buf_ctrl);
+			cyz_handle_tx(info, buf_ctrl);
@@ -2494,2 +2377,2 @@
-	unsigned int i;
-	int retval, line;
+	unsigned int i, line;
+	int retval;
@@ -2498 +2381 @@
-	if ((line < 0) || (NR_PORTS <= line)) {
+	if ((tty->index < 0) || (NR_PORTS <= line)) {
@@ -2815 +2697,0 @@
-	info->event = 0;
@@ -4447 +4328,0 @@
-	info->event = 0;
@@ -4470 +4351 @@
-	unsigned int nports;
+	unsigned int nports, port;
@@ -4472 +4353 @@
-	int uninitialized_var(index), port;
+	int uninitialized_var(index);
@@ -4505 +4385,0 @@
-		INIT_WORK(&info->tqueue, do_softint);
@@ -5239 +5119 @@
-		cy_card[card_no].num_chips = -1;
+		cy_card[card_no].num_chips = (unsigned int)-1;
@@ -5483,2 +5363,4 @@
-	if (retval && !nboards)
-		goto err_unr;
+	if (retval && !nboards) {
+		tty_unregister_driver(cy_serial_driver);
+		goto err_frtty;
+	}
@@ -5488,2 +5369,0 @@
-err_unr:
-	tty_unregister_driver(cy_serial_driver);
@@ -5499 +5379 @@
-	int i, e1;
+	unsigned int i, e1;
@@ -5527,2 +5407 @@
-			for (e1 = card->first_line;
-					e1 < card->first_line +
+			for (e1 = card->first_line; e1 < card->first_line +
--- ./projects/linux/linux-2.6.25/drivers/char/cyclades.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/cyclades.c	2008-07-13 23:51:29.000000000 +0200
@@ -24 +23,0 @@
- * $Log: cyclades.c,v $
@@ -65 +64 @@
- * Fixed bug in cyz_poll that would make all ports but port 0 
+ * Fixed bug in cyz_poll that would make all ports but port 0
@@ -86 +85 @@
- * Implemented a new ISA IRQ autoprobe that uses the irq_probe_[on|off] 
+ * Implemented a new ISA IRQ autoprobe that uses the irq_probe_[on|off]
@@ -90 +89 @@
- * Fixed bug in set_line_char that would prevent the Cyclades-Z 
+ * Fixed bug in set_line_char that would prevent the Cyclades-Z
@@ -94 +93 @@
- * The driver now only prints IRQ info for the Cyclades-Z if it's 
+ * The driver now only prints IRQ info for the Cyclades-Z if it's
@@ -100 +99 @@
- * Added a missing MOD_DEC_USE_COUNT in the cy_open function for when 
+ * Added a missing MOD_DEC_USE_COUNT in the cy_open function for when
@@ -102 +101 @@
- * Replaced the "manual" Z Tx flush buffer by a call to a FW command of 
+ * Replaced the "manual" Z Tx flush buffer by a call to a FW command of
@@ -104 +103 @@
- * Implemented workaround for IRQ setting loss on the PCI configuration 
+ * Implemented workaround for IRQ setting loss on the PCI configuration
@@ -115 +114 @@
- * Included a PCI bridge reset and EEPROM reload in the board 
+ * Included a PCI bridge reset and EEPROM reload in the board
@@ -119 +118 @@
- * Fixed a bug in cy_wait_until_sent that was preventing the port to be 
+ * Fixed a bug in cy_wait_until_sent that was preventing the port to be
@@ -124 +123 @@
- * 
+ *
@@ -130 +129 @@
- * Changed access to PLX PCI bridge registers from I/O to MMIO, in 
+ * Changed access to PLX PCI bridge registers from I/O to MMIO, in
@@ -151 +150 @@
- * /proc/cyclades implementation with great collaboration of 
+ * /proc/cyclades implementation with great collaboration of
@@ -160 +159 @@
- * removed conditional compilation for new/old PCI structure support 
+ * removed conditional compilation for new/old PCI structure support
@@ -171 +170 @@
- * introduction of a mechanism to prevent data loss with slow 
+ * introduction of a mechanism to prevent data loss with slow
@@ -185 +184 @@
- * 
+ *
@@ -190 +189 @@
- * introduction of flag that allows driver to take advantage of 
+ * introduction of flag that allows driver to take advantage of
@@ -199 +198 @@
- * Fixes related to kernel version conditional 
+ * Fixes related to kernel version conditional
@@ -201 +200 @@
- *  
+ *
@@ -203 +202 @@
- * Compatibility issues between kernels 2.0.x and 
+ * Compatibility issues between kernels 2.0.x and
@@ -205 +204 @@
- *  
+ *
@@ -207 +206 @@
- * Changes to define the memory window according to the 
+ * Changes to define the memory window according to the
@@ -209 +208 @@
- *  
+ *
@@ -627 +626 @@
- * Include section 
+ * Include section
@@ -652 +651 @@
-#include <asm/io.h>
+#include <linux/io.h>
@@ -654 +653 @@
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
@@ -671 +670 @@
-#define ISZLOADED(card)	(((ZO_V1==readl(&((struct RUNTIME_9060 __iomem *) \
+#define ISZLOADED(card)	(((ZO_V1 == readl(&((struct RUNTIME_9060 __iomem *) \
@@ -674 +673 @@
-			(ZFIRM_ID==readl(&((struct FIRM_ID __iomem *) \
+			(ZFIRM_ID == readl(&((struct FIRM_ID __iomem *) \
@@ -812,6 +811,6 @@
- * The cyclades_port structure member rflow and the vector rflow_thr 
- * allows us to take advantage of a special feature in the CD1400 to avoid 
- * data loss even when the system interrupt latency is too high. These flags 
- * are to be used only with very special applications. Setting these flags 
- * requires the use of a special cable (DTR and RTS reversed). In the new 
- * CD1400-based boards (rev. 6.00 or later), there is no need for special 
+ * The cyclades_port structure member rflow and the vector rflow_thr
+ * allows us to take advantage of a special feature in the CD1400 to avoid
+ * data loss even when the system interrupt latency is too high. These flags
+ * are to be used only with very special applications. Setting these flags
+ * requires the use of a special cable (DTR and RTS reversed). In the new
+ * CD1400-based boards (rev. 6.00 or later), there is no need for special
@@ -844,8 +843,16 @@
-	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_Y_Lo) },	/* PCI < 1Mb */
-	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_Y_Hi) },	/* PCI > 1Mb */
-	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_4Y_Lo) },	/* 4Y PCI < 1Mb */
-	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_4Y_Hi) },	/* 4Y PCI > 1Mb */
-	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_8Y_Lo) },	/* 8Y PCI < 1Mb */
-	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_8Y_Hi) },	/* 8Y PCI > 1Mb */
-	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_Z_Lo) },	/* Z PCI < 1Mb */
-	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_Z_Hi) },	/* Z PCI > 1Mb */
+	/* PCI < 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_Y_Lo) },
+	/* PCI > 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_Y_Hi) },
+	/* 4Y PCI < 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_4Y_Lo) },
+	/* 4Y PCI > 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_4Y_Hi) },
+	/* 8Y PCI < 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_8Y_Lo) },
+	/* 8Y PCI > 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_8Y_Hi) },
+	/* Z PCI < 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_Z_Lo) },
+	/* Z PCI > 1Mb */
+	{ PCI_DEVICE(PCI_VENDOR_ID_CYCLADES, PCI_DEVICE_ID_CYCLOM_Z_Hi) },
@@ -908 +915 @@
-static int cyy_issue_cmd(void __iomem * base_addr, u_char cmd, int index)
+static int cyy_issue_cmd(void __iomem *base_addr, u_char cmd, int index)
@@ -914 +921 @@
-		if (readb(base_addr + (CyCCR << index)) == 0) {
+		if (readb(base_addr + (CyCCR << index)) == 0)
@@ -916 +922,0 @@
-		}
@@ -932 +938 @@
-static unsigned detect_isa_irq(void __iomem * address)
+static unsigned detect_isa_irq(void __iomem *address)
@@ -1041 +1047 @@
-					tty_insert_flip_char( tty,
+					tty_insert_flip_char(tty,
@@ -1323 +1329,2 @@
-		printk(KERN_DEBUG "cyy_interrupt: spurious interrupt %d\n",irq);
+		printk(KERN_DEBUG "cyy_interrupt: spurious interrupt %d\n",
+				irq);
@@ -1378 +1385 @@
-/******** Start of block of Cyclades-Z specific code *********/
+/******** Start of block of Cyclades-Z specific code *******/
@@ -1383 +1390 @@
-		__u32 * channel, __u8 * cmd, __u32 * param)
+		__u32 *channel, __u8 *cmd, __u32 *param)
@@ -1391 +1398 @@
-	if (!ISZLOADED(*cinfo)) {
+	if (!ISZLOADED(*cinfo))
@@ -1393 +1399,0 @@
-	}
@@ -1421 +1427 @@
-	if (!ISZLOADED(*cinfo)) {
+	if (!ISZLOADED(*cinfo))
@@ -1423 +1429 @@
-	}
+
@@ -1431 +1437 @@
-		if (index++ == 1000) {
+		if (index++ == 1000)
@@ -1433 +1438,0 @@
-		}
@@ -1507 +1512,2 @@
-				new_rx_get = (new_rx_get + 1)& (rx_bufsize - 1);
+				new_rx_get = (new_rx_get + 1) &
+							(rx_bufsize - 1);
@@ -1639 +1645,2 @@
-		if ((tty = info->tty) == NULL)
+		tty = info->tty;
+		if (tty == NULL)
@@ -1735 +1742,2 @@
-		printk(KERN_DEBUG "cyz_interrupt: spurious interrupt %d\n",irq);
+		printk(KERN_DEBUG "cyz_interrupt: spurious interrupt %d\n",
+									irq);
@@ -1854 +1862 @@
-		if (info->tty) {
+		if (info->tty)
@@ -1856 +1863,0 @@
-		}
@@ -1907 +1914 @@
-		if (info->tty) {
+		if (info->tty)
@@ -1909 +1915,0 @@
-		}
@@ -1928 +1934 @@
-		if (!ISZLOADED(*card)) {
+		if (!ISZLOADED(*card))
@@ -1930 +1935,0 @@
-		}
@@ -1993 +1998 @@
-		if (info->tty) {
+		if (info->tty)
@@ -1995 +1999,0 @@
-		}
@@ -2064 +2068 @@
-	if (!(info->flags & ASYNC_INITIALIZED)) {
+	if (!(info->flags & ASYNC_INITIALIZED))
@@ -2066 +2069,0 @@
-	}
@@ -2108 +2111 @@
-		if (info->tty) {
+		if (info->tty)
@@ -2110 +2112,0 @@
-		}
@@ -2127 +2129 @@
-		if (!ISZLOADED(*card)) {
+		if (!ISZLOADED(*card))
@@ -2129 +2130,0 @@
-		}
@@ -2160 +2161 @@
-		if (info->tty) {
+		if (info->tty)
@@ -2162 +2162,0 @@
-		}
@@ -2207 +2207,2 @@
-	if ((filp->f_flags & O_NONBLOCK) || (tty->flags & (1 << TTY_IO_ERROR))) {
+	if ((filp->f_flags & O_NONBLOCK) ||
+					(tty->flags & (1 << TTY_IO_ERROR))) {
@@ -2304 +2305,2 @@
-		zfw_ctrl = base_addr + (readl(&firm_id->zfwctrl_addr)& 0xfffff);
+		zfw_ctrl = base_addr + (readl(&firm_id->zfwctrl_addr)
+								& 0xfffff);
@@ -2381 +2383 @@
-	if ((tty->index < 0) || (NR_PORTS <= line)) {
+	if (tty->index < 0 || NR_PORTS <= line)
@@ -2383 +2385 @@
-	}
+
@@ -2391 +2393 @@
-	if (info->line < 0) {
+	if (info->line < 0)
@@ -2393 +2394,0 @@
-	}
@@ -2459 +2460 @@
-	if (serial_paranoia_check(info, tty->name, "cy_open")) {
+	if (serial_paranoia_check(info, tty->name, "cy_open"))
@@ -2461 +2462 @@
-	}
+
@@ -2485 +2486 @@
-	if (retval) {
+	if (retval)
@@ -2487 +2487,0 @@
-	}
@@ -2524,0 +2525 @@
+	lock_kernel();
@@ -2575,0 +2577 @@
+	unlock_kernel();
@@ -2580,0 +2583,35 @@
+static void cy_flush_buffer(struct tty_struct *tty)
+{
+	struct cyclades_port *info = tty->driver_data;
+	struct cyclades_card *card;
+	int channel, retval;
+	unsigned long flags;
+
+#ifdef CY_DEBUG_IO
+	printk(KERN_DEBUG "cyc:cy_flush_buffer ttyC%d\n", info->line);
+#endif
+
+	if (serial_paranoia_check(info, tty->name, "cy_flush_buffer"))
+		return;
+
+	card = info->card;
+	channel = info->line - card->first_line;
+
+	spin_lock_irqsave(&card->card_lock, flags);
+	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
+	spin_unlock_irqrestore(&card->card_lock, flags);
+
+	if (IS_CYC_Z(*card)) {	/* If it is a Z card, flush the on-board
+					   buffers as well */
+		spin_lock_irqsave(&card->card_lock, flags);
+		retval = cyz_issue_cmd(card, channel, C_CM_FLUSH_TX, 0L);
+		if (retval != 0) {
+			printk(KERN_ERR "cyc: flush_buffer retval on ttyC%d "
+				"was %x\n", info->line, retval);
+		}
+		spin_unlock_irqrestore(&card->card_lock, flags);
+	}
+	tty_wakeup(tty);
+}				/* cy_flush_buffer */
+
+
@@ -2594 +2631 @@
-	if (!info || serial_paranoia_check(info, tty->name, "cy_close")) {
+	if (!info || serial_paranoia_check(info, tty->name, "cy_close"))
@@ -2596 +2632,0 @@
-	}
@@ -2644 +2680 @@
-	if (info->closing_wait != CY_CLOSING_WAIT_NONE) {
+	if (info->closing_wait != CY_CLOSING_WAIT_NONE)
@@ -2646 +2682 @@
-	}
+
@@ -2660,2 +2696,2 @@
-			/* Waiting for on-board buffers to be empty before closing
-			   the port */
+			/* Waiting for on-board buffers to be empty before
+			   closing the port */
@@ -2668 +2704,2 @@
-		/* Waiting for on-board buffers to be empty before closing the port */
+		/* Waiting for on-board buffers to be empty before closing
+		   the port */
@@ -2692,2 +2729 @@
-	if (tty->driver->flush_buffer)
-		tty->driver->flush_buffer(tty);
+	cy_flush_buffer(tty);
@@ -2741 +2777 @@
-	if (serial_paranoia_check(info, tty->name, "cy_write")) {
+	if (serial_paranoia_check(info, tty->name, "cy_write"))
@@ -2743 +2778,0 @@
-	}
@@ -2750,2 +2785,2 @@
-		c = min(count, min((int)(SERIAL_XMIT_SIZE - info->xmit_cnt - 1),
-				   (int)(SERIAL_XMIT_SIZE - info->xmit_head)));
+		c = min(count, (int)(SERIAL_XMIT_SIZE - info->xmit_cnt - 1));
+		c = min(c, (int)(SERIAL_XMIT_SIZE - info->xmit_head));
@@ -2769 +2804 @@
-	if (info->xmit_cnt && !tty->stopped && !tty->hw_stopped) {
+	if (info->xmit_cnt && !tty->stopped && !tty->hw_stopped)
@@ -2771 +2806 @@
-	}
+
@@ -2782 +2817 @@
-static void cy_put_char(struct tty_struct *tty, unsigned char ch)
+static int cy_put_char(struct tty_struct *tty, unsigned char ch)
@@ -2792 +2827 @@
-		return;
+		return 0;
@@ -2795 +2830 @@
-		return;
+		return 0;
@@ -2800 +2835 @@
-		return;
+		return 0;
@@ -2808,0 +2844 @@
+	return 1;
@@ -2813 +2849 @@
- * series of characters to the tty device using put_char().  
+ * series of characters to the tty device using put_char().
@@ -2884,0 +2921 @@
+		lock_kernel();
@@ -2901,0 +2939 @@
+		unlock_kernel();
@@ -2953 +2991 @@
-	if (!info->tty || !info->tty->termios) {
+	if (!info->tty || !info->tty->termios)
@@ -2955,2 +2993,2 @@
-	}
-	if (info->line == -1) {
+
+	if (info->line == -1)
@@ -2958 +2996 @@
-	}
+
@@ -2997 +3035 @@
-			if (baud == baud_table[i]) {
+			if (baud == baud_table[i])
@@ -2999 +3036,0 @@
-			}
@@ -3001 +3038 @@
-		if (i == 20) {
+		if (i == 20)
@@ -3003 +3039,0 @@
-		}
@@ -3062 +3098 @@
-		if (cflag & CSTOPB) {
+		if (cflag & CSTOPB)
@@ -3064 +3100 @@
-		}
+
@@ -3066 +3102 @@
-			if (cflag & PARODD) {
+			if (cflag & PARODD)
@@ -3068 +3104 @@
-			} else {
+			else
@@ -3070,2 +3106 @@
-			}
-		} else {
+		} else
@@ -3073 +3107,0 @@
-		}
@@ -3126 +3160,2 @@
-		cy_writeb(base_addr + (CyCAR << index), (u_char) channel);	/* !!! Is this needed? */
+		/* !!! Is this needed? */
+		cy_writeb(base_addr + (CyCAR << index), (u_char) channel);
@@ -3194 +3229 @@
-		if (info->tty) {
+		if (info->tty)
@@ -3196 +3230,0 @@
-		}
@@ -3209 +3243 @@
-		if (!ISZLOADED(*card)) {
+		if (!ISZLOADED(*card))
@@ -3211 +3244,0 @@
-		}
@@ -3271 +3304 @@
-			if (cflag & PARODD) {
+			if (cflag & PARODD)
@@ -3273 +3306 @@
-			} else {
+			else
@@ -3275,2 +3308 @@
-			}
-		} else {
+		} else
@@ -3278 +3309,0 @@
-		}
@@ -3308 +3339 @@
-		if (cflag & CLOCAL) {
+		if (cflag & CLOCAL)
@@ -3310 +3341 @@
-		} else {
+		else
@@ -3312 +3342,0 @@
-		}
@@ -3328 +3358 @@
-		retval = cyz_issue_cmd(card, channel, C_CM_IOCTLM,0L);
+		retval = cyz_issue_cmd(card, channel, C_CM_IOCTLM, 0L);
@@ -3334 +3364 @@
-		if (info->tty) {
+		if (info->tty)
@@ -3336 +3365,0 @@
-		}
@@ -3342 +3371 @@
-		struct serial_struct __user * retinfo)
+		struct serial_struct __user *retinfo)
@@ -3366 +3395 @@
-		struct serial_struct __user * new_info)
+		struct serial_struct __user *new_info)
@@ -3420 +3449 @@
-static int get_lsr_info(struct cyclades_port *info, unsigned int __user * value)
+static int get_lsr_info(struct cyclades_port *info, unsigned int __user *value)
@@ -3464 +3493 @@
-	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+	if (serial_paranoia_check(info, tty->name, __func__))
@@ -3466,0 +3496,2 @@
+	lock_kernel();
+
@@ -3508,0 +3540 @@
+			unlock_kernel();
@@ -3512,0 +3545 @@
+	unlock_kernel();
@@ -3531 +3564 @@
-	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+	if (serial_paranoia_check(info, tty->name, __func__))
@@ -3730,2 +3763,2 @@
-static int
-get_mon_info(struct cyclades_port *info, struct cyclades_monitor __user * mon)
+static int get_mon_info(struct cyclades_port *info,
+				struct cyclades_monitor __user *mon)
@@ -3770,2 +3803,2 @@
-static int
-get_threshold(struct cyclades_port *info, unsigned long __user * value)
+static int get_threshold(struct cyclades_port *info,
+						unsigned long __user *value)
@@ -3792,2 +3825,2 @@
-static int
-set_default_threshold(struct cyclades_port *info, unsigned long value)
+static int set_default_threshold(struct cyclades_port *info,
+							unsigned long value)
@@ -3799,2 +3832,2 @@
-static int
-get_default_threshold(struct cyclades_port *info, unsigned long __user * value)
+static int get_default_threshold(struct cyclades_port *info,
+						unsigned long __user *value)
@@ -3827 +3860,2 @@
-static int get_timeout(struct cyclades_port *info, unsigned long __user * value)
+static int get_timeout(struct cyclades_port *info,
+						unsigned long __user *value)
@@ -3854,2 +3888,2 @@
-static int
-get_default_timeout(struct cyclades_port *info, unsigned long __user * value)
+static int get_default_timeout(struct cyclades_port *info,
+					unsigned long __user *value)
@@ -3882,0 +3917 @@
+	lock_kernel();
@@ -3939 +3974 @@
-		info->closing_wait = (unsigned short)arg *HZ / 100;
+		info->closing_wait = (unsigned short)arg * HZ / 100;
@@ -3991 +4026 @@
-			return ret_val;
+			break;
@@ -3994 +4029 @@
-			return ret_val;
+			break;
@@ -3997 +4032 @@
-			return ret_val;
+			break;
@@ -4000 +4035 @@
-			return ret_val;
+			break;
@@ -4003 +4038 @@
-			return ret_val;
+			break;
@@ -4006 +4041 @@
-			return ret_val;
+			break;
@@ -4009 +4044 @@
-			return ret_val;
+			break;
@@ -4012 +4047 @@
-			return ret_val;
+			break;
@@ -4015 +4050 @@
-			return ret_val;
+			break;
@@ -4018 +4053 @@
-			return ret_val;
+			break;
@@ -4021 +4056 @@
-			return ret_val;
+			break;
@@ -4026,0 +4062 @@
+	unlock_kernel();
@@ -4031 +4066,0 @@
-
@@ -4116 +4151 @@
-	if (serial_paranoia_check(info, tty->name, "cy_throttle")) {
+	if (serial_paranoia_check(info, tty->name, "cy_throttle"))
@@ -4118 +4152,0 @@
-	}
@@ -4172 +4206 @@
-		tty_name(tty, buf), tty->ldisc.chars_in_buffer(tty),info->line);
+		tty_name(tty, buf), tty_chars_in_buffer(tty), info->line);
@@ -4175 +4209 @@
-	if (serial_paranoia_check(info, tty->name, "cy_unthrottle")) {
+	if (serial_paranoia_check(info, tty->name, "cy_unthrottle"))
@@ -4177 +4210,0 @@
-	}
@@ -4272 +4305,2 @@
-		cy_writeb(base_addr + (CyCAR << index), (u_char) (channel & 0x0003));	/* index channel */
+		cy_writeb(base_addr + (CyCAR << index),
+			(u_char) (channel & 0x0003));	/* index channel */
@@ -4279,34 +4312,0 @@
-static void cy_flush_buffer(struct tty_struct *tty)
-{
-	struct cyclades_port *info = tty->driver_data;
-	struct cyclades_card *card;
-	int channel, retval;
-	unsigned long flags;
-
-#ifdef CY_DEBUG_IO
-	printk(KERN_DEBUG "cyc:cy_flush_buffer ttyC%d\n", info->line);
-#endif
-
-	if (serial_paranoia_check(info, tty->name, "cy_flush_buffer"))
-		return;
-
-	card = info->card;
-	channel = info->line - card->first_line;
-
-	spin_lock_irqsave(&card->card_lock, flags);
-	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
-	spin_unlock_irqrestore(&card->card_lock, flags);
-
-	if (IS_CYC_Z(*card)) {	/* If it is a Z card, flush the on-board
-					   buffers as well */
-		spin_lock_irqsave(&card->card_lock, flags);
-		retval = cyz_issue_cmd(card, channel, C_CM_FLUSH_TX, 0L);
-		if (retval != 0) {
-			printk(KERN_ERR "cyc: flush_buffer retval on ttyC%d "
-				"was %x\n", info->line, retval);
-		}
-		spin_unlock_irqrestore(&card->card_lock, flags);
-	}
-	tty_wakeup(tty);
-}				/* cy_flush_buffer */
-
@@ -4409,4 +4409,5 @@
-			if ((info->chip_rev = readb(cinfo->base_addr +
-				      (cy_chip_offset[chip_number] <<
-				       index) + (CyGFRCR << index))) >=
-			    CD1400_REV_J) {
+			info->chip_rev = readb(cinfo->base_addr +
+				      (cy_chip_offset[chip_number] << index) +
+				      (CyGFRCR << index));
+
+			if (info->chip_rev >= CD1400_REV_J) {
@@ -4457 +4458,2 @@
-	for (chip_number = 0; chip_number < CyMAX_CHIPS_PER_CARD; chip_number++) {
+	for (chip_number = 0; chip_number < CyMAX_CHIPS_PER_CARD;
+							chip_number++) {
@@ -4558 +4560 @@
-		if (isa_address == 0x0000) {
+		if (isa_address == 0x0000)
@@ -4560 +4561,0 @@
-		}
@@ -4563 +4564 @@
-		cy_isa_address = ioremap(isa_address, CyISA_Ywin);
+		cy_isa_address = ioremap_nocache(isa_address, CyISA_Ywin);
@@ -4850 +4850,0 @@
-		//sleep(1);
@@ -4855 +4854,0 @@
-		//sleep(1);
@@ -5385 +5384,2 @@
-	if ((e1 = tty_unregister_driver(cy_serial_driver)))
+	e1 = tty_unregister_driver(cy_serial_driver);
+	if (e1)
--- ./projects/linux/linux-2.6.26/drivers/char/cyclades.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/char/cyclades.c	2008-10-10 00:13:53.000000000 +0200
@@ -765 +765 @@
- * are accessed via settings in info->flags.
+ * are accessed via settings in info->port.flags.
@@ -1006 +1006 @@
-	if (info->tty == NULL) {
+	if (info->port.tty == NULL) {
@@ -1018 +1018 @@
-	tty = info->tty;
+	tty = info->port.tty;
@@ -1044 +1044 @@
-					if (info->flags & ASYNC_SAK)
+					if (info->port.flags & ASYNC_SAK)
@@ -1148 +1148 @@
-	if (info->tty == NULL) {
+	if (info->port.tty == NULL) {
@@ -1193 +1193 @@
-		if (info->xmit_buf == NULL) {
+		if (info->port.xmit_buf == NULL) {
@@ -1199 +1199 @@
-		if (info->tty->stopped || info->tty->hw_stopped) {
+		if (info->port.tty->stopped || info->port.tty->hw_stopped) {
@@ -1214 +1214 @@
-		outch = info->xmit_buf[info->xmit_tail];
+		outch = info->port.xmit_buf[info->xmit_tail];
@@ -1235 +1235 @@
-	tty_wakeup(info->tty);
+	tty_wakeup(info->port.tty);
@@ -1259 +1259 @@
-	if (!info->tty)
+	if (!info->port.tty)
@@ -1276 +1276 @@
-	if ((mdm_change & CyDCD) && (info->flags & ASYNC_CHECK_CD)) {
+	if ((mdm_change & CyDCD) && (info->port.flags & ASYNC_CHECK_CD)) {
@@ -1278,2 +1278,2 @@
-			tty_hangup(info->tty);
-			info->flags &= ~ASYNC_NORMAL_ACTIVE;
+			tty_hangup(info->port.tty);
+			info->port.flags &= ~ASYNC_NORMAL_ACTIVE;
@@ -1281 +1281 @@
-		wake_up_interruptible(&info->open_wait);
+		wake_up_interruptible(&info->port.open_wait);
@@ -1283,2 +1283,2 @@
-	if ((mdm_change & CyCTS) && (info->flags & ASYNC_CTS_FLOW)) {
-		if (info->tty->hw_stopped) {
+	if ((mdm_change & CyCTS) && (info->port.flags & ASYNC_CTS_FLOW)) {
+		if (info->port.tty->hw_stopped) {
@@ -1288 +1288 @@
-				info->tty->hw_stopped = 0;
+				info->port.tty->hw_stopped = 0;
@@ -1292 +1292 @@
-				tty_wakeup(info->tty);
+				tty_wakeup(info->port.tty);
@@ -1298 +1298 @@
-				info->tty->hw_stopped = 1;
+				info->port.tty->hw_stopped = 1;
@@ -1452 +1452 @@
-	struct tty_struct *tty = info->tty;
+	struct tty_struct *tty = info->port.tty;
@@ -1545 +1545 @@
-	struct tty_struct *tty = info->tty;
+	struct tty_struct *tty = info->port.tty;
@@ -1588 +1588 @@
-					&info->xmit_buf[info->xmit_tail],
+					&info->port.xmit_buf[info->xmit_tail],
@@ -1600 +1600 @@
-			data = info->xmit_buf[info->xmit_tail];
+			data = info->port.xmit_buf[info->xmit_tail];
@@ -1645 +1645 @@
-		tty = info->tty;
+		tty = info->port.tty;
@@ -1671 +1671 @@
-			if (info->flags & ASYNC_CHECK_CD) {
+			if (info->port.flags & ASYNC_CHECK_CD) {
@@ -1675 +1675 @@
-					wake_up_interruptible(&info->open_wait);
+					wake_up_interruptible(&info->port.open_wait);
@@ -1677,3 +1677,3 @@
-					tty_hangup(info->tty);
-					wake_up_interruptible(&info->open_wait);
-					info->flags &= ~ASYNC_NORMAL_ACTIVE;
+					tty_hangup(info->port.tty);
+					wake_up_interruptible(&info->port.open_wait);
+					info->port.flags &= ~ASYNC_NORMAL_ACTIVE;
@@ -1817 +1817 @@
-			tty = info->tty;
+			tty = info->port.tty;
@@ -1856 +1856 @@
-	if (info->flags & ASYNC_INITIALIZED) {
+	if (info->port.flags & ASYNC_INITIALIZED) {
@@ -1862,2 +1862,2 @@
-		if (info->tty)
-			set_bit(TTY_IO_ERROR, &info->tty->flags);
+		if (info->port.tty)
+			set_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -1868 +1868 @@
-	if (info->xmit_buf)
+	if (info->port.xmit_buf)
@@ -1871 +1871 @@
-		info->xmit_buf = (unsigned char *)page;
+		info->port.xmit_buf = (unsigned char *)page;
@@ -1912 +1912 @@
-		info->flags |= ASYNC_INITIALIZED;
+		info->port.flags |= ASYNC_INITIALIZED;
@@ -1914,2 +1914,2 @@
-		if (info->tty)
-			clear_bit(TTY_IO_ERROR, &info->tty->flags);
+		if (info->port.tty)
+			clear_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -1997,3 +1997,3 @@
-		info->flags |= ASYNC_INITIALIZED;
-		if (info->tty)
-			clear_bit(TTY_IO_ERROR, &info->tty->flags);
+		info->port.flags |= ASYNC_INITIALIZED;
+		if (info->port.tty)
+			clear_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -2068 +2068 @@
-	if (!(info->flags & ASYNC_INITIALIZED))
+	if (!(info->port.flags & ASYNC_INITIALIZED))
@@ -2090 +2090 @@
-		if (info->xmit_buf) {
+		if (info->port.xmit_buf) {
@@ -2092,2 +2092,2 @@
-			temp = info->xmit_buf;
-			info->xmit_buf = NULL;
+			temp = info->port.xmit_buf;
+			info->port.xmit_buf = NULL;
@@ -2097 +2097 @@
-		if (!info->tty || (info->tty->termios->c_cflag & HUPCL)) {
+		if (!info->port.tty || (info->port.tty->termios->c_cflag & HUPCL)) {
@@ -2111,3 +2111,3 @@
-		if (info->tty)
-			set_bit(TTY_IO_ERROR, &info->tty->flags);
-		info->flags &= ~ASYNC_INITIALIZED;
+		if (info->port.tty)
+			set_bit(TTY_IO_ERROR, &info->port.tty->flags);
+		info->port.flags &= ~ASYNC_INITIALIZED;
@@ -2139 +2139 @@
-		if (info->xmit_buf) {
+		if (info->port.xmit_buf) {
@@ -2141,2 +2141,2 @@
-			temp = info->xmit_buf;
-			info->xmit_buf = NULL;
+			temp = info->port.xmit_buf;
+			info->port.xmit_buf = NULL;
@@ -2146 +2146 @@
-		if (!info->tty || (info->tty->termios->c_cflag & HUPCL)) {
+		if (!info->port.tty || (info->port.tty->termios->c_cflag & HUPCL)) {
@@ -2161,3 +2161,3 @@
-		if (info->tty)
-			set_bit(TTY_IO_ERROR, &info->tty->flags);
-		info->flags &= ~ASYNC_INITIALIZED;
+		if (info->port.tty)
+			set_bit(TTY_IO_ERROR, &info->port.tty->flags);
+		info->port.flags &= ~ASYNC_INITIALIZED;
@@ -2197,4 +2197,4 @@
-	if (tty_hung_up_p(filp) || (info->flags & ASYNC_CLOSING)) {
-		wait_event_interruptible(info->close_wait,
-				!(info->flags & ASYNC_CLOSING));
-		return (info->flags & ASYNC_HUP_NOTIFY) ? -EAGAIN: -ERESTARTSYS;
+	if (tty_hung_up_p(filp) || (info->port.flags & ASYNC_CLOSING)) {
+		wait_event_interruptible(info->port.close_wait,
+				!(info->port.flags & ASYNC_CLOSING));
+		return (info->port.flags & ASYNC_HUP_NOTIFY) ? -EAGAIN: -ERESTARTSYS;
@@ -2209 +2209 @@
-		info->flags |= ASYNC_NORMAL_ACTIVE;
+		info->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -2216 +2216 @@
-	 * this loop, info->count is dropped by one, so that
+	 * this loop, info->port.count is dropped by one, so that
@@ -2221 +2221 @@
-	add_wait_queue(&info->open_wait, &wait);
+	add_wait_queue(&info->port.open_wait, &wait);
@@ -2224 +2224 @@
-		"count = %d\n", info->line, info->count);
+		"count = %d\n", info->line, info->port.count);
@@ -2228 +2228 @@
-		info->count--;
+		info->port.count--;
@@ -2232 +2232 @@
-		"%d\n", current->pid, info->count);
+		"%d\n", current->pid, info->port.count);
@@ -2234 +2234 @@
-	info->blocked_open++;
+	info->port.blocked_open++;
@@ -2263,2 +2263,2 @@
-					!(info->flags & ASYNC_INITIALIZED)) {
-				retval = ((info->flags & ASYNC_HUP_NOTIFY) ?
+					!(info->port.flags & ASYNC_INITIALIZED)) {
+				retval = ((info->port.flags & ASYNC_HUP_NOTIFY) ?
@@ -2272 +2272 @@
-			if (!(info->flags & ASYNC_CLOSING) && (C_CLOCAL(tty) ||
+			if (!(info->port.flags & ASYNC_CLOSING) && (C_CLOCAL(tty) ||
@@ -2287 +2287 @@
-				info->line, info->count);
+				info->line, info->port.count);
@@ -2301 +2301 @@
-			remove_wait_queue(&info->open_wait, &wait);
+			remove_wait_queue(&info->port.open_wait, &wait);
@@ -2330,2 +2330,2 @@
-					!(info->flags & ASYNC_INITIALIZED)) {
-				retval = ((info->flags & ASYNC_HUP_NOTIFY) ?
+					!(info->port.flags & ASYNC_INITIALIZED)) {
+				retval = ((info->port.flags & ASYNC_HUP_NOTIFY) ?
@@ -2335 +2335 @@
-			if (!(info->flags & ASYNC_CLOSING) && (C_CLOCAL(tty) ||
+			if (!(info->port.flags & ASYNC_CLOSING) && (C_CLOCAL(tty) ||
@@ -2347 +2347 @@
-				info->line, info->count);
+				info->line, info->port.count);
@@ -2353 +2353 @@
-	remove_wait_queue(&info->open_wait, &wait);
+	remove_wait_queue(&info->port.open_wait, &wait);
@@ -2355 +2355 @@
-		info->count++;
+		info->port.count++;
@@ -2358 +2358 @@
-			"count to %d\n", current->pid, info->count);
+			"count to %d\n", current->pid, info->port.count);
@@ -2361 +2361 @@
-	info->blocked_open--;
+	info->port.blocked_open--;
@@ -2364 +2364 @@
-		"count = %d\n", info->line, info->count);
+		"count = %d\n", info->line, info->port.count);
@@ -2368 +2368 @@
-	info->flags |= ASYNC_NORMAL_ACTIVE;
+	info->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -2459 +2459 @@
-	info->tty = tty;
+	info->port.tty = tty;
@@ -2465 +2465 @@
-			info->count);
+			info->port.count);
@@ -2467 +2467 @@
-	info->count++;
+	info->port.count++;
@@ -2470 +2470 @@
-		current->pid, info->count);
+		current->pid, info->port.count);
@@ -2476,4 +2476,4 @@
-	if (tty_hung_up_p(filp) || (info->flags & ASYNC_CLOSING)) {
-		wait_event_interruptible(info->close_wait,
-				!(info->flags & ASYNC_CLOSING));
-		return (info->flags & ASYNC_HUP_NOTIFY) ? -EAGAIN: -ERESTARTSYS;
+	if (tty_hung_up_p(filp) || (info->port.flags & ASYNC_CLOSING)) {
+		wait_event_interruptible(info->port.close_wait,
+				!(info->port.flags & ASYNC_CLOSING));
+		return (info->port.flags & ASYNC_HUP_NOTIFY) ? -EAGAIN: -ERESTARTSYS;
@@ -2644 +2644 @@
-		info->count);
+		info->port.count);
@@ -2646 +2646 @@
-	if ((tty->count == 1) && (info->count != 1)) {
+	if ((tty->count == 1) && (info->port.count != 1)) {
@@ -2655,2 +2655,2 @@
-			"tty->count is 1, info->count is %d\n", info->count);
-		info->count = 1;
+			"tty->count is 1, info->port.count is %d\n", info->port.count);
+		info->port.count = 1;
@@ -2660 +2660 @@
-		current->pid, info->count - 1);
+		current->pid, info->port.count - 1);
@@ -2662 +2662 @@
-	if (--info->count < 0) {
+	if (--info->port.count < 0) {
@@ -2666 +2666 @@
-		info->count = 0;
+		info->port.count = 0;
@@ -2668 +2668 @@
-	if (info->count) {
+	if (info->port.count) {
@@ -2672 +2672 @@
-	info->flags |= ASYNC_CLOSING;
+	info->port.flags |= ASYNC_CLOSING;
@@ -2680,2 +2680,2 @@
-	if (info->closing_wait != CY_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, info->closing_wait);
+	if (info->port.closing_wait != CY_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, info->port.closing_wait);
@@ -2695 +2695 @@
-		if (info->flags & ASYNC_INITIALIZED) {
+		if (info->port.flags & ASYNC_INITIALIZED) {
@@ -2734,2 +2734,2 @@
-	info->tty = NULL;
-	if (info->blocked_open) {
+	info->port.tty = NULL;
+	if (info->port.blocked_open) {
@@ -2737 +2737 @@
-		if (info->close_delay) {
+		if (info->port.close_delay) {
@@ -2739 +2739 @@
-						(info->close_delay));
+						(info->port.close_delay));
@@ -2741 +2741 @@
-		wake_up_interruptible(&info->open_wait);
+		wake_up_interruptible(&info->port.open_wait);
@@ -2744,2 +2744,2 @@
-	info->flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
-	wake_up_interruptible(&info->close_wait);
+	info->port.flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
+	wake_up_interruptible(&info->port.close_wait);
@@ -2780 +2780 @@
-	if (!info->xmit_buf)
+	if (!info->port.xmit_buf)
@@ -2791 +2791 @@
-		memcpy(info->xmit_buf + info->xmit_head, buf, c);
+		memcpy(info->port.xmit_buf + info->xmit_head, buf, c);
@@ -2829 +2829 @@
-	if (!info->xmit_buf)
+	if (!info->port.xmit_buf)
@@ -2838 +2838 @@
-	info->xmit_buf[info->xmit_head++] = ch;
+	info->port.xmit_buf[info->xmit_head++] = ch;
@@ -2863 +2863 @@
-			!info->xmit_buf)
+			!info->port.xmit_buf)
@@ -2991 +2991 @@
-	if (!info->tty || !info->tty->termios)
+	if (!info->port.tty || !info->port.tty->termios)
@@ -2997,2 +2997,2 @@
-	cflag = info->tty->termios->c_cflag;
-	iflag = info->tty->termios->c_iflag;
+	cflag = info->port.tty->termios->c_cflag;
+	iflag = info->port.tty->termios->c_iflag;
@@ -3003,9 +3003,9 @@
-	if (info->tty) {
-		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
-			info->tty->alt_speed = 57600;
-		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
-			info->tty->alt_speed = 115200;
-		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
-			info->tty->alt_speed = 230400;
-		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
-			info->tty->alt_speed = 460800;
+	if (info->port.tty) {
+		if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+			info->port.tty->alt_speed = 57600;
+		if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+			info->port.tty->alt_speed = 115200;
+		if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+			info->port.tty->alt_speed = 230400;
+		if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+			info->port.tty->alt_speed = 460800;
@@ -3023,2 +3023,2 @@
-		baud = tty_get_baud_rate(info->tty);
-		if (baud == 38400 && (info->flags & ASYNC_SPD_MASK) ==
+		baud = tty_get_baud_rate(info->port.tty);
+		if (baud == 38400 && (info->port.flags & ASYNC_SPD_MASK) ==
@@ -3041 +3041 @@
-		if (baud == 38400 && (info->flags & ASYNC_SPD_MASK) ==
+		if (baud == 38400 && (info->port.flags & ASYNC_SPD_MASK) ==
@@ -3062 +3062 @@
-		} else if (baud == 38400 && (info->flags & ASYNC_SPD_MASK) ==
+		} else if (baud == 38400 && (info->port.flags & ASYNC_SPD_MASK) ==
@@ -3111 +3111 @@
-			info->flags |= ASYNC_CTS_FLOW;
+			info->port.flags |= ASYNC_CTS_FLOW;
@@ -3114 +3114 @@
-			info->flags &= ~ASYNC_CTS_FLOW;
+			info->port.flags &= ~ASYNC_CTS_FLOW;
@@ -3118 +3118 @@
-			info->flags &= ~ASYNC_CHECK_CD;
+			info->port.flags &= ~ASYNC_CHECK_CD;
@@ -3120 +3120 @@
-			info->flags |= ASYNC_CHECK_CD;
+			info->port.flags |= ASYNC_CHECK_CD;
@@ -3149,2 +3149,2 @@
-			  START_CHAR(info->tty));
-		cy_writeb(base_addr + (CySCHR2 << index), STOP_CHAR(info->tty));
+			  START_CHAR(info->port.tty));
+		cy_writeb(base_addr + (CySCHR2 << index), STOP_CHAR(info->port.tty));
@@ -3166 +3166 @@
-		if (C_CLOCAL(info->tty)) {
+		if (C_CLOCAL(info->port.tty)) {
@@ -3229,2 +3229,2 @@
-		if (info->tty)
-			clear_bit(TTY_IO_ERROR, &info->tty->flags);
+		if (info->port.tty)
+			clear_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -3253,2 +3253,2 @@
-		baud = tty_get_baud_rate(info->tty);
-		if (baud == 38400 && (info->flags & ASYNC_SPD_MASK) ==
+		baud = tty_get_baud_rate(info->port.tty);
+		if (baud == 38400 && (info->port.flags & ASYNC_SPD_MASK) ==
@@ -3269 +3269 @@
-		} else if (baud == 38400 && (info->flags & ASYNC_SPD_MASK) ==
+		} else if (baud == 38400 && (info->port.flags & ASYNC_SPD_MASK) ==
@@ -3321 +3321 @@
-		info->flags &= ~ASYNC_CTS_FLOW;
+		info->port.flags &= ~ASYNC_CTS_FLOW;
@@ -3340 +3340 @@
-			info->flags &= ~ASYNC_CHECK_CD;
+			info->port.flags &= ~ASYNC_CHECK_CD;
@@ -3342 +3342 @@
-			info->flags |= ASYNC_CHECK_CD;
+			info->port.flags |= ASYNC_CHECK_CD;
@@ -3364,2 +3364,2 @@
-		if (info->tty)
-			clear_bit(TTY_IO_ERROR, &info->tty->flags);
+		if (info->port.tty)
+			clear_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -3384,3 +3384,3 @@
-	tmp.flags = info->flags;
-	tmp.close_delay = info->close_delay;
-	tmp.closing_wait = info->closing_wait;
+	tmp.flags = info->port.flags;
+	tmp.close_delay = info->port.close_delay;
+	tmp.closing_wait = info->port.closing_wait;
@@ -3405 +3405 @@
-		if (new_serial.close_delay != info->close_delay ||
+		if (new_serial.close_delay != info->port.close_delay ||
@@ -3409 +3409 @@
-				(info->flags & ASYNC_FLAGS & ~ASYNC_USR_MASK))
+				(info->port.flags & ASYNC_FLAGS & ~ASYNC_USR_MASK))
@@ -3411 +3411 @@
-		info->flags = (info->flags & ~ASYNC_USR_MASK) |
+		info->port.flags = (info->port.flags & ~ASYNC_USR_MASK) |
@@ -3425 +3425 @@
-	info->flags = (info->flags & ~ASYNC_FLAGS) |
+	info->port.flags = (info->port.flags & ~ASYNC_FLAGS) |
@@ -3427,2 +3427,2 @@
-	info->close_delay = new_serial.close_delay * HZ / 100;
-	info->closing_wait = new_serial.closing_wait * HZ / 100;
+	info->port.close_delay = new_serial.close_delay * HZ / 100;
+	info->port.closing_wait = new_serial.closing_wait * HZ / 100;
@@ -3431 +3431 @@
-	if (info->flags & ASYNC_INITIALIZED) {
+	if (info->port.flags & ASYNC_INITIALIZED) {
@@ -3703 +3703 @@
-static void cy_break(struct tty_struct *tty, int break_state)
+static int cy_break(struct tty_struct *tty, int break_state)
@@ -3707,0 +3708 @@
+	int retval = 0;
@@ -3710 +3711 @@
-		return;
+		return -EINVAL;
@@ -3739,2 +3739,0 @@
-		int retval;
-
@@ -3760,0 +3760 @@
+	return retval;
@@ -3974 +3974 @@
-		info->closing_wait = (unsigned short)arg * HZ / 100;
+		info->port.closing_wait = (unsigned short)arg * HZ / 100;
@@ -3978 +3978 @@
-		ret_val = info->closing_wait / (HZ / 100);
+		ret_val = info->port.closing_wait / (HZ / 100);
@@ -4100 +4100 @@
-		wake_up_interruptible(&info->open_wait);
+		wake_up_interruptible(&info->port.open_wait);
@@ -4329 +4329 @@
-	info->count = 0;
+	info->port.count = 0;
@@ -4334,3 +4334,3 @@
-	info->tty = NULL;
-	info->flags &= ~ASYNC_NORMAL_ACTIVE;
-	wake_up_interruptible(&info->open_wait);
+	info->port.tty = NULL;
+	info->port.flags &= ~ASYNC_NORMAL_ACTIVE;
+	wake_up_interruptible(&info->port.open_wait);
@@ -4378,0 +4379 @@
+		tty_port_init(&info->port);
@@ -4382,3 +4382,0 @@
-		info->flags = STD_COM_FLAGS;
-		info->closing_wait = CLOSING_WAIT_DELAY;
-		info->close_delay = 5 * HZ / 10;
@@ -4386,2 +4384,3 @@
-		init_waitqueue_head(&info->open_wait);
-		init_waitqueue_head(&info->close_wait);
+		info->port.closing_wait = CLOSING_WAIT_DELAY;
+		info->port.close_delay = 5 * HZ / 10;
+		info->port.flags = STD_COM_FLAGS;
@@ -4671 +4670 @@
-static inline void __devinit cyz_fpga_copy(void __iomem *fpga, u8 *data,
+static inline void __devinit cyz_fpga_copy(void __iomem *fpga, const u8 *data,
@@ -4704,4 +4703,4 @@
-	void *ptr = fw->data;
-	struct zfile_header *h = ptr;
-	struct zfile_config *c, *cs;
-	struct zfile_block *b, *bs;
+	const void *ptr = fw->data;
+	const struct zfile_header *h = ptr;
+	const struct zfile_config *c, *cs;
+	const struct zfile_block *b, *bs;
@@ -5240 +5239 @@
-			if (info->count)
+			if (info->port.count)
@@ -5249 +5248,2 @@
-					(long)info->tty->ldisc.num);
+					/* FIXME: double check locking */
+					(long)info->port.tty->ldisc.ops->num);
--- ./projects/linux/linux-2.6.27/drivers/char/cyclades.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/char/cyclades.c	2008-12-25 00:26:37.000000000 +0100
@@ -4996 +4996,2 @@
-		addr0 = pci_iomap(pdev, 0, CyPCI_Yctl);
+		addr0 = ioremap_nocache(pci_resource_start(pdev, 0),
+				CyPCI_Yctl);
@@ -5001 +5002,2 @@
-		addr2 = pci_iomap(pdev, 2, CyPCI_Ywin);
+		addr2 = ioremap_nocache(pci_resource_start(pdev, 2),
+				CyPCI_Ywin);
@@ -5016 +5018,2 @@
-		ctl_addr = addr0 = pci_iomap(pdev, 0, CyPCI_Zctl);
+		ctl_addr = addr0 = ioremap_nocache(pci_resource_start(pdev, 0),
+				CyPCI_Zctl);
@@ -5029,2 +5032,2 @@
-		addr2 = pci_iomap(pdev, 2, mailbox == ZE_V1 ?
-				CyPCI_Ze_win : CyPCI_Zwin);
+		addr2 = ioremap_nocache(pci_resource_start(pdev, 2),
+				mailbox == ZE_V1 ? CyPCI_Ze_win : CyPCI_Zwin);
@@ -5162 +5165 @@
-	pci_iounmap(pdev, addr0);
+	iounmap(addr0);
@@ -5164 +5167 @@
-		pci_iounmap(pdev, addr2);
+		iounmap(addr2);
@@ -5189 +5192 @@
-	pci_iounmap(pdev, cinfo->base_addr);
+	iounmap(cinfo->base_addr);
@@ -5191 +5194 @@
-		pci_iounmap(pdev, cinfo->ctl_addr);
+		iounmap(cinfo->ctl_addr);
--- ./projects/linux/linux-2.6.28/drivers/char/cyclades.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/char/cyclades.c	2009-03-24 00:12:14.000000000 +0100
@@ -5013 +5013 @@
-			return -EIO;
+			goto err_unmap;
--- ./projects/linux/linux-2.6.29/drivers/char/cyclades.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/char/cyclades.c	2009-06-27 11:32:32.000000000 +0200
@@ -648,0 +649 @@
+#include <linux/device.h>
@@ -659,0 +661 @@
+#include <linux/seq_file.h>
@@ -871,2 +872,0 @@
-static int cyclades_get_proc_info(char *, char **, off_t, int, int *, void *);
-
@@ -5219,3 +5219 @@
-static int
-cyclades_get_proc_info(char *buf, char **start, off_t offset, int length,
-		int *eof, void *data)
+static int cyclades_proc_show(struct seq_file *m, void *v)
@@ -5225,4 +5222,0 @@
-	int len = 0;
-	off_t begin = 0;
-	off_t pos = 0;
-	int size;
@@ -5231 +5225 @@
-	size = sprintf(buf, "Dev TimeOpen   BytesOut  IdleOut    BytesIn   "
+	seq_puts(m, "Dev TimeOpen   BytesOut  IdleOut    BytesIn   "
@@ -5234,3 +5227,0 @@
-	pos += size;
-	len += size;
-
@@ -5243 +5234 @@
-				size = sprintf(buf + len, "%3d %8lu %10lu %8lu "
+				seq_printf(m, "%3d %8lu %10lu %8lu "
@@ -5254 +5245 @@
-				size = sprintf(buf + len, "%3d %8lu %10lu %8lu "
+				seq_printf(m, "%3d %8lu %10lu %8lu "
@@ -5257,9 +5247,0 @@
-			len += size;
-			pos = begin + len;
-
-			if (pos < offset) {
-				len = 0;
-				begin = pos;
-			}
-			if (pos > offset + length)
-				goto done;
@@ -5267,9 +5249,6 @@
-	*eof = 1;
-done:
-	*start = buf + (offset - begin);	/* Start of wanted data */
-	len -= (offset - begin);	/* Start slop */
-	if (len > length)
-		len = length;	/* Ending slop */
-	if (len < 0)
-		len = 0;
-	return len;
+	return 0;
+}
+
+static int cyclades_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, cyclades_proc_show, NULL);
@@ -5277,0 +5257,8 @@
+static const struct file_operations cyclades_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= cyclades_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
@@ -5314 +5300,0 @@
-	.read_proc = cyclades_get_proc_info,
@@ -5316,0 +5303 @@
+	.proc_fops = &cyclades_proc_fops,
@@ -5424,0 +5412 @@
+MODULE_ALIAS_CHARDEV_MAJOR(CYCLADES_MAJOR);
--- ./projects/linux/linux-2.6.13/drivers/char/drm/drm_fops.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/char/drm/drm_fops.c	2005-10-28 02:02:08.000000000 +0200
@@ -74,6 +73,0 @@
-	dev->maplist = drm_alloc(sizeof(*dev->maplist),
-				  DRM_MEM_MAPS);
-	if(dev->maplist == NULL) return -ENOMEM;
-	memset(dev->maplist, 0, sizeof(*dev->maplist));
-	INIT_LIST_HEAD(&dev->maplist->head);
-
--- ./projects/linux/linux-2.6.14/drivers/char/drm/drm_fops.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/char/drm/drm_fops.c	2006-01-03 04:21:10.000000000 +0100
@@ -2 +2 @@
- * \file drm_fops.h 
+ * \file drm_fops.c
@@ -4 +4 @@
- * 
+ *
@@ -40 +40,2 @@
-static int drm_open_helper(struct inode *inode, struct file *filp, drm_device_t *dev);
+static int drm_open_helper(struct inode *inode, struct file *filp,
+			   drm_device_t * dev);
@@ -42 +43 @@
-static int drm_setup( drm_device_t *dev )
+static int drm_setup(drm_device_t * dev)
@@ -47,4 +48,3 @@
-	if (dev->driver->presetup)
-	{
-		ret=dev->driver->presetup(dev);
-		if (ret!=0) 
+	if (dev->driver->presetup) {
+		ret = dev->driver->presetup(dev);
+		if (ret != 0)
@@ -54,2 +54,2 @@
-	atomic_set( &dev->ioctl_count, 0 );
-	atomic_set( &dev->vma_count, 0 );
+	atomic_set(&dev->ioctl_count, 0);
+	atomic_set(&dev->vma_count, 0);
@@ -57 +57 @@
-	atomic_set( &dev->buf_alloc, 0 );
+	atomic_set(&dev->buf_alloc, 0);
@@ -59,4 +59,3 @@
-	if (drm_core_check_feature(dev, DRIVER_HAVE_DMA))
-	{
-		i = drm_dma_setup( dev );
-		if ( i < 0 )
+	if (drm_core_check_feature(dev, DRIVER_HAVE_DMA)) {
+		i = drm_dma_setup(dev);
+		if (i < 0)
@@ -66,2 +65,2 @@
-	for ( i = 0 ; i < DRM_ARRAY_SIZE(dev->counts) ; i++ )
-		atomic_set( &dev->counts[i], 0 );
+	for (i = 0; i < DRM_ARRAY_SIZE(dev->counts); i++)
+		atomic_set(&dev->counts[i], 0);
@@ -69 +68 @@
-	for ( i = 0 ; i < DRM_HASH_SIZE ; i++ ) {
+	for (i = 0; i < DRM_HASH_SIZE; i++) {
@@ -74,3 +73,3 @@
-	dev->ctxlist = drm_alloc(sizeof(*dev->ctxlist),
-				  DRM_MEM_CTXLIST);
-	if(dev->ctxlist == NULL) return -ENOMEM;
+	dev->ctxlist = drm_alloc(sizeof(*dev->ctxlist), DRM_MEM_CTXLIST);
+	if (dev->ctxlist == NULL)
+		return -ENOMEM;
@@ -82 +81 @@
-	init_waitqueue_head( &dev->lock.lock_queue );
+	init_waitqueue_head(&dev->lock.lock_queue);
@@ -94 +93 @@
-	init_waitqueue_head( &dev->context_wait );
+	init_waitqueue_head(&dev->context_wait);
@@ -100,3 +98,0 @@
-	dev->buf_rp = dev->buf;
-	dev->buf_wp = dev->buf;
-	dev->buf_end = dev->buf + DRM_BSZ;
@@ -104,2 +100,2 @@
-	init_waitqueue_head( &dev->buf_readers );
-	init_waitqueue_head( &dev->buf_writers );
+	init_waitqueue_head(&dev->buf_readers);
+	init_waitqueue_head(&dev->buf_writers);
@@ -107 +103 @@
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
@@ -111 +107 @@
-	 * in drm_dma_enqueue.	This is more resource-efficient for
+	 * in drm_dma_enqueue.  This is more resource-efficient for
@@ -124 +120 @@
- * 
+ *
@@ -133 +129 @@
-int drm_open( struct inode *inode, struct file *filp )
+int drm_open(struct inode *inode, struct file *filp)
@@ -141 +137 @@
-		
+
@@ -147,8 +143,8 @@
-	
-	retcode = drm_open_helper( inode, filp, dev );
-	if ( !retcode ) {
-		atomic_inc( &dev->counts[_DRM_STAT_OPENS] );
-		spin_lock( &dev->count_lock );
-		if ( !dev->open_count++ ) {
-			spin_unlock( &dev->count_lock );
-			return drm_setup( dev );
+
+	retcode = drm_open_helper(inode, filp, dev);
+	if (!retcode) {
+		atomic_inc(&dev->counts[_DRM_STAT_OPENS]);
+		spin_lock(&dev->count_lock);
+		if (!dev->open_count++) {
+			spin_unlock(&dev->count_lock);
+			return drm_setup(dev);
@@ -156 +152 @@
-		spin_unlock( &dev->count_lock );
+		spin_unlock(&dev->count_lock);
@@ -160,0 +157 @@
+
@@ -175 +172 @@
-int drm_release( struct inode *inode, struct file *filp )
+int drm_release(struct inode *inode, struct file *filp)
@@ -184 +181 @@
-	DRM_DEBUG( "open_count = %d\n", dev->open_count );
+	DRM_DEBUG("open_count = %d\n", dev->open_count);
@@ -193,2 +190,9 @@
-	DRM_DEBUG( "pid = %d, device = 0x%lx, open_count = %d\n",
-		   current->pid, (long)old_encode_dev(priv->head->device), dev->open_count );
+	DRM_DEBUG("pid = %d, device = 0x%lx, open_count = %d\n",
+		  current->pid, (long)old_encode_dev(priv->head->device),
+		  dev->open_count);
+
+	if (priv->lock_count && dev->lock.hw_lock &&
+	    _DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock) &&
+	    dev->lock.filp == filp) {
+		DRM_DEBUG("File %p released, freeing lock for context %d\n",
+			  filp, _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
@@ -196,7 +199,0 @@
-	if ( priv->lock_count && dev->lock.hw_lock &&
-	     _DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock) &&
-	     dev->lock.filp == filp ) {
-		DRM_DEBUG( "File %p released, freeing lock for context %d\n",
-			filp,
-			_DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock) );
-		
@@ -206,2 +203,2 @@
-		drm_lock_free( dev, &dev->lock.hw_lock->lock,
-				_DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock) );
+		drm_lock_free(dev, &dev->lock.hw_lock->lock,
+			      _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
@@ -209,6 +206,6 @@
-				/* FIXME: may require heavy-handed reset of
-                                   hardware at this point, possibly
-                                   processed via a callback to the X
-                                   server. */
-	}
-	else if ( dev->driver->release && priv->lock_count && dev->lock.hw_lock ) {
+		/* FIXME: may require heavy-handed reset of
+		   hardware at this point, possibly
+		   processed via a callback to the X
+		   server. */
+	} else if (dev->driver->release && priv->lock_count
+		   && dev->lock.hw_lock) {
@@ -216 +213 @@
-		DECLARE_WAITQUEUE( entry, current );
+		DECLARE_WAITQUEUE(entry, current);
@@ -218 +215 @@
-		add_wait_queue( &dev->lock.lock_queue, &entry );
+		add_wait_queue(&dev->lock.lock_queue, &entry);
@@ -221 +218 @@
-			if ( !dev->lock.hw_lock ) {
+			if (!dev->lock.hw_lock) {
@@ -226,3 +223,3 @@
-			if ( drm_lock_take( &dev->lock.hw_lock->lock,
-					     DRM_KERNEL_CONTEXT ) ) {
-				dev->lock.filp	    = filp;
+			if (drm_lock_take(&dev->lock.hw_lock->lock,
+					  DRM_KERNEL_CONTEXT)) {
+				dev->lock.filp = filp;
@@ -230 +227 @@
-                                atomic_inc( &dev->counts[_DRM_STAT_LOCKS] );
+				atomic_inc(&dev->counts[_DRM_STAT_LOCKS]);
@@ -233 +230 @@
-				/* Contention */
+			/* Contention */
@@ -235 +232 @@
-			if ( signal_pending( current ) ) {
+			if (signal_pending(current)) {
@@ -241,2 +238,2 @@
-		remove_wait_queue( &dev->lock.lock_queue, &entry );
-		if( !retcode ) {
+		remove_wait_queue(&dev->lock.lock_queue, &entry);
+		if (!retcode) {
@@ -245,2 +242,2 @@
-			drm_lock_free( dev, &dev->lock.hw_lock->lock,
-					DRM_KERNEL_CONTEXT );
+			drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				      DRM_KERNEL_CONTEXT);
@@ -249,3 +246,3 @@
-	
-	if (drm_core_check_feature(dev, DRIVER_HAVE_DMA) && !dev->driver->release)
-	{
+
+	if (drm_core_check_feature(dev, DRIVER_HAVE_DMA)
+	    && !dev->driver->release) {
@@ -255 +252 @@
-	drm_fasync( -1, filp, 0 );
+	drm_fasync(-1, filp, 0);
@@ -257,2 +254,2 @@
-	down( &dev->ctxlist_sem );
-	if ( dev->ctxlist && (!list_empty(&dev->ctxlist->head))) {
+	down(&dev->ctxlist_sem);
+	if (dev->ctxlist && (!list_empty(&dev->ctxlist->head))) {
@@ -261,3 +258,3 @@
-		list_for_each_entry_safe( pos, n, &dev->ctxlist->head, head ) {
-			if ( pos->tag == priv &&
-			     pos->handle != DRM_KERNEL_CONTEXT ) {
+		list_for_each_entry_safe(pos, n, &dev->ctxlist->head, head) {
+			if (pos->tag == priv &&
+			    pos->handle != DRM_KERNEL_CONTEXT) {
@@ -265 +262,2 @@
-					dev->driver->context_dtor(dev, pos->handle);
+					dev->driver->context_dtor(dev,
+								  pos->handle);
@@ -267 +265 @@
-				drm_ctxbitmap_free( dev, pos->handle );
+				drm_ctxbitmap_free(dev, pos->handle);
@@ -269,2 +267,2 @@
-				list_del( &pos->head );
-				drm_free( pos, sizeof(*pos), DRM_MEM_CTXLIST );
+				list_del(&pos->head);
+				drm_free(pos, sizeof(*pos), DRM_MEM_CTXLIST);
@@ -275 +273 @@
-	up( &dev->ctxlist_sem );
+	up(&dev->ctxlist_sem);
@@ -277,2 +275,2 @@
-	down( &dev->struct_sem );
-	if ( priv->remove_auth_on_close == 1 ) {
+	down(&dev->struct_sem);
+	if (priv->remove_auth_on_close == 1) {
@@ -280 +278 @@
-		while ( temp ) {
+		while (temp) {
@@ -285 +283 @@
-	if ( priv->prev ) {
+	if (priv->prev) {
@@ -288 +286 @@
-		dev->file_first	 = priv->next;
+		dev->file_first = priv->next;
@@ -290 +288 @@
-	if ( priv->next ) {
+	if (priv->next) {
@@ -293 +291 @@
-		dev->file_last	 = priv->prev;
+		dev->file_last = priv->prev;
@@ -295,2 +293,2 @@
-	up( &dev->struct_sem );
-	
+	up(&dev->struct_sem);
+
@@ -300 +298 @@
-	drm_free( priv, sizeof(*priv), DRM_MEM_FILES );
+	drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
@@ -306,8 +304,7 @@
-	atomic_inc( &dev->counts[_DRM_STAT_CLOSES] );
-	spin_lock( &dev->count_lock );
-	if ( !--dev->open_count ) {
-		if ( atomic_read( &dev->ioctl_count ) || dev->blocked ) {
-			DRM_ERROR( "Device busy: %d %d\n",
-				   atomic_read( &dev->ioctl_count ),
-				   dev->blocked );
-			spin_unlock( &dev->count_lock );
+	atomic_inc(&dev->counts[_DRM_STAT_CLOSES]);
+	spin_lock(&dev->count_lock);
+	if (!--dev->open_count) {
+		if (atomic_read(&dev->ioctl_count) || dev->blocked) {
+			DRM_ERROR("Device busy: %d %d\n",
+				  atomic_read(&dev->ioctl_count), dev->blocked);
+			spin_unlock(&dev->count_lock);
@@ -317 +314 @@
-		spin_unlock( &dev->count_lock );
+		spin_unlock(&dev->count_lock);
@@ -319 +316 @@
-		return drm_takedown( dev );
+		return drm_takedown(dev);
@@ -321 +318 @@
-	spin_unlock( &dev->count_lock );
+	spin_unlock(&dev->count_lock);
@@ -326,0 +324 @@
+
@@ -330 +328 @@
- * Called whenever a process opens /dev/drm. 
+ * Called whenever a process opens /dev/drm.
@@ -336 +334 @@
- * 
+ *
@@ -340 +338,2 @@
-static int drm_open_helper(struct inode *inode, struct file *filp, drm_device_t *dev)
+static int drm_open_helper(struct inode *inode, struct file *filp,
+			   drm_device_t * dev)
@@ -342,2 +341,2 @@
-	int	     minor = iminor(inode);
-	drm_file_t   *priv;
+	int minor = iminor(inode);
+	drm_file_t *priv;
@@ -346,2 +345,4 @@
-	if (filp->f_flags & O_EXCL)   return -EBUSY; /* No exclusive opens */
-	if (!drm_cpu_valid())        return -EINVAL;
+	if (filp->f_flags & O_EXCL)
+		return -EBUSY;	/* No exclusive opens */
+	if (!drm_cpu_valid())
+		return -EINVAL;
@@ -351,2 +352,3 @@
-	priv		    = drm_alloc(sizeof(*priv), DRM_MEM_FILES);
-	if(!priv) return -ENOMEM;
+	priv = drm_alloc(sizeof(*priv), DRM_MEM_FILES);
+	if (!priv)
+		return -ENOMEM;
@@ -355,6 +357,6 @@
-	filp->private_data  = priv;
-	priv->uid	    = current->euid;
-	priv->pid	    = current->pid;
-	priv->minor	    = minor;
-	priv->head          = drm_heads[minor];
-	priv->ioctl_count   = 0;
+	filp->private_data = priv;
+	priv->uid = current->euid;
+	priv->pid = current->pid;
+	priv->minor = minor;
+	priv->head = drm_heads[minor];
+	priv->ioctl_count = 0;
@@ -362 +364 @@
-	priv->lock_count    = 0;
+	priv->lock_count = 0;
@@ -365 +367 @@
-		ret=dev->driver->open_helper(dev, priv);
+		ret = dev->driver->open_helper(dev, priv);
@@ -372,2 +374,2 @@
-		priv->next	= NULL;
-		priv->prev	= NULL;
+		priv->next = NULL;
+		priv->prev = NULL;
@@ -375 +377 @@
-		dev->file_last	= priv;
+		dev->file_last = priv;
@@ -377,2 +379,2 @@
-		priv->next	     = NULL;
-		priv->prev	     = dev->file_last;
+		priv->next = NULL;
+		priv->prev = dev->file_last;
@@ -380 +382 @@
-		dev->file_last	     = priv;
+		dev->file_last = priv;
@@ -397 +399,2 @@
-			if (b) dev->hose = b->sysdata;
+			if (b)
+				dev->hose = b->sysdata;
@@ -403 +406 @@
-out_free:
+      out_free:
@@ -405 +408 @@
-	filp->private_data=NULL;
+	filp->private_data = NULL;
@@ -412,2 +415,2 @@
-	drm_file_t    *priv   = filp->private_data;
-	drm_device_t  *dev    = priv->head->dev;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
@@ -416 +419,2 @@
-		  current->pid, (long)old_encode_dev(priv->head->device), dev->open_count);
+		  current->pid, (long)old_encode_dev(priv->head->device),
+		  dev->open_count);
@@ -418,0 +423 @@
+
@@ -424,3 +429,3 @@
-	drm_file_t    *priv   = filp->private_data;
-	drm_device_t  *dev    = priv->head->dev;
-	int	      retcode;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	int retcode;
@@ -428 +433,2 @@
-	DRM_DEBUG("fd = %d, device = 0x%lx\n", fd, (long)old_encode_dev(priv->head->device));
+	DRM_DEBUG("fd = %d, device = 0x%lx\n", fd,
+		  (long)old_encode_dev(priv->head->device));
@@ -430 +436,2 @@
-	if (retcode < 0) return retcode;
+	if (retcode < 0)
+		return retcode;
@@ -432,0 +440 @@
+
@@ -440 +447,0 @@
-EXPORT_SYMBOL(drm_poll);
@@ -441,0 +449 @@
+EXPORT_SYMBOL(drm_poll);
--- ./projects/linux/linux-2.6.15/drivers/char/drm/drm_fops.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/drm/drm_fops.c	2006-03-20 06:53:29.000000000 +0100
@@ -37,0 +38 @@
+#include "drm_sarea.h"
@@ -44,0 +46 @@
+	drm_local_map_t *map;
@@ -48,2 +50,2 @@
-	if (dev->driver->presetup) {
-		ret = dev->driver->presetup(dev);
+	if (dev->driver->firstopen) {
+		ret = dev->driver->firstopen(dev);
@@ -53,0 +56,5 @@
+	/* prebuild the SAREA */
+	i = drm_addmap(dev, 0, SAREA_MAX, _DRM_SHM, _DRM_CONTAINS_LOCK, &map);
+	if (i != 0)
+		return i;
+
@@ -112,2 +118,0 @@
-	if (dev->driver->postsetup)
-		dev->driver->postsetup(dev);
@@ -157 +161,0 @@
-
@@ -160,0 +165,159 @@
+ * File \c open operation.
+ *
+ * \param inode device inode.
+ * \param filp file pointer.
+ *
+ * Puts the dev->fops corresponding to the device minor number into
+ * \p filp, call the \c open method, and restore the file operations.
+ */
+int drm_stub_open(struct inode *inode, struct file *filp)
+{
+	drm_device_t *dev = NULL;
+	int minor = iminor(inode);
+	int err = -ENODEV;
+	struct file_operations *old_fops;
+
+	DRM_DEBUG("\n");
+
+	if (!((minor >= 0) && (minor < drm_cards_limit)))
+		return -ENODEV;
+
+	if (!drm_heads[minor])
+		return -ENODEV;
+
+	if (!(dev = drm_heads[minor]->dev))
+		return -ENODEV;
+
+	old_fops = filp->f_op;
+	filp->f_op = fops_get(&dev->driver->fops);
+	if (filp->f_op->open && (err = filp->f_op->open(inode, filp))) {
+		fops_put(filp->f_op);
+		filp->f_op = fops_get(old_fops);
+	}
+	fops_put(old_fops);
+
+	return err;
+}
+
+/**
+ * Check whether DRI will run on this CPU.
+ *
+ * \return non-zero if the DRI will run on this CPU, or zero otherwise.
+ */
+static int drm_cpu_valid(void)
+{
+#if defined(__i386__)
+	if (boot_cpu_data.x86 == 3)
+		return 0;	/* No cmpxchg on a 386 */
+#endif
+#if defined(__sparc__) && !defined(__sparc_v9__)
+	return 0;		/* No cmpxchg before v9 sparc. */
+#endif
+	return 1;
+}
+
+/**
+ * Called whenever a process opens /dev/drm.
+ *
+ * \param inode device inode.
+ * \param filp file pointer.
+ * \param dev device.
+ * \return zero on success or a negative number on failure.
+ *
+ * Creates and initializes a drm_file structure for the file private data in \p
+ * filp and add it into the double linked list in \p dev.
+ */
+static int drm_open_helper(struct inode *inode, struct file *filp,
+			   drm_device_t * dev)
+{
+	int minor = iminor(inode);
+	drm_file_t *priv;
+	int ret;
+
+	if (filp->f_flags & O_EXCL)
+		return -EBUSY;	/* No exclusive opens */
+	if (!drm_cpu_valid())
+		return -EINVAL;
+
+	DRM_DEBUG("pid = %d, minor = %d\n", current->pid, minor);
+
+	priv = drm_alloc(sizeof(*priv), DRM_MEM_FILES);
+	if (!priv)
+		return -ENOMEM;
+
+	memset(priv, 0, sizeof(*priv));
+	filp->private_data = priv;
+	priv->uid = current->euid;
+	priv->pid = current->pid;
+	priv->minor = minor;
+	priv->head = drm_heads[minor];
+	priv->ioctl_count = 0;
+	/* for compatibility root is always authenticated */
+	priv->authenticated = capable(CAP_SYS_ADMIN);
+	priv->lock_count = 0;
+
+	if (dev->driver->open) {
+		ret = dev->driver->open(dev, priv);
+		if (ret < 0)
+			goto out_free;
+	}
+
+	mutex_lock(&dev->struct_mutex);
+	if (!dev->file_last) {
+		priv->next = NULL;
+		priv->prev = NULL;
+		dev->file_first = priv;
+		dev->file_last = priv;
+		/* first opener automatically becomes master */
+		priv->master = 1;
+	} else {
+		priv->next = NULL;
+		priv->prev = dev->file_last;
+		dev->file_last->next = priv;
+		dev->file_last = priv;
+	}
+	mutex_unlock(&dev->struct_mutex);
+
+#ifdef __alpha__
+	/*
+	 * Default the hose
+	 */
+	if (!dev->hose) {
+		struct pci_dev *pci_dev;
+		pci_dev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, NULL);
+		if (pci_dev) {
+			dev->hose = pci_dev->sysdata;
+			pci_dev_put(pci_dev);
+		}
+		if (!dev->hose) {
+			struct pci_bus *b = pci_bus_b(pci_root_buses.next);
+			if (b)
+				dev->hose = b->sysdata;
+		}
+	}
+#endif
+
+	return 0;
+      out_free:
+	drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
+	filp->private_data = NULL;
+	return ret;
+}
+
+/** No-op. */
+int drm_fasync(int fd, struct file *filp, int on)
+{
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	int retcode;
+
+	DRM_DEBUG("fd = %d, device = 0x%lx\n", fd,
+		  (long)old_encode_dev(priv->head->device));
+	retcode = fasync_helper(fd, filp, on, &dev->buf_async);
+	if (retcode < 0)
+		return retcode;
+	return 0;
+}
+EXPORT_SYMBOL(drm_fasync);
+
+/**
@@ -170 +333 @@
- * zero calls takedown().
+ * zero calls drm_lastclose().
@@ -183,2 +346,2 @@
-	if (dev->driver->prerelease)
-		dev->driver->prerelease(dev, filp);
+	if (dev->driver->preclose)
+		dev->driver->preclose(dev, filp);
@@ -200,2 +363,2 @@
-		if (dev->driver->release)
-			dev->driver->release(dev, filp);
+		if (dev->driver->reclaim_buffers_locked)
+			dev->driver->reclaim_buffers_locked(dev, filp);
@@ -210 +373 @@
-	} else if (dev->driver->release && priv->lock_count
+	} else if (dev->driver->reclaim_buffers_locked && priv->lock_count
@@ -240,2 +403 @@
-			if (dev->driver->release)
-				dev->driver->release(dev, filp);
+			dev->driver->reclaim_buffers_locked(dev, filp);
@@ -247,2 +409,2 @@
-	if (drm_core_check_feature(dev, DRIVER_HAVE_DMA)
-	    && !dev->driver->release) {
+	if (drm_core_check_feature(dev, DRIVER_HAVE_DMA) &&
+	    !dev->driver->reclaim_buffers_locked) {
@@ -254 +416 @@
-	down(&dev->ctxlist_sem);
+	mutex_lock(&dev->ctxlist_mutex);
@@ -273 +435 @@
-	up(&dev->ctxlist_sem);
+	mutex_unlock(&dev->ctxlist_mutex);
@@ -275 +437 @@
-	down(&dev->struct_sem);
+	mutex_lock(&dev->struct_mutex);
@@ -293,4 +455 @@
-	up(&dev->struct_sem);
-
-	if (dev->driver->free_filp_priv)
-		dev->driver->free_filp_priv(dev, priv);
+	mutex_unlock(&dev->struct_mutex);
@@ -297,0 +457,2 @@
+	if (dev->driver->postclose)
+		dev->driver->postclose(dev, priv);
@@ -316 +477 @@
-		return drm_takedown(dev);
+		return drm_lastclose(dev);
@@ -324 +484,0 @@
-
@@ -327,116 +486,0 @@
-/**
- * Called whenever a process opens /dev/drm.
- *
- * \param inode device inode.
- * \param filp file pointer.
- * \param dev device.
- * \return zero on success or a negative number on failure.
- *
- * Creates and initializes a drm_file structure for the file private data in \p
- * filp and add it into the double linked list in \p dev.
- */
-static int drm_open_helper(struct inode *inode, struct file *filp,
-			   drm_device_t * dev)
-{
-	int minor = iminor(inode);
-	drm_file_t *priv;
-	int ret;
-
-	if (filp->f_flags & O_EXCL)
-		return -EBUSY;	/* No exclusive opens */
-	if (!drm_cpu_valid())
-		return -EINVAL;
-
-	DRM_DEBUG("pid = %d, minor = %d\n", current->pid, minor);
-
-	priv = drm_alloc(sizeof(*priv), DRM_MEM_FILES);
-	if (!priv)
-		return -ENOMEM;
-
-	memset(priv, 0, sizeof(*priv));
-	filp->private_data = priv;
-	priv->uid = current->euid;
-	priv->pid = current->pid;
-	priv->minor = minor;
-	priv->head = drm_heads[minor];
-	priv->ioctl_count = 0;
-	priv->authenticated = capable(CAP_SYS_ADMIN);
-	priv->lock_count = 0;
-
-	if (dev->driver->open_helper) {
-		ret = dev->driver->open_helper(dev, priv);
-		if (ret < 0)
-			goto out_free;
-	}
-
-	down(&dev->struct_sem);
-	if (!dev->file_last) {
-		priv->next = NULL;
-		priv->prev = NULL;
-		dev->file_first = priv;
-		dev->file_last = priv;
-	} else {
-		priv->next = NULL;
-		priv->prev = dev->file_last;
-		dev->file_last->next = priv;
-		dev->file_last = priv;
-	}
-	up(&dev->struct_sem);
-
-#ifdef __alpha__
-	/*
-	 * Default the hose
-	 */
-	if (!dev->hose) {
-		struct pci_dev *pci_dev;
-		pci_dev = pci_get_class(PCI_CLASS_DISPLAY_VGA << 8, NULL);
-		if (pci_dev) {
-			dev->hose = pci_dev->sysdata;
-			pci_dev_put(pci_dev);
-		}
-		if (!dev->hose) {
-			struct pci_bus *b = pci_bus_b(pci_root_buses.next);
-			if (b)
-				dev->hose = b->sysdata;
-		}
-	}
-#endif
-
-	return 0;
-      out_free:
-	drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
-	filp->private_data = NULL;
-	return ret;
-}
-
-/** No-op. */
-int drm_flush(struct file *filp)
-{
-	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev = priv->head->dev;
-
-	DRM_DEBUG("pid = %d, device = 0x%lx, open_count = %d\n",
-		  current->pid, (long)old_encode_dev(priv->head->device),
-		  dev->open_count);
-	return 0;
-}
-
-EXPORT_SYMBOL(drm_flush);
-
-/** No-op. */
-int drm_fasync(int fd, struct file *filp, int on)
-{
-	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev = priv->head->dev;
-	int retcode;
-
-	DRM_DEBUG("fd = %d, device = 0x%lx\n", fd,
-		  (long)old_encode_dev(priv->head->device));
-	retcode = fasync_helper(fd, filp, on, &dev->buf_async);
-	if (retcode < 0)
-		return retcode;
-	return 0;
-}
-
-EXPORT_SYMBOL(drm_fasync);
-
@@ -448 +491,0 @@
-
--- ./projects/linux/linux-2.6.16/drivers/char/drm/drm_fops.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/char/drm/drm_fops.c	2006-06-18 03:49:35.000000000 +0200
@@ -178 +178 @@
-	struct file_operations *old_fops;
+	const struct file_operations *old_fops;
--- ./projects/linux/linux-2.6.18/drivers/char/drm/drm_fops.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/drm/drm_fops.c	2006-11-29 22:57:37.000000000 +0100
@@ -55,0 +56,2 @@
+	dev->magicfree.next = NULL;
+
@@ -72 +74 @@
-	for (i = 0; i < DRM_ARRAY_SIZE(dev->counts); i++)
+	for (i = 0; i < ARRAY_SIZE(dev->counts); i++)
@@ -75,4 +77,2 @@
-	for (i = 0; i < DRM_HASH_SIZE; i++) {
-		dev->magiclist[i].head = NULL;
-		dev->magiclist[i].tail = NULL;
-	}
+	drm_ht_create(&dev->magiclist, DRM_MAGIC_HASH_ORDER);
+	INIT_LIST_HEAD(&dev->magicfree);
--- ./projects/linux/linux-2.6.21/drivers/char/drm/drm_fops.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/char/drm/drm_fops.c	2007-07-09 01:32:17.000000000 +0200
@@ -48,0 +49 @@
+	u32 sareapage;
@@ -59 +60,2 @@
-	i = drm_addmap(dev, 0, SAREA_MAX, _DRM_SHM, _DRM_CONTAINS_LOCK, &map);
+	sareapage = max_t(unsigned, SAREA_MAX, PAGE_SIZE);
+	i = drm_addmap(dev, 0, sareapage, _DRM_SHM, _DRM_CONTAINS_LOCK, &map);
@@ -87 +89 @@
-	dev->sigdata.lock = dev->lock.hw_lock = NULL;
+	dev->sigdata.lock = NULL;
@@ -357,7 +359,2 @@
-	if (priv->lock_count && dev->lock.hw_lock &&
-	    _DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock) &&
-	    dev->lock.filp == filp) {
-		DRM_DEBUG("File %p released, freeing lock for context %d\n",
-			  filp, _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
-
-		if (dev->driver->reclaim_buffers_locked)
+	if (dev->driver->reclaim_buffers_locked && dev->lock.hw_lock) {
+		if (drm_i_have_hw_lock(filp)) {
@@ -365,20 +362,23 @@
-
-		drm_lock_free(dev, &dev->lock.hw_lock->lock,
-			      _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
-
-		/* FIXME: may require heavy-handed reset of
-		   hardware at this point, possibly
-		   processed via a callback to the X
-		   server. */
-	} else if (dev->driver->reclaim_buffers_locked && priv->lock_count
-		   && dev->lock.hw_lock) {
-		/* The lock is required to reclaim buffers */
-		DECLARE_WAITQUEUE(entry, current);
-
-		add_wait_queue(&dev->lock.lock_queue, &entry);
-		for (;;) {
-			__set_current_state(TASK_INTERRUPTIBLE);
-			if (!dev->lock.hw_lock) {
-				/* Device has been unregistered */
-				retcode = -EINTR;
-				break;
+		} else {
+			unsigned long _end=jiffies + 3*DRM_HZ;
+			int locked = 0;
+
+			drm_idlelock_take(&dev->lock);
+
+			/*
+			 * Wait for a while.
+			 */
+
+			do{
+				spin_lock(&dev->lock.spinlock);
+				locked = dev->lock.idle_has_lock;
+				spin_unlock(&dev->lock.spinlock);
+				if (locked)
+					break;
+				schedule();
+			} while (!time_after_eq(jiffies, _end));
+
+			if (!locked) {
+				DRM_ERROR("reclaim_buffers_locked() deadlock. Please rework this\n"
+					  "\tdriver to use reclaim_buffers_idlelocked() instead.\n"
+					  "\tI will go on reclaiming the buffers anyway.\n");
@@ -386,17 +386 @@
-			if (drm_lock_take(&dev->lock.hw_lock->lock,
-					  DRM_KERNEL_CONTEXT)) {
-				dev->lock.filp = filp;
-				dev->lock.lock_time = jiffies;
-				atomic_inc(&dev->counts[_DRM_STAT_LOCKS]);
-				break;	/* Got lock */
-			}
-			/* Contention */
-			schedule();
-			if (signal_pending(current)) {
-				retcode = -ERESTARTSYS;
-				break;
-			}
-		}
-		__set_current_state(TASK_RUNNING);
-		remove_wait_queue(&dev->lock.lock_queue, &entry);
-		if (!retcode) {
+
@@ -404,2 +388 @@
-			drm_lock_free(dev, &dev->lock.hw_lock->lock,
-				      DRM_KERNEL_CONTEXT);
+			drm_idlelock_release(&dev->lock);
@@ -408,0 +392,17 @@
+	if (dev->driver->reclaim_buffers_idlelocked && dev->lock.hw_lock) {
+
+		drm_idlelock_take(&dev->lock);
+		dev->driver->reclaim_buffers_idlelocked(dev, filp);
+		drm_idlelock_release(&dev->lock);
+
+	}
+
+	if (drm_i_have_hw_lock(filp)) {
+		DRM_DEBUG("File %p released, freeing lock for context %d\n",
+			  filp, _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+
+		drm_lock_free(&dev->lock,
+			      _DRM_LOCKING_CONTEXT(dev->lock.hw_lock->lock));
+	}
+
+
--- ./projects/linux/linux-2.6.22/drivers/char/drm/drm_fops.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/drm/drm_fops.c	2007-10-09 22:31:38.000000000 +0200
@@ -42 +42 @@
-			   drm_device_t * dev);
+			   struct drm_device * dev);
@@ -44 +44 @@
-static int drm_setup(drm_device_t * dev)
+static int drm_setup(struct drm_device * dev)
@@ -82,7 +81,0 @@
-	dev->ctxlist = drm_alloc(sizeof(*dev->ctxlist), DRM_MEM_CTXLIST);
-	if (dev->ctxlist == NULL)
-		return -ENOMEM;
-	memset(dev->ctxlist, 0, sizeof(*dev->ctxlist));
-	INIT_LIST_HEAD(&dev->ctxlist->head);
-
-	dev->vmalist = NULL;
@@ -138 +131 @@
-	drm_device_t *dev = NULL;
+	struct drm_device *dev = NULL;
@@ -177 +170 @@
-	drm_device_t *dev = NULL;
+	struct drm_device *dev = NULL;
@@ -233 +226 @@
-			   drm_device_t * dev)
+			   struct drm_device * dev)
@@ -236 +229 @@
-	drm_file_t *priv;
+	struct drm_file *priv;
@@ -260,0 +254,2 @@
+	INIT_LIST_HEAD(&priv->lhead);
+
@@ -268,6 +263 @@
-	if (!dev->file_last) {
-		priv->next = NULL;
-		priv->prev = NULL;
-		dev->file_first = priv;
-		dev->file_last = priv;
-		/* first opener automatically becomes master */
+	if (list_empty(&dev->filelist))
@@ -275,6 +265,2 @@
-	} else {
-		priv->next = NULL;
-		priv->prev = dev->file_last;
-		dev->file_last->next = priv;
-		dev->file_last = priv;
-	}
+
+	list_add(&priv->lhead, &dev->filelist);
@@ -312,2 +298,2 @@
-	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev = priv->head->dev;
+	struct drm_file *priv = filp->private_data;
+	struct drm_device *dev = priv->head->dev;
@@ -339,2 +325,2 @@
-	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev;
+	struct drm_file *priv = filp->private_data;
+	struct drm_device *dev;
@@ -417,2 +403,2 @@
-	if (dev->ctxlist && (!list_empty(&dev->ctxlist->head))) {
-		drm_ctx_list_t *pos, *n;
+	if (!list_empty(&dev->ctxlist)) {
+		struct drm_ctx_list *pos, *n;
@@ -420 +406 @@
-		list_for_each_entry_safe(pos, n, &dev->ctxlist->head, head) {
+		list_for_each_entry_safe(pos, n, &dev->ctxlist, head) {
@@ -439,2 +425,3 @@
-		drm_file_t *temp = dev->file_first;
-		while (temp) {
+		struct drm_file *temp;
+
+		list_for_each_entry(temp, &dev->filelist, lhead)
@@ -442,12 +428,0 @@
-			temp = temp->next;
-		}
-	}
-	if (priv->prev) {
-		priv->prev->next = priv->next;
-	} else {
-		dev->file_first = priv->next;
-	}
-	if (priv->next) {
-		priv->next->prev = priv->prev;
-	} else {
-		dev->file_last = priv->prev;
@@ -454,0 +430 @@
+	list_del(&priv->lhead);
--- ./projects/linux/linux-2.6.23/drivers/char/drm/drm_fops.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/drm/drm_fops.c	2008-01-24 23:58:37.000000000 +0100
@@ -237 +237 @@
-	DRM_DEBUG("pid = %d, minor = %d\n", current->pid, minor);
+	DRM_DEBUG("pid = %d, minor = %d\n", task_pid_nr(current), minor);
@@ -244,0 +245 @@
+	priv->filp = filp;
@@ -246 +247 @@
-	priv->pid = current->pid;
+	priv->pid = task_pid_nr(current);
@@ -315 +316 @@
- * \param filp file pointer.
+ * \param file_priv DRM file private.
@@ -325,2 +326,2 @@
-	struct drm_file *priv = filp->private_data;
-	struct drm_device *dev;
+	struct drm_file *file_priv = filp->private_data;
+	struct drm_device *dev = file_priv->head->dev;
@@ -330 +330,0 @@
-	dev = priv->head->dev;
@@ -335 +335 @@
-		dev->driver->preclose(dev, filp);
+		dev->driver->preclose(dev, file_priv);
@@ -342 +342,2 @@
-		  current->pid, (long)old_encode_dev(priv->head->device),
+		  task_pid_nr(current),
+		  (long)old_encode_dev(file_priv->head->device),
@@ -346,2 +347,2 @@
-		if (drm_i_have_hw_lock(filp)) {
-			dev->driver->reclaim_buffers_locked(dev, filp);
+		if (drm_i_have_hw_lock(dev, file_priv)) {
+			dev->driver->reclaim_buffers_locked(dev, file_priv);
@@ -373 +374 @@
-			dev->driver->reclaim_buffers_locked(dev, filp);
+			dev->driver->reclaim_buffers_locked(dev, file_priv);
@@ -381 +382 @@
-		dev->driver->reclaim_buffers_idlelocked(dev, filp);
+		dev->driver->reclaim_buffers_idlelocked(dev, file_priv);
@@ -386 +387 @@
-	if (drm_i_have_hw_lock(filp)) {
+	if (drm_i_have_hw_lock(dev, file_priv)) {
@@ -397 +398 @@
-		dev->driver->reclaim_buffers(dev, filp);
+		dev->driver->reclaim_buffers(dev, file_priv);
@@ -407 +408 @@
-			if (pos->tag == priv &&
+			if (pos->tag == file_priv &&
@@ -424 +425 @@
-	if (priv->remove_auth_on_close == 1) {
+	if (file_priv->remove_auth_on_close == 1) {
@@ -430 +431 @@
-	list_del(&priv->lhead);
+	list_del(&file_priv->lhead);
@@ -434,2 +435,2 @@
-		dev->driver->postclose(dev, priv);
-	drm_free(priv, sizeof(*priv), DRM_MEM_FILES);
+		dev->driver->postclose(dev, file_priv);
+	drm_free(file_priv, sizeof(*file_priv), DRM_MEM_FILES);
--- ./projects/linux/linux-2.6.24/drivers/char/drm/drm_fops.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/drm/drm_fops.c	2008-04-17 04:49:44.000000000 +0200
@@ -328,0 +329 @@
+	unsigned long irqflags;
@@ -360 +361,2 @@
-				spin_lock(&dev->lock.spinlock);
+				spin_lock_irqsave(&dev->lock.spinlock,
+						  irqflags);
@@ -362 +364,2 @@
-				spin_unlock(&dev->lock.spinlock);
+				spin_unlock_irqrestore(&dev->lock.spinlock,
+						       irqflags);
--- ./projects/linux/linux-2.6.25/drivers/char/drm/drm_fops.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/drm/drm_fops.c	2008-07-13 23:51:29.000000000 +0200
@@ -132 +132,2 @@
-	int minor = iminor(inode);
+	int minor_id = iminor(inode);
+	struct drm_minor *minor;
@@ -135 +136,2 @@
-	if (!((minor >= 0) && (minor < drm_cards_limit)))
+	minor = idr_find(&drm_minors_idr, minor_id);
+	if (!minor)
@@ -138,4 +140 @@
-	if (!drm_heads[minor])
-		return -ENODEV;
-
-	if (!(dev = drm_heads[minor]->dev))
+	if (!(dev = minor->dev))
@@ -171 +170,2 @@
-	int minor = iminor(inode);
+	struct drm_minor *minor;
+	int minor_id = iminor(inode);
@@ -177,4 +177,2 @@
-	if (!((minor >= 0) && (minor < drm_cards_limit)))
-		return -ENODEV;
-
-	if (!drm_heads[minor])
+	minor = idr_find(&drm_minors_idr, minor_id);
+	if (!minor)
@@ -183 +181 @@
-	if (!(dev = drm_heads[minor]->dev))
+	if (!(dev = minor->dev))
@@ -228 +226 @@
-	int minor = iminor(inode);
+	int minor_id = iminor(inode);
@@ -237 +235 @@
-	DRM_DEBUG("pid = %d, minor = %d\n", task_pid_nr(current), minor);
+	DRM_DEBUG("pid = %d, minor = %d\n", task_pid_nr(current), minor_id);
@@ -248,2 +246 @@
-	priv->minor = minor;
-	priv->head = drm_heads[minor];
+	priv->minor = idr_find(&drm_minors_idr, minor_id);
@@ -300 +297 @@
-	struct drm_device *dev = priv->head->dev;
+	struct drm_device *dev = priv->minor->dev;
@@ -304 +301 @@
-		  (long)old_encode_dev(priv->head->device));
+		  (long)old_encode_dev(priv->minor->device));
@@ -327 +324 @@
-	struct drm_device *dev = file_priv->head->dev;
+	struct drm_device *dev = file_priv->minor->dev;
@@ -329 +325,0 @@
-	unsigned long irqflags;
@@ -344 +340 @@
-		  (long)old_encode_dev(file_priv->head->device),
+		  (long)old_encode_dev(file_priv->minor->device),
@@ -351 +347 @@
-			unsigned long _end=jiffies + 3*DRM_HZ;
+			unsigned long endtime = jiffies + 3 * DRM_HZ;
@@ -361,2 +357 @@
-				spin_lock_irqsave(&dev->lock.spinlock,
-						  irqflags);
+				spin_lock_bh(&dev->lock.spinlock);
@@ -364,2 +359 @@
-				spin_unlock_irqrestore(&dev->lock.spinlock,
-						       irqflags);
+				spin_unlock_bh(&dev->lock.spinlock);
@@ -369 +363 @@
-			} while (!time_after_eq(jiffies, _end));
+			} while (!time_after_eq(jiffies, endtime));
--- ./projects/linux/linux-2.6.14/drivers/char/drm/drm_lock.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/char/drm/drm_lock.c	2006-01-03 04:21:10.000000000 +0100
@@ -2 +2 @@
- * \file drm_lock.h 
+ * \file drm_lock.c
@@ -4 +4 @@
- * 
+ *
@@ -38 +38 @@
-static int drm_lock_transfer(drm_device_t *dev,
+static int drm_lock_transfer(drm_device_t * dev,
@@ -43 +43 @@
-/** 
+/**
@@ -54,2 +54,2 @@
-int drm_lock( struct inode *inode, struct file *filp,
-	       unsigned int cmd, unsigned long arg )
+int drm_lock(struct inode *inode, struct file *filp,
+	     unsigned int cmd, unsigned long arg)
@@ -57,5 +57,5 @@
-        drm_file_t *priv = filp->private_data;
-        drm_device_t *dev = priv->head->dev;
-        DECLARE_WAITQUEUE( entry, current );
-        drm_lock_t lock;
-        int ret = 0;
+	drm_file_t *priv = filp->private_data;
+	drm_device_t *dev = priv->head->dev;
+	DECLARE_WAITQUEUE(entry, current);
+	drm_lock_t lock;
+	int ret = 0;
@@ -65 +65 @@
-        if ( copy_from_user( &lock, (drm_lock_t __user *)arg, sizeof(lock) ) )
+	if (copy_from_user(&lock, (drm_lock_t __user *) arg, sizeof(lock)))
@@ -68,9 +68,9 @@
-        if ( lock.context == DRM_KERNEL_CONTEXT ) {
-                DRM_ERROR( "Process %d using kernel context %d\n",
-			   current->pid, lock.context );
-                return -EINVAL;
-        }
-
-        DRM_DEBUG( "%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
-		   lock.context, current->pid,
-		   dev->lock.hw_lock->lock, lock.flags );
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
+		return -EINVAL;
+	}
+
+	DRM_DEBUG("%d (pid %d) requests lock (0x%08x), flags = 0x%08x\n",
+		  lock.context, current->pid,
+		  dev->lock.hw_lock->lock, lock.flags);
@@ -79 +79 @@
-		if ( lock.context < 0 )
+		if (lock.context < 0)
@@ -82 +82 @@
-	add_wait_queue( &dev->lock.lock_queue, &entry );
+	add_wait_queue(&dev->lock.lock_queue, &entry);
@@ -85 +85 @@
-		if ( !dev->lock.hw_lock ) {
+		if (!dev->lock.hw_lock) {
@@ -90,3 +90,2 @@
-		if ( drm_lock_take( &dev->lock.hw_lock->lock,
-				     lock.context ) ) {
-			dev->lock.filp      = filp;
+		if (drm_lock_take(&dev->lock.hw_lock->lock, lock.context)) {
+			dev->lock.filp = filp;
@@ -94,2 +93,2 @@
-			atomic_inc( &dev->counts[_DRM_STAT_LOCKS] );
-			break;  /* Got lock */
+			atomic_inc(&dev->counts[_DRM_STAT_LOCKS]);
+			break;	/* Got lock */
@@ -97 +96 @@
-		
+
@@ -100 +99 @@
-		if ( signal_pending( current ) ) {
+		if (signal_pending(current)) {
@@ -106 +105 @@
-	remove_wait_queue( &dev->lock.lock_queue, &entry );
+	remove_wait_queue(&dev->lock.lock_queue, &entry);
@@ -108,5 +107,9 @@
-	sigemptyset( &dev->sigmask );
-	sigaddset( &dev->sigmask, SIGSTOP );
-	sigaddset( &dev->sigmask, SIGTSTP );
-	sigaddset( &dev->sigmask, SIGTTIN );
-	sigaddset( &dev->sigmask, SIGTTOU );
+	DRM_DEBUG("%d %s\n", lock.context, ret ? "interrupted" : "has lock");
+	if (ret)
+		return ret;
+
+	sigemptyset(&dev->sigmask);
+	sigaddset(&dev->sigmask, SIGSTOP);
+	sigaddset(&dev->sigmask, SIGTSTP);
+	sigaddset(&dev->sigmask, SIGTTIN);
+	sigaddset(&dev->sigmask, SIGTTOU);
@@ -114,4 +117,3 @@
-	dev->sigdata.lock    = dev->lock.hw_lock;
-	block_all_signals( drm_notifier,
-			   &dev->sigdata, &dev->sigmask );
-	
+	dev->sigdata.lock = dev->lock.hw_lock;
+	block_all_signals(drm_notifier, &dev->sigdata, &dev->sigmask);
+
@@ -120,5 +122,9 @@
-	
-	if ( dev->driver->dma_quiescent && (lock.flags & _DRM_LOCK_QUIESCENT ))
-		return dev->driver->dma_quiescent(dev);
-	
-	/* dev->driver->kernel_context_switch isn't used by any of the x86 
+
+	if (dev->driver->dma_quiescent && (lock.flags & _DRM_LOCK_QUIESCENT)) {
+		if (dev->driver->dma_quiescent(dev)) {
+			DRM_DEBUG("%d waiting for DMA quiescent\n", lock.context);
+			return DRM_ERR(EBUSY);
+		}
+	}
+
+	/* dev->driver->kernel_context_switch isn't used by any of the x86
@@ -127,2 +133,2 @@
-	
-	if (dev->driver->kernel_context_switch && 
+
+	if (dev->driver->kernel_context_switch &&
@@ -130,2 +136,2 @@
-	  dev->driver->kernel_context_switch(dev, dev->last_context, 
-					    lock.context);
+		dev->driver->kernel_context_switch(dev, dev->last_context,
+						   lock.context);
@@ -133,3 +139 @@
-        DRM_DEBUG( "%d %s\n", lock.context, ret ? "interrupted" : "has lock" );
-
-        return ret;
+	return 0;
@@ -138 +142 @@
-/** 
+/**
@@ -149,2 +153,2 @@
-int drm_unlock( struct inode *inode, struct file *filp,
-		 unsigned int cmd, unsigned long arg )
+int drm_unlock(struct inode *inode, struct file *filp,
+	       unsigned int cmd, unsigned long arg)
@@ -156 +160 @@
-	if ( copy_from_user( &lock, (drm_lock_t __user *)arg, sizeof(lock) ) )
+	if (copy_from_user(&lock, (drm_lock_t __user *) arg, sizeof(lock)))
@@ -159,3 +163,3 @@
-	if ( lock.context == DRM_KERNEL_CONTEXT ) {
-		DRM_ERROR( "Process %d using kernel context %d\n",
-			   current->pid, lock.context );
+	if (lock.context == DRM_KERNEL_CONTEXT) {
+		DRM_ERROR("Process %d using kernel context %d\n",
+			  current->pid, lock.context);
@@ -165 +169 @@
-	atomic_inc( &dev->counts[_DRM_STAT_UNLOCKS] );
+	atomic_inc(&dev->counts[_DRM_STAT_UNLOCKS]);
@@ -173,6 +177,6 @@
-		drm_lock_transfer( dev, &dev->lock.hw_lock->lock, 
-				    DRM_KERNEL_CONTEXT );
-		
-		if ( drm_lock_free( dev, &dev->lock.hw_lock->lock,
-				     DRM_KERNEL_CONTEXT ) ) {
-			DRM_ERROR( "\n" );
+		drm_lock_transfer(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT);
+
+		if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
+				  DRM_KERNEL_CONTEXT)) {
+			DRM_ERROR("\n");
@@ -201,2 +205,4 @@
-		if (old & _DRM_LOCK_HELD) new = old | _DRM_LOCK_CONT;
-		else			  new = context | _DRM_LOCK_HELD;
+		if (old & _DRM_LOCK_HELD)
+			new = old | _DRM_LOCK_CONT;
+		else
+			new = context | _DRM_LOCK_HELD;
@@ -215 +221 @@
-				/* Have lock */
+		/* Have lock */
@@ -223,2 +229,2 @@
- * inside *_unlock to give lock to kernel before calling *_dma_schedule. 
- * 
+ * inside *_unlock to give lock to kernel before calling *_dma_schedule.
+ *
@@ -233 +239 @@
-static int drm_lock_transfer(drm_device_t *dev,
+static int drm_lock_transfer(drm_device_t * dev,
@@ -241,2 +247,2 @@
-		old  = *lock;
-		new  = context | _DRM_LOCK_HELD;
+		old = *lock;
+		new = context | _DRM_LOCK_HELD;
@@ -250 +256 @@
- * 
+ *
@@ -254 +260 @@
- * 
+ *
@@ -259,2 +265,2 @@
-int drm_lock_free(drm_device_t *dev,
-		   __volatile__ unsigned int *lock, unsigned int context)
+int drm_lock_free(drm_device_t * dev,
+		  __volatile__ unsigned int *lock, unsigned int context)
@@ -266,2 +272,2 @@
-		old  = *lock;
-		new  = 0;
+		old = *lock;
+		new = 0;
@@ -272,2 +278 @@
-			  context,
-			  _DRM_LOCKING_CONTEXT(old));
+			  context, _DRM_LOCKING_CONTEXT(old));
@@ -293,3 +298,2 @@
-	drm_sigdata_t *s = (drm_sigdata_t *)priv;
-	unsigned int  old, new, prev;
-
+	drm_sigdata_t *s = (drm_sigdata_t *) priv;
+	unsigned int old, new, prev;
@@ -297 +301 @@
-				/* Allow signal delivery if lock isn't held */
+	/* Allow signal delivery if lock isn't held */
@@ -299 +303,2 @@
-	    || _DRM_LOCKING_CONTEXT(s->lock->lock) != s->context) return 1;
+	    || _DRM_LOCKING_CONTEXT(s->lock->lock) != s->context)
+		return 1;
@@ -301,2 +306,2 @@
-				/* Otherwise, set flag to force call to
-                                   drmUnlock */
+	/* Otherwise, set flag to force call to
+	   drmUnlock */
@@ -304,2 +309,2 @@
-		old  = s->lock->lock;
-		new  = old | _DRM_LOCK_CONT;
+		old = s->lock->lock;
+		new = old | _DRM_LOCK_CONT;
--- ./projects/linux/linux-2.6.15/drivers/char/drm/drm_lock.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/drm/drm_lock.c	2006-03-20 06:53:29.000000000 +0100
@@ -133 +132,0 @@
-
--- ./projects/linux/linux-2.6.19/drivers/char/drm/drm_lock.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/drm/drm_lock.c	2007-02-04 19:44:54.000000000 +0100
@@ -157,0 +158 @@
+	unsigned long irqflags;
@@ -167,0 +169,10 @@
+	spin_lock_irqsave(&dev->tasklet_lock, irqflags);
+
+	if (dev->locked_tasklet_func) {
+		dev->locked_tasklet_func(dev);
+
+		dev->locked_tasklet_func = NULL;
+	}
+
+	spin_unlock_irqrestore(&dev->tasklet_lock, irqflags);
+
@@ -174 +185 @@
-		dev->driver->kernel_context_switch_unlock(dev, &lock);
+		dev->driver->kernel_context_switch_unlock(dev);
--- ./projects/linux/linux-2.6.21/drivers/char/drm/drm_lock.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/char/drm/drm_lock.c	2007-07-09 01:32:17.000000000 +0200
@@ -38,3 +37,0 @@
-static int drm_lock_transfer(drm_device_t * dev,
-			     __volatile__ unsigned int *lock,
-			     unsigned int context);
@@ -82,0 +80,3 @@
+	spin_lock(&dev->lock.spinlock);
+	dev->lock.user_waiters++;
+	spin_unlock(&dev->lock.spinlock);
@@ -90 +90 @@
-		if (drm_lock_take(&dev->lock.hw_lock->lock, lock.context)) {
+		if (drm_lock_take(&dev->lock, lock.context)) {
@@ -103,0 +104,3 @@
+	spin_lock(&dev->lock.spinlock);
+	dev->lock.user_waiters--;
+	spin_unlock(&dev->lock.spinlock);
@@ -107,3 +110,2 @@
-	DRM_DEBUG("%d %s\n", lock.context, ret ? "interrupted" : "has lock");
-	if (ret)
-		return ret;
+	DRM_DEBUG( "%d %s\n", lock.context, ret ? "interrupted" : "has lock" );
+	if (ret) return ret;
@@ -130,3 +131,0 @@
-	/* dev->driver->kernel_context_switch isn't used by any of the x86
-	 *  drivers but is used by the Sparc driver.
-	 */
@@ -137,0 +137 @@
+
@@ -187,6 +187,2 @@
-		drm_lock_transfer(dev, &dev->lock.hw_lock->lock,
-				  DRM_KERNEL_CONTEXT);
-
-		if (drm_lock_free(dev, &dev->lock.hw_lock->lock,
-				  DRM_KERNEL_CONTEXT)) {
-			DRM_ERROR("\n");
+		if (drm_lock_free(&dev->lock,lock.context)) {
+			/* FIXME: Should really bail out here. */
@@ -209 +205,2 @@
-int drm_lock_take(__volatile__ unsigned int *lock, unsigned int context)
+int drm_lock_take(drm_lock_data_t *lock_data,
+		  unsigned int context)
@@ -211,0 +209 @@
+	volatile unsigned int *lock = &lock_data->hw_lock->lock;
@@ -212,0 +211 @@
+	spin_lock(&lock_data->spinlock);
@@ -217,2 +216,5 @@
-		else
-			new = context | _DRM_LOCK_HELD;
+		else {
+			new = context | _DRM_LOCK_HELD |
+				((lock_data->user_waiters + lock_data->kernel_waiters > 1) ?
+				 _DRM_LOCK_CONT : 0);
+		}
@@ -220,0 +223,2 @@
+	spin_unlock(&lock_data->spinlock);
+
@@ -230 +234,2 @@
-	if (new == (context | _DRM_LOCK_HELD)) {
+
+	if ((_DRM_LOCKING_CONTEXT(new)) == context && (new & _DRM_LOCK_HELD)) {
@@ -249,2 +254 @@
-static int drm_lock_transfer(drm_device_t * dev,
-			     __volatile__ unsigned int *lock,
+static int drm_lock_transfer(drm_lock_data_t *lock_data,
@@ -253,0 +258 @@
+	volatile unsigned int *lock = &lock_data->hw_lock->lock;
@@ -255 +260 @@
-	dev->lock.filp = NULL;
+	lock_data->filp = NULL;
@@ -275,2 +280 @@
-int drm_lock_free(drm_device_t * dev,
-		  __volatile__ unsigned int *lock, unsigned int context)
+int drm_lock_free(drm_lock_data_t *lock_data, unsigned int context)
@@ -278,0 +283,10 @@
+	volatile unsigned int *lock = &lock_data->hw_lock->lock;
+
+	spin_lock(&lock_data->spinlock);
+	if (lock_data->kernel_waiters != 0) {
+		drm_lock_transfer(lock_data, 0);
+		lock_data->idle_has_lock = 1;
+		spin_unlock(&lock_data->spinlock);
+		return 1;
+	}
+	spin_unlock(&lock_data->spinlock);
@@ -280 +293,0 @@
-	dev->lock.filp = NULL;
@@ -283 +296 @@
-		new = 0;
+		new = _DRM_LOCKING_CONTEXT(old);
@@ -285,0 +299 @@
+
@@ -291 +305 @@
-	wake_up_interruptible(&dev->lock.lock_queue);
+	wake_up_interruptible(&lock_data->lock_queue);
@@ -324,0 +339,64 @@
+
+/**
+ * This function returns immediately and takes the hw lock
+ * with the kernel context if it is free, otherwise it gets the highest priority when and if
+ * it is eventually released.
+ *
+ * This guarantees that the kernel will _eventually_ have the lock _unless_ it is held
+ * by a blocked process. (In the latter case an explicit wait for the hardware lock would cause
+ * a deadlock, which is why the "idlelock" was invented).
+ *
+ * This should be sufficient to wait for GPU idle without
+ * having to worry about starvation.
+ */
+
+void drm_idlelock_take(drm_lock_data_t *lock_data)
+{
+	int ret = 0;
+
+	spin_lock(&lock_data->spinlock);
+	lock_data->kernel_waiters++;
+	if (!lock_data->idle_has_lock) {
+
+		spin_unlock(&lock_data->spinlock);
+		ret = drm_lock_take(lock_data, DRM_KERNEL_CONTEXT);
+		spin_lock(&lock_data->spinlock);
+
+		if (ret == 1)
+			lock_data->idle_has_lock = 1;
+	}
+	spin_unlock(&lock_data->spinlock);
+}
+EXPORT_SYMBOL(drm_idlelock_take);
+
+void drm_idlelock_release(drm_lock_data_t *lock_data)
+{
+	unsigned int old, prev;
+	volatile unsigned int *lock = &lock_data->hw_lock->lock;
+
+	spin_lock(&lock_data->spinlock);
+	if (--lock_data->kernel_waiters == 0) {
+		if (lock_data->idle_has_lock) {
+			do {
+				old = *lock;
+				prev = cmpxchg(lock, old, DRM_KERNEL_CONTEXT);
+			} while (prev != old);
+			wake_up_interruptible(&lock_data->lock_queue);
+			lock_data->idle_has_lock = 0;
+		}
+	}
+	spin_unlock(&lock_data->spinlock);
+}
+EXPORT_SYMBOL(drm_idlelock_release);
+
+
+int drm_i_have_hw_lock(struct file *filp)
+{
+	DRM_DEVICE;
+
+	return (priv->lock_count && dev->lock.hw_lock &&
+		_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock) &&
+		dev->lock.filp == filp);
+}
+
+EXPORT_SYMBOL(drm_i_have_hw_lock);
--- ./projects/linux/linux-2.6.22/drivers/char/drm/drm_lock.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/drm/drm_lock.c	2007-10-09 22:31:38.000000000 +0200
@@ -54,2 +54,2 @@
-	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev = priv->head->dev;
+	struct drm_file *priv = filp->private_data;
+	struct drm_device *dev = priv->head->dev;
@@ -57 +57 @@
-	drm_lock_t lock;
+	struct drm_lock lock;
@@ -62 +62 @@
-	if (copy_from_user(&lock, (drm_lock_t __user *) arg, sizeof(lock)))
+	if (copy_from_user(&lock, (struct drm_lock __user *) arg, sizeof(lock)))
@@ -155,3 +155,3 @@
-	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev = priv->head->dev;
-	drm_lock_t lock;
+	struct drm_file *priv = filp->private_data;
+	struct drm_device *dev = priv->head->dev;
+	struct drm_lock lock;
@@ -160 +160 @@
-	if (copy_from_user(&lock, (drm_lock_t __user *) arg, sizeof(lock)))
+	if (copy_from_user(&lock, (struct drm_lock __user *) arg, sizeof(lock)))
@@ -205 +205 @@
-int drm_lock_take(drm_lock_data_t *lock_data,
+int drm_lock_take(struct drm_lock_data *lock_data,
@@ -254 +254 @@
-static int drm_lock_transfer(drm_lock_data_t *lock_data,
+static int drm_lock_transfer(struct drm_lock_data *lock_data,
@@ -280 +280 @@
-int drm_lock_free(drm_lock_data_t *lock_data, unsigned int context)
+int drm_lock_free(struct drm_lock_data *lock_data, unsigned int context)
@@ -322 +322 @@
-	drm_sigdata_t *s = (drm_sigdata_t *) priv;
+	struct drm_sigdata *s = (struct drm_sigdata *) priv;
@@ -353 +353 @@
-void drm_idlelock_take(drm_lock_data_t *lock_data)
+void drm_idlelock_take(struct drm_lock_data *lock_data)
@@ -372 +372 @@
-void drm_idlelock_release(drm_lock_data_t *lock_data)
+void drm_idlelock_release(struct drm_lock_data *lock_data)
--- ./projects/linux/linux-2.6.23/drivers/char/drm/drm_lock.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/drm/drm_lock.c	2008-01-24 23:58:37.000000000 +0100
@@ -44 +44 @@
- * \param filp file pointer.
+ * \param file_priv DRM file private.
@@ -51,2 +51 @@
-int drm_lock(struct inode *inode, struct file *filp,
-	     unsigned int cmd, unsigned long arg)
+int drm_lock(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -54,2 +52,0 @@
-	struct drm_file *priv = filp->private_data;
-	struct drm_device *dev = priv->head->dev;
@@ -57 +54 @@
-	struct drm_lock lock;
+	struct drm_lock *lock = data;
@@ -60 +57 @@
-	++priv->lock_count;
+	++file_priv->lock_count;
@@ -62,4 +59 @@
-	if (copy_from_user(&lock, (struct drm_lock __user *) arg, sizeof(lock)))
-		return -EFAULT;
-
-	if (lock.context == DRM_KERNEL_CONTEXT) {
+	if (lock->context == DRM_KERNEL_CONTEXT) {
@@ -67 +61 @@
-			  current->pid, lock.context);
+			  task_pid_nr(current), lock->context);
@@ -72,2 +66,2 @@
-		  lock.context, current->pid,
-		  dev->lock.hw_lock->lock, lock.flags);
+		  lock->context, task_pid_nr(current),
+		  dev->lock.hw_lock->lock, lock->flags);
@@ -76 +70 @@
-		if (lock.context < 0)
+		if (lock->context < 0)
@@ -90,2 +84,2 @@
-		if (drm_lock_take(&dev->lock, lock.context)) {
-			dev->lock.filp = filp;
+		if (drm_lock_take(&dev->lock, lock->context)) {
+			dev->lock.file_priv = file_priv;
@@ -110 +104,2 @@
-	DRM_DEBUG( "%d %s\n", lock.context, ret ? "interrupted" : "has lock" );
+	DRM_DEBUG("%d %s\n", lock->context,
+		  ret ? "interrupted" : "has lock");
@@ -118 +113 @@
-	dev->sigdata.context = lock.context;
+	dev->sigdata.context = lock->context;
@@ -122 +117 @@
-	if (dev->driver->dma_ready && (lock.flags & _DRM_LOCK_READY))
+	if (dev->driver->dma_ready && (lock->flags & _DRM_LOCK_READY))
@@ -125 +120,2 @@
-	if (dev->driver->dma_quiescent && (lock.flags & _DRM_LOCK_QUIESCENT)) {
+	if (dev->driver->dma_quiescent && (lock->flags & _DRM_LOCK_QUIESCENT))
+	{
@@ -127,2 +123,3 @@
-			DRM_DEBUG("%d waiting for DMA quiescent\n", lock.context);
-			return DRM_ERR(EBUSY);
+			DRM_DEBUG("%d waiting for DMA quiescent\n",
+				  lock->context);
+			return -EBUSY;
@@ -133 +130 @@
-	    dev->last_context != lock.context) {
+	    dev->last_context != lock->context) {
@@ -135 +132 @@
-						   lock.context);
+						   lock->context);
@@ -145 +142 @@
- * \param filp file pointer.
+ * \param file_priv DRM file private.
@@ -152,2 +149 @@
-int drm_unlock(struct inode *inode, struct file *filp,
-	       unsigned int cmd, unsigned long arg)
+int drm_unlock(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -155,3 +151 @@
-	struct drm_file *priv = filp->private_data;
-	struct drm_device *dev = priv->head->dev;
-	struct drm_lock lock;
+	struct drm_lock *lock = data;
@@ -160,4 +154 @@
-	if (copy_from_user(&lock, (struct drm_lock __user *) arg, sizeof(lock)))
-		return -EFAULT;
-
-	if (lock.context == DRM_KERNEL_CONTEXT) {
+	if (lock->context == DRM_KERNEL_CONTEXT) {
@@ -165 +156 @@
-			  current->pid, lock.context);
+			  task_pid_nr(current), lock->context);
@@ -187 +178 @@
-		if (drm_lock_free(&dev->lock,lock.context)) {
+		if (drm_lock_free(&dev->lock,lock->context)) {
@@ -260 +251 @@
-	lock_data->filp = NULL;
+	lock_data->file_priv = NULL;
@@ -393 +384 @@
-int drm_i_have_hw_lock(struct file *filp)
+int drm_i_have_hw_lock(struct drm_device *dev, struct drm_file *file_priv)
@@ -395,3 +386 @@
-	DRM_DEVICE;
-
-	return (priv->lock_count && dev->lock.hw_lock &&
+	return (file_priv->lock_count && dev->lock.hw_lock &&
@@ -399 +388 @@
-		dev->lock.filp == filp);
+		dev->lock.file_priv == file_priv);
--- ./projects/linux/linux-2.6.24/drivers/char/drm/drm_lock.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/drm/drm_lock.c	2008-04-17 04:49:44.000000000 +0200
@@ -55,0 +56 @@
+	unsigned long irqflags;
@@ -74 +75 @@
-	spin_lock(&dev->lock.spinlock);
+	spin_lock_irqsave(&dev->lock.spinlock, irqflags);
@@ -76 +77 @@
-	spin_unlock(&dev->lock.spinlock);
+	spin_unlock_irqrestore(&dev->lock.spinlock, irqflags);
@@ -98 +99 @@
-	spin_lock(&dev->lock.spinlock);
+	spin_lock_irqsave(&dev->lock.spinlock, irqflags);
@@ -100 +101 @@
-	spin_unlock(&dev->lock.spinlock);
+	spin_unlock_irqrestore(&dev->lock.spinlock, irqflags);
@@ -200,0 +202 @@
+	unsigned long irqflags;
@@ -202 +204 @@
-	spin_lock(&lock_data->spinlock);
+	spin_lock_irqsave(&lock_data->spinlock, irqflags);
@@ -214 +216 @@
-	spin_unlock(&lock_data->spinlock);
+	spin_unlock_irqrestore(&lock_data->spinlock, irqflags);
@@ -274,0 +277 @@
+	unsigned long irqflags;
@@ -276 +279 @@
-	spin_lock(&lock_data->spinlock);
+	spin_lock_irqsave(&lock_data->spinlock, irqflags);
@@ -280 +283 @@
-		spin_unlock(&lock_data->spinlock);
+		spin_unlock_irqrestore(&lock_data->spinlock, irqflags);
@@ -283 +286 @@
-	spin_unlock(&lock_data->spinlock);
+	spin_unlock_irqrestore(&lock_data->spinlock, irqflags);
@@ -346,0 +350 @@
+	unsigned long irqflags;
@@ -348 +352 @@
-	spin_lock(&lock_data->spinlock);
+	spin_lock_irqsave(&lock_data->spinlock, irqflags);
@@ -352 +356 @@
-		spin_unlock(&lock_data->spinlock);
+		spin_unlock_irqrestore(&lock_data->spinlock, irqflags);
@@ -354 +358 @@
-		spin_lock(&lock_data->spinlock);
+		spin_lock_irqsave(&lock_data->spinlock, irqflags);
@@ -359 +363 @@
-	spin_unlock(&lock_data->spinlock);
+	spin_unlock_irqrestore(&lock_data->spinlock, irqflags);
@@ -366,0 +371 @@
+	unsigned long irqflags;
@@ -368 +373 @@
-	spin_lock(&lock_data->spinlock);
+	spin_lock_irqsave(&lock_data->spinlock, irqflags);
@@ -379 +384 @@
-	spin_unlock(&lock_data->spinlock);
+	spin_unlock_irqrestore(&lock_data->spinlock, irqflags);
--- ./projects/linux/linux-2.6.25/drivers/char/drm/drm_lock.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/drm/drm_lock.c	2008-07-13 23:51:29.000000000 +0200
@@ -56 +55,0 @@
-	unsigned long irqflags;
@@ -75 +74 @@
-	spin_lock_irqsave(&dev->lock.spinlock, irqflags);
+	spin_lock_bh(&dev->lock.spinlock);
@@ -77 +76 @@
-	spin_unlock_irqrestore(&dev->lock.spinlock, irqflags);
+	spin_unlock_bh(&dev->lock.spinlock);
@@ -99 +98 @@
-	spin_lock_irqsave(&dev->lock.spinlock, irqflags);
+	spin_lock_bh(&dev->lock.spinlock);
@@ -101 +100 @@
-	spin_unlock_irqrestore(&dev->lock.spinlock, irqflags);
+	spin_unlock_bh(&dev->lock.spinlock);
@@ -202 +200,0 @@
-	unsigned long irqflags;
@@ -204 +202 @@
-	spin_lock_irqsave(&lock_data->spinlock, irqflags);
+	spin_lock_bh(&lock_data->spinlock);
@@ -216 +214 @@
-	spin_unlock_irqrestore(&lock_data->spinlock, irqflags);
+	spin_unlock_bh(&lock_data->spinlock);
@@ -277 +274,0 @@
-	unsigned long irqflags;
@@ -279 +276 @@
-	spin_lock_irqsave(&lock_data->spinlock, irqflags);
+	spin_lock_bh(&lock_data->spinlock);
@@ -283 +280 @@
-		spin_unlock_irqrestore(&lock_data->spinlock, irqflags);
+		spin_unlock_bh(&lock_data->spinlock);
@@ -286 +283 @@
-	spin_unlock_irqrestore(&lock_data->spinlock, irqflags);
+	spin_unlock_bh(&lock_data->spinlock);
@@ -350 +346,0 @@
-	unsigned long irqflags;
@@ -352 +348 @@
-	spin_lock_irqsave(&lock_data->spinlock, irqflags);
+	spin_lock_bh(&lock_data->spinlock);
@@ -356 +352 @@
-		spin_unlock_irqrestore(&lock_data->spinlock, irqflags);
+		spin_unlock_bh(&lock_data->spinlock);
@@ -358 +354 @@
-		spin_lock_irqsave(&lock_data->spinlock, irqflags);
+		spin_lock_bh(&lock_data->spinlock);
@@ -363 +359 @@
-	spin_unlock_irqrestore(&lock_data->spinlock, irqflags);
+	spin_unlock_bh(&lock_data->spinlock);
@@ -371 +366,0 @@
-	unsigned long irqflags;
@@ -373 +368 @@
-	spin_lock_irqsave(&lock_data->spinlock, irqflags);
+	spin_lock_bh(&lock_data->spinlock);
@@ -384 +379 @@
-	spin_unlock_irqrestore(&lock_data->spinlock, irqflags);
+	spin_unlock_bh(&lock_data->spinlock);
--- ./projects/linux/linux-2.6.13/drivers/char/drm/i915_drv.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/char/drm/i915_drv.c	2005-10-28 02:02:08.000000000 +0200
@@ -81,0 +82 @@
+	.device_is_agp = i915_driver_device_is_agp,
--- ./projects/linux/linux-2.6.14/drivers/char/drm/i915_drv.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/char/drm/i915_drv.c	2006-01-03 04:21:10.000000000 +0100
@@ -37 +37 @@
-static int postinit( struct drm_device *dev, unsigned long flags )
+static int postinit(struct drm_device *dev, unsigned long flags)
@@ -44,10 +44,8 @@
-	
-	DRM_INFO( "Initialized %s %d.%d.%d %s on minor %d: %s\n",
-		DRIVER_NAME,
-		DRIVER_MAJOR,
-		DRIVER_MINOR,
-		DRIVER_PATCHLEVEL,
-		DRIVER_DATE,
-		dev->primary.minor,
-		pci_pretty_name(dev->pdev)
-		);
+
+	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
+		 DRIVER_NAME,
+		 DRIVER_MAJOR,
+		 DRIVER_MINOR,
+		 DRIVER_PATCHLEVEL,
+		 DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev)
+	    );
@@ -57 +55 @@
-static int version( drm_version_t *version )
+static int version(drm_version_t * version)
@@ -64,3 +62,3 @@
-	DRM_COPY( version->name, DRIVER_NAME );
-	DRM_COPY( version->date, DRIVER_DATE );
-	DRM_COPY( version->desc, DRIVER_DESC );
+	DRM_COPY(version->name, DRIVER_NAME);
+	DRM_COPY(version->date, DRIVER_DATE);
+	DRM_COPY(version->desc, DRIVER_DESC);
@@ -74,3 +71,0 @@
-extern drm_ioctl_desc_t i915_ioctls[];
-extern int i915_max_ioctl;
-
@@ -78,2 +73,3 @@
-	.driver_features = DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR |
-				DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED,
+	.driver_features =
+	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR |
+	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED,
@@ -94,7 +90,7 @@
-		.owner = THIS_MODULE,
-		.open = drm_open,
-		.release = drm_release,
-		.ioctl = drm_ioctl,
-		.mmap = drm_mmap,
-		.poll = drm_poll,
-		.fasync = drm_fasync,
+		 .owner = THIS_MODULE,
+		 .open = drm_open,
+		 .release = drm_release,
+		 .ioctl = drm_ioctl,
+		 .mmap = drm_mmap,
+		 .poll = drm_poll,
+		 .fasync = drm_fasync,
@@ -102 +98 @@
-		.compat_ioctl = i915_compat_ioctl,
+		 .compat_ioctl = i915_compat_ioctl,
@@ -104 +100 @@
-	},
+		 },
@@ -106,3 +102,3 @@
-		.name          = DRIVER_NAME,
-		.id_table      = pciidlist,
-	}
+		       .name = DRIVER_NAME,
+		       .id_table = pciidlist,
+		       }
@@ -125,2 +121,2 @@
-MODULE_AUTHOR( DRIVER_AUTHOR );
-MODULE_DESCRIPTION( DRIVER_DESC );
+MODULE_AUTHOR(DRIVER_AUTHOR);
+MODULE_DESCRIPTION(DRIVER_DESC);
--- ./projects/linux/linux-2.6.15/drivers/char/drm/i915_drv.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/drm/i915_drv.c	2006-03-20 06:53:29.000000000 +0100
@@ -3 +3 @@
-/**************************************************************************
+/*
@@ -28 +28 @@
- **************************************************************************/
+ */
@@ -37,31 +36,0 @@
-static int postinit(struct drm_device *dev, unsigned long flags)
-{
-	dev->counters += 4;
-	dev->types[6] = _DRM_STAT_IRQ;
-	dev->types[7] = _DRM_STAT_PRIMARY;
-	dev->types[8] = _DRM_STAT_SECONDARY;
-	dev->types[9] = _DRM_STAT_DMA;
-
-	DRM_INFO("Initialized %s %d.%d.%d %s on minor %d: %s\n",
-		 DRIVER_NAME,
-		 DRIVER_MAJOR,
-		 DRIVER_MINOR,
-		 DRIVER_PATCHLEVEL,
-		 DRIVER_DATE, dev->primary.minor, pci_pretty_name(dev->pdev)
-	    );
-	return 0;
-}
-
-static int version(drm_version_t * version)
-{
-	int len;
-
-	version->version_major = DRIVER_MAJOR;
-	version->version_minor = DRIVER_MINOR;
-	version->version_patchlevel = DRIVER_PATCHLEVEL;
-	DRM_COPY(version->name, DRIVER_NAME);
-	DRM_COPY(version->date, DRIVER_DATE);
-	DRM_COPY(version->desc, DRIVER_DESC);
-	return 0;
-}
-
@@ -72,0 +42,3 @@
+	/* don't use mtrr's here, the Xserver or user space app should
+	 * deal with them for intel hardware.
+	 */
@@ -74,4 +46,5 @@
-	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | DRIVER_USE_MTRR |
-	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED,
-	.pretakedown = i915_driver_pretakedown,
-	.prerelease = i915_driver_prerelease,
+	    DRIVER_USE_AGP | DRIVER_REQUIRE_AGP | /* DRIVER_USE_MTRR |*/
+	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL,
+	.load = i915_driver_load,
+	.lastclose = i915_driver_lastclose,
+	.preclose = i915_driver_preclose,
@@ -78,0 +52 @@
+	.vblank_wait = i915_driver_vblank_wait,
@@ -86,2 +59,0 @@
-	.postinit = postinit,
-	.version = version,
@@ -100 +72,2 @@
-		 },
+	},
+
@@ -102,3 +75,10 @@
-		       .name = DRIVER_NAME,
-		       .id_table = pciidlist,
-		       }
+		 .name = DRIVER_NAME,
+		 .id_table = pciidlist,
+	},
+	
+	.name = DRIVER_NAME,
+	.desc = DRIVER_DESC,
+	.date = DRIVER_DATE,
+	.major = DRIVER_MAJOR,
+	.minor = DRIVER_MINOR,
+	.patchlevel = DRIVER_PATCHLEVEL,
--- ./projects/linux/linux-2.6.19/drivers/char/drm/i915_drv.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/drm/i915_drv.c	2007-02-04 19:44:54.000000000 +0100
@@ -47 +47,2 @@
-	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL,
+	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL |
+	    DRIVER_IRQ_VBL2,
@@ -52,0 +54 @@
+	.vblank_wait2 = i915_driver_vblank_wait2,
--- ./projects/linux/linux-2.6.24/drivers/char/drm/i915_drv.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/drm/i915_drv.c	2008-04-17 04:49:44.000000000 +0200
@@ -40,0 +41,489 @@
+enum pipe {
+    PIPE_A = 0,
+    PIPE_B,
+};
+
+static bool i915_pipe_enabled(struct drm_device *dev, enum pipe pipe)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+
+	if (pipe == PIPE_A)
+		return (I915_READ(DPLL_A) & DPLL_VCO_ENABLE);
+	else
+		return (I915_READ(DPLL_B) & DPLL_VCO_ENABLE);
+}
+
+static void i915_save_palette(struct drm_device *dev, enum pipe pipe)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	unsigned long reg = (pipe == PIPE_A ? PALETTE_A : PALETTE_B);
+	u32 *array;
+	int i;
+
+	if (!i915_pipe_enabled(dev, pipe))
+		return;
+
+	if (pipe == PIPE_A)
+		array = dev_priv->save_palette_a;
+	else
+		array = dev_priv->save_palette_b;
+
+	for(i = 0; i < 256; i++)
+		array[i] = I915_READ(reg + (i << 2));
+}
+
+static void i915_restore_palette(struct drm_device *dev, enum pipe pipe)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	unsigned long reg = (pipe == PIPE_A ? PALETTE_A : PALETTE_B);
+	u32 *array;
+	int i;
+
+	if (!i915_pipe_enabled(dev, pipe))
+		return;
+
+	if (pipe == PIPE_A)
+		array = dev_priv->save_palette_a;
+	else
+		array = dev_priv->save_palette_b;
+
+	for(i = 0; i < 256; i++)
+		I915_WRITE(reg + (i << 2), array[i]);
+}
+
+static u8 i915_read_indexed(u16 index_port, u16 data_port, u8 reg)
+{
+	outb(reg, index_port);
+	return inb(data_port);
+}
+
+static u8 i915_read_ar(u16 st01, u8 reg, u16 palette_enable)
+{
+	inb(st01);
+	outb(palette_enable | reg, VGA_AR_INDEX);
+	return inb(VGA_AR_DATA_READ);
+}
+
+static void i915_write_ar(u8 st01, u8 reg, u8 val, u16 palette_enable)
+{
+	inb(st01);
+	outb(palette_enable | reg, VGA_AR_INDEX);
+	outb(val, VGA_AR_DATA_WRITE);
+}
+
+static void i915_write_indexed(u16 index_port, u16 data_port, u8 reg, u8 val)
+{
+	outb(reg, index_port);
+	outb(val, data_port);
+}
+
+static void i915_save_vga(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int i;
+	u16 cr_index, cr_data, st01;
+
+	/* VGA color palette registers */
+	dev_priv->saveDACMASK = inb(VGA_DACMASK);
+	/* DACCRX automatically increments during read */
+	outb(0, VGA_DACRX);
+	/* Read 3 bytes of color data from each index */
+	for (i = 0; i < 256 * 3; i++)
+		dev_priv->saveDACDATA[i] = inb(VGA_DACDATA);
+
+	/* MSR bits */
+	dev_priv->saveMSR = inb(VGA_MSR_READ);
+	if (dev_priv->saveMSR & VGA_MSR_CGA_MODE) {
+		cr_index = VGA_CR_INDEX_CGA;
+		cr_data = VGA_CR_DATA_CGA;
+		st01 = VGA_ST01_CGA;
+	} else {
+		cr_index = VGA_CR_INDEX_MDA;
+		cr_data = VGA_CR_DATA_MDA;
+		st01 = VGA_ST01_MDA;
+	}
+
+	/* CRT controller regs */
+	i915_write_indexed(cr_index, cr_data, 0x11,
+			   i915_read_indexed(cr_index, cr_data, 0x11) &
+			   (~0x80));
+	for (i = 0; i < 0x24; i++)
+		dev_priv->saveCR[i] =
+			i915_read_indexed(cr_index, cr_data, i);
+	/* Make sure we don't turn off CR group 0 writes */
+	dev_priv->saveCR[0x11] &= ~0x80;
+
+	/* Attribute controller registers */
+	inb(st01);
+	dev_priv->saveAR_INDEX = inb(VGA_AR_INDEX);
+	for (i = 0; i < 20; i++)
+		dev_priv->saveAR[i] = i915_read_ar(st01, i, 0);
+	inb(st01);
+	outb(dev_priv->saveAR_INDEX, VGA_AR_INDEX);
+	inb(st01);
+
+	/* Graphics controller registers */
+	for (i = 0; i < 9; i++)
+		dev_priv->saveGR[i] =
+			i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, i);
+
+	dev_priv->saveGR[0x10] =
+		i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x10);
+	dev_priv->saveGR[0x11] =
+		i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x11);
+	dev_priv->saveGR[0x18] =
+		i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x18);
+
+	/* Sequencer registers */
+	for (i = 0; i < 8; i++)
+		dev_priv->saveSR[i] =
+			i915_read_indexed(VGA_SR_INDEX, VGA_SR_DATA, i);
+}
+
+static void i915_restore_vga(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int i;
+	u16 cr_index, cr_data, st01;
+
+	/* MSR bits */
+	outb(dev_priv->saveMSR, VGA_MSR_WRITE);
+	if (dev_priv->saveMSR & VGA_MSR_CGA_MODE) {
+		cr_index = VGA_CR_INDEX_CGA;
+		cr_data = VGA_CR_DATA_CGA;
+		st01 = VGA_ST01_CGA;
+	} else {
+		cr_index = VGA_CR_INDEX_MDA;
+		cr_data = VGA_CR_DATA_MDA;
+		st01 = VGA_ST01_MDA;
+	}
+
+	/* Sequencer registers, don't write SR07 */
+	for (i = 0; i < 7; i++)
+		i915_write_indexed(VGA_SR_INDEX, VGA_SR_DATA, i,
+				   dev_priv->saveSR[i]);
+
+	/* CRT controller regs */
+	/* Enable CR group 0 writes */
+	i915_write_indexed(cr_index, cr_data, 0x11, dev_priv->saveCR[0x11]);
+	for (i = 0; i < 0x24; i++)
+		i915_write_indexed(cr_index, cr_data, i, dev_priv->saveCR[i]);
+
+	/* Graphics controller regs */
+	for (i = 0; i < 9; i++)
+		i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, i,
+				   dev_priv->saveGR[i]);
+
+	i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x10,
+			   dev_priv->saveGR[0x10]);
+	i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x11,
+			   dev_priv->saveGR[0x11]);
+	i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x18,
+			   dev_priv->saveGR[0x18]);
+
+	/* Attribute controller registers */
+	inb(st01);
+	for (i = 0; i < 20; i++)
+		i915_write_ar(st01, i, dev_priv->saveAR[i], 0);
+	inb(st01); /* switch back to index mode */
+	outb(dev_priv->saveAR_INDEX | 0x20, VGA_AR_INDEX);
+	inb(st01);
+
+	/* VGA color palette registers */
+	outb(dev_priv->saveDACMASK, VGA_DACMASK);
+	/* DACCRX automatically increments during read */
+	outb(0, VGA_DACWX);
+	/* Read 3 bytes of color data from each index */
+	for (i = 0; i < 256 * 3; i++)
+		outb(dev_priv->saveDACDATA[i], VGA_DACDATA);
+
+}
+
+static int i915_suspend(struct drm_device *dev, pm_message_t state)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int i;
+
+	if (!dev || !dev_priv) {
+		printk(KERN_ERR "dev: %p, dev_priv: %p\n", dev, dev_priv);
+		printk(KERN_ERR "DRM not initialized, aborting suspend.\n");
+		return -ENODEV;
+	}
+
+	if (state.event == PM_EVENT_PRETHAW)
+		return 0;
+
+	pci_save_state(dev->pdev);
+	pci_read_config_byte(dev->pdev, LBB, &dev_priv->saveLBB);
+
+	/* Pipe & plane A info */
+	dev_priv->savePIPEACONF = I915_READ(PIPEACONF);
+	dev_priv->savePIPEASRC = I915_READ(PIPEASRC);
+	dev_priv->saveFPA0 = I915_READ(FPA0);
+	dev_priv->saveFPA1 = I915_READ(FPA1);
+	dev_priv->saveDPLL_A = I915_READ(DPLL_A);
+	if (IS_I965G(dev))
+		dev_priv->saveDPLL_A_MD = I915_READ(DPLL_A_MD);
+	dev_priv->saveHTOTAL_A = I915_READ(HTOTAL_A);
+	dev_priv->saveHBLANK_A = I915_READ(HBLANK_A);
+	dev_priv->saveHSYNC_A = I915_READ(HSYNC_A);
+	dev_priv->saveVTOTAL_A = I915_READ(VTOTAL_A);
+	dev_priv->saveVBLANK_A = I915_READ(VBLANK_A);
+	dev_priv->saveVSYNC_A = I915_READ(VSYNC_A);
+	dev_priv->saveBCLRPAT_A = I915_READ(BCLRPAT_A);
+
+	dev_priv->saveDSPACNTR = I915_READ(DSPACNTR);
+	dev_priv->saveDSPASTRIDE = I915_READ(DSPASTRIDE);
+	dev_priv->saveDSPASIZE = I915_READ(DSPASIZE);
+	dev_priv->saveDSPAPOS = I915_READ(DSPAPOS);
+	dev_priv->saveDSPABASE = I915_READ(DSPABASE);
+	if (IS_I965G(dev)) {
+		dev_priv->saveDSPASURF = I915_READ(DSPASURF);
+		dev_priv->saveDSPATILEOFF = I915_READ(DSPATILEOFF);
+	}
+	i915_save_palette(dev, PIPE_A);
+	dev_priv->savePIPEASTAT = I915_READ(I915REG_PIPEASTAT);
+
+	/* Pipe & plane B info */
+	dev_priv->savePIPEBCONF = I915_READ(PIPEBCONF);
+	dev_priv->savePIPEBSRC = I915_READ(PIPEBSRC);
+	dev_priv->saveFPB0 = I915_READ(FPB0);
+	dev_priv->saveFPB1 = I915_READ(FPB1);
+	dev_priv->saveDPLL_B = I915_READ(DPLL_B);
+	if (IS_I965G(dev))
+		dev_priv->saveDPLL_B_MD = I915_READ(DPLL_B_MD);
+	dev_priv->saveHTOTAL_B = I915_READ(HTOTAL_B);
+	dev_priv->saveHBLANK_B = I915_READ(HBLANK_B);
+	dev_priv->saveHSYNC_B = I915_READ(HSYNC_B);
+	dev_priv->saveVTOTAL_B = I915_READ(VTOTAL_B);
+	dev_priv->saveVBLANK_B = I915_READ(VBLANK_B);
+	dev_priv->saveVSYNC_B = I915_READ(VSYNC_B);
+	dev_priv->saveBCLRPAT_A = I915_READ(BCLRPAT_A);
+
+	dev_priv->saveDSPBCNTR = I915_READ(DSPBCNTR);
+	dev_priv->saveDSPBSTRIDE = I915_READ(DSPBSTRIDE);
+	dev_priv->saveDSPBSIZE = I915_READ(DSPBSIZE);
+	dev_priv->saveDSPBPOS = I915_READ(DSPBPOS);
+	dev_priv->saveDSPBBASE = I915_READ(DSPBBASE);
+	if (IS_I965GM(dev) || IS_IGD_GM(dev)) {
+		dev_priv->saveDSPBSURF = I915_READ(DSPBSURF);
+		dev_priv->saveDSPBTILEOFF = I915_READ(DSPBTILEOFF);
+	}
+	i915_save_palette(dev, PIPE_B);
+	dev_priv->savePIPEBSTAT = I915_READ(I915REG_PIPEBSTAT);
+
+	/* CRT state */
+	dev_priv->saveADPA = I915_READ(ADPA);
+
+	/* LVDS state */
+	dev_priv->savePP_CONTROL = I915_READ(PP_CONTROL);
+	dev_priv->savePFIT_PGM_RATIOS = I915_READ(PFIT_PGM_RATIOS);
+	dev_priv->saveBLC_PWM_CTL = I915_READ(BLC_PWM_CTL);
+	if (IS_I965G(dev))
+		dev_priv->saveBLC_PWM_CTL2 = I915_READ(BLC_PWM_CTL2);
+	if (IS_MOBILE(dev) && !IS_I830(dev))
+		dev_priv->saveLVDS = I915_READ(LVDS);
+	if (!IS_I830(dev) && !IS_845G(dev))
+		dev_priv->savePFIT_CONTROL = I915_READ(PFIT_CONTROL);
+	dev_priv->saveLVDSPP_ON = I915_READ(LVDSPP_ON);
+	dev_priv->saveLVDSPP_OFF = I915_READ(LVDSPP_OFF);
+	dev_priv->savePP_CYCLE = I915_READ(PP_CYCLE);
+
+	/* FIXME: save TV & SDVO state */
+
+	/* FBC state */
+	dev_priv->saveFBC_CFB_BASE = I915_READ(FBC_CFB_BASE);
+	dev_priv->saveFBC_LL_BASE = I915_READ(FBC_LL_BASE);
+	dev_priv->saveFBC_CONTROL2 = I915_READ(FBC_CONTROL2);
+	dev_priv->saveFBC_CONTROL = I915_READ(FBC_CONTROL);
+
+	/* Interrupt state */
+	dev_priv->saveIIR = I915_READ(I915REG_INT_IDENTITY_R);
+	dev_priv->saveIER = I915_READ(I915REG_INT_ENABLE_R);
+	dev_priv->saveIMR = I915_READ(I915REG_INT_MASK_R);
+
+	/* VGA state */
+	dev_priv->saveVCLK_DIVISOR_VGA0 = I915_READ(VCLK_DIVISOR_VGA0);
+	dev_priv->saveVCLK_DIVISOR_VGA1 = I915_READ(VCLK_DIVISOR_VGA1);
+	dev_priv->saveVCLK_POST_DIV = I915_READ(VCLK_POST_DIV);
+	dev_priv->saveVGACNTRL = I915_READ(VGACNTRL);
+
+	/* Clock gating state */
+	dev_priv->saveDSPCLK_GATE_D = I915_READ(DSPCLK_GATE_D);
+
+	/* Cache mode state */
+	dev_priv->saveCACHE_MODE_0 = I915_READ(CACHE_MODE_0);
+
+	/* Memory Arbitration state */
+	dev_priv->saveMI_ARB_STATE = I915_READ(MI_ARB_STATE);
+
+	/* Scratch space */
+	for (i = 0; i < 16; i++) {
+		dev_priv->saveSWF0[i] = I915_READ(SWF0 + (i << 2));
+		dev_priv->saveSWF1[i] = I915_READ(SWF10 + (i << 2));
+	}
+	for (i = 0; i < 3; i++)
+		dev_priv->saveSWF2[i] = I915_READ(SWF30 + (i << 2));
+
+	i915_save_vga(dev);
+
+	if (state.event == PM_EVENT_SUSPEND) {
+		/* Shut down the device */
+		pci_disable_device(dev->pdev);
+		pci_set_power_state(dev->pdev, PCI_D3hot);
+	}
+
+	return 0;
+}
+
+static int i915_resume(struct drm_device *dev)
+{
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int i;
+
+	pci_set_power_state(dev->pdev, PCI_D0);
+	pci_restore_state(dev->pdev);
+	if (pci_enable_device(dev->pdev))
+		return -1;
+
+	pci_write_config_byte(dev->pdev, LBB, dev_priv->saveLBB);
+
+	/* Pipe & plane A info */
+	/* Prime the clock */
+	if (dev_priv->saveDPLL_A & DPLL_VCO_ENABLE) {
+		I915_WRITE(DPLL_A, dev_priv->saveDPLL_A &
+			   ~DPLL_VCO_ENABLE);
+		udelay(150);
+	}
+	I915_WRITE(FPA0, dev_priv->saveFPA0);
+	I915_WRITE(FPA1, dev_priv->saveFPA1);
+	/* Actually enable it */
+	I915_WRITE(DPLL_A, dev_priv->saveDPLL_A);
+	udelay(150);
+	if (IS_I965G(dev))
+		I915_WRITE(DPLL_A_MD, dev_priv->saveDPLL_A_MD);
+	udelay(150);
+
+	/* Restore mode */
+	I915_WRITE(HTOTAL_A, dev_priv->saveHTOTAL_A);
+	I915_WRITE(HBLANK_A, dev_priv->saveHBLANK_A);
+	I915_WRITE(HSYNC_A, dev_priv->saveHSYNC_A);
+	I915_WRITE(VTOTAL_A, dev_priv->saveVTOTAL_A);
+	I915_WRITE(VBLANK_A, dev_priv->saveVBLANK_A);
+	I915_WRITE(VSYNC_A, dev_priv->saveVSYNC_A);
+	I915_WRITE(BCLRPAT_A, dev_priv->saveBCLRPAT_A);
+
+	/* Restore plane info */
+	I915_WRITE(DSPASIZE, dev_priv->saveDSPASIZE);
+	I915_WRITE(DSPAPOS, dev_priv->saveDSPAPOS);
+	I915_WRITE(PIPEASRC, dev_priv->savePIPEASRC);
+	I915_WRITE(DSPABASE, dev_priv->saveDSPABASE);
+	I915_WRITE(DSPASTRIDE, dev_priv->saveDSPASTRIDE);
+	if (IS_I965G(dev)) {
+		I915_WRITE(DSPASURF, dev_priv->saveDSPASURF);
+		I915_WRITE(DSPATILEOFF, dev_priv->saveDSPATILEOFF);
+	}
+
+	I915_WRITE(PIPEACONF, dev_priv->savePIPEACONF);
+
+	i915_restore_palette(dev, PIPE_A);
+	/* Enable the plane */
+	I915_WRITE(DSPACNTR, dev_priv->saveDSPACNTR);
+	I915_WRITE(DSPABASE, I915_READ(DSPABASE));
+
+	/* Pipe & plane B info */
+	if (dev_priv->saveDPLL_B & DPLL_VCO_ENABLE) {
+		I915_WRITE(DPLL_B, dev_priv->saveDPLL_B &
+			   ~DPLL_VCO_ENABLE);
+		udelay(150);
+	}
+	I915_WRITE(FPB0, dev_priv->saveFPB0);
+	I915_WRITE(FPB1, dev_priv->saveFPB1);
+	/* Actually enable it */
+	I915_WRITE(DPLL_B, dev_priv->saveDPLL_B);
+	udelay(150);
+	if (IS_I965G(dev))
+		I915_WRITE(DPLL_B_MD, dev_priv->saveDPLL_B_MD);
+	udelay(150);
+
+	/* Restore mode */
+	I915_WRITE(HTOTAL_B, dev_priv->saveHTOTAL_B);
+	I915_WRITE(HBLANK_B, dev_priv->saveHBLANK_B);
+	I915_WRITE(HSYNC_B, dev_priv->saveHSYNC_B);
+	I915_WRITE(VTOTAL_B, dev_priv->saveVTOTAL_B);
+	I915_WRITE(VBLANK_B, dev_priv->saveVBLANK_B);
+	I915_WRITE(VSYNC_B, dev_priv->saveVSYNC_B);
+	I915_WRITE(BCLRPAT_B, dev_priv->saveBCLRPAT_B);
+
+	/* Restore plane info */
+	I915_WRITE(DSPBSIZE, dev_priv->saveDSPBSIZE);
+	I915_WRITE(DSPBPOS, dev_priv->saveDSPBPOS);
+	I915_WRITE(PIPEBSRC, dev_priv->savePIPEBSRC);
+	I915_WRITE(DSPBBASE, dev_priv->saveDSPBBASE);
+	I915_WRITE(DSPBSTRIDE, dev_priv->saveDSPBSTRIDE);
+	if (IS_I965G(dev)) {
+		I915_WRITE(DSPBSURF, dev_priv->saveDSPBSURF);
+		I915_WRITE(DSPBTILEOFF, dev_priv->saveDSPBTILEOFF);
+	}
+
+	I915_WRITE(PIPEBCONF, dev_priv->savePIPEBCONF);
+
+	i915_restore_palette(dev, PIPE_B);
+	/* Enable the plane */
+	I915_WRITE(DSPBCNTR, dev_priv->saveDSPBCNTR);
+	I915_WRITE(DSPBBASE, I915_READ(DSPBBASE));
+
+	/* CRT state */
+	I915_WRITE(ADPA, dev_priv->saveADPA);
+
+	/* LVDS state */
+	if (IS_I965G(dev))
+		I915_WRITE(BLC_PWM_CTL2, dev_priv->saveBLC_PWM_CTL2);
+	if (IS_MOBILE(dev) && !IS_I830(dev))
+		I915_WRITE(LVDS, dev_priv->saveLVDS);
+	if (!IS_I830(dev) && !IS_845G(dev))
+		I915_WRITE(PFIT_CONTROL, dev_priv->savePFIT_CONTROL);
+
+	I915_WRITE(PFIT_PGM_RATIOS, dev_priv->savePFIT_PGM_RATIOS);
+	I915_WRITE(BLC_PWM_CTL, dev_priv->saveBLC_PWM_CTL);
+	I915_WRITE(LVDSPP_ON, dev_priv->saveLVDSPP_ON);
+	I915_WRITE(LVDSPP_OFF, dev_priv->saveLVDSPP_OFF);
+	I915_WRITE(PP_CYCLE, dev_priv->savePP_CYCLE);
+	I915_WRITE(PP_CONTROL, dev_priv->savePP_CONTROL);
+
+	/* FIXME: restore TV & SDVO state */
+
+	/* FBC info */
+	I915_WRITE(FBC_CFB_BASE, dev_priv->saveFBC_CFB_BASE);
+	I915_WRITE(FBC_LL_BASE, dev_priv->saveFBC_LL_BASE);
+	I915_WRITE(FBC_CONTROL2, dev_priv->saveFBC_CONTROL2);
+	I915_WRITE(FBC_CONTROL, dev_priv->saveFBC_CONTROL);
+
+	/* VGA state */
+	I915_WRITE(VGACNTRL, dev_priv->saveVGACNTRL);
+	I915_WRITE(VCLK_DIVISOR_VGA0, dev_priv->saveVCLK_DIVISOR_VGA0);
+	I915_WRITE(VCLK_DIVISOR_VGA1, dev_priv->saveVCLK_DIVISOR_VGA1);
+	I915_WRITE(VCLK_POST_DIV, dev_priv->saveVCLK_POST_DIV);
+	udelay(150);
+
+	/* Clock gating state */
+	I915_WRITE (DSPCLK_GATE_D, dev_priv->saveDSPCLK_GATE_D);
+
+	/* Cache mode state */
+	I915_WRITE (CACHE_MODE_0, dev_priv->saveCACHE_MODE_0 | 0xffff0000);
+
+	/* Memory arbitration state */
+	I915_WRITE (MI_ARB_STATE, dev_priv->saveMI_ARB_STATE | 0xffff0000);
+
+	for (i = 0; i < 16; i++) {
+		I915_WRITE(SWF0 + (i << 2), dev_priv->saveSWF0[i]);
+		I915_WRITE(SWF10 + (i << 2), dev_priv->saveSWF1[i+7]);
+	}
+	for (i = 0; i < 3; i++)
+		I915_WRITE(SWF30 + (i << 2), dev_priv->saveSWF2[i]);
+
+	i915_restore_vga(dev);
+
+	return 0;
+}
+
@@ -49,0 +539 @@
+	.unload = i915_driver_unload,
@@ -51,0 +542,2 @@
+	.suspend = i915_suspend,
+	.resume = i915_resume,
@@ -80 +572 @@
-	
+
--- ./projects/linux/linux-2.6.25/drivers/char/drm/i915_drv.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/drm/i915_drv.c	2008-07-13 23:51:29.000000000 +0200
@@ -150 +150 @@
-	for (i = 0; i < 0x24; i++)
+	for (i = 0; i <= 0x24; i++)
@@ -159 +159 @@
-	for (i = 0; i < 20; i++)
+	for (i = 0; i <= 0x14; i++)
@@ -209 +209 @@
-	for (i = 0; i < 0x24; i++)
+	for (i = 0; i <= 0x24; i++)
@@ -226 +226 @@
-	for (i = 0; i < 20; i++)
+	for (i = 0; i <= 0x14; i++)
@@ -258,0 +259,3 @@
+	/* Display arbitration control */
+	dev_priv->saveDSPARB = I915_READ(DSPARB);
+
@@ -351,0 +355 @@
+	dev_priv->saveD_STATE = I915_READ(D_STATE);
@@ -387,0 +392 @@
+	pci_set_master(dev->pdev);
@@ -390,0 +396,2 @@
+	I915_WRITE(DSPARB, dev_priv->saveDSPARB);
+
@@ -509,0 +517 @@
+	I915_WRITE (D_STATE, dev_priv->saveD_STATE);
--- ./projects/linux/linux-2.6.13/drivers/char/drm/radeon_state.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/char/drm/radeon_state.c	2005-10-28 02:02:08.000000000 +0200
@@ -1496 +1496 @@
-#define RADEON_MAX_TEXTURE_SIZE (RADEON_BUFFER_SIZE - 8 * sizeof(u32))
+#define RADEON_MAX_TEXTURE_SIZE RADEON_BUFFER_SIZE
@@ -1509 +1509 @@
-	int size, dwords, tex_width, blit_width;
+	int size, dwords, tex_width, blit_width, spitch;
@@ -1512,0 +1513 @@
+	u32 offset;
@@ -1533,11 +1533,0 @@
-#ifdef __BIG_ENDIAN
-	/* The Mesa texture functions provide the data in little endian as the
-	 * chip wants it, but we need to compensate for the fact that the CP
-	 * ring gets byte-swapped
-	 */
-	BEGIN_RING( 2 );
-	OUT_RING_REG( RADEON_RBBM_GUICNTL, RADEON_HOST_DATA_SWAP_32BIT );
-	ADVANCE_RING();
-#endif
-
-
@@ -1574,0 +1565,4 @@
+	spitch = blit_width >> 6;
+	if (spitch == 0 && image->height > 1)
+		return DRM_ERR(EINVAL);
+
@@ -1627,19 +1620,0 @@
-		buffer[0] = CP_PACKET3( RADEON_CNTL_HOSTDATA_BLT, dwords + 6 );
-		buffer[1] = (RADEON_GMC_DST_PITCH_OFFSET_CNTL |
-			     RADEON_GMC_BRUSH_NONE |
-			     (format << 8) |
-			     RADEON_GMC_SRC_DATATYPE_COLOR |
-			     RADEON_ROP3_S |
-			     RADEON_DP_SRC_SOURCE_HOST_DATA |
-			     RADEON_GMC_CLR_CMP_CNTL_DIS |
-			     RADEON_GMC_WR_MSK_DIS);
-		
-		buffer[2] = (texpitch << 22) | (tex->offset >> 10);
-		buffer[3] = 0xffffffff;
-		buffer[4] = 0xffffffff;
-		buffer[5] = (image->y << 16) | image->x;
-		buffer[6] = (height << 16) | image->width;
-		buffer[7] = dwords;
-		buffer += 8;
-
-		
@@ -1753,3 +1728,22 @@
-		buf->used = (dwords + 8) * sizeof(u32);
-		radeon_cp_dispatch_indirect( dev, buf, 0, buf->used );
-		radeon_cp_discard_buffer( dev, buf );
+		buf->used = size;
+		offset = dev_priv->gart_buffers_offset + buf->offset;
+		BEGIN_RING(9);
+		OUT_RING(CP_PACKET3(RADEON_CNTL_BITBLT_MULTI, 5));
+		OUT_RING(RADEON_GMC_SRC_PITCH_OFFSET_CNTL |
+			 RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+			 RADEON_GMC_BRUSH_NONE |
+			 (format << 8) |
+			 RADEON_GMC_SRC_DATATYPE_COLOR |
+			 RADEON_ROP3_S |
+			 RADEON_DP_SRC_SOURCE_MEMORY |
+			 RADEON_GMC_CLR_CMP_CNTL_DIS |
+			 RADEON_GMC_WR_MSK_DIS );
+		OUT_RING((spitch << 22) | (offset >> 10));
+		OUT_RING((texpitch << 22) | (tex->offset >> 10));
+		OUT_RING(0);
+		OUT_RING((image->x << 16) | image->y);
+		OUT_RING((image->width << 16) | height);
+		RADEON_WAIT_UNTIL_2D_IDLE();
+		ADVANCE_RING();
+
+		radeon_cp_discard_buffer(dev, buf);
@@ -2799,0 +2794,11 @@
+	if(dev_priv->microcode_version == UCODE_R300) {
+		int temp;
+		temp=r300_do_cp_cmdbuf(dev, filp, filp_priv, &cmdbuf);
+	
+		if (orig_bufsz != 0)
+			drm_free(kbuf, orig_bufsz, DRM_MEM_DRIVER);
+	
+		return temp;
+	}
+
+	/* microcode_version != r300 */
--- ./projects/linux/linux-2.6.14/drivers/char/drm/radeon_state.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/char/drm/radeon_state.c	2006-01-03 04:21:10.000000000 +0100
@@ -40,3 +40,5 @@
-static __inline__ int radeon_check_and_fixup_offset( drm_radeon_private_t *dev_priv,
-						     drm_file_t *filp_priv,
-						     u32 *offset ) {
+static __inline__ int radeon_check_and_fixup_offset(drm_radeon_private_t *
+						    dev_priv,
+						    drm_file_t * filp_priv,
+						    u32 *offset)
+{
@@ -46,2 +48,2 @@
-	if ( off >= dev_priv->fb_location &&
-	     off < ( dev_priv->gart_vm_start + dev_priv->gart_size ) )
+	if (off >= dev_priv->fb_location &&
+	    off < (dev_priv->gart_vm_start + dev_priv->gart_size))
@@ -53 +55 @@
-	DRM_DEBUG( "offset fixed up to 0x%x\n", off );
+	DRM_DEBUG("offset fixed up to 0x%x\n", off);
@@ -55,3 +57,3 @@
-	if ( off < dev_priv->fb_location ||
-	     off >= ( dev_priv->gart_vm_start + dev_priv->gart_size ) )
-		return DRM_ERR( EINVAL );
+	if (off < dev_priv->fb_location ||
+	    off >= (dev_priv->gart_vm_start + dev_priv->gart_size))
+		return DRM_ERR(EINVAL);
@@ -64,5 +66,6 @@
-static __inline__ int radeon_check_and_fixup_packets( drm_radeon_private_t *dev_priv,
-						      drm_file_t *filp_priv,
-						      int id,
-						      u32 __user *data ) {
-	switch ( id ) {
+static __inline__ int radeon_check_and_fixup_packets(drm_radeon_private_t *
+						     dev_priv,
+						     drm_file_t * filp_priv,
+						     int id, u32 *data)
+{
+	switch (id) {
@@ -71,5 +74,7 @@
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &data[( RADEON_RB3D_DEPTHOFFSET
-							    - RADEON_PP_MISC ) / 4] ) ) {
-			DRM_ERROR( "Invalid depth buffer offset\n" );
-			return DRM_ERR( EINVAL );
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &data[(RADEON_RB3D_DEPTHOFFSET
+							 -
+							 RADEON_PP_MISC) /
+							4])) {
+			DRM_ERROR("Invalid depth buffer offset\n");
+			return DRM_ERR(EINVAL);
@@ -80,5 +85,7 @@
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &data[( RADEON_RB3D_COLOROFFSET
-							    - RADEON_PP_CNTL ) / 4] ) ) {
-			DRM_ERROR( "Invalid colour buffer offset\n" );
-			return DRM_ERR( EINVAL );
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &data[(RADEON_RB3D_COLOROFFSET
+							 -
+							 RADEON_PP_CNTL) /
+							4])) {
+			DRM_ERROR("Invalid colour buffer offset\n");
+			return DRM_ERR(EINVAL);
@@ -94,4 +101,4 @@
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &data[0] ) ) {
-			DRM_ERROR( "Invalid R200 texture offset\n" );
-			return DRM_ERR( EINVAL );
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &data[0])) {
+			DRM_ERROR("Invalid R200 texture offset\n");
+			return DRM_ERR(EINVAL);
@@ -104,5 +111,7 @@
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &data[( RADEON_PP_TXOFFSET_0
-							    - RADEON_PP_TXFILTER_0 ) / 4] ) ) {
-			DRM_ERROR( "Invalid R100 texture offset\n" );
-			return DRM_ERR( EINVAL );
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &data[(RADEON_PP_TXOFFSET_0
+							 -
+							 RADEON_PP_TXFILTER_0) /
+							4])) {
+			DRM_ERROR("Invalid R100 texture offset\n");
+			return DRM_ERR(EINVAL);
@@ -117,7 +126,9 @@
-	case R200_EMIT_PP_CUBIC_OFFSETS_5: {
-		int i;
-		for ( i = 0; i < 5; i++ ) {
-			if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-							    &data[i] ) ) {
-				DRM_ERROR( "Invalid R200 cubic texture offset\n" );
-				return DRM_ERR( EINVAL );
+	case R200_EMIT_PP_CUBIC_OFFSETS_5:{
+			int i;
+			for (i = 0; i < 5; i++) {
+				if (radeon_check_and_fixup_offset
+				    (dev_priv, filp_priv, &data[i])) {
+					DRM_ERROR
+					    ("Invalid R200 cubic texture offset\n");
+					return DRM_ERR(EINVAL);
+				}
@@ -124,0 +136 @@
+			break;
@@ -126,2 +137,0 @@
-		break;
-	}
@@ -209,0 +220,9 @@
+	case R200_EMIT_PP_AFS_0:
+	case R200_EMIT_PP_AFS_1:
+	case R200_EMIT_ATF_TFACTOR:
+	case R200_EMIT_PP_TXCTLALL_0:
+	case R200_EMIT_PP_TXCTLALL_1:
+	case R200_EMIT_PP_TXCTLALL_2:
+	case R200_EMIT_PP_TXCTLALL_3:
+	case R200_EMIT_PP_TXCTLALL_4:
+	case R200_EMIT_PP_TXCTLALL_5:
@@ -214,2 +233,2 @@
-		DRM_ERROR( "Unknown state packet ID %d\n", id );
-		return DRM_ERR( EINVAL );
+		DRM_ERROR("Unknown state packet ID %d\n", id);
+		return DRM_ERR(EINVAL);
@@ -221,4 +240,6 @@
-static __inline__ int radeon_check_and_fixup_packet3( drm_radeon_private_t *dev_priv,
-						      drm_file_t *filp_priv,
-						      drm_radeon_cmd_buffer_t *cmdbuf,
-						      unsigned int *cmdsz ) {
+static __inline__ int radeon_check_and_fixup_packet3(drm_radeon_private_t *
+						     dev_priv,
+						     drm_file_t * filp_priv,
+						     drm_radeon_kcmd_buffer_t *cmdbuf,
+						     unsigned int *cmdsz)
+{
@@ -227 +248 @@
-	*cmdsz = 2 + ( ( cmd[0] & RADEON_CP_PACKET_COUNT_MASK ) >> 16 );
+	*cmdsz = 2 + ((cmd[0] & RADEON_CP_PACKET_COUNT_MASK) >> 16);
@@ -229,3 +250,3 @@
-	if ( ( cmd[0] & 0xc0000000 ) != RADEON_CP_PACKET3 ) {
-		DRM_ERROR( "Not a type 3 packet\n" );
-		return DRM_ERR( EINVAL );
+	if ((cmd[0] & 0xc0000000) != RADEON_CP_PACKET3) {
+		DRM_ERROR("Not a type 3 packet\n");
+		return DRM_ERR(EINVAL);
@@ -234,3 +255,3 @@
-	if ( 4 * *cmdsz > cmdbuf->bufsz ) {
-		DRM_ERROR( "Packet size larger than size of data provided\n" );
-		return DRM_ERR( EINVAL );
+	if (4 * *cmdsz > cmdbuf->bufsz) {
+		DRM_ERROR("Packet size larger than size of data provided\n");
+		return DRM_ERR(EINVAL);
@@ -240 +261 @@
-	if ( cmd[0] & 0x8000 ) { /* MSB of opcode: next DWORD GUI_CNTL */
+	if (cmd[0] & 0x8000) {	/* MSB of opcode: next DWORD GUI_CNTL */
@@ -243,2 +264,2 @@
-		if ( cmd[1] & ( RADEON_GMC_SRC_PITCH_OFFSET_CNTL
-			      | RADEON_GMC_DST_PITCH_OFFSET_CNTL ) ) {
+		if (cmd[1] & (RADEON_GMC_SRC_PITCH_OFFSET_CNTL
+			      | RADEON_GMC_DST_PITCH_OFFSET_CNTL)) {
@@ -246,3 +267,4 @@
-			if ( radeon_check_and_fixup_offset( dev_priv, filp_priv, &offset ) ) {
-				DRM_ERROR( "Invalid first packet offset\n" );
-				return DRM_ERR( EINVAL );
+			if (radeon_check_and_fixup_offset
+			    (dev_priv, filp_priv, &offset)) {
+				DRM_ERROR("Invalid first packet offset\n");
+				return DRM_ERR(EINVAL);
@@ -250 +272 @@
-			cmd[2] = ( cmd[2] & 0xffc00000 ) | offset >> 10;
+			cmd[2] = (cmd[2] & 0xffc00000) | offset >> 10;
@@ -253,2 +275,2 @@
-		if ( ( cmd[1] & RADEON_GMC_SRC_PITCH_OFFSET_CNTL ) &&
-		     ( cmd[1] & RADEON_GMC_DST_PITCH_OFFSET_CNTL ) ) {
+		if ((cmd[1] & RADEON_GMC_SRC_PITCH_OFFSET_CNTL) &&
+		    (cmd[1] & RADEON_GMC_DST_PITCH_OFFSET_CNTL)) {
@@ -256,3 +278,4 @@
-			if ( radeon_check_and_fixup_offset( dev_priv, filp_priv, &offset ) ) {
-				DRM_ERROR( "Invalid second packet offset\n" );
-				return DRM_ERR( EINVAL );
+			if (radeon_check_and_fixup_offset
+			    (dev_priv, filp_priv, &offset)) {
+				DRM_ERROR("Invalid second packet offset\n");
+				return DRM_ERR(EINVAL);
@@ -260 +283 @@
-			cmd[3] = ( cmd[3] & 0xffc00000 ) | offset >> 10;
+			cmd[3] = (cmd[3] & 0xffc00000) | offset >> 10;
@@ -267 +289,0 @@
-
@@ -272,2 +294,2 @@
-static __inline__ void radeon_emit_clip_rect( drm_radeon_private_t *dev_priv,
-					  drm_clip_rect_t *box )
+static __inline__ void radeon_emit_clip_rect(drm_radeon_private_t * dev_priv,
+					     drm_clip_rect_t * box)
@@ -277,2 +299,2 @@
-	DRM_DEBUG( "   box:  x1=%d y1=%d  x2=%d y2=%d\n",
-		   box->x1, box->y1, box->x2, box->y2 );
+	DRM_DEBUG("   box:  x1=%d y1=%d  x2=%d y2=%d\n",
+		  box->x1, box->y1, box->x2, box->y2);
@@ -280,5 +302,5 @@
-	BEGIN_RING( 4 );
-	OUT_RING( CP_PACKET0( RADEON_RE_TOP_LEFT, 0 ) );
-	OUT_RING( (box->y1 << 16) | box->x1 );
-	OUT_RING( CP_PACKET0( RADEON_RE_WIDTH_HEIGHT, 0 ) );
-	OUT_RING( ((box->y2 - 1) << 16) | (box->x2 - 1) );
+	BEGIN_RING(4);
+	OUT_RING(CP_PACKET0(RADEON_RE_TOP_LEFT, 0));
+	OUT_RING((box->y1 << 16) | box->x1);
+	OUT_RING(CP_PACKET0(RADEON_RE_WIDTH_HEIGHT, 0));
+	OUT_RING(((box->y2 - 1) << 16) | (box->x2 - 1));
@@ -290,5 +312,5 @@
-static int radeon_emit_state( drm_radeon_private_t *dev_priv,
-			      drm_file_t *filp_priv,
-			      drm_radeon_context_regs_t *ctx,
-			      drm_radeon_texture_regs_t *tex,
-			      unsigned int dirty )
+static int radeon_emit_state(drm_radeon_private_t * dev_priv,
+			     drm_file_t * filp_priv,
+			     drm_radeon_context_regs_t * ctx,
+			     drm_radeon_texture_regs_t * tex,
+			     unsigned int dirty)
@@ -297 +319 @@
-	DRM_DEBUG( "dirty=0x%08x\n", dirty );
+	DRM_DEBUG("dirty=0x%08x\n", dirty);
@@ -299,5 +321,5 @@
-	if ( dirty & RADEON_UPLOAD_CONTEXT ) {
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &ctx->rb3d_depthoffset ) ) {
-			DRM_ERROR( "Invalid depth buffer offset\n" );
-			return DRM_ERR( EINVAL );
+	if (dirty & RADEON_UPLOAD_CONTEXT) {
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &ctx->rb3d_depthoffset)) {
+			DRM_ERROR("Invalid depth buffer offset\n");
+			return DRM_ERR(EINVAL);
@@ -306,4 +328,4 @@
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &ctx->rb3d_coloroffset ) ) {
-			DRM_ERROR( "Invalid depth buffer offset\n" );
-			return DRM_ERR( EINVAL );
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &ctx->rb3d_coloroffset)) {
+			DRM_ERROR("Invalid depth buffer offset\n");
+			return DRM_ERR(EINVAL);
@@ -312,15 +334,15 @@
-		BEGIN_RING( 14 );
-		OUT_RING( CP_PACKET0( RADEON_PP_MISC, 6 ) );
-		OUT_RING( ctx->pp_misc );
-		OUT_RING( ctx->pp_fog_color );
-		OUT_RING( ctx->re_solid_color );
-		OUT_RING( ctx->rb3d_blendcntl );
-		OUT_RING( ctx->rb3d_depthoffset );
-		OUT_RING( ctx->rb3d_depthpitch );
-		OUT_RING( ctx->rb3d_zstencilcntl );
-		OUT_RING( CP_PACKET0( RADEON_PP_CNTL, 2 ) );
-		OUT_RING( ctx->pp_cntl );
-		OUT_RING( ctx->rb3d_cntl );
-		OUT_RING( ctx->rb3d_coloroffset );
-		OUT_RING( CP_PACKET0( RADEON_RB3D_COLORPITCH, 0 ) );
-		OUT_RING( ctx->rb3d_colorpitch );
+		BEGIN_RING(14);
+		OUT_RING(CP_PACKET0(RADEON_PP_MISC, 6));
+		OUT_RING(ctx->pp_misc);
+		OUT_RING(ctx->pp_fog_color);
+		OUT_RING(ctx->re_solid_color);
+		OUT_RING(ctx->rb3d_blendcntl);
+		OUT_RING(ctx->rb3d_depthoffset);
+		OUT_RING(ctx->rb3d_depthpitch);
+		OUT_RING(ctx->rb3d_zstencilcntl);
+		OUT_RING(CP_PACKET0(RADEON_PP_CNTL, 2));
+		OUT_RING(ctx->pp_cntl);
+		OUT_RING(ctx->rb3d_cntl);
+		OUT_RING(ctx->rb3d_coloroffset);
+		OUT_RING(CP_PACKET0(RADEON_RB3D_COLORPITCH, 0));
+		OUT_RING(ctx->rb3d_colorpitch);
@@ -330,4 +352,4 @@
-	if ( dirty & RADEON_UPLOAD_VERTFMT ) {
-		BEGIN_RING( 2 );
-		OUT_RING( CP_PACKET0( RADEON_SE_COORD_FMT, 0 ) );
-		OUT_RING( ctx->se_coord_fmt );
+	if (dirty & RADEON_UPLOAD_VERTFMT) {
+		BEGIN_RING(2);
+		OUT_RING(CP_PACKET0(RADEON_SE_COORD_FMT, 0));
+		OUT_RING(ctx->se_coord_fmt);
@@ -337,7 +359,7 @@
-	if ( dirty & RADEON_UPLOAD_LINE ) {
-		BEGIN_RING( 5 );
-		OUT_RING( CP_PACKET0( RADEON_RE_LINE_PATTERN, 1 ) );
-		OUT_RING( ctx->re_line_pattern );
-		OUT_RING( ctx->re_line_state );
-		OUT_RING( CP_PACKET0( RADEON_SE_LINE_WIDTH, 0 ) );
-		OUT_RING( ctx->se_line_width );
+	if (dirty & RADEON_UPLOAD_LINE) {
+		BEGIN_RING(5);
+		OUT_RING(CP_PACKET0(RADEON_RE_LINE_PATTERN, 1));
+		OUT_RING(ctx->re_line_pattern);
+		OUT_RING(ctx->re_line_state);
+		OUT_RING(CP_PACKET0(RADEON_SE_LINE_WIDTH, 0));
+		OUT_RING(ctx->se_line_width);
@@ -347,7 +369,7 @@
-	if ( dirty & RADEON_UPLOAD_BUMPMAP ) {
-		BEGIN_RING( 5 );
-		OUT_RING( CP_PACKET0( RADEON_PP_LUM_MATRIX, 0 ) );
-		OUT_RING( ctx->pp_lum_matrix );
-		OUT_RING( CP_PACKET0( RADEON_PP_ROT_MATRIX_0, 1 ) );
-		OUT_RING( ctx->pp_rot_matrix_0 );
-		OUT_RING( ctx->pp_rot_matrix_1 );
+	if (dirty & RADEON_UPLOAD_BUMPMAP) {
+		BEGIN_RING(5);
+		OUT_RING(CP_PACKET0(RADEON_PP_LUM_MATRIX, 0));
+		OUT_RING(ctx->pp_lum_matrix);
+		OUT_RING(CP_PACKET0(RADEON_PP_ROT_MATRIX_0, 1));
+		OUT_RING(ctx->pp_rot_matrix_0);
+		OUT_RING(ctx->pp_rot_matrix_1);
@@ -357,6 +379,6 @@
-	if ( dirty & RADEON_UPLOAD_MASKS ) {
-		BEGIN_RING( 4 );
-		OUT_RING( CP_PACKET0( RADEON_RB3D_STENCILREFMASK, 2 ) );
-		OUT_RING( ctx->rb3d_stencilrefmask );
-		OUT_RING( ctx->rb3d_ropcntl );
-		OUT_RING( ctx->rb3d_planemask );
+	if (dirty & RADEON_UPLOAD_MASKS) {
+		BEGIN_RING(4);
+		OUT_RING(CP_PACKET0(RADEON_RB3D_STENCILREFMASK, 2));
+		OUT_RING(ctx->rb3d_stencilrefmask);
+		OUT_RING(ctx->rb3d_ropcntl);
+		OUT_RING(ctx->rb3d_planemask);
@@ -366,9 +388,9 @@
-	if ( dirty & RADEON_UPLOAD_VIEWPORT ) {
-		BEGIN_RING( 7 );
-		OUT_RING( CP_PACKET0( RADEON_SE_VPORT_XSCALE, 5 ) );
-		OUT_RING( ctx->se_vport_xscale );
-		OUT_RING( ctx->se_vport_xoffset );
-		OUT_RING( ctx->se_vport_yscale );
-		OUT_RING( ctx->se_vport_yoffset );
-		OUT_RING( ctx->se_vport_zscale );
-		OUT_RING( ctx->se_vport_zoffset );
+	if (dirty & RADEON_UPLOAD_VIEWPORT) {
+		BEGIN_RING(7);
+		OUT_RING(CP_PACKET0(RADEON_SE_VPORT_XSCALE, 5));
+		OUT_RING(ctx->se_vport_xscale);
+		OUT_RING(ctx->se_vport_xoffset);
+		OUT_RING(ctx->se_vport_yscale);
+		OUT_RING(ctx->se_vport_yoffset);
+		OUT_RING(ctx->se_vport_zscale);
+		OUT_RING(ctx->se_vport_zoffset);
@@ -378,6 +400,6 @@
-	if ( dirty & RADEON_UPLOAD_SETUP ) {
-		BEGIN_RING( 4 );
-		OUT_RING( CP_PACKET0( RADEON_SE_CNTL, 0 ) );
-		OUT_RING( ctx->se_cntl );
-		OUT_RING( CP_PACKET0( RADEON_SE_CNTL_STATUS, 0 ) );
-		OUT_RING( ctx->se_cntl_status );
+	if (dirty & RADEON_UPLOAD_SETUP) {
+		BEGIN_RING(4);
+		OUT_RING(CP_PACKET0(RADEON_SE_CNTL, 0));
+		OUT_RING(ctx->se_cntl);
+		OUT_RING(CP_PACKET0(RADEON_SE_CNTL_STATUS, 0));
+		OUT_RING(ctx->se_cntl_status);
@@ -387,4 +409,4 @@
-	if ( dirty & RADEON_UPLOAD_MISC ) {
-		BEGIN_RING( 2 );
-		OUT_RING( CP_PACKET0( RADEON_RE_MISC, 0 ) );
-		OUT_RING( ctx->re_misc );
+	if (dirty & RADEON_UPLOAD_MISC) {
+		BEGIN_RING(2);
+		OUT_RING(CP_PACKET0(RADEON_RE_MISC, 0));
+		OUT_RING(ctx->re_misc);
@@ -394,5 +416,5 @@
-	if ( dirty & RADEON_UPLOAD_TEX0 ) {
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &tex[0].pp_txoffset ) ) {
-			DRM_ERROR( "Invalid texture offset for unit 0\n" );
-			return DRM_ERR( EINVAL );
+	if (dirty & RADEON_UPLOAD_TEX0) {
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &tex[0].pp_txoffset)) {
+			DRM_ERROR("Invalid texture offset for unit 0\n");
+			return DRM_ERR(EINVAL);
@@ -401,10 +423,10 @@
-		BEGIN_RING( 9 );
-		OUT_RING( CP_PACKET0( RADEON_PP_TXFILTER_0, 5 ) );
-		OUT_RING( tex[0].pp_txfilter );
-		OUT_RING( tex[0].pp_txformat );
-		OUT_RING( tex[0].pp_txoffset );
-		OUT_RING( tex[0].pp_txcblend );
-		OUT_RING( tex[0].pp_txablend );
-		OUT_RING( tex[0].pp_tfactor );
-		OUT_RING( CP_PACKET0( RADEON_PP_BORDER_COLOR_0, 0 ) );
-		OUT_RING( tex[0].pp_border_color );
+		BEGIN_RING(9);
+		OUT_RING(CP_PACKET0(RADEON_PP_TXFILTER_0, 5));
+		OUT_RING(tex[0].pp_txfilter);
+		OUT_RING(tex[0].pp_txformat);
+		OUT_RING(tex[0].pp_txoffset);
+		OUT_RING(tex[0].pp_txcblend);
+		OUT_RING(tex[0].pp_txablend);
+		OUT_RING(tex[0].pp_tfactor);
+		OUT_RING(CP_PACKET0(RADEON_PP_BORDER_COLOR_0, 0));
+		OUT_RING(tex[0].pp_border_color);
@@ -414,5 +436,5 @@
-	if ( dirty & RADEON_UPLOAD_TEX1 ) {
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &tex[1].pp_txoffset ) ) {
-			DRM_ERROR( "Invalid texture offset for unit 1\n" );
-			return DRM_ERR( EINVAL );
+	if (dirty & RADEON_UPLOAD_TEX1) {
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &tex[1].pp_txoffset)) {
+			DRM_ERROR("Invalid texture offset for unit 1\n");
+			return DRM_ERR(EINVAL);
@@ -421,10 +443,10 @@
-		BEGIN_RING( 9 );
-		OUT_RING( CP_PACKET0( RADEON_PP_TXFILTER_1, 5 ) );
-		OUT_RING( tex[1].pp_txfilter );
-		OUT_RING( tex[1].pp_txformat );
-		OUT_RING( tex[1].pp_txoffset );
-		OUT_RING( tex[1].pp_txcblend );
-		OUT_RING( tex[1].pp_txablend );
-		OUT_RING( tex[1].pp_tfactor );
-		OUT_RING( CP_PACKET0( RADEON_PP_BORDER_COLOR_1, 0 ) );
-		OUT_RING( tex[1].pp_border_color );
+		BEGIN_RING(9);
+		OUT_RING(CP_PACKET0(RADEON_PP_TXFILTER_1, 5));
+		OUT_RING(tex[1].pp_txfilter);
+		OUT_RING(tex[1].pp_txformat);
+		OUT_RING(tex[1].pp_txoffset);
+		OUT_RING(tex[1].pp_txcblend);
+		OUT_RING(tex[1].pp_txablend);
+		OUT_RING(tex[1].pp_tfactor);
+		OUT_RING(CP_PACKET0(RADEON_PP_BORDER_COLOR_1, 0));
+		OUT_RING(tex[1].pp_border_color);
@@ -434,5 +456,5 @@
-	if ( dirty & RADEON_UPLOAD_TEX2 ) {
-		if ( radeon_check_and_fixup_offset( dev_priv, filp_priv,
-						    &tex[2].pp_txoffset ) ) {
-			DRM_ERROR( "Invalid texture offset for unit 2\n" );
-			return DRM_ERR( EINVAL );
+	if (dirty & RADEON_UPLOAD_TEX2) {
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+						  &tex[2].pp_txoffset)) {
+			DRM_ERROR("Invalid texture offset for unit 2\n");
+			return DRM_ERR(EINVAL);
@@ -441,10 +463,10 @@
-		BEGIN_RING( 9 );
-		OUT_RING( CP_PACKET0( RADEON_PP_TXFILTER_2, 5 ) );
-		OUT_RING( tex[2].pp_txfilter );
-		OUT_RING( tex[2].pp_txformat );
-		OUT_RING( tex[2].pp_txoffset );
-		OUT_RING( tex[2].pp_txcblend );
-		OUT_RING( tex[2].pp_txablend );
-		OUT_RING( tex[2].pp_tfactor );
-		OUT_RING( CP_PACKET0( RADEON_PP_BORDER_COLOR_2, 0 ) );
-		OUT_RING( tex[2].pp_border_color );
+		BEGIN_RING(9);
+		OUT_RING(CP_PACKET0(RADEON_PP_TXFILTER_2, 5));
+		OUT_RING(tex[2].pp_txfilter);
+		OUT_RING(tex[2].pp_txformat);
+		OUT_RING(tex[2].pp_txoffset);
+		OUT_RING(tex[2].pp_txcblend);
+		OUT_RING(tex[2].pp_txablend);
+		OUT_RING(tex[2].pp_tfactor);
+		OUT_RING(CP_PACKET0(RADEON_PP_BORDER_COLOR_2, 0));
+		OUT_RING(tex[2].pp_border_color);
@@ -459,3 +481,3 @@
-static int radeon_emit_state2( drm_radeon_private_t *dev_priv,
-			       drm_file_t *filp_priv,
-			       drm_radeon_state_t *state )
+static int radeon_emit_state2(drm_radeon_private_t * dev_priv,
+			      drm_file_t * filp_priv,
+			      drm_radeon_state_t * state)
@@ -466,4 +488,4 @@
-		BEGIN_RING( 3 );
-		OUT_RING( CP_PACKET0( RADEON_SE_ZBIAS_FACTOR, 1 ) );
-		OUT_RING( state->context2.se_zbias_factor ); 
-		OUT_RING( state->context2.se_zbias_constant ); 
+		BEGIN_RING(3);
+		OUT_RING(CP_PACKET0(RADEON_SE_ZBIAS_FACTOR, 1));
+		OUT_RING(state->context2.se_zbias_factor);
+		OUT_RING(state->context2.se_zbias_constant);
@@ -473,2 +495,2 @@
-	return radeon_emit_state( dev_priv, filp_priv, &state->context,
-			   state->tex, state->dirty );
+	return radeon_emit_state(dev_priv, filp_priv, &state->context,
+				 state->tex, state->dirty);
@@ -479 +501 @@
- * the tcl scalar and vector areas.  
+ * the tcl scalar and vector areas.
@@ -481,3 +503,3 @@
-static struct { 
-	int start; 
-	int len; 
+static struct {
+	int start;
+	int len;
@@ -486,85 +508,96 @@
-	{ RADEON_PP_MISC,7,"RADEON_PP_MISC" },
-	{ RADEON_PP_CNTL,3,"RADEON_PP_CNTL" },
-	{ RADEON_RB3D_COLORPITCH,1,"RADEON_RB3D_COLORPITCH" },
-	{ RADEON_RE_LINE_PATTERN,2,"RADEON_RE_LINE_PATTERN" },
-	{ RADEON_SE_LINE_WIDTH,1,"RADEON_SE_LINE_WIDTH" },
-	{ RADEON_PP_LUM_MATRIX,1,"RADEON_PP_LUM_MATRIX" },
-	{ RADEON_PP_ROT_MATRIX_0,2,"RADEON_PP_ROT_MATRIX_0" },
-	{ RADEON_RB3D_STENCILREFMASK,3,"RADEON_RB3D_STENCILREFMASK" },
-	{ RADEON_SE_VPORT_XSCALE,6,"RADEON_SE_VPORT_XSCALE" },
-	{ RADEON_SE_CNTL,2,"RADEON_SE_CNTL" },
-	{ RADEON_SE_CNTL_STATUS,1,"RADEON_SE_CNTL_STATUS" },
-	{ RADEON_RE_MISC,1,"RADEON_RE_MISC" },
-	{ RADEON_PP_TXFILTER_0,6,"RADEON_PP_TXFILTER_0" },
-	{ RADEON_PP_BORDER_COLOR_0,1,"RADEON_PP_BORDER_COLOR_0" },
-	{ RADEON_PP_TXFILTER_1,6,"RADEON_PP_TXFILTER_1" },
-	{ RADEON_PP_BORDER_COLOR_1,1,"RADEON_PP_BORDER_COLOR_1" },
-	{ RADEON_PP_TXFILTER_2,6,"RADEON_PP_TXFILTER_2" },
-	{ RADEON_PP_BORDER_COLOR_2,1,"RADEON_PP_BORDER_COLOR_2" },
-	{ RADEON_SE_ZBIAS_FACTOR,2,"RADEON_SE_ZBIAS_FACTOR" },
-	{ RADEON_SE_TCL_OUTPUT_VTX_FMT,11,"RADEON_SE_TCL_OUTPUT_VTX_FMT" },
-	{ RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED,17,"RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED" },
-	{ R200_PP_TXCBLEND_0, 4, "R200_PP_TXCBLEND_0" },
-	{ R200_PP_TXCBLEND_1, 4, "R200_PP_TXCBLEND_1" },
-	{ R200_PP_TXCBLEND_2, 4, "R200_PP_TXCBLEND_2" },
-	{ R200_PP_TXCBLEND_3, 4, "R200_PP_TXCBLEND_3" },
-	{ R200_PP_TXCBLEND_4, 4, "R200_PP_TXCBLEND_4" },
-	{ R200_PP_TXCBLEND_5, 4, "R200_PP_TXCBLEND_5" },
-	{ R200_PP_TXCBLEND_6, 4, "R200_PP_TXCBLEND_6" },
-	{ R200_PP_TXCBLEND_7, 4, "R200_PP_TXCBLEND_7" },
-	{ R200_SE_TCL_LIGHT_MODEL_CTL_0, 6, "R200_SE_TCL_LIGHT_MODEL_CTL_0" },
-	{ R200_PP_TFACTOR_0, 6, "R200_PP_TFACTOR_0" },
-	{ R200_SE_VTX_FMT_0, 4, "R200_SE_VTX_FMT_0" },
-	{ R200_SE_VAP_CNTL, 1, "R200_SE_VAP_CNTL" },
-	{ R200_SE_TCL_MATRIX_SEL_0, 5, "R200_SE_TCL_MATRIX_SEL_0" },
-	{ R200_SE_TCL_TEX_PROC_CTL_2, 5, "R200_SE_TCL_TEX_PROC_CTL_2" },
-	{ R200_SE_TCL_UCP_VERT_BLEND_CTL, 1, "R200_SE_TCL_UCP_VERT_BLEND_CTL" },
-	{ R200_PP_TXFILTER_0, 6, "R200_PP_TXFILTER_0" },
-	{ R200_PP_TXFILTER_1, 6, "R200_PP_TXFILTER_1" },
-	{ R200_PP_TXFILTER_2, 6, "R200_PP_TXFILTER_2" },
-	{ R200_PP_TXFILTER_3, 6, "R200_PP_TXFILTER_3" },
-	{ R200_PP_TXFILTER_4, 6, "R200_PP_TXFILTER_4" },
-	{ R200_PP_TXFILTER_5, 6, "R200_PP_TXFILTER_5" },
-	{ R200_PP_TXOFFSET_0, 1, "R200_PP_TXOFFSET_0" },
-	{ R200_PP_TXOFFSET_1, 1, "R200_PP_TXOFFSET_1" },
-	{ R200_PP_TXOFFSET_2, 1, "R200_PP_TXOFFSET_2" },
-	{ R200_PP_TXOFFSET_3, 1, "R200_PP_TXOFFSET_3" },
-	{ R200_PP_TXOFFSET_4, 1, "R200_PP_TXOFFSET_4" },
-	{ R200_PP_TXOFFSET_5, 1, "R200_PP_TXOFFSET_5" },
-	{ R200_SE_VTE_CNTL, 1, "R200_SE_VTE_CNTL" },
-	{ R200_SE_TCL_OUTPUT_VTX_COMP_SEL, 1, "R200_SE_TCL_OUTPUT_VTX_COMP_SEL" },
-	{ R200_PP_TAM_DEBUG3, 1, "R200_PP_TAM_DEBUG3" },
-	{ R200_PP_CNTL_X, 1, "R200_PP_CNTL_X" }, 
-	{ R200_RB3D_DEPTHXY_OFFSET, 1, "R200_RB3D_DEPTHXY_OFFSET" }, 
-	{ R200_RE_AUX_SCISSOR_CNTL, 1, "R200_RE_AUX_SCISSOR_CNTL" }, 
-	{ R200_RE_SCISSOR_TL_0, 2, "R200_RE_SCISSOR_TL_0" }, 
-	{ R200_RE_SCISSOR_TL_1, 2, "R200_RE_SCISSOR_TL_1" }, 
-	{ R200_RE_SCISSOR_TL_2, 2, "R200_RE_SCISSOR_TL_2" }, 
-	{ R200_SE_VAP_CNTL_STATUS, 1, "R200_SE_VAP_CNTL_STATUS" }, 
-	{ R200_SE_VTX_STATE_CNTL, 1, "R200_SE_VTX_STATE_CNTL" }, 
-	{ R200_RE_POINTSIZE, 1, "R200_RE_POINTSIZE" }, 
-	{ R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0, 4, "R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0" },
-	{ R200_PP_CUBIC_FACES_0, 1, "R200_PP_CUBIC_FACES_0" }, /* 61 */
-	{ R200_PP_CUBIC_OFFSET_F1_0, 5, "R200_PP_CUBIC_OFFSET_F1_0" }, /* 62 */
-	{ R200_PP_CUBIC_FACES_1, 1, "R200_PP_CUBIC_FACES_1" },
-	{ R200_PP_CUBIC_OFFSET_F1_1, 5, "R200_PP_CUBIC_OFFSET_F1_1" },
-	{ R200_PP_CUBIC_FACES_2, 1, "R200_PP_CUBIC_FACES_2" },
-	{ R200_PP_CUBIC_OFFSET_F1_2, 5, "R200_PP_CUBIC_OFFSET_F1_2" },
-	{ R200_PP_CUBIC_FACES_3, 1, "R200_PP_CUBIC_FACES_3" },
-	{ R200_PP_CUBIC_OFFSET_F1_3, 5, "R200_PP_CUBIC_OFFSET_F1_3" },
-	{ R200_PP_CUBIC_FACES_4, 1, "R200_PP_CUBIC_FACES_4" },
-	{ R200_PP_CUBIC_OFFSET_F1_4, 5, "R200_PP_CUBIC_OFFSET_F1_4" },
-	{ R200_PP_CUBIC_FACES_5, 1, "R200_PP_CUBIC_FACES_5" },
-	{ R200_PP_CUBIC_OFFSET_F1_5, 5, "R200_PP_CUBIC_OFFSET_F1_5" },
-	{ RADEON_PP_TEX_SIZE_0, 2, "RADEON_PP_TEX_SIZE_0" },
-	{ RADEON_PP_TEX_SIZE_1, 2, "RADEON_PP_TEX_SIZE_1" },
-	{ RADEON_PP_TEX_SIZE_2, 2, "RADEON_PP_TEX_SIZE_2" },
-	{ R200_RB3D_BLENDCOLOR, 3, "R200_RB3D_BLENDCOLOR" },
-	{ R200_SE_TCL_POINT_SPRITE_CNTL, 1, "R200_SE_TCL_POINT_SPRITE_CNTL" },
-	{ RADEON_PP_CUBIC_FACES_0, 1, "RADEON_PP_CUBIC_FACES_0"},
-	{ RADEON_PP_CUBIC_OFFSET_T0_0, 5, "RADEON_PP_CUBIC_OFFSET_T0_0"},
-	{ RADEON_PP_CUBIC_FACES_1, 1, "RADEON_PP_CUBIC_FACES_1"},
-	{ RADEON_PP_CUBIC_OFFSET_T1_0, 5, "RADEON_PP_CUBIC_OFFSET_T1_0"},
-	{ RADEON_PP_CUBIC_FACES_2, 1, "RADEON_PP_CUBIC_FACES_2"},
-	{ RADEON_PP_CUBIC_OFFSET_T2_0, 5, "RADEON_PP_CUBIC_OFFSET_T2_0"},
-	{ R200_PP_TRI_PERF, 2, "R200_PP_TRI_PERF"},
+	{RADEON_PP_MISC, 7, "RADEON_PP_MISC"},
+	{RADEON_PP_CNTL, 3, "RADEON_PP_CNTL"},
+	{RADEON_RB3D_COLORPITCH, 1, "RADEON_RB3D_COLORPITCH"},
+	{RADEON_RE_LINE_PATTERN, 2, "RADEON_RE_LINE_PATTERN"},
+	{RADEON_SE_LINE_WIDTH, 1, "RADEON_SE_LINE_WIDTH"},
+	{RADEON_PP_LUM_MATRIX, 1, "RADEON_PP_LUM_MATRIX"},
+	{RADEON_PP_ROT_MATRIX_0, 2, "RADEON_PP_ROT_MATRIX_0"},
+	{RADEON_RB3D_STENCILREFMASK, 3, "RADEON_RB3D_STENCILREFMASK"},
+	{RADEON_SE_VPORT_XSCALE, 6, "RADEON_SE_VPORT_XSCALE"},
+	{RADEON_SE_CNTL, 2, "RADEON_SE_CNTL"},
+	{RADEON_SE_CNTL_STATUS, 1, "RADEON_SE_CNTL_STATUS"},
+	{RADEON_RE_MISC, 1, "RADEON_RE_MISC"},
+	{RADEON_PP_TXFILTER_0, 6, "RADEON_PP_TXFILTER_0"},
+	{RADEON_PP_BORDER_COLOR_0, 1, "RADEON_PP_BORDER_COLOR_0"},
+	{RADEON_PP_TXFILTER_1, 6, "RADEON_PP_TXFILTER_1"},
+	{RADEON_PP_BORDER_COLOR_1, 1, "RADEON_PP_BORDER_COLOR_1"},
+	{RADEON_PP_TXFILTER_2, 6, "RADEON_PP_TXFILTER_2"},
+	{RADEON_PP_BORDER_COLOR_2, 1, "RADEON_PP_BORDER_COLOR_2"},
+	{RADEON_SE_ZBIAS_FACTOR, 2, "RADEON_SE_ZBIAS_FACTOR"},
+	{RADEON_SE_TCL_OUTPUT_VTX_FMT, 11, "RADEON_SE_TCL_OUTPUT_VTX_FMT"},
+	{RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED, 17,
+		    "RADEON_SE_TCL_MATERIAL_EMMISSIVE_RED"},
+	{R200_PP_TXCBLEND_0, 4, "R200_PP_TXCBLEND_0"},
+	{R200_PP_TXCBLEND_1, 4, "R200_PP_TXCBLEND_1"},
+	{R200_PP_TXCBLEND_2, 4, "R200_PP_TXCBLEND_2"},
+	{R200_PP_TXCBLEND_3, 4, "R200_PP_TXCBLEND_3"},
+	{R200_PP_TXCBLEND_4, 4, "R200_PP_TXCBLEND_4"},
+	{R200_PP_TXCBLEND_5, 4, "R200_PP_TXCBLEND_5"},
+	{R200_PP_TXCBLEND_6, 4, "R200_PP_TXCBLEND_6"},
+	{R200_PP_TXCBLEND_7, 4, "R200_PP_TXCBLEND_7"},
+	{R200_SE_TCL_LIGHT_MODEL_CTL_0, 6, "R200_SE_TCL_LIGHT_MODEL_CTL_0"},
+	{R200_PP_TFACTOR_0, 6, "R200_PP_TFACTOR_0"},
+	{R200_SE_VTX_FMT_0, 4, "R200_SE_VTX_FMT_0"},
+	{R200_SE_VAP_CNTL, 1, "R200_SE_VAP_CNTL"},
+	{R200_SE_TCL_MATRIX_SEL_0, 5, "R200_SE_TCL_MATRIX_SEL_0"},
+	{R200_SE_TCL_TEX_PROC_CTL_2, 5, "R200_SE_TCL_TEX_PROC_CTL_2"},
+	{R200_SE_TCL_UCP_VERT_BLEND_CTL, 1, "R200_SE_TCL_UCP_VERT_BLEND_CTL"},
+	{R200_PP_TXFILTER_0, 6, "R200_PP_TXFILTER_0"},
+	{R200_PP_TXFILTER_1, 6, "R200_PP_TXFILTER_1"},
+	{R200_PP_TXFILTER_2, 6, "R200_PP_TXFILTER_2"},
+	{R200_PP_TXFILTER_3, 6, "R200_PP_TXFILTER_3"},
+	{R200_PP_TXFILTER_4, 6, "R200_PP_TXFILTER_4"},
+	{R200_PP_TXFILTER_5, 6, "R200_PP_TXFILTER_5"},
+	{R200_PP_TXOFFSET_0, 1, "R200_PP_TXOFFSET_0"},
+	{R200_PP_TXOFFSET_1, 1, "R200_PP_TXOFFSET_1"},
+	{R200_PP_TXOFFSET_2, 1, "R200_PP_TXOFFSET_2"},
+	{R200_PP_TXOFFSET_3, 1, "R200_PP_TXOFFSET_3"},
+	{R200_PP_TXOFFSET_4, 1, "R200_PP_TXOFFSET_4"},
+	{R200_PP_TXOFFSET_5, 1, "R200_PP_TXOFFSET_5"},
+	{R200_SE_VTE_CNTL, 1, "R200_SE_VTE_CNTL"},
+	{R200_SE_TCL_OUTPUT_VTX_COMP_SEL, 1, "R200_SE_TCL_OUTPUT_VTX_COMP_SEL"},
+	{R200_PP_TAM_DEBUG3, 1, "R200_PP_TAM_DEBUG3"},
+	{R200_PP_CNTL_X, 1, "R200_PP_CNTL_X"},
+	{R200_RB3D_DEPTHXY_OFFSET, 1, "R200_RB3D_DEPTHXY_OFFSET"},
+	{R200_RE_AUX_SCISSOR_CNTL, 1, "R200_RE_AUX_SCISSOR_CNTL"},
+	{R200_RE_SCISSOR_TL_0, 2, "R200_RE_SCISSOR_TL_0"},
+	{R200_RE_SCISSOR_TL_1, 2, "R200_RE_SCISSOR_TL_1"},
+	{R200_RE_SCISSOR_TL_2, 2, "R200_RE_SCISSOR_TL_2"},
+	{R200_SE_VAP_CNTL_STATUS, 1, "R200_SE_VAP_CNTL_STATUS"},
+	{R200_SE_VTX_STATE_CNTL, 1, "R200_SE_VTX_STATE_CNTL"},
+	{R200_RE_POINTSIZE, 1, "R200_RE_POINTSIZE"},
+	{R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0, 4,
+		    "R200_SE_TCL_INPUT_VTX_VECTOR_ADDR_0"},
+	{R200_PP_CUBIC_FACES_0, 1, "R200_PP_CUBIC_FACES_0"},	/* 61 */
+	{R200_PP_CUBIC_OFFSET_F1_0, 5, "R200_PP_CUBIC_OFFSET_F1_0"},	/* 62 */
+	{R200_PP_CUBIC_FACES_1, 1, "R200_PP_CUBIC_FACES_1"},
+	{R200_PP_CUBIC_OFFSET_F1_1, 5, "R200_PP_CUBIC_OFFSET_F1_1"},
+	{R200_PP_CUBIC_FACES_2, 1, "R200_PP_CUBIC_FACES_2"},
+	{R200_PP_CUBIC_OFFSET_F1_2, 5, "R200_PP_CUBIC_OFFSET_F1_2"},
+	{R200_PP_CUBIC_FACES_3, 1, "R200_PP_CUBIC_FACES_3"},
+	{R200_PP_CUBIC_OFFSET_F1_3, 5, "R200_PP_CUBIC_OFFSET_F1_3"},
+	{R200_PP_CUBIC_FACES_4, 1, "R200_PP_CUBIC_FACES_4"},
+	{R200_PP_CUBIC_OFFSET_F1_4, 5, "R200_PP_CUBIC_OFFSET_F1_4"},
+	{R200_PP_CUBIC_FACES_5, 1, "R200_PP_CUBIC_FACES_5"},
+	{R200_PP_CUBIC_OFFSET_F1_5, 5, "R200_PP_CUBIC_OFFSET_F1_5"},
+	{RADEON_PP_TEX_SIZE_0, 2, "RADEON_PP_TEX_SIZE_0"},
+	{RADEON_PP_TEX_SIZE_1, 2, "RADEON_PP_TEX_SIZE_1"},
+	{RADEON_PP_TEX_SIZE_2, 2, "RADEON_PP_TEX_SIZE_2"},
+	{R200_RB3D_BLENDCOLOR, 3, "R200_RB3D_BLENDCOLOR"},
+	{R200_SE_TCL_POINT_SPRITE_CNTL, 1, "R200_SE_TCL_POINT_SPRITE_CNTL"},
+	{RADEON_PP_CUBIC_FACES_0, 1, "RADEON_PP_CUBIC_FACES_0"},
+	{RADEON_PP_CUBIC_OFFSET_T0_0, 5, "RADEON_PP_CUBIC_OFFSET_T0_0"},
+	{RADEON_PP_CUBIC_FACES_1, 1, "RADEON_PP_CUBIC_FACES_1"},
+	{RADEON_PP_CUBIC_OFFSET_T1_0, 5, "RADEON_PP_CUBIC_OFFSET_T1_0"},
+	{RADEON_PP_CUBIC_FACES_2, 1, "RADEON_PP_CUBIC_FACES_2"},
+	{RADEON_PP_CUBIC_OFFSET_T2_0, 5, "RADEON_PP_CUBIC_OFFSET_T2_0"},
+	{R200_PP_TRI_PERF, 2, "R200_PP_TRI_PERF"},
+	{R200_PP_AFS_0, 32, "R200_PP_AFS_0"},	/* 85 */
+	{R200_PP_AFS_1, 32, "R200_PP_AFS_1"},
+	{R200_PP_TFACTOR_0, 8, "R200_ATF_TFACTOR"},
+	{R200_PP_TXFILTER_0, 8, "R200_PP_TXCTLALL_0"},
+	{R200_PP_TXFILTER_1, 8, "R200_PP_TXCTLALL_1"},
+	{R200_PP_TXFILTER_2, 8, "R200_PP_TXCTLALL_2"},
+	{R200_PP_TXFILTER_3, 8, "R200_PP_TXCTLALL_3"},
+	{R200_PP_TXFILTER_4, 8, "R200_PP_TXCTLALL_4"},
+	{R200_PP_TXFILTER_5, 8, "R200_PP_TXCTLALL_5"},
@@ -573,2 +605,0 @@
-
-
@@ -579,3 +610,2 @@
-static void radeon_clear_box( drm_radeon_private_t *dev_priv,
-			      int x, int y, int w, int h,
-			      int r, int g, int b )
+static void radeon_clear_box(drm_radeon_private_t * dev_priv,
+			     int x, int y, int w, int h, int r, int g, int b)
@@ -589 +619 @@
-	switch ( dev_priv->color_fmt ) {
+	switch (dev_priv->color_fmt) {
@@ -592,2 +622 @@
-			 ((g & 0xfc) << 3) |
-			 ((b & 0xf8) >> 3));
+			 ((g & 0xfc) << 3) | ((b & 0xf8) >> 3));
@@ -597 +626 @@
-		color = (((0xff) << 24) | (r << 16) | (g <<  8) | b);
+		color = (((0xff) << 24) | (r << 16) | (g << 8) | b);
@@ -601,4 +630,4 @@
-	BEGIN_RING( 4 );
-	RADEON_WAIT_UNTIL_3D_IDLE();		
-	OUT_RING( CP_PACKET0( RADEON_DP_WRITE_MASK, 0 ) );
-	OUT_RING( 0xffffffff );
+	BEGIN_RING(4);
+	RADEON_WAIT_UNTIL_3D_IDLE();
+	OUT_RING(CP_PACKET0(RADEON_DP_WRITE_MASK, 0));
+	OUT_RING(0xffffffff);
@@ -607 +636 @@
-	BEGIN_RING( 6 );
+	BEGIN_RING(6);
@@ -609,13 +638,6 @@
-	OUT_RING( CP_PACKET3( RADEON_CNTL_PAINT_MULTI, 4 ) );
-	OUT_RING( RADEON_GMC_DST_PITCH_OFFSET_CNTL |
-		  RADEON_GMC_BRUSH_SOLID_COLOR |
-		  (dev_priv->color_fmt << 8) |
-		  RADEON_GMC_SRC_DATATYPE_COLOR |
-		  RADEON_ROP3_P |
-		  RADEON_GMC_CLR_CMP_CNTL_DIS );
-
- 	if ( dev_priv->page_flipping && dev_priv->current_page == 1 ) { 
-		OUT_RING( dev_priv->front_pitch_offset );
- 	} else {	 
-		OUT_RING( dev_priv->back_pitch_offset );
- 	} 
+	OUT_RING(CP_PACKET3(RADEON_CNTL_PAINT_MULTI, 4));
+	OUT_RING(RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+		 RADEON_GMC_BRUSH_SOLID_COLOR |
+		 (dev_priv->color_fmt << 8) |
+		 RADEON_GMC_SRC_DATATYPE_COLOR |
+		 RADEON_ROP3_P | RADEON_GMC_CLR_CMP_CNTL_DIS);
@@ -623 +645,5 @@
-	OUT_RING( color );
+	if (dev_priv->page_flipping && dev_priv->current_page == 1) {
+		OUT_RING(dev_priv->front_pitch_offset);
+	} else {
+		OUT_RING(dev_priv->back_pitch_offset);
+	}
@@ -625,2 +651,4 @@
-	OUT_RING( (x << 16) | y );
-	OUT_RING( (w << 16) | h );
+	OUT_RING(color);
+
+	OUT_RING((x << 16) | y);
+	OUT_RING((w << 16) | h);
@@ -631 +659 @@
-static void radeon_cp_performance_boxes( drm_radeon_private_t *dev_priv )
+static void radeon_cp_performance_boxes(drm_radeon_private_t * dev_priv)
@@ -647,2 +675,2 @@
-	if ( dev_priv->stats.boxes & RADEON_BOX_FLIP ) 
-		radeon_clear_box( dev_priv, 4, 4, 8, 8, 255, 0, 255 );
+	if (dev_priv->stats.boxes & RADEON_BOX_FLIP)
+		radeon_clear_box(dev_priv, 4, 4, 8, 8, 255, 0, 255);
@@ -652,2 +680,2 @@
-	if ( dev_priv->stats.boxes & RADEON_BOX_WAIT_IDLE ) 
-		radeon_clear_box( dev_priv, 16, 4, 8, 8, 255, 0, 0 );
+	if (dev_priv->stats.boxes & RADEON_BOX_WAIT_IDLE)
+		radeon_clear_box(dev_priv, 16, 4, 8, 8, 255, 0, 0);
@@ -660,2 +688,2 @@
-	if ( dev_priv->stats.boxes & RADEON_BOX_TEXTURE_LOAD ) 
-		radeon_clear_box( dev_priv, 40, 4, 8, 8, 255, 255, 0 );
+	if (dev_priv->stats.boxes & RADEON_BOX_TEXTURE_LOAD)
+		radeon_clear_box(dev_priv, 40, 4, 8, 8, 255, 255, 0);
@@ -665,3 +693,2 @@
-	if ( !(dev_priv->stats.boxes & RADEON_BOX_DMA_IDLE) ) 
-		radeon_clear_box( dev_priv, 64, 4, 8, 8, 0, 255, 0 );
-
+	if (!(dev_priv->stats.boxes & RADEON_BOX_DMA_IDLE))
+		radeon_clear_box(dev_priv, 64, 4, 8, 8, 0, 255, 0);
@@ -669 +696 @@
-	/* Draw bars indicating number of buffers allocated 
+	/* Draw bars indicating number of buffers allocated
@@ -676,3 +703,3 @@
-		radeon_clear_box( dev_priv, 4, 16,  
-				  dev_priv->stats.requested_bufs, 4,
-				  196, 128, 128 );
+		radeon_clear_box(dev_priv, 4, 16,
+				 dev_priv->stats.requested_bufs, 4,
+				 196, 128, 128);
@@ -681 +708 @@
-	memset( &dev_priv->stats, 0, sizeof(dev_priv->stats) );
+	memset(&dev_priv->stats, 0, sizeof(dev_priv->stats));
@@ -683,0 +711 @@
+
@@ -688,3 +716,3 @@
-static void radeon_cp_dispatch_clear( drm_device_t *dev,
-				      drm_radeon_clear_t *clear,
-				      drm_radeon_clear_rect_t *depth_boxes )
+static void radeon_cp_dispatch_clear(drm_device_t * dev,
+				     drm_radeon_clear_t * clear,
+				     drm_radeon_clear_rect_t * depth_boxes)
@@ -698 +726 @@
-	u32 rb3d_cntl = 0, rb3d_stencilrefmask= 0;
+	u32 rb3d_cntl = 0, rb3d_stencilrefmask = 0;
@@ -701 +729 @@
-	DRM_DEBUG( "flags = 0x%x\n", flags );
+	DRM_DEBUG("flags = 0x%x\n", flags);
@@ -705 +733 @@
-	if ( dev_priv->page_flipping && dev_priv->current_page == 1 ) {
+	if (dev_priv->page_flipping && dev_priv->current_page == 1) {
@@ -709,2 +737,4 @@
-		if ( tmp & RADEON_FRONT ) flags |= RADEON_BACK;
-		if ( tmp & RADEON_BACK )  flags |= RADEON_FRONT;
+		if (tmp & RADEON_FRONT)
+			flags |= RADEON_BACK;
+		if (tmp & RADEON_BACK)
+			flags |= RADEON_FRONT;
@@ -713 +743 @@
-	if ( flags & (RADEON_FRONT | RADEON_BACK) ) {
+	if (flags & (RADEON_FRONT | RADEON_BACK)) {
@@ -715 +745 @@
-		BEGIN_RING( 4 );
+		BEGIN_RING(4);
@@ -721,3 +751,3 @@
-		
-		OUT_RING( CP_PACKET0( RADEON_DP_WRITE_MASK, 0 ) );
-		OUT_RING( clear->color_mask );
+
+		OUT_RING(CP_PACKET0(RADEON_DP_WRITE_MASK, 0));
+		OUT_RING(clear->color_mask);
@@ -731 +761 @@
-		for ( i = 0 ; i < nbox ; i++ ) {
+		for (i = 0; i < nbox; i++) {
@@ -737,2 +767,21 @@
-			DRM_DEBUG( "dispatch clear %d,%d-%d,%d flags 0x%x\n",
-				   x, y, w, h, flags );
+			DRM_DEBUG("dispatch clear %d,%d-%d,%d flags 0x%x\n",
+				  x, y, w, h, flags);
+
+			if (flags & RADEON_FRONT) {
+				BEGIN_RING(6);
+
+				OUT_RING(CP_PACKET3
+					 (RADEON_CNTL_PAINT_MULTI, 4));
+				OUT_RING(RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+					 RADEON_GMC_BRUSH_SOLID_COLOR |
+					 (dev_priv->
+					  color_fmt << 8) |
+					 RADEON_GMC_SRC_DATATYPE_COLOR |
+					 RADEON_ROP3_P |
+					 RADEON_GMC_CLR_CMP_CNTL_DIS);
+
+				OUT_RING(dev_priv->front_pitch_offset);
+				OUT_RING(clear->clear_color);
+
+				OUT_RING((x << 16) | y);
+				OUT_RING((w << 16) | h);
@@ -740,17 +788,0 @@
-			if ( flags & RADEON_FRONT ) {
-				BEGIN_RING( 6 );
-				
-				OUT_RING( CP_PACKET3( RADEON_CNTL_PAINT_MULTI, 4 ) );
-				OUT_RING( RADEON_GMC_DST_PITCH_OFFSET_CNTL |
-					  RADEON_GMC_BRUSH_SOLID_COLOR |
-					  (dev_priv->color_fmt << 8) |
-					  RADEON_GMC_SRC_DATATYPE_COLOR |
-					  RADEON_ROP3_P |
-					  RADEON_GMC_CLR_CMP_CNTL_DIS );
-
-				OUT_RING( dev_priv->front_pitch_offset );
-				OUT_RING( clear->clear_color );
-				
-				OUT_RING( (x << 16) | y );
-				OUT_RING( (w << 16) | h );
-				
@@ -759,14 +790,0 @@
-			
-			if ( flags & RADEON_BACK ) {
-				BEGIN_RING( 6 );
-				
-				OUT_RING( CP_PACKET3( RADEON_CNTL_PAINT_MULTI, 4 ) );
-				OUT_RING( RADEON_GMC_DST_PITCH_OFFSET_CNTL |
-					  RADEON_GMC_BRUSH_SOLID_COLOR |
-					  (dev_priv->color_fmt << 8) |
-					  RADEON_GMC_SRC_DATATYPE_COLOR |
-					  RADEON_ROP3_P |
-					  RADEON_GMC_CLR_CMP_CNTL_DIS );
-				
-				OUT_RING( dev_priv->back_pitch_offset );
-				OUT_RING( clear->clear_color );
@@ -774,2 +792,18 @@
-				OUT_RING( (x << 16) | y );
-				OUT_RING( (w << 16) | h );
+			if (flags & RADEON_BACK) {
+				BEGIN_RING(6);
+
+				OUT_RING(CP_PACKET3
+					 (RADEON_CNTL_PAINT_MULTI, 4));
+				OUT_RING(RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+					 RADEON_GMC_BRUSH_SOLID_COLOR |
+					 (dev_priv->
+					  color_fmt << 8) |
+					 RADEON_GMC_SRC_DATATYPE_COLOR |
+					 RADEON_ROP3_P |
+					 RADEON_GMC_CLR_CMP_CNTL_DIS);
+
+				OUT_RING(dev_priv->back_pitch_offset);
+				OUT_RING(clear->clear_color);
+
+				OUT_RING((x << 16) | y);
+				OUT_RING((w << 16) | h);
@@ -781 +815 @@
-	
+
@@ -784 +818,2 @@
-	if ((flags & (RADEON_DEPTH | RADEON_STENCIL)) && (flags & RADEON_CLEAR_FASTZ)) {
+	if ((flags & (RADEON_DEPTH | RADEON_STENCIL))
+	    && (flags & RADEON_CLEAR_FASTZ)) {
@@ -787,3 +822,6 @@
-		int depthpixperline = dev_priv->depth_fmt==RADEON_DEPTH_FORMAT_16BIT_INT_Z? 
-			(dev_priv->depth_pitch / 2): (dev_priv->depth_pitch / 4);
-		
+		int depthpixperline =
+		    dev_priv->depth_fmt ==
+		    RADEON_DEPTH_FORMAT_16BIT_INT_Z ? (dev_priv->depth_pitch /
+						       2) : (dev_priv->
+							     depth_pitch / 4);
+
@@ -793,3 +831,2 @@
-			((clear->depth_mask & 0xff) << 24);
-	
-		
+		    ((clear->depth_mask & 0xff) << 24);
+
@@ -801,28 +838,28 @@
-		if ((dev_priv->flags & CHIP_HAS_HIERZ) && (flags & RADEON_USE_HIERZ)) {
-		/* FIXME : reverse engineer that for Rx00 cards */
-		/* FIXME : the mask supposedly contains low-res z values. So can't set
-		   just to the max (0xff? or actually 0x3fff?), need to take z clear
-		   value into account? */
-		/* pattern seems to work for r100, though get slight
-		   rendering errors with glxgears. If hierz is not enabled for r100,
-		   only 4 bits which indicate clear (15,16,31,32, all zero) matter, the
-		   other ones are ignored, and the same clear mask can be used. That's
-		   very different behaviour than R200 which needs different clear mask
-		   and different number of tiles to clear if hierz is enabled or not !?!
-		*/
-			clearmask = (0xff<<22)|(0xff<<6)| 0x003f003f;
-		}
-		else {
-		/* clear mask : chooses the clearing pattern.
-		   rv250: could be used to clear only parts of macrotiles
-		   (but that would get really complicated...)?
-		   bit 0 and 1 (either or both of them ?!?!) are used to
-		   not clear tile (or maybe one of the bits indicates if the tile is
-		   compressed or not), bit 2 and 3 to not clear tile 1,...,.
-		   Pattern is as follows:
-		        | 0,1 | 4,5 | 8,9 |12,13|16,17|20,21|24,25|28,29|
-		   bits -------------------------------------------------
-		        | 2,3 | 6,7 |10,11|14,15|18,19|22,23|26,27|30,31|
-		   rv100: clearmask covers 2x8 4x1 tiles, but one clear still
-		   covers 256 pixels ?!?
-		*/
+		if ((dev_priv->flags & CHIP_HAS_HIERZ)
+		    && (flags & RADEON_USE_HIERZ)) {
+			/* FIXME : reverse engineer that for Rx00 cards */
+			/* FIXME : the mask supposedly contains low-res z values. So can't set
+			   just to the max (0xff? or actually 0x3fff?), need to take z clear
+			   value into account? */
+			/* pattern seems to work for r100, though get slight
+			   rendering errors with glxgears. If hierz is not enabled for r100,
+			   only 4 bits which indicate clear (15,16,31,32, all zero) matter, the
+			   other ones are ignored, and the same clear mask can be used. That's
+			   very different behaviour than R200 which needs different clear mask
+			   and different number of tiles to clear if hierz is enabled or not !?!
+			 */
+			clearmask = (0xff << 22) | (0xff << 6) | 0x003f003f;
+		} else {
+			/* clear mask : chooses the clearing pattern.
+			   rv250: could be used to clear only parts of macrotiles
+			   (but that would get really complicated...)?
+			   bit 0 and 1 (either or both of them ?!?!) are used to
+			   not clear tile (or maybe one of the bits indicates if the tile is
+			   compressed or not), bit 2 and 3 to not clear tile 1,...,.
+			   Pattern is as follows:
+			   | 0,1 | 4,5 | 8,9 |12,13|16,17|20,21|24,25|28,29|
+			   bits -------------------------------------------------
+			   | 2,3 | 6,7 |10,11|14,15|18,19|22,23|26,27|30,31|
+			   rv100: clearmask covers 2x8 4x1 tiles, but one clear still
+			   covers 256 pixels ?!?
+			 */
@@ -832 +869 @@
-		BEGIN_RING( 8 );
+		BEGIN_RING(8);
@@ -834,2 +871,2 @@
-		OUT_RING_REG( RADEON_RB3D_DEPTHCLEARVALUE,
-			tempRB3D_DEPTHCLEARVALUE);
+		OUT_RING_REG(RADEON_RB3D_DEPTHCLEARVALUE,
+			     tempRB3D_DEPTHCLEARVALUE);
@@ -837 +874 @@
-		OUT_RING_REG( RADEON_RB3D_ZMASKOFFSET, 0 );
+		OUT_RING_REG(RADEON_RB3D_ZMASKOFFSET, 0);
@@ -839 +876,2 @@
-		OUT_RING_REG( RADEON_RB3D_ZCACHE_CTLSTAT, RADEON_RB3D_ZC_FLUSH_ALL );
+		OUT_RING_REG(RADEON_RB3D_ZCACHE_CTLSTAT,
+			     RADEON_RB3D_ZC_FLUSH_ALL);
@@ -845 +883,2 @@
-			if ((dev_priv->flags&CHIP_HAS_HIERZ) && !(dev_priv->microcode_version==UCODE_R200)) {
+			if ((dev_priv->flags & CHIP_HAS_HIERZ)
+			    && !(dev_priv->microcode_version == UCODE_R200)) {
@@ -853,3 +892,8 @@
-				tileoffset = ((pbox[i].y1 >> 3) * depthpixperline + pbox[i].x1) >> 6;
-				nrtilesx = ((pbox[i].x2 & ~63) - (pbox[i].x1 & ~63)) >> 4;
-				nrtilesy = (pbox[i].y2 >> 3) - (pbox[i].y1 >> 3);
+				tileoffset =
+				    ((pbox[i].y1 >> 3) * depthpixperline +
+				     pbox[i].x1) >> 6;
+				nrtilesx =
+				    ((pbox[i].x2 & ~63) -
+				     (pbox[i].x1 & ~63)) >> 4;
+				nrtilesy =
+				    (pbox[i].y2 >> 3) - (pbox[i].y1 >> 3);
@@ -857,2 +901,3 @@
-					BEGIN_RING( 4 );
-					OUT_RING( CP_PACKET3( RADEON_3D_CLEAR_ZMASK, 2 ) );
+					BEGIN_RING(4);
+					OUT_RING(CP_PACKET3
+						 (RADEON_3D_CLEAR_ZMASK, 2));
@@ -860 +905 @@
-					OUT_RING( tileoffset * 8 );
+					OUT_RING(tileoffset * 8);
@@ -862 +907 @@
-					OUT_RING( nrtilesx + 4 );
+					OUT_RING(nrtilesx + 4);
@@ -864 +909 @@
-					OUT_RING( clearmask );
+					OUT_RING(clearmask);
@@ -868,2 +913 @@
-			}
-			else if (dev_priv->microcode_version==UCODE_R200) {
+			} else if (dev_priv->microcode_version == UCODE_R200) {
@@ -872,3 +916,7 @@
-				tileoffset = ((pbox[i].y1 >> 3) * depthpixperline + pbox[i].x1) >> 5;
-				nrtilesx = (pbox[i].x2 >> 5) - (pbox[i].x1 >> 5);
-				nrtilesy = (pbox[i].y2 >> 3) - (pbox[i].y1 >> 3);
+				tileoffset =
+				    ((pbox[i].y1 >> 3) * depthpixperline +
+				     pbox[i].x1) >> 5;
+				nrtilesx =
+				    (pbox[i].x2 >> 5) - (pbox[i].x1 >> 5);
+				nrtilesy =
+				    (pbox[i].y2 >> 3) - (pbox[i].y1 >> 3);
@@ -876,2 +924,3 @@
-					BEGIN_RING( 4 );
-					OUT_RING( CP_PACKET3( RADEON_3D_CLEAR_ZMASK, 2 ) );
+					BEGIN_RING(4);
+					OUT_RING(CP_PACKET3
+						 (RADEON_3D_CLEAR_ZMASK, 2));
@@ -883 +932 @@
-					OUT_RING( tileoffset * 16 );
+					OUT_RING(tileoffset * 16);
@@ -885 +934 @@
-					OUT_RING( nrtilesx + 1 );
+					OUT_RING(nrtilesx + 1);
@@ -887 +936 @@
-					OUT_RING( clearmask );
+					OUT_RING(clearmask);
@@ -891,2 +940 @@
-			}
-			else { /* rv 100 */
+			} else {	/* rv 100 */
@@ -895,3 +943,8 @@
-				tileoffset = ((pbox[i].y1 >> 4) * depthpixperline + pbox[i].x1) >> 6;
-				nrtilesx = ((pbox[i].x2 & ~63) - (pbox[i].x1 & ~63)) >> 4;
-				nrtilesy = (pbox[i].y2 >> 4) - (pbox[i].y1 >> 4);
+				tileoffset =
+				    ((pbox[i].y1 >> 4) * depthpixperline +
+				     pbox[i].x1) >> 6;
+				nrtilesx =
+				    ((pbox[i].x2 & ~63) -
+				     (pbox[i].x1 & ~63)) >> 4;
+				nrtilesy =
+				    (pbox[i].y2 >> 4) - (pbox[i].y1 >> 4);
@@ -899,3 +952,4 @@
-					BEGIN_RING( 4 );
-					OUT_RING( CP_PACKET3( RADEON_3D_CLEAR_ZMASK, 2 ) );
-					OUT_RING( tileoffset * 128 );
+					BEGIN_RING(4);
+					OUT_RING(CP_PACKET3
+						 (RADEON_3D_CLEAR_ZMASK, 2));
+					OUT_RING(tileoffset * 128);
@@ -903 +957 @@
-					OUT_RING( nrtilesx + 4 );
+					OUT_RING(nrtilesx + 4);
@@ -905 +959 @@
-					OUT_RING( clearmask );
+					OUT_RING(clearmask);
@@ -913,6 +967,7 @@
-		if ((dev_priv->flags & CHIP_HAS_HIERZ) && (dev_priv->microcode_version==UCODE_R200)
-			&& (flags & RADEON_USE_HIERZ))
-		/* r100 and cards without hierarchical z-buffer have no high-level z-buffer */
-		/* FIXME : the mask supposedly contains low-res z values. So can't set
-		   just to the max (0xff? or actually 0x3fff?), need to take z clear
-		   value into account? */
+		if ((dev_priv->flags & CHIP_HAS_HIERZ)
+		    && (dev_priv->microcode_version == UCODE_R200)
+		    && (flags & RADEON_USE_HIERZ))
+			/* r100 and cards without hierarchical z-buffer have no high-level z-buffer */
+			/* FIXME : the mask supposedly contains low-res z values. So can't set
+			   just to the max (0xff? or actually 0x3fff?), need to take z clear
+			   value into account? */
@@ -920,5 +975,5 @@
-			BEGIN_RING( 4 );
-			OUT_RING( CP_PACKET3( RADEON_3D_CLEAR_HIZ, 2 ) );
-			OUT_RING( 0x0 ); /* First tile */
-			OUT_RING( 0x3cc0 );
-			OUT_RING( (0xff<<22)|(0xff<<6)| 0x003f003f);
+			BEGIN_RING(4);
+			OUT_RING(CP_PACKET3(RADEON_3D_CLEAR_HIZ, 2));
+			OUT_RING(0x0);	/* First tile */
+			OUT_RING(0x3cc0);
+			OUT_RING((0xff << 22) | (0xff << 6) | 0x003f003f);
@@ -959,2 +1013,0 @@
-
-
@@ -963,2 +1016,3 @@
-		tempSE_VAP_CNTL = (/* SE_VAP_CNTL__FORCE_W_TO_ONE_MASK |  */
-				   (0x9 << SE_VAP_CNTL__VF_MAX_VTX_NUM__SHIFT));
+		tempSE_VAP_CNTL = (	/* SE_VAP_CNTL__FORCE_W_TO_ONE_MASK |  */
+					  (0x9 <<
+					   SE_VAP_CNTL__VF_MAX_VTX_NUM__SHIFT));
@@ -971,2 +1025 @@
-			SE_VTE_CNTL__VTX_XY_FMT_MASK |
-			SE_VTE_CNTL__VTX_Z_FMT_MASK;
+		    SE_VTE_CNTL__VTX_XY_FMT_MASK | SE_VTE_CNTL__VTX_Z_FMT_MASK;
@@ -974 +1027 @@
-		/* Vertex format (X, Y, Z, W)*/
+		/* Vertex format (X, Y, Z, W) */
@@ -976,2 +1029,2 @@
-			SE_VTX_FMT_0__VTX_Z0_PRESENT_MASK |
-			SE_VTX_FMT_0__VTX_W0_PRESENT_MASK;
+		    SE_VTX_FMT_0__VTX_Z0_PRESENT_MASK |
+		    SE_VTX_FMT_0__VTX_W0_PRESENT_MASK;
@@ -980,3 +1033,2 @@
-
-		/* 
-		 * Depth buffer specific enables 
+		/*
+		 * Depth buffer specific enables
@@ -992 +1044 @@
-		/* 
+		/*
@@ -995,3 +1047,3 @@
-		if ( flags & RADEON_STENCIL ) {
-			tempRB3D_CNTL |=  RADEON_STENCIL_ENABLE;
-			tempRB3D_STENCILREFMASK = clear->depth_mask; 
+		if (flags & RADEON_STENCIL) {
+			tempRB3D_CNTL |= RADEON_STENCIL_ENABLE;
+			tempRB3D_STENCILREFMASK = clear->depth_mask;
@@ -1005 +1057 @@
-				RADEON_Z_DECOMPRESSION_ENABLE;
+			    RADEON_Z_DECOMPRESSION_ENABLE;
@@ -1011 +1063 @@
-		BEGIN_RING( 26 );
+		BEGIN_RING(26);
@@ -1014,15 +1066,13 @@
-		OUT_RING_REG( RADEON_PP_CNTL, tempPP_CNTL );
-		OUT_RING_REG( R200_RE_CNTL, tempRE_CNTL );
-		OUT_RING_REG( RADEON_RB3D_CNTL, tempRB3D_CNTL );
-		OUT_RING_REG( RADEON_RB3D_ZSTENCILCNTL,
-			      tempRB3D_ZSTENCILCNTL );
-		OUT_RING_REG( RADEON_RB3D_STENCILREFMASK, 
-			      tempRB3D_STENCILREFMASK );
-		OUT_RING_REG( RADEON_RB3D_PLANEMASK, tempRB3D_PLANEMASK );
-		OUT_RING_REG( RADEON_SE_CNTL, tempSE_CNTL );
-		OUT_RING_REG( R200_SE_VTE_CNTL, tempSE_VTE_CNTL );
-		OUT_RING_REG( R200_SE_VTX_FMT_0, tempSE_VTX_FMT_0 );
-		OUT_RING_REG( R200_SE_VTX_FMT_1, tempSE_VTX_FMT_1 );
-		OUT_RING_REG( R200_SE_VAP_CNTL, tempSE_VAP_CNTL );
-		OUT_RING_REG( R200_RE_AUX_SCISSOR_CNTL, 
-			      tempRE_AUX_SCISSOR_CNTL );
+		OUT_RING_REG(RADEON_PP_CNTL, tempPP_CNTL);
+		OUT_RING_REG(R200_RE_CNTL, tempRE_CNTL);
+		OUT_RING_REG(RADEON_RB3D_CNTL, tempRB3D_CNTL);
+		OUT_RING_REG(RADEON_RB3D_ZSTENCILCNTL, tempRB3D_ZSTENCILCNTL);
+		OUT_RING_REG(RADEON_RB3D_STENCILREFMASK,
+			     tempRB3D_STENCILREFMASK);
+		OUT_RING_REG(RADEON_RB3D_PLANEMASK, tempRB3D_PLANEMASK);
+		OUT_RING_REG(RADEON_SE_CNTL, tempSE_CNTL);
+		OUT_RING_REG(R200_SE_VTE_CNTL, tempSE_VTE_CNTL);
+		OUT_RING_REG(R200_SE_VTX_FMT_0, tempSE_VTX_FMT_0);
+		OUT_RING_REG(R200_SE_VTX_FMT_1, tempSE_VTX_FMT_1);
+		OUT_RING_REG(R200_SE_VAP_CNTL, tempSE_VAP_CNTL);
+		OUT_RING_REG(R200_RE_AUX_SCISSOR_CNTL, tempRE_AUX_SCISSOR_CNTL);
@@ -1035,3 +1085,3 @@
-		for ( i = 0 ; i < nbox ; i++ ) {
-			
-			/* Funny that this should be required -- 
+		for (i = 0; i < nbox; i++) {
+
+			/* Funny that this should be required --
@@ -1040,2 +1090 @@
-			radeon_emit_clip_rect( dev_priv,
-					       &sarea_priv->boxes[i] );
+			radeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);
@@ -1043,17 +1092,17 @@
-			BEGIN_RING( 14 );
-			OUT_RING( CP_PACKET3( R200_3D_DRAW_IMMD_2, 12 ) );
-			OUT_RING( (RADEON_PRIM_TYPE_RECT_LIST |
-				   RADEON_PRIM_WALK_RING |
-				   (3 << RADEON_NUM_VERTICES_SHIFT)) );
-			OUT_RING( depth_boxes[i].ui[CLEAR_X1] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_Y1] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_DEPTH] );
-			OUT_RING( 0x3f800000 );
-			OUT_RING( depth_boxes[i].ui[CLEAR_X1] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_Y2] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_DEPTH] );
-			OUT_RING( 0x3f800000 );
-			OUT_RING( depth_boxes[i].ui[CLEAR_X2] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_Y2] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_DEPTH] );
-			OUT_RING( 0x3f800000 );
+			BEGIN_RING(14);
+			OUT_RING(CP_PACKET3(R200_3D_DRAW_IMMD_2, 12));
+			OUT_RING((RADEON_PRIM_TYPE_RECT_LIST |
+				  RADEON_PRIM_WALK_RING |
+				  (3 << RADEON_NUM_VERTICES_SHIFT)));
+			OUT_RING(depth_boxes[i].ui[CLEAR_X1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x3f800000);
+			OUT_RING(depth_boxes[i].ui[CLEAR_X1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x3f800000);
+			OUT_RING(depth_boxes[i].ui[CLEAR_X2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x3f800000);
@@ -1062,2 +1111 @@
-	} 
-	else if ( (flags & (RADEON_DEPTH | RADEON_STENCIL)) ) {
+	} else if ((flags & (RADEON_DEPTH | RADEON_STENCIL))) {
@@ -1069,2 +1117,2 @@
-		if ( flags & RADEON_DEPTH ) {
-			rb3d_cntl |=  RADEON_Z_ENABLE;
+		if (flags & RADEON_DEPTH) {
+			rb3d_cntl |= RADEON_Z_ENABLE;
@@ -1075,3 +1123,3 @@
-		if ( flags & RADEON_STENCIL ) {
-			rb3d_cntl |=  RADEON_STENCIL_ENABLE;
-			rb3d_stencilrefmask = clear->depth_mask; /* misnamed field */
+		if (flags & RADEON_STENCIL) {
+			rb3d_cntl |= RADEON_STENCIL_ENABLE;
+			rb3d_stencilrefmask = clear->depth_mask;	/* misnamed field */
@@ -1085 +1133 @@
-				RADEON_Z_DECOMPRESSION_ENABLE;
+			    RADEON_Z_DECOMPRESSION_ENABLE;
@@ -1091 +1139 @@
-		BEGIN_RING( 13 );
+		BEGIN_RING(13);
@@ -1094,11 +1142,8 @@
-		OUT_RING( CP_PACKET0( RADEON_PP_CNTL, 1 ) );
-		OUT_RING( 0x00000000 );
-		OUT_RING( rb3d_cntl );
-		
-		OUT_RING_REG( RADEON_RB3D_ZSTENCILCNTL, tempRB3D_ZSTENCILCNTL );
-		OUT_RING_REG( RADEON_RB3D_STENCILREFMASK,
-			      rb3d_stencilrefmask );
-		OUT_RING_REG( RADEON_RB3D_PLANEMASK,
-			      0x00000000 );
-		OUT_RING_REG( RADEON_SE_CNTL,
-			      depth_clear->se_cntl );
+		OUT_RING(CP_PACKET0(RADEON_PP_CNTL, 1));
+		OUT_RING(0x00000000);
+		OUT_RING(rb3d_cntl);
+
+		OUT_RING_REG(RADEON_RB3D_ZSTENCILCNTL, tempRB3D_ZSTENCILCNTL);
+		OUT_RING_REG(RADEON_RB3D_STENCILREFMASK, rb3d_stencilrefmask);
+		OUT_RING_REG(RADEON_RB3D_PLANEMASK, 0x00000000);
+		OUT_RING_REG(RADEON_SE_CNTL, depth_clear->se_cntl);
@@ -1111,3 +1156,3 @@
-		for ( i = 0 ; i < nbox ; i++ ) {
-			
-			/* Funny that this should be required -- 
+		for (i = 0; i < nbox; i++) {
+
+			/* Funny that this should be required --
@@ -1116,2 +1161 @@
-			radeon_emit_clip_rect( dev_priv,
-					       &sarea_priv->boxes[i] );
+			radeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);
@@ -1119 +1163 @@
-			BEGIN_RING( 15 );
+			BEGIN_RING(15);
@@ -1121,24 +1165,23 @@
-			OUT_RING( CP_PACKET3( RADEON_3D_DRAW_IMMD, 13 ) );
-			OUT_RING( RADEON_VTX_Z_PRESENT |
-				  RADEON_VTX_PKCOLOR_PRESENT);
-			OUT_RING( (RADEON_PRIM_TYPE_RECT_LIST |
-				   RADEON_PRIM_WALK_RING |
-				   RADEON_MAOS_ENABLE |
-				   RADEON_VTX_FMT_RADEON_MODE |
-				   (3 << RADEON_NUM_VERTICES_SHIFT)) );
-
-
-			OUT_RING( depth_boxes[i].ui[CLEAR_X1] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_Y1] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_DEPTH] );
-			OUT_RING( 0x0 );
-
-			OUT_RING( depth_boxes[i].ui[CLEAR_X1] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_Y2] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_DEPTH] );
-			OUT_RING( 0x0 );
-
-			OUT_RING( depth_boxes[i].ui[CLEAR_X2] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_Y2] );
-			OUT_RING( depth_boxes[i].ui[CLEAR_DEPTH] );
-			OUT_RING( 0x0 );
+			OUT_RING(CP_PACKET3(RADEON_3D_DRAW_IMMD, 13));
+			OUT_RING(RADEON_VTX_Z_PRESENT |
+				 RADEON_VTX_PKCOLOR_PRESENT);
+			OUT_RING((RADEON_PRIM_TYPE_RECT_LIST |
+				  RADEON_PRIM_WALK_RING |
+				  RADEON_MAOS_ENABLE |
+				  RADEON_VTX_FMT_RADEON_MODE |
+				  (3 << RADEON_NUM_VERTICES_SHIFT)));
+
+			OUT_RING(depth_boxes[i].ui[CLEAR_X1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x0);
+
+			OUT_RING(depth_boxes[i].ui[CLEAR_X1]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x0);
+
+			OUT_RING(depth_boxes[i].ui[CLEAR_X2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_Y2]);
+			OUT_RING(depth_boxes[i].ui[CLEAR_DEPTH]);
+			OUT_RING(0x0);
@@ -1156 +1199 @@
-	BEGIN_RING( 4 );
+	BEGIN_RING(4);
@@ -1158 +1201 @@
-	RADEON_CLEAR_AGE( dev_priv->sarea_priv->last_clear );
+	RADEON_CLEAR_AGE(dev_priv->sarea_priv->last_clear);
@@ -1164 +1207 @@
-static void radeon_cp_dispatch_swap( drm_device_t *dev )
+static void radeon_cp_dispatch_swap(drm_device_t * dev)
@@ -1172 +1215 @@
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
@@ -1177,2 +1220 @@
-		radeon_cp_performance_boxes( dev_priv );
-
+		radeon_cp_performance_boxes(dev_priv);
@@ -1183 +1225 @@
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
@@ -1189 +1231 @@
-	for ( i = 0 ; i < nbox ; i++ ) {
+	for (i = 0; i < nbox; i++) {
@@ -1195,2 +1237 @@
-		DRM_DEBUG( "dispatch swap %d,%d-%d,%d\n",
-			   x, y, w, h );
+		DRM_DEBUG("dispatch swap %d,%d-%d,%d\n", x, y, w, h);
@@ -1198 +1239,11 @@
-		BEGIN_RING( 7 );
+		BEGIN_RING(7);
+
+		OUT_RING(CP_PACKET3(RADEON_CNTL_BITBLT_MULTI, 5));
+		OUT_RING(RADEON_GMC_SRC_PITCH_OFFSET_CNTL |
+			 RADEON_GMC_DST_PITCH_OFFSET_CNTL |
+			 RADEON_GMC_BRUSH_NONE |
+			 (dev_priv->color_fmt << 8) |
+			 RADEON_GMC_SRC_DATATYPE_COLOR |
+			 RADEON_ROP3_S |
+			 RADEON_DP_SRC_SOURCE_MEMORY |
+			 RADEON_GMC_CLR_CMP_CNTL_DIS | RADEON_GMC_WR_MSK_DIS);
@@ -1200,11 +1250,0 @@
-		OUT_RING( CP_PACKET3( RADEON_CNTL_BITBLT_MULTI, 5 ) );
-		OUT_RING( RADEON_GMC_SRC_PITCH_OFFSET_CNTL |
-			  RADEON_GMC_DST_PITCH_OFFSET_CNTL |
-			  RADEON_GMC_BRUSH_NONE |
-			  (dev_priv->color_fmt << 8) |
-			  RADEON_GMC_SRC_DATATYPE_COLOR |
-			  RADEON_ROP3_S |
-			  RADEON_DP_SRC_SOURCE_MEMORY |
-			  RADEON_GMC_CLR_CMP_CNTL_DIS |
-			  RADEON_GMC_WR_MSK_DIS );
-		
@@ -1214,6 +1254,5 @@
-			OUT_RING( dev_priv->back_pitch_offset );
-			OUT_RING( dev_priv->front_pitch_offset );
-		} 
-		else {
-			OUT_RING( dev_priv->front_pitch_offset );
-			OUT_RING( dev_priv->back_pitch_offset );
+			OUT_RING(dev_priv->back_pitch_offset);
+			OUT_RING(dev_priv->front_pitch_offset);
+		} else {
+			OUT_RING(dev_priv->front_pitch_offset);
+			OUT_RING(dev_priv->back_pitch_offset);
@@ -1222,3 +1261,3 @@
-		OUT_RING( (x << 16) | y );
-		OUT_RING( (x << 16) | y );
-		OUT_RING( (w << 16) | h );
+		OUT_RING((x << 16) | y);
+		OUT_RING((x << 16) | y);
+		OUT_RING((w << 16) | h);
@@ -1235 +1274 @@
-	BEGIN_RING( 4 );
+	BEGIN_RING(4);
@@ -1237 +1276 @@
-	RADEON_FRAME_AGE( dev_priv->sarea_priv->last_frame );
+	RADEON_FRAME_AGE(dev_priv->sarea_priv->last_frame);
@@ -1243 +1282 @@
-static void radeon_cp_dispatch_flip( drm_device_t *dev )
+static void radeon_cp_dispatch_flip(drm_device_t * dev)
@@ -1246 +1285 @@
-	drm_sarea_t *sarea = (drm_sarea_t *)dev_priv->sarea->handle;
+	drm_sarea_t *sarea = (drm_sarea_t *) dev_priv->sarea->handle;
@@ -1248 +1287 @@
-		   ? dev_priv->front_offset : dev_priv->back_offset;
+	    ? dev_priv->front_offset : dev_priv->back_offset;
@@ -1250,4 +1289,3 @@
-	DRM_DEBUG( "%s: page=%d pfCurrentPage=%d\n", 
-		__FUNCTION__, 
-		dev_priv->current_page,
-		dev_priv->sarea_priv->pfCurrentPage);
+	DRM_DEBUG("%s: page=%d pfCurrentPage=%d\n",
+		  __FUNCTION__,
+		  dev_priv->current_page, dev_priv->sarea_priv->pfCurrentPage);
@@ -1259 +1297 @@
-		radeon_cp_performance_boxes( dev_priv );
+		radeon_cp_performance_boxes(dev_priv);
@@ -1264 +1302 @@
-	BEGIN_RING( 6 );
+	BEGIN_RING(6);
@@ -1267,6 +1305,6 @@
-	OUT_RING_REG( RADEON_CRTC_OFFSET, ( ( sarea->frame.y * dev_priv->front_pitch
-					      + sarea->frame.x 
-					      * ( dev_priv->color_fmt - 2 ) ) & ~7 )
-					  + offset );
-	OUT_RING_REG( RADEON_CRTC2_OFFSET, dev_priv->sarea_priv->crtc2_base
-					   + offset );
+	OUT_RING_REG(RADEON_CRTC_OFFSET,
+		     ((sarea->frame.y * dev_priv->front_pitch +
+		       sarea->frame.x * (dev_priv->color_fmt - 2)) & ~7)
+		     + offset);
+	OUT_RING_REG(RADEON_CRTC2_OFFSET, dev_priv->sarea_priv->crtc2_base
+		     + offset);
@@ -1282 +1320 @@
-					      1 - dev_priv->current_page;
+	    1 - dev_priv->current_page;
@@ -1284 +1322 @@
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
@@ -1286 +1324 @@
-	RADEON_FRAME_AGE( dev_priv->sarea_priv->last_frame );
+	RADEON_FRAME_AGE(dev_priv->sarea_priv->last_frame);
@@ -1291 +1329 @@
-static int bad_prim_vertex_nr( int primitive, int nr )
+static int bad_prim_vertex_nr(int primitive, int nr)
@@ -1311 +1349 @@
-	}	
+	}
@@ -1314,2 +1351,0 @@
-
-
@@ -1321,2 +1357,2 @@
-	unsigned int offset;   
-        unsigned int vc_format;
+	unsigned int offset;
+	unsigned int vc_format;
@@ -1325,4 +1361,3 @@
-static void radeon_cp_dispatch_vertex( drm_device_t *dev,
-				       drm_buf_t *buf,
-				       drm_radeon_tcl_prim_t *prim )
-
+static void radeon_cp_dispatch_vertex(drm_device_t * dev,
+				      drm_buf_t * buf,
+				      drm_radeon_tcl_prim_t * prim)
@@ -1340,8 +1375,5 @@
-		  prim->vc_format,
-		  prim->start,
-		  prim->finish,
-		  prim->numverts);
-
-	if (bad_prim_vertex_nr( prim->prim, prim->numverts )) {
-		DRM_ERROR( "bad prim %x numverts %d\n", 
-			   prim->prim, prim->numverts );
+		  prim->vc_format, prim->start, prim->finish, prim->numverts);
+
+	if (bad_prim_vertex_nr(prim->prim, prim->numverts)) {
+		DRM_ERROR("bad prim %x numverts %d\n",
+			  prim->prim, prim->numverts);
@@ -1353,3 +1385,2 @@
-		if ( i < nbox ) {
-			radeon_emit_clip_rect( dev_priv, 
-					       &sarea_priv->boxes[i] );
+		if (i < nbox) {
+			radeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);
@@ -1359 +1390 @@
-		BEGIN_RING( 5 );
+		BEGIN_RING(5);
@@ -1361,8 +1392,8 @@
-		OUT_RING( CP_PACKET3( RADEON_3D_RNDR_GEN_INDX_PRIM, 3 ) );
-		OUT_RING( offset );
-		OUT_RING( numverts );
-		OUT_RING( prim->vc_format );
-		OUT_RING( prim->prim | RADEON_PRIM_WALK_LIST |
-			  RADEON_COLOR_ORDER_RGBA |
-			  RADEON_VTX_FMT_RADEON_MODE |
-			  (numverts << RADEON_NUM_VERTICES_SHIFT) );
+		OUT_RING(CP_PACKET3(RADEON_3D_RNDR_GEN_INDX_PRIM, 3));
+		OUT_RING(offset);
+		OUT_RING(numverts);
+		OUT_RING(prim->vc_format);
+		OUT_RING(prim->prim | RADEON_PRIM_WALK_LIST |
+			 RADEON_COLOR_ORDER_RGBA |
+			 RADEON_VTX_FMT_RADEON_MODE |
+			 (numverts << RADEON_NUM_VERTICES_SHIFT));
@@ -1373 +1404 @@
-	} while ( i < nbox );
+	} while (i < nbox);
@@ -1376,3 +1407 @@
-
-
-static void radeon_cp_discard_buffer( drm_device_t *dev, drm_buf_t *buf )
+static void radeon_cp_discard_buffer(drm_device_t * dev, drm_buf_t * buf)
@@ -1387,2 +1416,2 @@
-	BEGIN_RING( 2 );
-	RADEON_DISPATCH_AGE( buf_priv->age );
+	BEGIN_RING(2);
+	RADEON_DISPATCH_AGE(buf_priv->age);
@@ -1395,3 +1424,2 @@
-static void radeon_cp_dispatch_indirect( drm_device_t *dev,
-					 drm_buf_t *buf,
-					 int start, int end )
+static void radeon_cp_dispatch_indirect(drm_device_t * dev,
+					drm_buf_t * buf, int start, int end)
@@ -1401,2 +1429 @@
-	DRM_DEBUG( "indirect: buf=%d s=0x%x e=0x%x\n",
-		   buf->idx, start, end );
+	DRM_DEBUG("indirect: buf=%d s=0x%x e=0x%x\n", buf->idx, start, end);
@@ -1404 +1431 @@
-	if ( start != end ) {
+	if (start != end) {
@@ -1413 +1440 @@
-		if ( dwords & 1 ) {
+		if (dwords & 1) {
@@ -1415,2 +1442,2 @@
-				((char *)dev->agp_buffer_map->handle
-				 + buf->offset + start);
+			    ((char *)dev->agp_buffer_map->handle
+			     + buf->offset + start);
@@ -1421 +1448 @@
-		BEGIN_RING( 3 );
+		BEGIN_RING(3);
@@ -1423,3 +1450,3 @@
-		OUT_RING( CP_PACKET0( RADEON_CP_IB_BASE, 1 ) );
-		OUT_RING( offset );
-		OUT_RING( dwords );
+		OUT_RING(CP_PACKET0(RADEON_CP_IB_BASE, 1));
+		OUT_RING(offset);
+		OUT_RING(dwords);
@@ -1431,4 +1458,3 @@
-
-static void radeon_cp_dispatch_indices( drm_device_t *dev,
-					drm_buf_t *elt_buf,
-					drm_radeon_tcl_prim_t *prim )
+static void radeon_cp_dispatch_indices(drm_device_t * dev,
+				       drm_buf_t * elt_buf,
+				       drm_radeon_tcl_prim_t * prim)
@@ -1449,8 +1475,4 @@
-		  prim->start,
-		  prim->finish,
-		  prim->offset,
-		  prim->numverts);
-
-	if (bad_prim_vertex_nr( prim->prim, count )) {
-		DRM_ERROR( "bad prim %x count %d\n", 
-			   prim->prim, count );
+		  prim->start, prim->finish, prim->offset, prim->numverts);
+
+	if (bad_prim_vertex_nr(prim->prim, count)) {
+		DRM_ERROR("bad prim %x count %d\n", prim->prim, count);
@@ -1460,4 +1482,2 @@
-
-	if ( start >= prim->finish ||
-	     (prim->start & 0x7) ) {
-		DRM_ERROR( "buffer prim %d\n", prim->prim );
+	if (start >= prim->finish || (prim->start & 0x7)) {
+		DRM_ERROR("buffer prim %d\n", prim->prim);
@@ -1469,2 +1489,2 @@
-	data = (u32 *)((char *)dev->agp_buffer_map->handle +
-		       elt_buf->offset + prim->start);
+	data = (u32 *) ((char *)dev->agp_buffer_map->handle +
+			elt_buf->offset + prim->start);
@@ -1472 +1492 @@
-	data[0] = CP_PACKET3( RADEON_3D_RNDR_GEN_INDX_PRIM, dwords-2 );
+	data[0] = CP_PACKET3(RADEON_3D_RNDR_GEN_INDX_PRIM, dwords - 2);
@@ -1480 +1500 @@
-		   (count << RADEON_NUM_VERTICES_SHIFT) );
+		   (count << RADEON_NUM_VERTICES_SHIFT));
@@ -1483,7 +1503,5 @@
-		if ( i < nbox ) 
-			radeon_emit_clip_rect( dev_priv, 
-					       &sarea_priv->boxes[i] );
-
-		radeon_cp_dispatch_indirect( dev, elt_buf,
-					     prim->start,
-					     prim->finish );
+		if (i < nbox)
+			radeon_emit_clip_rect(dev_priv, &sarea_priv->boxes[i]);
+
+		radeon_cp_dispatch_indirect(dev, elt_buf,
+					    prim->start, prim->finish);
@@ -1492 +1510 @@
-	} while ( i < nbox );
+	} while (i < nbox);
@@ -1498,4 +1516,4 @@
-static int radeon_cp_dispatch_texture( DRMFILE filp,
-				       drm_device_t *dev,
-				       drm_radeon_texture_t *tex,
-				       drm_radeon_tex_image_t *image )
+static int radeon_cp_dispatch_texture(DRMFILE filp,
+				      drm_device_t * dev,
+				      drm_radeon_texture_t * tex,
+				      drm_radeon_tex_image_t * image)
@@ -1516 +1534 @@
-	DRM_GET_PRIV_WITH_RETURN( filp_priv, filp );
+	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
@@ -1518,3 +1536,3 @@
-	if ( radeon_check_and_fixup_offset( dev_priv, filp_priv, &tex->offset ) ) {
-		DRM_ERROR( "Invalid destination offset\n" );
-		return DRM_ERR( EINVAL );
+	if (radeon_check_and_fixup_offset(dev_priv, filp_priv, &tex->offset)) {
+		DRM_ERROR("Invalid destination offset\n");
+		return DRM_ERR(EINVAL);
@@ -1529 +1547 @@
-	BEGIN_RING( 4 );
+	BEGIN_RING(4);
@@ -1538 +1556 @@
-	switch ( tex->format ) {
+	switch (tex->format) {
@@ -1562 +1580 @@
-		DRM_ERROR( "invalid texture format %d\n", tex->format );
+		DRM_ERROR("invalid texture format %d\n", tex->format);
@@ -1577,2 +1595,2 @@
-	}
-	else microtile = 0;
+	} else
+		microtile = 0;
@@ -1580 +1598 @@
-	DRM_DEBUG("tex=%dx%d blit=%d\n", tex_width, tex->height, blit_width );
+	DRM_DEBUG("tex=%dx%d blit=%d\n", tex_width, tex->height, blit_width);
@@ -1583,3 +1601,3 @@
-		DRM_DEBUG( "tex: ofs=0x%x p=%d f=%d x=%hd y=%hd w=%hd h=%hd\n",
-			   tex->offset >> 10, tex->pitch, tex->format,
-			   image->x, image->y, image->width, image->height );
+		DRM_DEBUG("tex: ofs=0x%x p=%d f=%d x=%hd y=%hd w=%hd h=%hd\n",
+			  tex->offset >> 10, tex->pitch, tex->format,
+			  image->x, image->y, image->width, image->height);
@@ -1592 +1610 @@
-		
+
@@ -1595 +1613 @@
-		if ( size > RADEON_MAX_TEXTURE_SIZE ) {
+		if (size > RADEON_MAX_TEXTURE_SIZE) {
@@ -1598 +1616 @@
-		} else if ( size < 4 && size > 0 ) {
+		} else if (size < 4 && size > 0) {
@@ -1600 +1618 @@
-		} else if ( size == 0 ) {
+		} else if (size == 0) {
@@ -1604,4 +1622,4 @@
-		buf = radeon_freelist_get( dev );
-		if ( 0 && !buf ) {
-			radeon_do_cp_idle( dev_priv );
-			buf = radeon_freelist_get( dev );
+		buf = radeon_freelist_get(dev);
+		if (0 && !buf) {
+			radeon_do_cp_idle(dev_priv);
+			buf = radeon_freelist_get(dev);
@@ -1609 +1627 @@
-		if ( !buf ) {
+		if (!buf) {
@@ -1611 +1629 @@
-			if (DRM_COPY_TO_USER( tex->image, image, sizeof(*image) ))
+			if (DRM_COPY_TO_USER(tex->image, image, sizeof(*image)))
@@ -1616 +1633,0 @@
-
@@ -1619 +1636,2 @@
-		buffer = (u32*)((char*)dev->agp_buffer_map->handle + buf->offset);
+		buffer =
+		    (u32 *) ((char *)dev->agp_buffer_map->handle + buf->offset);
@@ -1634,3 +1652,5 @@
-							       tex_width * sizeof(u32))) {
-						DRM_ERROR("EFAULT on pad, %d bytes\n",
-							  tex_width);
+							       tex_width *
+							       sizeof(u32))) {
+						DRM_ERROR
+						    ("EFAULT on pad, %d bytes\n",
+						     tex_width);
@@ -1640,3 +1660,5 @@
-					if (DRM_COPY_FROM_USER(buffer, data, 16)) {
-						DRM_ERROR("EFAULT on pad, %d bytes\n",
-							  tex_width);
+					if (DRM_COPY_FROM_USER
+					    (buffer, data, 16)) {
+						DRM_ERROR
+						    ("EFAULT on pad, %d bytes\n",
+						     tex_width);
@@ -1645,3 +1667,5 @@
-					if (DRM_COPY_FROM_USER(buffer + 8, data + 16, 16)) {
-						DRM_ERROR("EFAULT on pad, %d bytes\n",
-							  tex_width);
+					if (DRM_COPY_FROM_USER
+					    (buffer + 8, data + 16, 16)) {
+						DRM_ERROR
+						    ("EFAULT on pad, %d bytes\n",
+						     tex_width);
@@ -1660,3 +1684,5 @@
-					if (DRM_COPY_FROM_USER(buffer, data, tex_width)) {
-						DRM_ERROR("EFAULT on pad, %d bytes\n",
-							  tex_width);
+					if (DRM_COPY_FROM_USER
+					    (buffer, data, tex_width)) {
+						DRM_ERROR
+						    ("EFAULT on pad, %d bytes\n",
+						     tex_width);
@@ -1672,3 +1698,5 @@
-					if (DRM_COPY_FROM_USER(buffer, data, 16)) {
-						DRM_ERROR("EFAULT on pad, %d bytes\n",
-							  tex_width);
+					if (DRM_COPY_FROM_USER
+					    (buffer, data, 16)) {
+						DRM_ERROR
+						    ("EFAULT on pad, %d bytes\n",
+						     tex_width);
@@ -1678,3 +1706,5 @@
-					if (DRM_COPY_FROM_USER(buffer + 8, data, 16)) {
-						DRM_ERROR("EFAULT on pad, %d bytes\n",
-							  tex_width);
+					if (DRM_COPY_FROM_USER
+					    (buffer + 8, data, 16)) {
+						DRM_ERROR
+						    ("EFAULT on pad, %d bytes\n",
+						     tex_width);
@@ -1684,3 +1714,5 @@
-					if (DRM_COPY_FROM_USER(buffer + 4, data, 16)) {
-						DRM_ERROR("EFAULT on pad, %d bytes\n",
-							  tex_width);
+					if (DRM_COPY_FROM_USER
+					    (buffer + 4, data, 16)) {
+						DRM_ERROR
+						    ("EFAULT on pad, %d bytes\n",
+						     tex_width);
@@ -1690,3 +1722,5 @@
-					if (DRM_COPY_FROM_USER(buffer + 12, data, 16)) {
-						DRM_ERROR("EFAULT on pad, %d bytes\n",
-							  tex_width);
+					if (DRM_COPY_FROM_USER
+					    (buffer + 12, data, 16)) {
+						DRM_ERROR
+						    ("EFAULT on pad, %d bytes\n",
+						     tex_width);
@@ -1699,2 +1733 @@
-		}
-		else {
+		} else {
@@ -1716,3 +1749,6 @@
-				for (i = 0 ; i < tex->height ; i++) {
-					if (DRM_COPY_FROM_USER(buffer, data, tex_width )) {
-						DRM_ERROR("EFAULT on pad, %d bytes\n", tex_width);
+				for (i = 0; i < tex->height; i++) {
+					if (DRM_COPY_FROM_USER
+					    (buffer, data, tex_width)) {
+						DRM_ERROR
+						    ("EFAULT on pad, %d bytes\n",
+						     tex_width);
@@ -1739,2 +1775 @@
-			 RADEON_GMC_CLR_CMP_CNTL_DIS |
-			 RADEON_GMC_WR_MSK_DIS );
+			 RADEON_GMC_CLR_CMP_CNTL_DIS | RADEON_GMC_WR_MSK_DIS);
@@ -1761 +1796 @@
-	BEGIN_RING( 4 );
+	BEGIN_RING(4);
@@ -1768,2 +1803 @@
-
-static void radeon_cp_dispatch_stipple( drm_device_t *dev, u32 *stipple )
+static void radeon_cp_dispatch_stipple(drm_device_t * dev, u32 * stipple)
@@ -1774 +1808 @@
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
@@ -1776 +1810 @@
-	BEGIN_RING( 35 );
+	BEGIN_RING(35);
@@ -1778,2 +1812,2 @@
-	OUT_RING( CP_PACKET0( RADEON_RE_STIPPLE_ADDR, 0 ) );
-	OUT_RING( 0x00000000 );
+	OUT_RING(CP_PACKET0(RADEON_RE_STIPPLE_ADDR, 0));
+	OUT_RING(0x00000000);
@@ -1781,3 +1815,3 @@
-	OUT_RING( CP_PACKET0_TABLE( RADEON_RE_STIPPLE_DATA, 31 ) );
-	for ( i = 0 ; i < 32 ; i++ ) {
-		OUT_RING( stipple[i] );
+	OUT_RING(CP_PACKET0_TABLE(RADEON_RE_STIPPLE_DATA, 31));
+	for (i = 0; i < 32; i++) {
+		OUT_RING(stipple[i]);
@@ -1789 +1823,2 @@
-static void radeon_apply_surface_regs(int surf_index, drm_radeon_private_t *dev_priv)
+static void radeon_apply_surface_regs(int surf_index,
+				      drm_radeon_private_t * dev_priv)
@@ -1796,6 +1831,6 @@
-	RADEON_WRITE(RADEON_SURFACE0_INFO + 16*surf_index,
-		dev_priv->surfaces[surf_index].flags);
-	RADEON_WRITE(RADEON_SURFACE0_LOWER_BOUND + 16*surf_index,
-		dev_priv->surfaces[surf_index].lower);
-	RADEON_WRITE(RADEON_SURFACE0_UPPER_BOUND + 16*surf_index,
-		dev_priv->surfaces[surf_index].upper);
+	RADEON_WRITE(RADEON_SURFACE0_INFO + 16 * surf_index,
+		     dev_priv->surfaces[surf_index].flags);
+	RADEON_WRITE(RADEON_SURFACE0_LOWER_BOUND + 16 * surf_index,
+		     dev_priv->surfaces[surf_index].lower);
+	RADEON_WRITE(RADEON_SURFACE0_UPPER_BOUND + 16 * surf_index,
+		     dev_priv->surfaces[surf_index].upper);
@@ -1804 +1838,0 @@
-
@@ -1806 +1840 @@
- * doesn't always allocate a real surface, will stretch an existing 
+ * doesn't always allocate a real surface, will stretch an existing
@@ -1812 +1846 @@
- * For example : we allocate three contigous surfaces ABC. If B is 
+ * For example : we allocate three contigous surfaces ABC. If B is
@@ -1816 +1850,2 @@
-static int alloc_surface(drm_radeon_surface_alloc_t* new, drm_radeon_private_t *dev_priv, DRMFILE filp)
+static int alloc_surface(drm_radeon_surface_alloc_t * new,
+			 drm_radeon_private_t * dev_priv, DRMFILE filp)
@@ -1828,2 +1863,3 @@
-		((new_upper & RADEON_SURF_ADDRESS_FIXED_MASK) != RADEON_SURF_ADDRESS_FIXED_MASK) ||
-		((new_lower & RADEON_SURF_ADDRESS_FIXED_MASK) != 0))
+	    ((new_upper & RADEON_SURF_ADDRESS_FIXED_MASK) !=
+	     RADEON_SURF_ADDRESS_FIXED_MASK)
+	    || ((new_lower & RADEON_SURF_ADDRESS_FIXED_MASK) != 0))
@@ -1835,5 +1871,6 @@
-		(( (new_lower >= dev_priv->surfaces[i].lower) &&
-			(new_lower < dev_priv->surfaces[i].upper) ) ||
-		 ( (new_lower < dev_priv->surfaces[i].lower) &&
-			(new_upper > dev_priv->surfaces[i].lower) )) ){
-		return -1;}
+		    (((new_lower >= dev_priv->surfaces[i].lower) &&
+		      (new_lower < dev_priv->surfaces[i].upper)) ||
+		     ((new_lower < dev_priv->surfaces[i].lower) &&
+		      (new_upper > dev_priv->surfaces[i].lower)))) {
+			return -1;
+		}
@@ -1843 +1880 @@
-	for (i = 0; i < 2*RADEON_MAX_SURFACES; i++)
+	for (i = 0; i < 2 * RADEON_MAX_SURFACES; i++)
@@ -1846,2 +1883,3 @@
-	if (i == 2*RADEON_MAX_SURFACES) {
-		return -1;}
+	if (i == 2 * RADEON_MAX_SURFACES) {
+		return -1;
+	}
@@ -1854,2 +1892,2 @@
-		  (new->flags == dev_priv->surfaces[i].flags) &&
-		  (new_upper + 1 == dev_priv->surfaces[i].lower)) {
+		    (new->flags == dev_priv->surfaces[i].flags) &&
+		    (new_upper + 1 == dev_priv->surfaces[i].lower)) {
@@ -1870,2 +1908,2 @@
-		  (new->flags == dev_priv->surfaces[i].flags) &&
-		  (new_lower == dev_priv->surfaces[i].upper + 1)) {
+		    (new->flags == dev_priv->surfaces[i].flags) &&
+		    (new_lower == dev_priv->surfaces[i].upper + 1)) {
@@ -1907 +1945,2 @@
-static int free_surface(DRMFILE filp, drm_radeon_private_t *dev_priv, int lower)
+static int free_surface(DRMFILE filp, drm_radeon_private_t * dev_priv,
+			int lower)
@@ -1912 +1951 @@
-	for(i = 0; i < 2*RADEON_MAX_SURFACES; i++) {
+	for (i = 0; i < 2 * RADEON_MAX_SURFACES; i++) {
@@ -1916,5 +1955,9 @@
-				if (dev_priv->surfaces[s->surface_index].lower == s->lower)
-					dev_priv->surfaces[s->surface_index].lower = s->upper;
-
-				if (dev_priv->surfaces[s->surface_index].upper == s->upper)
-					dev_priv->surfaces[s->surface_index].upper = s->lower;
+				if (dev_priv->surfaces[s->surface_index].
+				    lower == s->lower)
+					dev_priv->surfaces[s->surface_index].
+					    lower = s->upper;
+
+				if (dev_priv->surfaces[s->surface_index].
+				    upper == s->upper)
+					dev_priv->surfaces[s->surface_index].
+					    upper = s->lower;
@@ -1923,2 +1966,4 @@
-				if (dev_priv->surfaces[s->surface_index].refcount == 0)
-					dev_priv->surfaces[s->surface_index].flags = 0;
+				if (dev_priv->surfaces[s->surface_index].
+				    refcount == 0)
+					dev_priv->surfaces[s->surface_index].
+					    flags = 0;
@@ -1926 +1971,2 @@
-				radeon_apply_surface_regs(s->surface_index, dev_priv);
+				radeon_apply_surface_regs(s->surface_index,
+							  dev_priv);
@@ -1934 +1980,2 @@
-static void radeon_surfaces_release(DRMFILE filp, drm_radeon_private_t *dev_priv)
+static void radeon_surfaces_release(DRMFILE filp,
+				    drm_radeon_private_t * dev_priv)
@@ -1937,2 +1984 @@
-	for( i = 0; i < 2*RADEON_MAX_SURFACES; i++)
-	{
+	for (i = 0; i < 2 * RADEON_MAX_SURFACES; i++) {
@@ -1940 +1986,2 @@
-			free_surface(filp, dev_priv, dev_priv->virt_surfaces[i].lower);
+			free_surface(filp, dev_priv,
+				     dev_priv->virt_surfaces[i].lower);
@@ -1954 +2001 @@
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
@@ -1958,2 +2005,3 @@
-	DRM_COPY_FROM_USER_IOCTL(alloc, (drm_radeon_surface_alloc_t __user *)data,
-				  sizeof(alloc));
+	DRM_COPY_FROM_USER_IOCTL(alloc,
+				 (drm_radeon_surface_alloc_t __user *) data,
+				 sizeof(alloc));
@@ -1974 +2022 @@
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
@@ -1978,2 +2026,2 @@
-	DRM_COPY_FROM_USER_IOCTL(memfree, (drm_radeon_mem_free_t __user *)data,
-				  sizeof(memfree) );
+	DRM_COPY_FROM_USER_IOCTL(memfree, (drm_radeon_mem_free_t __user *) data,
+				 sizeof(memfree));
@@ -1987 +2035 @@
-static int radeon_cp_clear( DRM_IOCTL_ARGS )
+static int radeon_cp_clear(DRM_IOCTL_ARGS)
@@ -1994 +2042 @@
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
@@ -1996 +2044 @@
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -1998,2 +2046,2 @@
-	DRM_COPY_FROM_USER_IOCTL( clear, (drm_radeon_clear_t __user *)data,
-			     sizeof(clear) );
+	DRM_COPY_FROM_USER_IOCTL(clear, (drm_radeon_clear_t __user *) data,
+				 sizeof(clear));
@@ -2001 +2049 @@
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
@@ -2003 +2051 @@
-	if ( sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS )
+	if (sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS)
@@ -2006,2 +2054,2 @@
-	if ( DRM_COPY_FROM_USER( &depth_boxes, clear.depth_boxes,
-			     sarea_priv->nbox * sizeof(depth_boxes[0]) ) )
+	if (DRM_COPY_FROM_USER(&depth_boxes, clear.depth_boxes,
+			       sarea_priv->nbox * sizeof(depth_boxes[0])))
@@ -2010 +2058 @@
-	radeon_cp_dispatch_clear( dev, &clear, depth_boxes );
+	radeon_cp_dispatch_clear(dev, &clear, depth_boxes);
@@ -2016 +2063,0 @@
-
@@ -2018,2 +2065,2 @@
- */ 
-static int radeon_do_init_pageflip( drm_device_t *dev )
+ */
+static int radeon_do_init_pageflip(drm_device_t * dev)
@@ -2024 +2071 @@
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
@@ -2026 +2073 @@
-	BEGIN_RING( 6 );
+	BEGIN_RING(6);
@@ -2028,4 +2075,6 @@
-	OUT_RING( CP_PACKET0( RADEON_CRTC_OFFSET_CNTL, 0 ) );
-	OUT_RING( RADEON_READ( RADEON_CRTC_OFFSET_CNTL ) | RADEON_CRTC_OFFSET_FLIP_CNTL );
-	OUT_RING( CP_PACKET0( RADEON_CRTC2_OFFSET_CNTL, 0 ) );
-	OUT_RING( RADEON_READ( RADEON_CRTC2_OFFSET_CNTL ) | RADEON_CRTC_OFFSET_FLIP_CNTL );
+	OUT_RING(CP_PACKET0(RADEON_CRTC_OFFSET_CNTL, 0));
+	OUT_RING(RADEON_READ(RADEON_CRTC_OFFSET_CNTL) |
+		 RADEON_CRTC_OFFSET_FLIP_CNTL);
+	OUT_RING(CP_PACKET0(RADEON_CRTC2_OFFSET_CNTL, 0));
+	OUT_RING(RADEON_READ(RADEON_CRTC2_OFFSET_CNTL) |
+		 RADEON_CRTC_OFFSET_FLIP_CNTL);
@@ -2044 +2093 @@
-static int radeon_do_cleanup_pageflip( drm_device_t *dev )
+static int radeon_do_cleanup_pageflip(drm_device_t * dev)
@@ -2047 +2096 @@
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
@@ -2050 +2099 @@
-		radeon_cp_dispatch_flip( dev );
+		radeon_cp_dispatch_flip(dev);
@@ -2057 +2106 @@
- * They can & should be intermixed to support multiple 3d windows.  
+ * They can & should be intermixed to support multiple 3d windows.
@@ -2059 +2108 @@
-static int radeon_cp_flip( DRM_IOCTL_ARGS )
+static int radeon_cp_flip(DRM_IOCTL_ARGS)
@@ -2063 +2112 @@
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
@@ -2065 +2114 @@
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -2067 +2116 @@
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
@@ -2069,4 +2118,4 @@
-	if (!dev_priv->page_flipping) 
-		radeon_do_init_pageflip( dev );
-		
-	radeon_cp_dispatch_flip( dev );
+	if (!dev_priv->page_flipping)
+		radeon_do_init_pageflip(dev);
+
+	radeon_cp_dispatch_flip(dev);
@@ -2078 +2127 @@
-static int radeon_cp_swap( DRM_IOCTL_ARGS )
+static int radeon_cp_swap(DRM_IOCTL_ARGS)
@@ -2083 +2132 @@
-	DRM_DEBUG( "\n" );
+	DRM_DEBUG("\n");
@@ -2085 +2134 @@
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -2087 +2136 @@
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
@@ -2089 +2138 @@
-	if ( sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS )
+	if (sarea_priv->nbox > RADEON_NR_SAREA_CLIPRECTS)
@@ -2092 +2141 @@
-	radeon_cp_dispatch_swap( dev );
+	radeon_cp_dispatch_swap(dev);
@@ -2099 +2148 @@
-static int radeon_cp_vertex( DRM_IOCTL_ARGS )
+static int radeon_cp_vertex(DRM_IOCTL_ARGS)
@@ -2110 +2159 @@
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -2112 +2161 @@
-	DRM_GET_PRIV_WITH_RETURN( filp_priv, filp );
+	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
@@ -2114,2 +2163,2 @@
-	DRM_COPY_FROM_USER_IOCTL( vertex, (drm_radeon_vertex_t __user *)data,
-			     sizeof(vertex) );
+	DRM_COPY_FROM_USER_IOCTL(vertex, (drm_radeon_vertex_t __user *) data,
+				 sizeof(vertex));
@@ -2117,3 +2166,2 @@
-	DRM_DEBUG( "pid=%d index=%d count=%d discard=%d\n",
-		   DRM_CURRENTPID,
-		   vertex.idx, vertex.count, vertex.discard );
+	DRM_DEBUG("pid=%d index=%d count=%d discard=%d\n",
+		  DRM_CURRENTPID, vertex.idx, vertex.count, vertex.discard);
@@ -2121,3 +2169,3 @@
-	if ( vertex.idx < 0 || vertex.idx >= dma->buf_count ) {
-		DRM_ERROR( "buffer index %d (of %d max)\n",
-			   vertex.idx, dma->buf_count - 1 );
+	if (vertex.idx < 0 || vertex.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  vertex.idx, dma->buf_count - 1);
@@ -2126,3 +2174,2 @@
-	if ( vertex.prim < 0 ||
-	     vertex.prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST ) {
-		DRM_ERROR( "buffer prim %d\n", vertex.prim );
+	if (vertex.prim < 0 || vertex.prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST) {
+		DRM_ERROR("buffer prim %d\n", vertex.prim);
@@ -2132,2 +2179,2 @@
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
@@ -2137,3 +2184,3 @@
-	if ( buf->filp != filp ) {
-		DRM_ERROR( "process %d using buffer owned by %p\n",
-			   DRM_CURRENTPID, buf->filp );
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->filp);
@@ -2142,2 +2189,2 @@
-	if ( buf->pending ) {
-		DRM_ERROR( "sending pending buffer %d\n", vertex.idx );
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", vertex.idx);
@@ -2150 +2197 @@
-		buf->used = vertex.count; /* not used? */
+		buf->used = vertex.count;	/* not used? */
@@ -2152,7 +2199,7 @@
-		if ( sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS ) {
-			if ( radeon_emit_state( dev_priv, filp_priv,
-						&sarea_priv->context_state,
-						sarea_priv->tex_state,
-						sarea_priv->dirty ) ) {
-				DRM_ERROR( "radeon_emit_state failed\n" );
-				return DRM_ERR( EINVAL );
+		if (sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS) {
+			if (radeon_emit_state(dev_priv, filp_priv,
+					      &sarea_priv->context_state,
+					      sarea_priv->tex_state,
+					      sarea_priv->dirty)) {
+				DRM_ERROR("radeon_emit_state failed\n");
+				return DRM_ERR(EINVAL);
@@ -2168 +2215 @@
-		prim.finish = vertex.count; /* unused */
+		prim.finish = vertex.count;	/* unused */
@@ -2172,2 +2219,2 @@
-		
-		radeon_cp_dispatch_vertex( dev, buf, &prim );
+
+		radeon_cp_dispatch_vertex(dev, buf, &prim);
@@ -2177 +2224 @@
-		radeon_cp_discard_buffer( dev, buf );
+		radeon_cp_discard_buffer(dev, buf);
@@ -2184 +2231 @@
-static int radeon_cp_indices( DRM_IOCTL_ARGS )
+static int radeon_cp_indices(DRM_IOCTL_ARGS)
@@ -2196 +2243 @@
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -2198,2 +2245,2 @@
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
@@ -2203 +2250 @@
-	DRM_GET_PRIV_WITH_RETURN( filp_priv, filp );
+	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
@@ -2205,2 +2252,2 @@
-	DRM_COPY_FROM_USER_IOCTL( elts, (drm_radeon_indices_t __user *)data,
-			     sizeof(elts) );
+	DRM_COPY_FROM_USER_IOCTL(elts, (drm_radeon_indices_t __user *) data,
+				 sizeof(elts));
@@ -2208,3 +2255,2 @@
-	DRM_DEBUG( "pid=%d index=%d start=%d end=%d discard=%d\n",
-		   DRM_CURRENTPID,
-		   elts.idx, elts.start, elts.end, elts.discard );
+	DRM_DEBUG("pid=%d index=%d start=%d end=%d discard=%d\n",
+		  DRM_CURRENTPID, elts.idx, elts.start, elts.end, elts.discard);
@@ -2212,3 +2258,3 @@
-	if ( elts.idx < 0 || elts.idx >= dma->buf_count ) {
-		DRM_ERROR( "buffer index %d (of %d max)\n",
-			   elts.idx, dma->buf_count - 1 );
+	if (elts.idx < 0 || elts.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  elts.idx, dma->buf_count - 1);
@@ -2217,3 +2263,2 @@
-	if ( elts.prim < 0 ||
-	     elts.prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST ) {
-		DRM_ERROR( "buffer prim %d\n", elts.prim );
+	if (elts.prim < 0 || elts.prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST) {
+		DRM_ERROR("buffer prim %d\n", elts.prim);
@@ -2223,2 +2268,2 @@
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
@@ -2228,3 +2273,3 @@
-	if ( buf->filp != filp ) {
-		DRM_ERROR( "process %d using buffer owned by %p\n",
-			   DRM_CURRENTPID, buf->filp );
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->filp);
@@ -2233,2 +2278,2 @@
-	if ( buf->pending ) {
-		DRM_ERROR( "sending pending buffer %d\n", elts.idx );
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", elts.idx);
@@ -2241,2 +2286,2 @@
-	if ( elts.start & 0x7 ) {
-		DRM_ERROR( "misaligned buffer 0x%x\n", elts.start );
+	if (elts.start & 0x7) {
+		DRM_ERROR("misaligned buffer 0x%x\n", elts.start);
@@ -2245,2 +2290,2 @@
-	if ( elts.start < buf->used ) {
-		DRM_ERROR( "no header 0x%x - 0x%x\n", elts.start, buf->used );
+	if (elts.start < buf->used) {
+		DRM_ERROR("no header 0x%x - 0x%x\n", elts.start, buf->used);
@@ -2252,7 +2297,7 @@
-	if ( sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS ) {
-		if ( radeon_emit_state( dev_priv, filp_priv,
-					&sarea_priv->context_state,
-					sarea_priv->tex_state,
-					sarea_priv->dirty ) ) {
-			DRM_ERROR( "radeon_emit_state failed\n" );
-			return DRM_ERR( EINVAL );
+	if (sarea_priv->dirty & ~RADEON_UPLOAD_CLIPRECTS) {
+		if (radeon_emit_state(dev_priv, filp_priv,
+				      &sarea_priv->context_state,
+				      sarea_priv->tex_state,
+				      sarea_priv->dirty)) {
+			DRM_ERROR("radeon_emit_state failed\n");
+			return DRM_ERR(EINVAL);
@@ -2267 +2311,0 @@
-
@@ -2271 +2315 @@
-	prim.finish = elts.end; 
+	prim.finish = elts.end;
@@ -2274 +2318 @@
-	prim.numverts = RADEON_MAX_VB_VERTS; /* duh */
+	prim.numverts = RADEON_MAX_VB_VERTS;	/* duh */
@@ -2276,2 +2320,2 @@
-	
-	radeon_cp_dispatch_indices( dev, buf, &prim );
+
+	radeon_cp_dispatch_indices(dev, buf, &prim);
@@ -2279 +2323 @@
-		radeon_cp_discard_buffer( dev, buf );
+		radeon_cp_discard_buffer(dev, buf);
@@ -2286 +2330 @@
-static int radeon_cp_texture( DRM_IOCTL_ARGS )
+static int radeon_cp_texture(DRM_IOCTL_ARGS)
@@ -2294 +2338 @@
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -2296 +2340,2 @@
-	DRM_COPY_FROM_USER_IOCTL( tex, (drm_radeon_texture_t __user *)data, sizeof(tex) );
+	DRM_COPY_FROM_USER_IOCTL(tex, (drm_radeon_texture_t __user *) data,
+				 sizeof(tex));
@@ -2298,2 +2343,2 @@
-	if ( tex.image == NULL ) {
-		DRM_ERROR( "null texture image!\n" );
+	if (tex.image == NULL) {
+		DRM_ERROR("null texture image!\n");
@@ -2303,3 +2348,3 @@
-	if ( DRM_COPY_FROM_USER( &image,
-			     (drm_radeon_tex_image_t __user *)tex.image,
-			     sizeof(image) ) )
+	if (DRM_COPY_FROM_USER(&image,
+			       (drm_radeon_tex_image_t __user *) tex.image,
+			       sizeof(image)))
@@ -2308,2 +2353,2 @@
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
@@ -2311 +2356 @@
-	ret = radeon_cp_dispatch_texture( filp, dev, &tex, &image );
+	ret = radeon_cp_dispatch_texture(filp, dev, &tex, &image);
@@ -2317 +2362 @@
-static int radeon_cp_stipple( DRM_IOCTL_ARGS )
+static int radeon_cp_stipple(DRM_IOCTL_ARGS)
@@ -2324 +2369 @@
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -2326,2 +2371,2 @@
-	DRM_COPY_FROM_USER_IOCTL( stipple, (drm_radeon_stipple_t __user *)data,
-			     sizeof(stipple) );
+	DRM_COPY_FROM_USER_IOCTL(stipple, (drm_radeon_stipple_t __user *) data,
+				 sizeof(stipple));
@@ -2329 +2374 @@
-	if ( DRM_COPY_FROM_USER( &mask, stipple.mask, 32 * sizeof(u32) ) )
+	if (DRM_COPY_FROM_USER(&mask, stipple.mask, 32 * sizeof(u32)))
@@ -2332 +2377 @@
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
@@ -2334 +2379 @@
-	radeon_cp_dispatch_stipple( dev, mask );
+	radeon_cp_dispatch_stipple(dev, mask);
@@ -2340 +2385 @@
-static int radeon_cp_indirect( DRM_IOCTL_ARGS )
+static int radeon_cp_indirect(DRM_IOCTL_ARGS)
@@ -2349 +2394 @@
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -2351,2 +2396,2 @@
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
@@ -2356,2 +2401,3 @@
-	DRM_COPY_FROM_USER_IOCTL( indirect, (drm_radeon_indirect_t __user *)data,
-			     sizeof(indirect) );
+	DRM_COPY_FROM_USER_IOCTL(indirect,
+				 (drm_radeon_indirect_t __user *) data,
+				 sizeof(indirect));
@@ -2359,3 +2405,2 @@
-	DRM_DEBUG( "indirect: idx=%d s=%d e=%d d=%d\n",
-		   indirect.idx, indirect.start,
-		   indirect.end, indirect.discard );
+	DRM_DEBUG("indirect: idx=%d s=%d e=%d d=%d\n",
+		  indirect.idx, indirect.start, indirect.end, indirect.discard);
@@ -2363,3 +2408,3 @@
-	if ( indirect.idx < 0 || indirect.idx >= dma->buf_count ) {
-		DRM_ERROR( "buffer index %d (of %d max)\n",
-			   indirect.idx, dma->buf_count - 1 );
+	if (indirect.idx < 0 || indirect.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  indirect.idx, dma->buf_count - 1);
@@ -2371,3 +2416,3 @@
-	if ( buf->filp != filp ) {
-		DRM_ERROR( "process %d using buffer owned by %p\n",
-			   DRM_CURRENTPID, buf->filp );
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->filp);
@@ -2376,2 +2421,2 @@
-	if ( buf->pending ) {
-		DRM_ERROR( "sending pending buffer %d\n", indirect.idx );
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", indirect.idx);
@@ -2381,3 +2426,3 @@
-	if ( indirect.start < buf->used ) {
-		DRM_ERROR( "reusing indirect: start=0x%x actual=0x%x\n",
-			   indirect.start, buf->used );
+	if (indirect.start < buf->used) {
+		DRM_ERROR("reusing indirect: start=0x%x actual=0x%x\n",
+			  indirect.start, buf->used);
@@ -2387,2 +2432,2 @@
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
@@ -2395 +2440 @@
-	BEGIN_RING( 2 );
+	BEGIN_RING(2);
@@ -2405 +2450 @@
-	radeon_cp_dispatch_indirect( dev, buf, indirect.start, indirect.end );
+	radeon_cp_dispatch_indirect(dev, buf, indirect.start, indirect.end);
@@ -2407 +2452 @@
-		radeon_cp_discard_buffer( dev, buf );
+		radeon_cp_discard_buffer(dev, buf);
@@ -2410 +2454,0 @@
-
@@ -2415 +2459 @@
-static int radeon_cp_vertex2( DRM_IOCTL_ARGS )
+static int radeon_cp_vertex2(DRM_IOCTL_ARGS)
@@ -2427 +2471 @@
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -2429,2 +2473,2 @@
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
@@ -2434 +2478 @@
-	DRM_GET_PRIV_WITH_RETURN( filp_priv, filp );
+	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
@@ -2436,2 +2480,2 @@
-	DRM_COPY_FROM_USER_IOCTL( vertex, (drm_radeon_vertex2_t __user *)data,
-			     sizeof(vertex) );
+	DRM_COPY_FROM_USER_IOCTL(vertex, (drm_radeon_vertex2_t __user *) data,
+				 sizeof(vertex));
@@ -2439,3 +2483,2 @@
-	DRM_DEBUG( "pid=%d index=%d discard=%d\n",
-		   DRM_CURRENTPID,
-		   vertex.idx, vertex.discard );
+	DRM_DEBUG("pid=%d index=%d discard=%d\n",
+		  DRM_CURRENTPID, vertex.idx, vertex.discard);
@@ -2443,3 +2486,3 @@
-	if ( vertex.idx < 0 || vertex.idx >= dma->buf_count ) {
-		DRM_ERROR( "buffer index %d (of %d max)\n",
-			   vertex.idx, dma->buf_count - 1 );
+	if (vertex.idx < 0 || vertex.idx >= dma->buf_count) {
+		DRM_ERROR("buffer index %d (of %d max)\n",
+			  vertex.idx, dma->buf_count - 1);
@@ -2449,2 +2492,2 @@
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
@@ -2454,3 +2497,3 @@
-	if ( buf->filp != filp ) {
-		DRM_ERROR( "process %d using buffer owned by %p\n",
-			   DRM_CURRENTPID, buf->filp );
+	if (buf->filp != filp) {
+		DRM_ERROR("process %d using buffer owned by %p\n",
+			  DRM_CURRENTPID, buf->filp);
@@ -2460,2 +2503,2 @@
-	if ( buf->pending ) {
-		DRM_ERROR( "sending pending buffer %d\n", vertex.idx );
+	if (buf->pending) {
+		DRM_ERROR("sending pending buffer %d\n", vertex.idx);
@@ -2464 +2507 @@
-	
+
@@ -2468 +2511 @@
-	for (laststate = 0xff, i = 0 ; i < vertex.nr_prims ; i++) {
+	for (laststate = 0xff, i = 0; i < vertex.nr_prims; i++) {
@@ -2471,2 +2514,2 @@
-		
-		if ( DRM_COPY_FROM_USER( &prim, &vertex.prim[i], sizeof(prim) ) )
+
+		if (DRM_COPY_FROM_USER(&prim, &vertex.prim[i], sizeof(prim)))
@@ -2474,7 +2517,7 @@
-		
-		if ( prim.stateidx != laststate ) {
-			drm_radeon_state_t state;			       
-				
-			if ( DRM_COPY_FROM_USER( &state, 
-					     &vertex.state[prim.stateidx], 
-					     sizeof(state) ) )
+
+		if (prim.stateidx != laststate) {
+			drm_radeon_state_t state;
+
+			if (DRM_COPY_FROM_USER(&state,
+					       &vertex.state[prim.stateidx],
+					       sizeof(state)))
@@ -2483,3 +2526,3 @@
-			if ( radeon_emit_state2( dev_priv, filp_priv, &state ) ) {
-				DRM_ERROR( "radeon_emit_state2 failed\n" );
-				return DRM_ERR( EINVAL );
+			if (radeon_emit_state2(dev_priv, filp_priv, &state)) {
+				DRM_ERROR("radeon_emit_state2 failed\n");
+				return DRM_ERR(EINVAL);
@@ -2496 +2539 @@
-		if ( prim.prim & RADEON_PRIM_WALK_IND ) {
+		if (prim.prim & RADEON_PRIM_WALK_IND) {
@@ -2498 +2541 @@
-			tclprim.numverts = RADEON_MAX_VB_VERTS; /* duh */
+			tclprim.numverts = RADEON_MAX_VB_VERTS;	/* duh */
@@ -2500 +2543 @@
-			radeon_cp_dispatch_indices( dev, buf, &tclprim );
+			radeon_cp_dispatch_indices(dev, buf, &tclprim);
@@ -2503 +2546 @@
-			tclprim.offset = 0; /* not used */
+			tclprim.offset = 0;	/* not used */
@@ -2505 +2548 @@
-			radeon_cp_dispatch_vertex( dev, buf, &tclprim );
+			radeon_cp_dispatch_vertex(dev, buf, &tclprim);
@@ -2507 +2550 @@
-		
+
@@ -2512,2 +2555,2 @@
-	if ( vertex.discard ) {
-		radeon_cp_discard_buffer( dev, buf );
+	if (vertex.discard) {
+		radeon_cp_discard_buffer(dev, buf);
@@ -2520,6 +2563,4 @@
-
-static int radeon_emit_packets( 
-	drm_radeon_private_t *dev_priv,
-	drm_file_t *filp_priv,
-	drm_radeon_cmd_header_t header,
-	drm_radeon_cmd_buffer_t *cmdbuf )
+static int radeon_emit_packets(drm_radeon_private_t * dev_priv,
+			       drm_file_t * filp_priv,
+			       drm_radeon_cmd_header_t header,
+			       drm_radeon_kcmd_buffer_t *cmdbuf)
@@ -2531 +2572 @@
-   
+
@@ -2539 +2580 @@
-		DRM_ERROR( "Packet size provided larger than data provided\n" );
+		DRM_ERROR("Packet size provided larger than data provided\n");
@@ -2543,3 +2584,3 @@
-	if ( radeon_check_and_fixup_packets( dev_priv, filp_priv, id, data ) ) {
-		DRM_ERROR( "Packet verification failed\n" );
-		return DRM_ERR( EINVAL );
+	if (radeon_check_and_fixup_packets(dev_priv, filp_priv, id, data)) {
+		DRM_ERROR("Packet verification failed\n");
+		return DRM_ERR(EINVAL);
@@ -2548,3 +2589,3 @@
-	BEGIN_RING(sz+1);
-	OUT_RING( CP_PACKET0( reg, (sz-1) ) );
-	OUT_RING_TABLE( data, sz );
+	BEGIN_RING(sz + 1);
+	OUT_RING(CP_PACKET0(reg, (sz - 1)));
+	OUT_RING_TABLE(data, sz);
@@ -2558,4 +2599,3 @@
-static __inline__ int radeon_emit_scalars( 
-	drm_radeon_private_t *dev_priv,
-	drm_radeon_cmd_header_t header,
-	drm_radeon_cmd_buffer_t *cmdbuf )
+static __inline__ int radeon_emit_scalars(drm_radeon_private_t * dev_priv,
+					  drm_radeon_cmd_header_t header,
+					  drm_radeon_kcmd_buffer_t * cmdbuf)
@@ -2568,5 +2608,5 @@
-	BEGIN_RING( 3+sz );
-	OUT_RING( CP_PACKET0( RADEON_SE_TCL_SCALAR_INDX_REG, 0 ) );
-	OUT_RING( start | (stride << RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT));
-	OUT_RING( CP_PACKET0_TABLE( RADEON_SE_TCL_SCALAR_DATA_REG, sz-1 ) );
-	OUT_RING_TABLE( cmdbuf->buf, sz );
+	BEGIN_RING(3 + sz);
+	OUT_RING(CP_PACKET0(RADEON_SE_TCL_SCALAR_INDX_REG, 0));
+	OUT_RING(start | (stride << RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT));
+	OUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_SCALAR_DATA_REG, sz - 1));
+	OUT_RING_TABLE(cmdbuf->buf, sz);
@@ -2581,4 +2621,3 @@
-static __inline__ int radeon_emit_scalars2( 
-	drm_radeon_private_t *dev_priv,
-	drm_radeon_cmd_header_t header,
-	drm_radeon_cmd_buffer_t *cmdbuf )
+static __inline__ int radeon_emit_scalars2(drm_radeon_private_t * dev_priv,
+					   drm_radeon_cmd_header_t header,
+					   drm_radeon_kcmd_buffer_t * cmdbuf)
@@ -2591,5 +2630,5 @@
-	BEGIN_RING( 3+sz );
-	OUT_RING( CP_PACKET0( RADEON_SE_TCL_SCALAR_INDX_REG, 0 ) );
-	OUT_RING( start | (stride << RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT));
-	OUT_RING( CP_PACKET0_TABLE( RADEON_SE_TCL_SCALAR_DATA_REG, sz-1 ) );
-	OUT_RING_TABLE( cmdbuf->buf, sz );
+	BEGIN_RING(3 + sz);
+	OUT_RING(CP_PACKET0(RADEON_SE_TCL_SCALAR_INDX_REG, 0));
+	OUT_RING(start | (stride << RADEON_SCAL_INDX_DWORD_STRIDE_SHIFT));
+	OUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_SCALAR_DATA_REG, sz - 1));
+	OUT_RING_TABLE(cmdbuf->buf, sz);
@@ -2602,4 +2641,3 @@
-static __inline__ int radeon_emit_vectors( 
-	drm_radeon_private_t *dev_priv,
-	drm_radeon_cmd_header_t header,
-	drm_radeon_cmd_buffer_t *cmdbuf )
+static __inline__ int radeon_emit_vectors(drm_radeon_private_t * dev_priv,
+					  drm_radeon_cmd_header_t header,
+					  drm_radeon_kcmd_buffer_t * cmdbuf)
@@ -2612,5 +2650,5 @@
-	BEGIN_RING( 3+sz );
-	OUT_RING( CP_PACKET0( RADEON_SE_TCL_VECTOR_INDX_REG, 0 ) );
-	OUT_RING( start | (stride << RADEON_VEC_INDX_OCTWORD_STRIDE_SHIFT));
-	OUT_RING( CP_PACKET0_TABLE( RADEON_SE_TCL_VECTOR_DATA_REG, (sz-1) ) );
-	OUT_RING_TABLE( cmdbuf->buf, sz );
+	BEGIN_RING(3 + sz);
+	OUT_RING(CP_PACKET0(RADEON_SE_TCL_VECTOR_INDX_REG, 0));
+	OUT_RING(start | (stride << RADEON_VEC_INDX_OCTWORD_STRIDE_SHIFT));
+	OUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_VECTOR_DATA_REG, (sz - 1)));
+	OUT_RING_TABLE(cmdbuf->buf, sz);
@@ -2624,4 +2662,3 @@
-
-static int radeon_emit_packet3( drm_device_t *dev,
-				drm_file_t *filp_priv,
-				drm_radeon_cmd_buffer_t *cmdbuf )
+static int radeon_emit_packet3(drm_device_t * dev,
+			       drm_file_t * filp_priv,
+			       drm_radeon_kcmd_buffer_t *cmdbuf)
@@ -2636,3 +2673,3 @@
-	if ( ( ret = radeon_check_and_fixup_packet3( dev_priv, filp_priv,
-						     cmdbuf, &cmdsz ) ) ) {
-		DRM_ERROR( "Packet verification failed\n" );
+	if ((ret = radeon_check_and_fixup_packet3(dev_priv, filp_priv,
+						  cmdbuf, &cmdsz))) {
+		DRM_ERROR("Packet verification failed\n");
@@ -2642,2 +2679,2 @@
-	BEGIN_RING( cmdsz );
-	OUT_RING_TABLE( cmdbuf->buf, cmdsz );
+	BEGIN_RING(cmdsz);
+	OUT_RING_TABLE(cmdbuf->buf, cmdsz);
@@ -2651,5 +2688,4 @@
-
-static int radeon_emit_packet3_cliprect( drm_device_t *dev,
-					 drm_file_t *filp_priv,
-					 drm_radeon_cmd_buffer_t *cmdbuf,
-					 int orig_nbox )
+static int radeon_emit_packet3_cliprect(drm_device_t * dev,
+					drm_file_t * filp_priv,
+					drm_radeon_kcmd_buffer_t *cmdbuf,
+					int orig_nbox)
@@ -2667,3 +2703,3 @@
-	if ( ( ret = radeon_check_and_fixup_packet3( dev_priv, filp_priv,
-						     cmdbuf, &cmdsz ) ) ) {
-		DRM_ERROR( "Packet verification failed\n" );
+	if ((ret = radeon_check_and_fixup_packet3(dev_priv, filp_priv,
+						  cmdbuf, &cmdsz))) {
+		DRM_ERROR("Packet verification failed\n");
@@ -2677,2 +2713,2 @@
-		if ( i < cmdbuf->nbox ) {
-			if (DRM_COPY_FROM_USER( &box, &boxes[i], sizeof(box) ))
+		if (i < cmdbuf->nbox) {
+			if (DRM_COPY_FROM_USER(&box, &boxes[i], sizeof(box)))
@@ -2692,2 +2728,2 @@
-			if ( i ) {
-				BEGIN_RING( 2 );
+			if (i) {
+				BEGIN_RING(2);
@@ -2697 +2733 @@
-			radeon_emit_clip_rect( dev_priv, &box );
+			radeon_emit_clip_rect(dev_priv, &box);
@@ -2699,3 +2735,3 @@
-		
-		BEGIN_RING( cmdsz );
-		OUT_RING_TABLE( cmdbuf->buf, cmdsz );
+
+		BEGIN_RING(cmdsz);
+		OUT_RING_TABLE(cmdbuf->buf, cmdsz);
@@ -2704,2 +2740,2 @@
-	} while ( ++i < cmdbuf->nbox );
- 	if (cmdbuf->nbox == 1)
+	} while (++i < cmdbuf->nbox);
+	if (cmdbuf->nbox == 1)
@@ -2708 +2744 @@
- out:
+      out:
@@ -2714,2 +2750 @@
-
-static int radeon_emit_wait( drm_device_t *dev, int flags )
+static int radeon_emit_wait(drm_device_t * dev, int flags)
@@ -2723,2 +2758,2 @@
-		BEGIN_RING( 2 );
-		RADEON_WAIT_UNTIL_2D_IDLE(); 
+		BEGIN_RING(2);
+		RADEON_WAIT_UNTIL_2D_IDLE();
@@ -2728,2 +2763,2 @@
-		BEGIN_RING( 2 );
-		RADEON_WAIT_UNTIL_3D_IDLE(); 
+		BEGIN_RING(2);
+		RADEON_WAIT_UNTIL_3D_IDLE();
@@ -2732,3 +2767,3 @@
-	case RADEON_WAIT_2D|RADEON_WAIT_3D:
-		BEGIN_RING( 2 );
-		RADEON_WAIT_UNTIL_IDLE(); 
+	case RADEON_WAIT_2D | RADEON_WAIT_3D:
+		BEGIN_RING(2);
+		RADEON_WAIT_UNTIL_IDLE();
@@ -2744 +2779 @@
-static int radeon_cp_cmdbuf( DRM_IOCTL_ARGS )
+static int radeon_cp_cmdbuf(DRM_IOCTL_ARGS)
@@ -2752 +2787 @@
-	drm_radeon_cmd_buffer_t cmdbuf;
+	drm_radeon_kcmd_buffer_t cmdbuf;
@@ -2755 +2790 @@
-	char *kbuf=NULL;
+	char *kbuf = NULL;
@@ -2757 +2792 @@
-	LOCK_TEST_WITH_RETURN( dev, filp );
+	LOCK_TEST_WITH_RETURN(dev, filp);
@@ -2759,2 +2794,2 @@
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
@@ -2764 +2799 @@
-	DRM_GET_PRIV_WITH_RETURN( filp_priv, filp );
+	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
@@ -2766,2 +2801,3 @@
-	DRM_COPY_FROM_USER_IOCTL( cmdbuf, (drm_radeon_cmd_buffer_t __user *)data,
-			     sizeof(cmdbuf) );
+	DRM_COPY_FROM_USER_IOCTL(cmdbuf,
+				 (drm_radeon_cmd_buffer_t __user *) data,
+				 sizeof(cmdbuf));
@@ -2769,2 +2805,2 @@
-	RING_SPACE_TEST_WITH_RETURN( dev_priv );
-	VB_AGE_TEST_WITH_RETURN( dev_priv );
+	RING_SPACE_TEST_WITH_RETURN(dev_priv);
+	VB_AGE_TEST_WITH_RETURN(dev_priv);
@@ -2772 +2808 @@
-	if (cmdbuf.bufsz > 64*1024 || cmdbuf.bufsz<0) {
+	if (cmdbuf.bufsz > 64 * 1024 || cmdbuf.bufsz < 0) {
@@ -2785 +2821 @@
-		if (DRM_COPY_FROM_USER(kbuf, cmdbuf.buf, cmdbuf.bufsz)) {
+		if (DRM_COPY_FROM_USER(kbuf, (void __user *)cmdbuf.buf, cmdbuf.bufsz)) {
@@ -2794 +2830 @@
-	if(dev_priv->microcode_version == UCODE_R300) {
+	if (dev_priv->microcode_version == UCODE_R300) {
@@ -2796,2 +2832,2 @@
-		temp=r300_do_cp_cmdbuf(dev, filp, filp_priv, &cmdbuf);
-	
+		temp = r300_do_cp_cmdbuf(dev, filp, filp_priv, &cmdbuf);
+
@@ -2800 +2836 @@
-	
+
@@ -2805 +2841 @@
-	while ( cmdbuf.bufsz >= sizeof(header) ) {
+	while (cmdbuf.bufsz >= sizeof(header)) {
@@ -2812 +2848 @@
-		case RADEON_CMD_PACKET: 
+		case RADEON_CMD_PACKET:
@@ -2814 +2850,2 @@
-			if (radeon_emit_packets( dev_priv, filp_priv, header, &cmdbuf )) {
+			if (radeon_emit_packets
+			    (dev_priv, filp_priv, header, &cmdbuf)) {
@@ -2822 +2859 @@
-			if (radeon_emit_scalars( dev_priv, header, &cmdbuf )) {
+			if (radeon_emit_scalars(dev_priv, header, &cmdbuf)) {
@@ -2830 +2867 @@
-			if (radeon_emit_vectors( dev_priv, header, &cmdbuf )) {
+			if (radeon_emit_vectors(dev_priv, header, &cmdbuf)) {
@@ -2839,3 +2876,3 @@
-			if ( idx < 0 || idx >= dma->buf_count ) {
-				DRM_ERROR( "buffer index %d (of %d max)\n",
-					   idx, dma->buf_count - 1 );
+			if (idx < 0 || idx >= dma->buf_count) {
+				DRM_ERROR("buffer index %d (of %d max)\n",
+					  idx, dma->buf_count - 1);
@@ -2846,3 +2883,3 @@
-			if ( buf->filp != filp || buf->pending ) {
-				DRM_ERROR( "bad buffer %p %p %d\n",
-					   buf->filp, filp, buf->pending);
+			if (buf->filp != filp || buf->pending) {
+				DRM_ERROR("bad buffer %p %p %d\n",
+					  buf->filp, filp, buf->pending);
@@ -2852 +2889 @@
-			radeon_cp_discard_buffer( dev, buf );
+			radeon_cp_discard_buffer(dev, buf);
@@ -2857 +2894 @@
-			if (radeon_emit_packet3( dev, filp_priv, &cmdbuf )) {
+			if (radeon_emit_packet3(dev, filp_priv, &cmdbuf)) {
@@ -2865 +2902,2 @@
-			if (radeon_emit_packet3_cliprect( dev, filp_priv, &cmdbuf, orig_nbox )) {
+			if (radeon_emit_packet3_cliprect
+			    (dev, filp_priv, &cmdbuf, orig_nbox)) {
@@ -2873 +2911 @@
-			if (radeon_emit_scalars2( dev_priv, header, &cmdbuf )) {
+			if (radeon_emit_scalars2(dev_priv, header, &cmdbuf)) {
@@ -2881 +2919 @@
-			if (radeon_emit_wait( dev, header.wait.flags )) {
+			if (radeon_emit_wait(dev, header.wait.flags)) {
@@ -2887 +2925 @@
-			DRM_ERROR("bad cmd_type %d at %p\n", 
+			DRM_ERROR("bad cmd_type %d at %p\n",
@@ -2901 +2939 @@
-err:
+      err:
@@ -2907,3 +2945 @@
-
-
-static int radeon_cp_getparam( DRM_IOCTL_ARGS )
+static int radeon_cp_getparam(DRM_IOCTL_ARGS)
@@ -2916,2 +2952,2 @@
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
@@ -2921,2 +2957,2 @@
-	DRM_COPY_FROM_USER_IOCTL( param, (drm_radeon_getparam_t __user *)data,
-			     sizeof(param) );
+	DRM_COPY_FROM_USER_IOCTL(param, (drm_radeon_getparam_t __user *) data,
+				 sizeof(param));
@@ -2924 +2960 @@
-	DRM_DEBUG( "pid=%d\n", DRM_CURRENTPID );
+	DRM_DEBUG("pid=%d\n", DRM_CURRENTPID);
@@ -2926 +2962 @@
-	switch( param.param ) {
+	switch (param.param) {
@@ -2932 +2968 @@
-		value = GET_SCRATCH( 0 );
+		value = GET_SCRATCH(0);
@@ -2935 +2971 @@
-		value = GET_SCRATCH( 1 );
+		value = GET_SCRATCH(1);
@@ -2939 +2975 @@
-		value = GET_SCRATCH( 2 );
+		value = GET_SCRATCH(2);
@@ -2954,9 +2990,9 @@
-	/*
-	 * This ioctl() doesn't work on 64-bit platforms because hw_lock is a
-	 * pointer which can't fit into an int-sized variable.  According to
-	 * Michel Dnzer, the ioctl() is only used on embedded platforms, so
-	 * not supporting it shouldn't be a problem.  If the same functionality
-	 * is needed on 64-bit platforms, a new ioctl() would have to be added,
-	 * so backwards-compatibility for the embedded platforms can be
-	 * maintained.  --davidm 4-Feb-2004.
-	 */
+		/*
+		 * This ioctl() doesn't work on 64-bit platforms because hw_lock is a
+		 * pointer which can't fit into an int-sized variable.  According to
+		 * Michel Dnzer, the ioctl() is only used on embedded platforms, so
+		 * not supporting it shouldn't be a problem.  If the same functionality
+		 * is needed on 64-bit platforms, a new ioctl() would have to be added,
+		 * so backwards-compatibility for the embedded platforms can be
+		 * maintained.  --davidm 4-Feb-2004.
+		 */
@@ -2975,2 +3011,2 @@
-	if ( DRM_COPY_TO_USER( param.value, &value, sizeof(int) ) ) {
-		DRM_ERROR( "copy_to_user\n" );
+	if (DRM_COPY_TO_USER(param.value, &value, sizeof(int))) {
+		DRM_ERROR("copy_to_user\n");
@@ -2979 +3015 @@
-	
+
@@ -2983 +3019,2 @@
-static int radeon_cp_setparam( DRM_IOCTL_ARGS ) {
+static int radeon_cp_setparam(DRM_IOCTL_ARGS)
+{
@@ -2990,3 +3027,3 @@
-	if ( !dev_priv ) {
-		DRM_ERROR( "%s called with no initialization\n", __FUNCTION__ );
-		return DRM_ERR( EINVAL );
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return DRM_ERR(EINVAL);
@@ -2995 +3032 @@
-	DRM_GET_PRIV_WITH_RETURN( filp_priv, filp );
+	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
@@ -2997,2 +3034,2 @@
-	DRM_COPY_FROM_USER_IOCTL( sp, ( drm_radeon_setparam_t __user * )data,
-				  sizeof( sp ) );
+	DRM_COPY_FROM_USER_IOCTL(sp, (drm_radeon_setparam_t __user *) data,
+				 sizeof(sp));
@@ -3000 +3037 @@
-	switch( sp.param ) {
+	switch (sp.param) {
@@ -3007 +3044 @@
-			DRM_DEBUG( "color tiling disabled\n" );
+			DRM_DEBUG("color tiling disabled\n");
@@ -3011,3 +3048,2 @@
-		}
-		else if (sp.value == 1) {
-			DRM_DEBUG( "color tiling enabled\n" );
+		} else if (sp.value == 1) {
+			DRM_DEBUG("color tiling enabled\n");
@@ -3018 +3054,4 @@
-		break;	
+		break;
+	case RADEON_SETPARAM_PCIGART_LOCATION:
+		dev_priv->pcigart_offset = sp.value;
+		break;
@@ -3020,2 +3059,2 @@
-		DRM_DEBUG( "Invalid parameter %d\n", sp.param );
-		return DRM_ERR( EINVAL );
+		DRM_DEBUG("Invalid parameter %d\n", sp.param);
+		return DRM_ERR(EINVAL);
@@ -3033 +3072 @@
-void radeon_driver_prerelease(drm_device_t *dev, DRMFILE filp)
+void radeon_driver_prerelease(drm_device_t * dev, DRMFILE filp)
@@ -3035,7 +3074,7 @@
-	if ( dev->dev_private ) {				
-		drm_radeon_private_t *dev_priv = dev->dev_private; 
-		if ( dev_priv->page_flipping ) {		
-			radeon_do_cleanup_pageflip( dev );	
-		}						
-		radeon_mem_release( filp, dev_priv->gart_heap ); 
-		radeon_mem_release( filp, dev_priv->fb_heap );	
+	if (dev->dev_private) {
+		drm_radeon_private_t *dev_priv = dev->dev_private;
+		if (dev_priv->page_flipping) {
+			radeon_do_cleanup_pageflip(dev);
+		}
+		radeon_mem_release(filp, dev_priv->gart_heap);
+		radeon_mem_release(filp, dev_priv->fb_heap);
@@ -3043 +3082 @@
-	}				
+	}
@@ -3046 +3085 @@
-void radeon_driver_pretakedown(drm_device_t *dev)
+void radeon_driver_pretakedown(drm_device_t * dev)
@@ -3051 +3090 @@
-int radeon_driver_open_helper(drm_device_t *dev, drm_file_t *filp_priv)
+int radeon_driver_open_helper(drm_device_t * dev, drm_file_t * filp_priv)
@@ -3055,3 +3094,5 @@
-	
-	radeon_priv = (struct drm_radeon_driver_file_fields *)drm_alloc(sizeof(*radeon_priv), DRM_MEM_FILES);
-	
+
+	radeon_priv =
+	    (struct drm_radeon_driver_file_fields *)
+	    drm_alloc(sizeof(*radeon_priv), DRM_MEM_FILES);
+
@@ -3062 +3103 @@
-	if ( dev_priv )
+	if (dev_priv)
@@ -3069,2 +3110 @@
-
-void radeon_driver_free_filp_priv(drm_device_t *dev, drm_file_t *filp_priv)
+void radeon_driver_free_filp_priv(drm_device_t * dev, drm_file_t * filp_priv)
@@ -3072,3 +3112,4 @@
-	 struct drm_radeon_driver_file_fields *radeon_priv = filp_priv->driver_priv;
-	 
-	 drm_free(radeon_priv, sizeof(*radeon_priv), DRM_MEM_FILES);
+	struct drm_radeon_driver_file_fields *radeon_priv =
+	    filp_priv->driver_priv;
+
+	drm_free(radeon_priv, sizeof(*radeon_priv), DRM_MEM_FILES);
@@ -3078,27 +3119,27 @@
-	[DRM_IOCTL_NR(DRM_RADEON_CP_INIT)]    = { radeon_cp_init,      1, 1 },
-	[DRM_IOCTL_NR(DRM_RADEON_CP_START)]   = { radeon_cp_start,     1, 1 },
-	[DRM_IOCTL_NR(DRM_RADEON_CP_STOP)]    = { radeon_cp_stop,      1, 1 },
-	[DRM_IOCTL_NR(DRM_RADEON_CP_RESET)]   = { radeon_cp_reset,     1, 1 },
-	[DRM_IOCTL_NR(DRM_RADEON_CP_IDLE)]    = { radeon_cp_idle,      1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_CP_RESUME)]  = { radeon_cp_resume,    1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_RESET)]      = { radeon_engine_reset, 1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_FULLSCREEN)] = { radeon_fullscreen,   1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_SWAP)]       = { radeon_cp_swap,      1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_CLEAR)]      = { radeon_cp_clear,     1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_VERTEX)]     = { radeon_cp_vertex,    1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_INDICES)]    = { radeon_cp_indices,   1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_TEXTURE)]    = { radeon_cp_texture,   1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_STIPPLE)]    = { radeon_cp_stipple,   1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_INDIRECT)]   = { radeon_cp_indirect,  1, 1 },
-	[DRM_IOCTL_NR(DRM_RADEON_VERTEX2)]    = { radeon_cp_vertex2,   1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_CMDBUF)]     = { radeon_cp_cmdbuf,    1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_GETPARAM)]   = { radeon_cp_getparam,  1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_FLIP)]       = { radeon_cp_flip,      1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_ALLOC)]      = { radeon_mem_alloc,    1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_FREE)]       = { radeon_mem_free,     1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_INIT_HEAP)]  = { radeon_mem_init_heap,1, 1 },
-	[DRM_IOCTL_NR(DRM_RADEON_IRQ_EMIT)]   = { radeon_irq_emit,     1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_IRQ_WAIT)]   = { radeon_irq_wait,     1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_SETPARAM)]   = { radeon_cp_setparam,  1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_SURF_ALLOC)] = { radeon_surface_alloc,1, 0 },
-	[DRM_IOCTL_NR(DRM_RADEON_SURF_FREE)]  = { radeon_surface_free, 1, 0 }
+	[DRM_IOCTL_NR(DRM_RADEON_CP_INIT)] = {radeon_cp_init, 1, 1},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_START)] = {radeon_cp_start, 1, 1},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_STOP)] = {radeon_cp_stop, 1, 1},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_RESET)] = {radeon_cp_reset, 1, 1},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_IDLE)] = {radeon_cp_idle, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_RESUME)] = {radeon_cp_resume, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_RESET)] = {radeon_engine_reset, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_FULLSCREEN)] = {radeon_fullscreen, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_SWAP)] = {radeon_cp_swap, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_CLEAR)] = {radeon_cp_clear, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_VERTEX)] = {radeon_cp_vertex, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_INDICES)] = {radeon_cp_indices, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_TEXTURE)] = {radeon_cp_texture, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_STIPPLE)] = {radeon_cp_stipple, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_INDIRECT)] = {radeon_cp_indirect, 1, 1},
+	[DRM_IOCTL_NR(DRM_RADEON_VERTEX2)] = {radeon_cp_vertex2, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_CMDBUF)] = {radeon_cp_cmdbuf, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_GETPARAM)] = {radeon_cp_getparam, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_FLIP)] = {radeon_cp_flip, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_ALLOC)] = {radeon_mem_alloc, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_FREE)] = {radeon_mem_free, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_INIT_HEAP)] = {radeon_mem_init_heap, 1, 1},
+	[DRM_IOCTL_NR(DRM_RADEON_IRQ_EMIT)] = {radeon_irq_emit, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_IRQ_WAIT)] = {radeon_irq_wait, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_SETPARAM)] = {radeon_cp_setparam, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_SURF_ALLOC)] = {radeon_surface_alloc, 1, 0},
+	[DRM_IOCTL_NR(DRM_RADEON_SURF_FREE)] = {radeon_surface_free, 1, 0}
--- ./projects/linux/linux-2.6.15/drivers/char/drm/radeon_state.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/drm/radeon_state.c	2006-03-20 06:53:29.000000000 +0100
@@ -1,2 +1,2 @@
-/* radeon_state.c -- State support for Radeon -*- linux-c -*-
- *
+/* radeon_state.c -- State support for Radeon -*- linux-c -*- */
+/*
@@ -75,4 +75 @@
-						  &data[(RADEON_RB3D_DEPTHOFFSET
-							 -
-							 RADEON_PP_MISC) /
-							4])) {
+		    &data[(RADEON_RB3D_DEPTHOFFSET - RADEON_PP_MISC) / 4])) {
@@ -86,4 +83 @@
-						  &data[(RADEON_RB3D_COLOROFFSET
-							 -
-							 RADEON_PP_CNTL) /
-							4])) {
+		    &data[(RADEON_RB3D_COLOROFFSET - RADEON_PP_CNTL) / 4])) {
@@ -112,4 +106 @@
-						  &data[(RADEON_PP_TXOFFSET_0
-							 -
-							 RADEON_PP_TXFILTER_0) /
-							4])) {
+		    &data[(RADEON_PP_TXOFFSET_0 - RADEON_PP_TXFILTER_0) / 4])) {
@@ -129,2 +120,3 @@
-				if (radeon_check_and_fixup_offset
-				    (dev_priv, filp_priv, &data[i])) {
+				if (radeon_check_and_fixup_offset(dev_priv,
+								  filp_priv,
+								  &data[i])) {
@@ -242,2 +234,3 @@
-						     drm_file_t * filp_priv,
-						     drm_radeon_kcmd_buffer_t *cmdbuf,
+						     drm_file_t *filp_priv,
+						     drm_radeon_kcmd_buffer_t *
+						     cmdbuf,
@@ -558 +551,2 @@
-	{R200_SE_TCL_OUTPUT_VTX_COMP_SEL, 1, "R200_SE_TCL_OUTPUT_VTX_COMP_SEL"},
+	{R200_SE_TCL_OUTPUT_VTX_COMP_SEL, 1,
+	 "R200_SE_TCL_OUTPUT_VTX_COMP_SEL"},
@@ -572 +566 @@
-	{R200_PP_CUBIC_OFFSET_F1_0, 5, "R200_PP_CUBIC_OFFSET_F1_0"},	/* 62 */
+	{R200_PP_CUBIC_OFFSET_F1_0, 5, "R200_PP_CUBIC_OFFSET_F1_0"}, /* 62 */
@@ -595 +589 @@
-	{R200_PP_AFS_0, 32, "R200_PP_AFS_0"},	/* 85 */
+	{R200_PP_AFS_0, 32, "R200_PP_AFS_0"},     /* 85 */
@@ -988,2 +982,2 @@
-	if ((dev_priv->microcode_version == UCODE_R200) &&
-	    (flags & (RADEON_DEPTH | RADEON_STENCIL))) {
+	else if ((dev_priv->microcode_version == UCODE_R200) &&
+		(flags & (RADEON_DEPTH | RADEON_STENCIL))) {
@@ -1639,0 +1634,8 @@
+#define RADEON_COPY_MT(_buf, _data, _width) \
+	do { \
+		if (DRM_COPY_FROM_USER(_buf, _data, (_width))) {\
+			DRM_ERROR("EFAULT on pad, %d bytes\n", (_width)); \
+			return DRM_ERR(EFAULT); \
+		} \
+	} while(0)
+
@@ -1651,8 +1653,2 @@
-					if (DRM_COPY_FROM_USER(buffer, data,
-							       tex_width *
-							       sizeof(u32))) {
-						DRM_ERROR
-						    ("EFAULT on pad, %d bytes\n",
-						     tex_width);
-						return DRM_ERR(EFAULT);
-					}
+					RADEON_COPY_MT(buffer, data,
+						(int)(tex_width * sizeof(u32)));
@@ -1660,14 +1656,3 @@
-					if (DRM_COPY_FROM_USER
-					    (buffer, data, 16)) {
-						DRM_ERROR
-						    ("EFAULT on pad, %d bytes\n",
-						     tex_width);
-						return DRM_ERR(EFAULT);
-					}
-					if (DRM_COPY_FROM_USER
-					    (buffer + 8, data + 16, 16)) {
-						DRM_ERROR
-						    ("EFAULT on pad, %d bytes\n",
-						     tex_width);
-						return DRM_ERR(EFAULT);
-					}
+					RADEON_COPY_MT(buffer, data, 16);
+					RADEON_COPY_MT(buffer + 8,
+						       data + 16, 16);
@@ -1676,6 +1661,2 @@
-				if (DRM_COPY_FROM_USER(buffer, data,
-						       dwords * sizeof(u32))) {
-					DRM_ERROR("EFAULT on data, %d dwords\n",
-						  dwords);
-					return DRM_ERR(EFAULT);
-				}
+				RADEON_COPY_MT(buffer, data,
+					       (int)(dwords * sizeof(u32)));
@@ -1684,7 +1665 @@
-					if (DRM_COPY_FROM_USER
-					    (buffer, data, tex_width)) {
-						DRM_ERROR
-						    ("EFAULT on pad, %d bytes\n",
-						     tex_width);
-						return DRM_ERR(EFAULT);
-					}
+					RADEON_COPY_MT(buffer, data, tex_width);
@@ -1698,7 +1673 @@
-					if (DRM_COPY_FROM_USER
-					    (buffer, data, 16)) {
-						DRM_ERROR
-						    ("EFAULT on pad, %d bytes\n",
-						     tex_width);
-						return DRM_ERR(EFAULT);
-					}
+					RADEON_COPY_MT(buffer, data, 16);
@@ -1706,7 +1675 @@
-					if (DRM_COPY_FROM_USER
-					    (buffer + 8, data, 16)) {
-						DRM_ERROR
-						    ("EFAULT on pad, %d bytes\n",
-						     tex_width);
-						return DRM_ERR(EFAULT);
-					}
+					RADEON_COPY_MT(buffer + 8, data, 16);
@@ -1714,7 +1677 @@
-					if (DRM_COPY_FROM_USER
-					    (buffer + 4, data, 16)) {
-						DRM_ERROR
-						    ("EFAULT on pad, %d bytes\n",
-						     tex_width);
-						return DRM_ERR(EFAULT);
-					}
+					RADEON_COPY_MT(buffer + 4, data, 16);
@@ -1722,7 +1679 @@
-					if (DRM_COPY_FROM_USER
-					    (buffer + 12, data, 16)) {
-						DRM_ERROR
-						    ("EFAULT on pad, %d bytes\n",
-						     tex_width);
-						return DRM_ERR(EFAULT);
-					}
+					RADEON_COPY_MT(buffer + 12, data, 16);
@@ -1738,6 +1689,2 @@
-				if (DRM_COPY_FROM_USER(buffer, data,
-						       dwords * sizeof(u32))) {
-					DRM_ERROR("EFAULT on data, %d dwords\n",
-						  dwords);
-					return DRM_ERR(EFAULT);
-				}
+				RADEON_COPY_MT(buffer, data,
+					       (int)(dwords * sizeof(u32)));
@@ -1750,7 +1697 @@
-					if (DRM_COPY_FROM_USER
-					    (buffer, data, tex_width)) {
-						DRM_ERROR
-						    ("EFAULT on pad, %d bytes\n",
-						     tex_width);
-						return DRM_ERR(EFAULT);
-					}
+					RADEON_COPY_MT(buffer, data, tex_width);
@@ -1762,0 +1704 @@
+#undef RADEON_COPY_MT
@@ -1824 +1766 @@
-				      drm_radeon_private_t * dev_priv)
+				      drm_radeon_private_t *dev_priv)
@@ -1850,2 +1792,2 @@
-static int alloc_surface(drm_radeon_surface_alloc_t * new,
-			 drm_radeon_private_t * dev_priv, DRMFILE filp)
+static int alloc_surface(drm_radeon_surface_alloc_t *new,
+			 drm_radeon_private_t *dev_priv, DRMFILE filp)
@@ -2160,0 +2103,5 @@
+	if (!dev_priv) {
+		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		return DRM_ERR(EINVAL);
+	}
+
@@ -2599 +2546 @@
-static __inline__ int radeon_emit_scalars(drm_radeon_private_t * dev_priv,
+static __inline__ int radeon_emit_scalars(drm_radeon_private_t *dev_priv,
@@ -2601 +2548 @@
-					  drm_radeon_kcmd_buffer_t * cmdbuf)
+					  drm_radeon_kcmd_buffer_t *cmdbuf)
@@ -2621 +2568 @@
-static __inline__ int radeon_emit_scalars2(drm_radeon_private_t * dev_priv,
+static __inline__ int radeon_emit_scalars2(drm_radeon_private_t *dev_priv,
@@ -2623 +2570 @@
-					   drm_radeon_kcmd_buffer_t * cmdbuf)
+					   drm_radeon_kcmd_buffer_t *cmdbuf)
@@ -2641 +2588 @@
-static __inline__ int radeon_emit_vectors(drm_radeon_private_t * dev_priv,
+static __inline__ int radeon_emit_vectors(drm_radeon_private_t *dev_priv,
@@ -2643 +2590 @@
-					  drm_radeon_kcmd_buffer_t * cmdbuf)
+					  drm_radeon_kcmd_buffer_t *cmdbuf)
@@ -2688,2 +2635,2 @@
-static int radeon_emit_packet3_cliprect(drm_device_t * dev,
-					drm_file_t * filp_priv,
+static int radeon_emit_packet3_cliprect(drm_device_t *dev,
+					drm_file_t *filp_priv,
@@ -2821 +2768,2 @@
-		if (DRM_COPY_FROM_USER(kbuf, (void __user *)cmdbuf.buf, cmdbuf.bufsz)) {
+		if (DRM_COPY_FROM_USER(kbuf, (void __user *)cmdbuf.buf,
+				       cmdbuf.bufsz)) {
@@ -2984 +2932 @@
-		value = dev_priv->mmio_offset;
+		value = dev_priv->mmio->offset;
@@ -3006,0 +2955,9 @@
+	
+	case RADEON_PARAM_CARD_TYPE:
+		if (dev_priv->flags & CHIP_IS_PCIE)
+			value = RADEON_CARD_PCIE;
+		else if (dev_priv->flags & CHIP_IS_AGP)
+			value = RADEON_CARD_AGP;
+		else
+			value = RADEON_CARD_PCI;
+		break;
@@ -3068,0 +3026 @@
+ *    - Free any alloced radeon surfaces.
@@ -3072 +3030 @@
-void radeon_driver_prerelease(drm_device_t * dev, DRMFILE filp)
+void radeon_driver_preclose(drm_device_t * dev, DRMFILE filp)
@@ -3085 +3043 @@
-void radeon_driver_pretakedown(drm_device_t * dev)
+void radeon_driver_lastclose(drm_device_t * dev)
@@ -3090 +3048 @@
-int radeon_driver_open_helper(drm_device_t * dev, drm_file_t * filp_priv)
+int radeon_driver_open(drm_device_t * dev, drm_file_t * filp_priv)
@@ -3094,0 +3053 @@
+	DRM_DEBUG("\n");
@@ -3102,0 +3062 @@
+
@@ -3110 +3070 @@
-void radeon_driver_free_filp_priv(drm_device_t * dev, drm_file_t * filp_priv)
+void radeon_driver_postclose(drm_device_t * dev, drm_file_t * filp_priv)
@@ -3119,27 +3079,27 @@
-	[DRM_IOCTL_NR(DRM_RADEON_CP_INIT)] = {radeon_cp_init, 1, 1},
-	[DRM_IOCTL_NR(DRM_RADEON_CP_START)] = {radeon_cp_start, 1, 1},
-	[DRM_IOCTL_NR(DRM_RADEON_CP_STOP)] = {radeon_cp_stop, 1, 1},
-	[DRM_IOCTL_NR(DRM_RADEON_CP_RESET)] = {radeon_cp_reset, 1, 1},
-	[DRM_IOCTL_NR(DRM_RADEON_CP_IDLE)] = {radeon_cp_idle, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_CP_RESUME)] = {radeon_cp_resume, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_RESET)] = {radeon_engine_reset, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_FULLSCREEN)] = {radeon_fullscreen, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_SWAP)] = {radeon_cp_swap, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_CLEAR)] = {radeon_cp_clear, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_VERTEX)] = {radeon_cp_vertex, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_INDICES)] = {radeon_cp_indices, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_TEXTURE)] = {radeon_cp_texture, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_STIPPLE)] = {radeon_cp_stipple, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_INDIRECT)] = {radeon_cp_indirect, 1, 1},
-	[DRM_IOCTL_NR(DRM_RADEON_VERTEX2)] = {radeon_cp_vertex2, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_CMDBUF)] = {radeon_cp_cmdbuf, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_GETPARAM)] = {radeon_cp_getparam, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_FLIP)] = {radeon_cp_flip, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_ALLOC)] = {radeon_mem_alloc, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_FREE)] = {radeon_mem_free, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_INIT_HEAP)] = {radeon_mem_init_heap, 1, 1},
-	[DRM_IOCTL_NR(DRM_RADEON_IRQ_EMIT)] = {radeon_irq_emit, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_IRQ_WAIT)] = {radeon_irq_wait, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_SETPARAM)] = {radeon_cp_setparam, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_SURF_ALLOC)] = {radeon_surface_alloc, 1, 0},
-	[DRM_IOCTL_NR(DRM_RADEON_SURF_FREE)] = {radeon_surface_free, 1, 0}
+	[DRM_IOCTL_NR(DRM_RADEON_CP_INIT)] = {radeon_cp_init, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_START)] = {radeon_cp_start, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_STOP)] = {radeon_cp_stop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_RESET)] = {radeon_cp_reset, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_IDLE)] = {radeon_cp_idle, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_CP_RESUME)] = {radeon_cp_resume, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_RESET)] = {radeon_engine_reset, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_FULLSCREEN)] = {radeon_fullscreen, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_SWAP)] = {radeon_cp_swap, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_CLEAR)] = {radeon_cp_clear, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_VERTEX)] = {radeon_cp_vertex, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_INDICES)] = {radeon_cp_indices, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_TEXTURE)] = {radeon_cp_texture, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_STIPPLE)] = {radeon_cp_stipple, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_INDIRECT)] = {radeon_cp_indirect, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY},
+	[DRM_IOCTL_NR(DRM_RADEON_VERTEX2)] = {radeon_cp_vertex2, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_CMDBUF)] = {radeon_cp_cmdbuf, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_GETPARAM)] = {radeon_cp_getparam, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_FLIP)] = {radeon_cp_flip, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_ALLOC)] = {radeon_mem_alloc, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_FREE)] = {radeon_mem_free, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_INIT_HEAP)] = {radeon_mem_init_heap, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY},
+	[DRM_IOCTL_NR(DRM_RADEON_IRQ_EMIT)] = {radeon_irq_emit, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_IRQ_WAIT)] = {radeon_irq_wait, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_SETPARAM)] = {radeon_cp_setparam, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_SURF_ALLOC)] = {radeon_surface_alloc, DRM_AUTH},
+	[DRM_IOCTL_NR(DRM_RADEON_SURF_FREE)] = {radeon_surface_free, DRM_AUTH}
--- ./projects/linux/linux-2.6.16/drivers/char/drm/radeon_state.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/char/drm/radeon_state.c	2006-06-18 03:49:35.000000000 +0200
@@ -48,2 +48,21 @@
-	if (off >= dev_priv->fb_location &&
-	    off < (dev_priv->gart_vm_start + dev_priv->gart_size))
+	/* Hrm ... the story of the offset ... So this function converts
+	 * the various ideas of what userland clients might have for an
+	 * offset in the card address space into an offset into the card
+	 * address space :) So with a sane client, it should just keep
+	 * the value intact and just do some boundary checking. However,
+	 * not all clients are sane. Some older clients pass us 0 based
+	 * offsets relative to the start of the framebuffer and some may
+	 * assume the AGP aperture it appended to the framebuffer, so we
+	 * try to detect those cases and fix them up.
+	 *
+	 * Note: It might be a good idea here to make sure the offset lands
+	 * in some "allowed" area to protect things like the PCIE GART...
+	 */
+
+	/* First, the best case, the offset already lands in either the
+	 * framebuffer or the GART mapped space
+	 */
+	if ((off >= dev_priv->fb_location &&
+	     off < (dev_priv->fb_location + dev_priv->fb_size)) ||
+	    (off >= dev_priv->gart_vm_start &&
+	     off < (dev_priv->gart_vm_start + dev_priv->gart_size)))
@@ -52,10 +71,8 @@
-	radeon_priv = filp_priv->driver_priv;
-	off += radeon_priv->radeon_fb_delta;
-
-	DRM_DEBUG("offset fixed up to 0x%x\n", off);
-
-	if (off < dev_priv->fb_location ||
-	    off >= (dev_priv->gart_vm_start + dev_priv->gart_size))
-		return DRM_ERR(EINVAL);
-
-	*offset = off;
+	/* Ok, that didn't happen... now check if we have a zero based
+	 * offset that fits in the framebuffer + gart space, apply the
+	 * magic offset we get from SETPARAM or calculated from fb_location
+	 */
+	if (off < (dev_priv->fb_size + dev_priv->gart_size)) {
+		radeon_priv = filp_priv->driver_priv;
+		off += radeon_priv->radeon_fb_delta;
+	}
@@ -63 +80,15 @@
-	return 0;
+	/* Finally, assume we aimed at a GART offset if beyond the fb */
+	if (off > (dev_priv->fb_location + dev_priv->fb_size))
+		off = off - (dev_priv->fb_location + dev_priv->fb_size) +
+			dev_priv->gart_vm_start;
+
+	/* Now recheck and fail if out of bounds */
+	if ((off >= dev_priv->fb_location &&
+	     off < (dev_priv->fb_location + dev_priv->fb_size)) ||
+	    (off >= dev_priv->gart_vm_start &&
+	     off < (dev_priv->gart_vm_start + dev_priv->gart_size))) {
+		DRM_DEBUG("offset fixed up to 0x%x\n", off);
+		*offset = off;
+		return 0;
+	}
+	return DRM_ERR(EINVAL);
@@ -1942,5 +1972,0 @@
-	if (!dev_priv) {
-		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
-		return DRM_ERR(EINVAL);
-	}
-
@@ -1963,6 +1989 @@
-	if (!dev_priv) {
-		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
-		return DRM_ERR(EINVAL);
-	}
-
-	DRM_COPY_FROM_USER_IOCTL(memfree, (drm_radeon_mem_free_t __user *) data,
+	DRM_COPY_FROM_USER_IOCTL(memfree, (drm_radeon_surface_free_t __user *) data,
@@ -2103,5 +2123,0 @@
-	if (!dev_priv) {
-		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
-		return DRM_ERR(EINVAL);
-	}
-
@@ -2192,5 +2207,0 @@
-	if (!dev_priv) {
-		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
-		return DRM_ERR(EINVAL);
-	}
-
@@ -2343,5 +2353,0 @@
-	if (!dev_priv) {
-		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
-		return DRM_ERR(EINVAL);
-	}
-
@@ -2420,5 +2425,0 @@
-	if (!dev_priv) {
-		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
-		return DRM_ERR(EINVAL);
-	}
-
@@ -2741,5 +2741,0 @@
-	if (!dev_priv) {
-		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
-		return DRM_ERR(EINVAL);
-	}
-
@@ -2900,5 +2895,0 @@
-	if (!dev_priv) {
-		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
-		return DRM_ERR(EINVAL);
-	}
-
@@ -2984,5 +2974,0 @@
-	if (!dev_priv) {
-		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
-		return DRM_ERR(EINVAL);
-	}
-
@@ -3014,0 +3001,3 @@
+	case RADEON_SETPARAM_NEW_MEMMAP:
+		dev_priv->new_memmap = sp.value;
+		break;
--- ./projects/linux/linux-2.6.17/drivers/char/drm/radeon_state.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/drm/radeon_state.c	2006-09-20 05:42:06.000000000 +0200
@@ -177,0 +178,8 @@
+	case R200_EMIT_VAP_CTL:{
+			RING_LOCALS;
+			BEGIN_RING(2);
+			OUT_RING_REG(RADEON_SE_TCL_STATE_FLUSH, 0);
+			ADVANCE_RING();
+		}
+		break;
+
@@ -205 +212,0 @@
-	case R200_EMIT_VAP_CTL:
@@ -251,0 +259 @@
+	case R200_EMIT_VAP_PVS_CNTL:
@@ -628,0 +637 @@
+	{R200_VAP_PVS_CNTL_1, 2, "R200_VAP_PVS_CNTL"},
@@ -2598 +2607,2 @@
-	BEGIN_RING(3 + sz);
+	BEGIN_RING(5 + sz);
+	OUT_RING_REG(RADEON_SE_TCL_STATE_FLUSH, 0);
@@ -2609,0 +2620,26 @@
+static __inline__ int radeon_emit_veclinear(drm_radeon_private_t *dev_priv,
+					  drm_radeon_cmd_header_t header,
+					  drm_radeon_kcmd_buffer_t *cmdbuf)
+{
+	int sz = header.veclinear.count * 4;
+	int start = header.veclinear.addr_lo | (header.veclinear.addr_hi << 8);
+	RING_LOCALS;
+
+        if (!sz)
+                return 0;
+        if (sz * 4 > cmdbuf->bufsz)
+                return DRM_ERR(EINVAL);
+
+	BEGIN_RING(5 + sz);
+	OUT_RING_REG(RADEON_SE_TCL_STATE_FLUSH, 0);
+	OUT_RING(CP_PACKET0(RADEON_SE_TCL_VECTOR_INDX_REG, 0));
+	OUT_RING(start | (1 << RADEON_VEC_INDX_OCTWORD_STRIDE_SHIFT));
+	OUT_RING(CP_PACKET0_TABLE(RADEON_SE_TCL_VECTOR_DATA_REG, (sz - 1)));
+	OUT_RING_TABLE(cmdbuf->buf, sz);
+	ADVANCE_RING();
+
+	cmdbuf->buf += sz * sizeof(int);
+	cmdbuf->bufsz -= sz * sizeof(int);
+	return 0;
+}
+
@@ -2867,0 +2904,8 @@
+		case RADEON_CMD_VECLINEAR:
+			DRM_DEBUG("RADEON_CMD_VECLINEAR\n");
+			if (radeon_emit_veclinear(dev_priv, header, &cmdbuf)) {
+				DRM_ERROR("radeon_emit_veclinear failed\n");
+				goto err;
+			}
+			break;
+
--- ./projects/linux/linux-2.6.18/drivers/char/drm/radeon_state.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/drm/radeon_state.c	2006-11-29 22:57:37.000000000 +0100
@@ -45 +45,5 @@
-	u32 off = *offset;
+	u64 off = *offset;
+	u32 fb_start = dev_priv->fb_location;
+	u32 fb_end = fb_start + dev_priv->fb_size - 1;
+	u32 gart_start = dev_priv->gart_vm_start;
+	u32 gart_end = gart_start + dev_priv->gart_size - 1;
@@ -65,4 +69,2 @@
-	if ((off >= dev_priv->fb_location &&
-	     off < (dev_priv->fb_location + dev_priv->fb_size)) ||
-	    (off >= dev_priv->gart_vm_start &&
-	     off < (dev_priv->gart_vm_start + dev_priv->gart_size)))
+	if ((off >= fb_start && off <= fb_end) ||
+	    (off >= gart_start && off <= gart_end))
@@ -81,3 +83,2 @@
-	if (off > (dev_priv->fb_location + dev_priv->fb_size))
-		off = off - (dev_priv->fb_location + dev_priv->fb_size) +
-			dev_priv->gart_vm_start;
+	if (off > fb_end)
+		off = off - fb_end - 1 + gart_start;
@@ -86,5 +87,3 @@
-	if ((off >= dev_priv->fb_location &&
-	     off < (dev_priv->fb_location + dev_priv->fb_size)) ||
-	    (off >= dev_priv->gart_vm_start &&
-	     off < (dev_priv->gart_vm_start + dev_priv->gart_size))) {
-		DRM_DEBUG("offset fixed up to 0x%x\n", off);
+	if ((off >= fb_start && off <= fb_end) ||
+	    (off >= gart_start && off <= gart_end)) {
+		DRM_DEBUG("offset fixed up to 0x%x\n", (unsigned int)off);
@@ -278,0 +278,2 @@
+	u32 offset, narrays;
+	int count, i, k;
@@ -292,3 +293,2 @@
-	/* Check client state and fix it up if necessary */
-	if (cmd[0] & 0x8000) {	/* MSB of opcode: next DWORD GUI_CNTL */
-		u32 offset;
+	switch(cmd[0] & 0xff00) {
+	/* XXX Are there old drivers needing other packets? */
@@ -295,0 +296,97 @@
+	case RADEON_3D_DRAW_IMMD:
+	case RADEON_3D_DRAW_VBUF:
+	case RADEON_3D_DRAW_INDX:
+	case RADEON_WAIT_FOR_IDLE:
+	case RADEON_CP_NOP:
+	case RADEON_3D_CLEAR_ZMASK:
+/*	case RADEON_CP_NEXT_CHAR:
+	case RADEON_CP_PLY_NEXTSCAN:
+	case RADEON_CP_SET_SCISSORS: */ /* probably safe but will never need them? */
+		/* these packets are safe */
+		break;
+
+	case RADEON_CP_3D_DRAW_IMMD_2:
+	case RADEON_CP_3D_DRAW_VBUF_2:
+	case RADEON_CP_3D_DRAW_INDX_2:
+	case RADEON_3D_CLEAR_HIZ:
+		/* safe but r200 only */
+		if (dev_priv->microcode_version != UCODE_R200) {
+			DRM_ERROR("Invalid 3d packet for r100-class chip\n");
+			return DRM_ERR(EINVAL);
+		}
+		break;
+
+	case RADEON_3D_LOAD_VBPNTR:
+		count = (cmd[0] >> 16) & 0x3fff;
+
+		if (count > 18) { /* 12 arrays max */
+			DRM_ERROR("Too large payload in 3D_LOAD_VBPNTR (count=%d)\n",
+				  count);
+			return DRM_ERR(EINVAL);
+		}
+
+		/* carefully check packet contents */
+		narrays = cmd[1] & ~0xc000;
+		k = 0;
+		i = 2;
+		while ((k < narrays) && (i < (count + 2))) {
+			i++;		/* skip attribute field */
+			if (radeon_check_and_fixup_offset(dev_priv, filp_priv, &cmd[i])) {
+				DRM_ERROR
+				    ("Invalid offset (k=%d i=%d) in 3D_LOAD_VBPNTR packet.\n",
+				     k, i);
+				return DRM_ERR(EINVAL);
+			}
+			k++;
+			i++;
+			if (k == narrays)
+				break;
+			/* have one more to process, they come in pairs */
+			if (radeon_check_and_fixup_offset(dev_priv, filp_priv, &cmd[i])) {
+				DRM_ERROR
+				    ("Invalid offset (k=%d i=%d) in 3D_LOAD_VBPNTR packet.\n",
+				     k, i);
+				return DRM_ERR(EINVAL);
+			}
+			k++;
+			i++;
+		}
+		/* do the counts match what we expect ? */
+		if ((k != narrays) || (i != (count + 2))) {
+			DRM_ERROR
+			    ("Malformed 3D_LOAD_VBPNTR packet (k=%d i=%d narrays=%d count+1=%d).\n",
+			      k, i, narrays, count + 1);
+			return DRM_ERR(EINVAL);
+		}
+		break;
+
+	case RADEON_3D_RNDR_GEN_INDX_PRIM:
+		if (dev_priv->microcode_version != UCODE_R100) {
+			DRM_ERROR("Invalid 3d packet for r200-class chip\n");
+			return DRM_ERR(EINVAL);
+		}
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv, &cmd[1])) {
+				DRM_ERROR("Invalid rndr_gen_indx offset\n");
+				return DRM_ERR(EINVAL);
+		}
+		break;
+
+	case RADEON_CP_INDX_BUFFER:
+		if (dev_priv->microcode_version != UCODE_R200) {
+			DRM_ERROR("Invalid 3d packet for r100-class chip\n");
+			return DRM_ERR(EINVAL);
+		}
+		if ((cmd[1] & 0x8000ffff) != 0x80000810) {
+			DRM_ERROR("Invalid indx_buffer reg address %08X\n", cmd[1]);
+			return DRM_ERR(EINVAL);
+		}
+		if (radeon_check_and_fixup_offset(dev_priv, filp_priv, &cmd[2])) {
+			DRM_ERROR("Invalid indx_buffer offset is %08X\n", cmd[2]);
+			return DRM_ERR(EINVAL);
+		}
+		break;
+
+	case RADEON_CNTL_HOSTDATA_BLT:
+	case RADEON_CNTL_PAINT_MULTI:
+	case RADEON_CNTL_BITBLT_MULTI:
+		/* MSB of opcode: next DWORD GUI_CNTL */
@@ -316,0 +414,5 @@
+		break;
+
+	default:
+		DRM_ERROR("Invalid packet type %x\n", cmd[0] & 0xff00);
+		return DRM_ERR(EINVAL);
@@ -872 +974 @@
-		if ((dev_priv->flags & CHIP_HAS_HIERZ)
+		if ((dev_priv->flags & RADEON_HAS_HIERZ)
@@ -917 +1019 @@
-			if ((dev_priv->flags & CHIP_HAS_HIERZ)
+			if ((dev_priv->flags & RADEON_HAS_HIERZ)
@@ -1001 +1103 @@
-		if ((dev_priv->flags & CHIP_HAS_HIERZ)
+		if ((dev_priv->flags & RADEON_HAS_HIERZ)
@@ -1273 +1375 @@
-		BEGIN_RING(7);
+		BEGIN_RING(9);
@@ -1275 +1377 @@
-		OUT_RING(CP_PACKET3(RADEON_CNTL_BITBLT_MULTI, 5));
+		OUT_RING(CP_PACKET0(RADEON_DP_GUI_MASTER_CNTL, 0));
@@ -1286,0 +1389 @@
+		OUT_RING(CP_PACKET0(RADEON_SRC_PITCH_OFFSET, 1));
@@ -1294,0 +1398 @@
+		OUT_RING(CP_PACKET0(RADEON_SRC_X_Y, 2));
@@ -2990 +3094,5 @@
-	
+	case RADEON_PARAM_SCRATCH_OFFSET:
+		if (!dev_priv->writeback_works)
+			return DRM_ERR(EINVAL);
+		value = RADEON_SCRATCH_REG_OFFSET;
+		break;
@@ -2992 +3100 @@
-		if (dev_priv->flags & CHIP_IS_PCIE)
+		if (dev_priv->flags & RADEON_IS_PCIE)
@@ -2994 +3102 @@
-		else if (dev_priv->flags & CHIP_IS_AGP)
+		else if (dev_priv->flags & RADEON_IS_AGP)
@@ -2999,0 +3108 @@
+		DRM_DEBUG("Invalid parameter %d\n", param.param);
--- ./projects/linux/linux-2.6.19/drivers/char/drm/radeon_state.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/drm/radeon_state.c	2007-02-04 19:44:54.000000000 +0100
@@ -46,4 +46 @@
-	u32 fb_start = dev_priv->fb_location;
-	u32 fb_end = fb_start + dev_priv->fb_size - 1;
-	u32 gart_start = dev_priv->gart_vm_start;
-	u32 gart_end = gart_start + dev_priv->gart_size - 1;
+	u32 fb_end = dev_priv->fb_location + dev_priv->fb_size - 1;
@@ -69,2 +66 @@
-	if ((off >= fb_start && off <= fb_end) ||
-	    (off >= gart_start && off <= gart_end))
+	if (radeon_check_offset(dev_priv, off))
@@ -84 +80 @@
-		off = off - fb_end - 1 + gart_start;
+		off = off - fb_end - 1 + dev_priv->gart_vm_start;
@@ -87,2 +83 @@
-	if ((off >= fb_start && off <= fb_end) ||
-	    (off >= gart_start && off <= gart_end)) {
+	if (radeon_check_offset(dev_priv, off)) {
--- ./projects/linux/linux-2.6.21/drivers/char/drm/radeon_state.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/char/drm/radeon_state.c	2007-07-09 01:32:17.000000000 +0200
@@ -776 +776 @@
-	if (dev_priv->page_flipping && dev_priv->current_page == 1) {
+	if (dev_priv->sarea_priv->pfCurrentPage == 1) {
@@ -864 +864 @@
-	if (dev_priv->page_flipping && dev_priv->current_page == 1) {
+	if (dev_priv->sarea_priv->pfCurrentPage == 1) {
@@ -1385 +1385 @@
-		if (dev_priv->current_page == 0) {
+		if (dev_priv->sarea_priv->pfCurrentPage == 0) {
@@ -1419 +1419 @@
-	int offset = (dev_priv->current_page == 1)
+	int offset = (dev_priv->sarea_priv->pfCurrentPage == 1)
@@ -1422 +1422 @@
-	DRM_DEBUG("%s: page=%d pfCurrentPage=%d\n",
+	DRM_DEBUG("%s: pfCurrentPage=%d\n",
@@ -1424 +1424 @@
-		  dev_priv->current_page, dev_priv->sarea_priv->pfCurrentPage);
+		  dev_priv->sarea_priv->pfCurrentPage);
@@ -1452,2 +1452,2 @@
-	dev_priv->sarea_priv->pfCurrentPage = dev_priv->current_page =
-	    1 - dev_priv->current_page;
+	dev_priv->sarea_priv->pfCurrentPage =
+		1 - dev_priv->sarea_priv->pfCurrentPage;
@@ -2155,2 +2154,0 @@
-	dev_priv->current_page = 0;
-	dev_priv->sarea_priv->pfCurrentPage = dev_priv->current_page;
@@ -2158,13 +2156,2 @@
-	return 0;
-}
-
-/* Called whenever a client dies, from drm_release.
- * NOTE:  Lock isn't necessarily held when this is called!
- */
-static int radeon_do_cleanup_pageflip(drm_device_t * dev)
-{
-	drm_radeon_private_t *dev_priv = dev->dev_private;
-	DRM_DEBUG("\n");
-
-	if (dev_priv->current_page != 0)
-		radeon_cp_dispatch_flip(dev);
+	if (dev_priv->sarea_priv->pfCurrentPage != 1)
+		dev_priv->sarea_priv->pfCurrentPage = 0;
@@ -2172 +2158,0 @@
-	dev_priv->page_flipping = 0;
@@ -3147,0 +3134 @@
+		dev_priv->pcigart_offset_set = 1;
@@ -3151,0 +3139,5 @@
+	case RADEON_SETPARAM_PCIGART_TABLE_SIZE:
+		dev_priv->gart_info.table_size = sp.value;
+		if (dev_priv->gart_info.table_size < RADEON_PCIGART_TABLE_SIZE)
+			dev_priv->gart_info.table_size = RADEON_PCIGART_TABLE_SIZE;
+		break;
@@ -3171,3 +3163 @@
-		if (dev_priv->page_flipping) {
-			radeon_do_cleanup_pageflip(dev);
-		}
+		dev_priv->page_flipping = 0;
@@ -3181,0 +3172,8 @@
+	if (dev->dev_private) {
+		drm_radeon_private_t *dev_priv = dev->dev_private;
+
+		if (dev_priv->sarea_priv &&
+		    dev_priv->sarea_priv->pfCurrentPage != 0)
+			radeon_cp_dispatch_flip(dev);
+	}
+
--- ./projects/linux/linux-2.6.22/drivers/char/drm/radeon_state.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/drm/radeon_state.c	2007-10-09 22:31:38.000000000 +0200
@@ -42 +42 @@
-						    drm_file_t * filp_priv,
+						    struct drm_file * filp_priv,
@@ -93 +93 @@
-						     drm_file_t * filp_priv,
+						     struct drm_file * filp_priv,
@@ -267 +267 @@
-						     drm_file_t *filp_priv,
+						     struct drm_file *filp_priv,
@@ -424 +424 @@
-					     drm_clip_rect_t * box)
+					     struct drm_clip_rect * box)
@@ -442 +442 @@
-			     drm_file_t * filp_priv,
+			     struct drm_file * filp_priv,
@@ -611 +611 @@
-			      drm_file_t * filp_priv,
+			      struct drm_file * filp_priv,
@@ -847 +847 @@
-static void radeon_cp_dispatch_clear(drm_device_t * dev,
+static void radeon_cp_dispatch_clear(struct drm_device * dev,
@@ -855 +855 @@
-	drm_clip_rect_t *pbox = sarea_priv->boxes;
+	struct drm_clip_rect *pbox = sarea_priv->boxes;
@@ -1338 +1338 @@
-static void radeon_cp_dispatch_swap(drm_device_t * dev)
+static void radeon_cp_dispatch_swap(struct drm_device * dev)
@@ -1343 +1343 @@
-	drm_clip_rect_t *pbox = sarea_priv->boxes;
+	struct drm_clip_rect *pbox = sarea_priv->boxes;
@@ -1415 +1415 @@
-static void radeon_cp_dispatch_flip(drm_device_t * dev)
+static void radeon_cp_dispatch_flip(struct drm_device * dev)
@@ -1418 +1418 @@
-	drm_sarea_t *sarea = (drm_sarea_t *) dev_priv->sarea->handle;
+	struct drm_sarea *sarea = (struct drm_sarea *) dev_priv->sarea->handle;
@@ -1494,2 +1494,2 @@
-static void radeon_cp_dispatch_vertex(drm_device_t * dev,
-				      drm_buf_t * buf,
+static void radeon_cp_dispatch_vertex(struct drm_device * dev,
+				      struct drm_buf * buf,
@@ -1540 +1540 @@
-static void radeon_cp_discard_buffer(drm_device_t * dev, drm_buf_t * buf)
+static void radeon_cp_discard_buffer(struct drm_device * dev, struct drm_buf * buf)
@@ -1557,2 +1557,2 @@
-static void radeon_cp_dispatch_indirect(drm_device_t * dev,
-					drm_buf_t * buf, int start, int end)
+static void radeon_cp_dispatch_indirect(struct drm_device * dev,
+					struct drm_buf * buf, int start, int end)
@@ -1591,2 +1591,2 @@
-static void radeon_cp_dispatch_indices(drm_device_t * dev,
-				       drm_buf_t * elt_buf,
+static void radeon_cp_dispatch_indices(struct drm_device * dev,
+				       struct drm_buf * elt_buf,
@@ -1650 +1650 @@
-				      drm_device_t * dev,
+				      struct drm_device * dev,
@@ -1655,2 +1655,2 @@
-	drm_file_t *filp_priv;
-	drm_buf_t *buf;
+	struct drm_file *filp_priv;
+	struct drm_buf *buf;
@@ -1884 +1884 @@
-static void radeon_cp_dispatch_stipple(drm_device_t * dev, u32 * stipple)
+static void radeon_cp_dispatch_stipple(struct drm_device * dev, u32 * stipple)
@@ -2137 +2137 @@
-static int radeon_do_init_pageflip(drm_device_t * dev)
+static int radeon_do_init_pageflip(struct drm_device * dev)
@@ -2209 +2209 @@
-	drm_file_t *filp_priv;
+	struct drm_file *filp_priv;
@@ -2211,2 +2211,2 @@
-	drm_device_dma_t *dma = dev->dma;
-	drm_buf_t *buf;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
@@ -2292 +2292 @@
-	drm_file_t *filp_priv;
+	struct drm_file *filp_priv;
@@ -2294,2 +2294,2 @@
-	drm_device_dma_t *dma = dev->dma;
-	drm_buf_t *buf;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
@@ -2441,2 +2441,2 @@
-	drm_device_dma_t *dma = dev->dma;
-	drm_buf_t *buf;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
@@ -2510 +2510 @@
-	drm_file_t *filp_priv;
+	struct drm_file *filp_priv;
@@ -2512,2 +2512,2 @@
-	drm_device_dma_t *dma = dev->dma;
-	drm_buf_t *buf;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf;
@@ -2606 +2606 @@
-			       drm_file_t * filp_priv,
+			       struct drm_file * filp_priv,
@@ -2731,2 +2731,2 @@
-static int radeon_emit_packet3(drm_device_t * dev,
-			       drm_file_t * filp_priv,
+static int radeon_emit_packet3(struct drm_device * dev,
+			       struct drm_file * filp_priv,
@@ -2757,2 +2757,2 @@
-static int radeon_emit_packet3_cliprect(drm_device_t *dev,
-					drm_file_t *filp_priv,
+static int radeon_emit_packet3_cliprect(struct drm_device *dev,
+					struct drm_file *filp_priv,
@@ -2763 +2763 @@
-	drm_clip_rect_t box;
+	struct drm_clip_rect box;
@@ -2766 +2766 @@
-	drm_clip_rect_t __user *boxes = cmdbuf->boxes;
+	struct drm_clip_rect __user *boxes = cmdbuf->boxes;
@@ -2819 +2819 @@
-static int radeon_emit_wait(drm_device_t * dev, int flags)
+static int radeon_emit_wait(struct drm_device * dev, int flags)
@@ -2852,3 +2852,3 @@
-	drm_file_t *filp_priv;
-	drm_device_dma_t *dma = dev->dma;
-	drm_buf_t *buf = NULL;
+	struct drm_file *filp_priv;
+	struct drm_device_dma *dma = dev->dma;
+	struct drm_buf *buf = NULL;
@@ -3087,0 +3088,3 @@
+	case RADEON_PARAM_VBLANK_CRTC:
+		value = radeon_vblank_crtc_get(dev);
+		break;
@@ -3105 +3108 @@
-	drm_file_t *filp_priv;
+	struct drm_file *filp_priv;
@@ -3143,0 +3147,3 @@
+	case RADEON_SETPARAM_VBLANK_CRTC:
+		return radeon_vblank_crtc_set(dev, sp.value);
+		break;
@@ -3159 +3165 @@
-void radeon_driver_preclose(drm_device_t * dev, DRMFILE filp)
+void radeon_driver_preclose(struct drm_device *dev, DRMFILE filp)
@@ -3170 +3176 @@
-void radeon_driver_lastclose(drm_device_t * dev)
+void radeon_driver_lastclose(struct drm_device *dev)
@@ -3183 +3189 @@
-int radeon_driver_open(drm_device_t * dev, drm_file_t * filp_priv)
+int radeon_driver_open(struct drm_device *dev, struct drm_file *filp_priv)
@@ -3205 +3211 @@
-void radeon_driver_postclose(drm_device_t * dev, drm_file_t * filp_priv)
+void radeon_driver_postclose(struct drm_device *dev, struct drm_file *filp_priv)
--- ./projects/linux/linux-2.6.23/drivers/char/drm/radeon_state.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/drm/radeon_state.c	2008-01-24 23:58:37.000000000 +0100
@@ -42 +42 @@
-						    struct drm_file * filp_priv,
+						    struct drm_file * file_priv,
@@ -74 +74 @@
-		radeon_priv = filp_priv->driver_priv;
+		radeon_priv = file_priv->driver_priv;
@@ -88 +88 @@
-	return DRM_ERR(EINVAL);
+	return -EINVAL;
@@ -93 +93 @@
-						     struct drm_file * filp_priv,
+						     struct drm_file *file_priv,
@@ -99 +99 @@
-		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
@@ -102 +102 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -107 +107 @@
-		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
@@ -110 +110 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -120 +120 @@
-		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
@@ -123 +123 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -130 +130 @@
-		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
@@ -133 +133 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -146 +146 @@
-								  filp_priv,
+								  file_priv,
@@ -150 +150 @@
-					return DRM_ERR(EINVAL);
+					return -EINVAL;
@@ -162 +162 @@
-								  filp_priv,
+								  file_priv,
@@ -166 +166 @@
-					return DRM_ERR(EINVAL);
+					return -EINVAL;
@@ -259 +259 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -267 +267 @@
-						     struct drm_file *filp_priv,
+						     struct drm_file *file_priv,
@@ -280 +280 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -285 +285 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -310 +310 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -320 +320 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -329 +329,2 @@
-			if (radeon_check_and_fixup_offset(dev_priv, filp_priv, &cmd[i])) {
+			if (radeon_check_and_fixup_offset(dev_priv, file_priv,
+							  &cmd[i])) {
@@ -333 +334 @@
-				return DRM_ERR(EINVAL);
+				return -EINVAL;
@@ -340 +341,3 @@
-			if (radeon_check_and_fixup_offset(dev_priv, filp_priv, &cmd[i])) {
+			if (radeon_check_and_fixup_offset(dev_priv,
+							  file_priv, &cmd[i]))
+			{
@@ -344 +347 @@
-				return DRM_ERR(EINVAL);
+				return -EINVAL;
@@ -354 +357 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -361 +364 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -363 +366 @@
-		if (radeon_check_and_fixup_offset(dev_priv, filp_priv, &cmd[1])) {
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv, &cmd[1])) {
@@ -365 +368 @@
-				return DRM_ERR(EINVAL);
+				return -EINVAL;
@@ -372 +375 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -376 +379 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -378 +381 @@
-		if (radeon_check_and_fixup_offset(dev_priv, filp_priv, &cmd[2])) {
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv, &cmd[2])) {
@@ -380 +383 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -392 +395 @@
-			    (dev_priv, filp_priv, &offset)) {
+			    (dev_priv, file_priv, &offset)) {
@@ -394 +397 @@
-				return DRM_ERR(EINVAL);
+				return -EINVAL;
@@ -403 +406 @@
-			    (dev_priv, filp_priv, &offset)) {
+			    (dev_priv, file_priv, &offset)) {
@@ -405 +408 @@
-				return DRM_ERR(EINVAL);
+				return -EINVAL;
@@ -413 +416 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -442 +445 @@
-			     struct drm_file * filp_priv,
+			     struct drm_file *file_priv,
@@ -451 +454 @@
-		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
@@ -454 +457 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -457 +460 @@
-		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
@@ -460 +463 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -546 +549 @@
-		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
@@ -549 +552 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -566 +569 @@
-		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
@@ -569 +572 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -586 +589 @@
-		if (radeon_check_and_fixup_offset(dev_priv, filp_priv,
+		if (radeon_check_and_fixup_offset(dev_priv, file_priv,
@@ -589 +592 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -611 +614 @@
-			      struct drm_file * filp_priv,
+			      struct drm_file *file_priv,
@@ -624 +627 @@
-	return radeon_emit_state(dev_priv, filp_priv, &state->context,
+	return radeon_emit_state(dev_priv, file_priv, &state->context,
@@ -1649,2 +1652,2 @@
-static int radeon_cp_dispatch_texture(DRMFILE filp,
-				      struct drm_device * dev,
+static int radeon_cp_dispatch_texture(struct drm_device * dev,
+				      struct drm_file *file_priv,
@@ -1655 +1657,0 @@
-	struct drm_file *filp_priv;
@@ -1667,3 +1669 @@
-	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
-
-	if (radeon_check_and_fixup_offset(dev_priv, filp_priv, &tex->offset)) {
+	if (radeon_check_and_fixup_offset(dev_priv, file_priv, &tex->offset)) {
@@ -1671 +1671 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -1714 +1714 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -1718 +1718 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -1763,2 +1763,2 @@
-				return DRM_ERR(EFAULT);
-			return DRM_ERR(EAGAIN);
+				return -EFAULT;
+			return -EAGAIN;
@@ -1777 +1777 @@
-			return DRM_ERR(EFAULT); \
+			return -EFAULT; \
@@ -1844 +1844 @@
-		buf->filp = filp;
+		buf->file_priv = file_priv;
@@ -1863,0 +1864 @@
+		COMMIT_RING();
@@ -1880,0 +1882,2 @@
+	COMMIT_RING();
+
@@ -1932 +1935,2 @@
-			 drm_radeon_private_t *dev_priv, DRMFILE filp)
+			 drm_radeon_private_t *dev_priv,
+			 struct drm_file *file_priv)
@@ -1962 +1966 @@
-		if (dev_priv->virt_surfaces[i].filp == 0)
+		if (dev_priv->virt_surfaces[i].file_priv == 0)
@@ -1980 +1984 @@
-			s->filp = filp;
+			s->file_priv = file_priv;
@@ -1996 +2000 @@
-			s->filp = filp;
+			s->file_priv = file_priv;
@@ -2012 +2016 @@
-			s->filp = filp;
+			s->file_priv = file_priv;
@@ -2026 +2030,2 @@
-static int free_surface(DRMFILE filp, drm_radeon_private_t * dev_priv,
+static int free_surface(struct drm_file *file_priv,
+			drm_radeon_private_t * dev_priv,
@@ -2034,2 +2039,3 @@
-		if (s->filp) {
-			if ((lower == s->lower) && (filp == s->filp)) {
+		if (s->file_priv) {
+			if ((lower == s->lower) && (file_priv == s->file_priv))
+			{
@@ -2051 +2057 @@
-				s->filp = NULL;
+				s->file_priv = NULL;
@@ -2061 +2067 @@
-static void radeon_surfaces_release(DRMFILE filp,
+static void radeon_surfaces_release(struct drm_file *file_priv,
@@ -2066,2 +2072,2 @@
-		if (dev_priv->virt_surfaces[i].filp == filp)
-			free_surface(filp, dev_priv,
+		if (dev_priv->virt_surfaces[i].file_priv == file_priv)
+			free_surface(file_priv, dev_priv,
@@ -2075 +2081 @@
-static int radeon_surface_alloc(DRM_IOCTL_ARGS)
+static int radeon_surface_alloc(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -2077 +2082,0 @@
-	DRM_DEVICE;
@@ -2079 +2084 @@
-	drm_radeon_surface_alloc_t alloc;
+	drm_radeon_surface_alloc_t *alloc = data;
@@ -2081,6 +2086,2 @@
-	DRM_COPY_FROM_USER_IOCTL(alloc,
-				 (drm_radeon_surface_alloc_t __user *) data,
-				 sizeof(alloc));
-
-	if (alloc_surface(&alloc, dev_priv, filp) == -1)
-		return DRM_ERR(EINVAL);
+	if (alloc_surface(alloc, dev_priv, file_priv) == -1)
+		return -EINVAL;
@@ -2091 +2092 @@
-static int radeon_surface_free(DRM_IOCTL_ARGS)
+static int radeon_surface_free(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -2093 +2093,0 @@
-	DRM_DEVICE;
@@ -2095,4 +2095 @@
-	drm_radeon_surface_free_t memfree;
-
-	DRM_COPY_FROM_USER_IOCTL(memfree, (drm_radeon_surface_free_t __user *) data,
-				 sizeof(memfree));
+	drm_radeon_surface_free_t *memfree = data;
@@ -2100,2 +2097,2 @@
-	if (free_surface(filp, dev_priv, memfree.address))
-		return DRM_ERR(EINVAL);
+	if (free_surface(file_priv, dev_priv, memfree->address))
+		return -EINVAL;
@@ -2106 +2103 @@
-static int radeon_cp_clear(DRM_IOCTL_ARGS)
+static int radeon_cp_clear(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -2108 +2104,0 @@
-	DRM_DEVICE;
@@ -2111 +2107 @@
-	drm_radeon_clear_t clear;
+	drm_radeon_clear_t *clear = data;
@@ -2115,4 +2111 @@
-	LOCK_TEST_WITH_RETURN(dev, filp);
-
-	DRM_COPY_FROM_USER_IOCTL(clear, (drm_radeon_clear_t __user *) data,
-				 sizeof(clear));
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
@@ -2125 +2118 @@
-	if (DRM_COPY_FROM_USER(&depth_boxes, clear.depth_boxes,
+	if (DRM_COPY_FROM_USER(&depth_boxes, clear->depth_boxes,
@@ -2127 +2120 @@
-		return DRM_ERR(EFAULT);
+		return -EFAULT;
@@ -2129 +2122 @@
-	radeon_cp_dispatch_clear(dev, &clear, depth_boxes);
+	radeon_cp_dispatch_clear(dev, clear, depth_boxes);
@@ -2165 +2158 @@
-static int radeon_cp_flip(DRM_IOCTL_ARGS)
+static int radeon_cp_flip(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -2167 +2159,0 @@
-	DRM_DEVICE;
@@ -2171 +2163 @@
-	LOCK_TEST_WITH_RETURN(dev, filp);
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
@@ -2184 +2176 @@
-static int radeon_cp_swap(DRM_IOCTL_ARGS)
+static int radeon_cp_swap(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -2186 +2177,0 @@
-	DRM_DEVICE;
@@ -2191 +2182 @@
-	LOCK_TEST_WITH_RETURN(dev, filp);
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
@@ -2205 +2196 @@
-static int radeon_cp_vertex(DRM_IOCTL_ARGS)
+static int radeon_cp_vertex(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -2207 +2197,0 @@
-	DRM_DEVICE;
@@ -2209 +2198,0 @@
-	struct drm_file *filp_priv;
@@ -2213 +2202 @@
-	drm_radeon_vertex_t vertex;
+	drm_radeon_vertex_t *vertex = data;
@@ -2216,6 +2205 @@
-	LOCK_TEST_WITH_RETURN(dev, filp);
-
-	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
-
-	DRM_COPY_FROM_USER_IOCTL(vertex, (drm_radeon_vertex_t __user *) data,
-				 sizeof(vertex));
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
@@ -2224 +2208 @@
-		  DRM_CURRENTPID, vertex.idx, vertex.count, vertex.discard);
+		  DRM_CURRENTPID, vertex->idx, vertex->count, vertex->discard);
@@ -2226 +2210 @@
-	if (vertex.idx < 0 || vertex.idx >= dma->buf_count) {
+	if (vertex->idx < 0 || vertex->idx >= dma->buf_count) {
@@ -2228,2 +2212,2 @@
-			  vertex.idx, dma->buf_count - 1);
-		return DRM_ERR(EINVAL);
+			  vertex->idx, dma->buf_count - 1);
+		return -EINVAL;
@@ -2231,3 +2215,3 @@
-	if (vertex.prim < 0 || vertex.prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST) {
-		DRM_ERROR("buffer prim %d\n", vertex.prim);
-		return DRM_ERR(EINVAL);
+	if (vertex->prim < 0 || vertex->prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST) {
+		DRM_ERROR("buffer prim %d\n", vertex->prim);
+		return -EINVAL;
@@ -2239 +2223 @@
-	buf = dma->buflist[vertex.idx];
+	buf = dma->buflist[vertex->idx];
@@ -2241 +2225 @@
-	if (buf->filp != filp) {
+	if (buf->file_priv != file_priv) {
@@ -2243,2 +2227,2 @@
-			  DRM_CURRENTPID, buf->filp);
-		return DRM_ERR(EINVAL);
+			  DRM_CURRENTPID, buf->file_priv);
+		return -EINVAL;
@@ -2247,2 +2231,2 @@
-		DRM_ERROR("sending pending buffer %d\n", vertex.idx);
-		return DRM_ERR(EINVAL);
+		DRM_ERROR("sending pending buffer %d\n", vertex->idx);
+		return -EINVAL;
@@ -2253,2 +2237,2 @@
-	if (vertex.count) {
-		buf->used = vertex.count;	/* not used? */
+	if (vertex->count) {
+		buf->used = vertex->count;	/* not used? */
@@ -2257 +2241 @@
-			if (radeon_emit_state(dev_priv, filp_priv,
+			if (radeon_emit_state(dev_priv, file_priv,
@@ -2262 +2246 @@
-				return DRM_ERR(EINVAL);
+				return -EINVAL;
@@ -2272,3 +2256,3 @@
-		prim.finish = vertex.count;	/* unused */
-		prim.prim = vertex.prim;
-		prim.numverts = vertex.count;
+		prim.finish = vertex->count;	/* unused */
+		prim.prim = vertex->prim;
+		prim.numverts = vertex->count;
@@ -2280 +2264 @@
-	if (vertex.discard) {
+	if (vertex->discard) {
@@ -2288 +2272 @@
-static int radeon_cp_indices(DRM_IOCTL_ARGS)
+static int radeon_cp_indices(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -2290 +2273,0 @@
-	DRM_DEVICE;
@@ -2292 +2274,0 @@
-	struct drm_file *filp_priv;
@@ -2296 +2278 @@
-	drm_radeon_indices_t elts;
+	drm_radeon_indices_t *elts = data;
@@ -2300,6 +2282 @@
-	LOCK_TEST_WITH_RETURN(dev, filp);
-
-	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
-
-	DRM_COPY_FROM_USER_IOCTL(elts, (drm_radeon_indices_t __user *) data,
-				 sizeof(elts));
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
@@ -2308 +2285,2 @@
-		  DRM_CURRENTPID, elts.idx, elts.start, elts.end, elts.discard);
+		  DRM_CURRENTPID, elts->idx, elts->start, elts->end,
+		  elts->discard);
@@ -2310 +2288 @@
-	if (elts.idx < 0 || elts.idx >= dma->buf_count) {
+	if (elts->idx < 0 || elts->idx >= dma->buf_count) {
@@ -2312,2 +2290,2 @@
-			  elts.idx, dma->buf_count - 1);
-		return DRM_ERR(EINVAL);
+			  elts->idx, dma->buf_count - 1);
+		return -EINVAL;
@@ -2315,3 +2293,3 @@
-	if (elts.prim < 0 || elts.prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST) {
-		DRM_ERROR("buffer prim %d\n", elts.prim);
-		return DRM_ERR(EINVAL);
+	if (elts->prim < 0 || elts->prim > RADEON_PRIM_TYPE_3VRT_LINE_LIST) {
+		DRM_ERROR("buffer prim %d\n", elts->prim);
+		return -EINVAL;
@@ -2323 +2301 @@
-	buf = dma->buflist[elts.idx];
+	buf = dma->buflist[elts->idx];
@@ -2325 +2303 @@
-	if (buf->filp != filp) {
+	if (buf->file_priv != file_priv) {
@@ -2327,2 +2305,2 @@
-			  DRM_CURRENTPID, buf->filp);
-		return DRM_ERR(EINVAL);
+			  DRM_CURRENTPID, buf->file_priv);
+		return -EINVAL;
@@ -2331,2 +2309,2 @@
-		DRM_ERROR("sending pending buffer %d\n", elts.idx);
-		return DRM_ERR(EINVAL);
+		DRM_ERROR("sending pending buffer %d\n", elts->idx);
+		return -EINVAL;
@@ -2335,2 +2313,2 @@
-	count = (elts.end - elts.start) / sizeof(u16);
-	elts.start -= RADEON_INDEX_PRIM_OFFSET;
+	count = (elts->end - elts->start) / sizeof(u16);
+	elts->start -= RADEON_INDEX_PRIM_OFFSET;
@@ -2338,3 +2316,3 @@
-	if (elts.start & 0x7) {
-		DRM_ERROR("misaligned buffer 0x%x\n", elts.start);
-		return DRM_ERR(EINVAL);
+	if (elts->start & 0x7) {
+		DRM_ERROR("misaligned buffer 0x%x\n", elts->start);
+		return -EINVAL;
@@ -2342,3 +2320,3 @@
-	if (elts.start < buf->used) {
-		DRM_ERROR("no header 0x%x - 0x%x\n", elts.start, buf->used);
-		return DRM_ERR(EINVAL);
+	if (elts->start < buf->used) {
+		DRM_ERROR("no header 0x%x - 0x%x\n", elts->start, buf->used);
+		return -EINVAL;
@@ -2347 +2325 @@
-	buf->used = elts.end;
+	buf->used = elts->end;
@@ -2350 +2328 @@
-		if (radeon_emit_state(dev_priv, filp_priv,
+		if (radeon_emit_state(dev_priv, file_priv,
@@ -2355 +2333 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -2366,3 +2344,3 @@
-	prim.start = elts.start;
-	prim.finish = elts.end;
-	prim.prim = elts.prim;
+	prim.start = elts->start;
+	prim.finish = elts->end;
+	prim.prim = elts->prim;
@@ -2374 +2352 @@
-	if (elts.discard) {
+	if (elts->discard) {
@@ -2382 +2360 @@
-static int radeon_cp_texture(DRM_IOCTL_ARGS)
+static int radeon_cp_texture(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -2384 +2361,0 @@
-	DRM_DEVICE;
@@ -2386 +2363 @@
-	drm_radeon_texture_t tex;
+	drm_radeon_texture_t *tex = data;
@@ -2390,4 +2367 @@
-	LOCK_TEST_WITH_RETURN(dev, filp);
-
-	DRM_COPY_FROM_USER_IOCTL(tex, (drm_radeon_texture_t __user *) data,
-				 sizeof(tex));
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
@@ -2395 +2369 @@
-	if (tex.image == NULL) {
+	if (tex->image == NULL) {
@@ -2397 +2371 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -2401 +2375 @@
-			       (drm_radeon_tex_image_t __user *) tex.image,
+			       (drm_radeon_tex_image_t __user *) tex->image,
@@ -2403 +2377 @@
-		return DRM_ERR(EFAULT);
+		return -EFAULT;
@@ -2408 +2382 @@
-	ret = radeon_cp_dispatch_texture(filp, dev, &tex, &image);
+	ret = radeon_cp_dispatch_texture(dev, file_priv, tex, &image);
@@ -2410 +2383,0 @@
-	COMMIT_RING();
@@ -2414 +2387 @@
-static int radeon_cp_stipple(DRM_IOCTL_ARGS)
+static int radeon_cp_stipple(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -2416 +2388,0 @@
-	DRM_DEVICE;
@@ -2418 +2390 @@
-	drm_radeon_stipple_t stipple;
+	drm_radeon_stipple_t *stipple = data;
@@ -2421,4 +2393 @@
-	LOCK_TEST_WITH_RETURN(dev, filp);
-
-	DRM_COPY_FROM_USER_IOCTL(stipple, (drm_radeon_stipple_t __user *) data,
-				 sizeof(stipple));
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
@@ -2426,2 +2395,2 @@
-	if (DRM_COPY_FROM_USER(&mask, stipple.mask, 32 * sizeof(u32)))
-		return DRM_ERR(EFAULT);
+	if (DRM_COPY_FROM_USER(&mask, stipple->mask, 32 * sizeof(u32)))
+		return -EFAULT;
@@ -2437 +2406 @@
-static int radeon_cp_indirect(DRM_IOCTL_ARGS)
+static int radeon_cp_indirect(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -2439 +2407,0 @@
-	DRM_DEVICE;
@@ -2443 +2411 @@
-	drm_radeon_indirect_t indirect;
+	drm_radeon_indirect_t *indirect = data;
@@ -2446,5 +2414 @@
-	LOCK_TEST_WITH_RETURN(dev, filp);
-
-	DRM_COPY_FROM_USER_IOCTL(indirect,
-				 (drm_radeon_indirect_t __user *) data,
-				 sizeof(indirect));
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
@@ -2453 +2417,2 @@
-		  indirect.idx, indirect.start, indirect.end, indirect.discard);
+		  indirect->idx, indirect->start, indirect->end,
+		  indirect->discard);
@@ -2455 +2420 @@
-	if (indirect.idx < 0 || indirect.idx >= dma->buf_count) {
+	if (indirect->idx < 0 || indirect->idx >= dma->buf_count) {
@@ -2457,2 +2422,2 @@
-			  indirect.idx, dma->buf_count - 1);
-		return DRM_ERR(EINVAL);
+			  indirect->idx, dma->buf_count - 1);
+		return -EINVAL;
@@ -2461 +2426 @@
-	buf = dma->buflist[indirect.idx];
+	buf = dma->buflist[indirect->idx];
@@ -2463 +2428 @@
-	if (buf->filp != filp) {
+	if (buf->file_priv != file_priv) {
@@ -2465,2 +2430,2 @@
-			  DRM_CURRENTPID, buf->filp);
-		return DRM_ERR(EINVAL);
+			  DRM_CURRENTPID, buf->file_priv);
+		return -EINVAL;
@@ -2469,2 +2434,2 @@
-		DRM_ERROR("sending pending buffer %d\n", indirect.idx);
-		return DRM_ERR(EINVAL);
+		DRM_ERROR("sending pending buffer %d\n", indirect->idx);
+		return -EINVAL;
@@ -2473 +2438 @@
-	if (indirect.start < buf->used) {
+	if (indirect->start < buf->used) {
@@ -2475,2 +2440,2 @@
-			  indirect.start, buf->used);
-		return DRM_ERR(EINVAL);
+			  indirect->start, buf->used);
+		return -EINVAL;
@@ -2482 +2447 @@
-	buf->used = indirect.end;
+	buf->used = indirect->end;
@@ -2497,2 +2462,2 @@
-	radeon_cp_dispatch_indirect(dev, buf, indirect.start, indirect.end);
-	if (indirect.discard) {
+	radeon_cp_dispatch_indirect(dev, buf, indirect->start, indirect->end);
+	if (indirect->discard) {
@@ -2506 +2471 @@
-static int radeon_cp_vertex2(DRM_IOCTL_ARGS)
+static int radeon_cp_vertex2(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -2508 +2472,0 @@
-	DRM_DEVICE;
@@ -2510 +2473,0 @@
-	struct drm_file *filp_priv;
@@ -2514 +2477 @@
-	drm_radeon_vertex2_t vertex;
+	drm_radeon_vertex2_t *vertex = data;
@@ -2518,6 +2481 @@
-	LOCK_TEST_WITH_RETURN(dev, filp);
-
-	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
-
-	DRM_COPY_FROM_USER_IOCTL(vertex, (drm_radeon_vertex2_t __user *) data,
-				 sizeof(vertex));
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
@@ -2526 +2484 @@
-		  DRM_CURRENTPID, vertex.idx, vertex.discard);
+		  DRM_CURRENTPID, vertex->idx, vertex->discard);
@@ -2528 +2486 @@
-	if (vertex.idx < 0 || vertex.idx >= dma->buf_count) {
+	if (vertex->idx < 0 || vertex->idx >= dma->buf_count) {
@@ -2530,2 +2488,2 @@
-			  vertex.idx, dma->buf_count - 1);
-		return DRM_ERR(EINVAL);
+			  vertex->idx, dma->buf_count - 1);
+		return -EINVAL;
@@ -2537 +2495 @@
-	buf = dma->buflist[vertex.idx];
+	buf = dma->buflist[vertex->idx];
@@ -2539 +2497 @@
-	if (buf->filp != filp) {
+	if (buf->file_priv != file_priv) {
@@ -2541,2 +2499,2 @@
-			  DRM_CURRENTPID, buf->filp);
-		return DRM_ERR(EINVAL);
+			  DRM_CURRENTPID, buf->file_priv);
+		return -EINVAL;
@@ -2546,2 +2504,2 @@
-		DRM_ERROR("sending pending buffer %d\n", vertex.idx);
-		return DRM_ERR(EINVAL);
+		DRM_ERROR("sending pending buffer %d\n", vertex->idx);
+		return -EINVAL;
@@ -2551 +2509 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -2553 +2511 @@
-	for (laststate = 0xff, i = 0; i < vertex.nr_prims; i++) {
+	for (laststate = 0xff, i = 0; i < vertex->nr_prims; i++) {
@@ -2557,2 +2515,2 @@
-		if (DRM_COPY_FROM_USER(&prim, &vertex.prim[i], sizeof(prim)))
-			return DRM_ERR(EFAULT);
+		if (DRM_COPY_FROM_USER(&prim, &vertex->prim[i], sizeof(prim)))
+			return -EFAULT;
@@ -2564 +2522 @@
-					       &vertex.state[prim.stateidx],
+					       &vertex->state[prim.stateidx],
@@ -2566 +2524 @@
-				return DRM_ERR(EFAULT);
+				return -EFAULT;
@@ -2568 +2526 @@
-			if (radeon_emit_state2(dev_priv, filp_priv, &state)) {
+			if (radeon_emit_state2(dev_priv, file_priv, &state)) {
@@ -2570 +2528 @@
-				return DRM_ERR(EINVAL);
+				return -EINVAL;
@@ -2597 +2555 @@
-	if (vertex.discard) {
+	if (vertex->discard) {
@@ -2606 +2564 @@
-			       struct drm_file * filp_priv,
+			       struct drm_file *file_priv,
@@ -2616 +2574 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -2623 +2581 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -2626 +2584 @@
-	if (radeon_check_and_fixup_packets(dev_priv, filp_priv, id, data)) {
+	if (radeon_check_and_fixup_packets(dev_priv, file_priv, id, data)) {
@@ -2628 +2586 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -2716 +2674 @@
-                return DRM_ERR(EINVAL);
+                return -EINVAL;
@@ -2732 +2690 @@
-			       struct drm_file * filp_priv,
+			       struct drm_file *file_priv,
@@ -2742 +2700 @@
-	if ((ret = radeon_check_and_fixup_packet3(dev_priv, filp_priv,
+	if ((ret = radeon_check_and_fixup_packet3(dev_priv, file_priv,
@@ -2758 +2716 @@
-					struct drm_file *filp_priv,
+					struct drm_file *file_priv,
@@ -2772 +2730 @@
-	if ((ret = radeon_check_and_fixup_packet3(dev_priv, filp_priv,
+	if ((ret = radeon_check_and_fixup_packet3(dev_priv, file_priv,
@@ -2784 +2742 @@
-				return DRM_ERR(EFAULT);
+				return -EFAULT;
@@ -2842 +2800 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -2848 +2806 @@
-static int radeon_cp_cmdbuf(DRM_IOCTL_ARGS)
+static int radeon_cp_cmdbuf(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -2850 +2807,0 @@
-	DRM_DEVICE;
@@ -2852 +2808,0 @@
-	struct drm_file *filp_priv;
@@ -2856 +2812 @@
-	drm_radeon_kcmd_buffer_t cmdbuf;
+	drm_radeon_kcmd_buffer_t *cmdbuf = data;
@@ -2861,7 +2817 @@
-	LOCK_TEST_WITH_RETURN(dev, filp);
-
-	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
-
-	DRM_COPY_FROM_USER_IOCTL(cmdbuf,
-				 (drm_radeon_cmd_buffer_t __user *) data,
-				 sizeof(cmdbuf));
+	LOCK_TEST_WITH_RETURN(dev, file_priv);
@@ -2872,2 +2822,2 @@
-	if (cmdbuf.bufsz > 64 * 1024 || cmdbuf.bufsz < 0) {
-		return DRM_ERR(EINVAL);
+	if (cmdbuf->bufsz > 64 * 1024 || cmdbuf->bufsz < 0) {
+		return -EINVAL;
@@ -2880 +2830 @@
-	orig_bufsz = cmdbuf.bufsz;
+	orig_bufsz = cmdbuf->bufsz;
@@ -2882 +2832 @@
-		kbuf = drm_alloc(cmdbuf.bufsz, DRM_MEM_DRIVER);
+		kbuf = drm_alloc(cmdbuf->bufsz, DRM_MEM_DRIVER);
@@ -2884,3 +2834,3 @@
-			return DRM_ERR(ENOMEM);
-		if (DRM_COPY_FROM_USER(kbuf, (void __user *)cmdbuf.buf,
-				       cmdbuf.bufsz)) {
+			return -ENOMEM;
+		if (DRM_COPY_FROM_USER(kbuf, (void __user *)cmdbuf->buf,
+				       cmdbuf->bufsz)) {
@@ -2888 +2838 @@
-			return DRM_ERR(EFAULT);
+			return -EFAULT;
@@ -2890 +2840 @@
-		cmdbuf.buf = kbuf;
+		cmdbuf->buf = kbuf;
@@ -2893 +2843 @@
-	orig_nbox = cmdbuf.nbox;
+	orig_nbox = cmdbuf->nbox;
@@ -2897 +2847 @@
-		temp = r300_do_cp_cmdbuf(dev, filp, filp_priv, &cmdbuf);
+		temp = r300_do_cp_cmdbuf(dev, file_priv, cmdbuf);
@@ -2906 +2856 @@
-	while (cmdbuf.bufsz >= sizeof(header)) {
+	while (cmdbuf->bufsz >= sizeof(header)) {
@@ -2908,3 +2858,3 @@
-		header.i = *(int *)cmdbuf.buf;
-		cmdbuf.buf += sizeof(header);
-		cmdbuf.bufsz -= sizeof(header);
+		header.i = *(int *)cmdbuf->buf;
+		cmdbuf->buf += sizeof(header);
+		cmdbuf->bufsz -= sizeof(header);
@@ -2916 +2866 @@
-			    (dev_priv, filp_priv, header, &cmdbuf)) {
+			    (dev_priv, file_priv, header, cmdbuf)) {
@@ -2924 +2874 @@
-			if (radeon_emit_scalars(dev_priv, header, &cmdbuf)) {
+			if (radeon_emit_scalars(dev_priv, header, cmdbuf)) {
@@ -2932 +2882 @@
-			if (radeon_emit_vectors(dev_priv, header, &cmdbuf)) {
+			if (radeon_emit_vectors(dev_priv, header, cmdbuf)) {
@@ -2948 +2898 @@
-			if (buf->filp != filp || buf->pending) {
+			if (buf->file_priv != file_priv || buf->pending) {
@@ -2950 +2900,2 @@
-					  buf->filp, filp, buf->pending);
+					  buf->file_priv, file_priv,
+					  buf->pending);
@@ -2959 +2910 @@
-			if (radeon_emit_packet3(dev, filp_priv, &cmdbuf)) {
+			if (radeon_emit_packet3(dev, file_priv, cmdbuf)) {
@@ -2968 +2919 @@
-			    (dev, filp_priv, &cmdbuf, orig_nbox)) {
+			    (dev, file_priv, cmdbuf, orig_nbox)) {
@@ -2976 +2927 @@
-			if (radeon_emit_scalars2(dev_priv, header, &cmdbuf)) {
+			if (radeon_emit_scalars2(dev_priv, header, cmdbuf)) {
@@ -2991 +2942 @@
-			if (radeon_emit_veclinear(dev_priv, header, &cmdbuf)) {
+			if (radeon_emit_veclinear(dev_priv, header, cmdbuf)) {
@@ -3000 +2951 @@
-				  cmdbuf.buf - sizeof(header));
+				  cmdbuf->buf - sizeof(header));
@@ -3015 +2966 @@
-	return DRM_ERR(EINVAL);
+	return -EINVAL;
@@ -3018 +2969 @@
-static int radeon_cp_getparam(DRM_IOCTL_ARGS)
+static int radeon_cp_getparam(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -3020 +2970,0 @@
-	DRM_DEVICE;
@@ -3022 +2972 @@
-	drm_radeon_getparam_t param;
+	drm_radeon_getparam_t *param = data;
@@ -3025,3 +2974,0 @@
-	DRM_COPY_FROM_USER_IOCTL(param, (drm_radeon_getparam_t __user *) data,
-				 sizeof(param));
-
@@ -3030 +2977 @@
-	switch (param.param) {
+	switch (param->param) {
@@ -3061 +3008 @@
-		 * Michel Dnzer, the ioctl() is only used on embedded platforms, so
+		 * Michel Dnzer, the ioctl() is only used on embedded platforms, so
@@ -3077 +3024 @@
-			return DRM_ERR(EINVAL);
+			return -EINVAL;
@@ -3092,2 +3039,2 @@
-		DRM_DEBUG("Invalid parameter %d\n", param.param);
-		return DRM_ERR(EINVAL);
+		DRM_DEBUG("Invalid parameter %d\n", param->param);
+		return -EINVAL;
@@ -3096 +3043 @@
-	if (DRM_COPY_TO_USER(param.value, &value, sizeof(int))) {
+	if (DRM_COPY_TO_USER(param->value, &value, sizeof(int))) {
@@ -3098 +3045 @@
-		return DRM_ERR(EFAULT);
+		return -EFAULT;
@@ -3104 +3051 @@
-static int radeon_cp_setparam(DRM_IOCTL_ARGS)
+static int radeon_cp_setparam(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -3106 +3052,0 @@
-	DRM_DEVICE;
@@ -3108,2 +3054 @@
-	struct drm_file *filp_priv;
-	drm_radeon_setparam_t sp;
+	drm_radeon_setparam_t *sp = data;
@@ -3112,6 +3057 @@
-	DRM_GET_PRIV_WITH_RETURN(filp_priv, filp);
-
-	DRM_COPY_FROM_USER_IOCTL(sp, (drm_radeon_setparam_t __user *) data,
-				 sizeof(sp));
-
-	switch (sp.param) {
+	switch (sp->param) {
@@ -3119,2 +3059,3 @@
-		radeon_priv = filp_priv->driver_priv;
-		radeon_priv->radeon_fb_delta = dev_priv->fb_location - sp.value;
+		radeon_priv = file_priv->driver_priv;
+		radeon_priv->radeon_fb_delta = dev_priv->fb_location -
+		    sp->value;
@@ -3123 +3064 @@
-		if (sp.value == 0) {
+		if (sp->value == 0) {
@@ -3128 +3069 @@
-		} else if (sp.value == 1) {
+		} else if (sp->value == 1) {
@@ -3136 +3077 @@
-		dev_priv->pcigart_offset = sp.value;
+		dev_priv->pcigart_offset = sp->value;
@@ -3140 +3081 @@
-		dev_priv->new_memmap = sp.value;
+		dev_priv->new_memmap = sp->value;
@@ -3143 +3084 @@
-		dev_priv->gart_info.table_size = sp.value;
+		dev_priv->gart_info.table_size = sp->value;
@@ -3148 +3089 @@
-		return radeon_vblank_crtc_set(dev, sp.value);
+		return radeon_vblank_crtc_set(dev, sp->value);
@@ -3151,2 +3092,2 @@
-		DRM_DEBUG("Invalid parameter %d\n", sp.param);
-		return DRM_ERR(EINVAL);
+		DRM_DEBUG("Invalid parameter %d\n", sp->param);
+		return -EINVAL;
@@ -3165 +3106 @@
-void radeon_driver_preclose(struct drm_device *dev, DRMFILE filp)
+void radeon_driver_preclose(struct drm_device *dev, struct drm_file *file_priv)
@@ -3170,3 +3111,3 @@
-		radeon_mem_release(filp, dev_priv->gart_heap);
-		radeon_mem_release(filp, dev_priv->fb_heap);
-		radeon_surfaces_release(filp, dev_priv);
+		radeon_mem_release(file_priv, dev_priv->gart_heap);
+		radeon_mem_release(file_priv, dev_priv->fb_heap);
+		radeon_surfaces_release(file_priv, dev_priv);
@@ -3189 +3130 @@
-int radeon_driver_open(struct drm_device *dev, struct drm_file *filp_priv)
+int radeon_driver_open(struct drm_device *dev, struct drm_file *file_priv)
@@ -3202 +3143 @@
-	filp_priv->driver_priv = radeon_priv;
+	file_priv->driver_priv = radeon_priv;
@@ -3211 +3152 @@
-void radeon_driver_postclose(struct drm_device *dev, struct drm_file *filp_priv)
+void radeon_driver_postclose(struct drm_device *dev, struct drm_file *file_priv)
@@ -3214 +3155 @@
-	    filp_priv->driver_priv;
+	    file_priv->driver_priv;
@@ -3219,28 +3160,28 @@
-drm_ioctl_desc_t radeon_ioctls[] = {
-	[DRM_IOCTL_NR(DRM_RADEON_CP_INIT)] = {radeon_cp_init, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY},
-	[DRM_IOCTL_NR(DRM_RADEON_CP_START)] = {radeon_cp_start, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY},
-	[DRM_IOCTL_NR(DRM_RADEON_CP_STOP)] = {radeon_cp_stop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY},
-	[DRM_IOCTL_NR(DRM_RADEON_CP_RESET)] = {radeon_cp_reset, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY},
-	[DRM_IOCTL_NR(DRM_RADEON_CP_IDLE)] = {radeon_cp_idle, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_CP_RESUME)] = {radeon_cp_resume, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_RESET)] = {radeon_engine_reset, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_FULLSCREEN)] = {radeon_fullscreen, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_SWAP)] = {radeon_cp_swap, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_CLEAR)] = {radeon_cp_clear, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_VERTEX)] = {radeon_cp_vertex, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_INDICES)] = {radeon_cp_indices, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_TEXTURE)] = {radeon_cp_texture, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_STIPPLE)] = {radeon_cp_stipple, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_INDIRECT)] = {radeon_cp_indirect, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY},
-	[DRM_IOCTL_NR(DRM_RADEON_VERTEX2)] = {radeon_cp_vertex2, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_CMDBUF)] = {radeon_cp_cmdbuf, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_GETPARAM)] = {radeon_cp_getparam, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_FLIP)] = {radeon_cp_flip, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_ALLOC)] = {radeon_mem_alloc, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_FREE)] = {radeon_mem_free, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_INIT_HEAP)] = {radeon_mem_init_heap, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY},
-	[DRM_IOCTL_NR(DRM_RADEON_IRQ_EMIT)] = {radeon_irq_emit, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_IRQ_WAIT)] = {radeon_irq_wait, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_SETPARAM)] = {radeon_cp_setparam, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_SURF_ALLOC)] = {radeon_surface_alloc, DRM_AUTH},
-	[DRM_IOCTL_NR(DRM_RADEON_SURF_FREE)] = {radeon_surface_free, DRM_AUTH}
+struct drm_ioctl_desc radeon_ioctls[] = {
+	DRM_IOCTL_DEF(DRM_RADEON_CP_INIT, radeon_cp_init, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_RADEON_CP_START, radeon_cp_start, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_RADEON_CP_STOP, radeon_cp_stop, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_RADEON_CP_RESET, radeon_cp_reset, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_RADEON_CP_IDLE, radeon_cp_idle, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_CP_RESUME, radeon_cp_resume, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_RESET, radeon_engine_reset, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_FULLSCREEN, radeon_fullscreen, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_SWAP, radeon_cp_swap, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_CLEAR, radeon_cp_clear, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_VERTEX, radeon_cp_vertex, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_INDICES, radeon_cp_indices, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_TEXTURE, radeon_cp_texture, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_STIPPLE, radeon_cp_stipple, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_INDIRECT, radeon_cp_indirect, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_RADEON_VERTEX2, radeon_cp_vertex2, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_CMDBUF, radeon_cp_cmdbuf, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_GETPARAM, radeon_cp_getparam, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_FLIP, radeon_cp_flip, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_ALLOC, radeon_mem_alloc, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_FREE, radeon_mem_free, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_INIT_HEAP, radeon_mem_init_heap, DRM_AUTH|DRM_MASTER|DRM_ROOT_ONLY),
+	DRM_IOCTL_DEF(DRM_RADEON_IRQ_EMIT, radeon_irq_emit, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_IRQ_WAIT, radeon_irq_wait, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_SETPARAM, radeon_cp_setparam, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_SURF_ALLOC, radeon_surface_alloc, DRM_AUTH),
+	DRM_IOCTL_DEF(DRM_RADEON_SURF_FREE, radeon_surface_free, DRM_AUTH)
--- ./projects/linux/linux-2.6.24/drivers/char/drm/radeon_state.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/drm/radeon_state.c	2008-04-17 04:49:44.000000000 +0200
@@ -901 +901 @@
-			DRM_DEBUG("dispatch clear %d,%d-%d,%d flags 0x%x\n",
+			DRM_DEBUG("%d,%d-%d,%d flags 0x%x\n",
@@ -1371 +1371 @@
-		DRM_DEBUG("dispatch swap %d,%d-%d,%d\n", x, y, w, h);
+		DRM_DEBUG("%d,%d-%d,%d\n", x, y, w, h);
@@ -1425,2 +1425 @@
-	DRM_DEBUG("%s: pfCurrentPage=%d\n",
-		  __FUNCTION__,
+	DRM_DEBUG("pfCurrentPage=%d\n",
@@ -1565 +1564 @@
-	DRM_DEBUG("indirect: buf=%d s=0x%x e=0x%x\n", buf->idx, start, end);
+	DRM_DEBUG("buf=%d s=0x%x e=0x%x\n", buf->idx, start, end);
@@ -1761 +1760 @@
-			DRM_DEBUG("radeon_cp_dispatch_texture: EAGAIN\n");
+			DRM_DEBUG("EAGAIN\n");
@@ -2416 +2415 @@
-	DRM_DEBUG("indirect: idx=%d s=%d e=%d d=%d\n",
+	DRM_DEBUG("idx=%d s=%d e=%d d=%d\n",
@@ -2782 +2781 @@
-	DRM_DEBUG("%s: %x\n", __FUNCTION__, flags);
+	DRM_DEBUG("%x\n", flags);
@@ -3037,0 +3037,3 @@
+	case RADEON_PARAM_FB_LOCATION:
+		value = radeon_read_fb_location(dev_priv);
+		break;
--- ./projects/linux/linux-2.6.25/drivers/char/drm/radeon_state.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/drm/radeon_state.c	2008-07-13 23:51:29.000000000 +0200
@@ -1665 +1665 @@
-	u32 offset;
+	u32 offset, byte_offset;
@@ -1729,0 +1730,7 @@
+	/* this might fail for zero-sized uploads - are those illegal? */
+	if (!radeon_check_offset(dev_priv, tex->offset + image->height *
+				blit_width - 1)) {
+		DRM_ERROR("Invalid final destination offset\n");
+		return -EINVAL;
+	}
+
@@ -1842,0 +1850 @@
+		byte_offset = (image->y & ~2047) * blit_width;
@@ -1857 +1865 @@
-		OUT_RING((texpitch << 22) | (tex->offset >> 10));
+		OUT_RING((texpitch << 22) | ((tex->offset >> 10) + (byte_offset >> 10)));
@@ -1859 +1867 @@
-		OUT_RING((image->x << 16) | image->y);
+		OUT_RING((image->x << 16) | (image->y % 2048));
@@ -3039,0 +3048,3 @@
+	case RADEON_PARAM_NUM_GB_PIPES:
+		value = dev_priv->num_gb_pipes;
+		break;
--- ./projects/linux/linux-2.6.14/drivers/char/drm/via_irq.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/char/drm/via_irq.c	2006-01-03 04:21:10.000000000 +0100
@@ -57 +57 @@
- * Currently we activate the HQV interrupts of  Unichrome Pro group A. 
+ * Currently we activate the HQV interrupts of  Unichrome Pro group A.
@@ -61,3 +61,7 @@
-	{VIA_IRQ_HQV0_ENABLE, VIA_IRQ_HQV0_PENDING, 0x000003D0, 0x00008010, 0x00000000 },
-	{VIA_IRQ_HQV1_ENABLE, VIA_IRQ_HQV1_PENDING, 0x000013D0, 0x00008010, 0x00000000 }};
-static int via_num_pro_group_a = sizeof(via_pro_group_a_irqs)/sizeof(maskarray_t);
+	{VIA_IRQ_HQV0_ENABLE, VIA_IRQ_HQV0_PENDING, 0x000003D0, 0x00008010,
+	 0x00000000},
+	{VIA_IRQ_HQV1_ENABLE, VIA_IRQ_HQV1_PENDING, 0x000013D0, 0x00008010,
+	 0x00000000}
+};
+static int via_num_pro_group_a =
+    sizeof(via_pro_group_a_irqs) / sizeof(maskarray_t);
@@ -65,2 +69,2 @@
-static maskarray_t via_unichrome_irqs[] = {};
-static int via_num_unichrome = sizeof(via_unichrome_irqs)/sizeof(maskarray_t);
+static maskarray_t via_unichrome_irqs[] = { };
+static int via_num_unichrome = sizeof(via_unichrome_irqs) / sizeof(maskarray_t);
@@ -68,2 +72 @@
-
-static unsigned time_diff(struct timeval *now,struct timeval *then) 
+static unsigned time_diff(struct timeval *now, struct timeval *then)
@@ -71,3 +74,3 @@
-    return (now->tv_usec >= then->tv_usec) ?
-        now->tv_usec - then->tv_usec :
-        1000000 - (then->tv_usec - now->tv_usec);
+	return (now->tv_usec >= then->tv_usec) ?
+	    now->tv_usec - then->tv_usec :
+	    1000000 - (then->tv_usec - now->tv_usec);
@@ -89 +92 @@
-                if (!(atomic_read(&dev->vbl_received) & 0x0F)) {
+		if (!(atomic_read(&dev->vbl_received) & 0x0F)) {
@@ -91,3 +94,4 @@
-                        if (dev_priv->last_vblank_valid) {
-				dev_priv->usec_per_vblank = 
-					time_diff( &cur_vblank,&dev_priv->last_vblank) >> 4;
+			if (dev_priv->last_vblank_valid) {
+				dev_priv->usec_per_vblank =
+				    time_diff(&cur_vblank,
+					      &dev_priv->last_vblank) >> 4;
@@ -97,2 +101,2 @@
-                }
-                if (!(atomic_read(&dev->vbl_received) & 0xFF)) {
+		}
+		if (!(atomic_read(&dev->vbl_received) & 0xFF)) {
@@ -100 +104 @@
-				dev_priv->usec_per_vblank);
+				  dev_priv->usec_per_vblank);
@@ -106 +109,0 @@
-	
@@ -108 +111 @@
-	for (i=0; i<dev_priv->num_irqs; ++i) {
+	for (i = 0; i < dev_priv->num_irqs; ++i) {
@@ -110,2 +113,2 @@
-			atomic_inc( &cur_irq->irq_received );
-			DRM_WAKEUP( &cur_irq->irq_queue );
+			atomic_inc(&cur_irq->irq_received);
+			DRM_WAKEUP(&cur_irq->irq_queue);
@@ -116 +119 @@
-	
+
@@ -120 +122,0 @@
-
@@ -134 +136 @@
-		VIA_WRITE(VIA_REG_INTERRUPT, status | 
+		VIA_WRITE(VIA_REG_INTERRUPT, status |
@@ -161 +163 @@
-	
+
@@ -166 +168 @@
-static int 
+static int
@@ -183,2 +185,3 @@
-	if (irq >= dev_priv->num_irqs ) {
-		DRM_ERROR("%s Trying to wait on unknown irq %d\n", __FUNCTION__, irq);
+	if (irq >= dev_priv->num_irqs) {
+		DRM_ERROR("%s Trying to wait on unknown irq %d\n", __FUNCTION__,
+			  irq);
@@ -187 +190 @@
-		
+
@@ -192 +195,2 @@
-			    ((VIA_READ(masks[irq][2]) & masks[irq][3]) == masks[irq][4]));
+			    ((VIA_READ(masks[irq][2]) & masks[irq][3]) ==
+			     masks[irq][4]));
@@ -196,2 +200,3 @@
-			    (((cur_irq_sequence = atomic_read(&cur_irq->irq_received)) -
-			      *sequence) <= (1 << 23)));		
+			    (((cur_irq_sequence =
+			       atomic_read(&cur_irq->irq_received)) -
+			      *sequence) <= (1 << 23)));
@@ -203 +207,0 @@
-
@@ -222 +226 @@
-			via_pro_group_a_irqs : via_unichrome_irqs;
+		    via_pro_group_a_irqs : via_unichrome_irqs;
@@ -224,3 +228,3 @@
-			via_num_pro_group_a : via_num_unichrome;
-		
-		for(i=0; i < dev_priv->num_irqs; ++i) {
+		    via_num_pro_group_a : via_num_unichrome;
+
+		for (i = 0; i < dev_priv->num_irqs; ++i) {
@@ -228 +232 @@
-			cur_irq->enable_mask = dev_priv->irq_masks[i][0]; 
+			cur_irq->enable_mask = dev_priv->irq_masks[i][0];
@@ -230 +234 @@
-			DRM_INIT_WAITQUEUE( &cur_irq->irq_queue );
+			DRM_INIT_WAITQUEUE(&cur_irq->irq_queue);
@@ -234 +238 @@
-			
+
@@ -237,2 +241,2 @@
-			
-	        dev_priv->last_vblank_valid = 0;
+
+		dev_priv->last_vblank_valid = 0;
@@ -242 +246 @@
-		VIA_WRITE(VIA_REG_INTERRUPT, status & 
+		VIA_WRITE(VIA_REG_INTERRUPT, status &
@@ -244 +248 @@
-		
+
@@ -265 +269 @@
-		
+
@@ -283 +287 @@
-		VIA_WRITE(VIA_REG_INTERRUPT, status & 
+		VIA_WRITE(VIA_REG_INTERRUPT, status &
@@ -305 +309 @@
-		DRM_ERROR("%s Trying to wait on unknown irq %d\n", __FUNCTION__, 
+		DRM_ERROR("%s Trying to wait on unknown irq %d\n", __FUNCTION__,
@@ -323 +327 @@
-		DRM_ERROR("%s Signals on Via IRQs not implemented yet.\n", 
+		DRM_ERROR("%s Signals on Via IRQs not implemented yet.\n",
--- ./projects/linux/linux-2.6.15/drivers/char/drm/via_irq.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/drm/via_irq.c	2006-03-20 06:53:29.000000000 +0100
@@ -52,0 +53,9 @@
+#define VIA_IRQ_DMA0_DD_ENABLE  (1 << 20)
+#define VIA_IRQ_DMA0_TD_ENABLE  (1 << 21)
+#define VIA_IRQ_DMA1_DD_ENABLE  (1 << 22)
+#define VIA_IRQ_DMA1_TD_ENABLE  (1 << 23)
+#define VIA_IRQ_DMA0_DD_PENDING (1 << 4)
+#define VIA_IRQ_DMA0_TD_PENDING (1 << 5)
+#define VIA_IRQ_DMA1_DD_PENDING (1 << 6)
+#define VIA_IRQ_DMA1_TD_PENDING (1 << 7)
+
@@ -64 +73,5 @@
-	 0x00000000}
+	 0x00000000},
+	{VIA_IRQ_DMA0_TD_ENABLE, VIA_IRQ_DMA0_TD_PENDING, VIA_PCI_DMA_CSR0,
+	 VIA_DMA_CSR_TA | VIA_DMA_CSR_TD, 0x00000008},
+	{VIA_IRQ_DMA1_TD_ENABLE, VIA_IRQ_DMA1_TD_PENDING, VIA_PCI_DMA_CSR1,
+	 VIA_DMA_CSR_TA | VIA_DMA_CSR_TD, 0x00000008},
@@ -67,0 +81 @@
+static int via_irqmap_pro_group_a[] = {0, 1, -1, 2, -1, 3};
@@ -69 +83,6 @@
-static maskarray_t via_unichrome_irqs[] = { };
+static maskarray_t via_unichrome_irqs[] = {
+	{VIA_IRQ_DMA0_TD_ENABLE, VIA_IRQ_DMA0_TD_PENDING, VIA_PCI_DMA_CSR0,
+	 VIA_DMA_CSR_TA | VIA_DMA_CSR_TD, 0x00000008},
+	{VIA_IRQ_DMA1_TD_ENABLE, VIA_IRQ_DMA1_TD_PENDING, VIA_PCI_DMA_CSR1,
+	 VIA_DMA_CSR_TA | VIA_DMA_CSR_TD, 0x00000008}
+};
@@ -70,0 +90 @@
+static int via_irqmap_unichrome[] = {-1, -1, -1, 0, -1, 1};
@@ -115,0 +136,5 @@
+			if (dev_priv->irq_map[drm_via_irq_dma0_td] == i) {
+				via_dmablit_handler(dev, 0, 1);
+			} else if (dev_priv->irq_map[drm_via_irq_dma1_td] == i) {
+				via_dmablit_handler(dev, 1, 1);
+			}
@@ -176,0 +202 @@
+	int real_irq;
@@ -185 +211 @@
-	if (irq >= dev_priv->num_irqs) {
+	if (irq >= drm_via_irq_num) {
@@ -191 +217,9 @@
-	cur_irq += irq;
+	real_irq = dev_priv->irq_map[irq];
+
+	if (real_irq < 0) {
+		DRM_ERROR("%s Video IRQ %d not available on this hardware.\n",
+			  __FUNCTION__, irq);
+		return DRM_ERR(EINVAL);
+	}
+	
+	cur_irq += real_irq;
@@ -193 +227 @@
-	if (masks[irq][2] && !force_sequence) {
+	if (masks[real_irq][2] && !force_sequence) {
@@ -228,0 +263,2 @@
+		dev_priv->irq_map = (dev_priv->pro_group_a) ?
+			via_irqmap_pro_group_a : via_irqmap_unichrome;
@@ -244 +280 @@
-		// Clear VSync interrupt regs
+		/* Clear VSync interrupt regs */
@@ -294,2 +330 @@
-	drm_file_t *priv = filp->private_data;
-	drm_device_t *dev = priv->head->dev;
+	DRM_DEVICE;
--- ./projects/linux/linux-2.6.16/drivers/char/drm/via_irq.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/char/drm/via_irq.c	2006-06-18 03:49:35.000000000 +0200
@@ -199 +199 @@
-	drm_via_irq_t *cur_irq = dev_priv->via_irqs;
+	drm_via_irq_t *cur_irq;
@@ -201 +201 @@
-	maskarray_t *masks = dev_priv->irq_masks;
+	maskarray_t *masks;
@@ -224,2 +224,3 @@
-	
-	cur_irq += real_irq;
+
+	masks = dev_priv->irq_masks;
+	cur_irq = dev_priv->via_irqs + real_irq;
@@ -250 +251 @@
-	drm_via_irq_t *cur_irq = dev_priv->via_irqs;
+	drm_via_irq_t *cur_irq;
@@ -254,0 +256 @@
+		cur_irq = dev_priv->via_irqs;
--- ./projects/linux/linux-2.6.20/drivers/char/drm/via_irq.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/drm/via_irq.c	2007-04-26 05:08:32.000000000 +0200
@@ -261,6 +261,10 @@
-		dev_priv->irq_masks = (dev_priv->pro_group_a) ?
-		    via_pro_group_a_irqs : via_unichrome_irqs;
-		dev_priv->num_irqs = (dev_priv->pro_group_a) ?
-		    via_num_pro_group_a : via_num_unichrome;
-		dev_priv->irq_map = (dev_priv->pro_group_a) ?
-			via_irqmap_pro_group_a : via_irqmap_unichrome;
+		if (dev_priv->chipset == VIA_PRO_GROUP_A ||
+		    dev_priv->chipset == VIA_DX9_0) {
+			dev_priv->irq_masks = via_pro_group_a_irqs;
+			dev_priv->num_irqs = via_num_pro_group_a;
+			dev_priv->irq_map = via_irqmap_pro_group_a;
+		} else {
+			dev_priv->irq_masks = via_unichrome_irqs;
+			dev_priv->num_irqs = via_num_unichrome;
+			dev_priv->irq_map = via_irqmap_unichrome;
+		}
--- ./projects/linux/linux-2.6.22/drivers/char/drm/via_irq.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/drm/via_irq.c	2007-10-09 22:31:38.000000000 +0200
@@ -101 +101 @@
-	drm_device_t *dev = (drm_device_t *) arg;
+	struct drm_device *dev = (struct drm_device *) arg;
@@ -166 +166 @@
-int via_driver_vblank_wait(drm_device_t * dev, unsigned int *sequence)
+int via_driver_vblank_wait(struct drm_device * dev, unsigned int *sequence)
@@ -194 +194 @@
-via_driver_irq_wait(drm_device_t * dev, unsigned int irq, int force_sequence,
+via_driver_irq_wait(struct drm_device * dev, unsigned int irq, int force_sequence,
@@ -247 +247 @@
-void via_driver_irq_preinstall(drm_device_t * dev)
+void via_driver_irq_preinstall(struct drm_device * dev)
@@ -296 +296 @@
-void via_driver_irq_postinstall(drm_device_t * dev)
+void via_driver_irq_postinstall(struct drm_device * dev)
@@ -315 +315 @@
-void via_driver_irq_uninstall(drm_device_t * dev)
+void via_driver_irq_uninstall(struct drm_device * dev)
--- ./projects/linux/linux-2.6.23/drivers/char/drm/via_irq.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/drm/via_irq.c	2008-01-24 23:58:37.000000000 +0100
@@ -208 +208 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -214 +214 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -222 +222 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -334 +334 @@
-int via_wait_irq(DRM_IOCTL_ARGS)
+int via_wait_irq(struct drm_device *dev, void *data, struct drm_file *file_priv)
@@ -336,3 +336 @@
-	DRM_DEVICE;
-	drm_via_irqwait_t __user *argp = (void __user *)data;
-	drm_via_irqwait_t irqwait;
+	drm_via_irqwait_t *irqwait = data;
@@ -346 +344 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -348,2 +346 @@
-	DRM_COPY_FROM_USER_IOCTL(irqwait, argp, sizeof(irqwait));
-	if (irqwait.request.irq >= dev_priv->num_irqs) {
+	if (irqwait->request.irq >= dev_priv->num_irqs) {
@@ -351,2 +348,2 @@
-			  irqwait.request.irq);
-		return DRM_ERR(EINVAL);
+			  irqwait->request.irq);
+		return -EINVAL;
@@ -355 +352 @@
-	cur_irq += irqwait.request.irq;
+	cur_irq += irqwait->request.irq;
@@ -357 +354 @@
-	switch (irqwait.request.type & ~VIA_IRQ_FLAGS_MASK) {
+	switch (irqwait->request.type & ~VIA_IRQ_FLAGS_MASK) {
@@ -359,2 +356,2 @@
-		irqwait.request.sequence += atomic_read(&cur_irq->irq_received);
-		irqwait.request.type &= ~_DRM_VBLANK_RELATIVE;
+		irqwait->request.sequence += atomic_read(&cur_irq->irq_received);
+		irqwait->request.type &= ~_DRM_VBLANK_RELATIVE;
@@ -364 +361 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -367 +364 @@
-	if (irqwait.request.type & VIA_IRQ_SIGNAL) {
+	if (irqwait->request.type & VIA_IRQ_SIGNAL) {
@@ -370 +367 @@
-		return DRM_ERR(EINVAL);
+		return -EINVAL;
@@ -373 +370 @@
-	force_sequence = (irqwait.request.type & VIA_IRQ_FORCE_SEQUENCE);
+	force_sequence = (irqwait->request.type & VIA_IRQ_FORCE_SEQUENCE);
@@ -375,2 +372,2 @@
-	ret = via_driver_irq_wait(dev, irqwait.request.irq, force_sequence,
-				  &irqwait.request.sequence);
+	ret = via_driver_irq_wait(dev, irqwait->request.irq, force_sequence,
+				  &irqwait->request.sequence);
@@ -378,4 +375,2 @@
-	irqwait.reply.tval_sec = now.tv_sec;
-	irqwait.reply.tval_usec = now.tv_usec;
-
-	DRM_COPY_TO_USER_IOCTL(argp, irqwait, sizeof(irqwait));
+	irqwait->reply.tval_sec = now.tv_sec;
+	irqwait->reply.tval_usec = now.tv_usec;
--- ./projects/linux/linux-2.6.24/drivers/char/drm/via_irq.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/drm/via_irq.c	2008-04-17 04:49:44.000000000 +0200
@@ -172 +172 @@
-	DRM_DEBUG("viadrv_vblank_wait\n");
+	DRM_DEBUG("\n");
@@ -174 +174 @@
-		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		DRM_ERROR("called with no initialization\n");
@@ -204 +204 @@
-	DRM_DEBUG("%s\n", __FUNCTION__);
+	DRM_DEBUG("\n");
@@ -207 +207 @@
-		DRM_ERROR("%s called with no initialization\n", __FUNCTION__);
+		DRM_ERROR("called with no initialization\n");
@@ -212,2 +212 @@
-		DRM_ERROR("%s Trying to wait on unknown irq %d\n", __FUNCTION__,
-			  irq);
+		DRM_ERROR("Trying to wait on unknown irq %d\n", irq);
@@ -220,2 +219,2 @@
-		DRM_ERROR("%s Video IRQ %d not available on this hardware.\n",
-			  __FUNCTION__, irq);
+		DRM_ERROR("Video IRQ %d not available on this hardware.\n",
+			  irq);
@@ -254 +253 @@
-	DRM_DEBUG("driver_irq_preinstall: dev_priv: %p\n", dev_priv);
+	DRM_DEBUG("dev_priv: %p\n", dev_priv);
@@ -301 +300 @@
-	DRM_DEBUG("via_driver_irq_postinstall\n");
+	DRM_DEBUG("\n");
@@ -320 +319 @@
-	DRM_DEBUG("driver_irq_uninstall)\n");
+	DRM_DEBUG("\n");
@@ -347 +346 @@
-		DRM_ERROR("%s Trying to wait on unknown irq %d\n", __FUNCTION__,
+		DRM_ERROR("Trying to wait on unknown irq %d\n",
@@ -365,2 +364 @@
-		DRM_ERROR("%s Signals on Via IRQs not implemented yet.\n",
-			  __FUNCTION__);
+		DRM_ERROR("Signals on Via IRQs not implemented yet.\n");
--- ./projects/linux/linux-2.6.15/drivers/char/esp.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/esp.c	2006-03-20 06:53:29.000000000 +0100
@@ -153,12 +152,0 @@
-/*
- * tmp_buf is used as a temporary buffer by serial_write.  We need to
- * lock it in case the memcpy_fromfs blocks while swapping in a page,
- * and some other program tries to do a serial write at the same time.
- * Since the lock will only come under contention when the system is
- * swapping and available memory is low, it makes sense to share one
- * buffer across all the serial ports, since it significantly saves
- * memory if large numbers of serial ports are open.
- */
-static unsigned char *tmp_buf;
-static DECLARE_MUTEX(tmp_buf_sem);
-
@@ -348 +336 @@
-			*(tty->flip.char_buf_ptr++) = pio_buf->data[i];
+			int flag = 0;
@@ -351,2 +339 @@
-				*(tty->flip.flag_buf_ptr++) = TTY_BREAK;
-
+				flag = TTY_BREAK;
@@ -357 +344 @@
-				*(tty->flip.flag_buf_ptr++) = TTY_FRAME;
+				flag = TTY_FRAME;
@@ -359,5 +346,2 @@
-				*(tty->flip.flag_buf_ptr++) = TTY_PARITY;
-			else
-				*(tty->flip.flag_buf_ptr++) = 0;
-		
-			tty->flip.count++;
+				flag = TTY_PARITY;
+			tty_insert_flip_char(tty, pio_buf->data[i], flag);
@@ -367 +351 @@
-	schedule_delayed_work(&tty->flip.work, 1);
+	tty_schedule_flip(tty);
@@ -400 +383,0 @@
-	
@@ -411,6 +393,0 @@
-	memcpy(tty->flip.char_buf_ptr, dma_buffer, num_bytes);
-	tty->flip.char_buf_ptr += num_bytes;
-	tty->flip.count += num_bytes;
-	memset(tty->flip.flag_buf_ptr, 0, num_bytes);
-	tty->flip.flag_buf_ptr += num_bytes;
-
@@ -418 +395 @@
-		tty->flip.flag_buf_ptr--;
+		tty_insert_flip_string(tty, dma_buffer, num_bytes - 1);
@@ -421,20 +397,0 @@
-
-		if (status & info->ignore_status_mask) {
-			tty->flip.count--;
-			tty->flip.char_buf_ptr--;
-			tty->flip.flag_buf_ptr--;
-		} else if (status & 0x10) {
-			*tty->flip.flag_buf_ptr = TTY_BREAK;
-			(info->icount.brk)++;
-			if (info->flags & ASYNC_SAK)
-				do_SAK(tty);
-		} else if (status & 0x08) {
-			*tty->flip.flag_buf_ptr = TTY_FRAME;
-			(info->icount.frame)++;
-		}
-		else if (status & 0x04) {
-			*tty->flip.flag_buf_ptr = TTY_PARITY;
-			(info->icount.parity)++;
-		}
-
-		tty->flip.flag_buf_ptr++;
@@ -442 +399,20 @@
-		schedule_delayed_work(&tty->flip.work, 1);
+		/* Is the status significant or do we throw the last byte ? */
+		if (!(status & info->ignore_status_mask)) {
+			int statflag = 0;
+
+			if (status & 0x10) {
+				statflag = TTY_BREAK;
+				(info->icount.brk)++;
+				if (info->flags & ASYNC_SAK)
+					do_SAK(tty);
+			} else if (status & 0x08) {
+				statflag = TTY_FRAME;
+				(info->icount.frame)++;
+			}
+			else if (status & 0x04) {
+				statflag = TTY_PARITY;
+				(info->icount.parity)++;
+			}
+			tty_insert_flip_char(tty, dma_buffer[num_bytes - 1], statflag);
+		}
+		tty_schedule_flip(tty);
@@ -696,2 +672 @@
-		if (num_bytes > (TTY_FLIPBUF_SIZE - info->tty->flip.count))
-		  num_bytes = TTY_FLIPBUF_SIZE - info->tty->flip.count;
+		num_bytes = tty_buffer_request_room(info->tty, num_bytes);
@@ -1284 +1259 @@
-	if (!tty || !info->xmit_buf || !tmp_buf)
+	if (!tty || !info->xmit_buf)
@@ -2308,5 +2283 @@
-	if (!tmp_buf) {
-		tmp_buf = (unsigned char *) get_zeroed_page(GFP_KERNEL);
-		if (!tmp_buf)
-			return -ENOMEM;
-	}
+	spin_unlock_irqrestore(&info->lock, flags);
@@ -2508,0 +2480 @@
+	spin_lock_init(&info->lock);
@@ -2545 +2516,0 @@
-		spin_lock_init(&info->lock);
@@ -2619,3 +2589,0 @@
-	if (tmp_buf)
-		free_page((unsigned long)tmp_buf);
-
--- ./projects/linux/linux-2.6.17/drivers/char/esp.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/esp.c	2006-09-20 05:42:06.000000000 +0200
@@ -886 +886 @@
-	retval = request_irq(info->irq, rs_interrupt_single, SA_SHIRQ,
+	retval = request_irq(info->irq, rs_interrupt_single, IRQF_SHARED,
@@ -1215 +1215 @@
-	if (!tty || !info->xmit_buf)
+	if (!info->xmit_buf)
@@ -1259 +1259 @@
-	if (!tty || !info->xmit_buf)
+	if (!info->xmit_buf)
@@ -2452 +2451,0 @@
-	esp_driver->devfs_name = "tts/P";
--- ./projects/linux/linux-2.6.18/drivers/char/esp.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/esp.c	2006-11-29 22:57:37.000000000 +0100
@@ -618,2 +618 @@
-static irqreturn_t rs_interrupt_single(int irq, void *dev_id,
-					struct pt_regs *regs)
+static irqreturn_t rs_interrupt_single(int irq, void *dev_id)
@@ -2379 +2378 @@
-static struct tty_operations esp_ops = {
+static const struct tty_operations esp_ops = {
--- ./projects/linux/linux-2.6.19/drivers/char/esp.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/esp.c	2007-02-04 19:44:54.000000000 +0100
@@ -726 +726 @@
-static void do_softint(void *private_)
+static void do_softint(struct work_struct *work)
@@ -728 +728,2 @@
-	struct esp_struct	*info = (struct esp_struct *) private_;
+	struct esp_struct	*info =
+		container_of(work, struct esp_struct, tqueue);
@@ -749 +750 @@
-static void do_serial_hangup(void *private_)
+static void do_serial_hangup(struct work_struct *work)
@@ -751 +752,2 @@
-	struct esp_struct	*info = (struct esp_struct *) private_;
+	struct esp_struct	*info =
+		container_of(work, struct esp_struct, tqueue_hangup);
@@ -1916 +1918 @@
-static void rs_set_termios(struct tty_struct *tty, struct termios *old_termios)
+static void rs_set_termios(struct tty_struct *tty, struct ktermios *old_termios)
@@ -2504,2 +2506,2 @@
-		INIT_WORK(&info->tqueue, do_softint, info);
-		INIT_WORK(&info->tqueue_hangup, do_serial_hangup, info);
+		INIT_WORK(&info->tqueue, do_softint);
+		INIT_WORK(&info->tqueue_hangup, do_serial_hangup);
--- ./projects/linux/linux-2.6.22/drivers/char/esp.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/esp.c	2007-10-09 22:31:38.000000000 +0200
@@ -1124,2 +1123,0 @@
-#define RELEVANT_IFLAG(iflag) (iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
-
@@ -1923,5 +1920,0 @@
-	if (   (tty->termios->c_cflag == old_termios->c_cflag)
-	    && (   RELEVANT_IFLAG(tty->termios->c_iflag) 
-		== RELEVANT_IFLAG(old_termios->c_iflag)))
-		return;
-
@@ -2469 +2462 @@
-	info = kmalloc(sizeof(struct esp_struct), GFP_KERNEL);
+	info = kzalloc(sizeof(struct esp_struct), GFP_KERNEL);
@@ -2479 +2471,0 @@
-	memset((void *)info, 0, sizeof(struct esp_struct));
@@ -2537 +2529 @@
-		info = kmalloc(sizeof(struct esp_struct), GFP_KERNEL);
+		info = kzalloc(sizeof(struct esp_struct), GFP_KERNEL);
@@ -2546 +2537,0 @@
-		memset((void *)info, 0, sizeof(struct esp_struct));
--- ./projects/linux/linux-2.6.23/drivers/char/esp.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/esp.c	2008-01-24 23:58:37.000000000 +0100
@@ -22 +22 @@
- *                                            Bernd Anhpl 05/17/96.
+ *                                            Bernd Anhupl 05/17/96.
@@ -60,0 +61 @@
+#include <linux/bitops.h>
@@ -64 +64,0 @@
-#include <asm/bitops.h>
--- ./projects/linux/linux-2.6.24/drivers/char/esp.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/esp.c	2008-04-17 04:49:44.000000000 +0200
@@ -114,3 +113,0 @@
-/* serial subtype definitions */
-#define SERIAL_TYPE_NORMAL	1
-
@@ -248,11 +244,0 @@
-/*
- * This routine is used by the interrupt handler to schedule
- * processing in the software interrupt portion of the driver.
- */
-static inline void rs_sched_event(struct esp_struct *info,
-				  int event)
-{
-	info->event |= 1 << event;
-	schedule_work(&info->tqueue);
-}
-
@@ -480 +466,2 @@
-		rs_sched_event(info, ESP_EVENT_WRITE_WAKEUP);
+		if (info->tty)
+			tty_wakeup(info->tty);
@@ -518 +505,2 @@
-		rs_sched_event(info, ESP_EVENT_WRITE_WAKEUP);
+		if (info->tty)
+			tty_wakeup(info->tty);
@@ -610 +598 @@
-			schedule_work(&info->tqueue_hangup);
+			tty_hangup(info->tty);
@@ -726,35 +713,0 @@
-static void do_softint(struct work_struct *work)
-{
-	struct esp_struct	*info =
-		container_of(work, struct esp_struct, tqueue);
-	struct tty_struct	*tty;
-	
-	tty = info->tty;
-	if (!tty)
-		return;
-
-	if (test_and_clear_bit(ESP_EVENT_WRITE_WAKEUP, &info->event)) {
-		tty_wakeup(tty);
-	}
-}
-
-/*
- * This routine is called from the scheduler tqueue when the interrupt
- * routine has signalled that a hangup has occurred.  The path of
- * hangup processing is:
- *
- * 	serial interrupt routine -> (scheduler tqueue) ->
- * 	do_serial_hangup() -> tty->hangup() -> esp_hangup()
- * 
- */
-static void do_serial_hangup(struct work_struct *work)
-{
-	struct esp_struct	*info =
-		container_of(work, struct esp_struct, tqueue_hangup);
-	struct tty_struct	*tty;
-	
-	tty = info->tty;
-	if (tty)
-		tty_hangup(tty);
-}
-
@@ -2044 +1996,0 @@
-	info->event = 0;
@@ -2112 +2063,0 @@
-	info->event = 0;
@@ -2498,2 +2448,0 @@
-		INIT_WORK(&info->tqueue, do_softint);
-		INIT_WORK(&info->tqueue_hangup, do_serial_hangup);
@@ -2537,0 +2487 @@
+		spin_lock_init(&info->lock);
--- ./projects/linux/linux-2.6.25/drivers/char/esp.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/esp.c	2008-07-13 23:51:29.000000000 +0200
@@ -11 +11 @@
- *  Accent Async board.  
+ *  Accent Async board.
@@ -64 +64 @@
-#include <asm/io.h>
+#include <linux/io.h>
@@ -68 +68 @@
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
@@ -130,2 +130,4 @@
-#define DBG_CNT(s) printk("(%s): [%x] refc=%d, serc=%d, ttyc=%d -> %s\n", \
- tty->name, (info->flags), serial_driver.refcount,info->count,tty->count,s)
+#define DBG_CNT(s) printk(KERN_DEBUG "(%s): [%x] refc=%d, serc=%d, ttyc=%d -> %s\n", \
+				tty->name, info->flags, \
+				serial_driver.refcount, \
+				info->count, tty->count, s)
@@ -192 +194 @@
-	struct esp_struct *info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -209 +211 @@
-	struct esp_struct *info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -211 +213 @@
-	
+
@@ -214 +216 @@
-	
+
@@ -236 +238 @@
- * 
+ *
@@ -293 +295 @@
-		
+
@@ -328,2 +330 @@
-			}
-			else if (err_buf->data[i] & 0x02)
+			} else if (err_buf->data[i] & 0x02)
@@ -344 +345 @@
-static inline void receive_chars_dma(struct esp_struct *info, int num_bytes)
+static void program_isa_dma(int dma, int dir, unsigned long addr, int len)
@@ -346,0 +348,13 @@
+
+	flags = claim_dma_lock();
+	disable_dma(dma);
+	clear_dma_ff(dma);
+	set_dma_mode(dma, dir);
+	set_dma_addr(dma, addr);
+	set_dma_count(dma, len);
+	enable_dma(dma);
+	release_dma_lock(flags);
+}
+
+static void receive_chars_dma(struct esp_struct *info, int num_bytes)
+{
@@ -350,11 +364,4 @@
-	
-	flags=claim_dma_lock();
-        disable_dma(dma);
-        clear_dma_ff(dma);
-        set_dma_mode(dma, DMA_MODE_READ);
-        set_dma_addr(dma, isa_virt_to_bus(dma_buffer));
-        set_dma_count(dma, dma_bytes);
-        enable_dma(dma);
-        release_dma_lock(flags);
-        
-        serial_out(info, UART_ESI_CMD1, ESI_START_DMA_RX);
+
+	program_isa_dma(dma, DMA_MODE_READ, isa_virt_to_bus(dma_buffer),
+								dma_bytes);
+	serial_out(info, UART_ESI_CMD1, ESI_START_DMA_RX);
@@ -369,2 +376,2 @@
-	
-	flags=claim_dma_lock();
+
+	flags = claim_dma_lock();
@@ -377 +384 @@
-	
+
@@ -384 +391 @@
-		
+
@@ -396,3 +403,2 @@
-				(info->icount.frame)++;
-			}
-			else if (status & 0x04) {
+				info->icount.frame++;
+			} else if (status & 0x04) {
@@ -400 +406 @@
-				(info->icount.parity)++;
+				info->icount.parity++;
@@ -402 +408,2 @@
-			tty_insert_flip_char(tty, dma_buffer[num_bytes - 1], statflag);
+			tty_insert_flip_char(tty, dma_buffer[num_bytes - 1],
+								statflag);
@@ -487,2 +493,0 @@
-	unsigned long flags;
-	
@@ -520,11 +525,4 @@
-	
-	flags=claim_dma_lock();
-        disable_dma(dma);
-        clear_dma_ff(dma);
-        set_dma_mode(dma, DMA_MODE_WRITE);
-        set_dma_addr(dma, isa_virt_to_bus(dma_buffer));
-        set_dma_count(dma, dma_bytes);
-        enable_dma(dma);
-        release_dma_lock(flags);
-        
-        serial_out(info, UART_ESI_CMD1, ESI_START_DMA_TX);
+
+	program_isa_dma(dma, DMA_MODE_WRITE, isa_virt_to_bus(dma_buffer),
+								dma_bytes);
+	serial_out(info, UART_ESI_CMD1, ESI_START_DMA_TX);
@@ -537 +534,0 @@
-	
@@ -539 +536 @@
-	flags=claim_dma_lock();
+	flags = claim_dma_lock();
@@ -550,11 +547,5 @@
-		
-		flags=claim_dma_lock();
-        	disable_dma(dma);
-        	clear_dma_ff(dma);
-        	set_dma_mode(dma, DMA_MODE_WRITE);
-        	set_dma_addr(dma, isa_virt_to_bus(dma_buffer));
-        	set_dma_count(dma, dma_bytes);
-        	enable_dma(dma);
-        	release_dma_lock(flags);
-        	
-        	serial_out(info, UART_ESI_CMD1, ESI_START_DMA_TX);
+
+		program_isa_dma(dma, DMA_MODE_WRITE,
+				isa_virt_to_bus(dma_buffer), dma_bytes);
+
+		serial_out(info, UART_ESI_CMD1, ESI_START_DMA_TX);
@@ -567 +558 @@
-static inline void check_modem_status(struct esp_struct *info)
+static void check_modem_status(struct esp_struct *info)
@@ -570 +561 @@
-	
+
@@ -591 +582 @@
-#endif		
+#endif
@@ -608 +599 @@
-	struct esp_struct * info;
+	struct esp_struct *info;
@@ -620 +611 @@
-	
+
@@ -640 +631 @@
-		
+
@@ -670 +661 @@
-	
+
@@ -725 +716 @@
-static inline void esp_basic_init(struct esp_struct * info)
+static void esp_basic_init(struct esp_struct *info)
@@ -729 +720 @@
-	
+
@@ -786 +777 @@
-static int startup(struct esp_struct * info)
+static int startup(struct esp_struct *info)
@@ -789,2 +780,2 @@
-	int	retval=0;
-        unsigned int num_chars;
+	int	retval = 0;
+	unsigned int num_chars;
@@ -792 +783 @@
-        spin_lock_irqsave(&info->lock, flags);
+	spin_lock_irqsave(&info->lock, flags);
@@ -805 +796,2 @@
-	printk("starting up ttys%d (irq %d)...", info->line, info->irq);
+	printk(KERN_DEBUG "starting up ttys%d (irq %d)...",
+						info->line, info->irq);
@@ -866 +858 @@
-			
+
@@ -875 +867 @@
-	
+
@@ -884 +876 @@
-	
+
@@ -903 +895 @@
-	
+
@@ -921 +913 @@
-static void shutdown(struct esp_struct * info)
+static void shutdown(struct esp_struct *info)
@@ -932 +924 @@
-	
+
@@ -944 +936 @@
-		f=claim_dma_lock();
+		f = claim_dma_lock();
@@ -948 +940 @@
-		
+
@@ -951 +943 @@
-	
+
@@ -973 +965 @@
-		}		
+		}
@@ -995 +987 @@
-	
+
@@ -1008 +1000 @@
-	unsigned cflag,cval;
+	unsigned cflag, cval;
@@ -1017 +1009 @@
-	
+
@@ -1020,5 +1012,5 @@
-	      case CS5: cval = 0x00; bits = 7; break;
-	      case CS6: cval = 0x01; bits = 8; break;
-	      case CS7: cval = 0x02; bits = 9; break;
-	      case CS8: cval = 0x03; bits = 10; break;
-	      default:  cval = 0x00; bits = 7; break;
+	case CS5: cval = 0x00; bits = 7; break;
+	case CS6: cval = 0x01; bits = 8; break;
+	case CS7: cval = 0x02; bits = 9; break;
+	case CS8: cval = 0x03; bits = 10; break;
+	default:  cval = 0x00; bits = 7; break;
@@ -1040 +1031,0 @@
-
@@ -1043 +1034 @@
-	    ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST))
+		((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST))
@@ -1046,2 +1037 @@
-		if (baud == 134)
-			/* Special case since 134 is really 134.5 */
+		if (baud == 134) /* Special case since 134 is really 134.5 */
@@ -1055 +1045,6 @@
-	
+
+	if (baud) {
+		/* Actual rate */
+		baud = BASE_BAUD/quot;
+		tty_encode_baud_rate(info->tty, baud, baud);
+	}
@@ -1069 +1064 @@
-	else {
+	else
@@ -1071,2 +1065,0 @@
-		/* info->IER |= UART_IER_MSI; */
-	}
@@ -1082 +1075 @@
-	
+
@@ -1095 +1088 @@
-		 * If we're ignore parity and break indicators, ignore 
+		 * If we're ignore parity and break indicators, ignore
@@ -1133,13 +1126,13 @@
-			case CS5:
-				serial_out(info, UART_ESI_CMD2, 0x1f);
-				break;
-			case CS6:
-				serial_out(info, UART_ESI_CMD2, 0x3f);
-				break;
-			case CS7:
-			case CS8:
-				serial_out(info, UART_ESI_CMD2, 0x7f);
-				break;
-			default:
-				serial_out(info, UART_ESI_CMD2, 0xff);
-				break;
+		case CS5:
+			serial_out(info, UART_ESI_CMD2, 0x1f);
+			break;
+		case CS6:
+			serial_out(info, UART_ESI_CMD2, 0x3f);
+			break;
+		case CS7:
+		case CS8:
+			serial_out(info, UART_ESI_CMD2, 0x7f);
+			break;
+		default:
+			serial_out(info, UART_ESI_CMD2, 0xff);
+			break;
@@ -1159 +1152 @@
-static void rs_put_char(struct tty_struct *tty, unsigned char ch)
+static int rs_put_char(struct tty_struct *tty, unsigned char ch)
@@ -1161 +1154 @@
-	struct esp_struct *info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1162,0 +1156 @@
+	int ret = 0;
@@ -1165 +1159 @@
-		return;
+		return 0;
@@ -1168 +1162 @@
-		return;
+		return 0;
@@ -1174,0 +1169 @@
+		ret = 1;
@@ -1176,0 +1172 @@
+	return ret;
@@ -1181 +1177 @@
-	struct esp_struct *info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1183 +1179 @@
-				
+
@@ -1201 +1197 @@
-static int rs_write(struct tty_struct * tty,
+static int rs_write(struct tty_struct *tty,
@@ -1205 +1201 @@
-	struct esp_struct *info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1213 +1209 @@
-	    
+
@@ -1220 +1216 @@
-		
+
@@ -1225 +1221 @@
-		
+
@@ -1255 +1251 @@
-	struct esp_struct *info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1258 +1254 @@
-				
+
@@ -1273,2 +1269,2 @@
-	struct esp_struct *info = (struct esp_struct *)tty->driver_data;
-				
+	struct esp_struct *info = tty->driver_data;
+
@@ -1282 +1278 @@
-	struct esp_struct *info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1284 +1280 @@
-				
+
@@ -1296 +1292 @@
- * 
+ *
@@ -1301 +1297 @@
-static void rs_throttle(struct tty_struct * tty)
+static void rs_throttle(struct tty_struct *tty)
@@ -1303 +1299 @@
-	struct esp_struct *info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1307 +1303 @@
-	
+
@@ -1309 +1305 @@
-	       tty->ldisc.chars_in_buffer(tty));
+						tty_chars_in_buffer(tty));
@@ -1324 +1320 @@
-static void rs_unthrottle(struct tty_struct * tty)
+static void rs_unthrottle(struct tty_struct *tty)
@@ -1326 +1322 @@
-	struct esp_struct *info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1330,3 +1326,3 @@
-	
-	printk("unthrottle %s: %d....\n", tty_name(tty, buf),
-	       tty->ldisc.chars_in_buffer(tty));
+
+	printk(KERN_DEBUG "unthrottle %s: %d....\n", tty_name(tty, buf),
+	       tty_chars_in_buffer(tty));
@@ -1337 +1333 @@
-	
+
@@ -1353 +1349 @@
-static int get_serial_info(struct esp_struct * info,
+static int get_serial_info(struct esp_struct *info,
@@ -1357 +1353,2 @@
-  
+
+	lock_kernel();
@@ -1370 +1367,2 @@
-	if (copy_to_user(retinfo,&tmp,sizeof(*retinfo)))
+	unlock_kernel();
+	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
@@ -1375 +1373 @@
-static int get_esp_config(struct esp_struct * info,
+static int get_esp_config(struct esp_struct *info,
@@ -1379 +1377 @@
-  
+
@@ -1383,0 +1382 @@
+	lock_kernel();
@@ -1390,0 +1390 @@
+	unlock_kernel();
@@ -1395 +1395 @@
-static int set_serial_info(struct esp_struct * info,
+static int set_serial_info(struct esp_struct *info,
@@ -1404 +1404 @@
-	if (copy_from_user(&new_serial,new_info,sizeof(new_serial)))
+	if (copy_from_user(&new_serial, new_info, sizeof(new_serial)))
@@ -1425 +1425 @@
-		if (change_irq || 
+		if (change_irq ||
@@ -1510,2 +1510,2 @@
-static int set_esp_config(struct esp_struct * info,
-			  struct hayes_esp_config __user * new_info)
+static int set_esp_config(struct esp_struct *info,
+			  struct hayes_esp_config __user *new_info)
@@ -1553 +1552,0 @@
-			
@@ -1562,3 +1561,2 @@
-					
-				current_async =
-					current_async->next_port;
+
+				current_async = current_async->next_port;
@@ -1570,2 +1568,2 @@
-			
-                        /* all ports must use the same DMA channel */
+
+			/* all ports must use the same DMA channel */
@@ -1583 +1580,0 @@
-			
@@ -1599,2 +1595,0 @@
-		unsigned long flags;
-
@@ -1615,2 +1609,0 @@
-		unsigned long flags;
-
@@ -1631,2 +1623,0 @@
-		unsigned long flags;
-
@@ -1660 +1651 @@
- * 	    allows an RS485 driver to be written in user space. 
+ * 	    allows an RS485 driver to be written in user space.
@@ -1662 +1653 @@
-static int get_lsr_info(struct esp_struct * info, unsigned int __user *value)
+static int get_lsr_info(struct esp_struct *info, unsigned int __user *value)
@@ -1673 +1664 @@
-	return put_user(result,value);
+	return put_user(result, value);
@@ -1679 +1670 @@
-	struct esp_struct * info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1683 +1674 @@
-	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+	if (serial_paranoia_check(info, tty->name, __func__))
@@ -1706 +1697 @@
-	struct esp_struct * info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1709 +1700 @@
-	if (serial_paranoia_check(info, tty->name, __FUNCTION__))
+	if (serial_paranoia_check(info, tty->name, __func__))
@@ -1739 +1730 @@
-	struct esp_struct * info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1741 +1732 @@
-	
+
@@ -1761 +1752 @@
-static int rs_ioctl(struct tty_struct *tty, struct file * file,
+static int rs_ioctl(struct tty_struct *tty, struct file *file,
@@ -1764 +1755 @@
-	struct esp_struct * info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1768,0 +1760 @@
+	int ret;
@@ -1781,12 +1772,0 @@
-	
-	switch (cmd) {
-		case TIOCGSERIAL:
-			return get_serial_info(info, argp);
-		case TIOCSSERIAL:
-			return set_serial_info(info, argp);
-		case TIOCSERCONFIG:
-			/* do not reconfigure after initial configuration */
-			return 0;
-
-		case TIOCSERGWILD:
-			return put_user(0L, (unsigned long __user *)argp);
@@ -1794,15 +1774,32 @@
-		case TIOCSERGETLSR: /* Get line status register */
-			    return get_lsr_info(info, argp);
-
-		case TIOCSERSWILD:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EPERM;
-			return 0;
-
-		/*
-		 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change
-		 * - mask passed in arg for lines of interest
- 		 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
-		 * Caller should use TIOCGICOUNT to see which one it was
-		 */
-		 case TIOCMIWAIT:
+	switch (cmd) {
+	case TIOCGSERIAL:
+		return get_serial_info(info, argp);
+	case TIOCSSERIAL:
+		lock_kernel();
+		ret = set_serial_info(info, argp);
+		unlock_kernel();
+		return ret;
+	case TIOCSERGWILD:
+		return put_user(0L, (unsigned long __user *)argp);
+	case TIOCSERGETLSR: /* Get line status register */
+		return get_lsr_info(info, argp);
+	case TIOCSERSWILD:
+		if (!capable(CAP_SYS_ADMIN))
+			return -EPERM;
+		return 0;
+	/*
+	 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change
+	 * - mask passed in arg for lines of interest
+	 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
+	 * Caller should use TIOCGICOUNT to see which one it was
+	 */
+	case TIOCMIWAIT:
+		spin_lock_irqsave(&info->lock, flags);
+		cprev = info->icount;	/* note the counters on entry */
+		spin_unlock_irqrestore(&info->lock, flags);
+		while (1) {
+			/* FIXME: convert to new style wakeup */
+			interruptible_sleep_on(&info->delta_msr_wait);
+			/* see if a signal did it */
+			if (signal_pending(current))
+				return -ERESTARTSYS;
@@ -1810 +1807 @@
-			cprev = info->icount;	/* note the counters on entry */
+			cnow = info->icount;	/* atomic copy */
@@ -1812,25 +1809,14 @@
-			while (1) {
-				/* FIXME: convert to new style wakeup */
-				interruptible_sleep_on(&info->delta_msr_wait);
-				/* see if a signal did it */
-				if (signal_pending(current))
-					return -ERESTARTSYS;
-				spin_lock_irqsave(&info->lock, flags);
-				cnow = info->icount;	/* atomic copy */
-				spin_unlock_irqrestore(&info->lock, flags);
-				if (cnow.rng == cprev.rng &&
-				    cnow.dsr == cprev.dsr && 
-				    cnow.dcd == cprev.dcd &&
-				    cnow.cts == cprev.cts)
-					return -EIO; /* no change => error */
-				if (((arg & TIOCM_RNG) &&
-				     (cnow.rng != cprev.rng)) ||
-				     ((arg & TIOCM_DSR) &&
-				      (cnow.dsr != cprev.dsr)) ||
-				     ((arg & TIOCM_CD) &&
-				      (cnow.dcd != cprev.dcd)) ||
-				     ((arg & TIOCM_CTS) &&
-				      (cnow.cts != cprev.cts)) ) {
-					return 0;
-				}
-				cprev = cnow;
+			if (cnow.rng == cprev.rng &&
+			    cnow.dsr == cprev.dsr &&
+			    cnow.dcd == cprev.dcd &&
+			    cnow.cts == cprev.cts)
+				return -EIO; /* no change => error */
+			if (((arg & TIOCM_RNG) &&
+			     (cnow.rng != cprev.rng)) ||
+			     ((arg & TIOCM_DSR) &&
+			      (cnow.dsr != cprev.dsr)) ||
+			     ((arg & TIOCM_CD) &&
+			      (cnow.dcd != cprev.dcd)) ||
+			     ((arg & TIOCM_CTS) &&
+			      (cnow.cts != cprev.cts))) {
+				return 0;
@@ -1838,19 +1824,19 @@
-			/* NOTREACHED */
-
-		/* 
-		 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
-		 * Return: write counters to the user passed counter struct
-		 * NB: both 1->0 and 0->1 transitions are counted except for
-		 *     RI where only 0->1 is counted.
-		 */
-		case TIOCGICOUNT:
-			spin_lock_irqsave(&info->lock, flags);
-			cnow = info->icount;
-			spin_unlock_irqrestore(&info->lock, flags);
-			p_cuser = argp;
-			if (put_user(cnow.cts, &p_cuser->cts) ||
-			    put_user(cnow.dsr, &p_cuser->dsr) ||
-			    put_user(cnow.rng, &p_cuser->rng) ||
-			    put_user(cnow.dcd, &p_cuser->dcd))
-				return -EFAULT;
-
+			cprev = cnow;
+		}
+		/* NOTREACHED */
+	/*
+	 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
+	 * Return: write counters to the user passed counter struct
+	 * NB: both 1->0 and 0->1 transitions are counted except for
+	 *     RI where only 0->1 is counted.
+	 */
+	case TIOCGICOUNT:
+		spin_lock_irqsave(&info->lock, flags);
+		cnow = info->icount;
+		spin_unlock_irqrestore(&info->lock, flags);
+		p_cuser = argp;
+		if (put_user(cnow.cts, &p_cuser->cts) ||
+		    put_user(cnow.dsr, &p_cuser->dsr) ||
+		    put_user(cnow.rng, &p_cuser->rng) ||
+		    put_user(cnow.dcd, &p_cuser->dcd))
+			return -EFAULT;
@@ -1861,5 +1847,7 @@
-		return set_esp_config(info, argp);
-
-		default:
-			return -ENOIOCTLCMD;
-		}
+		lock_kernel();
+		ret = set_esp_config(info, argp);
+		unlock_kernel();
+		return ret;
+	default:
+		return -ENOIOCTLCMD;
+	}
@@ -1871 +1859 @@
-	struct esp_struct *info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1908 +1896 @@
- * 
+ *
@@ -1915 +1903 @@
-static void rs_close(struct tty_struct *tty, struct file * filp)
+static void rs_close(struct tty_struct *tty, struct file *filp)
@@ -1917 +1905 @@
-	struct esp_struct * info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -1922 +1910 @@
-	
+
@@ -1924 +1912 @@
-	
+
@@ -1929 +1917 @@
-	
+
@@ -1931 +1919,2 @@
-	printk("rs_close ttys%d, count = %d\n", info->line, info->count);
+	printk(KERN_DEBUG "rs_close ttys%d, count = %d\n",
+						info->line, info->count);
@@ -1933 +1922 @@
-	if ((tty->count == 1) && (info->count != 1)) {
+	if (tty->count == 1 && info->count != 1) {
@@ -1941,2 +1930 @@
-		printk("rs_close: bad serial port count; tty->count is 1, "
-		       "info->count is %d\n", info->count);
+		printk(KERN_DEBUG "rs_close: bad serial port count; tty->count is 1, info->count is %d\n", info->count);
@@ -1946 +1934 @@
-		printk("rs_close: bad serial port count for ttys%d: %d\n",
+		printk(KERN_ERR "rs_close: bad serial port count for ttys%d: %d\n",
@@ -1958 +1946 @@
-	 * Now we wait for the transmit buffer to clear; and we notify 
+	 * Now we wait for the transmit buffer to clear; and we notify
@@ -1993,2 +1981 @@
-	if (tty->driver->flush_buffer)
-		tty->driver->flush_buffer(tty);
+	rs_flush_buffer(tty);
@@ -2000 +1987 @@
-		if (info->close_delay) {
+		if (info->close_delay)
@@ -2002 +1988,0 @@
-		}
@@ -2015 +2001 @@
-	struct esp_struct *info = (struct esp_struct *)tty->driver_data;
+	struct esp_struct *info = tty->driver_data;
@@ -2039 +2025 @@
-			break;
+			return;
@@ -2042 +2028 @@
-			break;
+			return;
@@ -2057,2 +2043,2 @@
-	struct esp_struct * info = (struct esp_struct *)tty->driver_data;
-	
+	struct esp_struct *info = tty->driver_data;
+
@@ -2061 +2047 @@
-	
+
@@ -2075 +2061 @@
-static int block_til_ready(struct tty_struct *tty, struct file * filp,
+static int block_til_ready(struct tty_struct *tty, struct file *filp,
@@ -2124 +2110 @@
-	printk("block_til_ready before block: ttys%d, count = %d\n",
+	printk(KERN_DEBUG "block_til_ready before block: ttys%d, count = %d\n",
@@ -2128 +2114 @@
-	if (!tty_hung_up_p(filp)) 
+	if (!tty_hung_up_p(filp))
@@ -2150 +2136 @@
-				retval = -ERESTARTSYS;	
+				retval = -ERESTARTSYS;
@@ -2169 +2155 @@
-		printk("block_til_ready blocking: ttys%d, count = %d\n",
+		printk(KERN_DEBUG "block_til_ready blocking: ttys%d, count = %d\n",
@@ -2183 +2169 @@
-	printk("block_til_ready after blocking: ttys%d, count = %d\n",
+	printk(KERN_DEBUG "block_til_ready after blocking: ttys%d, count = %d\n",
@@ -2190 +2176 @@
-}	
+}
@@ -2198 +2184 @@
-static int esp_open(struct tty_struct *tty, struct file * filp)
+static int esp_open(struct tty_struct *tty, struct file *filp)
@@ -2221 +2207 @@
-	printk("esp_open %s, count = %d\n", tty->name, info->count);
+	printk(KERN_DEBUG "esp_open %s, count = %d\n", tty->name, info->count);
@@ -2229 +2215 @@
-	
+
@@ -2240 +2226 @@
-		printk("esp_open returning after block_til_ready with %d\n",
+		printk(KERN_DEBUG "esp_open returning after block_til_ready with %d\n",
@@ -2245 +2230,0 @@
-
@@ -2247 +2232 @@
-	printk("esp_open %s successful...", tty->name);
+	printk(KERN_DEBUG "esp_open %s successful...", tty->name);
@@ -2265,2 +2250,2 @@
- 
-static inline void show_serial_version(void)
+
+static void show_serial_version(void)
@@ -2268 +2253 @@
- 	printk(KERN_INFO "%s version %s (DMA %u)\n",
+	printk(KERN_INFO "%s version %s (DMA %u)\n",
@@ -2276 +2261 @@
-static inline int autoconfig(struct esp_struct * info)
+static int autoconfig(struct esp_struct *info)
@@ -2352 +2337 @@
-	struct esp_struct * info;
+	struct esp_struct *info;
@@ -2354 +2339 @@
-	int esp[] = {0x100,0x140,0x180,0x200,0x240,0x280,0x300,0x380};
+	int esp[] = { 0x100, 0x140, 0x180, 0x200, 0x240, 0x280, 0x300, 0x380 };
@@ -2359 +2344 @@
-	
+
@@ -2381 +2366 @@
-	
+
@@ -2387 +2372 @@
-	
+
@@ -2394 +2379 @@
-	
+
@@ -2403,0 +2389,2 @@
+	esp_driver->init_termios.c_ispeed = 9600;
+	esp_driver->init_termios.c_ospeed = 9600;
@@ -2406,2 +2393 @@
-	if (tty_register_driver(esp_driver))
-	{
+	if (tty_register_driver(esp_driver)) {
@@ -2415,2 +2401 @@
-	if (!info)
-	{
+	if (!info) {
@@ -2479,4 +2464,2 @@
-		if (!info)
-		{
-			printk(KERN_ERR "Couldn't allocate memory for esp serial device information\n"); 
-
+		if (!info) {
+			printk(KERN_ERR "Couldn't allocate memory for esp serial device information\n");
@@ -2506 +2489 @@
-static void __exit espserial_exit(void) 
+static void __exit espserial_exit(void)
@@ -2512,4 +2495,3 @@
-	/* printk("Unloading %s: version %s\n", serial_name, serial_version); */
-	if ((e1 = tty_unregister_driver(esp_driver)))
-		printk("SERIAL: failed to unregister serial driver (%d)\n",
-		       e1);
+	e1 = tty_unregister_driver(esp_driver);
+	if (e1)
+		printk(KERN_ERR "esp: failed to unregister driver (%d)\n", e1);
@@ -2519 +2501 @@
-		if (ports->port) {
+		if (ports->port)
@@ -2521 +2502,0 @@
-		}
--- ./projects/linux/linux-2.6.26/drivers/char/esp.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/char/esp.c	2008-10-10 00:13:53.000000000 +0200
@@ -131 +131 @@
-				tty->name, info->flags, \
+				tty->name, info->port.flags, \
@@ -133 +133 @@
-				info->count, tty->count, s)
+				info->port.count, tty->count, s)
@@ -175 +175 @@
-	return inb(info->port + offset);
+	return inb(info->io_port + offset);
@@ -181 +181 @@
-	outb(value, info->port+offset);
+	outb(value, info->io_port+offset);
@@ -276 +276 @@
-	struct tty_struct *tty = info->tty;
+	struct tty_struct *tty = info->port.tty;
@@ -298 +298 @@
-			inw(info->port + UART_ESI_RX);
+			inw(info->io_port + UART_ESI_RX);
@@ -311 +311 @@
-	tty = info->tty;
+	tty = info->port.tty;
@@ -328 +328 @@
-				if (info->flags & ASYNC_SAK)
+				if (info->port.flags & ASYNC_SAK)
@@ -373 +373 @@
-	struct tty_struct *tty = info->tty;
+	struct tty_struct *tty = info->port.tty;
@@ -399 +399 @@
-				if (info->flags & ASYNC_SAK)
+				if (info->port.flags & ASYNC_SAK)
@@ -454 +454 @@
-			     info->port + UART_ESI_TX);
+			     info->io_port + UART_ESI_TX);
@@ -473,2 +473,2 @@
-		if (info->tty)
-			tty_wakeup(info->tty);
+		if (info->port.tty)
+			tty_wakeup(info->port.tty);
@@ -510,2 +510,2 @@
-		if (info->tty)
-			tty_wakeup(info->tty);
+		if (info->port.tty)
+			tty_wakeup(info->port.tty);
@@ -578 +578 @@
-	if ((info->flags & ASYNC_CHECK_CD) && (status & UART_MSR_DDCD)) {
+	if ((info->port.flags & ASYNC_CHECK_CD) && (status & UART_MSR_DDCD)) {
@@ -584 +584 @@
-			wake_up_interruptible(&info->open_wait);
+			wake_up_interruptible(&info->port.open_wait);
@@ -589 +589 @@
-			tty_hangup(info->tty);
+			tty_hangup(info->port.tty);
@@ -612 +612 @@
-	if (!info->tty) {
+	if (!info->port.tty) {
@@ -650 +650 @@
-		num_bytes = tty_buffer_request_room(info->tty, num_bytes);
+		num_bytes = tty_buffer_request_room(info->port.tty, num_bytes);
@@ -664 +664 @@
-		if ((info->xmit_cnt <= 0) || info->tty->stopped) {
+		if ((info->xmit_cnt <= 0) || info->port.tty->stopped) {
@@ -785 +785 @@
-	if (info->flags & ASYNC_INITIALIZED)
+	if (info->port.flags & ASYNC_INITIALIZED)
@@ -809 +809 @@
-		inw(info->port + UART_ESI_RX);
+		inw(info->io_port + UART_ESI_RX);
@@ -837 +837 @@
-			if (info->tty)
+			if (info->port.tty)
@@ -839 +839 @@
-					&info->tty->flags);
+					&info->port.tty->flags);
@@ -877,2 +877,2 @@
-	if (info->tty)
-		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->port.tty)
+		clear_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -885,9 +885,9 @@
-	if (info->tty) {
-		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
-			info->tty->alt_speed = 57600;
-		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
-			info->tty->alt_speed = 115200;
-		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
-			info->tty->alt_speed = 230400;
-		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
-			info->tty->alt_speed = 460800;
+	if (info->port.tty) {
+		if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+			info->port.tty->alt_speed = 57600;
+		if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+			info->port.tty->alt_speed = 115200;
+		if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+			info->port.tty->alt_speed = 230400;
+		if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+			info->port.tty->alt_speed = 460800;
@@ -900 +900 @@
-	info->flags |= ASYNC_INITIALIZED;
+	info->port.flags |= ASYNC_INITIALIZED;
@@ -917 +917 @@
-	if (!(info->flags & ASYNC_INITIALIZED))
+	if (!(info->port.flags & ASYNC_INITIALIZED))
@@ -954 +954 @@
-			    (current_port->flags & ASYNC_INITIALIZED))
+			    (current_port->port.flags & ASYNC_INITIALIZED))
@@ -977 +977 @@
-	if (!info->tty || (info->tty->termios->c_cflag & HUPCL))
+	if (!info->port.tty || (info->port.tty->termios->c_cflag & HUPCL))
@@ -985,2 +985,2 @@
-	if (info->tty)
-		set_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->port.tty)
+		set_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -988 +988 @@
-	info->flags &= ~ASYNC_INITIALIZED;
+	info->port.flags &= ~ASYNC_INITIALIZED;
@@ -1005 +1005 @@
-	if (!info->tty || !info->tty->termios)
+	if (!info->port.tty || !info->port.tty->termios)
@@ -1007,2 +1007,2 @@
-	cflag = info->tty->termios->c_cflag;
-	port = info->port;
+	cflag = info->port.tty->termios->c_cflag;
+	port = info->io_port;
@@ -1032 +1032 @@
-	baud = tty_get_baud_rate(info->tty);
+	baud = tty_get_baud_rate(info->port.tty);
@@ -1034 +1034 @@
-		((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST))
+		((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST))
@@ -1049 +1049 @@
-		tty_encode_baud_rate(info->tty, baud, baud);
+		tty_encode_baud_rate(info->port.tty, baud, baud);
@@ -1056 +1056 @@
-		info->flags |= ASYNC_CTS_FLOW;
+		info->port.flags |= ASYNC_CTS_FLOW;
@@ -1061 +1061 @@
-		info->flags &= ~ASYNC_CTS_FLOW;
+		info->port.flags &= ~ASYNC_CTS_FLOW;
@@ -1063 +1063 @@
-		info->flags &= ~ASYNC_CHECK_CD;
+		info->port.flags &= ~ASYNC_CHECK_CD;
@@ -1065 +1065 @@
-		info->flags |= ASYNC_CHECK_CD;
+		info->port.flags |= ASYNC_CHECK_CD;
@@ -1071 +1071 @@
-	if (I_INPCK(info->tty))
+	if (I_INPCK(info->port.tty))
@@ -1073 +1073 @@
-	if (I_BRKINT(info->tty) || I_PARMRK(info->tty))
+	if (I_BRKINT(info->port.tty) || I_PARMRK(info->port.tty))
@@ -1079 +1079 @@
-	if (I_IGNPAR(info->tty)) {
+	if (I_IGNPAR(info->port.tty)) {
@@ -1084 +1084 @@
-	if (I_IGNBRK(info->tty)) {
+	if (I_IGNBRK(info->port.tty)) {
@@ -1091 +1091 @@
-		if (I_IGNPAR(info->tty)) {
+		if (I_IGNPAR(info->port.tty)) {
@@ -1099 +1099 @@
-	if (I_IXOFF(info->tty))
+	if (I_IXOFF(info->port.tty))
@@ -1119 +1119 @@
-	if (I_IXOFF(info->tty)) {
+	if (I_IXOFF(info->port.tty)) {
@@ -1121,2 +1121,2 @@
-		serial_out(info, UART_ESI_CMD2, START_CHAR(info->tty));
-		serial_out(info, UART_ESI_CMD2, STOP_CHAR(info->tty));
+		serial_out(info, UART_ESI_CMD2, START_CHAR(info->port.tty));
+		serial_out(info, UART_ESI_CMD2, STOP_CHAR(info->port.tty));
@@ -1358 +1358 @@
-	tmp.port = info->port;
+	tmp.port = info->io_port;
@@ -1360 +1360 @@
-	tmp.flags = info->flags;
+	tmp.flags = info->port.flags;
@@ -1410 +1410 @@
-	    (info->port != new_serial.port) ||
+	    (info->io_port != new_serial.port) ||
@@ -1428 +1428 @@
-		     (info->flags & ~ASYNC_USR_MASK)))
+		     (info->port.flags & ~ASYNC_USR_MASK)))
@@ -1430 +1430 @@
-		info->flags = ((info->flags & ~ASYNC_USR_MASK) |
+		info->port.flags = ((info->port.flags & ~ASYNC_USR_MASK) |
@@ -1444 +1444 @@
-						if (current_async->count > 1)
+						if (current_async->port.count > 1)
@@ -1446 +1446 @@
-					} else if (current_async->count)
+					} else if (current_async->port.count)
@@ -1459 +1459 @@
-		info->flags = ((info->flags & ~ASYNC_FLAGS) |
+		info->port.flags = ((info->port.flags & ~ASYNC_FLAGS) |
@@ -1490,3 +1490,3 @@
-	if (info->flags & ASYNC_INITIALIZED) {
-		if (((old_info.flags & ASYNC_SPD_MASK) !=
-		     (info->flags & ASYNC_SPD_MASK)) ||
+	if (info->port.flags & ASYNC_INITIALIZED) {
+		if (((old_info.port.flags & ASYNC_SPD_MASK) !=
+		     (info->port.flags & ASYNC_SPD_MASK)) ||
@@ -1494,8 +1494,8 @@
-			if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
-				info->tty->alt_speed = 57600;
-			if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
-				info->tty->alt_speed = 115200;
-			if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
-				info->tty->alt_speed = 230400;
-			if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
-				info->tty->alt_speed = 460800;
+			if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+				info->port.tty->alt_speed = 57600;
+			if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+				info->port.tty->alt_speed = 115200;
+			if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+				info->port.tty->alt_speed = 230400;
+			if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+				info->port.tty->alt_speed = 460800;
@@ -1557 +1557 @@
-					if (current_async->count > 1)
+					if (current_async->port.count > 1)
@@ -1559 +1559 @@
-				} else if (current_async->count)
+				} else if (current_async->port.count)
@@ -1581 +1581 @@
-			if (info->count > 1)
+			if (info->port.count > 1)
@@ -1637 +1637 @@
-	if (!(info->flags & ASYNC_INITIALIZED))
+	if (!(info->port.flags & ASYNC_INITIALIZED))
@@ -1728 +1728 @@
-static void esp_break(struct tty_struct *tty, int break_state)
+static int esp_break(struct tty_struct *tty, int break_state)
@@ -1734 +1734 @@
-		return;
+		return -EINVAL;
@@ -1749,0 +1750 @@
+	return 0;
@@ -1920 +1921 @@
-						info->line, info->count);
+						info->line, info->port.count);
@@ -1922 +1923 @@
-	if (tty->count == 1 && info->count != 1) {
+	if (tty->count == 1 && info->port.count != 1) {
@@ -1930,2 +1931,2 @@
-		printk(KERN_DEBUG "rs_close: bad serial port count; tty->count is 1, info->count is %d\n", info->count);
-		info->count = 1;
+		printk(KERN_DEBUG "rs_close: bad serial port count; tty->count is 1, info->port.count is %d\n", info->port.count);
+		info->port.count = 1;
@@ -1933 +1934 @@
-	if (--info->count < 0) {
+	if (--info->port.count < 0) {
@@ -1935,2 +1936,2 @@
-		       info->line, info->count);
-		info->count = 0;
+		       info->line, info->port.count);
+		info->port.count = 0;
@@ -1938 +1939 @@
-	if (info->count) {
+	if (info->port.count) {
@@ -1942 +1943 @@
-	info->flags |= ASYNC_CLOSING;
+	info->port.flags |= ASYNC_CLOSING;
@@ -1961 +1962 @@
-	if (info->flags & ASYNC_INITIALIZED) {
+	if (info->port.flags & ASYNC_INITIALIZED) {
@@ -1984 +1985 @@
-	info->tty = NULL;
+	info->port.tty = NULL;
@@ -1986 +1987 @@
-	if (info->blocked_open) {
+	if (info->port.blocked_open) {
@@ -1989 +1990 @@
-		wake_up_interruptible(&info->open_wait);
+		wake_up_interruptible(&info->port.open_wait);
@@ -1991,2 +1992,2 @@
-	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-	wake_up_interruptible(&info->close_wait);
+	info->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
+	wake_up_interruptible(&info->port.close_wait);
@@ -2050,4 +2051,4 @@
-	info->count = 0;
-	info->flags &= ~ASYNC_NORMAL_ACTIVE;
-	info->tty = NULL;
-	wake_up_interruptible(&info->open_wait);
+	info->port.count = 0;
+	info->port.flags &= ~ASYNC_NORMAL_ACTIVE;
+	info->port.tty = NULL;
+	wake_up_interruptible(&info->port.open_wait);
@@ -2074,3 +2075,3 @@
-	    (info->flags & ASYNC_CLOSING)) {
-		if (info->flags & ASYNC_CLOSING)
-			interruptible_sleep_on(&info->close_wait);
+	    (info->port.flags & ASYNC_CLOSING)) {
+		if (info->port.flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&info->port.close_wait);
@@ -2078 +2079 @@
-		if (info->flags & ASYNC_HUP_NOTIFY)
+		if (info->port.flags & ASYNC_HUP_NOTIFY)
@@ -2093 +2094 @@
-		info->flags |= ASYNC_NORMAL_ACTIVE;
+		info->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -2103 +2104 @@
-	 * this loop, info->count is dropped by one, so that
+	 * this loop, info->port.count is dropped by one, so that
@@ -2108 +2109 @@
-	add_wait_queue(&info->open_wait, &wait);
+	add_wait_queue(&info->port.open_wait, &wait);
@@ -2111 +2112 @@
-	       info->line, info->count);
+	       info->line, info->port.count);
@@ -2115,2 +2116,2 @@
-		info->count--;
-	info->blocked_open++;
+		info->port.count--;
+	info->port.blocked_open++;
@@ -2131 +2132 @@
-		    !(info->flags & ASYNC_INITIALIZED)) {
+		    !(info->port.flags & ASYNC_INITIALIZED)) {
@@ -2133 +2134 @@
-			if (info->flags & ASYNC_HUP_NOTIFY)
+			if (info->port.flags & ASYNC_HUP_NOTIFY)
@@ -2147 +2148 @@
-		if (!(info->flags & ASYNC_CLOSING) &&
+		if (!(info->port.flags & ASYNC_CLOSING) &&
@@ -2156 +2157 @@
-		       info->line, info->count);
+		       info->line, info->port.count);
@@ -2163 +2164 @@
-	remove_wait_queue(&info->open_wait, &wait);
+	remove_wait_queue(&info->port.open_wait, &wait);
@@ -2165,2 +2166,2 @@
-		info->count++;
-	info->blocked_open--;
+		info->port.count++;
+	info->port.blocked_open--;
@@ -2170 +2171 @@
-	       info->line, info->count);
+	       info->line, info->port.count);
@@ -2174 +2175 @@
-	info->flags |= ASYNC_NORMAL_ACTIVE;
+	info->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -2207 +2208 @@
-	printk(KERN_DEBUG "esp_open %s, count = %d\n", tty->name, info->count);
+	printk(KERN_DEBUG "esp_open %s, count = %d\n", tty->name, info->port.count);
@@ -2210 +2211 @@
-	info->count++;
+	info->port.count++;
@@ -2212 +2213 @@
-	info->tty = tty;
+	info->port.tty = tty;
@@ -2266 +2267 @@
-	if (!request_region(info->port, REGION_SIZE, "esp serial"))
+	if (!request_region(info->io_port, REGION_SIZE, "esp serial"))
@@ -2303 +2304 @@
-		release_region(info->port, REGION_SIZE);
+		release_region(info->io_port, REGION_SIZE);
@@ -2417 +2418 @@
-		info->port = esp[i] + offset;
+		info->io_port = esp[i] + offset;
@@ -2428 +2429 @@
-		info->flags = STD_COM_FLAGS;
+		info->port.flags = STD_COM_FLAGS;
@@ -2430 +2431 @@
-			info->flags |= ASYNC_SPD_CUST;
+			info->port.flags |= ASYNC_SPD_CUST;
@@ -2439,2 +2440,2 @@
-		init_waitqueue_head(&info->open_wait);
-		init_waitqueue_head(&info->close_wait);
+		init_waitqueue_head(&info->port.open_wait);
+		init_waitqueue_head(&info->port.close_wait);
@@ -2445 +2446 @@
-			info->line, info->port, info->irq);
+			info->line, info->io_port, info->irq);
@@ -2501,2 +2502,2 @@
-		if (ports->port)
-			release_region(ports->port, REGION_SIZE);
+		if (ports->io_port)
+			release_region(ports->io_port, REGION_SIZE);
--- ./projects/linux/linux-2.6.28/drivers/char/esp.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/char/esp.c	2009-03-24 00:12:14.000000000 +0100
@@ -2056,0 +2057,9 @@
+static int esp_carrier_raised(struct tty_port *port)
+{
+	struct esp_struct *info = container_of(port, struct esp_struct, port);
+	serial_out(info, UART_ESI_CMD1, ESI_GET_UART_STAT);
+	if (serial_in(info, UART_ESI_STAT2) & UART_MSR_DCD)
+		return 1;
+	return 0;
+}
+
@@ -2068,0 +2078,2 @@
+	int		cd;
+	struct tty_port *port = &info->port;
@@ -2075,3 +2086,3 @@
-	    (info->port.flags & ASYNC_CLOSING)) {
-		if (info->port.flags & ASYNC_CLOSING)
-			interruptible_sleep_on(&info->port.close_wait);
+	    (port->flags & ASYNC_CLOSING)) {
+		if (port->flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&port->close_wait);
@@ -2079 +2090 @@
-		if (info->port.flags & ASYNC_HUP_NOTIFY)
+		if (port->flags & ASYNC_HUP_NOTIFY)
@@ -2094 +2105 @@
-		info->port.flags |= ASYNC_NORMAL_ACTIVE;
+		port->flags |= ASYNC_NORMAL_ACTIVE;
@@ -2104 +2115 @@
-	 * this loop, info->port.count is dropped by one, so that
+	 * this loop, port->count is dropped by one, so that
@@ -2109 +2120 @@
-	add_wait_queue(&info->port.open_wait, &wait);
+	add_wait_queue(&port->open_wait, &wait);
@@ -2112 +2123 @@
-	       info->line, info->port.count);
+	       info->line, port->count);
@@ -2116,2 +2127,2 @@
-		info->port.count--;
-	info->port.blocked_open++;
+		port->count--;
+	port->blocked_open++;
@@ -2132 +2143 @@
-		    !(info->port.flags & ASYNC_INITIALIZED)) {
+		    !(port->flags & ASYNC_INITIALIZED)) {
@@ -2134 +2145 @@
-			if (info->port.flags & ASYNC_HUP_NOTIFY)
+			if (port->flags & ASYNC_HUP_NOTIFY)
@@ -2144,3 +2155 @@
-		serial_out(info, UART_ESI_CMD1, ESI_GET_UART_STAT);
-		if (serial_in(info, UART_ESI_STAT2) & UART_MSR_DCD)
-			do_clocal = 1;
+		cd = tty_port_carrier_raised(port);
@@ -2148 +2157 @@
-		if (!(info->port.flags & ASYNC_CLOSING) &&
+		if (!(port->flags & ASYNC_CLOSING) &&
@@ -2157 +2166 @@
-		       info->line, info->port.count);
+		       info->line, port->count);
@@ -2164 +2173 @@
-	remove_wait_queue(&info->port.open_wait, &wait);
+	remove_wait_queue(&port->open_wait, &wait);
@@ -2166,2 +2175,2 @@
-		info->port.count++;
-	info->port.blocked_open--;
+		port->count++;
+	port->blocked_open--;
@@ -2171 +2180 @@
-	       info->line, info->port.count);
+	       info->line, port->count);
@@ -2175 +2184 @@
-	info->port.flags |= ASYNC_NORMAL_ACTIVE;
+	port->flags |= ASYNC_NORMAL_ACTIVE;
@@ -2331,0 +2341,4 @@
+static const struct tty_port_operations esp_port_ops = {
+	.esp_carrier_raised,
+};
+
@@ -2417,0 +2431,2 @@
+		tty_port_init(&info->port);
+		info->port.ops = &esp_port_ops;
@@ -2440,2 +2454,0 @@
-		init_waitqueue_head(&info->port.open_wait);
-		init_waitqueue_head(&info->port.close_wait);
--- ./projects/linux/linux-2.6.29/drivers/char/esp.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/char/esp.c	2009-06-27 11:32:32.000000000 +0200
@@ -2261 +2261 @@
-static void show_serial_version(void)
+static void __init show_serial_version(void)
--- ./projects/linux/linux-2.6.17/drivers/char/ip2/ip2main.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/ip2/ip2main.c	2006-09-20 05:42:06.000000000 +0200
@@ -85 +84,0 @@
-#include <linux/config.h>
@@ -94 +92,0 @@
-#include <linux/devfs_fs_kernel.h>
@@ -238 +236 @@
-static struct file_operations ip2_ipl = {
+static const struct file_operations ip2_ipl = {
@@ -308 +306 @@
-static int __init
+static int
@@ -319 +317 @@
-static void __init
+static void
@@ -326 +324 @@
-static int __init
+static int
@@ -340 +338 @@
-static int __init
+static int
@@ -417 +414,0 @@
-			devfs_remove("ip2/ipl%d", i);
@@ -419 +415,0 @@
-			devfs_remove("ip2/stat%d", i);
@@ -428 +423,0 @@
-	devfs_remove("ip2");
@@ -499,2 +494,2 @@
-/* SA_INTERRUPT- if set blocks all interrupts else only this line */
-/* SA_SHIRQ    - for shared irq PCI or maybe EISA only */
+/* IRQF_DISABLED - if set blocks all interrupts else only this line */
+/* IRQF_SHARED    - for shared irq PCI or maybe EISA only */
@@ -678 +672,0 @@
-	ip2_tty_driver->devfs_name	    = "tts/F";
@@ -686 +680 @@
-	ip2_tty_driver->flags                = TTY_DRIVER_REAL_RAW | TTY_DRIVER_NO_DEVFS;
+	ip2_tty_driver->flags                = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
@@ -727,9 +720,0 @@
-				err = devfs_mk_cdev(MKDEV(IP2_IPL_MAJOR, 4 * i),
-						S_IRUSR | S_IWUSR | S_IRGRP | S_IFCHR,
-						"ip2/ipl%d", i);
-				if (err) {
-					class_device_destroy(ip2_class,
-						MKDEV(IP2_IPL_MAJOR, 4 * i));
-					goto out_class;
-				}
-
@@ -739,8 +723,0 @@
-				err = devfs_mk_cdev(MKDEV(IP2_IPL_MAJOR, 4 * i + 1),
-						S_IRUSR | S_IWUSR | S_IRGRP | S_IFCHR,
-						"ip2/stat%d", i);
-				if (err) {
-					class_device_destroy(ip2_class,
-						MKDEV(IP2_IPL_MAJOR, 4 * i + 1));
-					goto out_class;
-				}
@@ -779 +756 @@
-					IP2_SA_FLAGS | (ip2config.type[i] == PCI ? SA_SHIRQ : 0),
+					IP2_SA_FLAGS | (ip2config.type[i] == PCI ? IRQF_SHARED : 0),
@@ -821 +798 @@
-static void __init
+static void
@@ -964 +941 @@
-static unsigned short __init
+static unsigned short
@@ -3211,0 +3189,7 @@
+
+static struct pci_device_id ip2main_pci_tbl[] __devinitdata = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_COMPUTONE, PCI_DEVICE_ID_COMPUTONE_IP2EX) },
+	{ }
+};
+
+MODULE_DEVICE_TABLE(pci, ip2main_pci_tbl);
--- ./projects/linux/linux-2.6.18/drivers/char/ip2/ip2main.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/ip2/ip2main.c	2006-11-29 22:57:37.000000000 +0100
@@ -193 +193 @@
-static irqreturn_t ip2_interrupt(int irq, void *dev_id, struct pt_regs * regs);
+static irqreturn_t ip2_interrupt(int irq, void *dev_id);
@@ -438,0 +439 @@
+			pci_dev_put(ip2config.pci_dev[i]);
@@ -460 +461 @@
-static struct tty_operations ip2_ops = {
+static const struct tty_operations ip2_ops = {
@@ -507,0 +509 @@
+	static struct pci_dev *pci_dev_i = NULL;
@@ -591,2 +593 @@
-				struct pci_dev *pci_dev_i = NULL;
-				pci_dev_i = pci_find_device(PCI_VENDOR_ID_COMPUTONE,
+				pci_dev_i = pci_get_device(PCI_VENDOR_ID_COMPUTONE,
@@ -603 +604 @@
-					ip2config.pci_dev[i] = pci_dev_i;
+					ip2config.pci_dev[i] = pci_dev_get(pci_dev_i);
@@ -643,0 +645,3 @@
+	if (pci_dev_i)
+		pci_dev_put(pci_dev_i);
+
@@ -778,2 +781,0 @@
-out_class:
-	class_destroy(ip2_class);
@@ -1155 +1157 @@
-/* Function:   ip2_interrupt(int irq, void *dev_id, struct pt_regs * regs)    */
+/* Function:   ip2_interrupt(int irq, void *dev_id)    */
@@ -1158 +1159,0 @@
-/*             pointer to register structure                                  */
@@ -1174 +1175 @@
-ip2_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+ip2_interrupt(int irq, void *dev_id)
@@ -1238 +1239 @@
-	ip2_interrupt(0, NULL, NULL);
+	ip2_interrupt(0, NULL);
@@ -1706 +1707 @@
-	bytesSent = i2Output( pCh, pData, count, 0 );
+	bytesSent = i2Output( pCh, pData, count);
@@ -1766 +1767 @@
-		strip = i2Output( pCh, pCh->Pbuf, pCh->Pbuf_stuff, 0 );
+		strip = i2Output( pCh, pCh->Pbuf, pCh->Pbuf_stuff);
--- ./projects/linux/linux-2.6.19/drivers/char/ip2/ip2main.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/ip2/ip2main.c	2007-02-04 19:44:54.000000000 +0100
@@ -180 +180 @@
-static void ip2_set_termios(PTTY, struct termios *);
+static void ip2_set_termios(PTTY, struct ktermios *);
@@ -192 +192 @@
-static void ip2_interrupt_bh(i2eBordStrPtr pB);
+static void ip2_interrupt_bh(struct work_struct *work);
@@ -196,2 +196,2 @@
-static void do_input(void *p);
-static void do_status(void *p);
+static void do_input(struct work_struct *);
+static void do_status(struct work_struct *);
@@ -201 +201 @@
-static void set_params (i2ChanStrPtr, struct termios *);
+static void set_params (i2ChanStrPtr, struct ktermios *);
@@ -921 +921 @@
-	INIT_WORK(&pB->tqueue_interrupt, (void(*)(void*)) ip2_interrupt_bh, pB);
+	INIT_WORK(&pB->tqueue_interrupt, ip2_interrupt_bh);
@@ -1128,2 +1128,2 @@
-/* Function:   ip2_interrupt_bh(pB)                                           */
-/* Parameters: pB - pointer to the board structure                            */
+/* Function:   ip2_interrupt_bh(work)                                         */
+/* Parameters: work - pointer to the board structure                          */
@@ -1138 +1138 @@
-ip2_interrupt_bh(i2eBordStrPtr pB)
+ip2_interrupt_bh(struct work_struct *work)
@@ -1139,0 +1140 @@
+	i2eBordStrPtr pB = container_of(work, i2eBordStr, tqueue_interrupt);
@@ -1248 +1249 @@
-static void do_input(void *p)
+static void do_input(struct work_struct *work)
@@ -1250 +1251 @@
-	i2ChanStrPtr pCh = p;
+	i2ChanStrPtr pCh = container_of(work, i2ChanStr, tqueue_input);
@@ -1282 +1283 @@
-static void do_status(void *p)
+static void do_status(struct work_struct *work)
@@ -1284 +1285 @@
-	i2ChanStrPtr pCh = p;
+	i2ChanStrPtr pCh = container_of(work, i2ChanStr, tqueue_status);
@@ -2400 +2401 @@
-ip2_set_termios( PTTY tty, struct termios *old_termios )
+ip2_set_termios( PTTY tty, struct ktermios *old_termios )
@@ -2442 +2443 @@
-set_params( i2ChanStrPtr pCh, struct termios *o_tios )
+set_params( i2ChanStrPtr pCh, struct ktermios *o_tios )
@@ -2446 +2447 @@
-	struct termios dummy;
+	struct ktermios dummy;
@@ -2702 +2703 @@
-	unsigned int minor = iminor(pFile->f_dentry->d_inode);
+	unsigned int minor = iminor(pFile->f_path.dentry->d_inode);
--- ./projects/linux/linux-2.6.20/drivers/char/ip2/ip2main.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/ip2/ip2main.c	2007-04-26 05:08:32.000000000 +0200
@@ -1274,2 +1274,2 @@
-	if (tty->pgrp > 0)
-		kill_pg(tty->pgrp, sig, 1);
+	if (tty->pgrp)
+		kill_pgrp(tty->pgrp, sig, 1);
--- ./projects/linux/linux-2.6.22/drivers/char/ip2/ip2main.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/ip2/ip2main.c	2007-10-09 22:31:38.000000000 +0200
@@ -428,3 +428 @@
-	if ( ( err = unregister_chrdev ( IP2_IPL_MAJOR, pcIpl ) ) ) {
-		printk(KERN_ERR "IP2: failed to unregister IPL driver (%d)\n", err);
-	}
+	unregister_chrdev(IP2_IPL_MAJOR, pcIpl);
@@ -505 +502,0 @@
-	int status = 0;
@@ -592,0 +590,2 @@
+				int status;
+
--- ./projects/linux/linux-2.6.23/drivers/char/ip2/ip2main.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/ip2/ip2main.c	2008-01-24 23:58:37.000000000 +0100
@@ -414,2 +414,2 @@
-			class_device_destroy(ip2_class, MKDEV(IP2_IPL_MAJOR, 4 * i));
-			class_device_destroy(ip2_class, MKDEV(IP2_IPL_MAJOR, 4 * i + 1));
+			device_destroy(ip2_class, MKDEV(IP2_IPL_MAJOR, 4 * i));
+			device_destroy(ip2_class, MKDEV(IP2_IPL_MAJOR, 4 * i + 1));
@@ -622,5 +622 @@
-					if (status == PCIBIOS_DEVICE_NOT_FOUND) {
-						printk( KERN_ERR "IP2: PCI board %d not found\n", i );
-					} else {
-						printk( KERN_ERR "IP2: PCI error 0x%x \n", status );
-					}
+					printk(KERN_ERR "IP2: PCI board %d not found\n", i);
@@ -649,2 +645,2 @@
-			pB = kmalloc( sizeof(i2eBordStr), GFP_KERNEL);
-			if ( pB != NULL ) {
+			pB = kzalloc(sizeof(i2eBordStr), GFP_KERNEL);
+			if (pB) {
@@ -652 +647,0 @@
-				memset( pB, 0, sizeof(i2eBordStr) );
@@ -721 +716 @@
-				class_device_create(ip2_class, NULL,
+				device_create(ip2_class, NULL,
@@ -723,2 +718,2 @@
-						NULL, "ipl%d", i);
-				class_device_create(ip2_class, NULL,
+						"ipl%d", i);
+				device_create(ip2_class, NULL,
@@ -726 +721 @@
-						NULL, "stat%d", i);
+						"stat%d", i);
@@ -760 +755 @@
-					pcName, (void *)&pcName);
+					pcName, i2BoardPtrTable[i]);
@@ -1174,2 +1169,27 @@
-static irqreturn_t
-ip2_interrupt(int irq, void *dev_id)
+static void
+ip2_irq_work(i2eBordStrPtr pB)
+{
+#ifdef USE_IQI
+	if (NO_MAIL_HERE != ( pB->i2eStartMail = iiGetMail(pB))) {
+//		Disable his interrupt (will be enabled when serviced)
+//		This is mostly to protect from reentrancy.
+		iiDisableMailIrq(pB);
+
+//		Park the board on the immediate queue for processing.
+		schedule_work(&pB->tqueue_interrupt);
+
+//		Make sure the immediate queue is flagged to fire.
+	}
+#else
+
+//	We are using immediate servicing here.  This sucks and can
+//	cause all sorts of havoc with ppp and others.  The failsafe
+//	check on iiSendPendingMail could also throw a hairball.
+
+	i2ServiceBoard( pB );
+
+#endif /* USE_IQI */
+}
+
+static void
+ip2_polled_interrupt(void)
@@ -1179 +1199 @@
-	int handled = 0;
+	const int irq = 0;
@@ -1191,2 +1211,3 @@
-			handled = 1;
-#ifdef USE_IQI
+			ip2_irq_work(pB);
+		}
+	}
@@ -1194,4 +1215 @@
-		    if (NO_MAIL_HERE != ( pB->i2eStartMail = iiGetMail(pB))) {
-//			Disable his interrupt (will be enabled when serviced)
-//			This is mostly to protect from reentrancy.
-			iiDisableMailIrq(pB);
+	++irq_counter;
@@ -1199,2 +1217,2 @@
-//			Park the board on the immediate queue for processing.
-			schedule_work(&pB->tqueue_interrupt);
+	ip2trace (ITRC_NO_PORT, ITRC_INTR, ITRC_RETURN, 0 );
+}
@@ -1202,10 +1220,8 @@
-//			Make sure the immediate queue is flagged to fire.
-		    }
-#else
-//		We are using immediate servicing here.  This sucks and can
-//		cause all sorts of havoc with ppp and others.  The failsafe
-//		check on iiSendPendingMail could also throw a hairball.
-			i2ServiceBoard( pB );
-#endif /* USE_IQI */
-		}
-	}
+static irqreturn_t
+ip2_interrupt(int irq, void *dev_id)
+{
+	i2eBordStrPtr pB = dev_id;
+
+	ip2trace (ITRC_NO_PORT, ITRC_INTR, 99, 1, pB->i2eUsingIrq );
+
+	ip2_irq_work(pB);
@@ -1216 +1232 @@
-	return IRQ_RETVAL(handled);
+	return IRQ_HANDLED;
@@ -1239 +1255 @@
-	ip2_interrupt(0, NULL);
+	ip2_polled_interrupt();
--- ./projects/linux/linux-2.6.24/drivers/char/ip2/ip2main.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/ip2/ip2main.c	2008-04-17 04:49:44.000000000 +0200
@@ -156,3 +155,0 @@
-/* Serial subtype definitions */
-#define SERIAL_TYPE_NORMAL    1
-
@@ -1254 +1251 @@
-	// The issue of queued BH interrups is handled in ip2_interrupt().
+	// The issue of queued BH interrupts is handled in ip2_interrupt().
--- ./projects/linux/linux-2.6.25/drivers/char/ip2/ip2main.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/ip2/ip2main.c	2008-07-13 23:51:29.000000000 +0200
@@ -135,0 +136 @@
+#include <linux/seq_file.h>
@@ -137 +138 @@
-static int ip2_read_procmem(char *, char **, off_t, int);
+static const struct file_operations ip2mem_proc_fops;
@@ -171 +172 @@
-static void ip2_putchar(PTTY, unsigned char);
+static int  ip2_putchar(PTTY, unsigned char);
@@ -348,20 +348,0 @@
-/* Function:   init_module()                                                  */
-/* Parameters: None                                                           */
-/* Returns:    Success (0)                                                    */
-/*                                                                            */
-/* Description:                                                               */
-/* This is a required entry point for an installable module. It simply calls  */
-/* the driver initialisation function and returns what it returns.            */
-/******************************************************************************/
-#ifdef MODULE
-int
-init_module(void)
-{
-#ifdef IP2DEBUG_INIT
-	printk (KERN_DEBUG "Loading module ...\n" );
-#endif
-    return 0;
-}
-#endif /* MODULE */
-
-/******************************************************************************/
@@ -383,2 +364,2 @@
-void
-cleanup_module(void)
+void __exit
+ip2_cleanup_module(void)
@@ -426 +407 @@
-	remove_proc_entry("ip2mem", &proc_root);
+	remove_proc_entry("ip2mem", NULL);
@@ -453,0 +435 @@
+module_exit(ip2_cleanup_module);
@@ -698 +680 @@
-	if (!create_proc_info_entry("ip2mem",0,&proc_root,ip2_read_procmem)) {
+	if (!proc_create("ip2mem",0,NULL,&ip2mem_proc_fops)) {
@@ -779,2 +760,0 @@
-EXPORT_SYMBOL(ip2_loadmain);
-
@@ -1052 +1032 @@
-	WRITE_LOCK_IRQSAVE(&pB->write_fifo_spinlock,flags);
+	write_lock_irqsave(&pB->write_fifo_spinlock, flags);
@@ -1054 +1034 @@
-	WRITE_UNLOCK_IRQRESTORE(&pB->write_fifo_spinlock,flags);
+	write_unlock_irqrestore(&pB->write_fifo_spinlock, flags);
@@ -1072 +1052 @@
-	WRITE_LOCK_IRQSAVE(&pB->write_fifo_spinlock,flags);
+	write_lock_irqsave(&pB->write_fifo_spinlock, flags);
@@ -1074 +1054 @@
-	WRITE_UNLOCK_IRQRESTORE(&pB->write_fifo_spinlock,flags);
+	write_unlock_irqrestore(&pB->write_fifo_spinlock, flags);
@@ -1089 +1069 @@
-	WRITE_LOCK_IRQSAVE(&pB->write_fifo_spinlock,flags);
+	write_lock_irqsave(&pB->write_fifo_spinlock, flags);
@@ -1091 +1071 @@
-	WRITE_UNLOCK_IRQRESTORE(&pB->write_fifo_spinlock,flags);
+	write_unlock_irqrestore(&pB->write_fifo_spinlock, flags);
@@ -1270 +1250 @@
-		READ_LOCK_IRQSAVE(&pCh->Ibuf_spinlock,flags)
+		read_lock_irqsave(&pCh->Ibuf_spinlock, flags);
@@ -1272 +1252 @@
-			READ_UNLOCK_IRQRESTORE(&pCh->Ibuf_spinlock,flags)
+			read_unlock_irqrestore(&pCh->Ibuf_spinlock, flags);
@@ -1275 +1255 @@
-			READ_UNLOCK_IRQRESTORE(&pCh->Ibuf_spinlock,flags)
+			read_unlock_irqrestore(&pCh->Ibuf_spinlock, flags);
@@ -1616,4 +1596,2 @@
-	if ( tty->driver->flush_buffer ) 
-		tty->driver->flush_buffer(tty);
-	if ( tty->ldisc.flush_buffer )  
-		tty->ldisc.flush_buffer(tty);
+	tty_ldisc_flush(tty);
+	tty_driver_flush_buffer(tty);
@@ -1719 +1697 @@
-	WRITE_LOCK_IRQSAVE(&pCh->Pbuf_spinlock,flags);
+	write_lock_irqsave(&pCh->Pbuf_spinlock, flags);
@@ -1721 +1699 @@
-	WRITE_UNLOCK_IRQRESTORE(&pCh->Pbuf_spinlock,flags);
+	write_unlock_irqrestore(&pCh->Pbuf_spinlock, flags);
@@ -1738 +1716 @@
-static void
+static int
@@ -1746 +1724 @@
-	WRITE_LOCK_IRQSAVE(&pCh->Pbuf_spinlock,flags);
+	write_lock_irqsave(&pCh->Pbuf_spinlock, flags);
@@ -1749 +1727 @@
-		WRITE_UNLOCK_IRQRESTORE(&pCh->Pbuf_spinlock,flags);
+		write_unlock_irqrestore(&pCh->Pbuf_spinlock, flags);
@@ -1752 +1730,2 @@
-		WRITE_UNLOCK_IRQRESTORE(&pCh->Pbuf_spinlock,flags);
+		write_unlock_irqrestore(&pCh->Pbuf_spinlock, flags);
+	return 1;
@@ -1772 +1751 @@
-	WRITE_LOCK_IRQSAVE(&pCh->Pbuf_spinlock,flags);
+	write_lock_irqsave(&pCh->Pbuf_spinlock, flags);
@@ -1786 +1765 @@
-	WRITE_UNLOCK_IRQRESTORE(&pCh->Pbuf_spinlock,flags);
+	write_unlock_irqrestore(&pCh->Pbuf_spinlock, flags);
@@ -1804 +1783 @@
-	READ_LOCK_IRQSAVE(&pCh->Pbuf_spinlock,flags);
+	read_lock_irqsave(&pCh->Pbuf_spinlock, flags);
@@ -1806 +1785 @@
-	READ_UNLOCK_IRQRESTORE(&pCh->Pbuf_spinlock,flags);
+	read_unlock_irqrestore(&pCh->Pbuf_spinlock, flags);
@@ -1836 +1815 @@
-	READ_LOCK_IRQSAVE(&pCh->Obuf_spinlock,flags);
+	read_lock_irqsave(&pCh->Obuf_spinlock, flags);
@@ -1838,2 +1817,2 @@
-	READ_UNLOCK_IRQRESTORE(&pCh->Obuf_spinlock,flags);
-	READ_LOCK_IRQSAVE(&pCh->Pbuf_spinlock,flags);
+	read_unlock_irqrestore(&pCh->Obuf_spinlock, flags);
+	read_lock_irqsave(&pCh->Pbuf_spinlock, flags);
@@ -1841 +1820 @@
-	READ_UNLOCK_IRQRESTORE(&pCh->Pbuf_spinlock,flags);
+	read_unlock_irqrestore(&pCh->Pbuf_spinlock, flags);
@@ -1865 +1844 @@
-	WRITE_LOCK_IRQSAVE(&pCh->Pbuf_spinlock,flags);
+	write_lock_irqsave(&pCh->Pbuf_spinlock, flags);
@@ -1867 +1846 @@
-	WRITE_UNLOCK_IRQRESTORE(&pCh->Pbuf_spinlock,flags);
+	write_unlock_irqrestore(&pCh->Pbuf_spinlock, flags);
@@ -1953 +1932 @@
-	READ_LOCK_IRQSAVE(&pCh->Ibuf_spinlock,flags)
+	read_lock_irqsave(&pCh->Ibuf_spinlock, flags);
@@ -1955 +1934 @@
-		READ_UNLOCK_IRQRESTORE(&pCh->Ibuf_spinlock,flags)
+		read_unlock_irqrestore(&pCh->Ibuf_spinlock, flags);
@@ -1961 +1940 @@
-		READ_UNLOCK_IRQRESTORE(&pCh->Ibuf_spinlock,flags)
+		read_unlock_irqrestore(&pCh->Ibuf_spinlock, flags);
@@ -2204 +2183 @@
-		WRITE_LOCK_IRQSAVE(&pB->read_fifo_spinlock, flags);
+		write_lock_irqsave(&pB->read_fifo_spinlock, flags);
@@ -2206 +2185 @@
-		WRITE_UNLOCK_IRQRESTORE(&pB->read_fifo_spinlock, flags);
+		write_unlock_irqrestore(&pB->read_fifo_spinlock, flags);
@@ -2226 +2205 @@
-			WRITE_LOCK_IRQSAVE(&pB->read_fifo_spinlock, flags);
+			write_lock_irqsave(&pB->read_fifo_spinlock, flags);
@@ -2228 +2207 @@
-			WRITE_UNLOCK_IRQRESTORE(&pB->read_fifo_spinlock, flags);
+			write_unlock_irqrestore(&pB->read_fifo_spinlock, flags);
@@ -2266 +2245 @@
-		WRITE_LOCK_IRQSAVE(&pB->read_fifo_spinlock, flags);
+		write_lock_irqsave(&pB->read_fifo_spinlock, flags);
@@ -2268 +2247 @@
-		WRITE_UNLOCK_IRQRESTORE(&pB->read_fifo_spinlock, flags);
+		write_unlock_irqrestore(&pB->read_fifo_spinlock, flags);
@@ -2874 +2853 @@
-				rc = put_user(INB(pB->i2eStatus),
+				rc = put_user(inb(pB->i2eStatus),
@@ -2970,13 +2948,0 @@
-/******************************************************************************/
-/* Function:   ip2_read_procmem                                               */
-/* Parameters:                                                                */
-/*                                                                            */
-/* Returns: Length of output                                                  */
-/*                                                                            */
-/* Description:                                                               */
-/*   Supplies some driver operating parameters                                */
-/*	Not real useful unless your debugging the fifo							  */
-/*                                                                            */
-/******************************************************************************/
-
-#define LIMIT  (PAGE_SIZE - 120)
@@ -2985 +2951 @@
-ip2_read_procmem(char *buf, char **start, off_t offset, int len)
+proc_ip2mem_show(struct seq_file *m, void *v)
@@ -2992,2 +2957,0 @@
-	len = 0;
-
@@ -2998 +2962 @@
-	len += sprintf(buf+len,"\n");
+	seq_printf(m,"\n");
@@ -3003,2 +2967,2 @@
-			len += sprintf(buf+len,"board %d:\n",i);
-			len += sprintf(buf+len,"\tFifo rem: %d mty: %x outM %x\n",
+			seq_printf(m,"board %d:\n",i);
+			seq_printf(m,"\tFifo rem: %d mty: %x outM %x\n",
@@ -3009 +2973 @@
-	len += sprintf(buf+len,"#: tty flags, port flags,     cflags,     iflags\n");
+	seq_printf(m,"#: tty flags, port flags,     cflags,     iflags\n");
@@ -3011,2 +2974,0 @@
-		if (len > LIMIT)
-			break;
@@ -3017 +2979 @@
-				len += sprintf(buf+len,FMTLINE,i,(int)tty->flags,pCh->flags,
+				seq_printf(m,FMTLINE,i,(int)tty->flags,pCh->flags,
@@ -3020 +2982 @@
-				len += sprintf(buf+len,FMTLIN2,
+				seq_printf(m,FMTLIN2,
@@ -3022 +2984 @@
-				len += sprintf(buf+len,FMTLIN3,pCh->infl.asof,pCh->infl.room);
+				seq_printf(m,FMTLIN3,pCh->infl.asof,pCh->infl.room);
@@ -3026 +2988,6 @@
-	return len;
+	return 0;
+}
+
+static int proc_ip2mem_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, proc_ip2mem_show, NULL);
@@ -3028,0 +2996,8 @@
+static const struct file_operations ip2mem_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= proc_ip2mem_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
--- ./projects/linux/linux-2.6.26/drivers/char/ip2/ip2main.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/char/ip2/ip2main.c	2008-10-10 00:13:53.000000000 +0200
@@ -100,0 +101,3 @@
+#include <linux/smp_lock.h>
+#include <linux/firmware.h>
+#include <linux/platform_device.h>
@@ -158,3 +161 @@
-int ip2_loadmain(int *, int *, unsigned char *, int);
-static unsigned char *Fip_firmware;
-static int Fip_firmware_size;
+int ip2_loadmain(int *, int *);
@@ -205 +206 @@
-static int ip2_ipl_ioctl(struct inode *, struct file *, UINT, ULONG);
+static long ip2_ipl_ioctl(struct file *, UINT, ULONG);
@@ -211 +212 @@
-static void ip2_init_board(int);
+static void ip2_init_board(int, const struct firmware *);
@@ -238 +239 @@
-	.ioctl		= ip2_ipl_ioctl,
+	.unlocked_ioctl	= ip2_ipl_ioctl,
@@ -476,0 +478,19 @@
+
+static const struct firmware *ip2_request_firmware(void)
+{
+	struct platform_device *pdev;
+	const struct firmware *fw;
+
+	pdev = platform_device_register_simple("ip2", 0, NULL, 0);
+	if (IS_ERR(pdev)) {
+		printk(KERN_ERR "Failed to register platform device for ip2\n");
+		return NULL;
+	}
+	if (request_firmware(&fw, "intelliport2.bin", &pdev->dev)) {
+		printk(KERN_ERR "Failed to load firmware 'intelliport2.bin'\n");
+		fw = NULL;
+	}
+	platform_device_unregister(pdev);
+	return fw;
+}
+
@@ -478 +498 @@
-ip2_loadmain(int *iop, int *irqp, unsigned char *firmware, int firmsize) 
+ip2_loadmain(int *iop, int *irqp)
@@ -485,0 +506 @@
+	const struct firmware *fw = NULL;
@@ -519,3 +539,0 @@
-	Fip_firmware = firmware;
-	Fip_firmware_size = firmsize;
-
@@ -640,0 +659,2 @@
+		/* We don't want to request the firmware unless we have at
+		   least one board */
@@ -642 +662,5 @@
-			ip2_init_board( i );
+			if (!fw)
+				fw = ip2_request_firmware();
+			if (!fw)
+				break;
+			ip2_init_board(i, fw);
@@ -644,0 +669,2 @@
+	if (fw)
+		release_firmware(fw);
@@ -695,6 +721,6 @@
-				device_create(ip2_class, NULL,
-						MKDEV(IP2_IPL_MAJOR, 4 * i),
-						"ipl%d", i);
-				device_create(ip2_class, NULL,
-						MKDEV(IP2_IPL_MAJOR, 4 * i + 1),
-						"stat%d", i);
+				device_create_drvdata(ip2_class, NULL,
+						      MKDEV(IP2_IPL_MAJOR, 4 * i),
+						      NULL, "ipl%d", i);
+				device_create_drvdata(ip2_class, NULL,
+						      MKDEV(IP2_IPL_MAJOR, 4 * i + 1),
+						      NULL, "stat%d", i);
@@ -772 +798 @@
-ip2_init_board( int boardnum )
+ip2_init_board(int boardnum, const struct firmware *fw)
@@ -792 +818 @@
-	if ( iiDownloadAll ( pB, (loadHdrStrPtr)Fip_firmware, 1, Fip_firmware_size )
+	if ( iiDownloadAll ( pB, (loadHdrStrPtr)fw->data, 1, fw->size )
@@ -1265,0 +1292 @@
+	/* FIXME: This is completely bogus */
@@ -1269,2 +1296,2 @@
-		if ( tty->ldisc.flush_buffer )  
-			tty->ldisc.flush_buffer(tty);
+		if ( tty->ldisc.ops->flush_buffer )  
+			tty->ldisc.ops->flush_buffer(tty);
@@ -1319 +1346 @@
-		pCh->pTTY->ldisc.receive_buf( pCh->pTTY, &brkc, &brkf, 1 );
+		pCh->pTTY->ldisc->ops.receive_buf( pCh->pTTY, &brkc, &brkf, 1 );
@@ -2821,2 +2848,2 @@
-static int
-ip2_ipl_ioctl ( struct inode *pInode, struct file *pFile, UINT cmd, ULONG arg )
+static long
+ip2_ipl_ioctl (struct file *pFile, UINT cmd, ULONG arg )
@@ -2824 +2851 @@
-	unsigned int iplminor = iminor(pInode);
+	unsigned int iplminor = iminor(pFile->f_path.dentry->d_inode);
@@ -2834,0 +2862,2 @@
+	lock_kernel();
+
@@ -2894,0 +2924 @@
+	unlock_kernel();
@@ -2911,3 +2940,0 @@
-	unsigned int iplminor = iminor(pInode);
-	i2eBordStrPtr pB;
-	i2ChanStrPtr  pCh;
@@ -2918,29 +2945 @@
-
-	switch(iplminor) {
-	// These are the IPL devices
-	case 0:
-	case 4:
-	case 8:
-	case 12:
-		break;
-
-	// These are the status devices
-	case 1:
-	case 5:
-	case 9:
-	case 13:
-		break;
-
-	// These are the debug devices
-	case 2:
-	case 6:
-	case 10:
-	case 14:
-		pB = i2BoardPtrTable[iplminor / 4];
-		pCh = (i2ChanStrPtr) pB->i2eChannelPtr;
-		break;
-
-	// This is the trace device
-	case 3:
-		break;
-	}
+	cycle_kernel_lock();
--- ./projects/linux/linux-2.6.27/drivers/char/ip2/ip2main.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/char/ip2/ip2main.c	2008-12-25 00:26:37.000000000 +0100
@@ -153,2 +153,2 @@
-static char *pcName    = "Computone IntelliPort Plus multiport driver";
-static char *pcVersion = "1.2.14";
+static const char pcName[] = "Computone IntelliPort Plus multiport driver";
+static const char pcVersion[] = "1.2.14";
@@ -157,5 +157,2 @@
-static char *pcDriver_name   = "ip2";
-static char *pcIpl    		 = "ip2ipl";
-
-// cheezy kludge or genius - you decide?
-int ip2_loadmain(int *, int *);
+static const char pcDriver_name[] = "ip2";
+static const char pcIpl[] = "ip2ipl";
@@ -243,2 +240,2 @@
-static unsigned long irq_counter = 0;
-static unsigned long bh_counter = 0;
+static unsigned long irq_counter;
+static unsigned long bh_counter;
@@ -255 +251,0 @@
-static char  TimerOn;
@@ -271,2 +267,2 @@
-#define DBG_CNT(s) printk(KERN_DEBUG "(%s): [%x] refc=%d, ttyc=%d, modc=%x -> %s\n", \
-		    tty->name,(pCh->flags),ip2_tty_driver->refcount, \
+#define DBG_CNT(s) printk(KERN_DEBUG "(%s): [%x] ttyc=%d, modc=%x -> %s\n", \
+		    tty->name,(pCh->flags), \
@@ -289,0 +286 @@
+MODULE_LICENSE("GPL");
@@ -291 +288 @@
-static int poll_only = 0;
+static int poll_only;
@@ -299,0 +297,16 @@
+/* Note: Add compiled in defaults to these arrays, not to the structure
+	in ip2.h any longer.  That structure WILL get overridden
+	by these values, or command line values, or insmod values!!!  =mhw=
+*/
+static int io[IP2_MAX_BOARDS];
+static int irq[IP2_MAX_BOARDS] = { -1, -1, -1, -1 };
+
+MODULE_AUTHOR("Doug McNash");
+MODULE_DESCRIPTION("Computone IntelliPort Plus Driver");
+module_param_array(irq, int, NULL, 0);
+MODULE_PARM_DESC(irq, "Interrupts for IntelliPort Cards");
+module_param_array(io, int, NULL, 0);
+MODULE_PARM_DESC(io, "I/O ports for IntelliPort Cards");
+module_param(poll_only, bool, 0);
+MODULE_PARM_DESC(poll_only, "Do not use card interrupts");
+
@@ -303 +316 @@
-// Some functions to keep track of what irq's we have
+/* Some functions to keep track of what irqs we have */
@@ -305,2 +318 @@
-static int
-is_valid_irq(int irq)
+static int __init is_valid_irq(int irq)
@@ -310 +322 @@
-	while ((*i != 0) && (*i != irq)) {
+	while (*i != 0 && *i != irq)
@@ -312,2 +324,2 @@
-	}
-	return (*i);
+
+	return *i;
@@ -316,2 +328 @@
-static void
-mark_requested_irq( char irq )
+static void __init mark_requested_irq(char irq)
@@ -322,3 +333 @@
-#ifdef MODULE
-static int
-clear_requested_irq( char irq )
+static int __exit clear_requested_irq(char irq)
@@ -327 +336 @@
-	for ( i = 0; i < IP2_MAX_BOARDS; ++i ) {
+	for (i = 0; i < IP2_MAX_BOARDS; ++i) {
@@ -335 +343,0 @@
-#endif
@@ -337,2 +345 @@
-static int
-have_requested_irq( char irq )
+static int have_requested_irq(char irq)
@@ -340 +347,2 @@
-	// array init to zeros so 0 irq will not be requested as a side effect
+	/* array init to zeros so 0 irq will not be requested as a side
+	 * effect */
@@ -342 +350 @@
-	for ( i = 0; i < IP2_MAX_BOARDS; ++i ) {
+	for (i = 0; i < IP2_MAX_BOARDS; ++i)
@@ -345 +352,0 @@
-	}
@@ -364,3 +371 @@
-#ifdef MODULE
-void __exit
-ip2_cleanup_module(void)
+static void __exit ip2_cleanup_module(void)
@@ -371,8 +376 @@
-#ifdef IP2DEBUG_INIT
-	printk (KERN_DEBUG "Unloading %s: version %s\n", pcName, pcVersion );
-#endif
-	/* Stop poll timer if we had one. */
-	if ( TimerOn ) {
-		del_timer ( &PollTimer );
-		TimerOn = 0;
-	}
+	del_timer_sync(&PollTimer);
@@ -381,5 +379,3 @@
-	for( i = 0; i < IP2_MAX_BOARDS; ++i ) {
-		if ( i2BoardPtrTable[i] ) {
-			iiReset( i2BoardPtrTable[i] );
-		}
-	}
+	for (i = 0; i < IP2_MAX_BOARDS; i++)
+		if (i2BoardPtrTable[i])
+			iiReset(i2BoardPtrTable[i]);
@@ -388,3 +384,3 @@
-	for ( i = 0; i < IP2_MAX_BOARDS; ++i ) {
-		if ( i2BoardPtrTable[i] ) {
-			iiResetDelay( i2BoardPtrTable[i] );
+	for (i = 0; i < IP2_MAX_BOARDS; i++) {
+		if (i2BoardPtrTable[i]) {
+			iiResetDelay(i2BoardPtrTable[i]);
@@ -392 +388 @@
-			release_region( ip2config.addr[i], 8 );
+			release_region(ip2config.addr[i], 8);
@@ -394 +390,2 @@
-			device_destroy(ip2_class, MKDEV(IP2_IPL_MAJOR, 4 * i + 1));
+			device_destroy(ip2_class, MKDEV(IP2_IPL_MAJOR,
+						4 * i + 1));
@@ -397,3 +394,4 @@
-		if ( (ip2config.irq[i] > 0) && have_requested_irq(ip2config.irq[i]) ) {	
-			free_irq ( ip2config.irq[i], (void *)&pcName);
-			clear_requested_irq( ip2config.irq[i]);
+		if (ip2config.irq[i] > 0 &&
+				have_requested_irq(ip2config.irq[i])) {
+			free_irq(ip2config.irq[i], (void *)&pcName);
+			clear_requested_irq(ip2config.irq[i]);
@@ -403,3 +401,4 @@
-	if ( ( err = tty_unregister_driver ( ip2_tty_driver ) ) ) {
-		printk(KERN_ERR "IP2: failed to unregister tty driver (%d)\n", err);
-	}
+	err = tty_unregister_driver(ip2_tty_driver);
+	if (err)
+		printk(KERN_ERR "IP2: failed to unregister tty driver (%d)\n",
+				err);
@@ -410 +409 @@
-	// free memory
+	/* free memory */
@@ -420,2 +419,3 @@
-		if ((pB = i2BoardPtrTable[i]) != 0 ) {
-			kfree ( pB );
+		pB = i2BoardPtrTable[i];
+		if (pB != NULL) {
+			kfree(pB);
@@ -424,2 +424,2 @@
-		if ((DevTableMem[i]) != NULL ) {
-			kfree ( DevTableMem[i]  );
+		if (DevTableMem[i] != NULL) {
+			kfree(DevTableMem[i]);
@@ -429,6 +428,0 @@
-
-	/* Cleanup the iiEllis subsystem. */
-	iiEllisCleanup();
-#ifdef IP2DEBUG_INIT
-	printk (KERN_DEBUG "IP2 Unloaded\n" );
-#endif
@@ -437 +430,0 @@
-#endif /* MODULE */
@@ -497,2 +490,47 @@
-int
-ip2_loadmain(int *iop, int *irqp)
+#ifndef MODULE
+/******************************************************************************
+ *	ip2_setup:
+ *		str: kernel command line string
+ *
+ *	Can't autoprobe the boards so user must specify configuration on
+ *	kernel command line.  Sane people build it modular but the others
+ *	come here.
+ *
+ *	Alternating pairs of io,irq for up to 4 boards.
+ *		ip2=io0,irq0,io1,irq1,io2,irq2,io3,irq3
+ *
+ *		io=0 => No board
+ *		io=1 => PCI
+ *		io=2 => EISA
+ *		else => ISA I/O address
+ *
+ *		irq=0 or invalid for ISA will revert to polling mode
+ *
+ *		Any value = -1, do not overwrite compiled in value.
+ *
+ ******************************************************************************/
+static int __init ip2_setup(char *str)
+{
+	int j, ints[10];	/* 4 boards, 2 parameters + 2 */
+	unsigned int i;
+
+	str = get_options(str, ARRAY_SIZE(ints), ints);
+
+	for (i = 0, j = 1; i < 4; i++) {
+		if (j > ints[0])
+			break;
+		if (ints[j] >= 0)
+			io[i] = ints[j];
+		j++;
+		if (j > ints[0])
+			break;
+		if (ints[j] >= 0)
+			irq[i] = ints[j];
+		j++;
+	}
+	return 1;
+}
+__setup("ip2=", ip2_setup);
+#endif /* !MODULE */
+
+static int __init ip2_loadmain(void)
@@ -502 +539,0 @@
-	static int loaded;
@@ -505 +542 @@
-	static struct pci_dev *pci_dev_i = NULL;
+	struct pci_dev *pdev = NULL;
@@ -508 +545,6 @@
-	ip2trace (ITRC_NO_PORT, ITRC_INIT, ITRC_ENTER, 0 );
+	if (poll_only) {
+		/* Hard lock the interrupts to zero */
+		irq[0] = irq[1] = irq[2] = irq[3] = poll_only = 0;
+	}
+
+	ip2trace(ITRC_NO_PORT, ITRC_INIT, ITRC_ENTER, 0);
@@ -514,23 +556,19 @@
-	for ( i = 0; i < IP2_MAX_BOARDS; ++i ) {
-		if (iop) {
-			ip2config.addr[i] = iop[i];
-			if (irqp) {
-				if( irqp[i] >= 0 ) {
-					ip2config.irq[i] = irqp[i];
-				} else {
-					ip2config.irq[i] = 0;
-				}
-	// This is a little bit of a hack.  If poll_only=1 on command
-	// line back in ip2.c OR all IRQs on all specified boards are
-	// explicitly set to 0, then drop to poll only mode and override
-	// PCI or EISA interrupts.  This superceeds the old hack of
-	// triggering if all interrupts were zero (like da default).
-	// Still a hack but less prone to random acts of terrorism.
-	//
-	// What we really should do, now that the IRQ default is set
-	// to -1, is to use 0 as a hard coded, do not probe.
-	//
-	//	/\/\|=mhw=|\/\/
-				poll_only |= irqp[i];
-			}
-		}
+	for (i = 0; i < IP2_MAX_BOARDS; ++i) {
+		ip2config.addr[i] = io[i];
+		if (irq[i] >= 0)
+			ip2config.irq[i] = irq[i];
+		else
+			ip2config.irq[i] = 0;
+	/* This is a little bit of a hack.  If poll_only=1 on command
+	   line back in ip2.c OR all IRQs on all specified boards are
+	   explicitly set to 0, then drop to poll only mode and override
+	   PCI or EISA interrupts.  This superceeds the old hack of
+	   triggering if all interrupts were zero (like da default).
+	   Still a hack but less prone to random acts of terrorism.
+
+	   What we really should do, now that the IRQ default is set
+	   to -1, is to use 0 as a hard coded, do not probe.
+
+		/\/\|=mhw=|\/\/
+	*/
+		poll_only |= irq[i];
@@ -541,10 +579 @@
-	printk( KERN_INFO "%s version %s\n", pcName, pcVersion );
-
-	// ip2 can be unloaded and reloaded for no good reason
-	// we can't let that happen here or bad things happen
-	// second load hoses board but not system - fixme later
-	if (loaded) {
-		printk( KERN_INFO "Still loaded\n" );
-		return 0;
-	}
-	loaded++;
+	printk(KERN_INFO "%s version %s\n", pcName, pcVersion);
@@ -556,7 +584,0 @@
-	/* Initialise the iiEllis subsystem. */
-	iiEllisInit();
-
-	/* Initialize arrays. */
-	memset( i2BoardPtrTable, 0, sizeof i2BoardPtrTable );
-	memset( DevTable, 0, sizeof DevTable );
-
@@ -564,2 +586,2 @@
-	for ( i = 0; i < IP2_MAX_BOARDS; ++i ) {
-		switch ( ip2config.addr[i] ) { 
+	for (i = 0; i < IP2_MAX_BOARDS; ++i) {
+		switch (ip2config.addr[i]) {
@@ -570,3 +592,5 @@
-			if ( (ip2config.addr[i] < 0x100) || (ip2config.addr[i] > 0x3f8) ) {
-				printk ( KERN_ERR "IP2: Bad ISA board %d address %x\n",
-							 i, ip2config.addr[i] );
+			if (ip2config.addr[i] < 0x100 ||
+					ip2config.addr[i] > 0x3f8) {
+				printk(KERN_ERR "IP2: Bad ISA board %d "
+						"address %x\n", i,
+						ip2config.addr[i]);
@@ -574,2 +598,3 @@
-			} else {
-				ip2config.type[i] = ISA;
+				break;
+			}
+			ip2config.type[i] = ISA;
@@ -577,5 +602,8 @@
-				/* Check for valid irq argument, set for polling if invalid */
-				if (ip2config.irq[i] && !is_valid_irq(ip2config.irq[i])) {
-					printk(KERN_ERR "IP2: Bad IRQ(%d) specified\n",ip2config.irq[i]);
-					ip2config.irq[i] = 0;// 0 is polling and is valid in that sense
-				}
+			/* Check for valid irq argument, set for polling if
+			 * invalid */
+			if (ip2config.irq[i] &&
+					!is_valid_irq(ip2config.irq[i])) {
+				printk(KERN_ERR "IP2: Bad IRQ(%d) specified\n",
+						ip2config.irq[i]);
+				/* 0 is polling and is valid in that sense */
+				ip2config.irq[i] = 0;
@@ -586,25 +614,12 @@
-			{
-				int status;
-
-				pci_dev_i = pci_get_device(PCI_VENDOR_ID_COMPUTONE,
-							  PCI_DEVICE_ID_COMPUTONE_IP2EX, pci_dev_i);
-				if (pci_dev_i != NULL) {
-					unsigned int addr;
-
-					if (pci_enable_device(pci_dev_i)) {
-						printk( KERN_ERR "IP2: can't enable PCI device at %s\n",
-							pci_name(pci_dev_i));
-						break;
-					}
-					ip2config.type[i] = PCI;
-					ip2config.pci_dev[i] = pci_dev_get(pci_dev_i);
-					status =
-					pci_read_config_dword(pci_dev_i, PCI_BASE_ADDRESS_1, &addr);
-					if ( addr & 1 ) {
-						ip2config.addr[i]=(USHORT)(addr&0xfffe);
-					} else {
-						printk( KERN_ERR "IP2: PCI I/O address error\n");
-					}
-
-//		If the PCI BIOS assigned it, lets try and use it.  If we
-//		can't acquire it or it screws up, deal with it then.
+		{
+			u32 addr;
+			int status;
+
+			pdev = pci_get_device(PCI_VENDOR_ID_COMPUTONE,
+					PCI_DEVICE_ID_COMPUTONE_IP2EX, pdev);
+			if (pdev == NULL) {
+				ip2config.addr[i] = 0;
+				printk(KERN_ERR "IP2: PCI board %d not "
+						"found\n", i);
+				break;
+			}
@@ -612,9 +627,3 @@
-//					if (!is_valid_irq(pci_irq)) {
-//						printk( KERN_ERR "IP2: Bad PCI BIOS IRQ(%d)\n",pci_irq);
-//						pci_irq = 0;
-//					}
-					ip2config.irq[i] = pci_dev_i->irq;
-				} else {	// ann error
-					ip2config.addr[i] = 0;
-					printk(KERN_ERR "IP2: PCI board %d not found\n", i);
-				} 
+			if (pci_enable_device(pdev)) {
+				dev_err(&pdev->dev, "can't enable device\n");
+				break;
@@ -621,0 +631,11 @@
+			ip2config.type[i] = PCI;
+			ip2config.pci_dev[i] = pci_dev_get(pdev);
+			status = pci_read_config_dword(pdev, PCI_BASE_ADDRESS_1,
+					&addr);
+			if (addr & 1)
+				ip2config.addr[i] = (USHORT)(addr & 0xfffe);
+			else
+				dev_err(&pdev->dev, "I/O address error\n");
+
+			ip2config.irq[i] = pdev->irq;
+		}
@@ -623,3 +643,4 @@
-			printk( KERN_ERR "IP2: PCI card specified but PCI support not\n");
-			printk( KERN_ERR "IP2: configured in this kernel.\n");
-			printk( KERN_ERR "IP2: Recompile kernel with CONFIG_PCI defined!\n");
+			printk(KERN_ERR "IP2: PCI card specified but PCI "
+					"support not enabled.\n");
+			printk(KERN_ERR "IP2: Recompile kernel with CONFIG_PCI "
+					"defined!\n");
@@ -629 +650,2 @@
-			if ( (ip2config.addr[i] = find_eisa_board( Eisa_slot + 1 )) != 0) {
+			ip2config.addr[i] = find_eisa_board(Eisa_slot + 1);
+			if (ip2config.addr[i] != 0) {
@@ -637,2 +659 @@
-	if (pci_dev_i)
-		pci_dev_put(pci_dev_i);
+	pci_dev_put(pdev);
@@ -640,2 +661,2 @@
-	for ( i = 0; i < IP2_MAX_BOARDS; ++i ) {
-		if ( ip2config.addr[i] ) {
+	for (i = 0; i < IP2_MAX_BOARDS; ++i) {
+		if (ip2config.addr[i]) {
@@ -645,5 +666,6 @@
-				iiSetAddress( pB, ip2config.addr[i], ii2DelayTimer );
-				iiReset( pB );
-			} else {
-				printk(KERN_ERR "IP2: board memory allocation error\n");
-			}
+				iiSetAddress(pB, ip2config.addr[i],
+						ii2DelayTimer);
+				iiReset(pB);
+			} else
+				printk(KERN_ERR "IP2: board memory allocation "
+						"error\n");
@@ -652,3 +674,4 @@
-	for ( i = 0; i < IP2_MAX_BOARDS; ++i ) {
-		if ( ( pB = i2BoardPtrTable[i] ) != NULL ) {
-			iiResetDelay( pB );
+	for (i = 0; i < IP2_MAX_BOARDS; ++i) {
+		pB = i2BoardPtrTable[i];
+		if (pB != NULL) {
+			iiResetDelay(pB);
@@ -658 +681 @@
-	for ( i = 0; i < IP2_MAX_BOARDS; ++i ) {
+	for (i = 0; i < IP2_MAX_BOARDS; ++i) {
@@ -661 +684 @@
-		if ( i2BoardPtrTable[i] != NULL ) {
+		if (i2BoardPtrTable[i] != NULL) {
@@ -672 +695 @@
-	ip2trace (ITRC_NO_PORT, ITRC_INIT, 2, 0 );
+	ip2trace(ITRC_NO_PORT, ITRC_INIT, 2, 0);
@@ -683 +706,2 @@
-	ip2_tty_driver->flags                = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
+	ip2_tty_driver->flags                = TTY_DRIVER_REAL_RAW |
+		TTY_DRIVER_DYNAMIC_DEV;
@@ -686 +710 @@
-	ip2trace (ITRC_NO_PORT, ITRC_INIT, 3, 0 );
+	ip2trace(ITRC_NO_PORT, ITRC_INIT, 3, 0);
@@ -688,3 +712,3 @@
-	/* Register the tty devices. */
-	if ( ( err = tty_register_driver ( ip2_tty_driver ) ) ) {
-		printk(KERN_ERR "IP2: failed to register tty driver (%d)\n", err);
+	err = tty_register_driver(ip2_tty_driver);
+	if (err) {
+		printk(KERN_ERR "IP2: failed to register tty driver\n");
@@ -692,5 +716,7 @@
-		return -EINVAL;
-	} else
-	/* Register the IPL driver. */
-	if ( ( err = register_chrdev ( IP2_IPL_MAJOR, pcIpl, &ip2_ipl ) ) ) {
-		printk(KERN_ERR "IP2: failed to register IPL device (%d)\n", err );
+		return err; /* leaking resources */
+	}
+
+	err = register_chrdev(IP2_IPL_MAJOR, pcIpl, &ip2_ipl);
+	if (err) {
+		printk(KERN_ERR "IP2: failed to register IPL device (%d)\n",
+				err);
@@ -708 +734,2 @@
-	} else {
+		return -EIO; /* leaking resources */
+	}
@@ -710,4 +737,4 @@
-	ip2trace (ITRC_NO_PORT, ITRC_INIT, 4, 0 );
-		/* Register the interrupt handler or poll handler, depending upon the
-		 * specified interrupt.
-		 */
+	ip2trace(ITRC_NO_PORT, ITRC_INIT, 4, 0);
+	/* Register the interrupt handler or poll handler, depending upon the
+	 * specified interrupt.
+	 */
@@ -715,4 +742,3 @@
-		for( i = 0; i < IP2_MAX_BOARDS; ++i ) {
-			if ( 0 == ip2config.addr[i] ) {
-				continue;
-			}
+	for (i = 0; i < IP2_MAX_BOARDS; ++i) {
+		if (ip2config.addr[i] == 0)
+			continue;
@@ -720,28 +746,25 @@
-			if ( NULL != ( pB = i2BoardPtrTable[i] ) ) {
-				device_create_drvdata(ip2_class, NULL,
-						      MKDEV(IP2_IPL_MAJOR, 4 * i),
-						      NULL, "ipl%d", i);
-				device_create_drvdata(ip2_class, NULL,
-						      MKDEV(IP2_IPL_MAJOR, 4 * i + 1),
-						      NULL, "stat%d", i);
-
-			    for ( box = 0; box < ABS_MAX_BOXES; ++box )
-			    {
-			        for ( j = 0; j < ABS_BIGGEST_BOX; ++j )
-			        {
-				    if ( pB->i2eChannelMap[box] & (1 << j) )
-				    {
-				        tty_register_device(ip2_tty_driver,
-					    j + ABS_BIGGEST_BOX *
-						    (box+i*ABS_MAX_BOXES), NULL);
-			    	    }
-			        }
-			    }
-			}
-
-			if (poll_only) {
-//		Poll only forces driver to only use polling and
-//		to ignore the probed PCI or EISA interrupts.
-				ip2config.irq[i] = CIR_POLL;
-			}
-			if ( ip2config.irq[i] == CIR_POLL ) {
+		pB = i2BoardPtrTable[i];
+		if (pB != NULL) {
+			device_create(ip2_class, NULL,
+				      MKDEV(IP2_IPL_MAJOR, 4 * i),
+				      NULL, "ipl%d", i);
+			device_create(ip2_class, NULL,
+				      MKDEV(IP2_IPL_MAJOR, 4 * i + 1),
+				      NULL, "stat%d", i);
+
+			for (box = 0; box < ABS_MAX_BOXES; box++)
+				for (j = 0; j < ABS_BIGGEST_BOX; j++)
+					if (pB->i2eChannelMap[box] & (1 << j))
+						tty_register_device(
+							ip2_tty_driver,
+							j + ABS_BIGGEST_BOX *
+							(box+i*ABS_MAX_BOXES),
+							NULL);
+		}
+
+		if (poll_only) {
+			/* Poll only forces driver to only use polling and
+			   to ignore the probed PCI or EISA interrupts. */
+			ip2config.irq[i] = CIR_POLL;
+		}
+		if (ip2config.irq[i] == CIR_POLL) {
@@ -749,26 +772,3 @@
-				if (!TimerOn) {
-					PollTimer.expires = POLL_TIMEOUT;
-					add_timer ( &PollTimer );
-					TimerOn = 1;
-					printk( KERN_INFO "IP2: polling\n");
-				}
-			} else {
-				if (have_requested_irq(ip2config.irq[i]))
-					continue;
-				rc = request_irq( ip2config.irq[i], ip2_interrupt,
-					IP2_SA_FLAGS | (ip2config.type[i] == PCI ? IRQF_SHARED : 0),
-					pcName, i2BoardPtrTable[i]);
-				if (rc) {
-					printk(KERN_ERR "IP2: an request_irq failed: error %d\n",rc);
-					ip2config.irq[i] = CIR_POLL;
-					printk( KERN_INFO "IP2: Polling %ld/sec.\n",
-							(POLL_TIMEOUT - jiffies));
-					goto retry;
-				} 
-				mark_requested_irq(ip2config.irq[i]);
-				/* Initialise the interrupt handler bottom half (aka slih). */
-			}
-		}
-		for( i = 0; i < IP2_MAX_BOARDS; ++i ) {
-			if ( i2BoardPtrTable[i] ) {
-				set_irq( i, ip2config.irq[i] ); /* set and enable board interrupt */
+			if (!timer_pending(&PollTimer)) {
+				mod_timer(&PollTimer, POLL_TIMEOUT);
+				printk(KERN_INFO "IP2: polling\n");
@@ -775,0 +776,18 @@
+		} else {
+			if (have_requested_irq(ip2config.irq[i]))
+				continue;
+			rc = request_irq(ip2config.irq[i], ip2_interrupt,
+				IP2_SA_FLAGS |
+				(ip2config.type[i] == PCI ? IRQF_SHARED : 0),
+				pcName, i2BoardPtrTable[i]);
+			if (rc) {
+				printk(KERN_ERR "IP2: request_irq failed: "
+						"error %d\n", rc);
+				ip2config.irq[i] = CIR_POLL;
+				printk(KERN_INFO "IP2: Polling %ld/sec.\n",
+						(POLL_TIMEOUT - jiffies));
+				goto retry;
+			}
+			mark_requested_irq(ip2config.irq[i]);
+			/* Initialise the interrupt handler bottom half
+			 * (aka slih). */
@@ -778,2 +796,11 @@
-	ip2trace (ITRC_NO_PORT, ITRC_INIT, ITRC_RETURN, 0 );
-	goto out;
+
+	for (i = 0; i < IP2_MAX_BOARDS; ++i) {
+		if (i2BoardPtrTable[i]) {
+			/* set and enable board interrupt */
+			set_irq(i, ip2config.irq[i]);
+		}
+	}
+
+	ip2trace(ITRC_NO_PORT, ITRC_INIT, ITRC_RETURN, 0);
+
+	return 0;
@@ -783 +810 @@
-out:
+	/* unregister and put tty here */
@@ -785,0 +813 @@
+module_init(ip2_loadmain);
@@ -1202 +1229,0 @@
-	const int irq = 0;
@@ -1204 +1231 @@
-	ip2trace (ITRC_NO_PORT, ITRC_INTR, 99, 1, irq );
+	ip2trace(ITRC_NO_PORT, ITRC_INTR, 99, 1, 0);
@@ -1213 +1240 @@
-		if ( pB && (pB->i2eUsingIrq == irq) ) {
+		if (pB && pB->i2eUsingIrq == 0)
@@ -1215 +1241,0 @@
-		}
@@ -1253,2 +1278,0 @@
-	TimerOn = 0; // it's the truth but not checked in service
-
@@ -1260,3 +1284 @@
-	PollTimer.expires = POLL_TIMEOUT;
-	add_timer( &PollTimer );
-	TimerOn = 1;
+	mod_timer(&PollTimer, POLL_TIMEOUT);
@@ -2874 +2896 @@
-			rc = put_user(ip2_tty_driver->refcount, pIndex++ );
+			rc = put_user(-1, pIndex++ );
--- ./projects/linux/linux-2.6.29/drivers/char/ip2/ip2main.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/char/ip2/ip2main.c	2009-06-27 11:32:32.000000000 +0200
@@ -142 +142 @@
-static int ip2_read_proc(char *, char **, off_t, int, int *, void * );
+static const struct file_operations ip2_proc_fops;
@@ -449 +448,0 @@
-	.read_proc       = ip2_read_proc,
@@ -451,0 +451 @@
+	.proc_fops	 = &ip2_proc_fops,
@@ -3032,2 +3032 @@
-static int ip2_read_proc(char *page, char **start, off_t off,
-				int count, int *eof, void *data)
+static int ip2_proc_show(struct seq_file *m, void *v)
@@ -3036 +3034,0 @@
-	int	len = 0;
@@ -3040 +3037,0 @@
-	off_t	begin = 0;
@@ -3041,0 +3039 @@
+	char *sep;
@@ -3043,2 +3041,2 @@
-	len += sprintf(page, "ip2info: 1.0 driver: %s\n", pcVersion );
-	len += sprintf(page+len, "Driver: SMajor=%d CMajor=%d IMajor=%d MaxBoards=%d MaxBoxes=%d MaxPorts=%d\n",
+	seq_printf(m, "ip2info: 1.0 driver: %s\n", pcVersion);
+	seq_printf(m, "Driver: SMajor=%d CMajor=%d IMajor=%d MaxBoards=%d MaxBoxes=%d MaxPorts=%d\n",
@@ -3056 +3054,2 @@
-				len += sprintf( page+len, "Board %d: EX ports=", i );
+				seq_printf(m, "Board %d: EX ports=", i);
+				sep = "";
@@ -3068 +3067,2 @@
-					len += sprintf( page+len, "%d,", ports );
+					seq_printf(m, "%s%d", sep, ports);
+					sep = ",";
@@ -3071,4 +3071 @@
-
-				--len;	/* Backup over that last comma */
-
-				len += sprintf( page+len, " boxes=%d width=%d", boxes, pB->i2eDataWidth16 ? 16 : 8 );
+				seq_printf(m, " boxes=%d width=%d", boxes, pB->i2eDataWidth16 ? 16 : 8);
@@ -3078 +3075 @@
-				len += sprintf(page+len, "Board %d: ISA-4 ports=4 boxes=1", i );
+				seq_printf(m, "Board %d: ISA-4 ports=4 boxes=1", i);
@@ -3083 +3080 @@
-				len += sprintf(page+len, "Board %d: ISA-8-std ports=8 boxes=1", i );
+				seq_printf(m, "Board %d: ISA-8-std ports=8 boxes=1", i);
@@ -3088 +3085 @@
-				len += sprintf(page+len, "Board %d: ISA-8-RJ11 ports=8 boxes=1", i );
+				seq_printf(m, "Board %d: ISA-8-RJ11 ports=8 boxes=1", i);
@@ -3093 +3090 @@
-				len += sprintf(page+len, "Board %d: unknown", i );
+				seq_printf(m, "Board %d: unknown", i);
@@ -3100 +3097 @@
-			len += sprintf(page+len, "Board %d: vacant", i );
+			seq_printf(m, "Board %d: vacant", i);
@@ -3105,2 +3102,2 @@
-			len += sprintf(page+len, " minors=" );
-
+			seq_puts(m, " minors=");
+			sep = "";
@@ -3113 +3110 @@
-						len += sprintf (page+len,"%d,",
+						seq_printf(m, "%s%d", sep,
@@ -3115,0 +3113 @@
+						sep = ",";
@@ -3119,11 +3116,0 @@
-
-			page[ len - 1 ] = '\n';	/* Overwrite that last comma */
-		} else {
-			len += sprintf (page+len,"\n" );
-		}
-
-		if (len+begin > off+count)
-			break;
-		if (len+begin < off) {
-			begin += len;
-			len = 0;
@@ -3130,0 +3118 @@
+		seq_putc(m, '\n');
@@ -3131,0 +3120,2 @@
+	return 0;
+ }
@@ -3133,4 +3123,4 @@
-	if (i >= IP2_MAX_BOARDS)
-		*eof = 1;
-	if (off >= len+begin)
-		return 0;
+static int ip2_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, ip2_proc_show, NULL);
+}
@@ -3138,3 +3128,7 @@
-	*start = page + (off-begin);
-	return ((count < begin+len-off) ? count : begin+len-off);
- }
+static const struct file_operations ip2_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= ip2_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
--- ./projects/linux/linux-2.6.13/drivers/char/ip2main.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/char/ip2main.c	2005-10-28 02:02:08.000000000 +0200
@@ -123 +122,0 @@
-#include <asm/serial.h>
@@ -258 +257 @@
-static struct timer_list PollTimer = TIMER_INITIALIZER(ip2_poll, 0, 0);
+static DEFINE_TIMER(PollTimer, ip2_poll, 0, 0);
--- ./projects/linux/linux-2.6.14/drivers/char/ip2main.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/char/ip2main.c	2006-01-03 04:21:10.000000000 +0100
@@ -724,2 +724,3 @@
-				class_device_create(ip2_class, MKDEV(IP2_IPL_MAJOR,
-						4 * i), NULL, "ipl%d", i);
+				class_device_create(ip2_class, NULL,
+						MKDEV(IP2_IPL_MAJOR, 4 * i),
+						NULL, "ipl%d", i);
@@ -735,2 +736,3 @@
-				class_device_create(ip2_class, MKDEV(IP2_IPL_MAJOR,
-						4 * i + 1), NULL, "stat%d", i);
+				class_device_create(ip2_class, NULL,
+						MKDEV(IP2_IPL_MAJOR, 4 * i + 1),
+						NULL, "stat%d", i);
--- ./projects/linux/linux-2.6.15/drivers/char/ip2main.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/ip2main.c	2006-03-20 06:53:29.000000000 +0100
@@ -175 +175 @@
-static int  ip2_write(PTTY, int, const unsigned char *, int);
+static int  ip2_write(PTTY, const unsigned char *, int);
@@ -1716 +1716 @@
-ip2_write( PTTY tty, int user, const unsigned char *pData, int count)
+ip2_write( PTTY tty, const unsigned char *pData, int count)
@@ -1729 +1729 @@
-	bytesSent = i2Output( pCh, pData, count, user );
+	bytesSent = i2Output( pCh, pData, count, 0 );
@@ -2003,0 +2004 @@
+#ifdef	ENABLE_DSSNOW
@@ -2004,0 +2006 @@
+#endif
@@ -2091,0 +2094 @@
+	i2eBordStrPtr pB;
@@ -2098 +2101 @@
-	if ( pCh == NULL ) {
+	if ( pCh == NULL )
@@ -2100 +2103,2 @@
-	}
+
+	pB = pCh->pMyBord;
@@ -2209 +2213 @@
-		save_flags(flags);cli();
+		WRITE_LOCK_IRQSAVE(&pB->read_fifo_spinlock, flags);
@@ -2211 +2215 @@
-		restore_flags(flags);
+		WRITE_UNLOCK_IRQRESTORE(&pB->read_fifo_spinlock, flags);
@@ -2231 +2235 @@
-			save_flags(flags);cli();
+			WRITE_LOCK_IRQSAVE(&pB->read_fifo_spinlock, flags);
@@ -2233 +2237 @@
-			restore_flags(flags);
+			WRITE_UNLOCK_IRQRESTORE(&pB->read_fifo_spinlock, flags);
@@ -2271 +2275 @@
-		save_flags(flags);cli();
+		WRITE_LOCK_IRQSAVE(&pB->read_fifo_spinlock, flags);
@@ -2273 +2277 @@
-		restore_flags(flags);
+		WRITE_UNLOCK_IRQRESTORE(&pB->read_fifo_spinlock, flags);
@@ -2905,56 +2909,9 @@
-		if ( cmd == 1 ) {
-			rc = put_user(iiSendPendingMail, pIndex++ );
-			rc = put_user(i2InitChannels, pIndex++ );
-			rc = put_user(i2QueueNeeds, pIndex++ );
-			rc = put_user(i2QueueCommands, pIndex++ );
-			rc = put_user(i2GetStatus, pIndex++ );
-			rc = put_user(i2Input, pIndex++ );
-			rc = put_user(i2InputFlush, pIndex++ );
-			rc = put_user(i2Output, pIndex++ );
-			rc = put_user(i2FlushOutput, pIndex++ );
-			rc = put_user(i2DrainWakeup, pIndex++ );
-			rc = put_user(i2DrainOutput, pIndex++ );
-			rc = put_user(i2OutputFree, pIndex++ );
-			rc = put_user(i2StripFifo, pIndex++ );
-			rc = put_user(i2StuffFifoBypass, pIndex++ );
-			rc = put_user(i2StuffFifoFlow, pIndex++ );
-			rc = put_user(i2StuffFifoInline, pIndex++ );
-			rc = put_user(i2ServiceBoard, pIndex++ );
-			rc = put_user(serviceOutgoingFifo, pIndex++ );
-			// rc = put_user(ip2_init, pIndex++ );
-			rc = put_user(ip2_init_board, pIndex++ );
-			rc = put_user(find_eisa_board, pIndex++ );
-			rc = put_user(set_irq, pIndex++ );
-			rc = put_user(ip2_interrupt, pIndex++ );
-			rc = put_user(ip2_poll, pIndex++ );
-			rc = put_user(service_all_boards, pIndex++ );
-			rc = put_user(do_input, pIndex++ );
-			rc = put_user(do_status, pIndex++ );
-#ifndef IP2DEBUG_OPEN
-			rc = put_user(0, pIndex++ );
-#else
-			rc = put_user(open_sanity_check, pIndex++ );
-#endif
-			rc = put_user(ip2_open, pIndex++ );
-			rc = put_user(ip2_close, pIndex++ );
-			rc = put_user(ip2_hangup, pIndex++ );
-			rc = put_user(ip2_write, pIndex++ );
-			rc = put_user(ip2_putchar, pIndex++ );
-			rc = put_user(ip2_flush_chars, pIndex++ );
-			rc = put_user(ip2_write_room, pIndex++ );
-			rc = put_user(ip2_chars_in_buf, pIndex++ );
-			rc = put_user(ip2_flush_buffer, pIndex++ );
-
-			//rc = put_user(ip2_wait_until_sent, pIndex++ );
-			rc = put_user(0, pIndex++ );
-
-			rc = put_user(ip2_throttle, pIndex++ );
-			rc = put_user(ip2_unthrottle, pIndex++ );
-			rc = put_user(ip2_ioctl, pIndex++ );
-			rc = put_user(0, pIndex++ );
-			rc = put_user(get_serial_info, pIndex++ );
-			rc = put_user(set_serial_info, pIndex++ );
-			rc = put_user(ip2_set_termios, pIndex++ );
-			rc = put_user(ip2_set_line_discipline, pIndex++ );
-			rc = put_user(set_params, pIndex++ );
-		} else {
+		/*
+		 * akpm: This used to write a whole bunch of function addresses
+		 * to userspace, which generated lots of put_user() warnings.
+		 * I killed it all.  Just return "success" and don't do
+		 * anything.
+		 */
+		if (cmd == 1)
+			rc = 0;
+		else
@@ -2962,2 +2918,0 @@
-		}
-
--- ./projects/linux/linux-2.6.15/drivers/char/isicom.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/isicom.c	2006-03-20 06:53:29.000000000 +0100
@@ -23 +23 @@
- *					This is to prevent the firmware 
+ *					This is to prevent the firmware
@@ -34 +34 @@
- *					when the last port on the card is 
+ *					when the last port on the card is
@@ -38 +38 @@
- *					to  isicom_setup_port and 
+ *					to  isicom_setup_port and
@@ -42,2 +42,2 @@
- *					
- *	
+ *
+ *
@@ -45,2 +45,2 @@
- *	
- *	
+ *
+ *
@@ -53 +53 @@
- *      11/04/01  Kevin			Fixed firmware load problem with
+ *	11/04/01  Kevin			Fixed firmware load problem with
@@ -55 +55 @@
- *	
+ *
@@ -65 +65 @@
- *					info during insmod as well as module 
+ *					info during insmod as well as module
@@ -67 +67 @@
- *	
+ *
@@ -76 +76 @@
- *  	
+ *
@@ -82,7 +82,7 @@
- *  	11/02/03  ranjeeth		Added support for 230 Kbps and 460 Kbps
- *  					Baud index extended to 21
- *  	
- *  	20/03/03  ranjeeth		Made to work for Linux Advanced server.
- *  					Taken care of license warning.	
- *      
- *	10/12/03  Ravindra		Made to work for Fedora Core 1 of 
+ *	11/02/03  ranjeeth		Added support for 230 Kbps and 460 Kbps
+ *					Baud index extended to 21
+ *
+ *	20/03/03  ranjeeth		Made to work for Linux Advanced server.
+ *					Taken care of license warning.
+ *
+ *	10/12/03  Ravindra		Made to work for Fedora Core 1 of
@@ -96 +96 @@
- *	To use this driver you also need the support package. You 
+ *	To use this driver you also need the support package. You
@@ -99 +99 @@
- * 	
+ *
@@ -110 +109,0 @@
- *		Hotplug
@@ -115,0 +115 @@
+#include <linux/firmware.h>
@@ -117,0 +118 @@
+#include <linux/tty_flip.h>
@@ -123 +123,0 @@
-#include <linux/miscdevice.h>
@@ -136,0 +137,14 @@
+#define InterruptTheCard(base) outw(0, (base) + 0xc)
+#define ClearInterrupt(base) inw((base) + 0x0a)
+
+#ifdef DEBUG
+#define pr_dbg(str...) printk(KERN_DEBUG "ISICOM: " str)
+#define isicom_paranoia_check(a, b, c) __isicom_paranoia_check((a), (b), (c))
+#else
+#define pr_dbg(str...) do { } while (0)
+#define isicom_paranoia_check(a, b, c) 0
+#endif
+
+static int isicom_probe(struct pci_dev *, const struct pci_device_id *);
+static void __devexit isicom_remove(struct pci_dev *);
+
@@ -138,9 +152,9 @@
-	{ VENDOR_ID, 0x2028, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2051, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2052, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2053, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2054, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2055, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2056, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2057, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2058, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_DEVICE(VENDOR_ID, 0x2028) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2051) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2052) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2053) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2054) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2055) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2056) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2057) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2058) },
@@ -150,0 +165,7 @@
+static struct pci_driver isicom_driver = {
+	.name		= "isicom",
+	.id_table	= isicom_pci_tbl,
+	.probe		= isicom_probe,
+	.remove		= __devexit_p(isicom_remove)
+};
+
@@ -156,5 +176,0 @@
-#ifdef ISICOM_DEBUG
-static unsigned long tx_count = 0;
-#endif
-
-static int ISILoad_ioctl(struct inode *inode, struct file *filp, unsigned  int cmd, unsigned long arg);
@@ -163,4 +179 @@
-static void isicom_start(struct tty_struct * tty);
-
-static unsigned char * tmp_buf;
-static DECLARE_MUTEX(tmp_buf_sem);
+static void isicom_start(struct tty_struct *tty);
@@ -171,2 +184 @@
-	-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 16, 17,     
-	18, 19
+	-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 16, 17, 18, 19
@@ -176 +188 @@
-	unsigned short		base;
+	unsigned long		base;
@@ -180 +192 @@
-	unsigned short		port_status; /* each bit represents a single port */
+	unsigned short		port_status; /* each bit for each port */
@@ -195,3 +207,3 @@
-	unsigned short		channel;
-	unsigned short		status;
-	unsigned short		closing_wait;
+	u16			channel;
+	u16			status;
+	u16			closing_wait;
@@ -218 +230 @@
- 
+
@@ -222 +234 @@
-	unsigned short base = card->base;
+	unsigned long base = card->base;
@@ -227 +239 @@
-			return 1; 
+			return 1;
@@ -233 +245,3 @@
-	printk(KERN_WARNING "ISICOM: Failed to lock Card (0x%x)\n", card->base);
+	printk(KERN_WARNING "ISICOM: Failed to lock Card (0x%lx)\n",
+		card->base);
+
@@ -240 +254 @@
-	unsigned short 		base = card->base;
+	unsigned long base = card->base;
@@ -246 +260 @@
-			return 1; 
+			return 1;
@@ -262,2 +276,2 @@
- 
-static void raise_dtr(struct isi_port * port)
+
+static void raise_dtr(struct isi_port *port)
@@ -265,3 +279,3 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -272 +286 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -279,5 +293,5 @@
-static inline void drop_dtr(struct isi_port * port)
-{	
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+static inline void drop_dtr(struct isi_port *port)
+{
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -288 +302 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -290 +304 @@
-	InterruptTheCard(base);	
+	InterruptTheCard(base);
@@ -295 +309 @@
-static inline void raise_rts(struct isi_port * port)
+static inline void raise_rts(struct isi_port *port)
@@ -297,3 +311,3 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -304 +318 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -306 +320 @@
-	InterruptTheCard(base);	
+	InterruptTheCard(base);
@@ -310 +324 @@
-static inline void drop_rts(struct isi_port * port)
+static inline void drop_rts(struct isi_port *port)
@@ -312,3 +326,3 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -319 +333 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -321 +335 @@
-	InterruptTheCard(base);	
+	InterruptTheCard(base);
@@ -326 +340 @@
-static inline void raise_dtr_rts(struct isi_port * port)
+static inline void raise_dtr_rts(struct isi_port *port)
@@ -328,3 +342,3 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -335 +349 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -342 +356 @@
-static void drop_dtr_rts(struct isi_port * port)
+static void drop_dtr_rts(struct isi_port *port)
@@ -344,3 +358,3 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -351 +365 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -353 +367 @@
-	InterruptTheCard(base);	
+	InterruptTheCard(base);
@@ -358 +372 @@
-static inline void kill_queue(struct isi_port * port, short queue)
+static inline void kill_queue(struct isi_port *port, short queue)
@@ -360,3 +374,3 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -367 +381 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -369 +383 @@
-	InterruptTheCard(base);	
+	InterruptTheCard(base);
@@ -373,229 +386,0 @@
-
-/* 
- *  Firmware loader driver specific routines. This needs to mostly die
- *  and be replaced with request_firmware.
- */
-
-static struct file_operations ISILoad_fops = {
-	.owner		= THIS_MODULE,
-	.ioctl		= ISILoad_ioctl,
-};
-
-static struct miscdevice isiloader_device = {
-	ISILOAD_MISC_MINOR, "isictl", &ISILoad_fops
-};
-
- 
-static inline int WaitTillCardIsFree(unsigned short base)
-{
-	unsigned long count=0;
-	while( (!(inw(base+0xe) & 0x1)) && (count++ < 6000000));
-	if (inw(base+0xe)&0x1)  
-		return 0;
-	else
-		return 1;
-}
-
-static int ISILoad_ioctl(struct inode *inode, struct file *filp,
-		         unsigned int cmd, unsigned long arg)
-{
-	unsigned int card, i, j, signature, status, portcount = 0;
-	unsigned long t;
-	unsigned short word_count, base;
-	bin_frame frame;
-	void __user *argp = (void __user *)arg;
-	/* exec_record exec_rec; */
-	
-	if(get_user(card, (int __user *)argp))
-		return -EFAULT;
-		
-	if(card < 0 || card >= BOARD_COUNT)
-		return -ENXIO;
-		
-	base=isi_card[card].base;
-	
-	if(base==0)
-		return -ENXIO;	/* disabled or not used */
-	
-	switch(cmd) {
-		case MIOCTL_RESET_CARD:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EPERM;
-			printk(KERN_DEBUG "ISILoad:Resetting Card%d at 0x%x ",card+1,base);
-								
-			inw(base+0x8);
-			
-			for(t=jiffies+HZ/100;time_before(jiffies, t););
-				
-			outw(0,base+0x8); /* Reset */
-			
-			for(j=1;j<=3;j++) {
-				for(t=jiffies+HZ;time_before(jiffies, t););
-				printk(".");
-			}	
-			signature=(inw(base+0x4)) & 0xff;	
-			if (isi_card[card].isa) {
-					
-				if (!(inw(base+0xe) & 0x1) || (inw(base+0x2))) {
-#ifdef ISICOM_DEBUG				
-					printk("\nbase+0x2=0x%x , base+0xe=0x%x",inw(base+0x2),inw(base+0xe));
-#endif				
-					printk("\nISILoad:ISA Card%d reset failure (Possible bad I/O Port Address 0x%x).\n",card+1,base);
-					return -EIO;					
-				}
-			}	
-			else {
-				portcount = inw(base+0x2);
-				if (!(inw(base+0xe) & 0x1) || ((portcount!=0) && (portcount!=4) && (portcount!=8))) {	
-#ifdef ISICOM_DEBUG
-					printk("\nbase+0x2=0x%x , base+0xe=0x%x",inw(base+0x2),inw(base+0xe));
-#endif
-					printk("\nISILoad:PCI Card%d reset failure (Possible bad I/O Port Address 0x%x).\n",card+1,base);
-					return -EIO;
-				}
-			}	
-			switch(signature) {
-			case	0xa5:
-			case	0xbb:
-			case	0xdd:	
-					if (isi_card[card].isa) 
-						isi_card[card].port_count = 8;
-					else {
-						if (portcount == 4)
-							isi_card[card].port_count = 4;
-						else
-							isi_card[card].port_count = 8;
-					}	
-				     	isi_card[card].shift_count = 12;
-				     	break;
-				        
-			case	0xcc:	isi_card[card].port_count = 16;
-					isi_card[card].shift_count = 11;
-					break;  			
-					
-			default: printk("ISILoad:Card%d reset failure (Possible bad I/O Port Address 0x%x).\n",card+1,base);
-#ifdef ISICOM_DEBUG			
-				 printk("Sig=0x%x\n",signature);
-#endif				 
-				 return -EIO;
-			}
-			printk("-Done\n");
-			return put_user(signature,(unsigned __user *)argp);
-						
-	case	MIOCTL_LOAD_FIRMWARE:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EPERM;
-				
-			if(copy_from_user(&frame, argp, sizeof(bin_frame)))
-				return -EFAULT;
-			
-			if (WaitTillCardIsFree(base))
-				return -EIO;
-			
-			outw(0xf0,base);	/* start upload sequence */ 
-			outw(0x00,base);
-			outw((frame.addr), base);/*      lsb of adderess    */
-			
-			word_count=(frame.count >> 1) + frame.count % 2;
-			outw(word_count, base);
-			InterruptTheCard(base);
-			
-			for(i=0;i<=0x2f;i++);	/* a wee bit of delay */
-			
-			if (WaitTillCardIsFree(base)) 
-				return -EIO;
-				
-			if ((status=inw(base+0x4))!=0) {
-				printk(KERN_WARNING "ISILoad:Card%d rejected load header:\nAddress:0x%x \nCount:0x%x \nStatus:0x%x \n", 
-				card+1, frame.addr, frame.count, status);
-				return -EIO;
-			}
-			outsw(base, (void *) frame.bin_data, word_count);
-			
-			InterruptTheCard(base);
-			
-			for(i=0;i<=0x0f;i++);	/* another wee bit of delay */ 
-			
-			if (WaitTillCardIsFree(base)) 
-				return -EIO;
-				
-			if ((status=inw(base+0x4))!=0) {
-				printk(KERN_ERR "ISILoad:Card%d got out of sync.Card Status:0x%x\n",card+1, status);
-				return -EIO;
-			}	
-			return 0;
-						
-	case	MIOCTL_READ_FIRMWARE:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EPERM;
-				
-			if(copy_from_user(&frame, argp, sizeof(bin_header)))
-				return -EFAULT;
-			
-			if (WaitTillCardIsFree(base))
-				return -EIO;
-			
-			outw(0xf1,base);	/* start download sequence */ 
-			outw(0x00,base);
-			outw((frame.addr), base);/*      lsb of adderess    */
-			
-			word_count=(frame.count >> 1) + frame.count % 2;
-			outw(word_count+1, base);
-			InterruptTheCard(base);
-			
-			for(i=0;i<=0xf;i++);	/* a wee bit of delay */
-			
-			if (WaitTillCardIsFree(base)) 
-				return -EIO;
-				
-			if ((status=inw(base+0x4))!=0) {
-				printk(KERN_WARNING "ISILoad:Card%d rejected verify header:\nAddress:0x%x \nCount:0x%x \nStatus:0x%x \n", 
-				card+1, frame.addr, frame.count, status);
-				return -EIO;
-			}
-			
-			inw(base);
-			insw(base, frame.bin_data, word_count);
-			InterruptTheCard(base);
-			
-			for(i=0;i<=0x0f;i++);	/* another wee bit of delay */ 
-			
-			if (WaitTillCardIsFree(base)) 
-				return -EIO;
-				
-			if ((status=inw(base+0x4))!=0) {
-				printk(KERN_ERR "ISILoad:Card%d verify got out of sync.Card Status:0x%x\n",card+1, status);
-				return -EIO;
-			}	
-			
-			if(copy_to_user(argp, &frame, sizeof(bin_frame)))
-				return -EFAULT;
-			return 0;
-	
-	case	MIOCTL_XFER_CTRL:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EPERM;
-			if (WaitTillCardIsFree(base)) 
-				return -EIO;
-					
-			outw(0xf2, base);
-			outw(0x800, base);
-			outw(0x0, base);
-			outw(0x0, base);
-			InterruptTheCard(base);
-			outw(0x0, base+0x4);    /* for ISI4608 cards */
-							
-			isi_card[card].status |= FIRMWARE_LOADED;
-			return 0;	
-			
-	default:
-#ifdef ISICOM_DEBUG	
-		printk(KERN_DEBUG "ISILoad: Received Ioctl cmd 0x%x.\n", cmd); 
-#endif
-		return -ENOIOCTLCMD;
-	
-	}
-	
-}
-		        	
-
@@ -606,9 +391,4 @@
- 
-static inline int isicom_paranoia_check(struct isi_port const * port, char *name, 
-					const char * routine)
-{
-#ifdef ISICOM_DEBUG 
-	static const char * badmagic = 
-			KERN_WARNING "ISICOM: Warning: bad isicom magic for dev %s in %s.\n";
-	static const char * badport = 
-			KERN_WARNING "ISICOM: Warning: NULL isicom port for dev %s in %s.\n";		
+
+static inline int __isicom_paranoia_check(struct isi_port const *port,
+	char *name, const char *routine)
+{
@@ -616 +396,2 @@
-		printk(badport, name, routine);
+		printk(KERN_WARNING "ISICOM: Warning: bad isicom magic for "
+			"dev %s in %s.\n", name, routine);
@@ -620 +401,2 @@
-		printk(badmagic, name, routine);
+		printk(KERN_WARNING "ISICOM: Warning: NULL isicom port for "
+			"dev %s in %s.\n", name, routine);
@@ -622,2 +404,2 @@
-	}	
-#endif	
+	}
+
@@ -626 +408 @@
-			
+
@@ -628 +410 @@
- *	Transmitter. 
+ *	Transmitter.
@@ -638,7 +420,3 @@
-	struct isi_port * port;
-	struct tty_struct * tty;
-	
-#ifdef ISICOM_DEBUG
-	++tx_count;
-#endif	
-	
+	struct isi_port *port;
+	struct tty_struct *tty;
+
@@ -648 +426 @@
-		if (isi_card[card].status & BOARD_ACTIVE) 
+		if (isi_card[card].status & BOARD_ACTIVE)
@@ -650 +428 @@
-		card = (card + 1) & 0x0003;	
+		card = (card + 1) & 0x0003;
@@ -654 +432 @@
-		
+
@@ -656 +434 @@
-	
+
@@ -665 +443 @@
-		 	!(port->status & ISI_TXOK))
+				!(port->status & ISI_TXOK))
@@ -668 +446 @@
-		
+
@@ -670,3 +448,3 @@
-		
-		
-		if(tty == NULL) {
+
+
+		if (tty == NULL) {
@@ -676 +454 @@
-		
+
@@ -684 +462 @@
-			continue;		
+			continue;
@@ -686,6 +464,4 @@
-#ifdef ISICOM_DEBUG
-		printk(KERN_DEBUG "ISICOM: txing %d bytes, port%d.\n", 
-				txcount, port->channel+1); 
-#endif	
-		outw((port->channel << isi_card[card].shift_count) | txcount
-					, base);
+		pr_dbg("txing %d bytes, port%d.\n", txcount,
+			port->channel + 1);
+		outw((port->channel << isi_card[card].shift_count) | txcount,
+			base);
@@ -693 +469 @@
-		wrd = 0;			
+		wrd = 0;
@@ -695 +471,2 @@
-			cnt = min_t(int, txcount, (SERIAL_XMIT_SIZE - port->xmit_tail));
+			cnt = min_t(int, txcount, (SERIAL_XMIT_SIZE
+					- port->xmit_tail));
@@ -699,2 +476,4 @@
-					wrd |= (port->xmit_buf[port->xmit_tail] << 8);
-					port->xmit_tail = (port->xmit_tail + 1) & (SERIAL_XMIT_SIZE - 1);
+					wrd |= (port->xmit_buf[port->xmit_tail]
+									<< 8);
+					port->xmit_tail = (port->xmit_tail + 1)
+						& (SERIAL_XMIT_SIZE - 1);
@@ -704,3 +483,2 @@
-					outw(wrd, base);			
-				}
-				else {
+					outw(wrd, base);
+				} else {
@@ -710 +488 @@
-			}		
+			}
@@ -713,3 +491,3 @@
-			outsw(base, port->xmit_buf+port->xmit_tail, word_count);
-			port->xmit_tail = (port->xmit_tail + (word_count << 1)) &
-						(SERIAL_XMIT_SIZE - 1);
+			outsw(base, port->xmit_buf+port->xmit_tail,word_count);
+			port->xmit_tail = (port->xmit_tail
+				+ (word_count << 1)) & (SERIAL_XMIT_SIZE - 1);
@@ -721 +499,2 @@
-				port->xmit_tail = (port->xmit_tail + 1) & (SERIAL_XMIT_SIZE - 1);
+				port->xmit_tail = (port->xmit_tail + 1)
+					& (SERIAL_XMIT_SIZE - 1);
@@ -733 +512,8 @@
-	}	
+	}
+
+	/*	schedule another tx for hopefully in about 10ms	*/
+sched_again:
+	if (!re_schedule) {
+		re_schedule = 2;
+ 		return;
+	}
@@ -735,4 +520,0 @@
-	/*	schedule another tx for hopefully in about 10ms	*/	
-sched_again:	
-	if (!re_schedule)	
-		return;
@@ -744,4 +526,4 @@
-	
-	return;	
-}		
- 
+
+	return;
+}
+
@@ -750,2 +532,2 @@
- 
-static void isicom_bottomhalf(void * data)
+
+static void isicom_bottomhalf(void *data)
@@ -753,3 +535,3 @@
-	struct isi_port * port = (struct isi_port *) data;
-	struct tty_struct * tty = port->tty;
-	
+	struct isi_port *port = (struct isi_port *) data;
+	struct tty_struct *tty = port->tty;
+
@@ -759 +541 @@
-	tty_wakeup(tty);	
+	tty_wakeup(tty);
@@ -761,2 +543,2 @@
-} 		
- 		
+}
+
@@ -764 +546 @@
- *	Main interrupt handler routine 
+ *	Main interrupt handler routine
@@ -766,9 +548,8 @@
- 
-static irqreturn_t isicom_interrupt(int irq, void *dev_id,
-					struct pt_regs *regs)
-{
-	struct isi_board * card;
-	struct isi_port * port;
-	struct tty_struct * tty;
-	unsigned short base, header, word_count, count;
-	unsigned char channel;
+
+static irqreturn_t isicom_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct isi_board *card = dev_id;
+	struct isi_port *port;
+	struct tty_struct *tty;
+	unsigned long base;
+	u16 header, word_count, count, channel;
@@ -776,2 +557 @@
-	
-	card = (struct isi_board *) dev_id;
+	unsigned char *rp;
@@ -781 +561 @@
-	
+
@@ -784 +564 @@
-	
+
@@ -787,2 +567,2 @@
-		 *      disable any interrupts from the PCI card and lower the
-		 *      interrupt line
+		 * disable any interrupts from the PCI card and lower the
+		 * interrupt line
@@ -793 +573 @@
-	
+
@@ -800,2 +580,2 @@
-		printk(KERN_WARNING "ISICOM: isicom_interrupt(0x%x): %d(channel) > port_count.\n",
-				base, channel+1);
+		printk(KERN_WARNING "ISICOM: isicom_interrupt(0x%lx): "
+			"%d(channel) > port_count.\n", base, channel+1);
@@ -805 +585 @@
-			outw(0x0000, base+0x04); /* enable interrupts */		
+			outw(0x0000, base+0x04); /* enable interrupts */
@@ -807 +587 @@
-		return IRQ_HANDLED;			
+		return IRQ_HANDLED;
@@ -816,2 +596,2 @@
-	}	
-		
+	}
+
@@ -834 +614 @@
-	
+
@@ -838,28 +618,7 @@
-			case 0:	/* Change in EIA signals */
-				
-				if (port->flags & ASYNC_CHECK_CD) {
-					if (port->status & ISI_DCD) {
-						if (!(header & ISI_DCD)) {
-						/* Carrier has been lost  */
-#ifdef ISICOM_DEBUG						
-							printk(KERN_DEBUG "ISICOM: interrupt: DCD->low.\n");
-#endif							
-							port->status &= ~ISI_DCD;
-							schedule_work(&port->hangup_tq);
-						}
-					}
-					else {
-						if (header & ISI_DCD) {
-						/* Carrier has been detected */
-#ifdef ISICOM_DEBUG
-							printk(KERN_DEBUG "ISICOM: interrupt: DCD->high.\n");
-#endif							
-							port->status |= ISI_DCD;
-							wake_up_interruptible(&port->open_wait);
-						}
-					}
-				}
-				else {
-					if (header & ISI_DCD) 
-						port->status |= ISI_DCD;
-					else
+		case 0:	/* Change in EIA signals */
+			if (port->flags & ASYNC_CHECK_CD) {
+				if (port->status & ISI_DCD) {
+					if (!(header & ISI_DCD)) {
+					/* Carrier has been lost  */
+						pr_dbg("interrupt: DCD->low.\n"
+							);
@@ -867,17 +626 @@
-				}	
-				
-				if (port->flags & ASYNC_CTS_FLOW) {
-					if (port->tty->hw_stopped) {
-						if (header & ISI_CTS) {
-							port->tty->hw_stopped = 0;
-							/* start tx ing */
-							port->status |= (ISI_TXOK | ISI_CTS);
-							schedule_work(&port->bh_tqueue);
-						}
-					}
-					else {
-						if (!(header & ISI_CTS)) {
-							port->tty->hw_stopped = 1;
-							/* stop tx ing */
-							port->status &= ~(ISI_TXOK | ISI_CTS);
-						}
+						schedule_work(&port->hangup_tq);
@@ -884,0 +628,5 @@
+				} else if (header & ISI_DCD) {
+				/* Carrier has been detected */
+					pr_dbg("interrupt: DCD->high.\n");
+					port->status |= ISI_DCD;
+					wake_up_interruptible(&port->open_wait);
@@ -886,9 +634,3 @@
-				else {
-					if (header & ISI_CTS) 
-						port->status |= ISI_CTS;
-					else
-						port->status &= ~ISI_CTS;
-				}
-				
-				if (header & ISI_DSR) 
-					port->status |= ISI_DSR;
+			} else {
+				if (header & ISI_DCD)
+					port->status |= ISI_DCD;
@@ -896,4 +638,20 @@
-					port->status &= ~ISI_DSR;
-				
-				if (header & ISI_RI) 
-					port->status |= ISI_RI;
+					port->status &= ~ISI_DCD;
+			}
+
+			if (port->flags & ASYNC_CTS_FLOW) {
+				if (port->tty->hw_stopped) {
+					if (header & ISI_CTS) {
+						port->tty->hw_stopped = 0;
+						/* start tx ing */
+						port->status |= (ISI_TXOK
+							| ISI_CTS);
+						schedule_work(&port->bh_tqueue);
+					}
+				} else if (!(header & ISI_CTS)) {
+					port->tty->hw_stopped = 1;
+					/* stop tx ing */
+					port->status &= ~(ISI_TXOK | ISI_CTS);
+				}
+			} else {
+				if (header & ISI_CTS)
+					port->status |= ISI_CTS;
@@ -901,30 +659,34 @@
-					port->status &= ~ISI_RI;						
-				
-				break;
-				
-			case 1:	/* Received Break !!!	 */
-				if (tty->flip.count >= TTY_FLIPBUF_SIZE)
-					break;
-				*tty->flip.flag_buf_ptr++ = TTY_BREAK;
-				*tty->flip.char_buf_ptr++ = 0;
-				tty->flip.count++;
-				if (port->flags & ASYNC_SAK)
-					do_SAK(tty);
-				schedule_delayed_work(&tty->flip.work, 1);
-				break;
-				
-			case 2:	/* Statistics		 */
-				printk(KERN_DEBUG "ISICOM: isicom_interrupt: stats!!!.\n");			
-				break;
-				
-			default:
-				printk(KERN_WARNING "ISICOM: Intr: Unknown code in status packet.\n");
-				break;
-		}	 
-	}
-	else {				/* Data   Packet */
-		count = min_t(unsigned short, byte_count, (TTY_FLIPBUF_SIZE - tty->flip.count));
-#ifdef ISICOM_DEBUG
-		printk(KERN_DEBUG "ISICOM: Intr: Can rx %d of %d bytes.\n", 
-					count, byte_count);
-#endif			
+					port->status &= ~ISI_CTS;
+			}
+
+			if (header & ISI_DSR)
+				port->status |= ISI_DSR;
+			else
+				port->status &= ~ISI_DSR;
+
+			if (header & ISI_RI)
+				port->status |= ISI_RI;
+			else
+				port->status &= ~ISI_RI;
+
+			break;
+
+		case 1:	/* Received Break !!! */
+			tty_insert_flip_char(tty, 0, TTY_BREAK);
+			if (port->flags & ASYNC_SAK)
+				do_SAK(tty);
+			tty_flip_buffer_push(tty);
+			break;
+
+		case 2:	/* Statistics		 */
+			pr_dbg("isicom_interrupt: stats!!!.\n");
+			break;
+
+		default:
+			pr_dbg("Intr: Unknown code in status packet.\n");
+			break;
+		}
+	} else {				/* Data   Packet */
+
+		count = tty_prepare_flip_string(tty, &rp, byte_count & ~1);
+		pr_dbg("Intr: Can rx %d of %d bytes.\n", count, byte_count);
@@ -932,2 +694 @@
-		insw(base, tty->flip.char_buf_ptr, word_count);
-		tty->flip.char_buf_ptr += (word_count << 1);		
+		insw(base, rp, word_count);
@@ -936 +697,2 @@
-			*tty->flip.char_buf_ptr++ = (char)(inw(base) & 0xff);
+			tty_insert_flip_char(tty,  inw(base) & 0xff,
+				TTY_NORMAL);
@@ -938,5 +700 @@
-		}	
-		memset(tty->flip.flag_buf_ptr, 0, count);
-		tty->flip.flag_buf_ptr += count;
-		tty->flip.count += count;
-		
+		}
@@ -944,2 +702,2 @@
-			printk(KERN_DEBUG "ISICOM: Intr(0x%x:%d): Flip buffer overflow! dropping bytes...\n",
-					base, channel+1);
+			pr_dbg("Intr(0x%lx:%d): Flip buffer overflow! dropping "
+				"bytes...\n", base, channel + 1);
@@ -951 +709 @@
-		schedule_delayed_work(&tty->flip.work, 1);
+		tty_flip_buffer_push(tty);
@@ -956 +714,2 @@
-		outw(0x0000, base+0x04); /* enable interrupts */	
+		outw(0x0000, base+0x04); /* enable interrupts */
+
@@ -958 +717 @@
-} 
+}
@@ -960 +719 @@
-static void isicom_config_port(struct isi_port * port)
+static void isicom_config_port(struct isi_port *port)
@@ -962,2 +721,2 @@
-	struct isi_board * card = port->card;
-	struct tty_struct * tty;
+	struct isi_board *card = port->card;
+	struct tty_struct *tty;
@@ -965,2 +724,3 @@
-	unsigned short channel_setup, base = card->base;
-	unsigned short channel = port->channel, shift_count = card->shift_count;
+	unsigned long base = card->base;
+	u16 channel_setup, channel = port->channel,
+		shift_count = card->shift_count;
@@ -968 +728 @@
-	
+
@@ -974 +734 @@
-		
+
@@ -978,2 +738,2 @@
-		 */   
-		 
+		 */
+
@@ -984 +744 @@
-	}	
+	}
@@ -986,2 +746,2 @@
-	
-		/*  the ASYNC_SPD_HI and ASYNC_SPD_VHI options are set 
+
+		/*  the ASYNC_SPD_HI and ASYNC_SPD_VHI options are set
@@ -990,2 +750,2 @@
-		 */  
-			
+		 */
+
@@ -993 +753 @@
-			baud++;     /*  57.6 Kbps */
+			baud++; /*  57.6 Kbps */
@@ -995 +755 @@
-			baud +=2;   /*  115  Kbps */	 
+			baud +=2; /*  115  Kbps */
@@ -999,4 +759,4 @@
-	 	drop_dtr(port);
-	 	return;
-	}	
-	else  
+		drop_dtr(port);
+		return;
+	}
+	else
@@ -1004 +764 @@
-		
+
@@ -1010,12 +770,12 @@
-			case CS5:
-				channel_setup |= ISICOM_CS5;
-				break;
-			case CS6:
-				channel_setup |= ISICOM_CS6;
-				break;
-			case CS7:
-				channel_setup |= ISICOM_CS7;
-				break;
-			case CS8:
-				channel_setup |= ISICOM_CS8;
-				break;
+		case CS5:
+			channel_setup |= ISICOM_CS5;
+			break;
+		case CS6:
+			channel_setup |= ISICOM_CS6;
+			break;
+		case CS7:
+			channel_setup |= ISICOM_CS7;
+			break;
+		case CS8:
+			channel_setup |= ISICOM_CS8;
+			break;
@@ -1023 +783 @@
-			
+
@@ -1029 +789 @@
-				channel_setup |= ISICOM_ODPAR;	
+				channel_setup |= ISICOM_ODPAR;
@@ -1031 +791 @@
-		outw(channel_setup, base);	
+		outw(channel_setup, base);
@@ -1033,2 +793,2 @@
-		unlock_card(card);	
-	}	
+		unlock_card(card);
+	}
@@ -1038,2 +798,2 @@
-		port->flags |= ASYNC_CHECK_CD;	
-	
+		port->flags |= ASYNC_CHECK_CD;
+
@@ -1046,2 +806,2 @@
-	}	
-	if (I_IXON(tty))	
+	}
+	if (I_IXON(tty))
@@ -1050,2 +810,2 @@
-		flow_ctrl |= ISICOM_INITIATE_XONXOFF;	
-		
+		flow_ctrl |= ISICOM_INITIATE_XONXOFF;
+
@@ -1059 +819 @@
-	
+
@@ -1066,2 +825,0 @@
- 
-/* open et all */ 
@@ -1069 +827,3 @@
-static inline void isicom_setup_board(struct isi_board * bp)
+/* open et all */
+
+static inline void isicom_setup_board(struct isi_board *bp)
@@ -1072 +832 @@
-	struct isi_port * port;
+	struct isi_port *port;
@@ -1074 +834 @@
-	
+
@@ -1083 +843 @@
-	for(channel = 0; channel < bp->port_count; channel++, port++)
+	for (channel = 0; channel < bp->port_count; channel++, port++)
@@ -1087,2 +847,2 @@
- 
-static int isicom_setup_port(struct isi_port * port)
+
+static int isicom_setup_port(struct isi_port *port)
@@ -1090 +850 @@
-	struct isi_board * card = port->card;
+	struct isi_board *card = port->card;
@@ -1092 +852 @@
-	
+
@@ -1098 +858 @@
-		
+
@@ -1101 +861 @@
-		
+
@@ -1106,2 +866,2 @@
-		port->xmit_buf = (unsigned char *) page;	
-	}	
+		port->xmit_buf = (unsigned char *) page;
+	}
@@ -1114 +874 @@
-		
+
@@ -1116 +876 @@
-	
+
@@ -1119 +879 @@
-	
+
@@ -1123,5 +883,6 @@
-	
-	return 0;		
-} 
- 
-static int block_til_ready(struct tty_struct * tty, struct file * filp, struct isi_port * port) 
+
+	return 0;
+}
+
+static int block_til_ready(struct tty_struct *tty, struct file *filp,
+	struct isi_port *port)
@@ -1129 +890 @@
-	struct isi_board * card = port->card;
+	struct isi_board *card = port->card;
@@ -1137,3 +898 @@
-#ifdef ISICOM_DEBUG	
-		printk(KERN_DEBUG "ISICOM: block_til_ready: close in progress.\n");
-#endif		
+		pr_dbg("block_til_ready: close in progress.\n");
@@ -1146 +905 @@
-	
+
@@ -1148,5 +907,4 @@
-	
-	if ((filp->f_flags & O_NONBLOCK) || (tty->flags & (1 << TTY_IO_ERROR))) {
-#ifdef ISICOM_DEBUG	
-		printk(KERN_DEBUG "ISICOM: block_til_ready: non-block mode.\n");
-#endif		
+
+	if ((filp->f_flags & O_NONBLOCK) ||
+			(tty->flags & (1 << TTY_IO_ERROR))) {
+		pr_dbg("block_til_ready: non-block mode.\n");
@@ -1154,3 +912,3 @@
-		return 0;	
-	}	
-	
+		return 0;
+	}
+
@@ -1159,2 +917,2 @@
-	
-	/* block waiting for DCD to be asserted, and while 
+
+	/* block waiting for DCD to be asserted, and while
@@ -1170 +928 @@
-	
+
@@ -1175 +933 @@
-		if (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)) { 	
+		if (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)) {
@@ -1181 +939 @@
-		}	
+		}
@@ -1183 +941 @@
-		    (do_clocal || (port->status & ISI_DCD))) {
+				(do_clocal || (port->status & ISI_DCD))) {
@@ -1185 +943 @@
-		}	
+		}
@@ -1190 +948 @@
-		schedule();		
+		schedule();
@@ -1204,2 +962,2 @@
- 
-static int isicom_open(struct tty_struct * tty, struct file * filp)
+
+static int isicom_open(struct tty_struct *tty, struct file *filp)
@@ -1207,2 +965,2 @@
-	struct isi_port * port;
-	struct isi_board * card;
+	struct isi_port *port;
+	struct isi_board *card;
@@ -1217 +975 @@
-	
+
@@ -1220 +978 @@
-	
+
@@ -1225 +983 @@
-	port = &isi_ports[line];	
+	port = &isi_ports[line];
@@ -1228,3 +986,3 @@
-		
-	isicom_setup_board(card);		
-	
+
+	isicom_setup_board(card);
+
@@ -1239 +997 @@
-	return 0;      		
+	return 0;
@@ -1241 +999 @@
- 
+
@@ -1244 +1002 @@
-static inline void isicom_shutdown_board(struct isi_board * bp)
+static inline void isicom_shutdown_board(struct isi_board *bp)
@@ -1255 +1013 @@
-static void isicom_shutdown_port(struct isi_port * port)
+static void isicom_shutdown_port(struct isi_port *port)
@@ -1257,2 +1015,2 @@
-	struct isi_board * card = port->card;
-	struct tty_struct * tty;	
+	struct isi_board *card = port->card;
+	struct tty_struct *tty;
@@ -1260 +1018 @@
-	
+
@@ -1263 +1021 @@
-	spin_lock_irqsave(&card->card_lock, flags);	
+	spin_lock_irqsave(&card->card_lock, flags);
@@ -1271 +1029 @@
-	}	
+	}
@@ -1276 +1034 @@
-	
+
@@ -1280 +1038 @@
-	appears on the remote end. Now we drop the dtr only if the 
+	appears on the remote end. Now we drop the dtr only if the
@@ -1282,2 +1040,2 @@
-	
-	if (C_HUPCL(tty)) 
+
+	if (C_HUPCL(tty))
@@ -1286,2 +1044,2 @@
-		
-	/* any other port uninits  */ 
+
+	/* any other port uninits  */
@@ -1290 +1048 @@
-	
+
@@ -1292 +1050 @@
-		printk(KERN_DEBUG "ISICOM: isicom_shutdown_port: bad board(0x%x) count %d.\n",
+		pr_dbg("isicom_shutdown_port: bad board(0x%lx) count %d.\n",
@@ -1294 +1052 @@
-		card->count = 0;	
+		card->count = 0;
@@ -1296,3 +1054,3 @@
-	
-	/* last port was closed , shutdown that boad too */
-	if(C_HUPCL(tty)) {
+
+	/* last port was closed, shutdown that boad too */
+	if (C_HUPCL(tty)) {
@@ -1304 +1062 @@
-static void isicom_close(struct tty_struct * tty, struct file * filp)
+static void isicom_close(struct tty_struct *tty, struct file *filp)
@@ -1306,2 +1064,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	struct isi_board * card = port->card;
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
@@ -1309 +1067 @@
-	
+
@@ -1314,5 +1072,3 @@
-	
-#ifdef ISICOM_DEBUG		
-	printk(KERN_DEBUG "ISICOM: Close start!!!.\n");
-#endif	
-	
+
+	pr_dbg("Close start!!!.\n");
+
@@ -1324 +1080 @@
-	
+
@@ -1326,2 +1082,2 @@
-		printk(KERN_WARNING "ISICOM:(0x%x) isicom_close: bad port count"
-			"tty->count = 1	port count = %d.\n",
+		printk(KERN_WARNING "ISICOM:(0x%lx) isicom_close: bad port "
+			"count tty->count = 1 port count = %d.\n",
@@ -1332,2 +1088,2 @@
-		printk(KERN_WARNING "ISICOM:(0x%x) isicom_close: bad port count for"
-			"channel%d = %d", card->base, port->channel, 
+		printk(KERN_WARNING "ISICOM:(0x%lx) isicom_close: bad port "
+			"count for channel%d = %d", card->base, port->channel,
@@ -1335 +1091 @@
-		port->count = 0;	
+		port->count = 0;
@@ -1337 +1093 @@
-	
+
@@ -1341 +1097 @@
-	} 	
+	}
@@ -1345 +1101 @@
-	
+
@@ -1348 +1104 @@
-	/* indicate to the card that no more data can be received 
+	/* indicate to the card that no more data can be received
@@ -1351 +1107 @@
-	if (port->flags & ASYNC_INITIALIZED) {   
+	if (port->flags & ASYNC_INITIALIZED) {
@@ -1354 +1110 @@
-	}	
+	}
@@ -1357 +1113 @@
-	
+
@@ -1368,4 +1124,3 @@
-#ifdef ISICOM_DEBUG			
-			printk(KERN_DEBUG "ISICOM: scheduling until time out.\n");
-#endif			
-			msleep_interruptible(jiffies_to_msecs(port->close_delay));
+			pr_dbg("scheduling until time out.\n");
+			msleep_interruptible(
+				jiffies_to_msecs(port->close_delay));
@@ -1375 +1130 @@
-	}	
+	}
@@ -1382,2 +1137,2 @@
-static int isicom_write(struct tty_struct * tty,
-			const unsigned char * buf, int count)
+static int isicom_write(struct tty_struct *tty,	const unsigned char *buf,
+	int count)
@@ -1385,2 +1140,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	struct isi_board * card = port->card;
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
@@ -1392,2 +1147,2 @@
-	
-	if (!tty || !port->xmit_buf || !tmp_buf)
+
+	if (!tty || !port->xmit_buf)
@@ -1395 +1150 @@
-		
+
@@ -1397,5 +1152,5 @@
-	
-	while(1) {	
-		cnt = min_t(int, count, min(SERIAL_XMIT_SIZE - port->xmit_cnt - 1,
-					    SERIAL_XMIT_SIZE - port->xmit_head));
-		if (cnt <= 0) 
+
+	while(1) {
+		cnt = min_t(int, count, min(SERIAL_XMIT_SIZE - port->xmit_cnt
+				- 1, SERIAL_XMIT_SIZE - port->xmit_head));
+		if (cnt <= 0)
@@ -1403 +1158 @@
-		
+
@@ -1405 +1160,2 @@
-		port->xmit_head = (port->xmit_head + cnt) & (SERIAL_XMIT_SIZE - 1);
+		port->xmit_head = (port->xmit_head + cnt) & (SERIAL_XMIT_SIZE
+			- 1);
@@ -1410 +1166 @@
-	}		
+	}
@@ -1414 +1170 @@
-	return total;	
+	return total;
@@ -1418 +1174 @@
-static void isicom_put_char(struct tty_struct * tty, unsigned char ch)
+static void isicom_put_char(struct tty_struct *tty, unsigned char ch)
@@ -1420,2 +1176,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	struct isi_board * card = port->card;
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
@@ -1423 +1179 @@
-	
+
@@ -1426 +1182 @@
-	
+
@@ -1435 +1191 @@
-	
+
@@ -1443 +1199 @@
-static void isicom_flush_chars(struct tty_struct * tty)
+static void isicom_flush_chars(struct tty_struct *tty)
@@ -1445,2 +1201,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	
+	struct isi_port *port = tty->driver_data;
+
@@ -1449,2 +1205,3 @@
-	
-	if (port->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped || !port->xmit_buf)
+
+	if (port->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||
+			!port->xmit_buf)
@@ -1452 +1209 @@
-		
+
@@ -1455 +1212 @@
-	port->status |= ISI_TXOK;	
+	port->status |= ISI_TXOK;
@@ -1459 +1216 @@
-static int isicom_write_room(struct tty_struct * tty)
+static int isicom_write_room(struct tty_struct *tty)
@@ -1461 +1218 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
+	struct isi_port *port = tty->driver_data;
@@ -1466 +1223 @@
-	
+
@@ -1474 +1231 @@
-static int isicom_chars_in_buffer(struct tty_struct * tty)
+static int isicom_chars_in_buffer(struct tty_struct *tty)
@@ -1476 +1233 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
+	struct isi_port *port = tty->driver_data;
@@ -1483 +1240,2 @@
-static inline void isicom_send_break(struct isi_port * port, unsigned long length)
+static inline void isicom_send_break(struct isi_port *port,
+	unsigned long length)
@@ -1485,4 +1243,4 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;	
-	
-	if(!lock_card(card))
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+
+	if (!lock_card(card))
@@ -1490 +1248 @@
-		
+
@@ -1501 +1259 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
+	struct isi_port *port = tty->driver_data;
@@ -1503 +1261 @@
-	unsigned short status = port->status;
+	u16 status = port->status;
@@ -1507 +1265 @@
-	
+
@@ -1517 +1275 @@
-			   unsigned int set, unsigned int clear)
+	unsigned int set, unsigned int clear)
@@ -1519,2 +1277,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	
+	struct isi_port *port = tty->driver_data;
+
@@ -1523 +1281 @@
-	
+
@@ -1535 +1293 @@
-}			
+}
@@ -1537,2 +1295,2 @@
-static int isicom_set_serial_info(struct isi_port * port,
-					struct serial_struct __user *info)
+static int isicom_set_serial_info(struct isi_port *port,
+	struct serial_struct __user *info)
@@ -1543 +1301 @@
-	if(copy_from_user(&newinfo, info, sizeof(newinfo)))
+	if (copy_from_user(&newinfo, info, sizeof(newinfo)))
@@ -1545,4 +1303,4 @@
-		
-	reconfig_port = ((port->flags & ASYNC_SPD_MASK) != 
-			 (newinfo.flags & ASYNC_SPD_MASK));
-	
+
+	reconfig_port = ((port->flags & ASYNC_SPD_MASK) !=
+		(newinfo.flags & ASYNC_SPD_MASK));
+
@@ -1551,3 +1309,3 @@
-		    (newinfo.closing_wait != port->closing_wait) ||
-		    ((newinfo.flags & ~ASYNC_USR_MASK) != 
-		     (port->flags & ~ASYNC_USR_MASK)))
+				(newinfo.closing_wait != port->closing_wait) ||
+				((newinfo.flags & ~ASYNC_USR_MASK) !=
+				(port->flags & ~ASYNC_USR_MASK)))
@@ -1557 +1315 @@
-	}	
+	}
@@ -1560,2 +1318,2 @@
-		port->closing_wait = newinfo.closing_wait; 
-		port->flags = ((port->flags & ~ASYNC_FLAGS) | 
+		port->closing_wait = newinfo.closing_wait;
+		port->flags = ((port->flags & ~ASYNC_FLAGS) |
@@ -1567,2 +1325,2 @@
-	return 0;		 
-}		
+	return 0;
+}
@@ -1570,2 +1328,2 @@
-static int isicom_get_serial_info(struct isi_port * port, 
-					struct serial_struct __user *info)
+static int isicom_get_serial_info(struct isi_port *port,
+	struct serial_struct __user *info)
@@ -1574 +1332 @@
-	
+
@@ -1584 +1342 @@
-	if(copy_to_user(info, &out_info, sizeof(out_info)))
+	if (copy_to_user(info, &out_info, sizeof(out_info)))
@@ -1587 +1345 @@
-}					
+}
@@ -1589,2 +1347,2 @@
-static int isicom_ioctl(struct tty_struct * tty, struct file * filp,
-			unsigned int cmd, unsigned long arg) 
+static int isicom_ioctl(struct tty_struct *tty, struct file *filp,
+	unsigned int cmd, unsigned long arg)
@@ -1592 +1350 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
+	struct isi_port *port = tty->driver_data;
@@ -1600,36 +1358,37 @@
-		case TCSBRK:
-			retval = tty_check_change(tty);
-			if (retval)
-				return retval;
-			tty_wait_until_sent(tty, 0);
-			if (!arg)
-				isicom_send_break(port, HZ/4);
-			return 0;
-			
-		case TCSBRKP:	
-			retval = tty_check_change(tty);
-			if (retval)
-				return retval;
-			tty_wait_until_sent(tty, 0);
-			isicom_send_break(port, arg ? arg * (HZ/10) : HZ/4);
-			return 0;
-			
-		case TIOCGSOFTCAR:
-			return put_user(C_CLOCAL(tty) ? 1 : 0, (unsigned long __user *)argp);
-			
-		case TIOCSSOFTCAR:
-			if(get_user(arg, (unsigned long __user *) argp))
-				return -EFAULT;
-			tty->termios->c_cflag =
-				((tty->termios->c_cflag & ~CLOCAL) |
-				(arg ? CLOCAL : 0));
-			return 0;	
-			
-		case TIOCGSERIAL:
-			return isicom_get_serial_info(port, argp);
-		
-		case TIOCSSERIAL:
-			return isicom_set_serial_info(port, argp);
-					
-		default:
-			return -ENOIOCTLCMD;						
+	case TCSBRK:
+		retval = tty_check_change(tty);
+		if (retval)
+			return retval;
+		tty_wait_until_sent(tty, 0);
+		if (!arg)
+			isicom_send_break(port, HZ/4);
+		return 0;
+
+	case TCSBRKP:
+		retval = tty_check_change(tty);
+		if (retval)
+			return retval;
+		tty_wait_until_sent(tty, 0);
+		isicom_send_break(port, arg ? arg * (HZ/10) : HZ/4);
+		return 0;
+
+	case TIOCGSOFTCAR:
+		return put_user(C_CLOCAL(tty) ? 1 : 0,
+				(unsigned long __user *)argp);
+
+	case TIOCSSOFTCAR:
+		if (get_user(arg, (unsigned long __user *) argp))
+			return -EFAULT;
+		tty->termios->c_cflag =
+			((tty->termios->c_cflag & ~CLOCAL) |
+			(arg ? CLOCAL : 0));
+		return 0;
+
+	case TIOCGSERIAL:
+		return isicom_get_serial_info(port, argp);
+
+	case TIOCSSERIAL:
+		return isicom_set_serial_info(port, argp);
+
+	default:
+		return -ENOIOCTLCMD;
@@ -1641 +1400,2 @@
-static void isicom_set_termios(struct tty_struct * tty, struct termios * old_termios)
+static void isicom_set_termios(struct tty_struct *tty,
+	struct termios *old_termios)
@@ -1643,2 +1403,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	
+	struct isi_port *port = tty->driver_data;
+
@@ -1647 +1407 @@
-	
+
@@ -1649 +1409 @@
-	    tty->termios->c_iflag == old_termios->c_iflag)
+			tty->termios->c_iflag == old_termios->c_iflag)
@@ -1651 +1411 @@
-		
+
@@ -1653 +1413 @@
-	
+
@@ -1655 +1415 @@
-	    !(tty->termios->c_cflag & CRTSCTS)) {	
+			!(tty->termios->c_cflag & CRTSCTS)) {
@@ -1657,2 +1417,2 @@
-		isicom_start(tty);   
-	}    
+		isicom_start(tty);
+	}
@@ -1662 +1422 @@
-static void isicom_throttle(struct tty_struct * tty)
+static void isicom_throttle(struct tty_struct *tty)
@@ -1664,3 +1424,3 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	struct isi_board * card = port->card;
-	
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
+
@@ -1669 +1429 @@
-	
+
@@ -1676 +1436 @@
-static void isicom_unthrottle(struct tty_struct * tty)
+static void isicom_unthrottle(struct tty_struct *tty)
@@ -1678,3 +1438,3 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	struct isi_board * card = port->card;
-	
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
+
@@ -1683 +1443 @@
-	
+
@@ -1690 +1450 @@
-static void isicom_stop(struct tty_struct * tty)
+static void isicom_stop(struct tty_struct *tty)
@@ -1692 +1452 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
+	struct isi_port *port = tty->driver_data;
@@ -1696 +1456 @@
-	
+
@@ -1703 +1463 @@
-static void isicom_start(struct tty_struct * tty)
+static void isicom_start(struct tty_struct *tty)
@@ -1705,2 +1465,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	
+	struct isi_port *port = tty->driver_data;
+
@@ -1709 +1469 @@
-	
+
@@ -1716 +1476 @@
-static void do_isicom_hangup(void * data)
+static void do_isicom_hangup(void *data)
@@ -1718,3 +1478,3 @@
-	struct isi_port * port = (struct isi_port *) data;
-	struct tty_struct * tty;
-	
+	struct isi_port *port = data;
+	struct tty_struct *tty;
+
@@ -1726 +1486 @@
-static void isicom_hangup(struct tty_struct * tty)
+static void isicom_hangup(struct tty_struct *tty)
@@ -1728,2 +1488,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	
+	struct isi_port *port = tty->driver_data;
+
@@ -1732 +1492 @@
-	
+
@@ -1741 +1501 @@
-static void isicom_flush_buffer(struct tty_struct * tty)
+static void isicom_flush_buffer(struct tty_struct *tty)
@@ -1743,2 +1503,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	struct isi_board * card = port->card;
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
@@ -1746 +1506 @@
-	
+
@@ -1749 +1509 @@
-	
+
@@ -1753 +1513 @@
-	
+
@@ -1757,0 +1518,3 @@
+/*
+ * Driver init and deinit functions
+ */
@@ -1759 +1522,2 @@
-static int __devinit register_ioregion(void)
+static int __devinit isicom_register_ioregion(struct pci_dev *pdev,
+	const unsigned int index)
@@ -1761,11 +1525,13 @@
-	int count, done=0;
-	for (count=0; count < BOARD_COUNT; count++ ) {
-		if (isi_card[count].base)
-			if (!request_region(isi_card[count].base,16,ISICOM_NAME)) {
-				printk(KERN_DEBUG "ISICOM: I/O Region 0x%x-0x%x is busy. Card%d will be disabled.\n",
-					isi_card[count].base,isi_card[count].base+15,count+1);
-				isi_card[count].base=0;
-				done++;
-			}
-	}
-	return done;
+	struct isi_board *board = pci_get_drvdata(pdev);
+
+	if (!board->base)
+		return -EINVAL;
+
+	if (!request_region(board->base, 16, ISICOM_NAME)) {
+		dev_dbg(&pdev->dev, "I/O Region 0x%lx-0x%lx is busy. Card%d "
+			"will be disabled.\n", board->base, board->base + 15,
+			index + 1);
+		return -EBUSY;
+ 	}
+
+	return 0;
@@ -1774 +1540 @@
-static void unregister_ioregion(void)
+static void isicom_unregister_ioregion(struct pci_dev *pdev)
@@ -1776,8 +1542,9 @@
-	int count;
-	for (count=0; count < BOARD_COUNT; count++ ) 
-		if (isi_card[count].base) {
-			release_region(isi_card[count].base,16);
-#ifdef ISICOM_DEBUG			
-			printk(KERN_DEBUG "ISICOM: I/O Region 0x%x-0x%x released for Card%d.\n",isi_card[count].base,isi_card[count].base+15,count+1);
-#endif			
-		}
+	struct isi_board *board = pci_get_drvdata(pdev);
+
+	if (!board->base)
+		return;
+
+	release_region(board->base, 16);
+	dev_dbg(&pdev->dev, "I/O Region 0x%lx-0x%lx released.\n",
+		board->base, board->base + 15);
+	board->base = 0;
@@ -1787,6 +1554,6 @@
-	.open	= isicom_open,
-	.close	= isicom_close,
-	.write	= isicom_write,
-	.put_char	= isicom_put_char,
-	.flush_chars	= isicom_flush_chars,
-	.write_room	= isicom_write_room,
+	.open			= isicom_open,
+	.close			= isicom_close,
+	.write			= isicom_write,
+	.put_char		= isicom_put_char,
+	.flush_chars		= isicom_flush_chars,
+	.write_room		= isicom_write_room,
@@ -1794,10 +1561,10 @@
-	.ioctl	= isicom_ioctl,
-	.set_termios	= isicom_set_termios,
-	.throttle	= isicom_throttle,
-	.unthrottle	= isicom_unthrottle,
-	.stop	= isicom_stop,
-	.start	= isicom_start,
-	.hangup	= isicom_hangup,
-	.flush_buffer	= isicom_flush_buffer,
-	.tiocmget	= isicom_tiocmget,
-	.tiocmset	= isicom_tiocmset,
+	.ioctl			= isicom_ioctl,
+	.set_termios		= isicom_set_termios,
+	.throttle		= isicom_throttle,
+	.unthrottle		= isicom_unthrottle,
+	.stop			= isicom_stop,
+	.start			= isicom_start,
+	.hangup			= isicom_hangup,
+	.flush_buffer		= isicom_flush_buffer,
+	.tiocmget		= isicom_tiocmget,
+	.tiocmset		= isicom_tiocmset,
@@ -1806 +1573 @@
-static int __devinit register_drivers(void)
+static int __devinit isicom_register_tty_driver(void)
@@ -1808 +1575 @@
-	int error;
+	int error = -ENOMEM;
@@ -1813 +1580 @@
-		return -ENOMEM;
+		goto end;
@@ -1815,11 +1582,11 @@
-	isicom_normal->owner	= THIS_MODULE;
-	isicom_normal->name 	= "ttyM";
-	isicom_normal->devfs_name = "isicom/";
-	isicom_normal->major	= ISICOM_NMAJOR;
-	isicom_normal->minor_start	= 0;
-	isicom_normal->type	= TTY_DRIVER_TYPE_SERIAL;
-	isicom_normal->subtype	= SERIAL_TYPE_NORMAL;
-	isicom_normal->init_termios	= tty_std_termios;
-	isicom_normal->init_termios.c_cflag	= 
-				B9600 | CS8 | CREAD | HUPCL |CLOCAL;
-	isicom_normal->flags	= TTY_DRIVER_REAL_RAW;
+	isicom_normal->owner			= THIS_MODULE;
+	isicom_normal->name 			= "ttyM";
+	isicom_normal->devfs_name	 	= "isicom/";
+	isicom_normal->major			= ISICOM_NMAJOR;
+	isicom_normal->minor_start		= 0;
+	isicom_normal->type			= TTY_DRIVER_TYPE_SERIAL;
+	isicom_normal->subtype			= SERIAL_TYPE_NORMAL;
+	isicom_normal->init_termios		= tty_std_termios;
+	isicom_normal->init_termios.c_cflag	= B9600 | CS8 | CREAD | HUPCL |
+		CLOCAL;
+	isicom_normal->flags			= TTY_DRIVER_REAL_RAW;
@@ -1827,3 +1594,3 @@
-	
-	if ((error=tty_register_driver(isicom_normal))!=0) {
-		printk(KERN_DEBUG "ISICOM: Couldn't register the dialin driver, error=%d\n",
+
+	if ((error = tty_register_driver(isicom_normal))) {
+		pr_dbg("Couldn't register the dialin driver, error=%d\n",
@@ -1832 +1598,0 @@
-		return error;
@@ -1834 +1600,2 @@
-	return 0;
+end:
+	return error;
@@ -1837 +1604 @@
-static void unregister_drivers(void)
+static void isicom_unregister_tty_driver(void)
@@ -1839,3 +1606,5 @@
-	int error = tty_unregister_driver(isicom_normal);
-	if (error)
-		printk(KERN_DEBUG "ISICOM: couldn't unregister normal driver error=%d.\n",error);
+	int error;
+
+	if ((error = tty_unregister_driver(isicom_normal)))
+		pr_dbg("couldn't unregister normal driver, error=%d.\n", error);
+
@@ -1845 +1614,2 @@
-static int __devinit register_isr(void)
+static int __devinit isicom_register_isr(struct pci_dev *pdev,
+	const unsigned int index)
@@ -1847,2 +1617,3 @@
-	int count, done=0;
-	unsigned long irqflags;
+	struct isi_board *board = pci_get_drvdata(pdev);
+	unsigned long irqflags = SA_INTERRUPT;
+	int retval = -EINVAL;
@@ -1850,15 +1621,2 @@
-	for (count=0; count < BOARD_COUNT; count++ ) {
-		if (isi_card[count].base) {
-			irqflags = (isi_card[count].isa == YES) ? 
-					SA_INTERRUPT : 
-					(SA_INTERRUPT | SA_SHIRQ);
-
-			if (request_irq(isi_card[count].irq, 
-					isicom_interrupt, 
-					irqflags, 
-					ISICOM_NAME, &isi_card[count])) {
-
-				printk(KERN_WARNING "ISICOM: Could not"
-					" install handler at Irq %d."
-					" Card%d will be disabled.\n",
-					isi_card[count].irq, count+1);
+	if (!board->base)
+		goto end;
@@ -1866,8 +1624,12 @@
-				release_region(isi_card[count].base,16);
-				isi_card[count].base=0;
-			}
-			else
-				done++;
-		}	
-	}
-	return done;
+	if (board->isa == NO)
+		irqflags |= SA_SHIRQ;
+
+	retval = request_irq(board->irq, isicom_interrupt, irqflags,
+		ISICOM_NAME, board);
+	if (retval < 0)
+		dev_warn(&pdev->dev, "Could not install handler at Irq %d. "
+			"Card%d will be disabled.\n", board->irq, index + 1);
+ 	else
+		retval = 0;
+end:
+	return retval;
@@ -1876 +1638,2 @@
-static void __exit unregister_isr(void)
+static int __devinit reset_card(struct pci_dev *pdev,
+	const unsigned int card, unsigned int *signature)
@@ -1878 +1641,4 @@
-	int count;
+	struct isi_board *board = pci_get_drvdata(pdev);
+	unsigned long base = board->base;
+	unsigned int portcount = 0;
+	int retval = 0;
@@ -1880,5 +1646,2 @@
-	for (count=0; count < BOARD_COUNT; count++ ) {
-		if (isi_card[count].base)
-			free_irq(isi_card[count].irq, &isi_card[count]);
-	}
-}
+	dev_dbg(&pdev->dev, "ISILoad:Resetting Card%d at 0x%lx\n", card + 1,
+		base);
@@ -1886,30 +1649,32 @@
-static int __devinit isicom_init(void)
-{
-	int card, channel, base;
-	struct isi_port * port;
-	unsigned long page;
-	
-	if (!tmp_buf) { 
-		page = get_zeroed_page(GFP_KERNEL);
-	      	if (!page) {
-#ifdef ISICOM_DEBUG	      	
-	      		printk(KERN_DEBUG "ISICOM: Couldn't allocate page for tmp_buf.\n");
-#else
-			printk(KERN_ERR "ISICOM: Not enough memory...\n");
-#endif	      
-	      		return 0;
-	      	}	
-	      	tmp_buf = (unsigned char *) page;
-	}
-	
-	if (!register_ioregion()) 
-	{
-		printk(KERN_ERR "ISICOM: All required I/O space found busy.\n");
-		free_page((unsigned long)tmp_buf);
-		return 0;
-	}
-	if (register_drivers()) 
-	{
-		unregister_ioregion();
-		free_page((unsigned long)tmp_buf);
-		return 0;
+	inw(base + 0x8);
+
+	mdelay(10);
+
+	outw(0, base + 0x8); /* Reset */
+
+	msleep(3000);
+
+	*signature = inw(base + 0x4) & 0xff;
+
+	if (board->isa == YES) {
+		if (!(inw(base + 0xe) & 0x1) || (inw(base + 0x2))) {
+			dev_dbg(&pdev->dev, "base+0x2=0x%lx, base+0xe=0x%lx\n",
+				inw(base + 0x2), inw(base + 0xe));
+			dev_err(&pdev->dev, "ISILoad:ISA Card%d reset failure "
+				"(Possible bad I/O Port Address 0x%lx).\n",
+				card + 1, base);
+			retval = -EIO;
+			goto end;
+		}
+	} else {
+		portcount = inw(base + 0x2);
+		if (!(inw(base + 0xe) & 0x1) || ((portcount != 0) &&
+				(portcount != 4) && (portcount != 8))) {
+			dev_dbg(&pdev->dev, "base+0x2=0x%lx, base+0xe=0x%lx\n",
+				inw(base + 0x2), inw(base + 0xe));
+			dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure "
+				"(Possible bad I/O Port Address 0x%lx).\n",
+				card + 1, base);
+			retval = -EIO;
+			goto end;
+		}
@@ -1917,6 +1682,183 @@
-	if (!register_isr()) 
-	{
-		unregister_drivers();
-		/*  ioports already uregistered in register_isr */
-		free_page((unsigned long)tmp_buf);
-		return 0;		
+
+	switch (*signature) {
+	case 0xa5:
+	case 0xbb:
+	case 0xdd:
+		board->port_count = (board->isa == NO && portcount == 4) ? 4 :
+			8;
+		board->shift_count = 12;
+		break;
+	case 0xcc:
+		board->port_count = 16;
+		board->shift_count = 11;
+		break;
+	default:
+		dev_warn(&pdev->dev, "ISILoad:Card%d reset failure (Possible "
+			"bad I/O Port Address 0x%lx).\n", card + 1, base);
+		dev_dbg(&pdev->dev, "Sig=0x%lx\n", signature);
+		retval = -EIO;
+	}
+	dev_info(&pdev->dev, "-Done\n");
+
+end:
+	return retval;
+}
+
+static inline int WaitTillCardIsFree(u16 base)
+{
+	unsigned long count = 0;
+
+	while (!(inw(base + 0xe) & 0x1) && count++ < 100)
+		msleep(5);
+
+	return !(inw(base + 0xe) & 0x1);
+}
+
+static int __devinit load_firmware(struct pci_dev *pdev,
+	const unsigned int index, const unsigned int signature)
+{
+	struct isi_board *board = pci_get_drvdata(pdev);
+	const struct firmware *fw;
+	unsigned long base = board->base;
+	unsigned int a;
+	u16 word_count, status;
+	int retval = -EIO;
+	char *name;
+	u8 *data;
+
+	struct stframe {
+		u16	addr;
+		u16	count;
+		u8	data[0];
+	} *frame;
+
+	switch (signature) {
+	case 0xa5:
+		name = "isi608.bin";
+		break;
+	case 0xbb:
+		name = "isi608em.bin";
+		break;
+	case 0xcc:
+		name = "isi616em.bin";
+		break;
+	case 0xdd:
+		name = "isi4608.bin";
+		break;
+	case 0xee:
+		name = "isi4616.bin";
+		break;
+	default:
+		dev_err(&pdev->dev, "Unknown signature.\n");
+		goto end;
+ 	}
+
+	retval = request_firmware(&fw, name, &pdev->dev);
+	if (retval)
+		goto end;
+
+	for (frame = (struct stframe *)fw->data;
+			frame < (struct stframe *)(fw->data + fw->size);
+			frame++) {
+		if (WaitTillCardIsFree(base))
+			goto errrelfw;
+
+		outw(0xf0, base);	/* start upload sequence */
+		outw(0x00, base);
+		outw(frame->addr, base); /* lsb of address */
+
+		word_count = frame->count / 2 + frame->count % 2;
+		outw(word_count, base);
+		InterruptTheCard(base);
+
+		udelay(100); /* 0x2f */
+
+		if (WaitTillCardIsFree(base))
+			goto errrelfw;
+
+		if ((status = inw(base + 0x4)) != 0) {
+			dev_warn(&pdev->dev, "Card%d rejected load header:\n"
+				"Address:0x%x\nCount:0x%x\nStatus:0x%x\n",
+				index + 1, frame->addr, frame->count, status);
+			goto errrelfw;
+		}
+		outsw(base, frame->data, word_count);
+
+		InterruptTheCard(base);
+
+		udelay(50); /* 0x0f */
+
+		if (WaitTillCardIsFree(base))
+			goto errrelfw;
+
+		if ((status = inw(base + 0x4)) != 0) {
+			dev_err(&pdev->dev, "Card%d got out of sync.Card "
+				"Status:0x%x\n", index + 1, status);
+			goto errrelfw;
+		}
+ 	}
+
+	retval = -EIO;
+
+	if (WaitTillCardIsFree(base))
+		goto errrelfw;
+
+	outw(0xf2, base);
+	outw(0x800, base);
+	outw(0x0, base);
+	outw(0x0, base);
+	InterruptTheCard(base);
+	outw(0x0, base + 0x4); /* for ISI4608 cards */
+
+/* XXX: should we test it by reading it back and comparing with original like
+ * in load firmware package? */
+	for (frame = (struct stframe*)fw->data;
+			frame < (struct stframe*)(fw->data + fw->size);
+			frame++) {
+		if (WaitTillCardIsFree(base))
+			goto errrelfw;
+
+		outw(0xf1, base); /* start download sequence */
+		outw(0x00, base);
+		outw(frame->addr, base); /* lsb of address */
+
+		word_count = (frame->count >> 1) + frame->count % 2;
+		outw(word_count + 1, base);
+		InterruptTheCard(base);
+
+		udelay(50); /* 0xf */
+
+		if (WaitTillCardIsFree(base))
+			goto errrelfw;
+
+		if ((status = inw(base + 0x4)) != 0) {
+			dev_warn(&pdev->dev, "Card%d rejected verify header:\n"
+				"Address:0x%x\nCount:0x%x\nStatus: 0x%x\n",
+				index + 1, frame->addr, frame->count, status);
+			goto errrelfw;
+		}
+
+		data = kmalloc(word_count * 2, GFP_KERNEL);
+		inw(base);
+		insw(base, data, word_count);
+		InterruptTheCard(base);
+
+		for (a = 0; a < frame->count; a++)
+			if (data[a] != frame->data[a]) {
+				kfree(data);
+				dev_err(&pdev->dev, "Card%d, firmware upload "
+					"failed\n", index + 1);
+				goto errrelfw;
+			}
+		kfree(data);
+
+		udelay(50); /* 0xf */
+
+		if (WaitTillCardIsFree(base))
+			goto errrelfw;
+
+		if ((status = inw(base + 0x4)) != 0) {
+			dev_err(&pdev->dev, "Card%d verify got out of sync. "
+				"Card Status:0x%x\n", index + 1, status);
+			goto errrelfw;
+		}
@@ -1924,23 +1866,8 @@
-	
-	memset(isi_ports, 0, sizeof(isi_ports));
-	for (card = 0; card < BOARD_COUNT; card++) {
-		port = &isi_ports[card * 16];
-		isi_card[card].ports = port;
-		spin_lock_init(&isi_card[card].card_lock);
-		base = isi_card[card].base;
-		for (channel = 0; channel < 16; channel++, port++) {
-			port->magic = ISICOM_MAGIC;
-			port->card = &isi_card[card];
-			port->channel = channel;
-		 	port->close_delay = 50 * HZ/100;
-		 	port->closing_wait = 3000 * HZ/100;
-		 	INIT_WORK(&port->hangup_tq, do_isicom_hangup, port);
-		 	INIT_WORK(&port->bh_tqueue, isicom_bottomhalf, port);
-		 	port->status = 0;
-			init_waitqueue_head(&port->open_wait);	 				
-			init_waitqueue_head(&port->close_wait);
-			/*  . . .  */
- 		}
-	} 
-	
-	return 1;	
+
+	board->status |= FIRMWARE_LOADED;
+	retval = 0;
+
+errrelfw:
+	release_firmware(fw);
+end:
+	return retval;
@@ -1952 +1878,0 @@
- 
@@ -1954,0 +1881 @@
+static int card;
@@ -1956,7 +1883,64 @@
-MODULE_AUTHOR("MultiTech");
-MODULE_DESCRIPTION("Driver for the ISI series of cards by MultiTech");
-MODULE_LICENSE("GPL");
-module_param_array(io, int, NULL, 0);
-MODULE_PARM_DESC(io, "I/O ports for the cards");
-module_param_array(irq, int, NULL, 0);
-MODULE_PARM_DESC(irq, "Interrupts for the cards");
+static int __devinit isicom_probe(struct pci_dev *pdev,
+	const struct pci_device_id *ent)
+{
+	unsigned int ioaddr, signature, index;
+	int retval = -EPERM;
+	u8 pciirq;
+	struct isi_board *board = NULL;
+
+	if (card >= BOARD_COUNT)
+		goto err;
+
+	ioaddr = pci_resource_start(pdev, 3);
+	/* i.e at offset 0x1c in the PCI configuration register space. */
+	pciirq = pdev->irq;
+	dev_info(&pdev->dev, "ISI PCI Card(Device ID 0x%x)\n", ent->device);
+
+	/* allot the first empty slot in the array */
+	for (index = 0; index < BOARD_COUNT; index++)
+		if (isi_card[index].base == 0) {
+			board = &isi_card[index];
+			break;
+		}
+
+	board->base = ioaddr;
+	board->irq = pciirq;
+	board->isa = NO;
+	card++;
+
+	pci_set_drvdata(pdev, board);
+
+	retval = isicom_register_ioregion(pdev, index);
+	if (retval < 0)
+		goto err;
+
+	retval = isicom_register_isr(pdev, index);
+	if (retval < 0)
+		goto errunrr;
+
+	retval = reset_card(pdev, index, &signature);
+	if (retval < 0)
+		goto errunri;
+
+	retval = load_firmware(pdev, index, signature);
+	if (retval < 0)
+		goto errunri;
+
+	return 0;
+
+errunri:
+	free_irq(board->irq, board);
+errunrr:
+	isicom_unregister_ioregion(pdev);
+err:
+	board->base = 0;
+	return retval;
+}
+
+static void __devexit isicom_remove(struct pci_dev *pdev)
+{
+	struct isi_board *board = pci_get_drvdata(pdev);
+
+	free_irq(board->irq, board);
+	isicom_unregister_ioregion(pdev);
+}
@@ -1966,5 +1950,3 @@
-	struct pci_dev *dev = NULL;
-	int retval, card, idx, count;
-	unsigned char pciirq;
-	unsigned int ioaddr;
-	                
+	int retval, idx, channel;
+	struct isi_port *port;
+
@@ -1972,40 +1954 @@
-	for(idx=0; idx < BOARD_COUNT; idx++) {	
-		if (io[idx]) {
-			isi_card[idx].base=io[idx];
-			isi_card[idx].irq=irq[idx];
-			isi_card[idx].isa=YES;
-			card++;
-		}
-		else {
-			isi_card[idx].base = 0;
-			isi_card[idx].irq = 0;
-		}
-	}
-	
-	for (idx=0 ;idx < card; idx++) {
-		if (!((isi_card[idx].irq==2)||(isi_card[idx].irq==3)||
-		    (isi_card[idx].irq==4)||(isi_card[idx].irq==5)||
-		    (isi_card[idx].irq==7)||(isi_card[idx].irq==10)||
-		    (isi_card[idx].irq==11)||(isi_card[idx].irq==12)||
-		    (isi_card[idx].irq==15))) {
-			
-			if (isi_card[idx].base) {
-				printk(KERN_ERR "ISICOM: Irq %d unsupported. Disabling Card%d...\n",
-					isi_card[idx].irq, idx+1);
-				isi_card[idx].base=0;
-				card--;
-			}	
-		}
-	}	
-	
-	if (card < BOARD_COUNT) {
-		for (idx=0; idx < DEVID_COUNT; idx++) {
-			dev = NULL;
-			for (;;){
-				if (!(dev = pci_find_device(VENDOR_ID, isicom_pci_tbl[idx].device, dev)))
-					break;
-				if (card >= BOARD_COUNT)
-					break;
-					
-				if (pci_enable_device(dev))
-					break;
+	memset(isi_ports, 0, sizeof(isi_ports));
@@ -2013,28 +1956,19 @@
-				/* found a PCI ISI card! */
-				ioaddr = pci_resource_start (dev, 3); /* i.e at offset 0x1c in the
-								       * PCI configuration register
-								       * space.
-								       */
-				pciirq = dev->irq;
-				printk(KERN_INFO "ISI PCI Card(Device ID 0x%x)\n", isicom_pci_tbl[idx].device);
-				/*
-				 * allot the first empty slot in the array
-				 */				
-				for (count=0; count < BOARD_COUNT; count++) {				
-					if (isi_card[count].base == 0) {
-						isi_card[count].base = ioaddr;
-						isi_card[count].irq = pciirq;
-						isi_card[count].isa = NO;
-						card++;
-						break;
-					}
-				}
-			}				
-			if (card >= BOARD_COUNT) break;
-		}
-	}
-	
-	if (!(isi_card[0].base || isi_card[1].base || isi_card[2].base || isi_card[3].base)) {
-		printk(KERN_ERR "ISICOM: No valid card configuration. Driver cannot be initialized...\n"); 
-		return -EIO;
-	}	
+	for(idx = 0; idx < BOARD_COUNT; idx++) {
+		port = &isi_ports[idx * 16];
+		isi_card[idx].ports = port;
+		spin_lock_init(&isi_card[idx].card_lock);
+		for (channel = 0; channel < 16; channel++, port++) {
+			port->magic = ISICOM_MAGIC;
+			port->card = &isi_card[idx];
+			port->channel = channel;
+			port->close_delay = 50 * HZ/100;
+			port->closing_wait = 3000 * HZ/100;
+			INIT_WORK(&port->hangup_tq, do_isicom_hangup, port);
+			INIT_WORK(&port->bh_tqueue, isicom_bottomhalf, port);
+			port->status = 0;
+			init_waitqueue_head(&port->open_wait);
+			init_waitqueue_head(&port->close_wait);
+			/*  . . .  */
+ 		}
+		isi_card[idx].base = 0;
+		isi_card[idx].irq = 0;
@@ -2042 +1976,20 @@
-	retval = misc_register(&isiloader_device);
+		if (!io[idx])
+			continue;
+
+		if (irq[idx] == 2 || irq[idx] == 3 || irq[idx] == 4	||
+				irq[idx] == 5	|| irq[idx] == 7	||
+				irq[idx] == 10	|| irq[idx] == 11	||
+				irq[idx] == 12	|| irq[idx] == 15) {
+			printk(KERN_ERR "ISICOM: ISA not supported yet.\n");
+			retval = -EINVAL;
+			goto error;
+		} else
+			printk(KERN_ERR "ISICOM: Irq %d unsupported. "
+				"Disabling Card%d...\n", irq[idx], idx + 1);
+	}
+
+	retval = isicom_register_tty_driver();
+	if (retval < 0)
+		goto error;
+
+	retval = pci_register_driver(&isicom_driver);
@@ -2044,8 +1997,2 @@
-		printk(KERN_ERR "ISICOM: Unable to register firmware loader driver.\n");
-		return retval;
-	}
-	
-	if (!isicom_init()) {
-		if (misc_deregister(&isiloader_device)) 
-			printk(KERN_ERR "ISICOM: Unable to unregister Firmware Loader driver\n");
-		return -EIO;
+		printk(KERN_ERR "ISICOM: Unable to register pci driver.\n");
+		goto errtty;
@@ -2053 +2000 @@
-	
+
@@ -2060 +2007 @@
-	
+
@@ -2061,0 +2009,4 @@
+errtty:
+	isicom_unregister_tty_driver();
+error:
+	return retval;
@@ -2065,0 +2017,2 @@
+	unsigned int index = 0;
+
@@ -2067,9 +2020,6 @@
-	/* FIXME */
-	msleep(1000);
-	unregister_isr();
-	unregister_drivers();
-	unregister_ioregion();	
-	if(tmp_buf)
-		free_page((unsigned long)tmp_buf);
-	if (misc_deregister(&isiloader_device))
-		printk(KERN_ERR "ISICOM: Unable to unregister Firmware Loader driver\n");
+
+	while (re_schedule != 2 && index++ < 100)
+		msleep(10);
+
+	pci_unregister_driver(&isicom_driver);
+	isicom_unregister_tty_driver();
@@ -2079,0 +2030,8 @@
+
+MODULE_AUTHOR("MultiTech");
+MODULE_DESCRIPTION("Driver for the ISI series of cards by MultiTech");
+MODULE_LICENSE("GPL");
+module_param_array(io, int, NULL, 0);
+MODULE_PARM_DESC(io, "I/O ports for the cards");
+module_param_array(irq, int, NULL, 0);
+MODULE_PARM_DESC(irq, "Interrupts for the cards");
--- ./projects/linux/linux-2.6.17/drivers/char/isicom.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/isicom.c	2006-09-20 05:42:06.000000000 +0200
@@ -248 +248 @@
-	return 0;	/* Failed to aquire the card! */
+	return 0;	/* Failed to acquire the card! */
@@ -265 +265 @@
-	return 0;	/* Failed to aquire the card! */
+	return 0;	/* Failed to acquire the card! */
@@ -1148 +1148 @@
-	if (!tty || !port->xmit_buf)
+	if (!port->xmit_buf)
@@ -1183 +1183 @@
-	if (!tty || !port->xmit_buf)
+	if (!port->xmit_buf)
@@ -1584 +1583,0 @@
-	isicom_normal->devfs_name	 	= "isicom/";
@@ -1618 +1617 @@
-	unsigned long irqflags = SA_INTERRUPT;
+	unsigned long irqflags = IRQF_DISABLED;
@@ -1625 +1624 @@
-		irqflags |= SA_SHIRQ;
+		irqflags |= IRQF_SHARED;
--- ./projects/linux/linux-2.6.18/drivers/char/isicom.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/isicom.c	2006-11-29 22:57:37.000000000 +0100
@@ -549 +549 @@
-static irqreturn_t isicom_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t isicom_interrupt(int irq, void *dev_id)
@@ -1065 +1065 @@
-	struct isi_board *card = port->card;
+	struct isi_board *card;
@@ -1069,0 +1070 @@
+	card = port->card;
@@ -1553 +1554 @@
-static struct tty_operations isicom_ops = {
+static const struct tty_operations isicom_ops = {
@@ -1758,0 +1760,2 @@
+	retval = -EIO;
+
@@ -1761 +1764,2 @@
-			frame++) {
+			frame = (struct stframe *)((u8 *)(frame + 1) +
+				frame->count)) {
@@ -1800,12 +1803,0 @@
-	retval = -EIO;
-
-	if (WaitTillCardIsFree(base))
-		goto errrelfw;
-
-	outw(0xf2, base);
-	outw(0x800, base);
-	outw(0x0, base);
-	outw(0x0, base);
-	InterruptTheCard(base);
-	outw(0x0, base + 0x4); /* for ISI4608 cards */
-
@@ -1814,3 +1806,4 @@
-	for (frame = (struct stframe*)fw->data;
-			frame < (struct stframe*)(fw->data + fw->size);
-			frame++) {
+	for (frame = (struct stframe *)fw->data;
+			frame < (struct stframe *)(fw->data + fw->size);
+			frame = (struct stframe *)((u8 *)(frame + 1) +
+				frame->count)) {
@@ -1865,0 +1859,11 @@
+	/* xfer ctrl */
+	if (WaitTillCardIsFree(base))
+		goto errrelfw;
+
+	outw(0xf2, base);
+	outw(0x800, base);
+	outw(0x0, base);
+	outw(0x0, base);
+	InterruptTheCard(base);
+	outw(0x0, base + 0x4); /* for ISI4608 cards */
+
--- ./projects/linux/linux-2.6.19/drivers/char/isicom.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/isicom.c	2007-02-04 19:44:54.000000000 +0100
@@ -175 +175 @@
-static struct timer_list tx;
+static DECLARE_COMPLETION(isi_timerdone);
@@ -180,0 +181,2 @@
+static DEFINE_TIMER(tx, isicom_tx, 0, 0);
+
@@ -196 +197,0 @@
-	unsigned char		isa;
@@ -198,0 +200 @@
+	unsigned int		index;
@@ -230,0 +233,14 @@
+static inline int WaitTillCardIsFree(u16 base)
+{
+	unsigned int count = 0;
+	unsigned int a = in_atomic(); /* do we run under spinlock? */
+
+	while (!(inw(base + 0xe) & 0x1) && count++ < 100)
+		if (a)
+			mdelay(1);
+		else
+			msleep(1);
+
+	return !(inw(base + 0xe) & 0x1);
+}
+
@@ -276,0 +293 @@
+/* card->lock HAS to be held */
@@ -283 +300 @@
-	if (!lock_card(card))
+	if (WaitTillCardIsFree(base))
@@ -290 +306,0 @@
-	unlock_card(card);
@@ -292,0 +309 @@
+/* card->lock HAS to be held */
@@ -299 +316 @@
-	if (!lock_card(card))
+	if (WaitTillCardIsFree(base))
@@ -306 +322,0 @@
-	unlock_card(card);
@@ -308,0 +325 @@
+/* card->lock HAS to be held */
@@ -315 +332 @@
-	if (!lock_card(card))
+	if (WaitTillCardIsFree(base))
@@ -322 +338,0 @@
-	unlock_card(card);
@@ -323,0 +340,2 @@
+
+/* card->lock HAS to be held */
@@ -330 +348 @@
-	if (!lock_card(card))
+	if (WaitTillCardIsFree(base))
@@ -337 +354,0 @@
-	unlock_card(card);
@@ -339,0 +357 @@
+/* card->lock MUST NOT be held */
@@ -355,0 +374 @@
+/* card->lock HAS to be held */
@@ -362 +381 @@
-	if (!lock_card(card))
+	if (WaitTillCardIsFree(base))
@@ -369,16 +387,0 @@
-	unlock_card(card);
-}
-
-static inline void kill_queue(struct isi_port *port, short queue)
-{
-	struct isi_board *card = port->card;
-	unsigned long base = card->base;
-	u16 channel = port->channel;
-
-	if (!lock_card(card))
-		return;
-
-	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
-	outw((queue << 8) | 0x06, base);
-	InterruptTheCard(base);
-	unlock_card(card);
@@ -517 +520 @@
-		re_schedule = 2;
+		complete(&isi_timerdone);
@@ -521,7 +524 @@
-	init_timer(&tx);
-	tx.expires = jiffies + HZ/100;
-	tx.data = 0;
-	tx.function = isicom_tx;
-	add_timer(&tx);
-
-	return;
+	mod_timer(&tx, jiffies + msecs_to_jiffies(10));
@@ -533 +530 @@
-static void isicom_bottomhalf(void *data)
+static void isicom_bottomhalf(struct work_struct *work)
@@ -535 +532 @@
-	struct isi_port *port = (struct isi_port *) data;
+	struct isi_port *port = container_of(work, struct isi_port, bh_tqueue);
@@ -565,8 +562,6 @@
-	if (card->isa == NO) {
-		/*
-		 * disable any interrupts from the PCI card and lower the
-		 * interrupt line
-		 */
-		outw(0x8000, base+0x04);
-		ClearInterrupt(base);
-	}
+	/*
+	 * disable any interrupts from the PCI card and lower the
+	 * interrupt line
+	 */
+	outw(0x8000, base+0x04);
+	ClearInterrupt(base);
@@ -582,4 +577 @@
-		if (card->isa)
-			ClearInterrupt(base);
-		else
-			outw(0x0000, base+0x04); /* enable interrupts */
+		outw(0x0000, base+0x04); /* enable interrupts */
@@ -591,4 +583 @@
-		if (card->isa)
-			ClearInterrupt(base);
-		else
-			outw(0x0000, base+0x04); /* enable interrupts */
+		outw(0x0000, base+0x04); /* enable interrupts */
@@ -607,4 +596 @@
-		if (card->isa == YES)
-			ClearInterrupt(base);
-		else
-			outw(0x0000, base+0x04); /* enable interrupts */
+		outw(0x0000, base+0x04); /* enable interrupts */
@@ -711,4 +697 @@
-	if (card->isa == YES)
-		ClearInterrupt(base);
-	else
-		outw(0x0000, base+0x04); /* enable interrupts */
+	outw(0x0000, base+0x04); /* enable interrupts */
@@ -765 +748 @@
-	if (lock_card(card)) {
+	if (WaitTillCardIsFree(base) == 0) {
@@ -793 +775,0 @@
-		unlock_card(card);
@@ -812 +794 @@
-	if (lock_card(card)) {
+	if (WaitTillCardIsFree(base) == 0) {
@@ -817 +798,0 @@
-		unlock_card(card);
@@ -842 +822,0 @@
-	spin_unlock_irqrestore(&bp->card_lock, flags);
@@ -845 +825 @@
-	return;
+	spin_unlock_irqrestore(&bp->card_lock, flags);
@@ -878 +858,6 @@
-	kill_queue(port, ISICOM_KILLTX | ISICOM_KILLRX);
+	if (WaitTillCardIsFree(card->base) == 0) {
+		outw(0x8000 | (port->channel << card->shift_count) | 0x02,
+				card->base);
+		outw(((ISICOM_KILLTX | ISICOM_KILLRX) << 8) | 0x06, card->base);
+		InterruptTheCard(card->base);
+	}
@@ -967,2 +952,2 @@
-	unsigned int line, board;
-	int error;
+	unsigned int board;
+	int error, line;
@@ -1004,3 +988,0 @@
-	unsigned long flags;
-
-	spin_lock_irqsave(&bp->card_lock, flags);
@@ -1010 +991,0 @@
-	spin_unlock_irqrestore(&bp->card_lock, flags);
@@ -1012,0 +994 @@
+/* card->lock HAS to be held */
@@ -1017 +998,0 @@
-	unsigned long flags;
@@ -1021,3 +1002 @@
-	spin_lock_irqsave(&card->card_lock, flags);
-	if (!(port->flags & ASYNC_INITIALIZED)) {
-		spin_unlock_irqrestore(&card->card_lock, flags);
+	if (!(port->flags & ASYNC_INITIALIZED))
@@ -1025 +1004 @@
-	}
+
@@ -1033 +1011,0 @@
-	spin_unlock_irqrestore(&card->card_lock, flags);
@@ -1278,0 +1257 @@
+	unsigned long flags;
@@ -1282,0 +1262 @@
+	spin_lock_irqsave(&port->card->card_lock, flags);
@@ -1291,0 +1272 @@
+	spin_unlock_irqrestore(&port->card->card_lock, flags);
@@ -1323,0 +1305,2 @@
+		unsigned long flags;
+		spin_lock_irqsave(&port->card->card_lock, flags);
@@ -1324,0 +1308 @@
+		spin_unlock_irqrestore(&port->card->card_lock, flags);
@@ -1402 +1386 @@
-	struct termios *old_termios)
+	struct ktermios *old_termios)
@@ -1404,0 +1389 @@
+	unsigned long flags;
@@ -1412,0 +1398 @@
+	spin_lock_irqsave(&port->card->card_lock, flags);
@@ -1413,0 +1400 @@
+	spin_unlock_irqrestore(&port->card->card_lock, flags);
@@ -1477 +1464 @@
-static void do_isicom_hangup(void *data)
+static void do_isicom_hangup(struct work_struct *work)
@@ -1479 +1466 @@
-	struct isi_port *port = data;
+	struct isi_port *port = container_of(work, struct isi_port, hangup_tq);
@@ -1489,0 +1477 @@
+	unsigned long flags;
@@ -1493,0 +1482 @@
+	spin_lock_irqsave(&port->card->card_lock, flags);
@@ -1494,0 +1484,2 @@
+	spin_unlock_irqrestore(&port->card->card_lock, flags);
+
@@ -1523,31 +1513,0 @@
-static int __devinit isicom_register_ioregion(struct pci_dev *pdev,
-	const unsigned int index)
-{
-	struct isi_board *board = pci_get_drvdata(pdev);
-
-	if (!board->base)
-		return -EINVAL;
-
-	if (!request_region(board->base, 16, ISICOM_NAME)) {
-		dev_dbg(&pdev->dev, "I/O Region 0x%lx-0x%lx is busy. Card%d "
-			"will be disabled.\n", board->base, board->base + 15,
-			index + 1);
-		return -EBUSY;
- 	}
-
-	return 0;
-}
-
-static void isicom_unregister_ioregion(struct pci_dev *pdev)
-{
-	struct isi_board *board = pci_get_drvdata(pdev);
-
-	if (!board->base)
-		return;
-
-	release_region(board->base, 16);
-	dev_dbg(&pdev->dev, "I/O Region 0x%lx-0x%lx released.\n",
-		board->base, board->base + 15);
-	board->base = 0;
-}
-
@@ -1574,64 +1533,0 @@
-static int __devinit isicom_register_tty_driver(void)
-{
-	int error = -ENOMEM;
-
-	/* tty driver structure initialization */
-	isicom_normal = alloc_tty_driver(PORT_COUNT);
-	if (!isicom_normal)
-		goto end;
-
-	isicom_normal->owner			= THIS_MODULE;
-	isicom_normal->name 			= "ttyM";
-	isicom_normal->major			= ISICOM_NMAJOR;
-	isicom_normal->minor_start		= 0;
-	isicom_normal->type			= TTY_DRIVER_TYPE_SERIAL;
-	isicom_normal->subtype			= SERIAL_TYPE_NORMAL;
-	isicom_normal->init_termios		= tty_std_termios;
-	isicom_normal->init_termios.c_cflag	= B9600 | CS8 | CREAD | HUPCL |
-		CLOCAL;
-	isicom_normal->flags			= TTY_DRIVER_REAL_RAW;
-	tty_set_operations(isicom_normal, &isicom_ops);
-
-	if ((error = tty_register_driver(isicom_normal))) {
-		pr_dbg("Couldn't register the dialin driver, error=%d\n",
-			error);
-		put_tty_driver(isicom_normal);
-	}
-end:
-	return error;
-}
-
-static void isicom_unregister_tty_driver(void)
-{
-	int error;
-
-	if ((error = tty_unregister_driver(isicom_normal)))
-		pr_dbg("couldn't unregister normal driver, error=%d.\n", error);
-
-	put_tty_driver(isicom_normal);
-}
-
-static int __devinit isicom_register_isr(struct pci_dev *pdev,
-	const unsigned int index)
-{
-	struct isi_board *board = pci_get_drvdata(pdev);
-	unsigned long irqflags = IRQF_DISABLED;
-	int retval = -EINVAL;
-
-	if (!board->base)
-		goto end;
-
-	if (board->isa == NO)
-		irqflags |= IRQF_SHARED;
-
-	retval = request_irq(board->irq, isicom_interrupt, irqflags,
-		ISICOM_NAME, board);
-	if (retval < 0)
-		dev_warn(&pdev->dev, "Could not install handler at Irq %d. "
-			"Card%d will be disabled.\n", board->irq, index + 1);
- 	else
-		retval = 0;
-end:
-	return retval;
-}
-
@@ -1659,22 +1555,10 @@
-	if (board->isa == YES) {
-		if (!(inw(base + 0xe) & 0x1) || (inw(base + 0x2))) {
-			dev_dbg(&pdev->dev, "base+0x2=0x%lx, base+0xe=0x%lx\n",
-				inw(base + 0x2), inw(base + 0xe));
-			dev_err(&pdev->dev, "ISILoad:ISA Card%d reset failure "
-				"(Possible bad I/O Port Address 0x%lx).\n",
-				card + 1, base);
-			retval = -EIO;
-			goto end;
-		}
-	} else {
-		portcount = inw(base + 0x2);
-		if (!(inw(base + 0xe) & 0x1) || ((portcount != 0) &&
-				(portcount != 4) && (portcount != 8))) {
-			dev_dbg(&pdev->dev, "base+0x2=0x%lx, base+0xe=0x%lx\n",
-				inw(base + 0x2), inw(base + 0xe));
-			dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure "
-				"(Possible bad I/O Port Address 0x%lx).\n",
-				card + 1, base);
-			retval = -EIO;
-			goto end;
-		}
+	portcount = inw(base + 0x2);
+	if (!(inw(base + 0xe) & 0x1) || ((portcount != 0) &&
+			(portcount != 4) && (portcount != 8))) {
+		dev_dbg(&pdev->dev, "base+0x2=0x%lx, base+0xe=0x%lx\n",
+			inw(base + 0x2), inw(base + 0xe));
+		dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure "
+			"(Possible bad I/O Port Address 0x%lx).\n",
+			card + 1, base);
+		retval = -EIO;
+		goto end;
@@ -1687,2 +1571 @@
-		board->port_count = (board->isa == NO && portcount == 4) ? 4 :
-			8;
+		board->port_count = (portcount == 4) ? 4 : 8;
@@ -1707,10 +1589,0 @@
-static inline int WaitTillCardIsFree(u16 base)
-{
-	unsigned long count = 0;
-
-	while (!(inw(base + 0xe) & 0x1) && count++ < 100)
-		msleep(5);
-
-	return !(inw(base + 0xe) & 0x1);
-}
-
@@ -1833,0 +1707,5 @@
+		if (data == NULL) {
+			dev_err(&pdev->dev, "Card%d, firmware upload "
+				"failed, not enough memory\n", index + 1);
+			goto errrelfw;
+		}
@@ -1882,2 +1759,0 @@
-static int io[4];
-static int irq[4];
@@ -1908,0 +1785 @@
+	board->index = index;
@@ -1911 +1787,0 @@
-	board->isa = NO;
@@ -1916,2 +1792,6 @@
-	retval = isicom_register_ioregion(pdev, index);
-	if (retval < 0)
+	retval = pci_request_region(pdev, 3, ISICOM_NAME);
+	if (retval) {
+		dev_err(&pdev->dev, "I/O Region 0x%lx-0x%lx is busy. Card%d "
+			"will be disabled.\n", board->base, board->base + 15,
+			index + 1);
+		retval = -EBUSY;
@@ -1918,0 +1799 @@
+ 	}
@@ -1920,2 +1801,5 @@
-	retval = isicom_register_isr(pdev, index);
-	if (retval < 0)
+	retval = request_irq(board->irq, isicom_interrupt,
+			IRQF_SHARED | IRQF_DISABLED, ISICOM_NAME, board);
+	if (retval < 0) {
+		dev_err(&pdev->dev, "Could not install handler at Irq %d. "
+			"Card%d will be disabled.\n", board->irq, index + 1);
@@ -1922,0 +1807 @@
+	}
@@ -1931,0 +1817,4 @@
+	for (index = 0; index < board->port_count; index++)
+		tty_register_device(isicom_normal, board->index * 16 + index,
+				&pdev->dev);
+
@@ -1937 +1826 @@
-	isicom_unregister_ioregion(pdev);
+	pci_release_region(pdev, 3);
@@ -1945,0 +1835,4 @@
+	unsigned int i;
+
+	for (i = 0; i < board->port_count; i++)
+		tty_unregister_device(isicom_normal, board->index * 16 + i);
@@ -1948 +1841 @@
-	isicom_unregister_ioregion(pdev);
+	pci_release_region(pdev, 3);
@@ -1951 +1844 @@
-static int __devinit isicom_setup(void)
+static int __init isicom_init(void)
@@ -1957 +1849,0 @@
-	memset(isi_ports, 0, sizeof(isi_ports));
@@ -1969,2 +1861,2 @@
-			INIT_WORK(&port->hangup_tq, do_isicom_hangup, port);
-			INIT_WORK(&port->bh_tqueue, isicom_bottomhalf, port);
+			INIT_WORK(&port->hangup_tq, do_isicom_hangup);
+			INIT_WORK(&port->bh_tqueue, isicom_bottomhalf);
@@ -1978,14 +1869,0 @@
-
-		if (!io[idx])
-			continue;
-
-		if (irq[idx] == 2 || irq[idx] == 3 || irq[idx] == 4	||
-				irq[idx] == 5	|| irq[idx] == 7	||
-				irq[idx] == 10	|| irq[idx] == 11	||
-				irq[idx] == 12	|| irq[idx] == 15) {
-			printk(KERN_ERR "ISICOM: ISA not supported yet.\n");
-			retval = -EINVAL;
-			goto error;
-		} else
-			printk(KERN_ERR "ISICOM: Irq %d unsupported. "
-				"Disabling Card%d...\n", irq[idx], idx + 1);
@@ -1994,2 +1872,4 @@
-	retval = isicom_register_tty_driver();
-	if (retval < 0)
+	/* tty driver structure initialization */
+	isicom_normal = alloc_tty_driver(PORT_COUNT);
+	if (!isicom_normal) {
+		retval = -ENOMEM;
@@ -1996,0 +1877,20 @@
+	}
+
+	isicom_normal->owner			= THIS_MODULE;
+	isicom_normal->name 			= "ttyM";
+	isicom_normal->major			= ISICOM_NMAJOR;
+	isicom_normal->minor_start		= 0;
+	isicom_normal->type			= TTY_DRIVER_TYPE_SERIAL;
+	isicom_normal->subtype			= SERIAL_TYPE_NORMAL;
+	isicom_normal->init_termios		= tty_std_termios;
+	isicom_normal->init_termios.c_cflag	= B9600 | CS8 | CREAD | HUPCL |
+		CLOCAL;
+	isicom_normal->flags			= TTY_DRIVER_REAL_RAW |
+		TTY_DRIVER_DYNAMIC_DEV;
+	tty_set_operations(isicom_normal, &isicom_ops);
+
+	retval = tty_register_driver(isicom_normal);
+	if (retval) {
+		pr_dbg("Couldn't register the dialin driver\n");
+		goto err_puttty;
+	}
@@ -2001 +1901 @@
-		goto errtty;
+		goto err_unrtty;
@@ -2004,6 +1904 @@
-	init_timer(&tx);
-	tx.expires = jiffies + 1;
-	tx.data = 0;
-	tx.function = isicom_tx;
-	re_schedule = 1;
-	add_timer(&tx);
+	mod_timer(&tx, jiffies + 1);
@@ -2012,2 +1907,4 @@
-errtty:
-	isicom_unregister_tty_driver();
+err_unrtty:
+	tty_unregister_driver(isicom_normal);
+err_puttty:
+	put_tty_driver(isicom_normal);
@@ -2020,2 +1916,0 @@
-	unsigned int index = 0;
-
@@ -2024,2 +1919 @@
-	while (re_schedule != 2 && index++ < 100)
-		msleep(10);
+	wait_for_completion_timeout(&isi_timerdone, HZ);
@@ -2028 +1922,2 @@
-	isicom_unregister_tty_driver();
+	tty_unregister_driver(isicom_normal);
+	put_tty_driver(isicom_normal);
@@ -2031 +1926 @@
-module_init(isicom_setup);
+module_init(isicom_init);
@@ -2037,4 +1931,0 @@
-module_param_array(io, int, NULL, 0);
-MODULE_PARM_DESC(io, "I/O ports for the cards");
-module_param_array(irq, int, NULL, 0);
-MODULE_PARM_DESC(irq, "Interrupts for the cards");
--- ./projects/linux/linux-2.6.20/drivers/char/isicom.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/isicom.c	2007-04-26 05:08:32.000000000 +0200
@@ -186 +186 @@
-	-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 16, 17, 18, 19
+	-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 16, 17, 18, 19, 20, 21
@@ -216,2 +215,0 @@
-	struct work_struct	hangup_tq;
-	struct work_struct	bh_tqueue;
@@ -513 +511 @@
-			schedule_work(&port->bh_tqueue);
+			tty_wakeup(tty);
@@ -527,15 +524,0 @@
-/* 	Interrupt handlers 	*/
-
-
-static void isicom_bottomhalf(struct work_struct *work)
-{
-	struct isi_port *port = container_of(work, struct isi_port, bh_tqueue);
-	struct tty_struct *tty = port->tty;
-
-	if (!tty)
-		return;
-
-	tty_wakeup(tty);
-	wake_up_interruptible(&tty->write_wait);
-}
-
@@ -559,0 +543,5 @@
+
+	/* did the card interrupt us? */
+	if (!(inw(base + 0x0e) & 0x02))
+		return IRQ_NONE;
+
@@ -583,0 +572 @@
+		spin_unlock(&card->card_lock);
@@ -612 +601 @@
-						schedule_work(&port->hangup_tq);
+						tty_hangup(tty);
@@ -634 +623 @@
-						schedule_work(&port->bh_tqueue);
+						tty_wakeup(tty);
@@ -697,0 +687 @@
+	spin_unlock(&card->card_lock);
@@ -723 +713,2 @@
-		if (baud < 1 || baud > 2)
+		/* 1,2,3,4 => 57.6, 115.2, 230, 460 kbps resp. */
+		if (baud < 1 || baud > 4)
@@ -738,0 +730,4 @@
+		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+			baud += 3; /* 230 kbps*/
+		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+			baud += 4; /* 460 kbps*/
@@ -1463,11 +1457,0 @@
-/* hangup et all */
-static void do_isicom_hangup(struct work_struct *work)
-{
-	struct isi_port *port = container_of(work, struct isi_port, hangup_tq);
-	struct tty_struct *tty;
-
-	tty = port->tty;
-	if (tty)
-		tty_hangup(tty);
-}
-
@@ -1506 +1489,0 @@
-	wake_up_interruptible(&tty->write_wait);
@@ -1539 +1522 @@
-	unsigned int portcount = 0;
+	unsigned int sig, portcount = 0;
@@ -1547 +1530 @@
-	mdelay(10);
+	msleep(10);
@@ -1551 +1534 @@
-	msleep(3000);
+	msleep(1000);
@@ -1553 +1536,12 @@
-	*signature = inw(base + 0x4) & 0xff;
+	sig = inw(base + 0x4) & 0xff;
+
+	if (sig != 0xa5 && sig != 0xbb && sig != 0xcc && sig != 0xdd &&
+			sig != 0xee) {
+		dev_warn(&pdev->dev, "ISILoad:Card%u reset failure (Possible "
+			"bad I/O Port Address 0x%lx).\n", card + 1, base);
+		dev_dbg(&pdev->dev, "Sig=0x%x\n", sig);
+		retval = -EIO;
+		goto end;
+	}
+
+	msleep(10);
@@ -1556,7 +1550,4 @@
-	if (!(inw(base + 0xe) & 0x1) || ((portcount != 0) &&
-			(portcount != 4) && (portcount != 8))) {
-		dev_dbg(&pdev->dev, "base+0x2=0x%lx, base+0xe=0x%lx\n",
-			inw(base + 0x2), inw(base + 0xe));
-		dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure "
-			"(Possible bad I/O Port Address 0x%lx).\n",
-			card + 1, base);
+	if (!inw(base + 0xe) & 0x1 || (portcount != 0 && portcount != 4 &&
+				portcount != 8 && portcount != 16)) {
+		dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure.",
+			card + 1);
@@ -1567 +1558 @@
-	switch (*signature) {
+	switch (sig) {
@@ -1574,0 +1566 @@
+	case 0xee:
@@ -1578,5 +1569,0 @@
-	default:
-		dev_warn(&pdev->dev, "ISILoad:Card%d reset failure (Possible "
-			"bad I/O Port Address 0x%lx).\n", card + 1, base);
-		dev_dbg(&pdev->dev, "Sig=0x%lx\n", signature);
-		retval = -EIO;
@@ -1584,0 +1572 @@
+	*signature = sig;
@@ -1760 +1748 @@
-static int card;
+static unsigned int card_count;
@@ -1770 +1758 @@
-	if (card >= BOARD_COUNT)
+	if (card_count >= BOARD_COUNT)
@@ -1788 +1776 @@
-	card++;
+	card_count++;
@@ -1798 +1786 @@
-		goto err;
+		goto errdec;
@@ -1827 +1815 @@
-err:
+errdec:
@@ -1828,0 +1817,2 @@
+	card_count--;
+err:
@@ -1841,0 +1832,2 @@
+	board->base = 0;
+	card_count--;
@@ -1849,2 +1840,0 @@
-	card = 0;
-
@@ -1861,2 +1850,0 @@
-			INIT_WORK(&port->hangup_tq, do_isicom_hangup);
-			INIT_WORK(&port->bh_tqueue, isicom_bottomhalf);
--- ./projects/linux/linux-2.6.21/drivers/char/isicom.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/char/isicom.c	2007-07-09 01:32:17.000000000 +0200
@@ -139,0 +140 @@
+#define pr_dbg(str...) pr_debug("ISICOM: " str)
@@ -141 +141,0 @@
-#define pr_dbg(str...) printk(KERN_DEBUG "ISICOM: " str)
@@ -144 +143,0 @@
-#define pr_dbg(str...) do { } while (0)
--- ./projects/linux/linux-2.6.22/drivers/char/isicom.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/isicom.c	2007-10-09 22:31:38.000000000 +0200
@@ -174,3 +173,0 @@
-static DECLARE_COMPLETION(isi_timerdone);
-static char re_schedule = 1;
-
@@ -190 +187 @@
-	unsigned char		irq;
+	int			irq;
@@ -230 +227 @@
-static inline int WaitTillCardIsFree(u16 base)
+static inline int WaitTillCardIsFree(unsigned long base)
@@ -246 +242,0 @@
-	char		retries;
@@ -247,0 +244 @@
+	unsigned int retries, a;
@@ -249 +246 @@
-	for (retries = 0; retries < 100; retries++) {
+	for (retries = 0; retries < 10; retries++) {
@@ -251,5 +248,4 @@
-		if (inw(base + 0xe) & 0x1) {
-			return 1;
-		} else {
-			spin_unlock_irqrestore(&card->card_lock, card->flags);
-			udelay(1000);   /* 1ms */
+		for (a = 0; a < 10; a++) {
+			if (inw(base + 0xe) & 0x1)
+				return 1;
+			udelay(10);
@@ -256,0 +253,2 @@
+		spin_unlock_irqrestore(&card->card_lock, card->flags);
+		msleep(10);
@@ -264,17 +261,0 @@
-static int lock_card_at_interrupt(struct isi_board *card)
-{
-	unsigned char		retries;
-	unsigned long base = card->base;
-
-	for (retries = 0; retries < 200; retries++) {
-		spin_lock_irqsave(&card->card_lock, card->flags);
-
-		if (inw(base + 0xe) & 0x1)
-			return 1;
-		else
-			spin_unlock_irqrestore(&card->card_lock, card->flags);
-	}
-	/* Failing in interrupt is an acceptable event */
-	return 0;	/* Failed to acquire the card! */
-}
-
@@ -418 +399,3 @@
-	short count = (BOARD_COUNT-1), card, base;
+	unsigned long flags, base;
+	unsigned int retries;
+	short count = (BOARD_COUNT-1), card;
@@ -437,0 +421,10 @@
+
+	spin_lock_irqsave(&isi_card[card].card_lock, flags);
+	for (retries = 0; retries < 100; retries++) {
+		if (inw(base + 0xe) & 0x1)
+			break;
+		udelay(2);
+	}
+	if (retries >= 100)
+		goto unlock;
+
@@ -439,2 +431,0 @@
-		if (!lock_card_at_interrupt(&isi_card[card]))
-			continue;
@@ -444 +434,0 @@
-			unlock_card(&isi_card[card]);
@@ -449,3 +439 @@
-
-		if (tty == NULL) {
-			unlock_card(&isi_card[card]);
+		if (tty == NULL)
@@ -453 +440,0 @@
-		}
@@ -456,2 +443 @@
-		if (txcount <= 0 || tty->stopped || tty->hw_stopped) {
-			unlock_card(&isi_card[card]);
+		if (txcount <= 0 || tty->stopped || tty->hw_stopped)
@@ -459,3 +445,2 @@
-		}
-		if (!(inw(base + 0x02) & (1 << port->channel))) {
-			unlock_card(&isi_card[card]);
+
+		if (!(inw(base + 0x02) & (1 << port->channel)))
@@ -463 +448 @@
-		}
+
@@ -511 +495,0 @@
-		unlock_card(&isi_card[card]);
@@ -513,0 +498,2 @@
+unlock:
+	spin_unlock_irqrestore(&isi_card[card].card_lock, flags);
@@ -516,5 +501,0 @@
-	if (!re_schedule) {
-		complete(&isi_timerdone);
- 		return;
-	}
-
@@ -1752 +1733 @@
-	unsigned int ioaddr, signature, index;
+	unsigned int signature, index;
@@ -1754 +1734,0 @@
-	u8 pciirq;
@@ -1760,3 +1739,0 @@
-	ioaddr = pci_resource_start(pdev, 3);
-	/* i.e at offset 0x1c in the PCI configuration register space. */
-	pciirq = pdev->irq;
@@ -1773,2 +1750,2 @@
-	board->base = ioaddr;
-	board->irq = pciirq;
+	board->base = pci_resource_start(pdev, 3);
+	board->irq = pdev->irq;
@@ -1904,3 +1881 @@
-	re_schedule = 0;
-
-	wait_for_completion_timeout(&isi_timerdone, HZ);
+	del_timer_sync(&tx);
--- ./projects/linux/linux-2.6.23/drivers/char/isicom.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/isicom.c	2008-01-24 23:58:37.000000000 +0100
@@ -1532 +1532 @@
-		dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure.",
+		dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure.\n",
@@ -1625 +1625,3 @@
-				"Address:0x%x\nCount:0x%x\nStatus:0x%x\n",
+				KERN_WARNING "Address:0x%x\n"
+				KERN_WARNING "Count:0x%x\n"
+				KERN_WARNING "Status:0x%x\n",
@@ -1669 +1671,3 @@
-				"Address:0x%x\nCount:0x%x\nStatus: 0x%x\n",
+				KERN_WARNING "Address:0x%x\n"
+				KERN_WARNING "Count:0x%x\n"
+				KERN_WARNING "Status: 0x%x\n",
--- ./projects/linux/linux-2.6.24/drivers/char/isicom.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/isicom.c	2008-04-17 04:49:44.000000000 +0200
@@ -1530 +1530 @@
-	if (!inw(base + 0xe) & 0x1 || (portcount != 0 && portcount != 4 &&
+	if (!(inw(base + 0xe) & 0x1) || (portcount != 0 && portcount != 4 &&
--- ./projects/linux/linux-2.6.25/drivers/char/isicom.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/isicom.c	2008-07-13 23:51:29.000000000 +0200
@@ -129,2 +129,2 @@
-#include <asm/uaccess.h>
-#include <asm/io.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
@@ -192 +192 @@
-	struct isi_port		* ports;
+	struct isi_port		*ports;
@@ -208,2 +208,2 @@
-	struct isi_board	* card;
-	struct tty_struct 	* tty;
+	struct isi_board	*card;
+	struct tty_struct 	*tty;
@@ -212 +212 @@
-	unsigned char		* xmit_buf;
+	unsigned char		*xmit_buf;
@@ -408 +408 @@
-	while(count-- > 0) {
+	while (count-- > 0) {
@@ -431 +431 @@
-	for (;count > 0;count--, port++) {
+	for (; count > 0; count--, port++) {
@@ -474 +474,2 @@
-			if (cnt <= 0) break;
+			if (cnt <= 0)
+				break;
@@ -476 +477 @@
-			outsw(base, port->xmit_buf+port->xmit_tail,word_count);
+			outsw(base, port->xmit_buf+port->xmit_tail, word_count);
@@ -559 +560 @@
-		while(byte_count > 1) {
+		while (byte_count > 1) {
@@ -572 +573 @@
-		switch(header & 0xff) {
+		switch (header & 0xff) {
@@ -659 +660,2 @@
-			while(byte_count > 0) { /* drain out unread xtra data */
+		/* drain out unread xtra data */
+		while (byte_count > 0) {
@@ -682 +684,3 @@
-	if (!(tty = port->tty) || !tty->termios)
+	tty = port->tty;
+
+	if (tty == NULL)
@@ -683,0 +688 @@
+	/* FIXME: Switch to new tty baud API */
@@ -709 +714 @@
-			baud +=2; /*  115  Kbps */
+			baud += 2; /*  115  Kbps */
@@ -719,2 +724 @@
-	}
-	else
+	} else
@@ -724 +728 @@
-		outw(0x8000 | (channel << shift_count) |0x03, base);
+		outw(0x8000 | (channel << shift_count) | 0x03, base);
@@ -727 +731 @@
-		switch(C_CSIZE(tty)) {
+		switch (C_CSIZE(tty)) {
@@ -770 +774 @@
-		outw(0x8000 | (channel << shift_count) |0x04, base);
+		outw(0x8000 | (channel << shift_count) | 0x04, base);
@@ -808 +812 @@
-	if (port->flags & ASYNC_INITIALIZED) {
+	if (port->flags & ASYNC_INITIALIZED)
@@ -810 +813,0 @@
-	}
@@ -812,3 +815,3 @@
-		unsigned long page;
-
-		if (!(page = get_zeroed_page(GFP_KERNEL)))
+		/* Relies on BKL */
+		unsigned long page  = get_zeroed_page(GFP_KERNEL);
+		if (page == 0)
@@ -816,2 +819 @@
-
-		if (port->xmit_buf) {
+		if (port->xmit_buf)
@@ -819,3 +821,2 @@
-			return -ERESTARTSYS;
-		}
-		port->xmit_buf = (unsigned char *) page;
+		else
+			port->xmit_buf = (unsigned char *) page;
@@ -952,6 +953,4 @@
-	if ((error = isicom_setup_port(port))!=0)
-		return error;
-	if ((error = block_til_ready(tty, filp, port))!=0)
-		return error;
-
-	return 0;
+	error = isicom_setup_port(port);
+	if (error == 0)
+		error = block_til_ready(tty, filp, port);
+	return error;
@@ -964 +963 @@
-	if (bp->status & BOARD_ACTIVE) {
+	if (bp->status & BOARD_ACTIVE)
@@ -966 +964,0 @@
-	}
@@ -1014,0 +1013,16 @@
+static void isicom_flush_buffer(struct tty_struct *tty)
+{
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
+	unsigned long flags;
+
+	if (isicom_paranoia_check(port, tty->name, "isicom_flush_buffer"))
+		return;
+
+	spin_lock_irqsave(&card->card_lock, flags);
+	port->xmit_cnt = port->xmit_head = port->xmit_tail = 0;
+	spin_unlock_irqrestore(&card->card_lock, flags);
+
+	tty_wakeup(tty);
+}
+
@@ -1068,2 +1082 @@
-	if (tty->driver->flush_buffer)
-		tty->driver->flush_buffer(tty);
+	isicom_flush_buffer(tty);
@@ -1107 +1120 @@
-	while(1) {
+	while (1) {
@@ -1128 +1141 @@
-static void isicom_put_char(struct tty_struct *tty, unsigned char ch)
+static int isicom_put_char(struct tty_struct *tty, unsigned char ch)
@@ -1135 +1148 @@
-		return;
+		return 0;
@@ -1138 +1151 @@
-		return;
+		return 0;
@@ -1143 +1156 @@
-		return;
+		return 0;
@@ -1149,0 +1163 @@
+	return 1;
@@ -1260,0 +1275,2 @@
+	lock_kernel();
+
@@ -1268 +1284,2 @@
-				(port->flags & ~ASYNC_USR_MASK)))
+				(port->flags & ~ASYNC_USR_MASK))) {
+			unlock_kernel();
@@ -1270 +1287,2 @@
-		port->flags = ((port->flags & ~ ASYNC_USR_MASK) |
+		}
+		port->flags = ((port->flags & ~ASYNC_USR_MASK) |
@@ -1272,2 +1290 @@
-	}
-	else {
+	} else {
@@ -1284,0 +1302 @@
+	unlock_kernel();
@@ -1292,0 +1311 @@
+	lock_kernel();
@@ -1301,0 +1321 @@
+	unlock_kernel();
@@ -1317 +1337 @@
-	switch(cmd) {
+	switch (cmd) {
@@ -1334,13 +1353,0 @@
-
-	case TIOCGSOFTCAR:
-		return put_user(C_CLOCAL(tty) ? 1 : 0,
-				(unsigned long __user *)argp);
-
-	case TIOCSSOFTCAR:
-		if (get_user(arg, (unsigned long __user *) argp))
-			return -EFAULT;
-		tty->termios->c_cflag =
-			((tty->termios->c_cflag & ~CLOCAL) |
-			(arg ? CLOCAL : 0));
-		return 0;
-
@@ -1456,16 +1462,0 @@
-/* flush_buffer et all */
-static void isicom_flush_buffer(struct tty_struct *tty)
-{
-	struct isi_port *port = tty->driver_data;
-	struct isi_board *card = port->card;
-	unsigned long flags;
-
-	if (isicom_paranoia_check(port, tty->name, "isicom_flush_buffer"))
-		return;
-
-	spin_lock_irqsave(&card->card_lock, flags);
-	port->xmit_cnt = port->xmit_head = port->xmit_tail = 0;
-	spin_unlock_irqrestore(&card->card_lock, flags);
-
-	tty_wakeup(tty);
-}
@@ -1595 +1586 @@
- 	}
+	}
@@ -1623 +1614,2 @@
-		if ((status = inw(base + 0x4)) != 0) {
+		status = inw(base + 0x4);
+		if (status != 0) {
@@ -1640 +1632,2 @@
-		if ((status = inw(base + 0x4)) != 0) {
+		status = inw(base + 0x4);
+		if (status != 0) {
@@ -1645 +1638 @@
- 	}
+	}
@@ -1669 +1662,2 @@
-		if ((status = inw(base + 0x4)) != 0) {
+		status = inw(base + 0x4);
+		if (status != 0) {
@@ -1702 +1696,2 @@
-		if ((status = inw(base + 0x4)) != 0) {
+		status = inw(base + 0x4);
+		if (status != 0) {
@@ -1767 +1762 @@
- 	}
+	}
@@ -1821 +1816 @@
-	for(idx = 0; idx < BOARD_COUNT; idx++) {
+	for (idx = 0; idx < BOARD_COUNT; idx++) {
@@ -1835 +1830 @@
- 		}
+		}
--- ./projects/linux/linux-2.6.26/drivers/char/isicom.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/char/isicom.c	2008-10-10 00:13:53.000000000 +0200
@@ -201,4 +201 @@
-	unsigned int		flags;
-	int			count;
-	int			blocked_open;
-	int			close_delay;
+	struct tty_port		port;
@@ -207 +203,0 @@
-	u16			closing_wait;
@@ -209,3 +204,0 @@
-	struct tty_struct 	*tty;
-	wait_queue_head_t	close_wait;
-	wait_queue_head_t	open_wait;
@@ -433 +426 @@
-		if (!(port->flags & ASYNC_INITIALIZED) ||
+		if (!(port->port.flags & ASYNC_INITIALIZED) ||
@@ -437 +430 @@
-		tty = port->tty;
+		tty = port->port.tty;
@@ -461 +454 @@
-					wrd |= (port->xmit_buf[port->xmit_tail]
+					wrd |= (port->port.xmit_buf[port->xmit_tail]
@@ -477 +470 @@
-			outsw(base, port->xmit_buf+port->xmit_tail, word_count);
+			outsw(base, port->port.xmit_buf+port->xmit_tail, word_count);
@@ -484 +477 @@
-				wrd = port->xmit_buf[port->xmit_tail];
+				wrd = port->port.xmit_buf[port->xmit_tail];
@@ -551 +544 @@
-	if (!(port->flags & ASYNC_INITIALIZED)) {
+	if (!(port->port.flags & ASYNC_INITIALIZED)) {
@@ -557 +550 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -575 +568 @@
-			if (port->flags & ASYNC_CHECK_CD) {
+			if (port->port.flags & ASYNC_CHECK_CD) {
@@ -588 +581 @@
-					wake_up_interruptible(&port->open_wait);
+					wake_up_interruptible(&port->port.open_wait);
@@ -597,2 +590,2 @@
-			if (port->flags & ASYNC_CTS_FLOW) {
-				if (port->tty->hw_stopped) {
+			if (port->port.flags & ASYNC_CTS_FLOW) {
+				if (port->port.tty->hw_stopped) {
@@ -600 +593 @@
-						port->tty->hw_stopped = 0;
+						port->port.tty->hw_stopped = 0;
@@ -607 +600 @@
-					port->tty->hw_stopped = 1;
+					port->port.tty->hw_stopped = 1;
@@ -632 +625 @@
-			if (port->flags & ASYNC_SAK)
+			if (port->port.flags & ASYNC_SAK)
@@ -684 +677 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -700 +693 @@
-			port->tty->termios->c_cflag &= ~CBAUDEX;
+			port->port.tty->termios->c_cflag &= ~CBAUDEX;
@@ -711 +704 @@
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+		if ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
@@ -713 +706 @@
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+		if ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
@@ -715 +708 @@
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+		if ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
@@ -717 +710 @@
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+		if ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
@@ -757 +750 @@
-		port->flags &= ~ASYNC_CHECK_CD;
+		port->port.flags &= ~ASYNC_CHECK_CD;
@@ -759 +752 @@
-		port->flags |= ASYNC_CHECK_CD;
+		port->port.flags |= ASYNC_CHECK_CD;
@@ -763 +756 @@
-	port->flags &= ~ASYNC_CTS_FLOW;
+	port->port.flags &= ~ASYNC_CTS_FLOW;
@@ -765 +758 @@
-		port->flags |= ASYNC_CTS_FLOW;
+		port->port.flags |= ASYNC_CTS_FLOW;
@@ -812 +805 @@
-	if (port->flags & ASYNC_INITIALIZED)
+	if (port->port.flags & ASYNC_INITIALIZED)
@@ -814,10 +807,2 @@
-	if (!port->xmit_buf) {
-		/* Relies on BKL */
-		unsigned long page  = get_zeroed_page(GFP_KERNEL);
-		if (page == 0)
-			return -ENOMEM;
-		if (port->xmit_buf)
-			free_page(page);
-		else
-			port->xmit_buf = (unsigned char *) page;
-	}
+	if (tty_port_alloc_xmit_buf(&port->port) < 0)
+		return -ENOMEM;
@@ -826,3 +811,3 @@
-	if (port->tty)
-		clear_bit(TTY_IO_ERROR, &port->tty->flags);
-	if (port->count == 1)
+	if (port->port.tty)
+		clear_bit(TTY_IO_ERROR, &port->port.tty->flags);
+	if (port->port.count == 1)
@@ -842 +827 @@
-	port->flags |= ASYNC_INITIALIZED;
+	port->port.flags |= ASYNC_INITIALIZED;
@@ -858 +843 @@
-	if (tty_hung_up_p(filp) || port->flags & ASYNC_CLOSING) {
+	if (tty_hung_up_p(filp) || port->port.flags & ASYNC_CLOSING) {
@@ -860,2 +845,2 @@
-		interruptible_sleep_on(&port->close_wait);
-		if (port->flags & ASYNC_HUP_NOTIFY)
+		interruptible_sleep_on(&port->port.close_wait);
+		if (port->port.flags & ASYNC_HUP_NOTIFY)
@@ -872 +857 @@
-		port->flags |= ASYNC_NORMAL_ACTIVE;
+		port->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -882 +867 @@
-	add_wait_queue(&port->open_wait, &wait);
+	add_wait_queue(&port->port.open_wait, &wait);
@@ -886,2 +871,2 @@
-		port->count--;
-	port->blocked_open++;
+		port->port.count--;
+	port->port.blocked_open++;
@@ -894,2 +879,2 @@
-		if (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)) {
-			if (port->flags & ASYNC_HUP_NOTIFY)
+		if (tty_hung_up_p(filp) || !(port->port.flags & ASYNC_INITIALIZED)) {
+			if (port->port.flags & ASYNC_HUP_NOTIFY)
@@ -901 +886 @@
-		if (!(port->flags & ASYNC_CLOSING) &&
+		if (!(port->port.flags & ASYNC_CLOSING) &&
@@ -912 +897 @@
-	remove_wait_queue(&port->open_wait, &wait);
+	remove_wait_queue(&port->port.open_wait, &wait);
@@ -915,2 +900,2 @@
-		port->count++;
-	port->blocked_open--;
+		port->port.count++;
+	port->port.blocked_open--;
@@ -920 +905 @@
-	port->flags |= ASYNC_NORMAL_ACTIVE;
+	port->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -950 +935 @@
-	port->count++;
+	port->port.count++;
@@ -952 +937 @@
-	port->tty = tty;
+	port->port.tty = tty;
@@ -973 +958 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -975 +960 @@
-	if (!(port->flags & ASYNC_INITIALIZED))
+	if (!(port->port.flags & ASYNC_INITIALIZED))
@@ -978,5 +963,2 @@
-	if (port->xmit_buf) {
-		free_page((unsigned long) port->xmit_buf);
-		port->xmit_buf = NULL;
-	}
-	port->flags &= ~ASYNC_INITIALIZED;
+	tty_port_free_xmit_buf(&port->port);
+	port->port.flags &= ~ASYNC_INITIALIZED;
@@ -984 +966 @@
-	port->tty = NULL;
+	port->port.tty = NULL;
@@ -1049 +1031 @@
-	if (tty->count == 1 && port->count != 1) {
+	if (tty->count == 1 && port->port.count != 1) {
@@ -1052,2 +1034,2 @@
-			card->base, port->count);
-		port->count = 1;
+			card->base, port->port.count);
+		port->port.count = 1;
@@ -1055 +1037 @@
-	if (--port->count < 0) {
+	if (--port->port.count < 0) {
@@ -1058,2 +1040,2 @@
-			port->count);
-		port->count = 0;
+			port->port.count);
+		port->port.count = 0;
@@ -1062 +1044 @@
-	if (port->count) {
+	if (port->port.count) {
@@ -1066 +1048 @@
-	port->flags |= ASYNC_CLOSING;
+	port->port.flags |= ASYNC_CLOSING;
@@ -1070,2 +1052,2 @@
-	if (port->closing_wait != ASYNC_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, port->closing_wait);
+	if (port->port.closing_wait != ASYNC_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, port->port.closing_wait);
@@ -1075 +1057 @@
-	if (port->flags & ASYNC_INITIALIZED) {
+	if (port->port.flags & ASYNC_INITIALIZED) {
@@ -1088 +1070 @@
-	if (port->blocked_open) {
+	if (port->port.blocked_open) {
@@ -1090 +1072 @@
-		if (port->close_delay) {
+		if (port->port.close_delay) {
@@ -1093 +1075 @@
-				jiffies_to_msecs(port->close_delay));
+				jiffies_to_msecs(port->port.close_delay));
@@ -1096 +1078 @@
-		wake_up_interruptible(&port->open_wait);
+		wake_up_interruptible(&port->port.open_wait);
@@ -1098,2 +1080,2 @@
-	port->flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
-	wake_up_interruptible(&port->close_wait);
+	port->port.flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
+	wake_up_interruptible(&port->port.close_wait);
@@ -1115,3 +1096,0 @@
-	if (!port->xmit_buf)
-		return 0;
-
@@ -1126 +1105 @@
-		memcpy(port->xmit_buf + port->xmit_head, buf, cnt);
+		memcpy(port->port.xmit_buf + port->xmit_head, buf, cnt);
@@ -1150,3 +1128,0 @@
-	if (!port->xmit_buf)
-		return 0;
-
@@ -1159 +1135 @@
-	port->xmit_buf[port->xmit_head++] = ch;
+	port->port.xmit_buf[port->xmit_head++] = ch;
@@ -1175 +1151 @@
-			!port->xmit_buf)
+			!port->port.xmit_buf)
@@ -1208,2 +1184 @@
-static inline void isicom_send_break(struct isi_port *port,
-	unsigned long length)
+static int isicom_send_break(struct tty_struct *tty, int length)
@@ -1210,0 +1186 @@
+	struct isi_port *port = tty->driver_data;
@@ -1213,0 +1190,3 @@
+	if (length == -1)
+		return -EOPNOTSUPP;
+
@@ -1215 +1194 @@
-		return;
+		return -EINVAL;
@@ -1222,0 +1202 @@
+	return 0;
@@ -1277 +1257 @@
-	reconfig_port = ((port->flags & ASYNC_SPD_MASK) !=
+	reconfig_port = ((port->port.flags & ASYNC_SPD_MASK) !=
@@ -1281,2 +1261,2 @@
-		if ((newinfo.close_delay != port->close_delay) ||
-				(newinfo.closing_wait != port->closing_wait) ||
+		if ((newinfo.close_delay != port->port.close_delay) ||
+				(newinfo.closing_wait != port->port.closing_wait) ||
@@ -1284 +1264 @@
-				(port->flags & ~ASYNC_USR_MASK))) {
+				(port->port.flags & ~ASYNC_USR_MASK))) {
@@ -1288 +1268 @@
-		port->flags = ((port->flags & ~ASYNC_USR_MASK) |
+		port->port.flags = ((port->port.flags & ~ASYNC_USR_MASK) |
@@ -1291,3 +1271,3 @@
-		port->close_delay = newinfo.close_delay;
-		port->closing_wait = newinfo.closing_wait;
-		port->flags = ((port->flags & ~ASYNC_FLAGS) |
+		port->port.close_delay = newinfo.close_delay;
+		port->port.closing_wait = newinfo.closing_wait;
+		port->port.flags = ((port->port.flags & ~ASYNC_FLAGS) |
@@ -1317 +1297 @@
-	out_info.flags = port->flags;
+	out_info.flags = port->port.flags;
@@ -1319,2 +1299,2 @@
-	out_info.close_delay = port->close_delay;
-	out_info.closing_wait = port->closing_wait;
+	out_info.close_delay = port->port.close_delay;
+	out_info.closing_wait = port->port.closing_wait;
@@ -1332 +1311,0 @@
-	int retval;
@@ -1338,16 +1316,0 @@
-	case TCSBRK:
-		retval = tty_check_change(tty);
-		if (retval)
-			return retval;
-		tty_wait_until_sent(tty, 0);
-		if (!arg)
-			isicom_send_break(port, HZ/4);
-		return 0;
-
-	case TCSBRKP:
-		retval = tty_check_change(tty);
-		if (retval)
-			return retval;
-		tty_wait_until_sent(tty, 0);
-		isicom_send_break(port, arg ? arg * (HZ/10) : HZ/4);
-		return 0;
@@ -1457,4 +1420,4 @@
-	port->count = 0;
-	port->flags &= ~ASYNC_NORMAL_ACTIVE;
-	port->tty = NULL;
-	wake_up_interruptible(&port->open_wait);
+	port->port.count = 0;
+	port->port.flags &= ~ASYNC_NORMAL_ACTIVE;
+	port->port.tty = NULL;
+	wake_up_interruptible(&port->port.open_wait);
@@ -1485,0 +1449 @@
+	.break_ctl		= isicom_send_break,
@@ -1738,0 +1703,6 @@
+	retval = pci_enable_device(pdev);
+	if (retval) {
+		dev_err(&pdev->dev, "failed to enable\n");
+		goto err;
+	}
+
@@ -1792,0 +1763 @@
+	pci_disable_device(pdev);
@@ -1808,0 +1780 @@
+	pci_disable_device(pdev);
@@ -1820,0 +1793 @@
+			tty_port_init(&port->port);
@@ -1824,2 +1797,2 @@
-			port->close_delay = 50 * HZ/100;
-			port->closing_wait = 3000 * HZ/100;
+			port->port.close_delay = 50 * HZ/100;
+			port->port.closing_wait = 3000 * HZ/100;
@@ -1827,2 +1799,0 @@
-			init_waitqueue_head(&port->open_wait);
-			init_waitqueue_head(&port->close_wait);
@@ -1852 +1823 @@
-		TTY_DRIVER_DYNAMIC_DEV;
+		TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_HARDWARE_BREAK;
--- ./projects/linux/linux-2.6.27/drivers/char/isicom.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/char/isicom.c	2008-12-25 00:26:37.000000000 +0100
@@ -10 +10,2 @@
- *	1/9/98	alan@redhat.com		Merge to 2.0.x kernel tree
+ *	1/9/98	alan@lxorguk.ukuu.org.uk
+ *					Merge to 2.0.x kernel tree
@@ -15 +16,2 @@
- *	9/12/98	alan@redhat.com		Rough port to 2.1.x
+ *	9/12/98	alan@lxorguk.ukuu.org.uk
+ *					Rough port to 2.1.x
@@ -423,0 +426,4 @@
+	tty = tty_port_tty_get(&port->port);
+	if (tty == NULL)
+		goto put_unlock;
+
@@ -430,5 +435,0 @@
-		tty = port->port.tty;
-
-		if (tty == NULL)
-			continue;
-
@@ -491,0 +493,2 @@
+put_unlock:
+	tty_kref_put(tty);
@@ -550 +553 @@
-	tty = port->port.tty;
+	tty = tty_port_tty_get(&port->port);
@@ -591 +594 @@
-				if (port->port.tty->hw_stopped) {
+				if (tty->hw_stopped) {
@@ -600 +603 @@
-					port->port.tty->hw_stopped = 1;
+					tty->hw_stopped = 1;
@@ -662,0 +666 @@
+	tty_kref_put(tty);
@@ -667 +671 @@
-static void isicom_config_port(struct isi_port *port)
+static void isicom_config_port(struct tty_struct *tty)
@@ -668,0 +673 @@
+	struct isi_port *port = tty->driver_data;
@@ -670 +674,0 @@
-	struct tty_struct *tty;
@@ -677,4 +680,0 @@
-	tty = port->port.tty;
-
-	if (tty == NULL)
-		return;
@@ -693 +693 @@
-			port->port.tty->termios->c_cflag &= ~CBAUDEX;
+			tty->termios->c_cflag &= ~CBAUDEX;
@@ -800 +800 @@
-static int isicom_setup_port(struct isi_port *port)
+static int isicom_setup_port(struct tty_struct *tty)
@@ -801,0 +802 @@
+	struct isi_port *port = tty->driver_data;
@@ -811,2 +812 @@
-	if (port->port.tty)
-		clear_bit(TTY_IO_ERROR, &port->port.tty->flags);
+	clear_bit(TTY_IO_ERROR, &tty->flags);
@@ -826 +826 @@
-	isicom_config_port(port);
+	isicom_config_port(tty);
@@ -937,2 +937,2 @@
-	port->port.tty = tty;
-	error = isicom_setup_port(port);
+	tty_port_tty_set(&port->port, tty);
+	error = isicom_setup_port(tty);
@@ -958 +958 @@
-	tty = port->port.tty;
+	tty = tty_port_tty_get(&port->port);
@@ -960 +960,2 @@
-	if (!(port->port.flags & ASYNC_INITIALIZED))
+	if (!(port->port.flags & ASYNC_INITIALIZED)) {
+		tty_kref_put(tty);
@@ -961,0 +963 @@
+	}
@@ -966 +968 @@
-	port->port.tty = NULL;
+	tty_port_tty_set(&port->port, NULL);
@@ -1246,2 +1248,2 @@
-static int isicom_set_serial_info(struct isi_port *port,
-	struct serial_struct __user *info)
+static int isicom_set_serial_info(struct tty_struct *tty,
+					struct serial_struct __user *info)
@@ -1248,0 +1251 @@
+	struct isi_port *port = tty->driver_data;
@@ -1279 +1282 @@
-		isicom_config_port(port);
+		isicom_config_port(tty);
@@ -1321 +1324 @@
-		return isicom_set_serial_info(port, argp);
+		return isicom_set_serial_info(tty, argp);
@@ -1344 +1347 @@
-	isicom_config_port(port);
+	isicom_config_port(tty);
@@ -1422 +1425 @@
-	port->port.tty = NULL;
+	tty_port_tty_set(&port->port, NULL);
--- ./projects/linux/linux-2.6.28/drivers/char/isicom.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/char/isicom.c	2009-03-24 00:12:14.000000000 +0100
@@ -331 +331,2 @@
-static inline void raise_dtr_rts(struct isi_port *port)
+
+static void isicom_raise_dtr_rts(struct tty_port *port)
@@ -333 +334,2 @@
-	struct isi_board *card = port->card;
+	struct isi_port *ip = container_of(port, struct isi_port, port);
+	struct isi_board *card = ip->card;
@@ -335 +337 @@
-	u16 channel = port->channel;
+	u16 channel = ip->channel;
@@ -343 +345 @@
-	port->status |= (ISI_DTR | ISI_RTS);
+	ip->status |= (ISI_DTR | ISI_RTS);
@@ -833,2 +835 @@
-static int block_til_ready(struct tty_struct *tty, struct file *filp,
-	struct isi_port *port)
+static int isicom_carrier_raised(struct tty_port *port)
@@ -836,71 +837,2 @@
-	struct isi_board *card = port->card;
-	int do_clocal = 0, retval;
-	unsigned long flags;
-	DECLARE_WAITQUEUE(wait, current);
-
-	/* block if port is in the process of being closed */
-
-	if (tty_hung_up_p(filp) || port->port.flags & ASYNC_CLOSING) {
-		pr_dbg("block_til_ready: close in progress.\n");
-		interruptible_sleep_on(&port->port.close_wait);
-		if (port->port.flags & ASYNC_HUP_NOTIFY)
-			return -EAGAIN;
-		else
-			return -ERESTARTSYS;
-	}
-
-	/* if non-blocking mode is set ... */
-
-	if ((filp->f_flags & O_NONBLOCK) ||
-			(tty->flags & (1 << TTY_IO_ERROR))) {
-		pr_dbg("block_til_ready: non-block mode.\n");
-		port->port.flags |= ASYNC_NORMAL_ACTIVE;
-		return 0;
-	}
-
-	if (C_CLOCAL(tty))
-		do_clocal = 1;
-
-	/* block waiting for DCD to be asserted, and while
-						callout dev is busy */
-	retval = 0;
-	add_wait_queue(&port->port.open_wait, &wait);
-
-	spin_lock_irqsave(&card->card_lock, flags);
-	if (!tty_hung_up_p(filp))
-		port->port.count--;
-	port->port.blocked_open++;
-	spin_unlock_irqrestore(&card->card_lock, flags);
-
-	while (1) {
-		raise_dtr_rts(port);
-
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (tty_hung_up_p(filp) || !(port->port.flags & ASYNC_INITIALIZED)) {
-			if (port->port.flags & ASYNC_HUP_NOTIFY)
-				retval = -EAGAIN;
-			else
-				retval = -ERESTARTSYS;
-			break;
-		}
-		if (!(port->port.flags & ASYNC_CLOSING) &&
-				(do_clocal || (port->status & ISI_DCD))) {
-			break;
-		}
-		if (signal_pending(current)) {
-			retval = -ERESTARTSYS;
-			break;
-		}
-		schedule();
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&port->port.open_wait, &wait);
-	spin_lock_irqsave(&card->card_lock, flags);
-	if (!tty_hung_up_p(filp))
-		port->port.count++;
-	port->port.blocked_open--;
-	spin_unlock_irqrestore(&card->card_lock, flags);
-	if (retval)
-		return retval;
-	port->port.flags |= ASYNC_NORMAL_ACTIVE;
-	return 0;
+	struct isi_port *ip = container_of(port, struct isi_port, port);
+	return (ip->status & ISI_DCD)?1 : 0;
@@ -934,0 +867 @@
+	/* FIXME: locking on port.count etc */
@@ -940 +873 @@
-		error = block_til_ready(tty, filp, port);
+		error = tty_port_block_til_ready(&port->port, tty, filp);
@@ -1015 +948,2 @@
-	struct isi_port *port = tty->driver_data;
+	struct isi_port *ip = tty->driver_data;
+	struct tty_port *port = &ip->port;
@@ -1019,26 +953 @@
-	if (!port)
-		return;
-	card = port->card;
-	if (isicom_paranoia_check(port, tty->name, "isicom_close"))
-		return;
-
-	pr_dbg("Close start!!!.\n");
-
-	spin_lock_irqsave(&card->card_lock, flags);
-	if (tty_hung_up_p(filp)) {
-		spin_unlock_irqrestore(&card->card_lock, flags);
-		return;
-	}
-
-	if (tty->count == 1 && port->port.count != 1) {
-		printk(KERN_WARNING "ISICOM:(0x%lx) isicom_close: bad port "
-			"count tty->count = 1 port count = %d.\n",
-			card->base, port->port.count);
-		port->port.count = 1;
-	}
-	if (--port->port.count < 0) {
-		printk(KERN_WARNING "ISICOM:(0x%lx) isicom_close: bad port "
-			"count for channel%d = %d", card->base, port->channel,
-			port->port.count);
-		port->port.count = 0;
-	}
+	BUG_ON(!ip);
@@ -1046,2 +955,2 @@
-	if (port->port.count) {
-		spin_unlock_irqrestore(&card->card_lock, flags);
+	card = ip->card;
+	if (isicom_paranoia_check(ip, tty->name, "isicom_close"))
@@ -1049,4 +957,0 @@
-	}
-	port->port.flags |= ASYNC_CLOSING;
-	tty->closing = 1;
-	spin_unlock_irqrestore(&card->card_lock, flags);
@@ -1054,2 +958,0 @@
-	if (port->port.closing_wait != ASYNC_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, port->port.closing_wait);
@@ -1059,2 +962,2 @@
-	if (port->port.flags & ASYNC_INITIALIZED) {
-		card->port_status &= ~(1 << port->channel);
+	if (port->flags & ASYNC_INITIALIZED) {
+		card->port_status &= ~(1 << ip->channel);
@@ -1063 +966 @@
-	isicom_shutdown_port(port);
+	isicom_shutdown_port(ip);
@@ -1067,18 +970,2 @@
-	tty_ldisc_flush(tty);
-
-	spin_lock_irqsave(&card->card_lock, flags);
-	tty->closing = 0;
-
-	if (port->port.blocked_open) {
-		spin_unlock_irqrestore(&card->card_lock, flags);
-		if (port->port.close_delay) {
-			pr_dbg("scheduling until time out.\n");
-			msleep_interruptible(
-				jiffies_to_msecs(port->port.close_delay));
-		}
-		spin_lock_irqsave(&card->card_lock, flags);
-		wake_up_interruptible(&port->port.open_wait);
-	}
-	port->port.flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
-	wake_up_interruptible(&port->port.close_wait);
-	spin_unlock_irqrestore(&card->card_lock, flags);
+	
+	tty_port_close_end(port, tty);
@@ -1423,4 +1310 @@
-	port->port.count = 0;
-	port->port.flags &= ~ASYNC_NORMAL_ACTIVE;
-	tty_port_tty_set(&port->port, NULL);
-	wake_up_interruptible(&port->port.open_wait);
+	tty_port_hangup(&port->port);
@@ -1454,0 +1339,5 @@
+static const struct tty_port_operations isicom_port_ops = {
+	.carrier_raised		= isicom_carrier_raised,
+	.raise_dtr_rts		= isicom_raise_dtr_rts,
+};
+
@@ -1796,0 +1686 @@
+			port->port.ops = &isicom_port_ops;
--- ./projects/linux/linux-2.6.29/drivers/char/isicom.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/char/isicom.c	2009-06-27 11:32:32.000000000 +0200
@@ -927,0 +928 @@
+	tty_kref_put(tty);
--- ./projects/linux/linux-2.6.13/drivers/char/mxser.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/char/mxser.c	2005-10-28 02:02:08.000000000 +0200
@@ -66 +65,0 @@
-#include <asm/segment.h>
@@ -1062,2 +1061 @@
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(5);
+			schedule_timeout_interruptible(5);
@@ -1084,4 +1082,2 @@
-		if (info->close_delay) {
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(info->close_delay);
-		}
+		if (info->close_delay)
+			schedule_timeout_interruptible(info->close_delay);
@@ -1805,2 +1801 @@
-		set_current_state(TASK_INTERRUPTIBLE);
-		schedule_timeout(char_time);
+		schedule_timeout_interruptible(char_time);
--- ./projects/linux/linux-2.6.14/drivers/char/mxser.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/char/mxser.c	2006-01-03 04:21:10.000000000 +0100
@@ -41 +40,0 @@
-#include <linux/version.h>
@@ -472,0 +472,2 @@
+	.break_ctl = mxser_rs_break,
+	.wait_until_sent = mxser_wait_until_sent,
@@ -495 +496 @@
-	int i, err = 0;
+	int i, err;
@@ -500 +501,4 @@
-	if ((err |= tty_unregister_driver(mxvar_sdriver)))
+	err = tty_unregister_driver(mxvar_sdriver);
+	if (!err)
+		put_tty_driver(mxvar_sdriver);
+	else
@@ -502,0 +507 @@
+
@@ -691 +695,0 @@
-	int ret1;
@@ -725,18 +728,0 @@
-	mxvar_sdriver->open = mxser_open;
-	mxvar_sdriver->close = mxser_close;
-	mxvar_sdriver->write = mxser_write;
-	mxvar_sdriver->put_char = mxser_put_char;
-	mxvar_sdriver->flush_chars = mxser_flush_chars;
-	mxvar_sdriver->write_room = mxser_write_room;
-	mxvar_sdriver->chars_in_buffer = mxser_chars_in_buffer;
-	mxvar_sdriver->flush_buffer = mxser_flush_buffer;
-	mxvar_sdriver->ioctl = mxser_ioctl;
-	mxvar_sdriver->throttle = mxser_throttle;
-	mxvar_sdriver->unthrottle = mxser_unthrottle;
-	mxvar_sdriver->set_termios = mxser_set_termios;
-	mxvar_sdriver->stop = mxser_stop;
-	mxvar_sdriver->start = mxser_start;
-	mxvar_sdriver->hangup = mxser_hangup;
-	mxvar_sdriver->break_ctl = mxser_rs_break;
-	mxvar_sdriver->wait_until_sent = mxser_wait_until_sent;
-
@@ -873,4 +859,2 @@
-	ret1 = 0;
-	if (!(ret1 = tty_register_driver(mxvar_sdriver))) {
-		return 0;
-	} else
+	retval = tty_register_driver(mxvar_sdriver);
+	if (retval) {
@@ -877,0 +862 @@
+		put_tty_driver(mxvar_sdriver);
@@ -879,2 +863,0 @@
-
-	if (ret1) {
@@ -889 +872 @@
-		return -1;
+		return retval;
@@ -892 +875 @@
-	return (0);
+	return 0;
@@ -935,0 +919,3 @@
+	/* initialize driver_data in case something fails */
+	tty->driver_data = NULL;
+
@@ -998 +984 @@
-		BUG();
+		return;
--- ./projects/linux/linux-2.6.15/drivers/char/mxser.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/mxser.c	2006-03-20 06:53:29.000000000 +0100
@@ -816 +816 @@
-	n = (sizeof(mxser_pcibrds) / sizeof(mxser_pcibrds[0])) - 1;
+	n = ARRAY_SIZE(mxser_pcibrds) - 1;
@@ -1985 +1985 @@
-	recv_room = tty->ldisc.receive_room(tty);
+	recv_room = tty->receive_room;
--- ./projects/linux/linux-2.6.16/drivers/char/mxser.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/char/mxser.c	2006-06-18 03:49:35.000000000 +0200
@@ -246,4 +246,4 @@
-MODULE_PARM(ioaddr, "1-4i");
-MODULE_PARM(ttymajor, "i");
-MODULE_PARM(calloutmajor, "i");
-MODULE_PARM(verbose, "i");
+module_param_array(ioaddr, int, NULL, 0);
+module_param(ttymajor, int, 0);
+module_param(calloutmajor, int, 0);
+module_param(verbose, bool, 0);
--- ./projects/linux/linux-2.6.17/drivers/char/mxser.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/mxser.c	2006-09-20 05:42:06.000000000 +0200
@@ -12 +12 @@
-*      (at your option) any later version.
+ *      (at your option) any later version.
@@ -39 +38,0 @@
-#include <linux/config.h>
@@ -74,2 +73,2 @@
-#define	MXSER_EVENT_TXLOW	 1
-#define	MXSER_EVENT_HANGUP	 2
+#define	MXSER_EVENT_TXLOW	1
+#define	MXSER_EVENT_HANGUP	2
@@ -95 +94,2 @@
-#define RELEVANT_IFLAG(iflag)	(iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK|IXON|IXOFF))
+#define RELEVANT_IFLAG(iflag)	(iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK|\
+					  IXON|IXOFF))
@@ -97 +97 @@
-#define IRQ_T(info) ((info->flags & ASYNC_SHARE_IRQ) ? SA_SHIRQ : SA_INTERRUPT)
+#define IRQ_T(info) ((info->flags & ASYNC_SHARE_IRQ) ? IRQF_SHARED : IRQF_DISABLED)
@@ -155,21 +155,21 @@
-	8,			// C168-ISA
-	4,			// C104-ISA
-	4,			// CI104J
-	8,			// C168-PCI
-	4,			// C104-PCI
-	2,			// C102-ISA
-	2,			// CI132
-	4,			// CI134
-	2,			// CP132
-	4,			// CP114
-	4,			// CT114
-	2,			// CP102
-	4,			// CP104U
-	8,			// CP168U
-	2,			// CP132U
-	4,			// CP134U
-	4,			// CP104JU
-	8,			// RC7000
-	8,			// CP118U 
-	2,			// CP102UL 
-	2,			// CP102U
+	8,			/* C168-ISA */
+	4,			/* C104-ISA */
+	4,			/* CI104J */
+	8,			/* C168-PCI */
+	4,			/* C104-PCI */
+	2,			/* C102-ISA */
+	2,			/* CI132 */
+	4,			/* CI134 */
+	2,			/* CP132 */
+	4,			/* CP114 */
+	4,			/* CT114 */
+	2,			/* CP102 */
+	4,			/* CP104U */
+	8,			/* CP168U */
+	2,			/* CP132U */
+	4,			/* CP134U */
+	4,			/* CP104JU */
+	8,			/* RC7000 */
+	8,			/* CP118U */
+	2,			/* CP102UL */
+	2,			/* CP102U */
@@ -185 +185 @@
-// This is only for PCI
+/* This is only for PCI */
@@ -234 +234 @@
-	struct pci_dev *pdev;	// add by Victor Yu. 06-23-2003
+	struct pci_dev *pdev;	/* add by Victor Yu. 06-23-2003 */
@@ -282,0 +283 @@
+
@@ -293,3 +294,3 @@
-	int IsMoxaMustChipFlag;	// add by Victor Yu. 08-30-2002
-	int MaxCanSetBaudRate[MXSER_PORTS_PER_BOARD];	// add by Victor Yu. 09-04-2002
-	int opmode_ioaddr[MXSER_PORTS_PER_BOARD];	// add by Victor Yu. 01-05-2004
+	int IsMoxaMustChipFlag;	/* add by Victor Yu. 08-30-2002 */
+	int MaxCanSetBaudRate[MXSER_PORTS_PER_BOARD];	/* add by Victor Yu. 09-04-2002 */
+	int opmode_ioaddr[MXSER_PORTS_PER_BOARD];	/* add by Victor Yu. 01-05-2004 */
@@ -337,3 +338,3 @@
-	int IsMoxaMustChipFlag;	// add by Victor Yu. 08-30-2002
-	int MaxCanSetBaudRate;	// add by Victor Yu. 09-04-2002
-	int opmode_ioaddr;	// add by Victor Yu. 01-05-2004
+	int IsMoxaMustChipFlag;	/* add by Victor Yu. 08-30-2002 */
+	int MaxCanSetBaudRate;	/* add by Victor Yu. 09-04-2002 */
+	int opmode_ioaddr;	/* add by Victor Yu. 01-05-2004 */
@@ -348 +348,0 @@
-
@@ -361 +361 @@
-	    /*  0x180, 0x280, 0x200, 0x320   */
+	/*  0x180, 0x280, 0x200, 0x320 */
@@ -389 +389 @@
-//static void   mxser_poll(unsigned long);
+/* static void   mxser_poll(unsigned long); */
@@ -443 +443 @@
-		return (MOXA_OTHER_UART);
+		return MOXA_OTHER_UART;
@@ -449 +449 @@
-			return (int) hwid;
+			return (int)hwid;
@@ -454 +454 @@
-// above is modified by Victor Yu. 08-15-2002
+/* above is modified by Victor Yu. 08-15-2002 */
@@ -507 +506,0 @@
-
@@ -516 +515 @@
-			if (pdev != NULL) {	//PCI
+			if (pdev != NULL) {	/* PCI */
@@ -527 +525,0 @@
-
@@ -561,2 +559,4 @@
-		printk(KERN_DEBUG "        ttyM%d - ttyM%d ", n, n + hwconf->ports - 1);
-		printk(" max. baud rate = %d bps.\n", hwconf->MaxCanSetBaudRate[0]);
+		printk(KERN_DEBUG "        ttyM%d - ttyM%d ",
+			n, n + hwconf->ports - 1);
+		printk(" max. baud rate = %d bps.\n",
+			hwconf->MaxCanSetBaudRate[0]);
@@ -571 +571 @@
-		info->opmode_ioaddr = hwconf->opmode_ioaddr[i];	// add by Victor Yu. 01-05-2004
+		info->opmode_ioaddr = hwconf->opmode_ioaddr[i];	/* add by Victor Yu. 01-05-2004 */
@@ -576 +576 @@
-		//Enhance mode enabled here
+		/* Enhance mode enabled here */
@@ -609 +609,2 @@
-		outb(inb(hwconf->ioaddr[i] + UART_IER) & 0xf0, hwconf->ioaddr[i] + UART_IER);
+		outb(inb(hwconf->ioaddr[i] + UART_IER) & 0xf0,
+			hwconf->ioaddr[i] + UART_IER);
@@ -615 +616,2 @@
-	retval = request_irq(hwconf->irq, mxser_interrupt, IRQ_T(info), "mxser", info);
+	retval = request_irq(hwconf->irq, mxser_interrupt, IRQ_T(info),
+				"mxser", info);
@@ -617,2 +619,4 @@
-		printk(KERN_ERR "Board %d: %s", board, mxser_brdname[hwconf->board_type - 1]);
-		printk("  Request irq fail,IRQ (%d) may be conflit with another device.\n", info->irq);
+		printk(KERN_ERR "Board %d: %s",
+			board, mxser_brdname[hwconf->board_type - 1]);
+		printk("  Request irq failed, IRQ (%d) may conflict with"
+			" another device.\n", info->irq);
@@ -624 +627,0 @@
-
@@ -634 +637 @@
-//      unsigned int    val;
+	/* unsigned int val; */
@@ -638 +641 @@
-	//io address
+	/* io address */
@@ -642 +645,2 @@
-	request_region(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2), "mxser(IO)");
+	request_region(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2),
+			"mxser(IO)");
@@ -644 +648 @@
-	for (i = 0; i < hwconf->ports; i++) {
+	for (i = 0; i < hwconf->ports; i++)
@@ -646 +649,0 @@
-	}
@@ -648 +651 @@
-	//vector
+	/* vector */
@@ -650 +653,2 @@
-	request_region(pci_resource_start(pdev, 3), pci_resource_len(pdev, 3), "mxser(vector)");
+	request_region(pci_resource_start(pdev, 3), pci_resource_len(pdev, 3),
+			"mxser(vector)");
@@ -653 +657 @@
-	//irq
+	/* irq */
@@ -666 +670 @@
-				//exception....CP-102
+				/* exception....CP-102 */
@@ -681,2 +685,2 @@
-		outb(0, ioaddress + 4);	// default set to RS232 mode
-		outb(0, ioaddress + 0x0c);	//default set to RS232 mode
+		outb(0, ioaddress + 4);	/* default set to RS232 mode */
+		outb(0, ioaddress + 0x0c);	/* default set to RS232 mode */
@@ -689 +693 @@
-	return (0);
+	return 0;
@@ -710 +714,2 @@
-	printk(KERN_INFO "MOXA Smartio/Industio family driver version %s\n", MXSER_VERSION);
+	printk(KERN_INFO "MOXA Smartio/Industio family driver version %s\n",
+		MXSER_VERSION);
@@ -722 +727 @@
-	mxvar_sdriver->init_termios.c_cflag = B9600 | CS8 | CREAD | HUPCL | CLOCAL;
+	mxvar_sdriver->init_termios.c_cflag = B9600|CS8|CREAD|HUPCL|CLOCAL;
@@ -741,0 +747 @@
+
@@ -748 +754,2 @@
-			printk(KERN_INFO "Found MOXA %s board (CAP=0x%x)\n", mxser_brdname[hwconf.board_type - 1], ioaddr[b]);
+			printk(KERN_INFO "Found MOXA %s board (CAP=0x%x)\n",
+				mxser_brdname[hwconf.board_type - 1], ioaddr[b]);
@@ -752 +759,2 @@
-				printk(KERN_ERR "Invalid interrupt number,board not configured\n");
+				printk(KERN_ERR "Invalid interrupt number, "
+					"board not configured\n");
@@ -754 +762,2 @@
-				printk(KERN_ERR "Invalid interrupt number,board not configured\n");
+				printk(KERN_ERR "Invalid interrupt number, "
+					"board not configured\n");
@@ -756 +765,2 @@
-				printk(KERN_ERR "Invalid interrupt vector,board not configured\n");
+				printk(KERN_ERR "Invalid interrupt vector, "
+					"board not configured\n");
@@ -758 +768,2 @@
-				printk(KERN_ERR "Invalid I/O address,board not configured\n");
+				printk(KERN_ERR "Invalid I/O address, "
+					"board not configured\n");
@@ -768,2 +779,5 @@
-		//init mxsercfg first, or mxsercfg data is not correct on ISR.
-		//mxser_initbrd will hook ISR.
+		/*
+		 * init mxsercfg first,
+		 * or mxsercfg data is not correct on ISR.
+		 */
+		/* mxser_initbrd will hook ISR. */
@@ -773 +786,0 @@
-
@@ -779,0 +793 @@
+
@@ -786 +800,2 @@
-			printk(KERN_INFO "Found MOXA %s board (CAP=0x%x)\n", mxser_brdname[hwconf.board_type - 1], ioaddr[b]);
+			printk(KERN_INFO "Found MOXA %s board (CAP=0x%x)\n",
+				mxser_brdname[hwconf.board_type - 1], ioaddr[b]);
@@ -790 +805,2 @@
-				printk(KERN_ERR "Invalid interrupt number,board not configured\n");
+				printk(KERN_ERR "Invalid interrupt number, "
+					"board not configured\n");
@@ -792 +808,2 @@
-				printk(KERN_ERR "Invalid interrupt number,board not configured\n");
+				printk(KERN_ERR "Invalid interrupt number, "
+					"board not configured\n");
@@ -794 +811,2 @@
-				printk(KERN_ERR "Invalid interrupt vector,board not configured\n");
+				printk(KERN_ERR "Invalid interrupt vector, "
+					"board not configured\n");
@@ -796 +814,2 @@
-				printk(KERN_ERR "Invalid I/O address,board not configured\n");
+				printk(KERN_ERR "Invalid I/O address, "
+					"board not configured\n");
@@ -806,2 +825,5 @@
-		//init mxsercfg first, or mxsercfg data is not correct on ISR.
-		//mxser_initbrd will hook ISR.
+		/*
+		 * init mxsercfg first,
+		 * or mxsercfg data is not correct on ISR.
+		 */
+		/* mxser_initbrd will hook ISR. */
@@ -820 +842,2 @@
-		pdev = pci_find_device(mxser_pcibrds[b].vendor, mxser_pcibrds[b].device, pdev);
+		pdev = pci_find_device(mxser_pcibrds[b].vendor,
+				mxser_pcibrds[b].device, pdev);
@@ -828 +851,3 @@
-		printk(KERN_INFO "Found MOXA %s board(BusNo=%d,DevNo=%d)\n", mxser_brdname[(int) (mxser_pcibrds[b].driver_data) - 1], busnum, devnum >> 3);
+		printk(KERN_INFO "Found MOXA %s board(BusNo=%d,DevNo=%d)\n",
+			mxser_brdname[(int) (mxser_pcibrds[b].driver_data) - 1],
+			busnum, devnum >> 3);
@@ -830,3 +855,6 @@
-		if (m >= MXSER_BOARDS) {
-			printk(KERN_ERR "Too many Smartio/Industio family boards find (maximum %d),board not configured\n", MXSER_BOARDS);
-		} else {
+		if (m >= MXSER_BOARDS)
+			printk(KERN_ERR
+				"Too many Smartio/Industio family boards find "
+				"(maximum %d), board not configured\n",
+				MXSER_BOARDS);
+		else {
@@ -834 +862,2 @@
-				printk(KERN_ERR "Moxa SmartI/O PCI enable fail !\n");
+				printk(KERN_ERR "Moxa SmartI/O PCI enable "
+					"fail !\n");
@@ -837 +866,3 @@
-			retval = mxser_get_PCI_conf(busnum, devnum, (int) mxser_pcibrds[b].driver_data, &hwconf);
+			retval = mxser_get_PCI_conf(busnum, devnum,
+					(int)mxser_pcibrds[b].driver_data,
+					&hwconf);
@@ -840 +871,3 @@
-					printk(KERN_ERR "Invalid interrupt number,board not configured\n");
+					printk(KERN_ERR
+						"Invalid interrupt number, "
+						"board not configured\n");
@@ -842 +875,3 @@
-					printk(KERN_ERR "Invalid interrupt number,board not configured\n");
+					printk(KERN_ERR
+						"Invalid interrupt number, "
+						"board not configured\n");
@@ -844 +879,3 @@
-					printk(KERN_ERR "Invalid interrupt vector,board not configured\n");
+					printk(KERN_ERR
+						"Invalid interrupt vector, "
+						"board not configured\n");
@@ -846 +883,3 @@
-					printk(KERN_ERR "Invalid I/O address,board not configured\n");
+					printk(KERN_ERR
+						"Invalid I/O address, "
+						"board not configured\n");
@@ -850,2 +889,4 @@
-			//init mxsercfg first, or mxsercfg data is not correct on ISR.
-			//mxser_initbrd will hook ISR.
+			/* init mxsercfg first,
+			 * or mxsercfg data is not correct on ISR.
+			 */
+			/* mxser_initbrd will hook ISR. */
@@ -861 +902,2 @@
-		printk(KERN_ERR "Couldn't install MOXA Smartio/Industio family driver !\n");
+		printk(KERN_ERR "Couldn't install MOXA Smartio/Industio family"
+				" driver !\n");
@@ -869 +911 @@
-				//todo: release io, vector
+				/* todo: release io, vector */
@@ -880 +922 @@
-	struct mxser_struct *info = (struct mxser_struct *) private_;
+	struct mxser_struct *info = private_;
@@ -929 +971 @@
-		return (-ENODEV);
+		return -ENODEV;
@@ -938 +980 @@
-		return (retval);
+		return retval;
@@ -942 +984 @@
-		return (retval);
+		return retval;
@@ -956 +997,0 @@
-	clear_bit(TTY_DONT_FLIP, &tty->flags);
@@ -958,2 +999,4 @@
-	//status = mxser_get_msr(info->base, 0, info->port);
-	//mxser_check_modem_status(info, status);
+	/*
+	status = mxser_get_msr(info->base, 0, info->port);
+	mxser_check_modem_status(info, status);
+	*/
@@ -961,2 +1004 @@
-/* unmark here for very high baud rate (ex. 921600 bps) used
-*/
+/* unmark here for very high baud rate (ex. 921600 bps) used */
@@ -975 +1017 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1000 +1042,2 @@
-		printk(KERN_ERR "mxser_close: bad serial port count; tty->count is 1, " "info->count is %d\n", info->count);
+		printk(KERN_ERR "mxser_close: bad serial port count; "
+			"tty->count is 1, info->count is %d\n", info->count);
@@ -1004 +1047,2 @@
-		printk(KERN_ERR "mxser_close: bad serial port count for ttys%d: %d\n", info->port, info->count);
+		printk(KERN_ERR "mxser_close: bad serial port count for "
+			"ttys%d: %d\n", info->port, info->count);
@@ -1059 +1103 @@
-		if(ld->flush_buffer)
+		if (ld->flush_buffer)
@@ -1081 +1125 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1084,2 +1128,2 @@
-	if (!tty || !info->xmit_buf)
-		return (0);
+	if (!info->xmit_buf)
+		return 0;
@@ -1088 +1132,2 @@
-		c = min_t(int, count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1, SERIAL_XMIT_SIZE - info->xmit_head));
+		c = min_t(int, count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
+					  SERIAL_XMIT_SIZE - info->xmit_head));
@@ -1094 +1139,2 @@
-		info->xmit_head = (info->xmit_head + c) & (SERIAL_XMIT_SIZE - 1);
+		info->xmit_head = (info->xmit_head + c) &
+				  (SERIAL_XMIT_SIZE - 1);
@@ -1101 +1146,0 @@
-
@@ -1105 +1150,3 @@
-		if (!tty->hw_stopped || (info->type == PORT_16550A) || (info->IsMoxaMustChipFlag)) {
+		if (!tty->hw_stopped ||
+				(info->type == PORT_16550A) ||
+				(info->IsMoxaMustChipFlag)) {
@@ -1117 +1164 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1120 +1167 @@
-	if (!tty || !info->xmit_buf)
+	if (!info->xmit_buf)
@@ -1132 +1179,3 @@
-		if (!tty->hw_stopped || (info->type == PORT_16550A) || info->IsMoxaMustChipFlag) {
+		if (!tty->hw_stopped ||
+				(info->type == PORT_16550A) ||
+				info->IsMoxaMustChipFlag) {
@@ -1144 +1193 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1147 +1196,7 @@
-	if (info->xmit_cnt <= 0 || tty->stopped || !info->xmit_buf || (tty->hw_stopped && (info->type != PORT_16550A) && (!info->IsMoxaMustChipFlag)))
+	if (info->xmit_cnt <= 0 ||
+			tty->stopped ||
+			!info->xmit_buf ||
+			(tty->hw_stopped &&
+			 (info->type != PORT_16550A) &&
+			 (!info->IsMoxaMustChipFlag)
+			))
@@ -1160 +1215 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1166 +1221 @@
-	return (ret);
+	return ret;
@@ -1171 +1226 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1177 +1232 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1187 +1242,2 @@
-	outb((fcr | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT), info->base + UART_FCR);
+	outb((fcr | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT),
+		info->base + UART_FCR);
@@ -1200 +1256 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1209 +1265 @@
-		return (mxser_ioctl_special(cmd, argp));
+		return mxser_ioctl_special(cmd, argp);
@@ -1211 +1267 @@
-	// following add by Victor Yu. 01-05-2004
+	/* following add by Victor Yu. 01-05-2004 */
@@ -1222 +1278,4 @@
-			if (opmode != RS232_MODE && opmode != RS485_2WIRE_MODE && opmode != RS422_MODE && opmode != RS485_4WIRE_MODE)
+			if (opmode != RS232_MODE &&
+					opmode != RS485_2WIRE_MODE &&
+					opmode != RS422_MODE &&
+					opmode != RS485_4WIRE_MODE)
@@ -1239 +1298 @@
-	// above add by Victor Yu. 01-05-2004
+	/* above add by Victor Yu. 01-05-2004 */
@@ -1243 +1302 @@
-			return (-EIO);
+			return -EIO;
@@ -1249 +1308 @@
-			return (retval);
+			return retval;
@@ -1253 +1312 @@
-		return (0);
+		return 0;
@@ -1257 +1316 @@
-			return (retval);
+			return retval;
@@ -1260 +1319 @@
-		return (0);
+		return 0;
@@ -1262 +1321 @@
-		return put_user(C_CLOCAL(tty) ? 1 : 0, (unsigned long __user *) argp);
+		return put_user(C_CLOCAL(tty) ? 1 : 0, (unsigned long __user *)argp);
@@ -1268 +1327 @@
-		return (0);
+		return 0;
@@ -1281 +1340 @@
-	case TIOCMIWAIT:{
+	case TIOCMIWAIT: {
@@ -1295 +1354,8 @@
-				if (((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) || ((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) || ((arg & TIOCM_CD) && (cnow.dcd != cprev.dcd)) || ((arg & TIOCM_CTS) && (cnow.cts != cprev.cts))) {
+				if (((arg & TIOCM_RNG) &&
+						(cnow.rng != cprev.rng)) ||
+						((arg & TIOCM_DSR) &&
+						(cnow.dsr != cprev.dsr)) ||
+						((arg & TIOCM_CD) &&
+						(cnow.dcd != cprev.dcd)) ||
+						((arg & TIOCM_CTS) &&
+						(cnow.cts != cprev.cts))) {
@@ -1341,2 +1406,0 @@
-
-/* */
@@ -1345,3 +1409,2 @@
-		return put_user(info->baud_base != 115200 ? 1 : 0, (int __user *) argp);
-
-	case MOXA_SDS_RSTICOUNTER:{
+		return put_user(info->baud_base != 115200 ? 1 : 0, (int __user *)argp);
+	case MOXA_SDS_RSTICOUNTER: {
@@ -1352 +1415 @@
-// (above) added by James.
+/* (above) added by James. */
@@ -1355 +1418 @@
-			if (get_user(baud, (long __user *) argp))
+			if (get_user(baud, (long __user *)argp))
@@ -1380 +1443 @@
-	case MOXA_ASPP_MON:{
+	case MOXA_ASPP_MON: {
@@ -1382 +1445,2 @@
-//      info->mon_data.ser_param = tty->termios->c_cflag;
+
+			/* info->mon_data.ser_param = tty->termios->c_cflag; */
@@ -1403,2 +1467,2 @@
-
-			if (copy_to_user(argp, &info->mon_data, sizeof(struct mxser_mon)))
+			if (copy_to_user(argp, &info->mon_data,
+					sizeof(struct mxser_mon)))
@@ -1408 +1471,0 @@
-
@@ -1411,2 +1474,3 @@
-	case MOXA_ASPP_LSTATUS:{
-			if (copy_to_user(argp, &info->err_shadow, sizeof(unsigned char)))
+	case MOXA_ASPP_LSTATUS: {
+			if (copy_to_user(argp, &info->err_shadow,
+					sizeof(unsigned char)))
@@ -1417 +1480,0 @@
-
@@ -1419 +1482 @@
-	case MOXA_SET_BAUD_METHOD:{
+	case MOXA_SET_BAUD_METHOD: {
@@ -1421 +1484,2 @@
-			if (get_user(method, (int __user *) argp))
+
+			if (get_user(method, (int __user *)argp))
@@ -1445 +1509,2 @@
-		if (copy_to_user(argp, mxsercfg, sizeof(struct mxser_hwconf) * 4))
+		if (copy_to_user(argp, mxsercfg,
+				sizeof(struct mxser_hwconf) * 4))
@@ -1464 +1529 @@
-		return put_user(result, (unsigned long __user *) argp);
+		return put_user(result, (unsigned long __user *)argp);
@@ -1468 +1533 @@
-		return (0);
+		return 0;
@@ -1501 +1566,2 @@
-		if (copy_to_user(argp, GMStatus, sizeof(struct mxser_mstatus) * MXSER_PORTS))
+		if (copy_to_user(argp, GMStatus,
+				sizeof(struct mxser_mstatus) * MXSER_PORTS))
@@ -1504 +1570 @@
-	case MOXA_ASPP_MON_EXT:{
+	case MOXA_ASPP_MON_EXT: {
@@ -1511 +1576,0 @@
-
@@ -1515,2 +1580,6 @@
-				status = mxser_get_msr(mxvar_table[i].base, 0, i, &(mxvar_table[i]));
-//                      mxser_check_modem_status(&mxvar_table[i], status);
+				status = mxser_get_msr(mxvar_table[i].base, 0,
+							i, &(mxvar_table[i]));
+				/*
+				mxser_check_modem_status(&mxvar_table[i],
+								status);
+				*/
@@ -1581 +1649,0 @@
-
@@ -1584,3 +1652,2 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
-	//unsigned long flags;
-
+	struct mxser_struct *info = tty->driver_data;
+	/* unsigned long flags; */
@@ -1590,3 +1657,2 @@
-
-		//MX_LOCK(&info->slock);
-		// following add by Victor Yu. 09-02-2002
+		/* MX_LOCK(&info->slock); */
+		/* following add by Victor Yu. 09-02-2002 */
@@ -1597,2 +1663 @@
-			// above add by Victor Yu. 09-02-2002
-
+			/* above add by Victor Yu. 09-02-2002 */
@@ -1600 +1665,2 @@
-			//      outb(info->IER, 0); // mask by Victor Yu. 09-02-2002
+			/* mask by Victor Yu. 09-02-2002 */
+			/* outb(info->IER, 0); */
@@ -1603,3 +1669,4 @@
-			outb(info->IER, info->base + UART_IER);	/* force Tx interrupt */
-		}		// add by Victor Yu. 09-02-2002
-		//MX_UNLOCK(&info->slock);
+			/* force Tx interrupt */
+			outb(info->IER, info->base + UART_IER);
+		}		/* add by Victor Yu. 09-02-2002 */
+		/* MX_UNLOCK(&info->slock); */
@@ -1609 +1676 @@
-		//MX_LOCK(&info->slock);
+		/* MX_LOCK(&info->slock); */
@@ -1612 +1679 @@
-		//MX_UNLOCK(&info->slock);
+		/* MX_UNLOCK(&info->slock); */
@@ -1618,2 +1685,2 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
-	//unsigned long flags;
+	struct mxser_struct *info = tty->driver_data;
+	/* unsigned long flags; */
@@ -1626 +1693 @@
-			//MX_LOCK(&info->slock);
+			/* MX_LOCK(&info->slock); */
@@ -1628 +1695 @@
-			// following add by Victor Yu. 09-02-2002
+			/* following add by Victor Yu. 09-02-2002 */
@@ -1633 +1700 @@
-				// above add by Victor Yu. 09-02-2002
+				/* above add by Victor Yu. 09-02-2002 */
@@ -1636,3 +1703,6 @@
-				//          outb(info->IER, 0); // mask by Victor Yu. 09-02-2002
-				outb(0, info->base + UART_IER);	// add by Victor Yu. 09-02-2002
-				info->IER |= UART_IER_THRI;	/* force Tx interrupt */
+				/* mask by Victor Yu. 09-02-2002 */
+				/* outb(info->IER, 0); */
+				/* add by Victor Yu. 09-02-2002 */
+				outb(0, info->base + UART_IER);
+				/* force Tx interrupt */
+				info->IER |= UART_IER_THRI;
@@ -1640,2 +1710,2 @@
-			}	// add by Victor Yu. 09-02-2002
-			//MX_UNLOCK(&info->slock);
+			}	/* add by Victor Yu. 09-02-2002 */
+			/* MX_UNLOCK(&info->slock); */
@@ -1646 +1716 @@
-		//MX_LOCK(&info->slock);
+		/* MX_LOCK(&info->slock); */
@@ -1649 +1719 @@
-		//MX_UNLOCK(&info->slock);
+		/* MX_UNLOCK(&info->slock); */
@@ -1659,3 +1729,4 @@
-	//struct mxser_struct *info = (struct mxser_struct *)tty->driver_data;
-	//unsigned long flags;
-	//MX_LOCK(&info->slock);
+	/* struct mxser_struct *info = tty->driver_data; */
+	/* unsigned long flags; */
+
+	/* MX_LOCK(&info->slock); */
@@ -1663 +1734 @@
-	//MX_UNLOCK(&info->slock);
+	/* MX_UNLOCK(&info->slock); */
@@ -1668,3 +1739,4 @@
-	//struct mxser_struct *info = (struct mxser_struct *)tty->driver_data;
-	//unsigned long flags;
-	//MX_LOCK(&info->slock);
+	/* struct mxser_struct *info = tty->driver_data; */
+	/* unsigned long flags; */
+
+	/* MX_LOCK(&info->slock); */
@@ -1672 +1744 @@
-	//MX_UNLOCK(&info->slock);
+	/* MX_UNLOCK(&info->slock); */
@@ -1677 +1749 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1680 +1752,2 @@
-	if ((tty->termios->c_cflag != old_termios->c_cflag) || (RELEVANT_IFLAG(tty->termios->c_iflag) != RELEVANT_IFLAG(old_termios->c_iflag))) {
+	if ((tty->termios->c_cflag != old_termios->c_cflag) ||
+			(RELEVANT_IFLAG(tty->termios->c_iflag) != RELEVANT_IFLAG(old_termios->c_iflag))) {
@@ -1684 +1757,2 @@
-		if ((old_termios->c_cflag & CRTSCTS) && !(tty->termios->c_cflag & CRTSCTS)) {
+		if ((old_termios->c_cflag & CRTSCTS) &&
+				!(tty->termios->c_cflag & CRTSCTS)) {
@@ -1691 +1765,2 @@
-	if ((old_termios->c_iflag & IXON) && !(tty->termios->c_iflag & IXON)) {
+	if ((old_termios->c_iflag & IXON) &&
+			!(tty->termios->c_iflag & IXON)) {
@@ -1694 +1769 @@
-		// following add by Victor Yu. 09-02-2002
+		/* following add by Victor Yu. 09-02-2002 */
@@ -1700 +1775 @@
-		// above add by Victor Yu. 09-02-2002
+		/* above add by Victor Yu. 09-02-2002 */
@@ -1714 +1789 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1727 +1802 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1743 +1818 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1780 +1855,2 @@
-	printk(KERN_DEBUG "In rs_wait_until_sent(%d) check=%lu...", timeout, char_time);
+	printk(KERN_DEBUG "In rs_wait_until_sent(%d) check=%lu...",
+		timeout, char_time);
@@ -1806 +1882 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1818 +1894 @@
-// added by James 03-12-2004.
+/* added by James 03-12-2004. */
@@ -1824 +1900 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -1829 +1905,2 @@
-		outb(inb(info->base + UART_LCR) | UART_LCR_SBC, info->base + UART_LCR);
+		outb(inb(info->base + UART_LCR) | UART_LCR_SBC,
+			info->base + UART_LCR);
@@ -1831 +1908,2 @@
-		outb(inb(info->base + UART_LCR) & ~UART_LCR_SBC, info->base + UART_LCR);
+		outb(inb(info->base + UART_LCR) & ~UART_LCR_SBC,
+			info->base + UART_LCR);
@@ -1835 +1913 @@
-// (above) added by James.
+/* (above) added by James. */
@@ -1851 +1929 @@
-	//spin_lock(&gm_lock);
+	/* spin_lock(&gm_lock); */
@@ -1860 +1938 @@
-	if (i == MXSER_BOARDS) {
+	if (i == MXSER_BOARDS)
@@ -1862,2 +1940 @@
-	}
-	if (port == 0) {
+	if (port == 0)
@@ -1865 +1941,0 @@
-	}
@@ -1869 +1945 @@
-		if (irqbits == port->vectormask) {
+		if (irqbits == port->vectormask)
@@ -1871 +1946,0 @@
-		}
@@ -1875 +1950 @@
-			if (irqbits == port->vectormask) {
+			if (irqbits == port->vectormask)
@@ -1877 +1951,0 @@
-			}
@@ -1882 +1956 @@
-			// following add by Victor Yu. 09-13-2002
+			/* following add by Victor Yu. 09-13-2002 */
@@ -1893 +1967 @@
-			// above add by Victor Yu. 09-13-2002
+			/* above add by Victor Yu. 09-13-2002 */
@@ -1895 +1969 @@
-			   if ( info->tty->flip.count < TTY_FLIPBUF_SIZE/4 ){
+			   if (info->tty->flip.count < TTY_FLIPBUF_SIZE / 4) {
@@ -1911 +1985 @@
-			// following add by Victor Yu. 09-02-2002
+			/* following add by Victor Yu. 09-02-2002 */
@@ -1914 +1988 @@
-			if (status & UART_LSR_PE) {
+			if (status & UART_LSR_PE)
@@ -1916,2 +1990 @@
-			}
-			if (status & UART_LSR_FE) {
+			if (status & UART_LSR_FE)
@@ -1919,2 +1992 @@
-			}
-			if (status & UART_LSR_OE) {
+			if (status & UART_LSR_OE)
@@ -1922 +1993,0 @@
-			}
@@ -1933 +2004,4 @@
-				if (iir == MOXA_MUST_IIR_GDA || iir == MOXA_MUST_IIR_RDA || iir == MOXA_MUST_IIR_RTO || iir == MOXA_MUST_IIR_LSR)
+				if (iir == MOXA_MUST_IIR_GDA ||
+						iir == MOXA_MUST_IIR_RDA ||
+						iir == MOXA_MUST_IIR_RTO ||
+						iir == MOXA_MUST_IIR_LSR)
@@ -1937 +2011 @@
-				// above add by Victor Yu. 09-02-2002
+				/* above add by Victor Yu. 09-02-2002 */
@@ -1947 +2021 @@
-			// following add by Victor Yu. 09-13-2002
+			/* following add by Victor Yu. 09-13-2002 */
@@ -1953 +2027 @@
-				// above add by Victor Yu. 09-13-2002
+				/* above add by Victor Yu. 09-13-2002 */
@@ -1969 +2043 @@
-	//spin_unlock(&gm_lock);
+	/* spin_unlock(&gm_lock); */
@@ -1987 +2061 @@
-		//mxser_throttle(tty);
+		/* mxser_throttle(tty); */
@@ -1989 +2063 @@
-		//return;
+		/* return; */
@@ -1992 +2066 @@
-	// following add by Victor Yu. 09-02-2002
+	/* following add by Victor Yu. 09-02-2002 */
@@ -1998,2 +2072,3 @@
-		// following add by Victor Yu. 02-11-2004
-		if (info->IsMoxaMustChipFlag == MOXA_MUST_MU860_HWID && (*status & MOXA_MUST_LSR_RERR))
+		/* following add by Victor Yu. 02-11-2004 */
+		if (info->IsMoxaMustChipFlag == MOXA_MUST_MU860_HWID &&
+				(*status & MOXA_MUST_LSR_RERR))
@@ -2001 +2076 @@
-		// above add by Victor Yu. 02-14-2004
+		/* above add by Victor Yu. 02-14-2004 */
@@ -2007 +2082,2 @@
-		if (info->IsMoxaMustChipFlag == MOXA_MUST_MU150_HWID)	// add by Victor Yu. 02-11-2004
+		/* add by Victor Yu. 02-11-2004 */
+		if (info->IsMoxaMustChipFlag == MOXA_MUST_MU150_HWID)
@@ -2011 +2087 @@
-				//mxser_throttle(tty);
+				/* mxser_throttle(tty); */
@@ -2014 +2090 @@
-			//return;
+			/* return; */
@@ -2021 +2097 @@
-			   if((cnt>=HI_WATER) && (info->stop_rx==0)){
+			   if ((cnt >= HI_WATER) && (info->stop_rx == 0)) {
@@ -2023 +2099 @@
-			   info->stop_rx=1;
+			   info->stop_rx = 1;
@@ -2029,2 +2105,2 @@
-intr_old:
-	// above add by Victor Yu. 09-02-2002
+ intr_old:
+	/* above add by Victor Yu. 09-02-2002 */
@@ -2036 +2112 @@
-		   if((cnt>=HI_WATER) && (info->stop_rx==0)){
+		   if ((cnt >= HI_WATER) && (info->stop_rx == 0)) {
@@ -2044 +2120 @@
-		// following add by Victor Yu. 09-02-2002
+		/* following add by Victor Yu. 09-02-2002 */
@@ -2048 +2124 @@
-		// above add by Victor Yu. 09-02-2002
+		/* above add by Victor Yu. 09-02-2002 */
@@ -2083 +2159 @@
-					//mxser_throttle(tty);
+					/* mxser_throttle(tty); */
@@ -2091 +2167 @@
-		// following add by Victor Yu. 09-02-2002
+		/* following add by Victor Yu. 09-02-2002 */
@@ -2094 +2170 @@
-		// above add by Victor Yu. 09-02-2002
+		/* above add by Victor Yu. 09-02-2002 */
@@ -2099 +2175 @@
-		// following add by Victor Yu. 09-02-2002
+		/* following add by Victor Yu. 09-02-2002 */
@@ -2101 +2177 @@
-		// above add by Victor Yu. 09-02-2002
+		/* above add by Victor Yu. 09-02-2002 */
@@ -2104,2 +2180 @@
-end_intr:		// add by Victor Yu. 09-02-2002
-
+end_intr:		/* add by Victor Yu. 09-02-2002 */
@@ -2140 +2215,4 @@
-	if ((info->xmit_cnt <= 0) || info->tty->stopped || (info->tty->hw_stopped && (info->type != PORT_16550A) && (!info->IsMoxaMustChipFlag))) {
+	if ((info->xmit_cnt <= 0) || info->tty->stopped ||
+			(info->tty->hw_stopped &&
+			(info->type != PORT_16550A) &&
+			(!info->IsMoxaMustChipFlag))) {
@@ -2150 +2228,2 @@
-		outb(info->xmit_buf[info->xmit_tail++], info->base + UART_TX);
+		outb(info->xmit_buf[info->xmit_tail++],
+			info->base + UART_TX);
@@ -2157 +2236 @@
-// added by James 03-12-2004.
+/* added by James 03-12-2004. */
@@ -2160 +2239 @@
-// (above) added by James.
+/* (above) added by James. */
@@ -2191 +2269,0 @@
-
@@ -2203 +2281,2 @@
-				if ((info->type != PORT_16550A) && (!info->IsMoxaMustChipFlag)) {
+				if ((info->type != PORT_16550A) &&
+						(!info->IsMoxaMustChipFlag)) {
@@ -2212 +2291,2 @@
-				if ((info->type != PORT_16550A) && (!info->IsMoxaMustChipFlag)) {
+				if ((info->type != PORT_16550A) &&
+						(!info->IsMoxaMustChipFlag)) {
@@ -2234 +2314 @@
-		return (0);
+		return 0;
@@ -2257 +2337,2 @@
-		outb(inb(info->base + UART_MCR) | UART_MCR_DTR | UART_MCR_RTS, info->base + UART_MCR);
+		outb(inb(info->base + UART_MCR) |
+			UART_MCR_DTR | UART_MCR_RTS, info->base + UART_MCR);
@@ -2267 +2348,3 @@
-		if (!(info->flags & ASYNC_CLOSING) && (do_clocal || (inb(info->base + UART_MSR) & UART_MSR_DCD)))
+		if (!(info->flags & ASYNC_CLOSING) &&
+				(do_clocal ||
+				(inb(info->base + UART_MSR) & UART_MSR_DCD)))
@@ -2281 +2364 @@
-		return (retval);
+		return retval;
@@ -2283 +2366 @@
-	return (0);
+	return 0;
@@ -2288 +2370,0 @@
-
@@ -2294 +2376 @@
-		return (-ENOMEM);
+		return -ENOMEM;
@@ -2301 +2383 @@
-		return (0);
+		return 0;
@@ -2309 +2391 @@
-		return (0);
+		return 0;
@@ -2321 +2403,3 @@
-		outb((UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT | MOXA_MUST_FCR_GDA_MODE_ENABLE), info->base + UART_FCR);
+		outb((UART_FCR_CLEAR_RCVR |
+			UART_FCR_CLEAR_XMIT |
+			MOXA_MUST_FCR_GDA_MODE_ENABLE), info->base + UART_FCR);
@@ -2323 +2407,2 @@
-		outb((UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT), info->base + UART_FCR);
+		outb((UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT),
+			info->base + UART_FCR);
@@ -2335 +2420 @@
-			return (0);
+			return 0;
@@ -2337 +2422 @@
-			return (-ENODEV);
+			return -ENODEV;
@@ -2359 +2444 @@
-//      info->IER = UART_IER_RLSI | UART_IER_RDI;
+	/* info->IER = UART_IER_RLSI | UART_IER_RDI; */
@@ -2361 +2446 @@
-	// following add by Victor Yu. 08-30-2002
+	/* following add by Victor Yu. 08-30-2002 */
@@ -2364 +2449 @@
-	// above add by Victor Yu. 08-30-2002
+	/* above add by Victor Yu. 08-30-2002 */
@@ -2386 +2471 @@
-	return (0);
+	return 0;
@@ -2424 +2509 @@
-	// following add by Victor Yu. 08-30-2002
+	/* following add by Victor Yu. 08-30-2002 */
@@ -2426 +2511,3 @@
-		outb((UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT | MOXA_MUST_FCR_GDA_MODE_ENABLE), info->base + UART_FCR);
+		outb((UART_FCR_CLEAR_RCVR |
+			UART_FCR_CLEAR_XMIT |
+			MOXA_MUST_FCR_GDA_MODE_ENABLE), info->base + UART_FCR);
@@ -2428,2 +2515,3 @@
-		// above add by Victor Yu. 08-30-2002
-		outb((UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT), info->base + UART_FCR);
+		/* above add by Victor Yu. 08-30-2002 */
+		outb((UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT),
+			info->base + UART_FCR);
@@ -2439,2 +2527,2 @@
-	// following add by Victor Yu. 09-23-2002
-	if (info->IsMoxaMustChipFlag) {
+	/* following add by Victor Yu. 09-23-2002 */
+	if (info->IsMoxaMustChipFlag)
@@ -2442,2 +2530 @@
-	}
-	// above add by Victor Yu. 09-23-2002
+	/* above add by Victor Yu. 09-23-2002 */
@@ -2460 +2546,0 @@
-
@@ -2467 +2552,0 @@
-
@@ -2562 +2647 @@
-	if (!(cflag & PARODD)) {
+	if (!(cflag & PARODD))
@@ -2564 +2648,0 @@
-	}
@@ -2577 +2661 @@
-		// following add by Victor Yu. 08-30-2002
+		/* following add by Victor Yu. 08-30-2002 */
@@ -2582,2 +2666 @@
-			// above add by Victor Yu. 08-30-2002
-
+			/* above add by Victor Yu. 08-30-2002 */
@@ -2609,2 +2692,3 @@
-			//status = mxser_get_msr(info->base, 0, info->port);
-/*	save_flags(flags);
+			/* status = mxser_get_msr(info->base, 0, info->port); */
+/*
+	save_flags(flags);
@@ -2613,2 +2697,3 @@
-	restore_flags(flags);*/
-			//mxser_check_modem_status(info, status);
+	restore_flags(flags);
+*/
+			/* mxser_check_modem_status(info, status); */
@@ -2616,3 +2701,2 @@
-			//status = mxser_get_msr(info->base, 0, info->port);
-
-			//MX_LOCK(&info->slock);
+			/* status = mxser_get_msr(info->base, 0, info->port); */
+			/* MX_LOCK(&info->slock); */
@@ -2620 +2704 @@
-			//MX_UNLOCK(&info->slock);
+			/* MX_UNLOCK(&info->slock); */
@@ -2624 +2708,2 @@
-					if ((info->type != PORT_16550A) && (!info->IsMoxaMustChipFlag)) {
+					if ((info->type != PORT_16550A) &&
+							(!info->IsMoxaMustChipFlag)) {
@@ -2633 +2718,2 @@
-					if ((info->type != PORT_16550A) && (!info->IsMoxaMustChipFlag)) {
+					if ((info->type != PORT_16550A) &&
+							(!info->IsMoxaMustChipFlag)) {
@@ -2671,2 +2757,8 @@
-			info->ignore_status_mask |= UART_LSR_OE | UART_LSR_PE | UART_LSR_FE;
-			info->read_status_mask |= UART_LSR_OE | UART_LSR_PE | UART_LSR_FE;
+			info->ignore_status_mask |=
+						UART_LSR_OE |
+						UART_LSR_PE |
+						UART_LSR_FE;
+			info->read_status_mask |=
+						UART_LSR_OE |
+						UART_LSR_PE |
+						UART_LSR_FE;
@@ -2675 +2767 @@
-	// following add by Victor Yu. 09-02-2002
+	/* following add by Victor Yu. 09-02-2002 */
@@ -2701 +2793 @@
-	// above add by Victor Yu. 09-02-2002
+	/* above add by Victor Yu. 09-02-2002 */
@@ -2732 +2823,0 @@
-
@@ -2735 +2825,0 @@
-
@@ -2768,2 +2857,0 @@
-
-
@@ -2780 +2868 @@
-		return (-EFAULT);
+		return -EFAULT;
@@ -2794 +2882 @@
-	return (0);
+	return 0;
@@ -2804 +2892 @@
-		return (-EFAULT);
+		return -EFAULT;
@@ -2808,2 +2896,5 @@
-	if ((new_serial.irq != info->irq) || (new_serial.port != info->base) || (new_serial.custom_divisor != info->custom_divisor) || (new_serial.baud_base != info->baud_base))
-		return (-EPERM);
+	if ((new_serial.irq != info->irq) ||
+			(new_serial.port != info->base) ||
+			(new_serial.custom_divisor != info->custom_divisor) ||
+			(new_serial.baud_base != info->baud_base))
+		return -EPERM;
@@ -2814,3 +2905,6 @@
-		if ((new_serial.baud_base != info->baud_base) || (new_serial.close_delay != info->close_delay) || ((new_serial.flags & ~ASYNC_USR_MASK) != (info->flags & ~ASYNC_USR_MASK)))
-			return (-EPERM);
-		info->flags = ((info->flags & ~ASYNC_USR_MASK) | (new_serial.flags & ASYNC_USR_MASK));
+		if ((new_serial.baud_base != info->baud_base) ||
+				(new_serial.close_delay != info->close_delay) ||
+				((new_serial.flags & ~ASYNC_USR_MASK) != (info->flags & ~ASYNC_USR_MASK)))
+			return -EPERM;
+		info->flags = ((info->flags & ~ASYNC_USR_MASK) |
+				(new_serial.flags & ASYNC_USR_MASK));
@@ -2822 +2916,2 @@
-		info->flags = ((info->flags & ~ASYNC_FLAGS) | (new_serial.flags & ASYNC_FLAGS));
+		info->flags = ((info->flags & ~ASYNC_FLAGS) |
+				(new_serial.flags & ASYNC_FLAGS));
@@ -2825,2 +2920,3 @@
-		info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
-		info->tty->low_latency = 0;	//(info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+		info->tty->low_latency =
+				(info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+		info->tty->low_latency = 0;	/* (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0; */
@@ -2834 +2929,0 @@
-	/* */
@@ -2842 +2937 @@
-	return (retval);
+	return retval;
@@ -2879 +2974,2 @@
-	outb(inb(info->base + UART_LCR) | UART_LCR_SBC, info->base + UART_LCR);
+	outb(inb(info->base + UART_LCR) | UART_LCR_SBC,
+		info->base + UART_LCR);
@@ -2883 +2979,2 @@
-	outb(inb(info->base + UART_LCR) & ~UART_LCR_SBC, info->base + UART_LCR);
+	outb(inb(info->base + UART_LCR) & ~UART_LCR_SBC,
+		info->base + UART_LCR);
@@ -2889 +2986 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -2895 +2992 @@
-		return (-ENOIOCTLCMD);
+		return -ENOIOCTLCMD;
@@ -2897 +2994 @@
-		return (-EIO);
+		return -EIO;
@@ -2907 +3004,5 @@
-	    ((control & UART_MCR_DTR) ? TIOCM_DTR : 0) | ((status & UART_MSR_DCD) ? TIOCM_CAR : 0) | ((status & UART_MSR_RI) ? TIOCM_RNG : 0) | ((status & UART_MSR_DSR) ? TIOCM_DSR : 0) | ((status & UART_MSR_CTS) ? TIOCM_CTS : 0);
+		    ((control & UART_MCR_DTR) ? TIOCM_DTR : 0) |
+		    ((status & UART_MSR_DCD) ? TIOCM_CAR : 0) |
+		    ((status & UART_MSR_RI) ? TIOCM_RNG : 0) |
+		    ((status & UART_MSR_DSR) ? TIOCM_DSR : 0) |
+		    ((status & UART_MSR_CTS) ? TIOCM_CTS : 0);
@@ -2912 +3013 @@
-	struct mxser_struct *info = (struct mxser_struct *) tty->driver_data;
+	struct mxser_struct *info = tty->driver_data;
@@ -2971 +3072 @@
-		return (0);
+		return 0;
@@ -2978 +3079 @@
-			return (MXSER_ERR_IRQ_CONFLIT);
+			return MXSER_ERR_IRQ_CONFLIT;
@@ -2984 +3085 @@
-			return (MXSER_ERR_IRQ_CONFLIT);
+			return MXSER_ERR_IRQ_CONFLIT;
@@ -2990 +3091 @@
-			return (MXSER_ERR_IRQ_CONFLIT);
+			return MXSER_ERR_IRQ_CONFLIT;
@@ -2993,4 +3094,3 @@
-	if (!irq) {
-		return (MXSER_ERR_IRQ);
-	}
-	hwconf->irq = ((int) (irq & 0xF000) >> 12);
+	if (!irq)
+		return MXSER_ERR_IRQ;
+	hwconf->irq = ((int)(irq & 0xF000) >> 12);
@@ -2999,4 +3099,3 @@
-	if ((regs[12] & 0x80) == 0) {
-		return (MXSER_ERR_VECTOR);
-	}
-	hwconf->vector = (int) regs[11];	/* interrupt vector */
+	if ((regs[12] & 0x80) == 0)
+		return MXSER_ERR_VECTOR;
+	hwconf->vector = (int)regs[11];	/* interrupt vector */
@@ -3010 +3109 @@
-			hwconf->MaxCanSetBaudRate[i] = 921600;	// add by Victor Yu. 09-04-2002
+			hwconf->MaxCanSetBaudRate[i] = 921600;	/* add by Victor Yu. 09-04-2002 */
@@ -3013 +3112 @@
-			hwconf->MaxCanSetBaudRate[i] = 115200;	// add by Victor Yu. 09-04-2002
+			hwconf->MaxCanSetBaudRate[i] = 115200;	/* add by Victor Yu. 09-04-2002 */
@@ -3033 +3132 @@
-	return (hwconf->ports);
+	return hwconf->ports;
@@ -3056 +3155 @@
-		return (id);
+		return id;
@@ -3069 +3168 @@
-		(void) inb(port);
+		(void)inb(port);
@@ -3081 +3180 @@
-	return (id);
+	return id;
@@ -3087 +3186 @@
-	//unsigned long flags;
+	/* unsigned long flags; */
@@ -3093,2 +3192,2 @@
-	(void) inb(port);
-	(void) inb(port);
+	(void)inb(port);
+	(void)inb(port);
@@ -3096,2 +3195,2 @@
-	(void) inb(port);
-	//restore_flags(flags);
+	(void)inb(port);
+	/* restore_flags(flags); */
@@ -3101,2 +3200,7 @@
-	if ((id != C168_ASIC_ID) && (id != C104_ASIC_ID) && (id != C102_ASIC_ID) && (id != CI132_ASIC_ID) && (id != CI134_ASIC_ID) && (id != CI104J_ASIC_ID))
-		return (-1);
+	if ((id != C168_ASIC_ID) &&
+			(id != C104_ASIC_ID) &&
+			(id != C102_ASIC_ID) &&
+			(id != CI132_ASIC_ID) &&
+			(id != CI134_ASIC_ID) &&
+			(id != CI104J_ASIC_ID))
+		return -1;
@@ -3115 +3219 @@
-	return (id);
+	return id;
@@ -3133 +3237 @@
-			(void) inb(port);
+			(void)inb(port);
--- ./projects/linux/linux-2.6.18/drivers/char/mxser.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/mxser.c	2006-11-29 22:57:37.000000000 +0100
@@ -410 +410 @@
-static irqreturn_t mxser_interrupt(int, void *, struct pt_regs *);
+static irqreturn_t mxser_interrupt(int, void *);
@@ -456 +456 @@
-static struct tty_operations mxser_ops = {
+static const struct tty_operations mxser_ops = {
@@ -1919 +1919 @@
-static irqreturn_t mxser_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t mxser_interrupt(int irq, void *dev_id)
@@ -2557,65 +2557 @@
-		switch (cflag & (CBAUD | CBAUDEX)) {
-		case B921600:
-			baud = 921600;
-			break;
-		case B460800:
-			baud = 460800;
-			break;
-		case B230400:
-			baud = 230400;
-			break;
-		case B115200:
-			baud = 115200;
-			break;
-		case B57600:
-			baud = 57600;
-			break;
-		case B38400:
-			baud = 38400;
-			break;
-		case B19200:
-			baud = 19200;
-			break;
-		case B9600:
-			baud = 9600;
-			break;
-		case B4800:
-			baud = 4800;
-			break;
-		case B2400:
-			baud = 2400;
-			break;
-		case B1800:
-			baud = 1800;
-			break;
-		case B1200:
-			baud = 1200;
-			break;
-		case B600:
-			baud = 600;
-			break;
-		case B300:
-			baud = 300;
-			break;
-		case B200:
-			baud = 200;
-			break;
-		case B150:
-			baud = 150;
-			break;
-		case B134:
-			baud = 134;
-			break;
-		case B110:
-			baud = 110;
-			break;
-		case B75:
-			baud = 75;
-			break;
-		case B50:
-			baud = 50;
-			break;
-		default:
-			baud = 0;
-			break;
-		}
+		baud = tty_get_baud_rate(info->tty);
--- ./projects/linux/linux-2.6.19/drivers/char/mxser.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/mxser.c	2007-02-04 19:44:54.000000000 +0100
@@ -331,2 +331,2 @@
-	struct termios normal_termios;
-	struct termios callout_termios;
+	struct ktermios normal_termios;
+	struct ktermios callout_termios;
@@ -367,2 +367,2 @@
-static struct termios *mxvar_termios[MXSER_PORTS + 1];
-static struct termios *mxvar_termios_locked[MXSER_PORTS + 1];
+static struct ktermios *mxvar_termios[MXSER_PORTS + 1];
+static struct ktermios *mxvar_termios_locked[MXSER_PORTS + 1];
@@ -392 +392 @@
-static void mxser_do_softint(void *);
+static void mxser_do_softint(struct work_struct *);
@@ -405 +405 @@
-static void mxser_set_termios(struct tty_struct *, struct termios *);
+static void mxser_set_termios(struct tty_struct *, struct ktermios *);
@@ -417 +417 @@
-static int mxser_change_speed(struct mxser_struct *, struct termios *old_termios);
+static int mxser_change_speed(struct mxser_struct *, struct ktermios *old_termios);
@@ -517,0 +518 @@
+				pci_dev_put(pdev);
@@ -559 +560 @@
-		printk(KERN_DEBUG "        ttyM%d - ttyM%d ",
+		printk(KERN_DEBUG "        ttyMI%d - ttyMI%d ",
@@ -593 +594 @@
-		INIT_WORK(&info->tqueue, mxser_do_softint, info);
+		INIT_WORK(&info->tqueue, mxser_do_softint);
@@ -718,0 +720 @@
+	mxvar_sdriver->owner = THIS_MODULE;
@@ -720 +722 @@
-	mxvar_sdriver->name = "ttyM";
+	mxvar_sdriver->name = "ttyMI";
@@ -727,0 +730,2 @@
+	mxvar_sdriver->init_termios.c_ispeed = 9600;
+	mxvar_sdriver->init_termios.c_ospeed = 9600;
@@ -842 +846 @@
-		pdev = pci_find_device(mxser_pcibrds[b].vendor,
+		pdev = pci_get_device(mxser_pcibrds[b].vendor,
@@ -844 +848 @@
-			if (pdev == NULL) {
+		if (pdev == NULL) {
@@ -895,0 +900,3 @@
+			/* Keep an extra reference if we succeeded. It will
+			   be returned at unload time */
+			pci_dev_get(pdev);
@@ -920 +927 @@
-static void mxser_do_softint(void *private_)
+static void mxser_do_softint(struct work_struct *work)
@@ -922 +929,2 @@
-	struct mxser_struct *info = private_;
+	struct mxser_struct *info =
+		container_of(work, struct mxser_struct, tqueue);
@@ -996 +1004 @@
-	info->session = current->signal->session;
+	info->session = process_session(current);
@@ -1747 +1755 @@
-static void mxser_set_termios(struct tty_struct *tty, struct termios *old_termios)
+static void mxser_set_termios(struct tty_struct *tty, struct ktermios *old_termios)
@@ -2539 +2547 @@
-static int mxser_change_speed(struct mxser_struct *info, struct termios *old_termios)
+static int mxser_change_speed(struct mxser_struct *info, struct ktermios *old_termios)
--- ./projects/linux/linux-2.6.20/drivers/char/mxser.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/mxser.c	2007-04-26 05:08:32.000000000 +0200
@@ -324,2 +323,0 @@
-	long session;		/* Session of opening process */
-	long pgrp;		/* pgrp of opening process */
@@ -1004,3 +1001,0 @@
-	info->session = process_session(current);
-	info->pgrp = process_group(current);
-
@@ -1012 +1007 @@
-/* unmark here for very high baud rate (ex. 921600 bps) used */
+	/* unmark here for very high baud rate (ex. 921600 bps) used */
@@ -1257,3 +1252 @@
-	wake_up_interruptible(&tty->write_wait);
-	if ((tty->flags & (1 << TTY_DO_WRITE_WAKEUP)) && tty->ldisc.write_wakeup)
-		(tty->ldisc.write_wakeup) (tty);
+	tty_wakeup(tty);
@@ -1348,3 +1341,7 @@
-	case TIOCMIWAIT: {
-			DECLARE_WAITQUEUE(wait, current);
-			int ret;
+	case TIOCMIWAIT:
+		spin_lock_irqsave(&info->slock, flags);
+		cnow = info->icount;	/* note the counters on entry */
+		spin_unlock_irqrestore(&info->slock, flags);
+
+		wait_event_interruptible(info->delta_msr_wait, ({
+			cprev = cnow;
@@ -1352 +1349 @@
-			cprev = info->icount;	/* note the counters on entry */
+			cnow = info->icount;	/* atomic copy */
@@ -1355,30 +1352,6 @@
-			add_wait_queue(&info->delta_msr_wait, &wait);
-			while (1) {
-				spin_lock_irqsave(&info->slock, flags);
-				cnow = info->icount;	/* atomic copy */
-				spin_unlock_irqrestore(&info->slock, flags);
-
-				set_current_state(TASK_INTERRUPTIBLE);
-				if (((arg & TIOCM_RNG) &&
-						(cnow.rng != cprev.rng)) ||
-						((arg & TIOCM_DSR) &&
-						(cnow.dsr != cprev.dsr)) ||
-						((arg & TIOCM_CD) &&
-						(cnow.dcd != cprev.dcd)) ||
-						((arg & TIOCM_CTS) &&
-						(cnow.cts != cprev.cts))) {
-					ret = 0;
-					break;
-				}
-				/* see if a signal did it */
-				if (signal_pending(current)) {
-					ret = -ERESTARTSYS;
-					break;
-				}
-				cprev = cnow;
-			}
-			current->state = TASK_RUNNING;
-			remove_wait_queue(&info->delta_msr_wait, &wait);
-			break;
-		}
-		/* NOTREACHED */
+			((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
+			((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
+			((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||
+			((arg & TIOCM_CTS) && (cnow.cts != cprev.cts));
+		}));
+		break;
--- ./projects/linux/linux-2.6.21/drivers/char/mxser.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/char/mxser.c	2007-07-09 01:32:17.000000000 +0200
@@ -57 +56,0 @@
-#include <linux/smp_lock.h>
--- ./projects/linux/linux-2.6.22/drivers/char/mxser.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/mxser.c	2007-10-09 22:31:38.000000000 +0200
@@ -93,2 +92,0 @@
-#define RELEVANT_IFLAG(iflag)	(iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK|\
-					  IXON|IXOFF))
@@ -1732,2 +1730 @@
-	if ((tty->termios->c_cflag != old_termios->c_cflag) ||
-			(RELEVANT_IFLAG(tty->termios->c_iflag) != RELEVANT_IFLAG(old_termios->c_iflag))) {
+	mxser_change_speed(info, old_termios);
@@ -1735,7 +1732,4 @@
-		mxser_change_speed(info, old_termios);
-
-		if ((old_termios->c_cflag & CRTSCTS) &&
-				!(tty->termios->c_cflag & CRTSCTS)) {
-			tty->hw_stopped = 0;
-			mxser_start(tty);
-		}
+	if ((old_termios->c_cflag & CRTSCTS) &&
+			!(tty->termios->c_cflag & CRTSCTS)) {
+		tty->hw_stopped = 0;
+		mxser_start(tty);
--- ./projects/linux/linux-2.6.23/drivers/char/mxser.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/mxser.c	2008-01-24 23:58:37.000000000 +0100
@@ -58,0 +59 @@
+#include <linux/bitops.h>
@@ -63 +63,0 @@
-#include <asm/bitops.h>
@@ -386 +385,0 @@
-static int mxser_get_PCI_conf(int, int, int, struct mxser_hwconf *);
@@ -425 +424 @@
-
+#ifdef CONFIG_PCI
@@ -447,0 +447 @@
+#endif
@@ -1941,8 +1940,0 @@
-			/* above add by Victor Yu. 09-13-2002 */
-			/*
-			   if (info->tty->flip.count < TTY_FLIPBUF_SIZE / 4) {
-			   info->IER |= MOXA_MUST_RECV_ISR;
-			   outb(info->IER, info->base + UART_IER);
-			   }
-			 */
-
@@ -2602,8 +2593,0 @@
-			/* status = mxser_get_msr(info->base, 0, info->port); */
-/*
-	save_flags(flags);
-	cli();
-	status = inb(baseaddr + UART_MSR);
-	restore_flags(flags);
-*/
-			/* mxser_check_modem_status(info, status); */
@@ -2611,2 +2594,0 @@
-			/* status = mxser_get_msr(info->base, 0, info->port); */
-			/* MX_LOCK(&info->slock); */
@@ -2614 +2595,0 @@
-			/* MX_UNLOCK(&info->slock); */
--- ./projects/linux/linux-2.6.24/drivers/char/mxser.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/mxser.c	2008-04-17 04:49:44.000000000 +0200
@@ -4 +4,2 @@
- *      Copyright (C) 1999-2001  Moxa Technologies (support@moxa.com.tw).
+ *      Copyright (C) 1999-2006  Moxa Technologies (support@moxa.com).
+ *	Copyright (C) 2006-2008  Jiri Slaby <jirislaby@gmail.com>
@@ -6,2 +7,3 @@
- *      This code is loosely based on the Linux serial driver, written by
- *      Linus Torvalds, Theodore T'so and others.
+ *      This code is loosely based on the 1.8 moxa driver which is based on
+ *	Linux serial driver, written by Linus Torvalds, Theodore T'so and
+ *	others.
@@ -14,18 +15,0 @@
- *      This program is distributed in the hope that it will be useful,
- *      but WITHOUT ANY WARRANTY; without even the implied warranty of
- *      MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
- *      GNU General Public License for more details.
- *
- *      You should have received a copy of the GNU General Public License
- *      along with this program; if not, write to the Free Software
- *      Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.
- *
- *	Original release	10/26/00
- *
- *	02/06/01	Support MOXA Industio family boards.
- *	02/06/01	Support TIOCGICOUNT.
- *	02/06/01	Fix the problem for connecting to serial mouse.
- *	02/06/01	Fix the problem for H/W flow control.
- *	02/06/01	Fix the compling warning when CONFIG_PCI
- *			don't be defined.
- *
@@ -38 +21,0 @@
-
@@ -40 +22,0 @@
-#include <linux/autoconf.h>
@@ -68 +50 @@
-#define	MXSER_VERSION	"1.8"
+#define	MXSER_VERSION	"2.0.3"		/* 1.11 */
@@ -72,3 +53,0 @@
-#define	MXSER_EVENT_TXLOW	1
-#define	MXSER_EVENT_HANGUP	2
-
@@ -76 +54,0 @@
-#define MXSER_PORTS		32	/* Max. ports */
@@ -78 +56,2 @@
-#define MXSER_ISR_PASS_LIMIT	256
+#define MXSER_PORTS		(MXSER_BOARDS * MXSER_PORTS_PER_BOARD)
+#define MXSER_ISR_PASS_LIMIT	100
@@ -85,2 +64,4 @@
-#define SERIAL_TYPE_NORMAL	1
-#define SERIAL_TYPE_CALLOUT	2
+/*CheckIsMoxaMust return value*/
+#define MOXA_OTHER_UART		0x00
+#define MOXA_MUST_MU150_HWID	0x01
+#define MOXA_MUST_MU860_HWID	0x02
@@ -92,0 +74,6 @@
+#define PCI_DEVICE_ID_CB108	0x1080
+#define PCI_DEVICE_ID_CB114	0x1142
+#define PCI_DEVICE_ID_CP114UL	0x1143
+#define PCI_DEVICE_ID_CB134I	0x1341
+#define PCI_DEVICE_ID_CP138U	0x1380
+#define PCI_DEVICE_ID_POS104UL	0x1044
@@ -94 +80,0 @@
-#define IRQ_T(info) ((info->flags & ASYNC_SHARE_IRQ) ? IRQF_SHARED : IRQF_DISABLED)
@@ -103,78 +89,2 @@
-enum {
-	MXSER_BOARD_C168_ISA = 1,
-	MXSER_BOARD_C104_ISA,
-	MXSER_BOARD_CI104J,
-	MXSER_BOARD_C168_PCI,
-	MXSER_BOARD_C104_PCI,
-	MXSER_BOARD_C102_ISA,
-	MXSER_BOARD_CI132,
-	MXSER_BOARD_CI134,
-	MXSER_BOARD_CP132,
-	MXSER_BOARD_CP114,
-	MXSER_BOARD_CT114,
-	MXSER_BOARD_CP102,
-	MXSER_BOARD_CP104U,
-	MXSER_BOARD_CP168U,
-	MXSER_BOARD_CP132U,
-	MXSER_BOARD_CP134U,
-	MXSER_BOARD_CP104JU,
-	MXSER_BOARD_RC7000,
-	MXSER_BOARD_CP118U,
-	MXSER_BOARD_CP102UL,
-	MXSER_BOARD_CP102U,
-};
-
-static char *mxser_brdname[] = {
-	"C168 series",
-	"C104 series",
-	"CI-104J series",
-	"C168H/PCI series",
-	"C104H/PCI series",
-	"C102 series",
-	"CI-132 series",
-	"CI-134 series",
-	"CP-132 series",
-	"CP-114 series",
-	"CT-114 series",
-	"CP-102 series",
-	"CP-104U series",
-	"CP-168U series",
-	"CP-132U series",
-	"CP-134U series",
-	"CP-104JU series",
-	"Moxa UC7000 Serial",
-	"CP-118U series",
-	"CP-102UL series",
-	"CP-102U series",
-};
-
-static int mxser_numports[] = {
-	8,			/* C168-ISA */
-	4,			/* C104-ISA */
-	4,			/* CI104J */
-	8,			/* C168-PCI */
-	4,			/* C104-PCI */
-	2,			/* C102-ISA */
-	2,			/* CI132 */
-	4,			/* CI134 */
-	2,			/* CP132 */
-	4,			/* CP114 */
-	4,			/* CT114 */
-	2,			/* CP102 */
-	4,			/* CP104U */
-	8,			/* CP168U */
-	2,			/* CP132U */
-	4,			/* CP134U */
-	4,			/* CP104JU */
-	8,			/* RC7000 */
-	8,			/* CP118U */
-	2,			/* CP102UL */
-	2,			/* CP102U */
-};
-
-#define UART_TYPE_NUM	2
-
-static const unsigned int Gmoxa_uart_id[UART_TYPE_NUM] = {
-	MOXA_MUST_MU150_HWID,
-	MOXA_MUST_MU860_HWID
-};
+#define MXSER_HIGHBAUD	1
+#define MXSER_HAS2	2
@@ -183,2 +93 @@
-#define UART_INFO_NUM	3
-struct mxpciuart_info {
+static const struct {
@@ -193,3 +102 @@
-};
-
-static const struct mxpciuart_info Gpci_uart_info[UART_INFO_NUM] = {
+} Gpci_uart_info[] = {
@@ -199,0 +107 @@
+#define UART_INFO_NUM	ARRAY_SIZE(Gpci_uart_info)
@@ -200,0 +109,5 @@
+struct mxser_cardinfo {
+	char *name;
+	unsigned int nports;
+	unsigned int flags;
+};
@@ -202 +115,32 @@
-#ifdef CONFIG_PCI
+static const struct mxser_cardinfo mxser_cards[] = {
+/* 0*/	{ "C168 series",	8, },
+	{ "C104 series",	4, },
+	{ "CI-104J series",	4, },
+	{ "C168H/PCI series",	8, },
+	{ "C104H/PCI series",	4, },
+/* 5*/	{ "C102 series",	4, MXSER_HAS2 },	/* C102-ISA */
+	{ "CI-132 series",	4, MXSER_HAS2 },
+	{ "CI-134 series",	4, },
+	{ "CP-132 series",	2, },
+	{ "CP-114 series",	4, },
+/*10*/	{ "CT-114 series",	4, },
+	{ "CP-102 series",	2, MXSER_HIGHBAUD },
+	{ "CP-104U series",	4, },
+	{ "CP-168U series",	8, },
+	{ "CP-132U series",	2, },
+/*15*/	{ "CP-134U series",	4, },
+	{ "CP-104JU series",	4, },
+	{ "Moxa UC7000 Serial",	8, },		/* RC7000 */
+	{ "CP-118U series",	8, },
+	{ "CP-102UL series",	2, },
+/*20*/	{ "CP-102U series",	2, },
+	{ "CP-118EL series",	8, },
+	{ "CP-168EL series",	8, },
+	{ "CP-104EL series",	4, },
+	{ "CB-108 series",	8, },
+/*25*/	{ "CB-114 series",	4, },
+	{ "CB-134I series",	4, },
+	{ "CP-138U series",	8, },
+	{ "POS-104UL series",	4, },
+	{ "CP-114UL series",	4, }
+};
@@ -203,0 +148,2 @@
+/* driver_data correspond to the lines in the structure above
+   see also ISA probe function before you change something */
@@ -205,16 +151,25 @@
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_C168, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_C168_PCI},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_C104, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_C104_PCI},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CP132, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_CP132},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CP114, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_CP114},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CT114, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_CT114},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CP102, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_CP102},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CP104U, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_CP104U},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CP168U, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_CP168U},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CP132U, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_CP132U},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CP134U, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_CP134U},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CP104JU, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_CP104JU},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_RC7000, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_RC7000},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CP118U, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_CP118U},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CP102UL, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_CP102UL},
-	{PCI_VENDOR_ID_MOXA, PCI_DEVICE_ID_MOXA_CP102U, PCI_ANY_ID, PCI_ANY_ID, 0, 0, MXSER_BOARD_CP102U},
-	{0}
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_C168),	.driver_data = 3 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_C104),	.driver_data = 4 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP132),	.driver_data = 8 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP114),	.driver_data = 9 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CT114),	.driver_data = 10 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP102),	.driver_data = 11 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP104U),	.driver_data = 12 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP168U),	.driver_data = 13 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP132U),	.driver_data = 14 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP134U),	.driver_data = 15 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP104JU),.driver_data = 16 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_RC7000),	.driver_data = 17 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP118U),	.driver_data = 18 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP102UL),.driver_data = 19 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP102U),	.driver_data = 20 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP118EL),.driver_data = 21 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP168EL),.driver_data = 22 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_MOXA_CP104EL),.driver_data = 23 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_CB108),	.driver_data = 24 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_CB114),	.driver_data = 25 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_CB134I),	.driver_data = 26 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_CP138U),	.driver_data = 27 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_POS104UL),	.driver_data = 28 },
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_CP114UL),	.driver_data = 29 },
+	{ }
@@ -222 +176,0 @@
-
@@ -225,9 +178,0 @@
-
-#endif
-
-typedef struct _moxa_pci_info {
-	unsigned short busNum;
-	unsigned short devNum;
-	struct pci_dev *pdev;	/* add by Victor Yu. 06-23-2003 */
-} moxa_pci_info;
-
@@ -236,2 +180,0 @@
-static int calloutmajor = MXSERCUMAJOR;
-static int verbose = 0;
@@ -245,2 +187,0 @@
-module_param(calloutmajor, int, 0);
-module_param(verbose, bool, 0);
@@ -281,14 +222,9 @@
-struct mxser_hwconf {
-	int board_type;
-	int ports;
-	int irq;
-	int vector;
-	int vector_mask;
-	int uart_type;
-	int ioaddr[MXSER_PORTS_PER_BOARD];
-	int baud_base[MXSER_PORTS_PER_BOARD];
-	moxa_pci_info pciInfo;
-	int IsMoxaMustChipFlag;	/* add by Victor Yu. 08-30-2002 */
-	int MaxCanSetBaudRate[MXSER_PORTS_PER_BOARD];	/* add by Victor Yu. 09-04-2002 */
-	int opmode_ioaddr[MXSER_PORTS_PER_BOARD];	/* add by Victor Yu. 01-05-2004 */
-};
+struct mxser_board;
+
+struct mxser_port {
+	struct mxser_board *board;
+	struct tty_struct *tty;
+
+	unsigned long ioaddr;
+	unsigned long opmode_ioaddr;
+	int max_baud;
@@ -296,6 +231,0 @@
-struct mxser_struct {
-	int port;
-	int base;		/* port base address */
-	int irq;		/* port using irq no. */
-	int vector;		/* port irq vector */
-	int vectormask;		/* port vector mask */
@@ -306 +235,0 @@
-	int flags;		/* defined in tty.h */
@@ -308,5 +237,2 @@
-	struct tty_struct *tty;
-	int read_status_mask;
-	int ignore_status_mask;
-	int xmit_fifo_size;
-	int custom_divisor;
+	int flags;		/* defined in tty.h */
+
@@ -314,2 +239,0 @@
-	int close_delay;
-	unsigned short closing_wait;
@@ -317,0 +242,8 @@
+
+	unsigned char stop_rx;
+	unsigned char ldisc_stop_rx;
+
+	int custom_divisor;
+	int close_delay;
+	unsigned short closing_wait;
+	unsigned char err_shadow;
@@ -318,0 +251 @@
+
@@ -320,0 +254,6 @@
+	struct async_icount icount; /* kernel counters for 4 input interrupts */
+	int timeout;
+
+	int read_status_mask;
+	int ignore_status_mask;
+	int xmit_fifo_size;
@@ -325 +264 @@
-	struct work_struct tqueue;
+
@@ -327,12 +266 @@
-	struct ktermios callout_termios;
-	wait_queue_head_t open_wait;
-	wait_queue_head_t close_wait;
-	wait_queue_head_t delta_msr_wait;
-	struct async_icount icount;	/* kernel counters for the 4 input interrupts */
-	int timeout;
-	int IsMoxaMustChipFlag;	/* add by Victor Yu. 08-30-2002 */
-	int MaxCanSetBaudRate;	/* add by Victor Yu. 09-04-2002 */
-	int opmode_ioaddr;	/* add by Victor Yu. 01-05-2004 */
-	unsigned char stop_rx;
-	unsigned char ldisc_stop_rx;
-	long realbaud;
+
@@ -340 +268 @@
-	unsigned char err_shadow;
+
@@ -341,0 +270,15 @@
+	wait_queue_head_t open_wait;
+	wait_queue_head_t delta_msr_wait;
+};
+
+struct mxser_board {
+	unsigned int idx;
+	int irq;
+	const struct mxser_cardinfo *info;
+	unsigned long vector;
+	unsigned long vector_mask;
+
+	int chip_flag;
+	int uart_type;
+
+	struct mxser_port ports[MXSER_PORTS_PER_BOARD];
@@ -358,0 +302 @@
+static struct mxser_board mxser_boards[MXSER_BOARDS];
@@ -360,4 +303,0 @@
-static struct mxser_struct mxvar_table[MXSER_PORTS];
-static struct tty_struct *mxvar_tty[MXSER_PORTS + 1];
-static struct ktermios *mxvar_termios[MXSER_PORTS + 1];
-static struct ktermios *mxvar_termios_locked[MXSER_PORTS + 1];
@@ -369,54 +308,0 @@
-static spinlock_t gm_lock;
-
-/*
- * This is used to figure out the divisor speeds and the timeouts
- */
-
-static struct mxser_hwconf mxsercfg[MXSER_BOARDS];
-
-/*
- * static functions:
- */
-
-static void mxser_getcfg(int board, struct mxser_hwconf *hwconf);
-static int mxser_init(void);
-
-/* static void   mxser_poll(unsigned long); */
-static int mxser_get_ISA_conf(int, struct mxser_hwconf *);
-static void mxser_do_softint(struct work_struct *);
-static int mxser_open(struct tty_struct *, struct file *);
-static void mxser_close(struct tty_struct *, struct file *);
-static int mxser_write(struct tty_struct *, const unsigned char *, int);
-static int mxser_write_room(struct tty_struct *);
-static void mxser_flush_buffer(struct tty_struct *);
-static int mxser_chars_in_buffer(struct tty_struct *);
-static void mxser_flush_chars(struct tty_struct *);
-static void mxser_put_char(struct tty_struct *, unsigned char);
-static int mxser_ioctl(struct tty_struct *, struct file *, uint, ulong);
-static int mxser_ioctl_special(unsigned int, void __user *);
-static void mxser_throttle(struct tty_struct *);
-static void mxser_unthrottle(struct tty_struct *);
-static void mxser_set_termios(struct tty_struct *, struct ktermios *);
-static void mxser_stop(struct tty_struct *);
-static void mxser_start(struct tty_struct *);
-static void mxser_hangup(struct tty_struct *);
-static void mxser_rs_break(struct tty_struct *, int);
-static irqreturn_t mxser_interrupt(int, void *);
-static void mxser_receive_chars(struct mxser_struct *, int *);
-static void mxser_transmit_chars(struct mxser_struct *);
-static void mxser_check_modem_status(struct mxser_struct *, int);
-static int mxser_block_til_ready(struct tty_struct *, struct file *, struct mxser_struct *);
-static int mxser_startup(struct mxser_struct *);
-static void mxser_shutdown(struct mxser_struct *);
-static int mxser_change_speed(struct mxser_struct *, struct ktermios *old_termios);
-static int mxser_get_serial_info(struct mxser_struct *, struct serial_struct __user *);
-static int mxser_set_serial_info(struct mxser_struct *, struct serial_struct __user *);
-static int mxser_get_lsr_info(struct mxser_struct *, unsigned int __user *);
-static void mxser_send_break(struct mxser_struct *, int);
-static int mxser_tiocmget(struct tty_struct *, struct file *);
-static int mxser_tiocmset(struct tty_struct *, struct file *, unsigned int, unsigned int);
-static int mxser_set_baud(struct mxser_struct *info, long newspd);
-static void mxser_wait_until_sent(struct tty_struct *tty, int timeout);
-
-static void mxser_startrx(struct tty_struct *tty);
-static void mxser_stoprx(struct tty_struct *tty);
@@ -425 +311 @@
-static int CheckIsMoxaMust(int io)
+static int __devinit CheckIsMoxaMust(unsigned long io)
@@ -441,2 +327,2 @@
-	for (i = 0; i < UART_TYPE_NUM; i++) {
-		if (hwid == Gmoxa_uart_id[i])
+	for (i = 1; i < UART_INFO_NUM; i++) { /* 0 = OTHER_UART */
+		if (hwid == Gpci_uart_info[i].type)
@@ -449,76 +335 @@
-/* above is modified by Victor Yu. 08-15-2002 */
-
-static const struct tty_operations mxser_ops = {
-	.open = mxser_open,
-	.close = mxser_close,
-	.write = mxser_write,
-	.put_char = mxser_put_char,
-	.flush_chars = mxser_flush_chars,
-	.write_room = mxser_write_room,
-	.chars_in_buffer = mxser_chars_in_buffer,
-	.flush_buffer = mxser_flush_buffer,
-	.ioctl = mxser_ioctl,
-	.throttle = mxser_throttle,
-	.unthrottle = mxser_unthrottle,
-	.set_termios = mxser_set_termios,
-	.stop = mxser_stop,
-	.start = mxser_start,
-	.hangup = mxser_hangup,
-	.break_ctl = mxser_rs_break,
-	.wait_until_sent = mxser_wait_until_sent,
-	.tiocmget = mxser_tiocmget,
-	.tiocmset = mxser_tiocmset,
-};
-
-/*
- * The MOXA Smartio/Industio serial driver boot-time initialization code!
- */
-
-static int __init mxser_module_init(void)
-{
-	int ret;
-
-	if (verbose)
-		printk(KERN_DEBUG "Loading module mxser ...\n");
-	ret = mxser_init();
-	if (verbose)
-		printk(KERN_DEBUG "Done.\n");
-	return ret;
-}
-
-static void __exit mxser_module_exit(void)
-{
-	int i, err;
-
-	if (verbose)
-		printk(KERN_DEBUG "Unloading module mxser ...\n");
-
-	err = tty_unregister_driver(mxvar_sdriver);
-	if (!err)
-		put_tty_driver(mxvar_sdriver);
-	else
-		printk(KERN_ERR "Couldn't unregister MOXA Smartio/Industio family serial driver\n");
-
-	for (i = 0; i < MXSER_BOARDS; i++) {
-		struct pci_dev *pdev;
-
-		if (mxsercfg[i].board_type == -1)
-			continue;
-		else {
-			pdev = mxsercfg[i].pciInfo.pdev;
-			free_irq(mxsercfg[i].irq, &mxvar_table[i * MXSER_PORTS_PER_BOARD]);
-			if (pdev != NULL) {	/* PCI */
-				release_region(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2));
-				release_region(pci_resource_start(pdev, 3), pci_resource_len(pdev, 3));
-				pci_dev_put(pdev);
-			} else {
-				release_region(mxsercfg[i].ioaddr[0], 8 * mxsercfg[i].ports);
-				release_region(mxsercfg[i].vector, 1);
-			}
-		}
-	}
-	if (verbose)
-		printk(KERN_DEBUG "Done.\n");
-}
-
-static void process_txrx_fifo(struct mxser_struct *info)
+static void process_txrx_fifo(struct mxser_port *info)
@@ -533,3 +344,3 @@
-	} else {
-		for (i = 0; i < UART_INFO_NUM; i++) {
-			if (info->IsMoxaMustChipFlag == Gpci_uart_info[i].type) {
+	} else
+		for (i = 0; i < UART_INFO_NUM; i++)
+			if (info->board->chip_flag == Gpci_uart_info[i].type) {
@@ -542,2 +352,0 @@
-		}
-	}
@@ -546 +355 @@
-static int mxser_initbrd(int board, struct mxser_hwconf *hwconf)
+static unsigned char mxser_get_msr(int baseaddr, int mode, int port)
@@ -548,3 +357 @@
-	struct mxser_struct *info;
-	int retval;
-	int i, n;
+	unsigned char status = 0;
@@ -552,18 +359 @@
-	n = board * MXSER_PORTS_PER_BOARD;
-	info = &mxvar_table[n];
-	/*if (verbose) */  {
-		printk(KERN_DEBUG "        ttyMI%d - ttyMI%d ",
-			n, n + hwconf->ports - 1);
-		printk(" max. baud rate = %d bps.\n",
-			hwconf->MaxCanSetBaudRate[0]);
-	}
-
-	for (i = 0; i < hwconf->ports; i++, n++, info++) {
-		info->port = n;
-		info->base = hwconf->ioaddr[i];
-		info->irq = hwconf->irq;
-		info->vector = hwconf->vector;
-		info->vectormask = hwconf->vector_mask;
-		info->opmode_ioaddr = hwconf->opmode_ioaddr[i];	/* add by Victor Yu. 01-05-2004 */
-		info->stop_rx = 0;
-		info->ldisc_stop_rx = 0;
+	status = inb(baseaddr + UART_MSR);
@@ -571,5 +361,5 @@
-		info->IsMoxaMustChipFlag = hwconf->IsMoxaMustChipFlag;
-		/* Enhance mode enabled here */
-		if (info->IsMoxaMustChipFlag != MOXA_OTHER_UART) {
-			ENABLE_MOXA_MUST_ENCHANCE_MODE(info->base);
-		}
+	mxser_msr[port] &= 0x0F;
+	mxser_msr[port] |= status;
+	status = mxser_msr[port];
+	if (mode)
+		mxser_msr[port] = 0;
@@ -577,3 +367,2 @@
-		info->flags = ASYNC_SHARE_IRQ;
-		info->type = hwconf->uart_type;
-		info->baud_base = hwconf->baud_base[i];
+	return status;
+}
@@ -581 +370,7 @@
-		info->MaxCanSetBaudRate = hwconf->MaxCanSetBaudRate[i];
+static int mxser_block_til_ready(struct tty_struct *tty, struct file *filp,
+		struct mxser_port *port)
+{
+	DECLARE_WAITQUEUE(wait, current);
+	int retval;
+	int do_clocal = 0;
+	unsigned long flags;
@@ -583 +378,9 @@
-		process_txrx_fifo(info);
+	/*
+	 * If non-blocking mode is set, or the port is not enabled,
+	 * then make the check up front and then exit.
+	 */
+	if ((filp->f_flags & O_NONBLOCK) ||
+			test_bit(TTY_IO_ERROR, &tty->flags)) {
+		port->flags |= ASYNC_NORMAL_ACTIVE;
+		return 0;
+	}
@@ -584,0 +388,2 @@
+	if (tty->termios->c_cflag & CLOCAL)
+		do_clocal = 1;
@@ -586,12 +390,0 @@
-		info->custom_divisor = hwconf->baud_base[i] * 16;
-		info->close_delay = 5 * HZ / 10;
-		info->closing_wait = 30 * HZ;
-		INIT_WORK(&info->tqueue, mxser_do_softint);
-		info->normal_termios = mxvar_sdriver->init_termios;
-		init_waitqueue_head(&info->open_wait);
-		init_waitqueue_head(&info->close_wait);
-		init_waitqueue_head(&info->delta_msr_wait);
-		memset(&info->mon_data, 0, sizeof(struct mxser_mon));
-		info->err_shadow = 0;
-		spin_lock_init(&info->slock);
-	}
@@ -599 +392,5 @@
-	 * Allocate the IRQ if necessary
+	 * Block waiting for the carrier detect and the line to become
+	 * free (i.e., not in use by the callout).  While we are in
+	 * this loop, port->count is dropped by one, so that
+	 * mxser_close() knows when to free things.  We restore it upon
+	 * exit, either normal or abnormal.
@@ -600,0 +398,2 @@
+	retval = 0;
+	add_wait_queue(&port->open_wait, &wait);
@@ -602,5 +401,27 @@
-
-	/* before set INT ISR, disable all int */
-	for (i = 0; i < hwconf->ports; i++) {
-		outb(inb(hwconf->ioaddr[i] + UART_IER) & 0xf0,
-			hwconf->ioaddr[i] + UART_IER);
+	spin_lock_irqsave(&port->slock, flags);
+	if (!tty_hung_up_p(filp))
+		port->count--;
+	spin_unlock_irqrestore(&port->slock, flags);
+	port->blocked_open++;
+	while (1) {
+		spin_lock_irqsave(&port->slock, flags);
+		outb(inb(port->ioaddr + UART_MCR) |
+			UART_MCR_DTR | UART_MCR_RTS, port->ioaddr + UART_MCR);
+		spin_unlock_irqrestore(&port->slock, flags);
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)) {
+			if (port->flags & ASYNC_HUP_NOTIFY)
+				retval = -EAGAIN;
+			else
+				retval = -ERESTARTSYS;
+			break;
+		}
+		if (!(port->flags & ASYNC_CLOSING) &&
+				(do_clocal ||
+				(inb(port->ioaddr + UART_MSR) & UART_MSR_DCD)))
+			break;
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			break;
+		}
+		schedule();
@@ -608,11 +429,6 @@
-
-	n = board * MXSER_PORTS_PER_BOARD;
-	info = &mxvar_table[n];
-
-	retval = request_irq(hwconf->irq, mxser_interrupt, IRQ_T(info),
-				"mxser", info);
-	if (retval) {
-		printk(KERN_ERR "Board %d: %s",
-			board, mxser_brdname[hwconf->board_type - 1]);
-		printk("  Request irq failed, IRQ (%d) may conflict with"
-			" another device.\n", info->irq);
+	set_current_state(TASK_RUNNING);
+	remove_wait_queue(&port->open_wait, &wait);
+	if (!tty_hung_up_p(filp))
+		port->count++;
+	port->blocked_open--;
+	if (retval)
@@ -620 +436 @@
-	}
+	port->flags |= ASYNC_NORMAL_ACTIVE;
@@ -624 +440 @@
-static void mxser_getcfg(int board, struct mxser_hwconf *hwconf)
+static int mxser_set_baud(struct mxser_port *info, long newspd)
@@ -626,2 +442,2 @@
-	mxsercfg[board] = *hwconf;
-}
+	int quot = 0, baud;
+	unsigned char cval;
@@ -629,7 +445,2 @@
-#ifdef CONFIG_PCI
-static int mxser_get_PCI_conf(int busnum, int devnum, int board_type, struct mxser_hwconf *hwconf)
-{
-	int i, j;
-	/* unsigned int val; */
-	unsigned int ioaddress;
-	struct pci_dev *pdev = hwconf->pciInfo.pdev;
+	if (!info->tty || !info->tty->termios)
+		return -1;
@@ -637,6 +448,2 @@
-	/* io address */
-	hwconf->board_type = board_type;
-	hwconf->ports = mxser_numports[board_type - 1];
-	ioaddress = pci_resource_start(pdev, 2);
-	request_region(pci_resource_start(pdev, 2), pci_resource_len(pdev, 2),
-			"mxser(IO)");
+	if (!(info->ioaddr))
+		return -1;
@@ -644,2 +451,2 @@
-	for (i = 0; i < hwconf->ports; i++)
-		hwconf->ioaddr[i] = ioaddress + 8 * i;
+	if (newspd > info->max_baud)
+		return -1;
@@ -647,5 +454,12 @@
-	/* vector */
-	ioaddress = pci_resource_start(pdev, 3);
-	request_region(pci_resource_start(pdev, 3), pci_resource_len(pdev, 3),
-			"mxser(vector)");
-	hwconf->vector = ioaddress;
+	if (newspd == 134) {
+		quot = 2 * info->baud_base / 269;
+		tty_encode_baud_rate(info->tty, 134, 134);
+	} else if (newspd) {
+		quot = info->baud_base / newspd;
+		if (quot == 0)
+			quot = 1;
+		baud = info->baud_base/quot;
+		tty_encode_baud_rate(info->tty, baud, baud);
+	} else {
+		quot = 0;
+	}
@@ -653,2 +467,2 @@
-	/* irq */
-	hwconf->irq = hwconf->pciInfo.pdev->irq;
+	info->timeout = ((info->xmit_fifo_size * HZ * 10 * quot) / info->baud_base);
+	info->timeout += HZ / 50;	/* Add .02 seconds of slop */
@@ -656,3 +470,8 @@
-	hwconf->IsMoxaMustChipFlag = CheckIsMoxaMust(hwconf->ioaddr[0]);
-	hwconf->uart_type = PORT_16550A;
-	hwconf->vector_mask = 0;
+	if (quot) {
+		info->MCR |= UART_MCR_DTR;
+		outb(info->MCR, info->ioaddr + UART_MCR);
+	} else {
+		info->MCR &= ~UART_MCR_DTR;
+		outb(info->MCR, info->ioaddr + UART_MCR);
+		return 0;
+	}
@@ -659,0 +479 @@
+	cval = inb(info->ioaddr + UART_LCR);
@@ -661,4 +481 @@
-	for (i = 0; i < hwconf->ports; i++) {
-		for (j = 0; j < UART_INFO_NUM; j++) {
-			if (Gpci_uart_info[j].type == hwconf->IsMoxaMustChipFlag) {
-				hwconf->MaxCanSetBaudRate[i] = Gpci_uart_info[j].max_baud;
+	outb(cval | UART_LCR_DLAB, info->ioaddr + UART_LCR);	/* set DLAB */
@@ -666,7 +483,13 @@
-				/* exception....CP-102 */
-				if (board_type == MXSER_BOARD_CP102)
-					hwconf->MaxCanSetBaudRate[i] = 921600;
-				break;
-			}
-		}
-	}
+	outb(quot & 0xff, info->ioaddr + UART_DLL);	/* LS of divisor */
+	outb(quot >> 8, info->ioaddr + UART_DLM);	/* MS of divisor */
+	outb(cval, info->ioaddr + UART_LCR);	/* reset DLAB */
+
+#ifdef BOTHER
+	if (C_BAUD(info->tty) == BOTHER) {
+		quot = info->baud_base % newspd;
+		quot *= 8;
+		if (quot % newspd > newspd / 2) {
+			quot /= newspd;
+			quot++;
+		} else
+			quot /= newspd;
@@ -674,10 +497,4 @@
-	if (hwconf->IsMoxaMustChipFlag == MOXA_MUST_MU860_HWID) {
-		for (i = 0; i < hwconf->ports; i++) {
-			if (i < 4)
-				hwconf->opmode_ioaddr[i] = ioaddress + 4;
-			else
-				hwconf->opmode_ioaddr[i] = ioaddress + 0x0c;
-		}
-		outb(0, ioaddress + 4);	/* default set to RS232 mode */
-		outb(0, ioaddress + 0x0c);	/* default set to RS232 mode */
-	}
+		SET_MOXA_MUST_ENUM_VALUE(info->ioaddr, quot);
+	} else
+#endif
+		SET_MOXA_MUST_ENUM_VALUE(info->ioaddr, 0);
@@ -685,4 +501,0 @@
-	for (i = 0; i < hwconf->ports; i++) {
-		hwconf->vector_mask |= (1 << i);
-		hwconf->baud_base[i] = 921600;
-	}
@@ -691 +503,0 @@
-#endif
@@ -693 +505,6 @@
-static int mxser_init(void)
+/*
+ * This routine is called to set the UART divisor registers to match
+ * the specified baud rate for a serial port.
+ */
+static int mxser_change_speed(struct mxser_port *info,
+		struct ktermios *old_termios)
@@ -695,5 +512,3 @@
-	int i, m, retval, b, n;
-	struct pci_dev *pdev = NULL;
-	int index;
-	unsigned char busnum, devnum;
-	struct mxser_hwconf hwconf;
+	unsigned cflag, cval, fcr;
+	int ret = 0;
+	unsigned char status;
@@ -701,75 +516,5 @@
-	mxvar_sdriver = alloc_tty_driver(MXSER_PORTS + 1);
-	if (!mxvar_sdriver)
-		return -ENOMEM;
-	spin_lock_init(&gm_lock);
-
-	for (i = 0; i < MXSER_BOARDS; i++) {
-		mxsercfg[i].board_type = -1;
-	}
-
-	printk(KERN_INFO "MOXA Smartio/Industio family driver version %s\n",
-		MXSER_VERSION);
-
-	/* Initialize the tty_driver structure */
-	memset(mxvar_sdriver, 0, sizeof(struct tty_driver));
-	mxvar_sdriver->owner = THIS_MODULE;
-	mxvar_sdriver->magic = TTY_DRIVER_MAGIC;
-	mxvar_sdriver->name = "ttyMI";
-	mxvar_sdriver->major = ttymajor;
-	mxvar_sdriver->minor_start = 0;
-	mxvar_sdriver->num = MXSER_PORTS + 1;
-	mxvar_sdriver->type = TTY_DRIVER_TYPE_SERIAL;
-	mxvar_sdriver->subtype = SERIAL_TYPE_NORMAL;
-	mxvar_sdriver->init_termios = tty_std_termios;
-	mxvar_sdriver->init_termios.c_cflag = B9600|CS8|CREAD|HUPCL|CLOCAL;
-	mxvar_sdriver->init_termios.c_ispeed = 9600;
-	mxvar_sdriver->init_termios.c_ospeed = 9600;
-	mxvar_sdriver->flags = TTY_DRIVER_REAL_RAW;
-	tty_set_operations(mxvar_sdriver, &mxser_ops);
-	mxvar_sdriver->ttys = mxvar_tty;
-	mxvar_sdriver->termios = mxvar_termios;
-	mxvar_sdriver->termios_locked = mxvar_termios_locked;
-
-	mxvar_diagflag = 0;
-	memset(mxvar_table, 0, MXSER_PORTS * sizeof(struct mxser_struct));
-	memset(&mxvar_log, 0, sizeof(struct mxser_log));
-
-	memset(&mxser_msr, 0, sizeof(unsigned char) * (MXSER_PORTS + 1));
-	memset(&mon_data_ext, 0, sizeof(struct mxser_mon_ext));
-	memset(&mxser_set_baud_method, 0, sizeof(int) * (MXSER_PORTS + 1));
-	memset(&hwconf, 0, sizeof(struct mxser_hwconf));
-
-	m = 0;
-	/* Start finding ISA boards here */
-	for (b = 0; b < MXSER_BOARDS && m < MXSER_BOARDS; b++) {
-		int cap;
-
-		if (!(cap = mxserBoardCAP[b]))
-			continue;
-
-		retval = mxser_get_ISA_conf(cap, &hwconf);
-
-		if (retval != 0)
-			printk(KERN_INFO "Found MOXA %s board (CAP=0x%x)\n",
-				mxser_brdname[hwconf.board_type - 1], ioaddr[b]);
-
-		if (retval <= 0) {
-			if (retval == MXSER_ERR_IRQ)
-				printk(KERN_ERR "Invalid interrupt number, "
-					"board not configured\n");
-			else if (retval == MXSER_ERR_IRQ_CONFLIT)
-				printk(KERN_ERR "Invalid interrupt number, "
-					"board not configured\n");
-			else if (retval == MXSER_ERR_VECTOR)
-				printk(KERN_ERR "Invalid interrupt vector, "
-					"board not configured\n");
-			else if (retval == MXSER_ERR_IOADDR)
-				printk(KERN_ERR "Invalid I/O address, "
-					"board not configured\n");
-
-			continue;
-		}
-
-		hwconf.pciInfo.busNum = 0;
-		hwconf.pciInfo.devNum = 0;
-		hwconf.pciInfo.pdev = NULL;
+	if (!info->tty || !info->tty->termios)
+		return ret;
+	cflag = info->tty->termios->c_cflag;
+	if (!(info->ioaddr))
+		return ret;
@@ -777,8 +522,2 @@
-		mxser_getcfg(m, &hwconf);
-		/*
-		 * init mxsercfg first,
-		 * or mxsercfg data is not correct on ISR.
-		 */
-		/* mxser_initbrd will hook ISR. */
-		if (mxser_initbrd(m, &hwconf) < 0)
-			continue;
+	if (mxser_set_baud_method[info->tty->index] == 0)
+		mxser_set_baud(info, tty_get_baud_rate(info->tty));
@@ -786 +525,17 @@
-		m++;
+	/* byte size and parity */
+	switch (cflag & CSIZE) {
+	case CS5:
+		cval = 0x00;
+		break;
+	case CS6:
+		cval = 0x01;
+		break;
+	case CS7:
+		cval = 0x02;
+		break;
+	case CS8:
+		cval = 0x03;
+		break;
+	default:
+		cval = 0x00;
+		break;		/* too keep GCC shut... */
@@ -787,0 +543,8 @@
+	if (cflag & CSTOPB)
+		cval |= 0x04;
+	if (cflag & PARENB)
+		cval |= UART_LCR_PARITY;
+	if (!(cflag & PARODD))
+		cval |= UART_LCR_EPAR;
+	if (cflag & CMSPAR)
+		cval |= UART_LCR_SPAR;
@@ -789,26 +552,29 @@
-	/* Start finding ISA boards from module arg */
-	for (b = 0; b < MXSER_BOARDS && m < MXSER_BOARDS; b++) {
-		int cap;
-
-		if (!(cap = ioaddr[b]))
-			continue;
-
-		retval = mxser_get_ISA_conf(cap, &hwconf);
-
-		if (retval != 0)
-			printk(KERN_INFO "Found MOXA %s board (CAP=0x%x)\n",
-				mxser_brdname[hwconf.board_type - 1], ioaddr[b]);
-
-		if (retval <= 0) {
-			if (retval == MXSER_ERR_IRQ)
-				printk(KERN_ERR "Invalid interrupt number, "
-					"board not configured\n");
-			else if (retval == MXSER_ERR_IRQ_CONFLIT)
-				printk(KERN_ERR "Invalid interrupt number, "
-					"board not configured\n");
-			else if (retval == MXSER_ERR_VECTOR)
-				printk(KERN_ERR "Invalid interrupt vector, "
-					"board not configured\n");
-			else if (retval == MXSER_ERR_IOADDR)
-				printk(KERN_ERR "Invalid I/O address, "
-					"board not configured\n");
+	if ((info->type == PORT_8250) || (info->type == PORT_16450)) {
+		if (info->board->chip_flag) {
+			fcr = UART_FCR_ENABLE_FIFO;
+			fcr |= MOXA_MUST_FCR_GDA_MODE_ENABLE;
+			SET_MOXA_MUST_FIFO_VALUE(info);
+		} else
+			fcr = 0;
+	} else {
+		fcr = UART_FCR_ENABLE_FIFO;
+		if (info->board->chip_flag) {
+			fcr |= MOXA_MUST_FCR_GDA_MODE_ENABLE;
+			SET_MOXA_MUST_FIFO_VALUE(info);
+		} else {
+			switch (info->rx_trigger) {
+			case 1:
+				fcr |= UART_FCR_TRIGGER_1;
+				break;
+			case 4:
+				fcr |= UART_FCR_TRIGGER_4;
+				break;
+			case 8:
+				fcr |= UART_FCR_TRIGGER_8;
+				break;
+			default:
+				fcr |= UART_FCR_TRIGGER_14;
+				break;
+			}
+		}
+	}
@@ -816 +582,35 @@
-			continue;
+	/* CTS flow control flag and modem status interrupts */
+	info->IER &= ~UART_IER_MSI;
+	info->MCR &= ~UART_MCR_AFE;
+	if (cflag & CRTSCTS) {
+		info->flags |= ASYNC_CTS_FLOW;
+		info->IER |= UART_IER_MSI;
+		if ((info->type == PORT_16550A) || (info->board->chip_flag)) {
+			info->MCR |= UART_MCR_AFE;
+		} else {
+			status = inb(info->ioaddr + UART_MSR);
+			if (info->tty->hw_stopped) {
+				if (status & UART_MSR_CTS) {
+					info->tty->hw_stopped = 0;
+					if (info->type != PORT_16550A &&
+							!info->board->chip_flag) {
+						outb(info->IER & ~UART_IER_THRI,
+							info->ioaddr +
+							UART_IER);
+						info->IER |= UART_IER_THRI;
+						outb(info->IER, info->ioaddr +
+								UART_IER);
+					}
+					tty_wakeup(info->tty);
+				}
+			} else {
+				if (!(status & UART_MSR_CTS)) {
+					info->tty->hw_stopped = 1;
+					if ((info->type != PORT_16550A) &&
+							(!info->board->chip_flag)) {
+						info->IER &= ~UART_IER_THRI;
+						outb(info->IER, info->ioaddr +
+								UART_IER);
+					}
+				}
+			}
@@ -817,0 +618,20 @@
+	} else {
+		info->flags &= ~ASYNC_CTS_FLOW;
+	}
+	outb(info->MCR, info->ioaddr + UART_MCR);
+	if (cflag & CLOCAL) {
+		info->flags &= ~ASYNC_CHECK_CD;
+	} else {
+		info->flags |= ASYNC_CHECK_CD;
+		info->IER |= UART_IER_MSI;
+	}
+	outb(info->IER, info->ioaddr + UART_IER);
+
+	/*
+	 * Set up parity check flag
+	 */
+	info->read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;
+	if (I_INPCK(info->tty))
+		info->read_status_mask |= UART_LSR_FE | UART_LSR_PE;
+	if (I_BRKINT(info->tty) || I_PARMRK(info->tty))
+		info->read_status_mask |= UART_LSR_BI;
@@ -819,3 +639 @@
-		hwconf.pciInfo.busNum = 0;
-		hwconf.pciInfo.devNum = 0;
-		hwconf.pciInfo.pdev = NULL;
+	info->ignore_status_mask = 0;
@@ -823 +641,3 @@
-		mxser_getcfg(m, &hwconf);
+	if (I_IGNBRK(info->tty)) {
+		info->ignore_status_mask |= UART_LSR_BI;
+		info->read_status_mask |= UART_LSR_BI;
@@ -825,2 +645,2 @@
-		 * init mxsercfg first,
-		 * or mxsercfg data is not correct on ISR.
+		 * If we're ignore parity and break indicators, ignore
+		 * overruns too.  (For real raw support).
@@ -828,5 +648,10 @@
-		/* mxser_initbrd will hook ISR. */
-		if (mxser_initbrd(m, &hwconf) < 0)
-			continue;
-
-		m++;
+		if (I_IGNPAR(info->tty)) {
+			info->ignore_status_mask |=
+						UART_LSR_OE |
+						UART_LSR_PE |
+						UART_LSR_FE;
+			info->read_status_mask |=
+						UART_LSR_OE |
+						UART_LSR_PE |
+						UART_LSR_FE;
+		}
@@ -834,64 +659,12 @@
-
-	/* start finding PCI board here */
-#ifdef CONFIG_PCI
-	n = ARRAY_SIZE(mxser_pcibrds) - 1;
-	index = 0;
-	b = 0;
-	while (b < n) {
-		pdev = pci_get_device(mxser_pcibrds[b].vendor,
-				mxser_pcibrds[b].device, pdev);
-		if (pdev == NULL) {
-			b++;
-			continue;
-		}
-		hwconf.pciInfo.busNum = busnum = pdev->bus->number;
-		hwconf.pciInfo.devNum = devnum = PCI_SLOT(pdev->devfn) << 3;
-		hwconf.pciInfo.pdev = pdev;
-		printk(KERN_INFO "Found MOXA %s board(BusNo=%d,DevNo=%d)\n",
-			mxser_brdname[(int) (mxser_pcibrds[b].driver_data) - 1],
-			busnum, devnum >> 3);
-		index++;
-		if (m >= MXSER_BOARDS)
-			printk(KERN_ERR
-				"Too many Smartio/Industio family boards find "
-				"(maximum %d), board not configured\n",
-				MXSER_BOARDS);
-		else {
-			if (pci_enable_device(pdev)) {
-				printk(KERN_ERR "Moxa SmartI/O PCI enable "
-					"fail !\n");
-				continue;
-			}
-			retval = mxser_get_PCI_conf(busnum, devnum,
-					(int)mxser_pcibrds[b].driver_data,
-					&hwconf);
-			if (retval < 0) {
-				if (retval == MXSER_ERR_IRQ)
-					printk(KERN_ERR
-						"Invalid interrupt number, "
-						"board not configured\n");
-				else if (retval == MXSER_ERR_IRQ_CONFLIT)
-					printk(KERN_ERR
-						"Invalid interrupt number, "
-						"board not configured\n");
-				else if (retval == MXSER_ERR_VECTOR)
-					printk(KERN_ERR
-						"Invalid interrupt vector, "
-						"board not configured\n");
-				else if (retval == MXSER_ERR_IOADDR)
-					printk(KERN_ERR
-						"Invalid I/O address, "
-						"board not configured\n");
-				continue;
-			}
-			mxser_getcfg(m, &hwconf);
-			/* init mxsercfg first,
-			 * or mxsercfg data is not correct on ISR.
-			 */
-			/* mxser_initbrd will hook ISR. */
-			if (mxser_initbrd(m, &hwconf) < 0)
-				continue;
-			m++;
-			/* Keep an extra reference if we succeeded. It will
-			   be returned at unload time */
-			pci_dev_get(pdev);
+	if (info->board->chip_flag) {
+		SET_MOXA_MUST_XON1_VALUE(info->ioaddr, START_CHAR(info->tty));
+		SET_MOXA_MUST_XOFF1_VALUE(info->ioaddr, STOP_CHAR(info->tty));
+		if (I_IXON(info->tty)) {
+			ENABLE_MOXA_MUST_RX_SOFTWARE_FLOW_CONTROL(info->ioaddr);
+		} else {
+			DISABLE_MOXA_MUST_RX_SOFTWARE_FLOW_CONTROL(info->ioaddr);
+		}
+		if (I_IXOFF(info->tty)) {
+			ENABLE_MOXA_MUST_TX_SOFTWARE_FLOW_CONTROL(info->ioaddr);
+		} else {
+			DISABLE_MOXA_MUST_TX_SOFTWARE_FLOW_CONTROL(info->ioaddr);
@@ -900 +672,0 @@
-#endif
@@ -902,5 +673,0 @@
-	retval = tty_register_driver(mxvar_sdriver);
-	if (retval) {
-		printk(KERN_ERR "Couldn't install MOXA Smartio/Industio family"
-				" driver !\n");
-		put_tty_driver(mxvar_sdriver);
@@ -908,10 +675,2 @@
-		for (i = 0; i < MXSER_BOARDS; i++) {
-			if (mxsercfg[i].board_type == -1)
-				continue;
-			else {
-				free_irq(mxsercfg[i].irq, &mxvar_table[i * MXSER_PORTS_PER_BOARD]);
-				/* todo: release io, vector */
-			}
-		}
-		return retval;
-	}
+	outb(fcr, info->ioaddr + UART_FCR);	/* set fcr */
+	outb(cval, info->ioaddr + UART_LCR);
@@ -919 +678 @@
-	return 0;
+	return ret;
@@ -922 +681 @@
-static void mxser_do_softint(struct work_struct *work)
+static void mxser_check_modem_status(struct mxser_port *port, int status)
@@ -924,3 +683,16 @@
-	struct mxser_struct *info =
-		container_of(work, struct mxser_struct, tqueue);
-	struct tty_struct *tty;
+	/* update input line counters */
+	if (status & UART_MSR_TERI)
+		port->icount.rng++;
+	if (status & UART_MSR_DDSR)
+		port->icount.dsr++;
+	if (status & UART_MSR_DDCD)
+		port->icount.dcd++;
+	if (status & UART_MSR_DCTS)
+		port->icount.cts++;
+	port->mon_data.modem_status = status;
+	wake_up_interruptible(&port->delta_msr_wait);
+
+	if ((port->flags & ASYNC_CHECK_CD) && (status & UART_MSR_DDCD)) {
+		if (status & UART_MSR_DCD)
+			wake_up_interruptible(&port->open_wait);
+	}
@@ -928 +700,4 @@
-	tty = info->tty;
+	if (port->flags & ASYNC_CTS_FLOW) {
+		if (port->tty->hw_stopped) {
+			if (status & UART_MSR_CTS) {
+				port->tty->hw_stopped = 0;
@@ -930,5 +705,21 @@
-	if (tty) {
-		if (test_and_clear_bit(MXSER_EVENT_TXLOW, &info->event))
-			tty_wakeup(tty);
-		if (test_and_clear_bit(MXSER_EVENT_HANGUP, &info->event))
-			tty_hangup(tty);
+				if ((port->type != PORT_16550A) &&
+						(!port->board->chip_flag)) {
+					outb(port->IER & ~UART_IER_THRI,
+						port->ioaddr + UART_IER);
+					port->IER |= UART_IER_THRI;
+					outb(port->IER, port->ioaddr +
+							UART_IER);
+				}
+				tty_wakeup(port->tty);
+			}
+		} else {
+			if (!(status & UART_MSR_CTS)) {
+				port->tty->hw_stopped = 1;
+				if (port->type != PORT_16550A &&
+						!port->board->chip_flag) {
+					port->IER &= ~UART_IER_THRI;
+					outb(port->IER, port->ioaddr +
+							UART_IER);
+				}
+			}
+		}
@@ -938 +729 @@
-static unsigned char mxser_get_msr(int baseaddr, int mode, int port, struct mxser_struct *info)
+static int mxser_startup(struct mxser_port *info)
@@ -940,9 +731,2 @@
-	unsigned char status = 0;
-
-	status = inb(baseaddr + UART_MSR);
-
-	mxser_msr[port] &= 0x0F;
-	mxser_msr[port] |= status;
-	status = mxser_msr[port];
-	if (mode)
-		mxser_msr[port] = 0;
+	unsigned long page;
+	unsigned long flags;
@@ -950,2 +734,3 @@
-	return status;
-}
+	page = __get_free_page(GFP_KERNEL);
+	if (!page)
+		return -ENOMEM;
@@ -953,10 +738 @@
-/*
- * This routine is called whenever a serial port is opened.  It
- * enables interrupts for a serial port, linking in its async structure into
- * the IRQ chain.   It also performs the serial-specific
- * initialization for the tty structure.
- */
-static int mxser_open(struct tty_struct *tty, struct file *filp)
-{
-	struct mxser_struct *info;
-	int retval, line;
+	spin_lock_irqsave(&info->slock, flags);
@@ -964,2 +740,5 @@
-	/* initialize driver_data in case something fails */
-	tty->driver_data = NULL;
+	if (info->flags & ASYNC_INITIALIZED) {
+		free_page(page);
+		spin_unlock_irqrestore(&info->slock, flags);
+		return 0;
+	}
@@ -967,2 +746,5 @@
-	line = tty->index;
-	if (line == MXSER_PORTS)
+	if (!info->ioaddr || !info->type) {
+		if (info->tty)
+			set_bit(TTY_IO_ERROR, &info->tty->flags);
+		free_page(page);
+		spin_unlock_irqrestore(&info->slock, flags);
@@ -970,5 +752,5 @@
-	if (line < 0 || line > MXSER_PORTS)
-		return -ENODEV;
-	info = mxvar_table + line;
-	if (!info->base)
-		return -ENODEV;
+	}
+	if (info->xmit_buf)
+		free_page(page);
+	else
+		info->xmit_buf = (unsigned char *) page;
@@ -976,2 +757,0 @@
-	tty->driver_data = info;
-	info->tty = tty;
@@ -979 +759,2 @@
-	 * Start up serial port
+	 * Clear the FIFO buffers and disable them
+	 * (they will be reenabled in mxser_change_speed())
@@ -981,3 +762,7 @@
-	retval = mxser_startup(info);
-	if (retval)
-		return retval;
+	if (info->board->chip_flag)
+		outb((UART_FCR_CLEAR_RCVR |
+			UART_FCR_CLEAR_XMIT |
+			MOXA_MUST_FCR_GDA_MODE_ENABLE), info->ioaddr + UART_FCR);
+	else
+		outb((UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT),
+			info->ioaddr + UART_FCR);
@@ -985,3 +770,14 @@
-	retval = mxser_block_til_ready(tty, filp, info);
-	if (retval)
-		return retval;
+	/*
+	 * At this point there's no way the LSR could still be 0xFF;
+	 * if it is, then bail out, because there's likely no UART
+	 * here.
+	 */
+	if (inb(info->ioaddr + UART_LSR) == 0xff) {
+		spin_unlock_irqrestore(&info->slock, flags);
+		if (capable(CAP_SYS_ADMIN)) {
+			if (info->tty)
+				set_bit(TTY_IO_ERROR, &info->tty->flags);
+			return 0;
+		} else
+			return -ENODEV;
+	}
@@ -989 +785,7 @@
-	info->count++;
+	/*
+	 * Clear the interrupt registers.
+	 */
+	(void) inb(info->ioaddr + UART_LSR);
+	(void) inb(info->ioaddr + UART_RX);
+	(void) inb(info->ioaddr + UART_IIR);
+	(void) inb(info->ioaddr + UART_MSR);
@@ -991,6 +793,63 @@
-	if ((info->count == 1) && (info->flags & ASYNC_SPLIT_TERMIOS)) {
-		if (tty->driver->subtype == SERIAL_TYPE_NORMAL)
-			*tty->termios = info->normal_termios;
-		else
-			*tty->termios = info->callout_termios;
-		mxser_change_speed(info, NULL);
+	/*
+	 * Now, initialize the UART
+	 */
+	outb(UART_LCR_WLEN8, info->ioaddr + UART_LCR);	/* reset DLAB */
+	info->MCR = UART_MCR_DTR | UART_MCR_RTS;
+	outb(info->MCR, info->ioaddr + UART_MCR);
+
+	/*
+	 * Finally, enable interrupts
+	 */
+	info->IER = UART_IER_MSI | UART_IER_RLSI | UART_IER_RDI;
+
+	if (info->board->chip_flag)
+		info->IER |= MOXA_MUST_IER_EGDAI;
+	outb(info->IER, info->ioaddr + UART_IER);	/* enable interrupts */
+
+	/*
+	 * And clear the interrupt registers again for luck.
+	 */
+	(void) inb(info->ioaddr + UART_LSR);
+	(void) inb(info->ioaddr + UART_RX);
+	(void) inb(info->ioaddr + UART_IIR);
+	(void) inb(info->ioaddr + UART_MSR);
+
+	if (info->tty)
+		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
+
+	/*
+	 * and set the speed of the serial port
+	 */
+	mxser_change_speed(info, NULL);
+	info->flags |= ASYNC_INITIALIZED;
+	spin_unlock_irqrestore(&info->slock, flags);
+
+	return 0;
+}
+
+/*
+ * This routine will shutdown a serial port; interrupts maybe disabled, and
+ * DTR is dropped if the hangup on close termio flag is on.
+ */
+static void mxser_shutdown(struct mxser_port *info)
+{
+	unsigned long flags;
+
+	if (!(info->flags & ASYNC_INITIALIZED))
+		return;
+
+	spin_lock_irqsave(&info->slock, flags);
+
+	/*
+	 * clear delta_msr_wait queue to avoid mem leaks: we may free the irq
+	 * here so the queue might never be waken up
+	 */
+	wake_up_interruptible(&info->delta_msr_wait);
+
+	/*
+	 * Free the IRQ, if necessary
+	 */
+	if (info->xmit_buf) {
+		free_page((unsigned long) info->xmit_buf);
+		info->xmit_buf = NULL;
@@ -998,0 +858,53 @@
+	info->IER = 0;
+	outb(0x00, info->ioaddr + UART_IER);
+
+	if (!info->tty || (info->tty->termios->c_cflag & HUPCL))
+		info->MCR &= ~(UART_MCR_DTR | UART_MCR_RTS);
+	outb(info->MCR, info->ioaddr + UART_MCR);
+
+	/* clear Rx/Tx FIFO's */
+	if (info->board->chip_flag)
+		outb(UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT |
+				MOXA_MUST_FCR_GDA_MODE_ENABLE,
+				info->ioaddr + UART_FCR);
+	else
+		outb(UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT,
+			info->ioaddr + UART_FCR);
+
+	/* read data port to reset things */
+	(void) inb(info->ioaddr + UART_RX);
+
+	if (info->tty)
+		set_bit(TTY_IO_ERROR, &info->tty->flags);
+
+	info->flags &= ~ASYNC_INITIALIZED;
+
+	if (info->board->chip_flag)
+		SET_MOXA_MUST_NO_SOFTWARE_FLOW_CONTROL(info->ioaddr);
+
+	spin_unlock_irqrestore(&info->slock, flags);
+}
+
+/*
+ * This routine is called whenever a serial port is opened.  It
+ * enables interrupts for a serial port, linking in its async structure into
+ * the IRQ chain.   It also performs the serial-specific
+ * initialization for the tty structure.
+ */
+static int mxser_open(struct tty_struct *tty, struct file *filp)
+{
+	struct mxser_port *info;
+	unsigned long flags;
+	int retval, line;
+
+	line = tty->index;
+	if (line == MXSER_PORTS)
+		return 0;
+	if (line < 0 || line > MXSER_PORTS)
+		return -ENODEV;
+	info = &mxser_boards[line / MXSER_PORTS_PER_BOARD].ports[line % MXSER_PORTS_PER_BOARD];
+	if (!info->ioaddr)
+		return -ENODEV;
+
+	tty->driver_data = info;
+	info->tty = tty;
@@ -1000,3 +912,12 @@
-	status = mxser_get_msr(info->base, 0, info->port);
-	mxser_check_modem_status(info, status);
-	*/
+	 * Start up serial port
+	 */
+	spin_lock_irqsave(&info->slock, flags);
+	info->count++;
+	spin_unlock_irqrestore(&info->slock, flags);
+	retval = mxser_startup(info);
+	if (retval)
+		return retval;
+
+	retval = mxser_block_til_ready(tty, filp, info);
+	if (retval)
+		return retval;
@@ -1017 +938 @@
-	struct mxser_struct *info = tty->driver_data;
+	struct mxser_port *info = tty->driver_data;
@@ -1021 +941,0 @@
-	struct tty_ldisc *ld;
@@ -1048 +968 @@
-			"ttys%d: %d\n", info->port, info->count);
+			"ttys%d: %d\n", tty->index, info->count);
@@ -1077 +997 @@
-	if (info->IsMoxaMustChipFlag)
+	if (info->board->chip_flag)
@@ -1079,3 +999 @@
-/* by William
-	info->read_status_mask &= ~UART_LSR_DR;
-*/
+
@@ -1083 +1001 @@
-		outb(info->IER, info->base + UART_IER);
+		outb(info->IER, info->ioaddr + UART_IER);
@@ -1090 +1008 @@
-		while (!(inb(info->base + UART_LSR) & UART_LSR_TEMT)) {
+		while (!(inb(info->ioaddr + UART_LSR) & UART_LSR_TEMT)) {
@@ -1100,8 +1018,3 @@
-		
-	ld = tty_ldisc_ref(tty);
-	if (ld) {
-		if (ld->flush_buffer)
-			ld->flush_buffer(tty);
-		tty_ldisc_deref(ld);
-	}
-		
+
+	tty_ldisc_flush(tty);
+
@@ -1118,2 +1030,0 @@
-	wake_up_interruptible(&info->close_wait);
-
@@ -1125 +1036 @@
-	struct mxser_struct *info = tty->driver_data;
+	struct mxser_port *info = tty->driver_data;
@@ -1149 +1060 @@
-	if (info->xmit_cnt && !tty->stopped && !(info->IER & UART_IER_THRI)) {
+	if (info->xmit_cnt && !tty->stopped) {
@@ -1152 +1063 @@
-				(info->IsMoxaMustChipFlag)) {
+				(info->board->chip_flag)) {
@@ -1153,0 +1065,2 @@
+			outb(info->IER & ~UART_IER_THRI, info->ioaddr +
+					UART_IER);
@@ -1155 +1068 @@
-			outb(info->IER, info->base + UART_IER);
+			outb(info->IER, info->ioaddr + UART_IER);
@@ -1164 +1077 @@
-	struct mxser_struct *info = tty->driver_data;
+	struct mxser_port *info = tty->driver_data;
@@ -1178 +1091 @@
-	if (!tty->stopped && !(info->IER & UART_IER_THRI)) {
+	if (!tty->stopped) {
@@ -1181 +1094 @@
-				info->IsMoxaMustChipFlag) {
+				info->board->chip_flag) {
@@ -1182,0 +1096 @@
+			outb(info->IER & ~UART_IER_THRI, info->ioaddr + UART_IER);
@@ -1184 +1098 @@
-			outb(info->IER, info->base + UART_IER);
+			outb(info->IER, info->ioaddr + UART_IER);
@@ -1193 +1107 @@
-	struct mxser_struct *info = tty->driver_data;
+	struct mxser_port *info = tty->driver_data;
@@ -1201 +1115 @@
-			 (!info->IsMoxaMustChipFlag)
+			 (!info->board->chip_flag)
@@ -1206,0 +1121 @@
+	outb(info->IER & ~UART_IER_THRI, info->ioaddr + UART_IER);
@@ -1208 +1123 @@
-	outb(info->IER, info->base + UART_IER);
+	outb(info->IER, info->ioaddr + UART_IER);
@@ -1215 +1130 @@
-	struct mxser_struct *info = tty->driver_data;
+	struct mxser_port *info = tty->driver_data;
@@ -1226 +1141 @@
-	struct mxser_struct *info = tty->driver_data;
+	struct mxser_port *info = tty->driver_data;
@@ -1232 +1147 @@
-	struct mxser_struct *info = tty->driver_data;
+	struct mxser_port *info = tty->driver_data;
@@ -1240,2 +1155 @@
-	/* below added by shinhay */
-	fcr = inb(info->base + UART_FCR);
+	fcr = inb(info->ioaddr + UART_FCR);
@@ -1243,2 +1157,2 @@
-		info->base + UART_FCR);
-	outb(fcr, info->base + UART_FCR);
+		info->ioaddr + UART_FCR);
+	outb(fcr, info->ioaddr + UART_FCR);
@@ -1247 +1160,0 @@
-	/* above added by shinhay */
@@ -1252 +1165,7 @@
-static int mxser_ioctl(struct tty_struct *tty, struct file *file, unsigned int cmd, unsigned long arg)
+/*
+ * ------------------------------------------------------------
+ * friends of mxser_ioctl()
+ * ------------------------------------------------------------
+ */
+static int mxser_get_serial_info(struct mxser_port *info,
+		struct serial_struct __user *retinfo)
@@ -1254,7 +1173,16 @@
-	struct mxser_struct *info = tty->driver_data;
-	int retval;
-	struct async_icount cprev, cnow;	/* kernel counter temps */
-	struct serial_icounter_struct __user *p_cuser;
-	unsigned long templ;
-	unsigned long flags;
-	void __user *argp = (void __user *)arg;
+	struct serial_struct tmp = {
+		.type = info->type,
+		.line = info->tty->index,
+		.port = info->ioaddr,
+		.irq = info->board->irq,
+		.flags = info->flags,
+		.baud_base = info->baud_base,
+		.close_delay = info->close_delay,
+		.closing_wait = info->closing_wait,
+		.custom_divisor = info->custom_divisor,
+		.hub6 = 0
+	};
+	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
+		return -EFAULT;
+	return 0;
+}
@@ -1262,2 +1190,8 @@
-	if (tty->index == MXSER_PORTS)
-		return mxser_ioctl_special(cmd, argp);
+static int mxser_set_serial_info(struct mxser_port *info,
+		struct serial_struct __user *new_info)
+{
+	struct serial_struct new_serial;
+	speed_t baud;
+	unsigned long sl_flags;
+	unsigned int flags;
+	int retval = 0;
@@ -1265,6 +1199,4 @@
-	/* following add by Victor Yu. 01-05-2004 */
-	if (cmd == MOXA_SET_OP_MODE || cmd == MOXA_GET_OP_MODE) {
-		int opmode, p;
-		static unsigned char ModeMask[] = { 0xfc, 0xf3, 0xcf, 0x3f };
-		int shiftbit;
-		unsigned char val, mask;
+	if (!new_info || !info->ioaddr)
+		return -ENODEV;
+	if (copy_from_user(&new_serial, new_info, sizeof(new_serial)))
+		return -EFAULT;
@@ -1272,25 +1204,3 @@
-		p = info->port % 4;
-		if (cmd == MOXA_SET_OP_MODE) {
-			if (get_user(opmode, (int __user *) argp))
-				return -EFAULT;
-			if (opmode != RS232_MODE &&
-					opmode != RS485_2WIRE_MODE &&
-					opmode != RS422_MODE &&
-					opmode != RS485_4WIRE_MODE)
-				return -EFAULT;
-			mask = ModeMask[p];
-			shiftbit = p * 2;
-			val = inb(info->opmode_ioaddr);
-			val &= mask;
-			val |= (opmode << shiftbit);
-			outb(val, info->opmode_ioaddr);
-		} else {
-			shiftbit = p * 2;
-			opmode = inb(info->opmode_ioaddr) >> shiftbit;
-			opmode &= OP_MODE_MASK;
-			if (copy_to_user(argp, &opmode, sizeof(int)))
-				return -EFAULT;
-		}
-		return 0;
-	}
-	/* above add by Victor Yu. 01-05-2004 */
+	if (new_serial.irq != info->board->irq ||
+			new_serial.port != info->ioaddr)
+		return -EINVAL;
@@ -1298,34 +1208,10 @@
-	if ((cmd != TIOCGSERIAL) && (cmd != TIOCMIWAIT) && (cmd != TIOCGICOUNT)) {
-		if (tty->flags & (1 << TTY_IO_ERROR))
-			return -EIO;
-	}
-	switch (cmd) {
-	case TCSBRK:		/* SVID version: non-zero arg --> no break */
-		retval = tty_check_change(tty);
-		if (retval)
-			return retval;
-		tty_wait_until_sent(tty, 0);
-		if (!arg)
-			mxser_send_break(info, HZ / 4);	/* 1/4 second */
-		return 0;
-	case TCSBRKP:		/* support for POSIX tcsendbreak() */
-		retval = tty_check_change(tty);
-		if (retval)
-			return retval;
-		tty_wait_until_sent(tty, 0);
-		mxser_send_break(info, arg ? arg * (HZ / 10) : HZ / 4);
-		return 0;
-	case TIOCGSOFTCAR:
-		return put_user(C_CLOCAL(tty) ? 1 : 0, (unsigned long __user *)argp);
-	case TIOCSSOFTCAR:
-		if (get_user(templ, (unsigned long __user *) argp))
-			return -EFAULT;
-		arg = templ;
-		tty->termios->c_cflag = ((tty->termios->c_cflag & ~CLOCAL) | (arg ? CLOCAL : 0));
-		return 0;
-	case TIOCGSERIAL:
-		return mxser_get_serial_info(info, argp);
-	case TIOCSSERIAL:
-		return mxser_set_serial_info(info, argp);
-	case TIOCSERGETLSR:	/* Get line status register */
-		return mxser_get_lsr_info(info, argp);
+	flags = info->flags & ASYNC_SPD_MASK;
+
+	if (!capable(CAP_SYS_ADMIN)) {
+		if ((new_serial.baud_base != info->baud_base) ||
+				(new_serial.close_delay != info->close_delay) ||
+				((new_serial.flags & ~ASYNC_USR_MASK) != (info->flags & ~ASYNC_USR_MASK)))
+			return -EPERM;
+		info->flags = ((info->flags & ~ASYNC_USR_MASK) |
+				(new_serial.flags & ASYNC_USR_MASK));
+	} else {
@@ -1333,4 +1219,2 @@
-		 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change
-		 * - mask passed in arg for lines of interest
-		 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
-		 * Caller should use TIOCGICOUNT to see which one it was
+		 * OK, past this point, all the error checking has been done.
+		 * At this point, we start making changes.....
@@ -1338,4 +1222,15 @@
-	case TIOCMIWAIT:
-		spin_lock_irqsave(&info->slock, flags);
-		cnow = info->icount;	/* note the counters on entry */
-		spin_unlock_irqrestore(&info->slock, flags);
+		info->flags = ((info->flags & ~ASYNC_FLAGS) |
+				(new_serial.flags & ASYNC_FLAGS));
+		info->close_delay = new_serial.close_delay * HZ / 100;
+		info->closing_wait = new_serial.closing_wait * HZ / 100;
+		info->tty->low_latency =
+				(info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+		info->tty->low_latency = 0;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST &&
+				(new_serial.baud_base != info->baud_base ||
+				new_serial.custom_divisor !=
+				info->custom_divisor)) {
+			baud = new_serial.baud_base / new_serial.custom_divisor;
+			tty_encode_baud_rate(info->tty, baud, baud);
+		}
+	}
@@ -1343,5 +1238 @@
-		wait_event_interruptible(info->delta_msr_wait, ({
-			cprev = cnow;
-			spin_lock_irqsave(&info->slock, flags);
-			cnow = info->icount;	/* atomic copy */
-			spin_unlock_irqrestore(&info->slock, flags);
+	info->type = new_serial.type;
@@ -1349,51 +1240,7 @@
-			((arg & TIOCM_RNG) && (cnow.rng != cprev.rng)) ||
-			((arg & TIOCM_DSR) && (cnow.dsr != cprev.dsr)) ||
-			((arg & TIOCM_CD)  && (cnow.dcd != cprev.dcd)) ||
-			((arg & TIOCM_CTS) && (cnow.cts != cprev.cts));
-		}));
-		break;
-		/*
-		 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
-		 * Return: write counters to the user passed counter struct
-		 * NB: both 1->0 and 0->1 transitions are counted except for
-		 *     RI where only 0->1 is counted.
-		 */
-	case TIOCGICOUNT:
-		spin_lock_irqsave(&info->slock, flags);
-		cnow = info->icount;
-		spin_unlock_irqrestore(&info->slock, flags);
-		p_cuser = argp;
-		/* modified by casper 1/11/2000 */
-		if (put_user(cnow.frame, &p_cuser->frame))
-			return -EFAULT;
-		if (put_user(cnow.brk, &p_cuser->brk))
-			return -EFAULT;
-		if (put_user(cnow.overrun, &p_cuser->overrun))
-			return -EFAULT;
-		if (put_user(cnow.buf_overrun, &p_cuser->buf_overrun))
-			return -EFAULT;
-		if (put_user(cnow.parity, &p_cuser->parity))
-			return -EFAULT;
-		if (put_user(cnow.rx, &p_cuser->rx))
-			return -EFAULT;
-		if (put_user(cnow.tx, &p_cuser->tx))
-			return -EFAULT;
-		put_user(cnow.cts, &p_cuser->cts);
-		put_user(cnow.dsr, &p_cuser->dsr);
-		put_user(cnow.rng, &p_cuser->rng);
-		put_user(cnow.dcd, &p_cuser->dcd);
-		return 0;
-	case MOXA_HighSpeedOn:
-		return put_user(info->baud_base != 115200 ? 1 : 0, (int __user *)argp);
-	case MOXA_SDS_RSTICOUNTER: {
-			info->mon_data.rxcnt = 0;
-			info->mon_data.txcnt = 0;
-			return 0;
-		}
-/* (above) added by James. */
-	case MOXA_ASPP_SETBAUD:{
-			long baud;
-			if (get_user(baud, (long __user *)argp))
-				return -EFAULT;
-			mxser_set_baud(info, baud);
-			return 0;
+	process_txrx_fifo(info);
+
+	if (info->flags & ASYNC_INITIALIZED) {
+		if (flags != (info->flags & ASYNC_SPD_MASK)) {
+			spin_lock_irqsave(&info->slock, sl_flags);
+			mxser_change_speed(info, NULL);
+			spin_unlock_irqrestore(&info->slock, sl_flags);
@@ -1401,3 +1248,2 @@
-	case MOXA_ASPP_GETBAUD:
-		if (copy_to_user(argp, &info->realbaud, sizeof(long)))
-			return -EFAULT;
+	} else
+		retval = mxser_startup(info);
@@ -1405 +1251,2 @@
-		return 0;
+	return retval;
+}
@@ -1407,2 +1254,16 @@
-	case MOXA_ASPP_OQUEUE:{
-			int len, lsr;
+/*
+ * mxser_get_lsr_info - get line status register info
+ *
+ * Purpose: Let user call ioctl() to get info when the UART physically
+ *	    is emptied.  On bus types like RS485, the transmitter must
+ *	    release the bus after transmitting. This must be done when
+ *	    the transmit shift register is empty, not be done when the
+ *	    transmit holding register is empty.  This functionality
+ *	    allows an RS485 driver to be written in user space.
+ */
+static int mxser_get_lsr_info(struct mxser_port *info,
+		unsigned int __user *value)
+{
+	unsigned char status;
+	unsigned int result;
+	unsigned long flags;
@@ -1410 +1271,6 @@
-			len = mxser_chars_in_buffer(tty);
+	spin_lock_irqsave(&info->slock, flags);
+	status = inb(info->ioaddr + UART_LSR);
+	spin_unlock_irqrestore(&info->slock, flags);
+	result = ((status & UART_LSR_TEMT) ? TIOCSER_TEMT : 0);
+	return put_user(result, value);
+}
@@ -1412 +1278,6 @@
-			lsr = inb(info->base + UART_LSR) & UART_LSR_TEMT;
+/*
+ * This routine sends a break character out the serial port.
+ */
+static void mxser_send_break(struct mxser_port *info, int duration)
+{
+	unsigned long flags;
@@ -1414 +1285,13 @@
-			len += (lsr ? 0 : 1);
+	if (!info->ioaddr)
+		return;
+	set_current_state(TASK_INTERRUPTIBLE);
+	spin_lock_irqsave(&info->slock, flags);
+	outb(inb(info->ioaddr + UART_LCR) | UART_LCR_SBC,
+		info->ioaddr + UART_LCR);
+	spin_unlock_irqrestore(&info->slock, flags);
+	schedule_timeout(duration);
+	spin_lock_irqsave(&info->slock, flags);
+	outb(inb(info->ioaddr + UART_LCR) & ~UART_LCR_SBC,
+		info->ioaddr + UART_LCR);
+	spin_unlock_irqrestore(&info->slock, flags);
+}
@@ -1416,2 +1299,5 @@
-			if (copy_to_user(argp, &len, sizeof(int)))
-				return -EFAULT;
+static int mxser_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	struct mxser_port *info = tty->driver_data;
+	unsigned char control, status;
+	unsigned long flags;
@@ -1419,4 +1304,0 @@
-			return 0;
-		}
-	case MOXA_ASPP_MON: {
-			int mcr, status;
@@ -1424 +1306,4 @@
-			/* info->mon_data.ser_param = tty->termios->c_cflag; */
+	if (tty->index == MXSER_PORTS)
+		return -ENOIOCTLCMD;
+	if (test_bit(TTY_IO_ERROR, &tty->flags))
+		return -EIO;
@@ -1426,2 +1311 @@
-			status = mxser_get_msr(info->base, 1, info->port, info);
-			mxser_check_modem_status(info, status);
+	control = info->MCR;
@@ -1429,5 +1313,12 @@
-			mcr = inb(info->base + UART_MCR);
-			if (mcr & MOXA_MUST_MCR_XON_FLAG)
-				info->mon_data.hold_reason &= ~NPPI_NOTIFY_XOFFHOLD;
-			else
-				info->mon_data.hold_reason |= NPPI_NOTIFY_XOFFHOLD;
+	spin_lock_irqsave(&info->slock, flags);
+	status = inb(info->ioaddr + UART_MSR);
+	if (status & UART_MSR_ANY_DELTA)
+		mxser_check_modem_status(info, status);
+	spin_unlock_irqrestore(&info->slock, flags);
+	return ((control & UART_MCR_RTS) ? TIOCM_RTS : 0) |
+		    ((control & UART_MCR_DTR) ? TIOCM_DTR : 0) |
+		    ((status & UART_MSR_DCD) ? TIOCM_CAR : 0) |
+		    ((status & UART_MSR_RI) ? TIOCM_RNG : 0) |
+		    ((status & UART_MSR_DSR) ? TIOCM_DSR : 0) |
+		    ((status & UART_MSR_CTS) ? TIOCM_CTS : 0);
+}
@@ -1435,4 +1326,5 @@
-			if (mcr & MOXA_MUST_MCR_TX_XON)
-				info->mon_data.hold_reason &= ~NPPI_NOTIFY_XOFFXENT;
-			else
-				info->mon_data.hold_reason |= NPPI_NOTIFY_XOFFXENT;
+static int mxser_tiocmset(struct tty_struct *tty, struct file *file,
+		unsigned int set, unsigned int clear)
+{
+	struct mxser_port *info = tty->driver_data;
+	unsigned long flags;
@@ -1440,4 +1331,0 @@
-			if (info->tty->hw_stopped)
-				info->mon_data.hold_reason |= NPPI_NOTIFY_CTSHOLD;
-			else
-				info->mon_data.hold_reason &= ~NPPI_NOTIFY_CTSHOLD;
@@ -1445,3 +1333,4 @@
-			if (copy_to_user(argp, &info->mon_data,
-					sizeof(struct mxser_mon)))
-				return -EFAULT;
+	if (tty->index == MXSER_PORTS)
+		return -ENOIOCTLCMD;
+	if (test_bit(TTY_IO_ERROR, &tty->flags))
+		return -EIO;
@@ -1449,2 +1338 @@
-			return 0;
-		}
+	spin_lock_irqsave(&info->slock, flags);
@@ -1452,4 +1340,4 @@
-	case MOXA_ASPP_LSTATUS: {
-			if (copy_to_user(argp, &info->err_shadow,
-					sizeof(unsigned char)))
-				return -EFAULT;
+	if (set & TIOCM_RTS)
+		info->MCR |= UART_MCR_RTS;
+	if (set & TIOCM_DTR)
+		info->MCR |= UART_MCR_DTR;
@@ -1457,5 +1345,4 @@
-			info->err_shadow = 0;
-			return 0;
-		}
-	case MOXA_SET_BAUD_METHOD: {
-			int method;
+	if (clear & TIOCM_RTS)
+		info->MCR &= ~UART_MCR_RTS;
+	if (clear & TIOCM_DTR)
+		info->MCR &= ~UART_MCR_DTR;
@@ -1463,5 +1350,4 @@
-			if (get_user(method, (int __user *)argp))
-				return -EFAULT;
-			mxser_set_baud_method[info->port] = method;
-			if (copy_to_user(argp, &method, sizeof(int)))
-				return -EFAULT;
+	outb(info->MCR, info->ioaddr + UART_MCR);
+	spin_unlock_irqrestore(&info->slock, flags);
+	return 0;
+}
@@ -1469,4 +1355,29 @@
-			return 0;
-		}
-	default:
-		return -ENOIOCTLCMD;
+static int __init mxser_program_mode(int port)
+{
+	int id, i, j, n;
+
+	outb(0, port);
+	outb(0, port);
+	outb(0, port);
+	(void)inb(port);
+	(void)inb(port);
+	outb(0, port);
+	(void)inb(port);
+
+	id = inb(port + 1) & 0x1F;
+	if ((id != C168_ASIC_ID) &&
+			(id != C104_ASIC_ID) &&
+			(id != C102_ASIC_ID) &&
+			(id != CI132_ASIC_ID) &&
+			(id != CI134_ASIC_ID) &&
+			(id != CI104J_ASIC_ID))
+		return -1;
+	for (i = 0, j = 0; i < 4; i++) {
+		n = inb(port + 2);
+		if (n == 'M') {
+			j = 1;
+		} else if ((j == 1) && (n == 1)) {
+			j = 2;
+			break;
+		} else
+			j = 0;
@@ -1474 +1385,3 @@
-	return 0;
+	if (j != 2)
+		id = -2;
+	return id;
@@ -1477,3 +1390,67 @@
-#ifndef CMSPAR
-#define	CMSPAR 010000000000
-#endif
+static void __init mxser_normal_mode(int port)
+{
+	int i, n;
+
+	outb(0xA5, port + 1);
+	outb(0x80, port + 3);
+	outb(12, port + 0);	/* 9600 bps */
+	outb(0, port + 1);
+	outb(0x03, port + 3);	/* 8 data bits */
+	outb(0x13, port + 4);	/* loop back mode */
+	for (i = 0; i < 16; i++) {
+		n = inb(port + 5);
+		if ((n & 0x61) == 0x60)
+			break;
+		if ((n & 1) == 1)
+			(void)inb(port);
+	}
+	outb(0x00, port + 4);
+}
+
+#define CHIP_SK 	0x01	/* Serial Data Clock  in Eprom */
+#define CHIP_DO 	0x02	/* Serial Data Output in Eprom */
+#define CHIP_CS 	0x04	/* Serial Chip Select in Eprom */
+#define CHIP_DI 	0x08	/* Serial Data Input  in Eprom */
+#define EN_CCMD 	0x000	/* Chip's command register     */
+#define EN0_RSARLO	0x008	/* Remote start address reg 0  */
+#define EN0_RSARHI	0x009	/* Remote start address reg 1  */
+#define EN0_RCNTLO	0x00A	/* Remote byte count reg WR    */
+#define EN0_RCNTHI	0x00B	/* Remote byte count reg WR    */
+#define EN0_DCFG	0x00E	/* Data configuration reg WR   */
+#define EN0_PORT	0x010	/* Rcv missed frame error counter RD */
+#define ENC_PAGE0	0x000	/* Select page 0 of chip registers   */
+#define ENC_PAGE3	0x0C0	/* Select page 3 of chip registers   */
+static int __init mxser_read_register(int port, unsigned short *regs)
+{
+	int i, k, value, id;
+	unsigned int j;
+
+	id = mxser_program_mode(port);
+	if (id < 0)
+		return id;
+	for (i = 0; i < 14; i++) {
+		k = (i & 0x3F) | 0x180;
+		for (j = 0x100; j > 0; j >>= 1) {
+			outb(CHIP_CS, port);
+			if (k & j) {
+				outb(CHIP_CS | CHIP_DO, port);
+				outb(CHIP_CS | CHIP_DO | CHIP_SK, port);	/* A? bit of read */
+			} else {
+				outb(CHIP_CS, port);
+				outb(CHIP_CS | CHIP_SK, port);	/* A? bit of read */
+			}
+		}
+		(void)inb(port);
+		value = 0;
+		for (k = 0, j = 0x8000; k < 16; k++, j >>= 1) {
+			outb(CHIP_CS, port);
+			outb(CHIP_CS | CHIP_SK, port);
+			if (inb(port) & CHIP_DI)
+				value |= j;
+		}
+		regs[i] = value;
+		outb(0, port);
+	}
+	mxser_normal_mode(port);
+	return id;
+}
@@ -1483 +1460,3 @@
-	int i, result, status;
+	struct mxser_port *port;
+	int result, status;
+	unsigned int i, j;
@@ -1486,5 +1464,0 @@
-	case MOXA_GET_CONF:
-		if (copy_to_user(argp, mxsercfg,
-				sizeof(struct mxser_hwconf) * 4))
-			return -EFAULT;
-		return 0;
@@ -1492,8 +1466 @@
-		if (copy_to_user(argp, &ttymajor, sizeof(int)))
-			return -EFAULT;
-		return 0;
-
-	case MOXA_GET_CUMAJOR:
-		if (copy_to_user(argp, &calloutmajor, sizeof(int)))
-			return -EFAULT;
-		return 0;
+		return put_user(ttymajor, (int __user *)argp);
@@ -1503,4 +1470,6 @@
-		for (i = 0; i < MXSER_PORTS; i++) {
-			if (mxvar_table[i].base)
-				result |= (1 << i);
-		}
+
+		for (i = 0; i < MXSER_BOARDS; i++)
+			for (j = 0; j < MXSER_PORTS_PER_BOARD; j++)
+				if (mxser_boards[i].ports[j].ioaddr)
+					result |= (1 << i);
+
@@ -1513,8 +1482,11 @@
-		for (i = 0; i < MXSER_PORTS; i++) {
-			GMStatus[i].ri = 0;
-			if (!mxvar_table[i].base) {
-				GMStatus[i].dcd = 0;
-				GMStatus[i].dsr = 0;
-				GMStatus[i].cts = 0;
-				continue;
-			}
+		for (i = 0; i < MXSER_BOARDS; i++)
+			for (j = 0; j < MXSER_PORTS_PER_BOARD; j++) {
+				port = &mxser_boards[i].ports[j];
+
+				GMStatus[i].ri = 0;
+				if (!port->ioaddr) {
+					GMStatus[i].dcd = 0;
+					GMStatus[i].dsr = 0;
+					GMStatus[i].cts = 0;
+					continue;
+				}
@@ -1522,4 +1494,6 @@
-			if (!mxvar_table[i].tty || !mxvar_table[i].tty->termios)
-				GMStatus[i].cflag = mxvar_table[i].normal_termios.c_cflag;
-			else
-				GMStatus[i].cflag = mxvar_table[i].tty->termios->c_cflag;
+				if (!port->tty || !port->tty->termios)
+					GMStatus[i].cflag =
+						port->normal_termios.c_cflag;
+				else
+					GMStatus[i].cflag =
+						port->tty->termios->c_cflag;
@@ -1527,5 +1501,5 @@
-			status = inb(mxvar_table[i].base + UART_MSR);
-			if (status & 0x80 /*UART_MSR_DCD */ )
-				GMStatus[i].dcd = 1;
-			else
-				GMStatus[i].dcd = 0;
+				status = inb(port->ioaddr + UART_MSR);
+				if (status & 0x80 /*UART_MSR_DCD */ )
+					GMStatus[i].dcd = 1;
+				else
+					GMStatus[i].dcd = 0;
@@ -1533,4 +1507,4 @@
-			if (status & 0x20 /*UART_MSR_DSR */ )
-				GMStatus[i].dsr = 1;
-			else
-				GMStatus[i].dsr = 0;
+				if (status & 0x20 /*UART_MSR_DSR */ )
+					GMStatus[i].dsr = 1;
+				else
+					GMStatus[i].dsr = 0;
@@ -1539,5 +1513,5 @@
-			if (status & 0x10 /*UART_MSR_CTS */ )
-				GMStatus[i].cts = 1;
-			else
-				GMStatus[i].cts = 0;
-		}
+				if (status & 0x10 /*UART_MSR_CTS */ )
+					GMStatus[i].cts = 1;
+				else
+					GMStatus[i].cts = 0;
+			}
@@ -1549,7 +1523,8 @@
-			int status;
-			int opmode, p;
-			int shiftbit;
-			unsigned cflag, iflag;
-
-			for (i = 0; i < MXSER_PORTS; i++) {
-				if (!mxvar_table[i].base)
+		int p, shiftbit;
+		unsigned long opmode;
+		unsigned cflag, iflag;
+
+		for (i = 0; i < MXSER_BOARDS; i++)
+			for (j = 0; j < MXSER_PORTS_PER_BOARD; j++) {
+				port = &mxser_boards[i].ports[j];
+				if (!port->ioaddr)
@@ -1558,6 +1533,2 @@
-				status = mxser_get_msr(mxvar_table[i].base, 0,
-							i, &(mxvar_table[i]));
-				/*
-				mxser_check_modem_status(&mxvar_table[i],
-								status);
-				*/
+				status = mxser_get_msr(port->ioaddr, 0, i);
+
@@ -1565 +1536 @@
-					mxvar_table[i].icount.rng++;
+					port->icount.rng++;
@@ -1567 +1538 @@
-					mxvar_table[i].icount.dsr++;
+					port->icount.dsr++;
@@ -1569 +1540 @@
-					mxvar_table[i].icount.dcd++;
+					port->icount.dcd++;
@@ -1571 +1542 @@
-					mxvar_table[i].icount.cts++;
+					port->icount.cts++;
@@ -1573,11 +1544,15 @@
-				mxvar_table[i].mon_data.modem_status = status;
-				mon_data_ext.rx_cnt[i] = mxvar_table[i].mon_data.rxcnt;
-				mon_data_ext.tx_cnt[i] = mxvar_table[i].mon_data.txcnt;
-				mon_data_ext.up_rxcnt[i] = mxvar_table[i].mon_data.up_rxcnt;
-				mon_data_ext.up_txcnt[i] = mxvar_table[i].mon_data.up_txcnt;
-				mon_data_ext.modem_status[i] = mxvar_table[i].mon_data.modem_status;
-				mon_data_ext.baudrate[i] = mxvar_table[i].realbaud;
-
-				if (!mxvar_table[i].tty || !mxvar_table[i].tty->termios) {
-					cflag = mxvar_table[i].normal_termios.c_cflag;
-					iflag = mxvar_table[i].normal_termios.c_iflag;
+				port->mon_data.modem_status = status;
+				mon_data_ext.rx_cnt[i] = port->mon_data.rxcnt;
+				mon_data_ext.tx_cnt[i] = port->mon_data.txcnt;
+				mon_data_ext.up_rxcnt[i] =
+					port->mon_data.up_rxcnt;
+				mon_data_ext.up_txcnt[i] =
+					port->mon_data.up_txcnt;
+				mon_data_ext.modem_status[i] =
+					port->mon_data.modem_status;
+				mon_data_ext.baudrate[i] =
+					tty_get_baud_rate(port->tty);
+
+				if (!port->tty || !port->tty->termios) {
+					cflag = port->normal_termios.c_cflag;
+					iflag = port->normal_termios.c_iflag;
@@ -1585,2 +1560,2 @@
-					cflag = mxvar_table[i].tty->termios->c_cflag;
-					iflag = mxvar_table[i].tty->termios->c_iflag;
+					cflag = port->tty->termios->c_cflag;
+					iflag = port->tty->termios->c_iflag;
@@ -1593 +1568,2 @@
-				mon_data_ext.parity[i] = cflag & (PARENB | PARODD | CMSPAR);
+				mon_data_ext.parity[i] =
+					cflag & (PARENB | PARODD | CMSPAR);
@@ -1603 +1579 @@
-				if (mxvar_table[i].type == PORT_16550A)
+				if (port->type == PORT_16550A)
@@ -1610 +1586 @@
-				opmode = inb(mxvar_table[i].opmode_ioaddr) >> shiftbit;
+				opmode = inb(port->opmode_ioaddr) >> shiftbit;
@@ -1616 +1592,2 @@
-			if (copy_to_user(argp, &mon_data_ext, sizeof(struct mxser_mon_ext)))
+			if (copy_to_user(argp, &mon_data_ext,
+						sizeof(mon_data_ext)))
@@ -1621,2 +1598 @@
-		}
-	default:
+	} default:
@@ -1628 +1604,2 @@
-static void mxser_stoprx(struct tty_struct *tty)
+static int mxser_cflags_changed(struct mxser_port *info, unsigned long arg,
+		struct async_icount *cprev)
@@ -1630,2 +1607,3 @@
-	struct mxser_struct *info = tty->driver_data;
-	/* unsigned long flags; */
+	struct async_icount cnow;
+	unsigned long flags;
+	int ret;
@@ -1633,19 +1611,3 @@
-	info->ldisc_stop_rx = 1;
-	if (I_IXOFF(tty)) {
-		/* MX_LOCK(&info->slock); */
-		/* following add by Victor Yu. 09-02-2002 */
-		if (info->IsMoxaMustChipFlag) {
-			info->IER &= ~MOXA_MUST_RECV_ISR;
-			outb(info->IER, info->base + UART_IER);
-		} else {
-			/* above add by Victor Yu. 09-02-2002 */
-			info->x_char = STOP_CHAR(tty);
-			/* mask by Victor Yu. 09-02-2002 */
-			/* outb(info->IER, 0); */
-			outb(0, info->base + UART_IER);
-			info->IER |= UART_IER_THRI;
-			/* force Tx interrupt */
-			outb(info->IER, info->base + UART_IER);
-		}		/* add by Victor Yu. 09-02-2002 */
-		/* MX_UNLOCK(&info->slock); */
-	}
+	spin_lock_irqsave(&info->slock, flags);
+	cnow = info->icount;	/* atomic copy */
+	spin_unlock_irqrestore(&info->slock, flags);
@@ -1653,7 +1615,4 @@
-	if (info->tty->termios->c_cflag & CRTSCTS) {
-		/* MX_LOCK(&info->slock); */
-		info->MCR &= ~UART_MCR_RTS;
-		outb(info->MCR, info->base + UART_MCR);
-		/* MX_UNLOCK(&info->slock); */
-	}
-}
+	ret =	((arg & TIOCM_RNG) && (cnow.rng != cprev->rng)) ||
+		((arg & TIOCM_DSR) && (cnow.dsr != cprev->dsr)) ||
+		((arg & TIOCM_CD)  && (cnow.dcd != cprev->dcd)) ||
+		((arg & TIOCM_CTS) && (cnow.cts != cprev->cts));
@@ -1661 +1620,7 @@
-static void mxser_startrx(struct tty_struct *tty)
+	*cprev = cnow;
+
+	return ret;
+}
+
+static int mxser_ioctl(struct tty_struct *tty, struct file *file,
+		unsigned int cmd, unsigned long arg)
@@ -1663,2 +1628,6 @@
-	struct mxser_struct *info = tty->driver_data;
-	/* unsigned long flags; */
+	struct mxser_port *info = tty->driver_data;
+	struct async_icount cnow;
+	struct serial_icounter_struct __user *p_cuser;
+	unsigned long flags;
+	void __user *argp = (void __user *)arg;
+	int retval;
@@ -1666,6 +1635,2 @@
-	info->ldisc_stop_rx = 0;
-	if (I_IXOFF(tty)) {
-		if (info->x_char)
-			info->x_char = 0;
-		else {
-			/* MX_LOCK(&info->slock); */
+	if (tty->index == MXSER_PORTS)
+		return mxser_ioctl_special(cmd, argp);
@@ -1673,6 +1638,6 @@
-			/* following add by Victor Yu. 09-02-2002 */
-			if (info->IsMoxaMustChipFlag) {
-				info->IER |= MOXA_MUST_RECV_ISR;
-				outb(info->IER, info->base + UART_IER);
-			} else {
-				/* above add by Victor Yu. 09-02-2002 */
+	if (cmd == MOXA_SET_OP_MODE || cmd == MOXA_GET_OP_MODE) {
+		int p;
+		unsigned long opmode;
+		static unsigned char ModeMask[] = { 0xfc, 0xf3, 0xcf, 0x3f };
+		int shiftbit;
+		unsigned char val, mask;
@@ -1680,10 +1645,182 @@
-				info->x_char = START_CHAR(tty);
-				/* mask by Victor Yu. 09-02-2002 */
-				/* outb(info->IER, 0); */
-				/* add by Victor Yu. 09-02-2002 */
-				outb(0, info->base + UART_IER);
-				/* force Tx interrupt */
-				info->IER |= UART_IER_THRI;
-				outb(info->IER, info->base + UART_IER);
-			}	/* add by Victor Yu. 09-02-2002 */
-			/* MX_UNLOCK(&info->slock); */
+		p = tty->index % 4;
+		if (cmd == MOXA_SET_OP_MODE) {
+			if (get_user(opmode, (int __user *) argp))
+				return -EFAULT;
+			if (opmode != RS232_MODE &&
+					opmode != RS485_2WIRE_MODE &&
+					opmode != RS422_MODE &&
+					opmode != RS485_4WIRE_MODE)
+				return -EFAULT;
+			mask = ModeMask[p];
+			shiftbit = p * 2;
+			val = inb(info->opmode_ioaddr);
+			val &= mask;
+			val |= (opmode << shiftbit);
+			outb(val, info->opmode_ioaddr);
+		} else {
+			shiftbit = p * 2;
+			opmode = inb(info->opmode_ioaddr) >> shiftbit;
+			opmode &= OP_MODE_MASK;
+			if (put_user(opmode, (int __user *)argp))
+				return -EFAULT;
+		}
+		return 0;
+	}
+
+	if (cmd != TIOCGSERIAL && cmd != TIOCMIWAIT && cmd != TIOCGICOUNT &&
+			test_bit(TTY_IO_ERROR, &tty->flags))
+		return -EIO;
+
+	switch (cmd) {
+	case TCSBRK:		/* SVID version: non-zero arg --> no break */
+		retval = tty_check_change(tty);
+		if (retval)
+			return retval;
+		tty_wait_until_sent(tty, 0);
+		if (!arg)
+			mxser_send_break(info, HZ / 4);	/* 1/4 second */
+		return 0;
+	case TCSBRKP:		/* support for POSIX tcsendbreak() */
+		retval = tty_check_change(tty);
+		if (retval)
+			return retval;
+		tty_wait_until_sent(tty, 0);
+		mxser_send_break(info, arg ? arg * (HZ / 10) : HZ / 4);
+		return 0;
+	case TIOCGSOFTCAR:
+		return put_user(!!C_CLOCAL(tty), (unsigned long __user *)argp);
+	case TIOCSSOFTCAR:
+		if (get_user(arg, (unsigned long __user *)argp))
+			return -EFAULT;
+		tty->termios->c_cflag = ((tty->termios->c_cflag & ~CLOCAL) | (arg ? CLOCAL : 0));
+		return 0;
+	case TIOCGSERIAL:
+		return mxser_get_serial_info(info, argp);
+	case TIOCSSERIAL:
+		return mxser_set_serial_info(info, argp);
+	case TIOCSERGETLSR:	/* Get line status register */
+		return mxser_get_lsr_info(info, argp);
+		/*
+		 * Wait for any of the 4 modem inputs (DCD,RI,DSR,CTS) to change
+		 * - mask passed in arg for lines of interest
+		 *   (use |'ed TIOCM_RNG/DSR/CD/CTS for masking)
+		 * Caller should use TIOCGICOUNT to see which one it was
+		 */
+	case TIOCMIWAIT:
+		spin_lock_irqsave(&info->slock, flags);
+		cnow = info->icount;	/* note the counters on entry */
+		spin_unlock_irqrestore(&info->slock, flags);
+
+		return wait_event_interruptible(info->delta_msr_wait,
+				mxser_cflags_changed(info, arg, &cnow));
+	/*
+	 * Get counter of input serial line interrupts (DCD,RI,DSR,CTS)
+	 * Return: write counters to the user passed counter struct
+	 * NB: both 1->0 and 0->1 transitions are counted except for
+	 *     RI where only 0->1 is counted.
+	 */
+	case TIOCGICOUNT:
+		spin_lock_irqsave(&info->slock, flags);
+		cnow = info->icount;
+		spin_unlock_irqrestore(&info->slock, flags);
+		p_cuser = argp;
+		if (put_user(cnow.frame, &p_cuser->frame))
+			return -EFAULT;
+		if (put_user(cnow.brk, &p_cuser->brk))
+			return -EFAULT;
+		if (put_user(cnow.overrun, &p_cuser->overrun))
+			return -EFAULT;
+		if (put_user(cnow.buf_overrun, &p_cuser->buf_overrun))
+			return -EFAULT;
+		if (put_user(cnow.parity, &p_cuser->parity))
+			return -EFAULT;
+		if (put_user(cnow.rx, &p_cuser->rx))
+			return -EFAULT;
+		if (put_user(cnow.tx, &p_cuser->tx))
+			return -EFAULT;
+		put_user(cnow.cts, &p_cuser->cts);
+		put_user(cnow.dsr, &p_cuser->dsr);
+		put_user(cnow.rng, &p_cuser->rng);
+		put_user(cnow.dcd, &p_cuser->dcd);
+		return 0;
+	case MOXA_HighSpeedOn:
+		return put_user(info->baud_base != 115200 ? 1 : 0, (int __user *)argp);
+	case MOXA_SDS_RSTICOUNTER:
+		info->mon_data.rxcnt = 0;
+		info->mon_data.txcnt = 0;
+		return 0;
+
+	case MOXA_ASPP_OQUEUE:{
+		int len, lsr;
+
+		len = mxser_chars_in_buffer(tty);
+
+		lsr = inb(info->ioaddr + UART_LSR) & UART_LSR_TEMT;
+
+		len += (lsr ? 0 : 1);
+
+		return put_user(len, (int __user *)argp);
+	}
+	case MOXA_ASPP_MON: {
+		int mcr, status;
+
+		status = mxser_get_msr(info->ioaddr, 1, tty->index);
+		mxser_check_modem_status(info, status);
+
+		mcr = inb(info->ioaddr + UART_MCR);
+		if (mcr & MOXA_MUST_MCR_XON_FLAG)
+			info->mon_data.hold_reason &= ~NPPI_NOTIFY_XOFFHOLD;
+		else
+			info->mon_data.hold_reason |= NPPI_NOTIFY_XOFFHOLD;
+
+		if (mcr & MOXA_MUST_MCR_TX_XON)
+			info->mon_data.hold_reason &= ~NPPI_NOTIFY_XOFFXENT;
+		else
+			info->mon_data.hold_reason |= NPPI_NOTIFY_XOFFXENT;
+
+		if (info->tty->hw_stopped)
+			info->mon_data.hold_reason |= NPPI_NOTIFY_CTSHOLD;
+		else
+			info->mon_data.hold_reason &= ~NPPI_NOTIFY_CTSHOLD;
+
+		if (copy_to_user(argp, &info->mon_data,
+				sizeof(struct mxser_mon)))
+			return -EFAULT;
+
+		return 0;
+	}
+	case MOXA_ASPP_LSTATUS: {
+		if (put_user(info->err_shadow, (unsigned char __user *)argp))
+			return -EFAULT;
+
+		info->err_shadow = 0;
+		return 0;
+	}
+	case MOXA_SET_BAUD_METHOD: {
+		int method;
+
+		if (get_user(method, (int __user *)argp))
+			return -EFAULT;
+		mxser_set_baud_method[tty->index] = method;
+		return put_user(method, (int __user *)argp);
+	}
+	default:
+		return -ENOIOCTLCMD;
+	}
+	return 0;
+}
+
+static void mxser_stoprx(struct tty_struct *tty)
+{
+	struct mxser_port *info = tty->driver_data;
+
+	info->ldisc_stop_rx = 1;
+	if (I_IXOFF(tty)) {
+		if (info->board->chip_flag) {
+			info->IER &= ~MOXA_MUST_RECV_ISR;
+			outb(info->IER, info->ioaddr + UART_IER);
+		} else {
+			info->x_char = STOP_CHAR(tty);
+			outb(0, info->ioaddr + UART_IER);
+			info->IER |= UART_IER_THRI;
+			outb(info->IER, info->ioaddr + UART_IER);
@@ -1694,4 +1831,2 @@
-		/* MX_LOCK(&info->slock); */
-		info->MCR |= UART_MCR_RTS;
-		outb(info->MCR, info->base + UART_MCR);
-		/* MX_UNLOCK(&info->slock); */
+		info->MCR &= ~UART_MCR_RTS;
+		outb(info->MCR, info->ioaddr + UART_MCR);
@@ -1707,4 +1841,0 @@
-	/* struct mxser_struct *info = tty->driver_data; */
-	/* unsigned long flags; */
-
-	/* MX_LOCK(&info->slock); */
@@ -1712 +1842,0 @@
-	/* MX_UNLOCK(&info->slock); */
@@ -1717,25 +1847 @@
-	/* struct mxser_struct *info = tty->driver_data; */
-	/* unsigned long flags; */
-
-	/* MX_LOCK(&info->slock); */
-	mxser_startrx(tty);
-	/* MX_UNLOCK(&info->slock); */
-}
-
-static void mxser_set_termios(struct tty_struct *tty, struct ktermios *old_termios)
-{
-	struct mxser_struct *info = tty->driver_data;
-	unsigned long flags;
-
-	mxser_change_speed(info, old_termios);
-
-	if ((old_termios->c_cflag & CRTSCTS) &&
-			!(tty->termios->c_cflag & CRTSCTS)) {
-		tty->hw_stopped = 0;
-		mxser_start(tty);
-	}
-
-/* Handle sw stopped */
-	if ((old_termios->c_iflag & IXON) &&
-			!(tty->termios->c_iflag & IXON)) {
-		tty->stopped = 0;
+	struct mxser_port *info = tty->driver_data;
@@ -1743,5 +1849,15 @@
-		/* following add by Victor Yu. 09-02-2002 */
-		if (info->IsMoxaMustChipFlag) {
-			spin_lock_irqsave(&info->slock, flags);
-			DISABLE_MOXA_MUST_RX_SOFTWARE_FLOW_CONTROL(info->base);
-			spin_unlock_irqrestore(&info->slock, flags);
+	/* startrx */
+	info->ldisc_stop_rx = 0;
+	if (I_IXOFF(tty)) {
+		if (info->x_char)
+			info->x_char = 0;
+		else {
+			if (info->board->chip_flag) {
+				info->IER |= MOXA_MUST_RECV_ISR;
+				outb(info->IER, info->ioaddr + UART_IER);
+			} else {
+				info->x_char = START_CHAR(tty);
+				outb(0, info->ioaddr + UART_IER);
+				info->IER |= UART_IER_THRI;
+				outb(info->IER, info->ioaddr + UART_IER);
+			}
@@ -1749 +1865 @@
-		/* above add by Victor Yu. 09-02-2002 */
+	}
@@ -1751 +1867,3 @@
-		mxser_start(tty);
+	if (info->tty->termios->c_cflag & CRTSCTS) {
+		info->MCR |= UART_MCR_RTS;
+		outb(info->MCR, info->ioaddr + UART_MCR);
@@ -1763 +1881 @@
-	struct mxser_struct *info = tty->driver_data;
+	struct mxser_port *info = tty->driver_data;
@@ -1769 +1887 @@
-		outb(info->IER, info->base + UART_IER);
+		outb(info->IER, info->ioaddr + UART_IER);
@@ -1776 +1894 @@
-	struct mxser_struct *info = tty->driver_data;
+	struct mxser_port *info = tty->driver_data;
@@ -1780 +1898,2 @@
-	if (info->xmit_cnt && info->xmit_buf && !(info->IER & UART_IER_THRI)) {
+	if (info->xmit_cnt && info->xmit_buf) {
+		outb(info->IER & ~UART_IER_THRI, info->ioaddr + UART_IER);
@@ -1782 +1901 @@
-		outb(info->IER, info->base + UART_IER);
+		outb(info->IER, info->ioaddr + UART_IER);
@@ -1786,0 +1906,30 @@
+static void mxser_set_termios(struct tty_struct *tty, struct ktermios *old_termios)
+{
+	struct mxser_port *info = tty->driver_data;
+	unsigned long flags;
+
+	spin_lock_irqsave(&info->slock, flags);
+	mxser_change_speed(info, old_termios);
+	spin_unlock_irqrestore(&info->slock, flags);
+
+	if ((old_termios->c_cflag & CRTSCTS) &&
+			!(tty->termios->c_cflag & CRTSCTS)) {
+		tty->hw_stopped = 0;
+		mxser_start(tty);
+	}
+
+	/* Handle sw stopped */
+	if ((old_termios->c_iflag & IXON) &&
+			!(tty->termios->c_iflag & IXON)) {
+		tty->stopped = 0;
+
+		if (info->board->chip_flag) {
+			spin_lock_irqsave(&info->slock, flags);
+			DISABLE_MOXA_MUST_RX_SOFTWARE_FLOW_CONTROL(info->ioaddr);
+			spin_unlock_irqrestore(&info->slock, flags);
+		}
+
+		mxser_start(tty);
+	}
+}
+
@@ -1792 +1941 @@
-	struct mxser_struct *info = tty->driver_data;
+	struct mxser_port *info = tty->driver_data;
@@ -1833 +1982 @@
-	while (!((lsr = inb(info->base + UART_LSR)) & UART_LSR_TEMT)) {
+	while (!((lsr = inb(info->ioaddr + UART_LSR)) & UART_LSR_TEMT)) {
@@ -1837,846 +1986,5 @@
-		schedule_timeout_interruptible(char_time);
-		if (signal_pending(current))
-			break;
-		if (timeout && time_after(jiffies, orig_jiffies + timeout))
-			break;
-	}
-	set_current_state(TASK_RUNNING);
-
-#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
-	printk("lsr = %d (jiff=%lu)...done\n", lsr, jiffies);
-#endif
-}
-
-
-/*
- * This routine is called by tty_hangup() when a hangup is signaled.
- */
-void mxser_hangup(struct tty_struct *tty)
-{
-	struct mxser_struct *info = tty->driver_data;
-
-	mxser_flush_buffer(tty);
-	mxser_shutdown(info);
-	info->event = 0;
-	info->count = 0;
-	info->flags &= ~ASYNC_NORMAL_ACTIVE;
-	info->tty = NULL;
-	wake_up_interruptible(&info->open_wait);
-}
-
-
-/* added by James 03-12-2004. */
-/*
- * mxser_rs_break() --- routine which turns the break handling on or off
- */
-static void mxser_rs_break(struct tty_struct *tty, int break_state)
-{
-	struct mxser_struct *info = tty->driver_data;
-	unsigned long flags;
-
-	spin_lock_irqsave(&info->slock, flags);
-	if (break_state == -1)
-		outb(inb(info->base + UART_LCR) | UART_LCR_SBC,
-			info->base + UART_LCR);
-	else
-		outb(inb(info->base + UART_LCR) & ~UART_LCR_SBC,
-			info->base + UART_LCR);
-	spin_unlock_irqrestore(&info->slock, flags);
-}
-
-/* (above) added by James. */
-
-
-/*
- * This is the serial driver's generic interrupt routine
- */
-static irqreturn_t mxser_interrupt(int irq, void *dev_id)
-{
-	int status, iir, i;
-	struct mxser_struct *info;
-	struct mxser_struct *port;
-	int max, irqbits, bits, msr;
-	int pass_counter = 0;
-	int handled = IRQ_NONE;
-
-	port = NULL;
-	/* spin_lock(&gm_lock); */
-
-	for (i = 0; i < MXSER_BOARDS; i++) {
-		if (dev_id == &(mxvar_table[i * MXSER_PORTS_PER_BOARD])) {
-			port = dev_id;
-			break;
-		}
-	}
-
-	if (i == MXSER_BOARDS)
-		goto irq_stop;
-	if (port == 0)
-		goto irq_stop;
-	max = mxser_numports[mxsercfg[i].board_type - 1];
-	while (1) {
-		irqbits = inb(port->vector) & port->vectormask;
-		if (irqbits == port->vectormask)
-			break;
-
-		handled = IRQ_HANDLED;
-		for (i = 0, bits = 1; i < max; i++, irqbits |= bits, bits <<= 1) {
-			if (irqbits == port->vectormask)
-				break;
-			if (bits & irqbits)
-				continue;
-			info = port + i;
-
-			/* following add by Victor Yu. 09-13-2002 */
-			iir = inb(info->base + UART_IIR);
-			if (iir & UART_IIR_NO_INT)
-				continue;
-			iir &= MOXA_MUST_IIR_MASK;
-			if (!info->tty) {
-				status = inb(info->base + UART_LSR);
-				outb(0x27, info->base + UART_FCR);
-				inb(info->base + UART_MSR);
-				continue;
-			}
-
-			/* mask by Victor Yu. 09-13-2002
-			   if ( !info->tty ||
-			   (inb(info->base + UART_IIR) & UART_IIR_NO_INT) )
-			   continue;
-			 */
-			/* mask by Victor Yu. 09-02-2002
-			   status = inb(info->base + UART_LSR) & info->read_status_mask;
-			 */
-
-			/* following add by Victor Yu. 09-02-2002 */
-			status = inb(info->base + UART_LSR);
-
-			if (status & UART_LSR_PE)
-				info->err_shadow |= NPPI_NOTIFY_PARITY;
-			if (status & UART_LSR_FE)
-				info->err_shadow |= NPPI_NOTIFY_FRAMING;
-			if (status & UART_LSR_OE)
-				info->err_shadow |= NPPI_NOTIFY_HW_OVERRUN;
-			if (status & UART_LSR_BI)
-				info->err_shadow |= NPPI_NOTIFY_BREAK;
-
-			if (info->IsMoxaMustChipFlag) {
-				/*
-				   if ( (status & 0x02) && !(status & 0x01) ) {
-				   outb(info->base+UART_FCR,  0x23);
-				   continue;
-				   }
-				 */
-				if (iir == MOXA_MUST_IIR_GDA ||
-						iir == MOXA_MUST_IIR_RDA ||
-						iir == MOXA_MUST_IIR_RTO ||
-						iir == MOXA_MUST_IIR_LSR)
-					mxser_receive_chars(info, &status);
-
-			} else {
-				/* above add by Victor Yu. 09-02-2002 */
-
-				status &= info->read_status_mask;
-				if (status & UART_LSR_DR)
-					mxser_receive_chars(info, &status);
-			}
-			msr = inb(info->base + UART_MSR);
-			if (msr & UART_MSR_ANY_DELTA) {
-				mxser_check_modem_status(info, msr);
-			}
-			/* following add by Victor Yu. 09-13-2002 */
-			if (info->IsMoxaMustChipFlag) {
-				if ((iir == 0x02) && (status & UART_LSR_THRE)) {
-					mxser_transmit_chars(info);
-				}
-			} else {
-				/* above add by Victor Yu. 09-13-2002 */
-
-				if (status & UART_LSR_THRE) {
-/* 8-2-99 by William
-			    if ( info->x_char || (info->xmit_cnt > 0) )
-*/
-					mxser_transmit_chars(info);
-				}
-			}
-		}
-		if (pass_counter++ > MXSER_ISR_PASS_LIMIT) {
-			break;	/* Prevent infinite loops */
-		}
-	}
-
-      irq_stop:
-	/* spin_unlock(&gm_lock); */
-	return handled;
-}
-
-static void mxser_receive_chars(struct mxser_struct *info, int *status)
-{
-	struct tty_struct *tty = info->tty;
-	unsigned char ch, gdl;
-	int ignored = 0;
-	int cnt = 0;
-	int recv_room;
-	int max = 256;
-	unsigned long flags;
-
-	spin_lock_irqsave(&info->slock, flags);
-
-	recv_room = tty->receive_room;
-	if ((recv_room == 0) && (!info->ldisc_stop_rx)) {
-		/* mxser_throttle(tty); */
-		mxser_stoprx(tty);
-		/* return; */
-	}
-
-	/* following add by Victor Yu. 09-02-2002 */
-	if (info->IsMoxaMustChipFlag != MOXA_OTHER_UART) {
-
-		if (*status & UART_LSR_SPECIAL) {
-			goto intr_old;
-		}
-		/* following add by Victor Yu. 02-11-2004 */
-		if (info->IsMoxaMustChipFlag == MOXA_MUST_MU860_HWID &&
-				(*status & MOXA_MUST_LSR_RERR))
-			goto intr_old;
-		/* above add by Victor Yu. 02-14-2004 */
-		if (*status & MOXA_MUST_LSR_RERR)
-			goto intr_old;
-
-		gdl = inb(info->base + MOXA_MUST_GDL_REGISTER);
-
-		/* add by Victor Yu. 02-11-2004 */
-		if (info->IsMoxaMustChipFlag == MOXA_MUST_MU150_HWID)
-			gdl &= MOXA_MUST_GDL_MASK;
-		if (gdl >= recv_room) {
-			if (!info->ldisc_stop_rx) {
-				/* mxser_throttle(tty); */
-				mxser_stoprx(tty);
-			}
-			/* return; */
-		}
-		while (gdl--) {
-			ch = inb(info->base + UART_RX);
-			tty_insert_flip_char(tty, ch, 0);
-			cnt++;
-			/*
-			   if ((cnt >= HI_WATER) && (info->stop_rx == 0)) {
-			   mxser_stoprx(tty);
-			   info->stop_rx = 1;
-			   break;
-			   } */
-		}
-		goto end_intr;
-	}
- intr_old:
-	/* above add by Victor Yu. 09-02-2002 */
-
-	do {
-		if (max-- < 0)
-			break;
-		/*
-		   if ((cnt >= HI_WATER) && (info->stop_rx == 0)) {
-		   mxser_stoprx(tty);
-		   info->stop_rx=1;
-		   break;
-		   }
-		 */
-
-		ch = inb(info->base + UART_RX);
-		/* following add by Victor Yu. 09-02-2002 */
-		if (info->IsMoxaMustChipFlag && (*status & UART_LSR_OE) /*&& !(*status&UART_LSR_DR) */ )
-			outb(0x23, info->base + UART_FCR);
-		*status &= info->read_status_mask;
-		/* above add by Victor Yu. 09-02-2002 */
-		if (*status & info->ignore_status_mask) {
-			if (++ignored > 100)
-				break;
-		} else {
-			char flag = 0;
-			if (*status & UART_LSR_SPECIAL) {
-				if (*status & UART_LSR_BI) {
-					flag = TTY_BREAK;
-/* added by casper 1/11/2000 */
-					info->icount.brk++;
-/* */
-					if (info->flags & ASYNC_SAK)
-						do_SAK(tty);
-				} else if (*status & UART_LSR_PE) {
-					flag = TTY_PARITY;
-/* added by casper 1/11/2000 */
-					info->icount.parity++;
-/* */
-				} else if (*status & UART_LSR_FE) {
-					flag = TTY_FRAME;
-/* added by casper 1/11/2000 */
-					info->icount.frame++;
-/* */
-				} else if (*status & UART_LSR_OE) {
-					flag = TTY_OVERRUN;
-/* added by casper 1/11/2000 */
-					info->icount.overrun++;
-/* */
-				}
-			}
-			tty_insert_flip_char(tty, ch, flag);
-			cnt++;
-			if (cnt >= recv_room) {
-				if (!info->ldisc_stop_rx) {
-					/* mxser_throttle(tty); */
-					mxser_stoprx(tty);
-				}
-				break;
-			}
-
-		}
-
-		/* following add by Victor Yu. 09-02-2002 */
-		if (info->IsMoxaMustChipFlag)
-			break;
-		/* above add by Victor Yu. 09-02-2002 */
-
-		/* mask by Victor Yu. 09-02-2002
-		 *status = inb(info->base + UART_LSR) & info->read_status_mask;
-		 */
-		/* following add by Victor Yu. 09-02-2002 */
-		*status = inb(info->base + UART_LSR);
-		/* above add by Victor Yu. 09-02-2002 */
-	} while (*status & UART_LSR_DR);
-
-end_intr:		/* add by Victor Yu. 09-02-2002 */
-	mxvar_log.rxcnt[info->port] += cnt;
-	info->mon_data.rxcnt += cnt;
-	info->mon_data.up_rxcnt += cnt;
-	spin_unlock_irqrestore(&info->slock, flags);
-
-	tty_flip_buffer_push(tty);
-}
-
-static void mxser_transmit_chars(struct mxser_struct *info)
-{
-	int count, cnt;
-	unsigned long flags;
-
-	spin_lock_irqsave(&info->slock, flags);
-
-	if (info->x_char) {
-		outb(info->x_char, info->base + UART_TX);
-		info->x_char = 0;
-		mxvar_log.txcnt[info->port]++;
-		info->mon_data.txcnt++;
-		info->mon_data.up_txcnt++;
-
-/* added by casper 1/11/2000 */
-		info->icount.tx++;
-/* */
-		spin_unlock_irqrestore(&info->slock, flags);
-		return;
-	}
-
-	if (info->xmit_buf == 0) {
-		spin_unlock_irqrestore(&info->slock, flags);
-		return;
-	}
-
-	if ((info->xmit_cnt <= 0) || info->tty->stopped ||
-			(info->tty->hw_stopped &&
-			(info->type != PORT_16550A) &&
-			(!info->IsMoxaMustChipFlag))) {
-		info->IER &= ~UART_IER_THRI;
-		outb(info->IER, info->base + UART_IER);
-		spin_unlock_irqrestore(&info->slock, flags);
-		return;
-	}
-
-	cnt = info->xmit_cnt;
-	count = info->xmit_fifo_size;
-	do {
-		outb(info->xmit_buf[info->xmit_tail++],
-			info->base + UART_TX);
-		info->xmit_tail = info->xmit_tail & (SERIAL_XMIT_SIZE - 1);
-		if (--info->xmit_cnt <= 0)
-			break;
-	} while (--count > 0);
-	mxvar_log.txcnt[info->port] += (cnt - info->xmit_cnt);
-
-/* added by James 03-12-2004. */
-	info->mon_data.txcnt += (cnt - info->xmit_cnt);
-	info->mon_data.up_txcnt += (cnt - info->xmit_cnt);
-/* (above) added by James. */
-
-/* added by casper 1/11/2000 */
-	info->icount.tx += (cnt - info->xmit_cnt);
-/* */
-
-	if (info->xmit_cnt < WAKEUP_CHARS) {
-		set_bit(MXSER_EVENT_TXLOW, &info->event);
-		schedule_work(&info->tqueue);
-	}
-	if (info->xmit_cnt <= 0) {
-		info->IER &= ~UART_IER_THRI;
-		outb(info->IER, info->base + UART_IER);
-	}
-	spin_unlock_irqrestore(&info->slock, flags);
-}
-
-static void mxser_check_modem_status(struct mxser_struct *info, int status)
-{
-	/* update input line counters */
-	if (status & UART_MSR_TERI)
-		info->icount.rng++;
-	if (status & UART_MSR_DDSR)
-		info->icount.dsr++;
-	if (status & UART_MSR_DDCD)
-		info->icount.dcd++;
-	if (status & UART_MSR_DCTS)
-		info->icount.cts++;
-	info->mon_data.modem_status = status;
-	wake_up_interruptible(&info->delta_msr_wait);
-
-	if ((info->flags & ASYNC_CHECK_CD) && (status & UART_MSR_DDCD)) {
-		if (status & UART_MSR_DCD)
-			wake_up_interruptible(&info->open_wait);
-		schedule_work(&info->tqueue);
-	}
-
-	if (info->flags & ASYNC_CTS_FLOW) {
-		if (info->tty->hw_stopped) {
-			if (status & UART_MSR_CTS) {
-				info->tty->hw_stopped = 0;
-
-				if ((info->type != PORT_16550A) &&
-						(!info->IsMoxaMustChipFlag)) {
-					info->IER |= UART_IER_THRI;
-					outb(info->IER, info->base + UART_IER);
-				}
-				set_bit(MXSER_EVENT_TXLOW, &info->event);
-				schedule_work(&info->tqueue);			}
-		} else {
-			if (!(status & UART_MSR_CTS)) {
-				info->tty->hw_stopped = 1;
-				if ((info->type != PORT_16550A) &&
-						(!info->IsMoxaMustChipFlag)) {
-					info->IER &= ~UART_IER_THRI;
-					outb(info->IER, info->base + UART_IER);
-				}
-			}
-		}
-	}
-}
-
-static int mxser_block_til_ready(struct tty_struct *tty, struct file *filp, struct mxser_struct *info)
-{
-	DECLARE_WAITQUEUE(wait, current);
-	int retval;
-	int do_clocal = 0;
-	unsigned long flags;
-
-	/*
-	 * If non-blocking mode is set, or the port is not enabled,
-	 * then make the check up front and then exit.
-	 */
-	if ((filp->f_flags & O_NONBLOCK) || (tty->flags & (1 << TTY_IO_ERROR))) {
-		info->flags |= ASYNC_NORMAL_ACTIVE;
-		return 0;
-	}
-
-	if (tty->termios->c_cflag & CLOCAL)
-		do_clocal = 1;
-
-	/*
-	 * Block waiting for the carrier detect and the line to become
-	 * free (i.e., not in use by the callout).  While we are in
-	 * this loop, info->count is dropped by one, so that
-	 * mxser_close() knows when to free things.  We restore it upon
-	 * exit, either normal or abnormal.
-	 */
-	retval = 0;
-	add_wait_queue(&info->open_wait, &wait);
-
-	spin_lock_irqsave(&info->slock, flags);
-	if (!tty_hung_up_p(filp))
-		info->count--;
-	spin_unlock_irqrestore(&info->slock, flags);
-	info->blocked_open++;
-	while (1) {
-		spin_lock_irqsave(&info->slock, flags);
-		outb(inb(info->base + UART_MCR) |
-			UART_MCR_DTR | UART_MCR_RTS, info->base + UART_MCR);
-		spin_unlock_irqrestore(&info->slock, flags);
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (tty_hung_up_p(filp) || !(info->flags & ASYNC_INITIALIZED)) {
-			if (info->flags & ASYNC_HUP_NOTIFY)
-				retval = -EAGAIN;
-			else
-				retval = -ERESTARTSYS;
-			break;
-		}
-		if (!(info->flags & ASYNC_CLOSING) &&
-				(do_clocal ||
-				(inb(info->base + UART_MSR) & UART_MSR_DCD)))
-			break;
-		if (signal_pending(current)) {
-			retval = -ERESTARTSYS;
-			break;
-		}
-		schedule();
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&info->open_wait, &wait);
-	if (!tty_hung_up_p(filp))
-		info->count++;
-	info->blocked_open--;
-	if (retval)
-		return retval;
-	info->flags |= ASYNC_NORMAL_ACTIVE;
-	return 0;
-}
-
-static int mxser_startup(struct mxser_struct *info)
-{
-	unsigned long page;
-	unsigned long flags;
-
-	page = __get_free_page(GFP_KERNEL);
-	if (!page)
-		return -ENOMEM;
-
-	spin_lock_irqsave(&info->slock, flags);
-
-	if (info->flags & ASYNC_INITIALIZED) {
-		free_page(page);
-		spin_unlock_irqrestore(&info->slock, flags);
-		return 0;
-	}
-
-	if (!info->base || !info->type) {
-		if (info->tty)
-			set_bit(TTY_IO_ERROR, &info->tty->flags);
-		free_page(page);
-		spin_unlock_irqrestore(&info->slock, flags);
-		return 0;
-	}
-	if (info->xmit_buf)
-		free_page(page);
-	else
-		info->xmit_buf = (unsigned char *) page;
-
-	/*
-	 * Clear the FIFO buffers and disable them
-	 * (they will be reenabled in mxser_change_speed())
-	 */
-	if (info->IsMoxaMustChipFlag)
-		outb((UART_FCR_CLEAR_RCVR |
-			UART_FCR_CLEAR_XMIT |
-			MOXA_MUST_FCR_GDA_MODE_ENABLE), info->base + UART_FCR);
-	else
-		outb((UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT),
-			info->base + UART_FCR);
-
-	/*
-	 * At this point there's no way the LSR could still be 0xFF;
-	 * if it is, then bail out, because there's likely no UART
-	 * here.
-	 */
-	if (inb(info->base + UART_LSR) == 0xff) {
-		spin_unlock_irqrestore(&info->slock, flags);
-		if (capable(CAP_SYS_ADMIN)) {
-			if (info->tty)
-				set_bit(TTY_IO_ERROR, &info->tty->flags);
-			return 0;
-		} else
-			return -ENODEV;
-	}
-
-	/*
-	 * Clear the interrupt registers.
-	 */
-	(void) inb(info->base + UART_LSR);
-	(void) inb(info->base + UART_RX);
-	(void) inb(info->base + UART_IIR);
-	(void) inb(info->base + UART_MSR);
-
-	/*
-	 * Now, initialize the UART
-	 */
-	outb(UART_LCR_WLEN8, info->base + UART_LCR);	/* reset DLAB */
-	info->MCR = UART_MCR_DTR | UART_MCR_RTS;
-	outb(info->MCR, info->base + UART_MCR);
-
-	/*
-	 * Finally, enable interrupts
-	 */
-	info->IER = UART_IER_MSI | UART_IER_RLSI | UART_IER_RDI;
-	/* info->IER = UART_IER_RLSI | UART_IER_RDI; */
-
-	/* following add by Victor Yu. 08-30-2002 */
-	if (info->IsMoxaMustChipFlag)
-		info->IER |= MOXA_MUST_IER_EGDAI;
-	/* above add by Victor Yu. 08-30-2002 */
-	outb(info->IER, info->base + UART_IER);	/* enable interrupts */
-
-	/*
-	 * And clear the interrupt registers again for luck.
-	 */
-	(void) inb(info->base + UART_LSR);
-	(void) inb(info->base + UART_RX);
-	(void) inb(info->base + UART_IIR);
-	(void) inb(info->base + UART_MSR);
-
-	if (info->tty)
-		clear_bit(TTY_IO_ERROR, &info->tty->flags);
-	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
-
-	/*
-	 * and set the speed of the serial port
-	 */
-	spin_unlock_irqrestore(&info->slock, flags);
-	mxser_change_speed(info, NULL);
-
-	info->flags |= ASYNC_INITIALIZED;
-	return 0;
-}
-
-/*
- * This routine will shutdown a serial port; interrupts maybe disabled, and
- * DTR is dropped if the hangup on close termio flag is on.
- */
-static void mxser_shutdown(struct mxser_struct *info)
-{
-	unsigned long flags;
-
-	if (!(info->flags & ASYNC_INITIALIZED))
-		return;
-
-	spin_lock_irqsave(&info->slock, flags);
-
-	/*
-	 * clear delta_msr_wait queue to avoid mem leaks: we may free the irq
-	 * here so the queue might never be waken up
-	 */
-	wake_up_interruptible(&info->delta_msr_wait);
-
-	/*
-	 * Free the IRQ, if necessary
-	 */
-	if (info->xmit_buf) {
-		free_page((unsigned long) info->xmit_buf);
-		info->xmit_buf = NULL;
-	}
-
-	info->IER = 0;
-	outb(0x00, info->base + UART_IER);
-
-	if (!info->tty || (info->tty->termios->c_cflag & HUPCL))
-		info->MCR &= ~(UART_MCR_DTR | UART_MCR_RTS);
-	outb(info->MCR, info->base + UART_MCR);
-
-	/* clear Rx/Tx FIFO's */
-	/* following add by Victor Yu. 08-30-2002 */
-	if (info->IsMoxaMustChipFlag)
-		outb((UART_FCR_CLEAR_RCVR |
-			UART_FCR_CLEAR_XMIT |
-			MOXA_MUST_FCR_GDA_MODE_ENABLE), info->base + UART_FCR);
-	else
-		/* above add by Victor Yu. 08-30-2002 */
-		outb((UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT),
-			info->base + UART_FCR);
-
-	/* read data port to reset things */
-	(void) inb(info->base + UART_RX);
-
-	if (info->tty)
-		set_bit(TTY_IO_ERROR, &info->tty->flags);
-
-	info->flags &= ~ASYNC_INITIALIZED;
-
-	/* following add by Victor Yu. 09-23-2002 */
-	if (info->IsMoxaMustChipFlag)
-		SET_MOXA_MUST_NO_SOFTWARE_FLOW_CONTROL(info->base);
-	/* above add by Victor Yu. 09-23-2002 */
-
-	spin_unlock_irqrestore(&info->slock, flags);
-}
-
-/*
- * This routine is called to set the UART divisor registers to match
- * the specified baud rate for a serial port.
- */
-static int mxser_change_speed(struct mxser_struct *info, struct ktermios *old_termios)
-{
-	unsigned cflag, cval, fcr;
-	int ret = 0;
-	unsigned char status;
-	long baud;
-	unsigned long flags;
-
-	if (!info->tty || !info->tty->termios)
-		return ret;
-	cflag = info->tty->termios->c_cflag;
-	if (!(info->base))
-		return ret;
-
-#ifndef B921600
-#define B921600 (B460800 +1)
-#endif
-	if (mxser_set_baud_method[info->port] == 0) {
-		baud = tty_get_baud_rate(info->tty);
-		mxser_set_baud(info, baud);
-	}
-
-	/* byte size and parity */
-	switch (cflag & CSIZE) {
-	case CS5:
-		cval = 0x00;
-		break;
-	case CS6:
-		cval = 0x01;
-		break;
-	case CS7:
-		cval = 0x02;
-		break;
-	case CS8:
-		cval = 0x03;
-		break;
-	default:
-		cval = 0x00;
-		break;		/* too keep GCC shut... */
-	}
-	if (cflag & CSTOPB)
-		cval |= 0x04;
-	if (cflag & PARENB)
-		cval |= UART_LCR_PARITY;
-	if (!(cflag & PARODD))
-		cval |= UART_LCR_EPAR;
-	if (cflag & CMSPAR)
-		cval |= UART_LCR_SPAR;
-
-	if ((info->type == PORT_8250) || (info->type == PORT_16450)) {
-		if (info->IsMoxaMustChipFlag) {
-			fcr = UART_FCR_ENABLE_FIFO;
-			fcr |= MOXA_MUST_FCR_GDA_MODE_ENABLE;
-			SET_MOXA_MUST_FIFO_VALUE(info);
-		} else
-			fcr = 0;
-	} else {
-		fcr = UART_FCR_ENABLE_FIFO;
-		/* following add by Victor Yu. 08-30-2002 */
-		if (info->IsMoxaMustChipFlag) {
-			fcr |= MOXA_MUST_FCR_GDA_MODE_ENABLE;
-			SET_MOXA_MUST_FIFO_VALUE(info);
-		} else {
-			/* above add by Victor Yu. 08-30-2002 */
-			switch (info->rx_trigger) {
-			case 1:
-				fcr |= UART_FCR_TRIGGER_1;
-				break;
-			case 4:
-				fcr |= UART_FCR_TRIGGER_4;
-				break;
-			case 8:
-				fcr |= UART_FCR_TRIGGER_8;
-				break;
-			default:
-				fcr |= UART_FCR_TRIGGER_14;
-				break;
-			}
-		}
-	}
-
-	/* CTS flow control flag and modem status interrupts */
-	info->IER &= ~UART_IER_MSI;
-	info->MCR &= ~UART_MCR_AFE;
-	if (cflag & CRTSCTS) {
-		info->flags |= ASYNC_CTS_FLOW;
-		info->IER |= UART_IER_MSI;
-		if ((info->type == PORT_16550A) || (info->IsMoxaMustChipFlag)) {
-			info->MCR |= UART_MCR_AFE;
-		} else {
-			status = inb(info->base + UART_MSR);
-			if (info->tty->hw_stopped) {
-				if (status & UART_MSR_CTS) {
-					info->tty->hw_stopped = 0;
-					if ((info->type != PORT_16550A) &&
-							(!info->IsMoxaMustChipFlag)) {
-						info->IER |= UART_IER_THRI;
-						outb(info->IER, info->base + UART_IER);
-					}
-					set_bit(MXSER_EVENT_TXLOW, &info->event);
-					schedule_work(&info->tqueue);				}
-			} else {
-				if (!(status & UART_MSR_CTS)) {
-					info->tty->hw_stopped = 1;
-					if ((info->type != PORT_16550A) &&
-							(!info->IsMoxaMustChipFlag)) {
-						info->IER &= ~UART_IER_THRI;
-						outb(info->IER, info->base + UART_IER);
-					}
-				}
-			}
-		}
-	} else {
-		info->flags &= ~ASYNC_CTS_FLOW;
-	}
-	outb(info->MCR, info->base + UART_MCR);
-	if (cflag & CLOCAL) {
-		info->flags &= ~ASYNC_CHECK_CD;
-	} else {
-		info->flags |= ASYNC_CHECK_CD;
-		info->IER |= UART_IER_MSI;
-	}
-	outb(info->IER, info->base + UART_IER);
-
-	/*
-	 * Set up parity check flag
-	 */
-	info->read_status_mask = UART_LSR_OE | UART_LSR_THRE | UART_LSR_DR;
-	if (I_INPCK(info->tty))
-		info->read_status_mask |= UART_LSR_FE | UART_LSR_PE;
-	if (I_BRKINT(info->tty) || I_PARMRK(info->tty))
-		info->read_status_mask |= UART_LSR_BI;
-
-	info->ignore_status_mask = 0;
-
-	if (I_IGNBRK(info->tty)) {
-		info->ignore_status_mask |= UART_LSR_BI;
-		info->read_status_mask |= UART_LSR_BI;
-		/*
-		 * If we're ignore parity and break indicators, ignore
-		 * overruns too.  (For real raw support).
-		 */
-		if (I_IGNPAR(info->tty)) {
-			info->ignore_status_mask |=
-						UART_LSR_OE |
-						UART_LSR_PE |
-						UART_LSR_FE;
-			info->read_status_mask |=
-						UART_LSR_OE |
-						UART_LSR_PE |
-						UART_LSR_FE;
-		}
-	}
-	/* following add by Victor Yu. 09-02-2002 */
-	if (info->IsMoxaMustChipFlag) {
-		spin_lock_irqsave(&info->slock, flags);
-		SET_MOXA_MUST_XON1_VALUE(info->base, START_CHAR(info->tty));
-		SET_MOXA_MUST_XOFF1_VALUE(info->base, STOP_CHAR(info->tty));
-		if (I_IXON(info->tty)) {
-			ENABLE_MOXA_MUST_RX_SOFTWARE_FLOW_CONTROL(info->base);
-		} else {
-			DISABLE_MOXA_MUST_RX_SOFTWARE_FLOW_CONTROL(info->base);
-		}
-		if (I_IXOFF(info->tty)) {
-			ENABLE_MOXA_MUST_TX_SOFTWARE_FLOW_CONTROL(info->base);
-		} else {
-			DISABLE_MOXA_MUST_TX_SOFTWARE_FLOW_CONTROL(info->base);
-		}
-		/*
-		   if ( I_IXANY(info->tty) ) {
-		   info->MCR |= MOXA_MUST_MCR_XON_ANY;
-		   ENABLE_MOXA_MUST_XON_ANY_FLOW_CONTROL(info->base);
-		   } else {
-		   info->MCR &= ~MOXA_MUST_MCR_XON_ANY;
-		   DISABLE_MOXA_MUST_XON_ANY_FLOW_CONTROL(info->base);
-		   }
-		 */
-		spin_unlock_irqrestore(&info->slock, flags);
+		schedule_timeout_interruptible(char_time);
+		if (signal_pending(current))
+			break;
+		if (timeout && time_after(jiffies, orig_jiffies + timeout))
+			break;
@@ -2684 +1992 @@
-	/* above add by Victor Yu. 09-02-2002 */
+	set_current_state(TASK_RUNNING);
@@ -2685,0 +1994,4 @@
+#ifdef SERIAL_DEBUG_RS_WAIT_UNTIL_SENT
+	printk("lsr = %d (jiff=%lu)...done\n", lsr, jiffies);
+#endif
+}
@@ -2687,2 +1999,6 @@
-	outb(fcr, info->base + UART_FCR);	/* set fcr */
-	outb(cval, info->base + UART_LCR);
+/*
+ * This routine is called by tty_hangup() when a hangup is signaled.
+ */
+static void mxser_hangup(struct tty_struct *tty)
+{
+	struct mxser_port *info = tty->driver_data;
@@ -2690 +2006,7 @@
-	return ret;
+	mxser_flush_buffer(tty);
+	mxser_shutdown(info);
+	info->event = 0;
+	info->count = 0;
+	info->flags &= ~ASYNC_NORMAL_ACTIVE;
+	info->tty = NULL;
+	wake_up_interruptible(&info->open_wait);
@@ -2693,2 +2015,4 @@
-
-static int mxser_set_baud(struct mxser_struct *info, long newspd)
+/*
+ * mxser_rs_break() --- routine which turns the break handling on or off
+ */
+static void mxser_rs_break(struct tty_struct *tty, int break_state)
@@ -2696,3 +2020 @@
-	int quot = 0;
-	unsigned char cval;
-	int ret = 0;
+	struct mxser_port *info = tty->driver_data;
@@ -2701,2 +2023,9 @@
-	if (!info->tty || !info->tty->termios)
-		return ret;
+	spin_lock_irqsave(&info->slock, flags);
+	if (break_state == -1)
+		outb(inb(info->ioaddr + UART_LCR) | UART_LCR_SBC,
+			info->ioaddr + UART_LCR);
+	else
+		outb(inb(info->ioaddr + UART_LCR) & ~UART_LCR_SBC,
+			info->ioaddr + UART_LCR);
+	spin_unlock_irqrestore(&info->slock, flags);
+}
@@ -2704,2 +2033,8 @@
-	if (!(info->base))
-		return ret;
+static void mxser_receive_chars(struct mxser_port *port, int *status)
+{
+	struct tty_struct *tty = port->tty;
+	unsigned char ch, gdl;
+	int ignored = 0;
+	int cnt = 0;
+	int recv_room;
+	int max = 256;
@@ -2707,2 +2042,3 @@
-	if (newspd > info->MaxCanSetBaudRate)
-		return 0;
+	recv_room = tty->receive_room;
+	if ((recv_room == 0) && (!port->ldisc_stop_rx))
+		mxser_stoprx(tty);
@@ -2710,10 +2046 @@
-	info->realbaud = newspd;
-	if (newspd == 134) {
-		quot = (2 * info->baud_base / 269);
-	} else if (newspd) {
-		quot = info->baud_base / newspd;
-		if (quot == 0)
-			quot = 1;
-	} else {
-		quot = 0;
-	}
+	if (port->board->chip_flag != MOXA_OTHER_UART) {
@@ -2721,2 +2048,7 @@
-	info->timeout = ((info->xmit_fifo_size * HZ * 10 * quot) / info->baud_base);
-	info->timeout += HZ / 50;	/* Add .02 seconds of slop */
+		if (*status & UART_LSR_SPECIAL)
+			goto intr_old;
+		if (port->board->chip_flag == MOXA_MUST_MU860_HWID &&
+				(*status & MOXA_MUST_LSR_RERR))
+			goto intr_old;
+		if (*status & MOXA_MUST_LSR_RERR)
+			goto intr_old;
@@ -2724,11 +2056,14 @@
-	if (quot) {
-		spin_lock_irqsave(&info->slock, flags);
-		info->MCR |= UART_MCR_DTR;
-		outb(info->MCR, info->base + UART_MCR);
-		spin_unlock_irqrestore(&info->slock, flags);
-	} else {
-		spin_lock_irqsave(&info->slock, flags);
-		info->MCR &= ~UART_MCR_DTR;
-		outb(info->MCR, info->base + UART_MCR);
-		spin_unlock_irqrestore(&info->slock, flags);
-		return ret;
+		gdl = inb(port->ioaddr + MOXA_MUST_GDL_REGISTER);
+
+		if (port->board->chip_flag == MOXA_MUST_MU150_HWID)
+			gdl &= MOXA_MUST_GDL_MASK;
+		if (gdl >= recv_room) {
+			if (!port->ldisc_stop_rx)
+				mxser_stoprx(tty);
+		}
+		while (gdl--) {
+			ch = inb(port->ioaddr + UART_RX);
+			tty_insert_flip_char(tty, ch, 0);
+			cnt++;
+		}
+		goto end_intr;
@@ -2735,0 +2071 @@
+intr_old:
@@ -2737 +2073,17 @@
-	cval = inb(info->base + UART_LCR);
+	do {
+		if (max-- < 0)
+			break;
+
+		ch = inb(port->ioaddr + UART_RX);
+		if (port->board->chip_flag && (*status & UART_LSR_OE))
+			outb(0x23, port->ioaddr + UART_FCR);
+		*status &= port->read_status_mask;
+		if (*status & port->ignore_status_mask) {
+			if (++ignored > 100)
+				break;
+		} else {
+			char flag = 0;
+			if (*status & UART_LSR_SPECIAL) {
+				if (*status & UART_LSR_BI) {
+					flag = TTY_BREAK;
+					port->icount.brk++;
@@ -2739 +2091,21 @@
-	outb(cval | UART_LCR_DLAB, info->base + UART_LCR);	/* set DLAB */
+					if (port->flags & ASYNC_SAK)
+						do_SAK(tty);
+				} else if (*status & UART_LSR_PE) {
+					flag = TTY_PARITY;
+					port->icount.parity++;
+				} else if (*status & UART_LSR_FE) {
+					flag = TTY_FRAME;
+					port->icount.frame++;
+				} else if (*status & UART_LSR_OE) {
+					flag = TTY_OVERRUN;
+					port->icount.overrun++;
+				} else
+					flag = TTY_BREAK;
+			}
+			tty_insert_flip_char(tty, ch, flag);
+			cnt++;
+			if (cnt >= recv_room) {
+				if (!port->ldisc_stop_rx)
+					mxser_stoprx(tty);
+				break;
+			}
@@ -2741,3 +2113 @@
-	outb(quot & 0xff, info->base + UART_DLL);	/* LS of divisor */
-	outb(quot >> 8, info->base + UART_DLM);	/* MS of divisor */
-	outb(cval, info->base + UART_LCR);	/* reset DLAB */
+		}
@@ -2744,0 +2115,2 @@
+		if (port->board->chip_flag)
+			break;
@@ -2746,2 +2118,2 @@
-	return ret;
-}
+		*status = inb(port->ioaddr + UART_LSR);
+	} while (*status & UART_LSR_DR);
@@ -2749,8 +2121,4 @@
-/*
- * ------------------------------------------------------------
- * friends of mxser_ioctl()
- * ------------------------------------------------------------
- */
-static int mxser_get_serial_info(struct mxser_struct *info, struct serial_struct __user *retinfo)
-{
-	struct serial_struct tmp;
+end_intr:
+	mxvar_log.rxcnt[port->tty->index] += cnt;
+	port->mon_data.rxcnt += cnt;
+	port->mon_data.up_rxcnt += cnt;
@@ -2758,16 +2126,8 @@
-	if (!retinfo)
-		return -EFAULT;
-	memset(&tmp, 0, sizeof(tmp));
-	tmp.type = info->type;
-	tmp.line = info->port;
-	tmp.port = info->base;
-	tmp.irq = info->irq;
-	tmp.flags = info->flags;
-	tmp.baud_base = info->baud_base;
-	tmp.close_delay = info->close_delay;
-	tmp.closing_wait = info->closing_wait;
-	tmp.custom_divisor = info->custom_divisor;
-	tmp.hub6 = 0;
-	if (copy_to_user(retinfo, &tmp, sizeof(*retinfo)))
-		return -EFAULT;
-	return 0;
+	/*
+	 * We are called from an interrupt context with &port->slock
+	 * being held. Drop it temporarily in order to prevent
+	 * recursive locking.
+	 */
+	spin_unlock(&port->slock);
+	tty_flip_buffer_push(tty);
+	spin_lock(&port->slock);
@@ -2776 +2136 @@
-static int mxser_set_serial_info(struct mxser_struct *info, struct serial_struct __user *new_info)
+static void mxser_transmit_chars(struct mxser_port *port)
@@ -2778,8 +2138 @@
-	struct serial_struct new_serial;
-	unsigned int flags;
-	int retval = 0;
-
-	if (!new_info || !info->base)
-		return -EFAULT;
-	if (copy_from_user(&new_serial, new_info, sizeof(new_serial)))
-		return -EFAULT;
+	int count, cnt;
@@ -2787,5 +2140,9 @@
-	if ((new_serial.irq != info->irq) ||
-			(new_serial.port != info->base) ||
-			(new_serial.custom_divisor != info->custom_divisor) ||
-			(new_serial.baud_base != info->baud_base))
-		return -EPERM;
+	if (port->x_char) {
+		outb(port->x_char, port->ioaddr + UART_TX);
+		port->x_char = 0;
+		mxvar_log.txcnt[port->tty->index]++;
+		port->mon_data.txcnt++;
+		port->mon_data.up_txcnt++;
+		port->icount.tx++;
+		return;
+	}
@@ -2793 +2150,2 @@
-	flags = info->flags & ASYNC_SPD_MASK;
+	if (port->xmit_buf == NULL)
+		return;
@@ -2795,19 +2153,7 @@
-	if (!capable(CAP_SYS_ADMIN)) {
-		if ((new_serial.baud_base != info->baud_base) ||
-				(new_serial.close_delay != info->close_delay) ||
-				((new_serial.flags & ~ASYNC_USR_MASK) != (info->flags & ~ASYNC_USR_MASK)))
-			return -EPERM;
-		info->flags = ((info->flags & ~ASYNC_USR_MASK) |
-				(new_serial.flags & ASYNC_USR_MASK));
-	} else {
-		/*
-		 * OK, past this point, all the error checking has been done.
-		 * At this point, we start making changes.....
-		 */
-		info->flags = ((info->flags & ~ASYNC_FLAGS) |
-				(new_serial.flags & ASYNC_FLAGS));
-		info->close_delay = new_serial.close_delay * HZ / 100;
-		info->closing_wait = new_serial.closing_wait * HZ / 100;
-		info->tty->low_latency =
-				(info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
-		info->tty->low_latency = 0;	/* (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0; */
+	if ((port->xmit_cnt <= 0) || port->tty->stopped ||
+			(port->tty->hw_stopped &&
+			(port->type != PORT_16550A) &&
+			(!port->board->chip_flag))) {
+		port->IER &= ~UART_IER_THRI;
+		outb(port->IER, port->ioaddr + UART_IER);
+		return;
@@ -2816,4 +2162,10 @@
-	/* added by casper, 3/17/2000, for mouse */
-	info->type = new_serial.type;
-
-	process_txrx_fifo(info);
+	cnt = port->xmit_cnt;
+	count = port->xmit_fifo_size;
+	do {
+		outb(port->xmit_buf[port->xmit_tail++],
+			port->ioaddr + UART_TX);
+		port->xmit_tail = port->xmit_tail & (SERIAL_XMIT_SIZE - 1);
+		if (--port->xmit_cnt <= 0)
+			break;
+	} while (--count > 0);
+	mxvar_log.txcnt[port->tty->index] += (cnt - port->xmit_cnt);
@@ -2821,6 +2173,10 @@
-	if (info->flags & ASYNC_INITIALIZED) {
-		if (flags != (info->flags & ASYNC_SPD_MASK)) {
-			mxser_change_speed(info, NULL);
-		}
-	} else {
-		retval = mxser_startup(info);
+	port->mon_data.txcnt += (cnt - port->xmit_cnt);
+	port->mon_data.up_txcnt += (cnt - port->xmit_cnt);
+	port->icount.tx += (cnt - port->xmit_cnt);
+
+	if (port->xmit_cnt < WAKEUP_CHARS)
+		tty_wakeup(port->tty);
+
+	if (port->xmit_cnt <= 0) {
+		port->IER &= ~UART_IER_THRI;
+		outb(port->IER, port->ioaddr + UART_IER);
@@ -2828 +2183,0 @@
-	return retval;
@@ -2832,8 +2187 @@
- * mxser_get_lsr_info - get line status register info
- *
- * Purpose: Let user call ioctl() to get info when the UART physically
- *	    is emptied.  On bus types like RS485, the transmitter must
- *	    release the bus after transmitting. This must be done when
- *	    the transmit shift register is empty, not be done when the
- *	    transmit holding register is empty.  This functionality
- *	    allows an RS485 driver to be written in user space.
+ * This is the serial driver's generic interrupt routine
@@ -2841 +2189 @@
-static int mxser_get_lsr_info(struct mxser_struct *info, unsigned int __user *value)
+static irqreturn_t mxser_interrupt(int irq, void *dev_id)
@@ -2843,3 +2191,6 @@
-	unsigned char status;
-	unsigned int result;
-	unsigned long flags;
+	int status, iir, i;
+	struct mxser_board *brd = NULL;
+	struct mxser_port *port;
+	int max, irqbits, bits, msr;
+	unsigned int int_cnt, pass_counter = 0;
+	int handled = IRQ_NONE;
@@ -2847,6 +2198,5 @@
-	spin_lock_irqsave(&info->slock, flags);
-	status = inb(info->base + UART_LSR);
-	spin_unlock_irqrestore(&info->slock, flags);
-	result = ((status & UART_LSR_TEMT) ? TIOCSER_TEMT : 0);
-	return put_user(result, value);
-}
+	for (i = 0; i < MXSER_BOARDS; i++)
+		if (dev_id == &mxser_boards[i]) {
+			brd = dev_id;
+			break;
+		}
@@ -2854,6 +2204,9 @@
-/*
- * This routine sends a break character out the serial port.
- */
-static void mxser_send_break(struct mxser_struct *info, int duration)
-{
-	unsigned long flags;
+	if (i == MXSER_BOARDS)
+		goto irq_stop;
+	if (brd == NULL)
+		goto irq_stop;
+	max = brd->info->nports;
+	while (pass_counter++ < MXSER_ISR_PASS_LIMIT) {
+		irqbits = inb(brd->vector) & brd->vector_mask;
+		if (irqbits == brd->vector_mask)
+			break;
@@ -2861,13 +2214,7 @@
-	if (!info->base)
-		return;
-	set_current_state(TASK_INTERRUPTIBLE);
-	spin_lock_irqsave(&info->slock, flags);
-	outb(inb(info->base + UART_LCR) | UART_LCR_SBC,
-		info->base + UART_LCR);
-	spin_unlock_irqrestore(&info->slock, flags);
-	schedule_timeout(duration);
-	spin_lock_irqsave(&info->slock, flags);
-	outb(inb(info->base + UART_LCR) & ~UART_LCR_SBC,
-		info->base + UART_LCR);
-	spin_unlock_irqrestore(&info->slock, flags);
-}
+		handled = IRQ_HANDLED;
+		for (i = 0, bits = 1; i < max; i++, irqbits |= bits, bits <<= 1) {
+			if (irqbits == brd->vector_mask)
+				break;
+			if (bits & irqbits)
+				continue;
+			port = &brd->ports[i];
@@ -2875,5 +2222,16 @@
-static int mxser_tiocmget(struct tty_struct *tty, struct file *file)
-{
-	struct mxser_struct *info = tty->driver_data;
-	unsigned char control, status;
-	unsigned long flags;
+			int_cnt = 0;
+			spin_lock(&port->slock);
+			do {
+				iir = inb(port->ioaddr + UART_IIR);
+				if (iir & UART_IIR_NO_INT)
+					break;
+				iir &= MOXA_MUST_IIR_MASK;
+				if (!port->tty ||
+						(port->flags & ASYNC_CLOSING) ||
+						!(port->flags &
+							ASYNC_INITIALIZED)) {
+					status = inb(port->ioaddr + UART_LSR);
+					outb(0x27, port->ioaddr + UART_FCR);
+					inb(port->ioaddr + UART_MSR);
+					break;
+				}
@@ -2880,0 +2239 @@
+				status = inb(port->ioaddr + UART_LSR);
@@ -2882,4 +2241,17 @@
-	if (tty->index == MXSER_PORTS)
-		return -ENOIOCTLCMD;
-	if (tty->flags & (1 << TTY_IO_ERROR))
-		return -EIO;
+				if (status & UART_LSR_PE)
+					port->err_shadow |= NPPI_NOTIFY_PARITY;
+				if (status & UART_LSR_FE)
+					port->err_shadow |= NPPI_NOTIFY_FRAMING;
+				if (status & UART_LSR_OE)
+					port->err_shadow |=
+						NPPI_NOTIFY_HW_OVERRUN;
+				if (status & UART_LSR_BI)
+					port->err_shadow |= NPPI_NOTIFY_BREAK;
+
+				if (port->board->chip_flag) {
+					if (iir == MOXA_MUST_IIR_GDA ||
+					    iir == MOXA_MUST_IIR_RDA ||
+					    iir == MOXA_MUST_IIR_RTO ||
+					    iir == MOXA_MUST_IIR_LSR)
+						mxser_receive_chars(port,
+								&status);
@@ -2887 +2259,52 @@
-	control = info->MCR;
+				} else {
+					status &= port->read_status_mask;
+					if (status & UART_LSR_DR)
+						mxser_receive_chars(port,
+								&status);
+				}
+				msr = inb(port->ioaddr + UART_MSR);
+				if (msr & UART_MSR_ANY_DELTA)
+					mxser_check_modem_status(port, msr);
+
+				if (port->board->chip_flag) {
+					if (iir == 0x02 && (status &
+								UART_LSR_THRE))
+						mxser_transmit_chars(port);
+				} else {
+					if (status & UART_LSR_THRE)
+						mxser_transmit_chars(port);
+				}
+			} while (int_cnt++ < MXSER_ISR_PASS_LIMIT);
+			spin_unlock(&port->slock);
+		}
+	}
+
+irq_stop:
+	return handled;
+}
+
+static const struct tty_operations mxser_ops = {
+	.open = mxser_open,
+	.close = mxser_close,
+	.write = mxser_write,
+	.put_char = mxser_put_char,
+	.flush_chars = mxser_flush_chars,
+	.write_room = mxser_write_room,
+	.chars_in_buffer = mxser_chars_in_buffer,
+	.flush_buffer = mxser_flush_buffer,
+	.ioctl = mxser_ioctl,
+	.throttle = mxser_throttle,
+	.unthrottle = mxser_unthrottle,
+	.set_termios = mxser_set_termios,
+	.stop = mxser_stop,
+	.start = mxser_start,
+	.hangup = mxser_hangup,
+	.break_ctl = mxser_rs_break,
+	.wait_until_sent = mxser_wait_until_sent,
+	.tiocmget = mxser_tiocmget,
+	.tiocmset = mxser_tiocmset,
+};
+
+/*
+ * The MOXA Smartio/Industio serial driver boot-time initialization code!
+ */
@@ -2889,11 +2312,14 @@
-	spin_lock_irqsave(&info->slock, flags);
-	status = inb(info->base + UART_MSR);
-	if (status & UART_MSR_ANY_DELTA)
-		mxser_check_modem_status(info, status);
-	spin_unlock_irqrestore(&info->slock, flags);
-	return ((control & UART_MCR_RTS) ? TIOCM_RTS : 0) |
-		    ((control & UART_MCR_DTR) ? TIOCM_DTR : 0) |
-		    ((status & UART_MSR_DCD) ? TIOCM_CAR : 0) |
-		    ((status & UART_MSR_RI) ? TIOCM_RNG : 0) |
-		    ((status & UART_MSR_DSR) ? TIOCM_DSR : 0) |
-		    ((status & UART_MSR_CTS) ? TIOCM_CTS : 0);
+static void mxser_release_res(struct mxser_board *brd, struct pci_dev *pdev,
+		unsigned int irq)
+{
+	if (irq)
+		free_irq(brd->irq, brd);
+	if (pdev != NULL) {	/* PCI */
+#ifdef CONFIG_PCI
+		pci_release_region(pdev, 2);
+		pci_release_region(pdev, 3);
+#endif
+	} else {
+		release_region(brd->ports[0].ioaddr, 8 * brd->info->nports);
+		release_region(brd->vector, 1);
+	}
@@ -2902 +2328,2 @@
-static int mxser_tiocmset(struct tty_struct *tty, struct file *file, unsigned int set, unsigned int clear)
+static int __devinit mxser_initbrd(struct mxser_board *brd,
+		struct pci_dev *pdev)
@@ -2904,2 +2331,3 @@
-	struct mxser_struct *info = tty->driver_data;
-	unsigned long flags;
+	struct mxser_port *info;
+	unsigned int i;
+	int retval;
@@ -2906,0 +2335 @@
+	printk(KERN_INFO "max. baud rate = %d bps.\n", brd->ports[0].max_baud);
@@ -2908,4 +2337,5 @@
-	if (tty->index == MXSER_PORTS)
-		return -ENOIOCTLCMD;
-	if (tty->flags & (1 << TTY_IO_ERROR))
-		return -EIO;
+	for (i = 0; i < brd->info->nports; i++) {
+		info = &brd->ports[i];
+		info->board = brd;
+		info->stop_rx = 0;
+		info->ldisc_stop_rx = 0;
@@ -2913 +2343,3 @@
-	spin_lock_irqsave(&info->slock, flags);
+		/* Enhance mode enabled here */
+		if (brd->chip_flag != MOXA_OTHER_UART)
+			ENABLE_MOXA_MUST_ENCHANCE_MODE(info->ioaddr);
@@ -2915,4 +2347,2 @@
-	if (set & TIOCM_RTS)
-		info->MCR |= UART_MCR_RTS;
-	if (set & TIOCM_DTR)
-		info->MCR |= UART_MCR_DTR;
+		info->flags = ASYNC_SHARE_IRQ;
+		info->type = brd->uart_type;
@@ -2920,4 +2350 @@
-	if (clear & TIOCM_RTS)
-		info->MCR &= ~UART_MCR_RTS;
-	if (clear & TIOCM_DTR)
-		info->MCR &= ~UART_MCR_DTR;
+		process_txrx_fifo(info);
@@ -2925,4 +2352,9 @@
-	outb(info->MCR, info->base + UART_MCR);
-	spin_unlock_irqrestore(&info->slock, flags);
-	return 0;
-}
+		info->custom_divisor = info->baud_base * 16;
+		info->close_delay = 5 * HZ / 10;
+		info->closing_wait = 30 * HZ;
+		info->normal_termios = mxvar_sdriver->init_termios;
+		init_waitqueue_head(&info->open_wait);
+		init_waitqueue_head(&info->delta_msr_wait);
+		memset(&info->mon_data, 0, sizeof(struct mxser_mon));
+		info->err_shadow = 0;
+		spin_lock_init(&info->slock);
@@ -2929,0 +2362,4 @@
+		/* before set INT ISR, disable all int */
+		outb(inb(info->ioaddr + UART_IER) & 0xf0,
+			info->ioaddr + UART_IER);
+	}
@@ -2931,3 +2367,11 @@
-static int mxser_read_register(int, unsigned short *);
-static int mxser_program_mode(int);
-static void mxser_normal_mode(int);
+	retval = request_irq(brd->irq, mxser_interrupt, IRQF_SHARED, "mxser",
+			brd);
+	if (retval) {
+		printk(KERN_ERR "Board %s: Request irq failed, IRQ (%d) may "
+			"conflict with another device.\n",
+			brd->info->name, brd->irq);
+		/* We hold resources, we need to release them. */
+		mxser_release_res(brd, pdev, 0);
+	}
+	return retval;
+}
@@ -2935 +2379 @@
-static int mxser_get_ISA_conf(int cap, struct mxser_hwconf *hwconf)
+static int __init mxser_get_ISA_conf(int cap, struct mxser_board *brd)
@@ -2941 +2385 @@
-	hwconf->IsMoxaMustChipFlag = MOXA_OTHER_UART;
+	brd->chip_flag = MOXA_OTHER_UART;
@@ -2944,19 +2388,20 @@
-	if (id == C168_ASIC_ID) {
-		hwconf->board_type = MXSER_BOARD_C168_ISA;
-		hwconf->ports = 8;
-	} else if (id == C104_ASIC_ID) {
-		hwconf->board_type = MXSER_BOARD_C104_ISA;
-		hwconf->ports = 4;
-	} else if (id == C102_ASIC_ID) {
-		hwconf->board_type = MXSER_BOARD_C102_ISA;
-		hwconf->ports = 2;
-	} else if (id == CI132_ASIC_ID) {
-		hwconf->board_type = MXSER_BOARD_CI132;
-		hwconf->ports = 2;
-	} else if (id == CI134_ASIC_ID) {
-		hwconf->board_type = MXSER_BOARD_CI134;
-		hwconf->ports = 4;
-	} else if (id == CI104J_ASIC_ID) {
-		hwconf->board_type = MXSER_BOARD_CI104J;
-		hwconf->ports = 4;
-	} else
+	switch (id) {
+	case C168_ASIC_ID:
+		brd->info = &mxser_cards[0];
+		break;
+	case C104_ASIC_ID:
+		brd->info = &mxser_cards[1];
+		break;
+	case CI104J_ASIC_ID:
+		brd->info = &mxser_cards[2];
+		break;
+	case C102_ASIC_ID:
+		brd->info = &mxser_cards[5];
+		break;
+	case CI132_ASIC_ID:
+		brd->info = &mxser_cards[6];
+		break;
+	case CI134_ASIC_ID:
+		brd->info = &mxser_cards[7];
+		break;
+	default:
@@ -2963,0 +2409 @@
+	}
@@ -2966 +2412,3 @@
-	if (hwconf->ports == 2) {
+	/* some ISA cards have 2 ports, but we want to see them as 4-port (why?)
+	   Flag-hack checks if configuration should be read as 2-port here. */
+	if (brd->info->nports == 2 || (brd->info->flags & MXSER_HAS2)) {
@@ -2971 +2419 @@
-	} else if (hwconf->ports == 4) {
+	} else if (brd->info->nports == 4) {
@@ -2977 +2425 @@
-	} else if (hwconf->ports == 8) {
+	} else if (brd->info->nports == 8) {
@@ -2987 +2435 @@
-	hwconf->irq = ((int)(irq & 0xF000) >> 12);
+	brd->irq = ((int)(irq & 0xF000) >> 12);
@@ -2989 +2437 @@
-		hwconf->ioaddr[i] = (int) regs[i + 1] & 0xFFF8;
+		brd->ports[i].ioaddr = (int) regs[i + 1] & 0xFFF8;
@@ -2992 +2440 @@
-	hwconf->vector = (int)regs[11];	/* interrupt vector */
+	brd->vector = (int)regs[11];	/* interrupt vector */
@@ -2994 +2442 @@
-		hwconf->vector_mask = 0x00FF;
+		brd->vector_mask = 0x00FF;
@@ -2996 +2444 @@
-		hwconf->vector_mask = 0x000F;
+		brd->vector_mask = 0x000F;
@@ -2999,2 +2447,2 @@
-			hwconf->baud_base[i] = 921600;
-			hwconf->MaxCanSetBaudRate[i] = 921600;	/* add by Victor Yu. 09-04-2002 */
+			brd->ports[i].baud_base = 921600;
+			brd->ports[i].max_baud = 921600;
@@ -3002,2 +2450,2 @@
-			hwconf->baud_base[i] = 115200;
-			hwconf->MaxCanSetBaudRate[i] = 115200;	/* add by Victor Yu. 09-04-2002 */
+			brd->ports[i].baud_base = 115200;
+			brd->ports[i].max_baud = 115200;
@@ -3014 +2462 @@
-		hwconf->uart_type = PORT_16550A;
+		brd->uart_type = PORT_16550A;
@@ -3016,8 +2464,9 @@
-		hwconf->uart_type = PORT_16450;
-	if (id == 1)
-		hwconf->ports = 8;
-	else
-		hwconf->ports = 4;
-	request_region(hwconf->ioaddr[0], 8 * hwconf->ports, "mxser(IO)");
-	request_region(hwconf->vector, 1, "mxser(vector)");
-	return hwconf->ports;
+		brd->uart_type = PORT_16450;
+	if (!request_region(brd->ports[0].ioaddr, 8 * brd->info->nports,
+			"mxser(IO)"))
+		return MXSER_ERR_IOADDR;
+	if (!request_region(brd->vector, 1, "mxser(vector)")) {
+		release_region(brd->ports[0].ioaddr, 8 * brd->info->nports);
+		return MXSER_ERR_VECTOR;
+	}
+	return brd->info->nports;
@@ -3026,14 +2475,2 @@
-#define CHIP_SK 	0x01	/* Serial Data Clock  in Eprom */
-#define CHIP_DO 	0x02	/* Serial Data Output in Eprom */
-#define CHIP_CS 	0x04	/* Serial Chip Select in Eprom */
-#define CHIP_DI 	0x08	/* Serial Data Input  in Eprom */
-#define EN_CCMD 	0x000	/* Chip's command register     */
-#define EN0_RSARLO	0x008	/* Remote start address reg 0  */
-#define EN0_RSARHI	0x009	/* Remote start address reg 1  */
-#define EN0_RCNTLO	0x00A	/* Remote byte count reg WR    */
-#define EN0_RCNTHI	0x00B	/* Remote byte count reg WR    */
-#define EN0_DCFG	0x00E	/* Data configuration reg WR   */
-#define EN0_PORT	0x010	/* Rcv missed frame error counter RD */
-#define ENC_PAGE0	0x000	/* Select page 0 of chip registers   */
-#define ENC_PAGE3	0x0C0	/* Select page 3 of chip registers   */
-static int mxser_read_register(int port, unsigned short *regs)
+static int __devinit mxser_probe(struct pci_dev *pdev,
+		const struct pci_device_id *ent)
@@ -3041,2 +2478,5 @@
-	int i, k, value, id;
-	unsigned int j;
+#ifdef CONFIG_PCI
+	struct mxser_board *brd;
+	unsigned int i, j;
+	unsigned long ioaddress;
+	int retval = -EINVAL;
@@ -3044,13 +2484,56 @@
-	id = mxser_program_mode(port);
-	if (id < 0)
-		return id;
-	for (i = 0; i < 14; i++) {
-		k = (i & 0x3F) | 0x180;
-		for (j = 0x100; j > 0; j >>= 1) {
-			outb(CHIP_CS, port);
-			if (k & j) {
-				outb(CHIP_CS | CHIP_DO, port);
-				outb(CHIP_CS | CHIP_DO | CHIP_SK, port);	/* A? bit of read */
-			} else {
-				outb(CHIP_CS, port);
-				outb(CHIP_CS | CHIP_SK, port);	/* A? bit of read */
+	for (i = 0; i < MXSER_BOARDS; i++)
+		if (mxser_boards[i].info == NULL)
+			break;
+
+	if (i >= MXSER_BOARDS) {
+		printk(KERN_ERR "Too many Smartio/Industio family boards found "
+			"(maximum %d), board not configured\n", MXSER_BOARDS);
+		goto err;
+	}
+
+	brd = &mxser_boards[i];
+	brd->idx = i * MXSER_PORTS_PER_BOARD;
+	printk(KERN_INFO "Found MOXA %s board (BusNo=%d, DevNo=%d)\n",
+		mxser_cards[ent->driver_data].name,
+		pdev->bus->number, PCI_SLOT(pdev->devfn));
+
+	retval = pci_enable_device(pdev);
+	if (retval) {
+		printk(KERN_ERR "Moxa SmartI/O PCI enable fail !\n");
+		goto err;
+	}
+
+	/* io address */
+	ioaddress = pci_resource_start(pdev, 2);
+	retval = pci_request_region(pdev, 2, "mxser(IO)");
+	if (retval)
+		goto err;
+
+	brd->info = &mxser_cards[ent->driver_data];
+	for (i = 0; i < brd->info->nports; i++)
+		brd->ports[i].ioaddr = ioaddress + 8 * i;
+
+	/* vector */
+	ioaddress = pci_resource_start(pdev, 3);
+	retval = pci_request_region(pdev, 3, "mxser(vector)");
+	if (retval)
+		goto err_relio;
+	brd->vector = ioaddress;
+
+	/* irq */
+	brd->irq = pdev->irq;
+
+	brd->chip_flag = CheckIsMoxaMust(brd->ports[0].ioaddr);
+	brd->uart_type = PORT_16550A;
+	brd->vector_mask = 0;
+
+	for (i = 0; i < brd->info->nports; i++) {
+		for (j = 0; j < UART_INFO_NUM; j++) {
+			if (Gpci_uart_info[j].type == brd->chip_flag) {
+				brd->ports[i].max_baud =
+					Gpci_uart_info[j].max_baud;
+
+				/* exception....CP-102 */
+				if (brd->info->flags & MXSER_HIGHBAUD)
+					brd->ports[i].max_baud = 921600;
+				break;
@@ -3059,7 +2542,8 @@
-		(void)inb(port);
-		value = 0;
-		for (k = 0, j = 0x8000; k < 16; k++, j >>= 1) {
-			outb(CHIP_CS, port);
-			outb(CHIP_CS | CHIP_SK, port);
-			if (inb(port) & CHIP_DI)
-				value |= j;
+	}
+
+	if (brd->chip_flag == MOXA_MUST_MU860_HWID) {
+		for (i = 0; i < brd->info->nports; i++) {
+			if (i < 4)
+				brd->ports[i].opmode_ioaddr = ioaddress + 4;
+			else
+				brd->ports[i].opmode_ioaddr = ioaddress + 0x0c;
@@ -3067,2 +2551,2 @@
-		regs[i] = value;
-		outb(0, port);
+		outb(0, ioaddress + 4);	/* default set to RS232 mode */
+		outb(0, ioaddress + 0x0c);	/* default set to RS232 mode */
@@ -3070,2 +2554,26 @@
-	mxser_normal_mode(port);
-	return id;
+
+	for (i = 0; i < brd->info->nports; i++) {
+		brd->vector_mask |= (1 << i);
+		brd->ports[i].baud_base = 921600;
+	}
+
+	/* mxser_initbrd will hook ISR. */
+	retval = mxser_initbrd(brd, pdev);
+	if (retval)
+		goto err_null;
+
+	for (i = 0; i < brd->info->nports; i++)
+		tty_register_device(mxvar_sdriver, brd->idx + i, &pdev->dev);
+
+	pci_set_drvdata(pdev, brd);
+
+	return 0;
+err_relio:
+	pci_release_region(pdev, 2);
+err_null:
+	brd->info = NULL;
+err:
+	return retval;
+#else
+	return -ENODEV;
+#endif
@@ -3074 +2582 @@
-static int mxser_program_mode(int port)
+static void __devexit mxser_remove(struct pci_dev *pdev)
@@ -3076,2 +2584,2 @@
-	int id, i, j, n;
-	/* unsigned long flags; */
+	struct mxser_board *brd = pci_get_drvdata(pdev);
+	unsigned int i;
@@ -3079,10 +2587,2 @@
-	spin_lock(&gm_lock);
-	outb(0, port);
-	outb(0, port);
-	outb(0, port);
-	(void)inb(port);
-	(void)inb(port);
-	outb(0, port);
-	(void)inb(port);
-	/* restore_flags(flags); */
-	spin_unlock(&gm_lock);
+	for (i = 0; i < brd->info->nports; i++)
+		tty_unregister_device(mxvar_sdriver, brd->idx + i);
@@ -3090,21 +2590,2 @@
-	id = inb(port + 1) & 0x1F;
-	if ((id != C168_ASIC_ID) &&
-			(id != C104_ASIC_ID) &&
-			(id != C102_ASIC_ID) &&
-			(id != CI132_ASIC_ID) &&
-			(id != CI134_ASIC_ID) &&
-			(id != CI104J_ASIC_ID))
-		return -1;
-	for (i = 0, j = 0; i < 4; i++) {
-		n = inb(port + 2);
-		if (n == 'M') {
-			j = 1;
-		} else if ((j == 1) && (n == 1)) {
-			j = 2;
-			break;
-		} else
-			j = 0;
-	}
-	if (j != 2)
-		id = -2;
-	return id;
+	mxser_release_res(brd, pdev, 1);
+	brd->info = NULL;
@@ -3113 +2594,8 @@
-static void mxser_normal_mode(int port)
+static struct pci_driver mxser_driver = {
+	.name = "mxser",
+	.id_table = mxser_pcibrds,
+	.probe = mxser_probe,
+	.remove = __devexit_p(mxser_remove)
+};
+
+static int __init mxser_module_init(void)
@@ -3115 +2603,4 @@
-	int i, n;
+	struct mxser_board *brd;
+	unsigned long cap;
+	unsigned int i, m, isaloop;
+	int retval, b;
@@ -3117,12 +2608,28 @@
-	outb(0xA5, port + 1);
-	outb(0x80, port + 3);
-	outb(12, port + 0);	/* 9600 bps */
-	outb(0, port + 1);
-	outb(0x03, port + 3);	/* 8 data bits */
-	outb(0x13, port + 4);	/* loop back mode */
-	for (i = 0; i < 16; i++) {
-		n = inb(port + 5);
-		if ((n & 0x61) == 0x60)
-			break;
-		if ((n & 1) == 1)
-			(void)inb(port);
+	pr_debug("Loading module mxser ...\n");
+
+	mxvar_sdriver = alloc_tty_driver(MXSER_PORTS + 1);
+	if (!mxvar_sdriver)
+		return -ENOMEM;
+
+	printk(KERN_INFO "MOXA Smartio/Industio family driver version %s\n",
+		MXSER_VERSION);
+
+	/* Initialize the tty_driver structure */
+	mxvar_sdriver->owner = THIS_MODULE;
+	mxvar_sdriver->magic = TTY_DRIVER_MAGIC;
+	mxvar_sdriver->name = "ttyMI";
+	mxvar_sdriver->major = ttymajor;
+	mxvar_sdriver->minor_start = 0;
+	mxvar_sdriver->num = MXSER_PORTS + 1;
+	mxvar_sdriver->type = TTY_DRIVER_TYPE_SERIAL;
+	mxvar_sdriver->subtype = SERIAL_TYPE_NORMAL;
+	mxvar_sdriver->init_termios = tty_std_termios;
+	mxvar_sdriver->init_termios.c_cflag = B9600|CS8|CREAD|HUPCL|CLOCAL;
+	mxvar_sdriver->flags = TTY_DRIVER_REAL_RAW|TTY_DRIVER_DYNAMIC_DEV;
+	tty_set_operations(mxvar_sdriver, &mxser_ops);
+
+	retval = tty_register_driver(mxvar_sdriver);
+	if (retval) {
+		printk(KERN_ERR "Couldn't install MOXA Smartio/Industio family "
+				"tty driver !\n");
+		goto err_put;
@@ -3130 +2637,98 @@
-	outb(0x00, port + 4);
+
+	mxvar_diagflag = 0;
+
+	m = 0;
+	/* Start finding ISA boards here */
+	for (isaloop = 0; isaloop < 2; isaloop++)
+		for (b = 0; b < MXSER_BOARDS && m < MXSER_BOARDS; b++) {
+			if (!isaloop)
+				cap = mxserBoardCAP[b]; /* predefined */
+			else
+				cap = ioaddr[b]; /* module param */
+
+			if (!cap)
+				continue;
+
+			brd = &mxser_boards[m];
+			retval = mxser_get_ISA_conf(cap, brd);
+
+			if (retval != 0)
+				printk(KERN_INFO "Found MOXA %s board "
+					"(CAP=0x%x)\n",
+					brd->info->name, ioaddr[b]);
+
+			if (retval <= 0) {
+				if (retval == MXSER_ERR_IRQ)
+					printk(KERN_ERR "Invalid interrupt "
+						"number, board not "
+						"configured\n");
+				else if (retval == MXSER_ERR_IRQ_CONFLIT)
+					printk(KERN_ERR "Invalid interrupt "
+						"number, board not "
+						"configured\n");
+				else if (retval == MXSER_ERR_VECTOR)
+					printk(KERN_ERR "Invalid interrupt "
+						"vector, board not "
+						"configured\n");
+				else if (retval == MXSER_ERR_IOADDR)
+					printk(KERN_ERR "Invalid I/O address, "
+						"board not configured\n");
+
+				brd->info = NULL;
+				continue;
+			}
+
+			/* mxser_initbrd will hook ISR. */
+			if (mxser_initbrd(brd, NULL) < 0) {
+				brd->info = NULL;
+				continue;
+			}
+
+			brd->idx = m * MXSER_PORTS_PER_BOARD;
+			for (i = 0; i < brd->info->nports; i++)
+				tty_register_device(mxvar_sdriver, brd->idx + i,
+						NULL);
+
+			m++;
+		}
+
+	retval = pci_register_driver(&mxser_driver);
+	if (retval) {
+		printk(KERN_ERR "Can't register pci driver\n");
+		if (!m) {
+			retval = -ENODEV;
+			goto err_unr;
+		} /* else: we have some ISA cards under control */
+	}
+
+	pr_debug("Done.\n");
+
+	return 0;
+err_unr:
+	tty_unregister_driver(mxvar_sdriver);
+err_put:
+	put_tty_driver(mxvar_sdriver);
+	return retval;
+}
+
+static void __exit mxser_module_exit(void)
+{
+	unsigned int i, j;
+
+	pr_debug("Unloading module mxser ...\n");
+
+	pci_unregister_driver(&mxser_driver);
+
+	for (i = 0; i < MXSER_BOARDS; i++) /* ISA remains */
+		if (mxser_boards[i].info != NULL)
+			for (j = 0; j < mxser_boards[i].info->nports; j++)
+				tty_unregister_device(mxvar_sdriver,
+						mxser_boards[i].idx + j);
+	tty_unregister_driver(mxvar_sdriver);
+	put_tty_driver(mxvar_sdriver);
+
+	for (i = 0; i < MXSER_BOARDS; i++)
+		if (mxser_boards[i].info != NULL)
+			mxser_release_res(&mxser_boards[i], NULL, 1);
+
+	pr_debug("Done.\n");
--- ./projects/linux/linux-2.6.25/drivers/char/mxser.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/mxser.c	2008-07-13 23:51:29.000000000 +0200
@@ -309,0 +310,194 @@
+static void mxser_enable_must_enchance_mode(unsigned long baseio)
+{
+	u8 oldlcr;
+	u8 efr;
+
+	oldlcr = inb(baseio + UART_LCR);
+	outb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);
+
+	efr = inb(baseio + MOXA_MUST_EFR_REGISTER);
+	efr |= MOXA_MUST_EFR_EFRB_ENABLE;
+
+	outb(efr, baseio + MOXA_MUST_EFR_REGISTER);
+	outb(oldlcr, baseio + UART_LCR);
+}
+
+static void mxser_disable_must_enchance_mode(unsigned long baseio)
+{
+	u8 oldlcr;
+	u8 efr;
+
+	oldlcr = inb(baseio + UART_LCR);
+	outb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);
+
+	efr = inb(baseio + MOXA_MUST_EFR_REGISTER);
+	efr &= ~MOXA_MUST_EFR_EFRB_ENABLE;
+
+	outb(efr, baseio + MOXA_MUST_EFR_REGISTER);
+	outb(oldlcr, baseio + UART_LCR);
+}
+
+static void mxser_set_must_xon1_value(unsigned long baseio, u8 value)
+{
+	u8 oldlcr;
+	u8 efr;
+
+	oldlcr = inb(baseio + UART_LCR);
+	outb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);
+
+	efr = inb(baseio + MOXA_MUST_EFR_REGISTER);
+	efr &= ~MOXA_MUST_EFR_BANK_MASK;
+	efr |= MOXA_MUST_EFR_BANK0;
+
+	outb(efr, baseio + MOXA_MUST_EFR_REGISTER);
+	outb(value, baseio + MOXA_MUST_XON1_REGISTER);
+	outb(oldlcr, baseio + UART_LCR);
+}
+
+static void mxser_set_must_xoff1_value(unsigned long baseio, u8 value)
+{
+	u8 oldlcr;
+	u8 efr;
+
+	oldlcr = inb(baseio + UART_LCR);
+	outb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);
+
+	efr = inb(baseio + MOXA_MUST_EFR_REGISTER);
+	efr &= ~MOXA_MUST_EFR_BANK_MASK;
+	efr |= MOXA_MUST_EFR_BANK0;
+
+	outb(efr, baseio + MOXA_MUST_EFR_REGISTER);
+	outb(value, baseio + MOXA_MUST_XOFF1_REGISTER);
+	outb(oldlcr, baseio + UART_LCR);
+}
+
+static void mxser_set_must_fifo_value(struct mxser_port *info)
+{
+	u8 oldlcr;
+	u8 efr;
+
+	oldlcr = inb(info->ioaddr + UART_LCR);
+	outb(MOXA_MUST_ENTER_ENCHANCE, info->ioaddr + UART_LCR);
+
+	efr = inb(info->ioaddr + MOXA_MUST_EFR_REGISTER);
+	efr &= ~MOXA_MUST_EFR_BANK_MASK;
+	efr |= MOXA_MUST_EFR_BANK1;
+
+	outb(efr, info->ioaddr + MOXA_MUST_EFR_REGISTER);
+	outb((u8)info->rx_high_water, info->ioaddr + MOXA_MUST_RBRTH_REGISTER);
+	outb((u8)info->rx_trigger, info->ioaddr + MOXA_MUST_RBRTI_REGISTER);
+	outb((u8)info->rx_low_water, info->ioaddr + MOXA_MUST_RBRTL_REGISTER);
+	outb(oldlcr, info->ioaddr + UART_LCR);
+}
+
+static void mxser_set_must_enum_value(unsigned long baseio, u8 value)
+{
+	u8 oldlcr;
+	u8 efr;
+
+	oldlcr = inb(baseio + UART_LCR);
+	outb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);
+
+	efr = inb(baseio + MOXA_MUST_EFR_REGISTER);
+	efr &= ~MOXA_MUST_EFR_BANK_MASK;
+	efr |= MOXA_MUST_EFR_BANK2;
+
+	outb(efr, baseio + MOXA_MUST_EFR_REGISTER);
+	outb(value, baseio + MOXA_MUST_ENUM_REGISTER);
+	outb(oldlcr, baseio + UART_LCR);
+}
+
+static void mxser_get_must_hardware_id(unsigned long baseio, u8 *pId)
+{
+	u8 oldlcr;
+	u8 efr;
+
+	oldlcr = inb(baseio + UART_LCR);
+	outb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);
+
+	efr = inb(baseio + MOXA_MUST_EFR_REGISTER);
+	efr &= ~MOXA_MUST_EFR_BANK_MASK;
+	efr |= MOXA_MUST_EFR_BANK2;
+
+	outb(efr, baseio + MOXA_MUST_EFR_REGISTER);
+	*pId = inb(baseio + MOXA_MUST_HWID_REGISTER);
+	outb(oldlcr, baseio + UART_LCR);
+}
+
+static void SET_MOXA_MUST_NO_SOFTWARE_FLOW_CONTROL(unsigned long baseio)
+{
+	u8 oldlcr;
+	u8 efr;
+
+	oldlcr = inb(baseio + UART_LCR);
+	outb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);
+
+	efr = inb(baseio + MOXA_MUST_EFR_REGISTER);
+	efr &= ~MOXA_MUST_EFR_SF_MASK;
+
+	outb(efr, baseio + MOXA_MUST_EFR_REGISTER);
+	outb(oldlcr, baseio + UART_LCR);
+}
+
+static void mxser_enable_must_tx_software_flow_control(unsigned long baseio)
+{
+	u8 oldlcr;
+	u8 efr;
+
+	oldlcr = inb(baseio + UART_LCR);
+	outb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);
+
+	efr = inb(baseio + MOXA_MUST_EFR_REGISTER);
+	efr &= ~MOXA_MUST_EFR_SF_TX_MASK;
+	efr |= MOXA_MUST_EFR_SF_TX1;
+
+	outb(efr, baseio + MOXA_MUST_EFR_REGISTER);
+	outb(oldlcr, baseio + UART_LCR);
+}
+
+static void mxser_disable_must_tx_software_flow_control(unsigned long baseio)
+{
+	u8 oldlcr;
+	u8 efr;
+
+	oldlcr = inb(baseio + UART_LCR);
+	outb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);
+
+	efr = inb(baseio + MOXA_MUST_EFR_REGISTER);
+	efr &= ~MOXA_MUST_EFR_SF_TX_MASK;
+
+	outb(efr, baseio + MOXA_MUST_EFR_REGISTER);
+	outb(oldlcr, baseio + UART_LCR);
+}
+
+static void mxser_enable_must_rx_software_flow_control(unsigned long baseio)
+{
+	u8 oldlcr;
+	u8 efr;
+
+	oldlcr = inb(baseio + UART_LCR);
+	outb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);
+
+	efr = inb(baseio + MOXA_MUST_EFR_REGISTER);
+	efr &= ~MOXA_MUST_EFR_SF_RX_MASK;
+	efr |= MOXA_MUST_EFR_SF_RX1;
+
+	outb(efr, baseio + MOXA_MUST_EFR_REGISTER);
+	outb(oldlcr, baseio + UART_LCR);
+}
+
+static void mxser_disable_must_rx_software_flow_control(unsigned long baseio)
+{
+	u8 oldlcr;
+	u8 efr;
+
+	oldlcr = inb(baseio + UART_LCR);
+	outb(MOXA_MUST_ENTER_ENCHANCE, baseio + UART_LCR);
+
+	efr = inb(baseio + MOXA_MUST_EFR_REGISTER);
+	efr &= ~MOXA_MUST_EFR_SF_RX_MASK;
+
+	outb(efr, baseio + MOXA_MUST_EFR_REGISTER);
+	outb(oldlcr, baseio + UART_LCR);
+}
+
@@ -317 +511 @@
-	DISABLE_MOXA_MUST_ENCHANCE_MODE(io);
+	mxser_disable_must_enchance_mode(io);
@@ -320 +514 @@
-	SET_MOXA_MUST_XON1_VALUE(io, 0x11);
+	mxser_set_must_xon1_value(io, 0x11);
@@ -326 +520 @@
-	GET_MOXA_MUST_HARDWARE_ID(io, &hwid);
+	mxser_get_must_hardware_id(io, &hwid);
@@ -497 +691 @@
-		SET_MOXA_MUST_ENUM_VALUE(info->ioaddr, quot);
+		mxser_set_must_enum_value(info->ioaddr, quot);
@@ -500 +694 @@
-		SET_MOXA_MUST_ENUM_VALUE(info->ioaddr, 0);
+		mxser_set_must_enum_value(info->ioaddr, 0);
@@ -556 +750 @@
-			SET_MOXA_MUST_FIFO_VALUE(info);
+			mxser_set_must_fifo_value(info);
@@ -563 +757 @@
-			SET_MOXA_MUST_FIFO_VALUE(info);
+			mxser_set_must_fifo_value(info);
@@ -660,2 +854,2 @@
-		SET_MOXA_MUST_XON1_VALUE(info->ioaddr, START_CHAR(info->tty));
-		SET_MOXA_MUST_XOFF1_VALUE(info->ioaddr, STOP_CHAR(info->tty));
+		mxser_set_must_xon1_value(info->ioaddr, START_CHAR(info->tty));
+		mxser_set_must_xoff1_value(info->ioaddr, STOP_CHAR(info->tty));
@@ -663 +857,2 @@
-			ENABLE_MOXA_MUST_RX_SOFTWARE_FLOW_CONTROL(info->ioaddr);
+			mxser_enable_must_rx_software_flow_control(
+					info->ioaddr);
@@ -665 +860,2 @@
-			DISABLE_MOXA_MUST_RX_SOFTWARE_FLOW_CONTROL(info->ioaddr);
+			mxser_disable_must_rx_software_flow_control(
+					info->ioaddr);
@@ -668 +864,2 @@
-			ENABLE_MOXA_MUST_TX_SOFTWARE_FLOW_CONTROL(info->ioaddr);
+			mxser_enable_must_tx_software_flow_control(
+					info->ioaddr);
@@ -670 +867,2 @@
-			DISABLE_MOXA_MUST_TX_SOFTWARE_FLOW_CONTROL(info->ioaddr);
+			mxser_disable_must_tx_software_flow_control(
+					info->ioaddr);
@@ -929,0 +1128,21 @@
+static void mxser_flush_buffer(struct tty_struct *tty)
+{
+	struct mxser_port *info = tty->driver_data;
+	char fcr;
+	unsigned long flags;
+
+
+	spin_lock_irqsave(&info->slock, flags);
+	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
+
+	fcr = inb(info->ioaddr + UART_FCR);
+	outb((fcr | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT),
+		info->ioaddr + UART_FCR);
+	outb(fcr, info->ioaddr + UART_FCR);
+
+	spin_unlock_irqrestore(&info->slock, flags);
+
+	tty_wakeup(tty);
+}
+
+
@@ -1016,3 +1235 @@
-	if (tty->driver->flush_buffer)
-		tty->driver->flush_buffer(tty);
-
+	mxser_flush_buffer(tty);
@@ -1075 +1292 @@
-static void mxser_put_char(struct tty_struct *tty, unsigned char ch)
+static int mxser_put_char(struct tty_struct *tty, unsigned char ch)
@@ -1081 +1298 @@
-		return;
+		return 0;
@@ -1084 +1301 @@
-		return;
+		return 0;
@@ -1101,0 +1319 @@
+	return 1;
@@ -1145,20 +1362,0 @@
-static void mxser_flush_buffer(struct tty_struct *tty)
-{
-	struct mxser_port *info = tty->driver_data;
-	char fcr;
-	unsigned long flags;
-
-
-	spin_lock_irqsave(&info->slock, flags);
-	info->xmit_cnt = info->xmit_head = info->xmit_tail = 0;
-
-	fcr = inb(info->ioaddr + UART_FCR);
-	outb((fcr | UART_FCR_CLEAR_RCVR | UART_FCR_CLEAR_XMIT),
-		info->ioaddr + UART_FCR);
-	outb(fcr, info->ioaddr + UART_FCR);
-
-	spin_unlock_irqrestore(&info->slock, flags);
-
-	tty_wakeup(tty);
-}
-
@@ -1462,0 +1661 @@
+	int ret = 0;
@@ -1470 +1669 @@
-
+		lock_kernel();
@@ -1475 +1674 @@
-
+		unlock_kernel();
@@ -1477,0 +1677 @@
+		lock_kernel();
@@ -1479,2 +1679,3 @@
-			return -EFAULT;
-		return 0;
+			ret = -EFAULT;
+		unlock_kernel();
+		return ret;
@@ -1481,0 +1683 @@
+		lock_kernel();
@@ -1517,0 +1720 @@
+		unlock_kernel();
@@ -1527 +1730,2 @@
-		for (i = 0; i < MXSER_BOARDS; i++)
+		lock_kernel();
+		for (i = 0; i < MXSER_BOARDS; i++) {
@@ -1592,7 +1796,8 @@
-			if (copy_to_user(argp, &mon_data_ext,
-						sizeof(mon_data_ext)))
-				return -EFAULT;
-
-			return 0;
-
-	} default:
+		}
+		unlock_kernel();
+		if (copy_to_user(argp, &mon_data_ext,
+					sizeof(mon_data_ext)))
+			return -EFAULT;
+		return 0;
+	}
+	default:
@@ -1653,0 +1859 @@
+			lock_kernel();
@@ -1659,0 +1866 @@
+			unlock_kernel();
@@ -1660,0 +1868 @@
+			lock_kernel();
@@ -1663,0 +1872 @@
+			unlock_kernel();
@@ -1690,7 +1898,0 @@
-	case TIOCGSOFTCAR:
-		return put_user(!!C_CLOCAL(tty), (unsigned long __user *)argp);
-	case TIOCSSOFTCAR:
-		if (get_user(arg, (unsigned long __user *)argp))
-			return -EFAULT;
-		tty->termios->c_cflag = ((tty->termios->c_cflag & ~CLOCAL) | (arg ? CLOCAL : 0));
-		return 0;
@@ -1698 +1900,4 @@
-		return mxser_get_serial_info(info, argp);
+		lock_kernel();
+		retval = mxser_get_serial_info(info, argp);
+		unlock_kernel();
+		return retval;
@@ -1700 +1905,4 @@
-		return mxser_set_serial_info(info, argp);
+		lock_kernel();
+		retval = mxser_set_serial_info(info, argp);
+		unlock_kernel();
+		return retval;
@@ -1702 +1910 @@
-		return mxser_get_lsr_info(info, argp);
+		return  mxser_get_lsr_info(info, argp);
@@ -1748,0 +1957 @@
+		lock_kernel();
@@ -1750,0 +1960 @@
+		unlock_kernel();
@@ -1755,0 +1966 @@
+		lock_kernel();
@@ -1757 +1967,0 @@
-
@@ -1759 +1968,0 @@
-
@@ -1760,0 +1970 @@
+		unlock_kernel();
@@ -1766,0 +1977 @@
+		lock_kernel();
@@ -1785 +1996 @@
-
+		unlock_kernel();
@@ -1928 +2139,2 @@
-			DISABLE_MOXA_MUST_RX_SOFTWARE_FLOW_CONTROL(info->ioaddr);
+			mxser_disable_must_rx_software_flow_control(
+					info->ioaddr);
@@ -1981,0 +2194 @@
+	lock_kernel();
@@ -1992,0 +2206 @@
+	unlock_kernel();
@@ -2345 +2559 @@
-			ENABLE_MOXA_MUST_ENCHANCE_MODE(info->ioaddr);
+			mxser_enable_must_enchance_mode(info->ioaddr);
--- ./projects/linux/linux-2.6.26/drivers/char/mxser.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/char/mxser.c	2008-10-10 00:13:53.000000000 +0200
@@ -19 +18,0 @@
- *	- Fixed sleep with spinlock held in mxser_send_break
@@ -50 +49 @@
-#define	MXSER_VERSION	"2.0.3"		/* 1.11 */
+#define	MXSER_VERSION	"2.0.4"		/* 1.12 */
@@ -52 +50,0 @@
-#define	MXSERCUMAJOR	 175
@@ -59,5 +56,0 @@
-#define	MXSER_ERR_IOADDR	-1
-#define	MXSER_ERR_IRQ		-2
-#define	MXSER_ERR_IRQ_CONFLIT	-3
-#define	MXSER_ERR_VECTOR	-4
-
@@ -73,0 +67 @@
+#define PCI_DEVICE_ID_POS104UL	0x1044
@@ -74,0 +69 @@
+#define PCI_DEVICE_ID_CP102UF	0x1023
@@ -79 +73,0 @@
-#define PCI_DEVICE_ID_POS104UL	0x1044
@@ -145 +139,2 @@
-	{ "CP-114UL series",	4, }
+	{ "CP-114UL series",	4, },
+/*30*/	{ "CP-102UF series",	2, }
@@ -174,0 +170 @@
+	{ PCI_VDEVICE(MOXA, PCI_DEVICE_ID_CP102UF),	.driver_data = 30 },
@@ -179 +175 @@
-static int ioaddr[MXSER_BOARDS] = { 0, 0, 0, 0 };
+static unsigned long ioaddr[MXSER_BOARDS];
@@ -186 +182,2 @@
-module_param_array(ioaddr, int, NULL, 0);
+module_param_array(ioaddr, ulong, NULL, 0);
+MODULE_PARM_DESC(ioaddr, "ISA io addresses to look for a moxa board");
@@ -196 +192,0 @@
-
@@ -224,0 +221 @@
+	struct tty_port port;
@@ -226 +222,0 @@
-	struct tty_struct *tty;
@@ -237 +232,0 @@
-	int flags;		/* defined in tty.h */
@@ -247,2 +241,0 @@
-	int close_delay;
-	unsigned short closing_wait;
@@ -250 +242,0 @@
-	unsigned long event;
@@ -252,2 +243,0 @@
-	int count;		/* # of fd on device */
-	int blocked_open;	/* # of blocked opens */
@@ -260 +249,0 @@
-	unsigned char *xmit_buf;
@@ -270 +258,0 @@
-	wait_queue_head_t open_wait;
@@ -295,7 +282,0 @@
-static struct mxser_mstatus GMStatus[MXSER_PORTS];
-
-static int mxserBoardCAP[MXSER_BOARDS] = {
-	0, 0, 0, 0
-	/*  0x180, 0x280, 0x200, 0x320 */
-};
-
@@ -305,3 +285,0 @@
-static int mxvar_diagflag;
-static unsigned char mxser_msr[MXSER_PORTS + 1];
-static struct mxser_mon_ext mon_data_ext;
@@ -550,0 +529 @@
+	static unsigned char mxser_msr[MXSER_PORTS + 1];
@@ -578 +557 @@
-		port->flags |= ASYNC_NORMAL_ACTIVE;
+		port->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -588 +567 @@
-	 * this loop, port->count is dropped by one, so that
+	 * this loop, port->port.count is dropped by one, so that
@@ -593 +572 @@
-	add_wait_queue(&port->open_wait, &wait);
+	add_wait_queue(&port->port.open_wait, &wait);
@@ -597 +576 @@
-		port->count--;
+		port->port.count--;
@@ -599 +578 @@
-	port->blocked_open++;
+	port->port.blocked_open++;
@@ -606,2 +585,2 @@
-		if (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)) {
-			if (port->flags & ASYNC_HUP_NOTIFY)
+		if (tty_hung_up_p(filp) || !(port->port.flags & ASYNC_INITIALIZED)) {
+			if (port->port.flags & ASYNC_HUP_NOTIFY)
@@ -613 +592 @@
-		if (!(port->flags & ASYNC_CLOSING) &&
+		if (!(port->port.flags & ASYNC_CLOSING) &&
@@ -624 +603 @@
-	remove_wait_queue(&port->open_wait, &wait);
+	remove_wait_queue(&port->port.open_wait, &wait);
@@ -626,2 +605,2 @@
-		port->count++;
-	port->blocked_open--;
+		port->port.count++;
+	port->port.blocked_open--;
@@ -630 +609 @@
-	port->flags |= ASYNC_NORMAL_ACTIVE;
+	port->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -639 +618 @@
-	if (!info->tty || !info->tty->termios)
+	if (!info->port.tty || !info->port.tty->termios)
@@ -650 +629 @@
-		tty_encode_baud_rate(info->tty, 134, 134);
+		tty_encode_baud_rate(info->port.tty, 134, 134);
@@ -656 +635 @@
-		tty_encode_baud_rate(info->tty, baud, baud);
+		tty_encode_baud_rate(info->port.tty, baud, baud);
@@ -682 +661 @@
-	if (C_BAUD(info->tty) == BOTHER) {
+	if (C_BAUD(info->port.tty) == BOTHER) {
@@ -710 +689 @@
-	if (!info->tty || !info->tty->termios)
+	if (!info->port.tty || !info->port.tty->termios)
@@ -712 +691 @@
-	cflag = info->tty->termios->c_cflag;
+	cflag = info->port.tty->termios->c_cflag;
@@ -716,2 +695,2 @@
-	if (mxser_set_baud_method[info->tty->index] == 0)
-		mxser_set_baud(info, tty_get_baud_rate(info->tty));
+	if (mxser_set_baud_method[info->port.tty->index] == 0)
+		mxser_set_baud(info, tty_get_baud_rate(info->port.tty));
@@ -780 +759 @@
-		info->flags |= ASYNC_CTS_FLOW;
+		info->port.flags |= ASYNC_CTS_FLOW;
@@ -786 +765 @@
-			if (info->tty->hw_stopped) {
+			if (info->port.tty->hw_stopped) {
@@ -788 +767 @@
-					info->tty->hw_stopped = 0;
+					info->port.tty->hw_stopped = 0;
@@ -798 +777 @@
-					tty_wakeup(info->tty);
+					tty_wakeup(info->port.tty);
@@ -802 +781 @@
-					info->tty->hw_stopped = 1;
+					info->port.tty->hw_stopped = 1;
@@ -813 +792 @@
-		info->flags &= ~ASYNC_CTS_FLOW;
+		info->port.flags &= ~ASYNC_CTS_FLOW;
@@ -817 +796 @@
-		info->flags &= ~ASYNC_CHECK_CD;
+		info->port.flags &= ~ASYNC_CHECK_CD;
@@ -819 +798 @@
-		info->flags |= ASYNC_CHECK_CD;
+		info->port.flags |= ASYNC_CHECK_CD;
@@ -828 +807 @@
-	if (I_INPCK(info->tty))
+	if (I_INPCK(info->port.tty))
@@ -830 +809 @@
-	if (I_BRKINT(info->tty) || I_PARMRK(info->tty))
+	if (I_BRKINT(info->port.tty) || I_PARMRK(info->port.tty))
@@ -835 +814 @@
-	if (I_IGNBRK(info->tty)) {
+	if (I_IGNBRK(info->port.tty)) {
@@ -842 +821 @@
-		if (I_IGNPAR(info->tty)) {
+		if (I_IGNPAR(info->port.tty)) {
@@ -854,3 +833,3 @@
-		mxser_set_must_xon1_value(info->ioaddr, START_CHAR(info->tty));
-		mxser_set_must_xoff1_value(info->ioaddr, STOP_CHAR(info->tty));
-		if (I_IXON(info->tty)) {
+		mxser_set_must_xon1_value(info->ioaddr, START_CHAR(info->port.tty));
+		mxser_set_must_xoff1_value(info->ioaddr, STOP_CHAR(info->port.tty));
+		if (I_IXON(info->port.tty)) {
@@ -863 +842 @@
-		if (I_IXOFF(info->tty)) {
+		if (I_IXOFF(info->port.tty)) {
@@ -893 +872 @@
-	if ((port->flags & ASYNC_CHECK_CD) && (status & UART_MSR_DDCD)) {
+	if ((port->port.flags & ASYNC_CHECK_CD) && (status & UART_MSR_DDCD)) {
@@ -895 +874 @@
-			wake_up_interruptible(&port->open_wait);
+			wake_up_interruptible(&port->port.open_wait);
@@ -898,2 +877,2 @@
-	if (port->flags & ASYNC_CTS_FLOW) {
-		if (port->tty->hw_stopped) {
+	if (port->port.flags & ASYNC_CTS_FLOW) {
+		if (port->port.tty->hw_stopped) {
@@ -901 +880 @@
-				port->tty->hw_stopped = 0;
+				port->port.tty->hw_stopped = 0;
@@ -911 +890 @@
-				tty_wakeup(port->tty);
+				tty_wakeup(port->port.tty);
@@ -915 +894 @@
-				port->tty->hw_stopped = 1;
+				port->port.tty->hw_stopped = 1;
@@ -938 +917 @@
-	if (info->flags & ASYNC_INITIALIZED) {
+	if (info->port.flags & ASYNC_INITIALIZED) {
@@ -945,2 +924,2 @@
-		if (info->tty)
-			set_bit(TTY_IO_ERROR, &info->tty->flags);
+		if (info->port.tty)
+			set_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -951 +930 @@
-	if (info->xmit_buf)
+	if (info->port.xmit_buf)
@@ -954 +933 @@
-		info->xmit_buf = (unsigned char *) page;
+		info->port.xmit_buf = (unsigned char *) page;
@@ -976,2 +955,2 @@
-			if (info->tty)
-				set_bit(TTY_IO_ERROR, &info->tty->flags);
+			if (info->port.tty)
+				set_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -1015,2 +994,2 @@
-	if (info->tty)
-		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->port.tty)
+		clear_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -1023 +1002 @@
-	info->flags |= ASYNC_INITIALIZED;
+	info->port.flags |= ASYNC_INITIALIZED;
@@ -1037 +1016 @@
-	if (!(info->flags & ASYNC_INITIALIZED))
+	if (!(info->port.flags & ASYNC_INITIALIZED))
@@ -1051,3 +1030,3 @@
-	if (info->xmit_buf) {
-		free_page((unsigned long) info->xmit_buf);
-		info->xmit_buf = NULL;
+	if (info->port.xmit_buf) {
+		free_page((unsigned long) info->port.xmit_buf);
+		info->port.xmit_buf = NULL;
@@ -1059 +1038 @@
-	if (!info->tty || (info->tty->termios->c_cflag & HUPCL))
+	if (!info->port.tty || (info->port.tty->termios->c_cflag & HUPCL))
@@ -1075,2 +1054,2 @@
-	if (info->tty)
-		set_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->port.tty)
+		set_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -1078 +1057 @@
-	info->flags &= ~ASYNC_INITIALIZED;
+	info->port.flags &= ~ASYNC_INITIALIZED;
@@ -1108 +1087 @@
-	info->tty = tty;
+	info->port.tty = tty;
@@ -1113 +1092 @@
-	info->count++;
+	info->port.count++;
@@ -1173 +1152 @@
-	if ((tty->count == 1) && (info->count != 1)) {
+	if ((tty->count == 1) && (info->port.count != 1)) {
@@ -1176 +1155 @@
-		 * structure will be freed.  Info->count should always
+		 * structure will be freed.  Info->port.count should always
@@ -1182,2 +1161,2 @@
-			"tty->count is 1, info->count is %d\n", info->count);
-		info->count = 1;
+			"tty->count is 1, info->port.count is %d\n", info->port.count);
+		info->port.count = 1;
@@ -1185 +1164 @@
-	if (--info->count < 0) {
+	if (--info->port.count < 0) {
@@ -1187,2 +1166,2 @@
-			"ttys%d: %d\n", tty->index, info->count);
-		info->count = 0;
+			"ttys%d: %d\n", tty->index, info->port.count);
+		info->port.count = 0;
@@ -1190 +1169 @@
-	if (info->count) {
+	if (info->port.count) {
@@ -1194 +1173 @@
-	info->flags |= ASYNC_CLOSING;
+	info->port.flags |= ASYNC_CLOSING;
@@ -1200 +1179 @@
-	if (info->flags & ASYNC_NORMAL_ACTIVE)
+	if (info->port.flags & ASYNC_NORMAL_ACTIVE)
@@ -1207,2 +1186,2 @@
-	if (info->closing_wait != ASYNC_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, info->closing_wait);
+	if (info->port.closing_wait != ASYNC_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, info->port.closing_wait);
@@ -1219 +1198 @@
-	if (info->flags & ASYNC_INITIALIZED) {
+	if (info->port.flags & ASYNC_INITIALIZED) {
@@ -1239,6 +1218,5 @@
-	info->event = 0;
-	info->tty = NULL;
-	if (info->blocked_open) {
-		if (info->close_delay)
-			schedule_timeout_interruptible(info->close_delay);
-		wake_up_interruptible(&info->open_wait);
+	info->port.tty = NULL;
+	if (info->port.blocked_open) {
+		if (info->port.close_delay)
+			schedule_timeout_interruptible(info->port.close_delay);
+		wake_up_interruptible(&info->port.open_wait);
@@ -1247 +1225 @@
-	info->flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
+	info->port.flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
@@ -1256 +1234 @@
-	if (!info->xmit_buf)
+	if (!info->port.xmit_buf)
@@ -1265 +1243 @@
-		memcpy(info->xmit_buf + info->xmit_head, buf, c);
+		memcpy(info->port.xmit_buf + info->xmit_head, buf, c);
@@ -1297 +1275 @@
-	if (!info->xmit_buf)
+	if (!info->port.xmit_buf)
@@ -1304 +1282 @@
-	info->xmit_buf[info->xmit_head++] = ch;
+	info->port.xmit_buf[info->xmit_head++] = ch;
@@ -1328,7 +1306,3 @@
-	if (info->xmit_cnt <= 0 ||
-			tty->stopped ||
-			!info->xmit_buf ||
-			(tty->hw_stopped &&
-			 (info->type != PORT_16550A) &&
-			 (!info->board->chip_flag)
-			))
+	if (info->xmit_cnt <= 0 || tty->stopped || !info->port.xmit_buf ||
+			(tty->hw_stopped && info->type != PORT_16550A &&
+			 !info->board->chip_flag))
@@ -1352,3 +1326 @@
-	if (ret < 0)
-		ret = 0;
-	return ret;
+	return ret < 0 ? 0 : ret;
@@ -1373 +1345 @@
-		.line = info->tty->index,
+		.line = info->port.tty->index,
@@ -1376 +1348 @@
-		.flags = info->flags,
+		.flags = info->port.flags,
@@ -1378,2 +1350,2 @@
-		.close_delay = info->close_delay,
-		.closing_wait = info->closing_wait,
+		.close_delay = info->port.close_delay,
+		.closing_wait = info->port.closing_wait,
@@ -1406 +1378 @@
-	flags = info->flags & ASYNC_SPD_MASK;
+	flags = info->port.flags & ASYNC_SPD_MASK;
@@ -1410,2 +1382,2 @@
-				(new_serial.close_delay != info->close_delay) ||
-				((new_serial.flags & ~ASYNC_USR_MASK) != (info->flags & ~ASYNC_USR_MASK)))
+				(new_serial.close_delay != info->port.close_delay) ||
+				((new_serial.flags & ~ASYNC_USR_MASK) != (info->port.flags & ~ASYNC_USR_MASK)))
@@ -1413 +1385 @@
-		info->flags = ((info->flags & ~ASYNC_USR_MASK) |
+		info->port.flags = ((info->port.flags & ~ASYNC_USR_MASK) |
@@ -1420 +1392 @@
-		info->flags = ((info->flags & ~ASYNC_FLAGS) |
+		info->port.flags = ((info->port.flags & ~ASYNC_FLAGS) |
@@ -1422,6 +1394,5 @@
-		info->close_delay = new_serial.close_delay * HZ / 100;
-		info->closing_wait = new_serial.closing_wait * HZ / 100;
-		info->tty->low_latency =
-				(info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
-		info->tty->low_latency = 0;
-		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST &&
+		info->port.close_delay = new_serial.close_delay * HZ / 100;
+		info->port.closing_wait = new_serial.closing_wait * HZ / 100;
+		info->port.tty->low_latency =
+				(info->port.flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+		if ((info->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_CUST &&
@@ -1432 +1403 @@
-			tty_encode_baud_rate(info->tty, baud, baud);
+			tty_encode_baud_rate(info->port.tty, baud, baud);
@@ -1440,2 +1411,2 @@
-	if (info->flags & ASYNC_INITIALIZED) {
-		if (flags != (info->flags & ASYNC_SPD_MASK)) {
+	if (info->port.flags & ASYNC_INITIALIZED) {
+		if (flags != (info->port.flags & ASYNC_SPD_MASK)) {
@@ -1476,21 +1446,0 @@
-/*
- * This routine sends a break character out the serial port.
- */
-static void mxser_send_break(struct mxser_port *info, int duration)
-{
-	unsigned long flags;
-
-	if (!info->ioaddr)
-		return;
-	set_current_state(TASK_INTERRUPTIBLE);
-	spin_lock_irqsave(&info->slock, flags);
-	outb(inb(info->ioaddr + UART_LCR) | UART_LCR_SBC,
-		info->ioaddr + UART_LCR);
-	spin_unlock_irqrestore(&info->slock, flags);
-	schedule_timeout(duration);
-	spin_lock_irqsave(&info->slock, flags);
-	outb(inb(info->ioaddr + UART_LCR) & ~UART_LCR_SBC,
-		info->ioaddr + UART_LCR);
-	spin_unlock_irqrestore(&info->slock, flags);
-}
-
@@ -1664,0 +1615,4 @@
+		if (printk_ratelimit())
+			printk(KERN_WARNING "mxser: '%s' uses deprecated ioctl "
+					"%x (GET_MAJOR), fix your userspace\n",
+					current->comm, cmd);
@@ -1682 +1636,2 @@
-	case MOXA_GETMSTATUS:
+	case MOXA_GETMSTATUS: {
+		struct mxser_mstatus ms, __user *msu = argp;
@@ -1686,0 +1642 @@
+				memset(&ms, 0, sizeof(ms));
@@ -1688,7 +1644,2 @@
-				GMStatus[i].ri = 0;
-				if (!port->ioaddr) {
-					GMStatus[i].dcd = 0;
-					GMStatus[i].dsr = 0;
-					GMStatus[i].cts = 0;
-					continue;
-				}
+				if (!port->ioaddr)
+					goto copy;
@@ -1696,3 +1647,2 @@
-				if (!port->tty || !port->tty->termios)
-					GMStatus[i].cflag =
-						port->normal_termios.c_cflag;
+				if (!port->port.tty || !port->port.tty->termios)
+					ms.cflag = port->normal_termios.c_cflag;
@@ -1700,2 +1650 @@
-					GMStatus[i].cflag =
-						port->tty->termios->c_cflag;
+					ms.cflag = port->port.tty->termios->c_cflag;
@@ -1704,15 +1653,12 @@
-				if (status & 0x80 /*UART_MSR_DCD */ )
-					GMStatus[i].dcd = 1;
-				else
-					GMStatus[i].dcd = 0;
-
-				if (status & 0x20 /*UART_MSR_DSR */ )
-					GMStatus[i].dsr = 1;
-				else
-					GMStatus[i].dsr = 0;
-
-
-				if (status & 0x10 /*UART_MSR_CTS */ )
-					GMStatus[i].cts = 1;
-				else
-					GMStatus[i].cts = 0;
+				if (status & UART_MSR_DCD)
+					ms.dcd = 1;
+				if (status & UART_MSR_DSR)
+					ms.dsr = 1;
+				if (status & UART_MSR_CTS)
+					ms.cts = 1;
+			copy:
+				if (copy_to_user(msu, &ms, sizeof(ms))) {
+					unlock_kernel();
+					return -EFAULT;
+				}
+				msu++;
@@ -1721,3 +1666,0 @@
-		if (copy_to_user(argp, GMStatus,
-				sizeof(struct mxser_mstatus) * MXSER_PORTS))
-			return -EFAULT;
@@ -1724,0 +1668 @@
+	}
@@ -1726,3 +1670,7 @@
-		int p, shiftbit;
-		unsigned long opmode;
-		unsigned cflag, iflag;
+		struct mxser_mon_ext *me; /* it's 2k, stack unfriendly */
+		unsigned int cflag, iflag, p;
+		u8 opmode;
+
+		me = kzalloc(sizeof(*me), GFP_KERNEL);
+		if (!me)
+			return -ENOMEM;
@@ -1731,2 +1679,6 @@
-		for (i = 0; i < MXSER_BOARDS; i++) {
-			for (j = 0; j < MXSER_PORTS_PER_BOARD; j++) {
+		for (i = 0, p = 0; i < MXSER_BOARDS; i++) {
+			for (j = 0; j < MXSER_PORTS_PER_BOARD; j++, p++) {
+				if (p >= ARRAY_SIZE(me->rx_cnt)) {
+					i = MXSER_BOARDS;
+					break;
+				}
@@ -1737 +1689 @@
-				status = mxser_get_msr(port->ioaddr, 0, i);
+				status = mxser_get_msr(port->ioaddr, 0, p);
@@ -1749,7 +1701,5 @@
-				mon_data_ext.rx_cnt[i] = port->mon_data.rxcnt;
-				mon_data_ext.tx_cnt[i] = port->mon_data.txcnt;
-				mon_data_ext.up_rxcnt[i] =
-					port->mon_data.up_rxcnt;
-				mon_data_ext.up_txcnt[i] =
-					port->mon_data.up_txcnt;
-				mon_data_ext.modem_status[i] =
+				me->rx_cnt[p] = port->mon_data.rxcnt;
+				me->tx_cnt[p] = port->mon_data.txcnt;
+				me->up_rxcnt[p] = port->mon_data.up_rxcnt;
+				me->up_txcnt[p] = port->mon_data.up_txcnt;
+				me->modem_status[p] =
@@ -1757,2 +1707 @@
-				mon_data_ext.baudrate[i] =
-					tty_get_baud_rate(port->tty);
+				me->baudrate[p] = tty_get_baud_rate(port->port.tty);
@@ -1760 +1709 @@
-				if (!port->tty || !port->tty->termios) {
+				if (!port->port.tty || !port->port.tty->termios) {
@@ -1764,2 +1713,2 @@
-					cflag = port->tty->termios->c_cflag;
-					iflag = port->tty->termios->c_iflag;
+					cflag = port->port.tty->termios->c_cflag;
+					iflag = port->port.tty->termios->c_iflag;
@@ -1768,8 +1717,4 @@
-				mon_data_ext.databits[i] = cflag & CSIZE;
-
-				mon_data_ext.stopbits[i] = cflag & CSTOPB;
-
-				mon_data_ext.parity[i] =
-					cflag & (PARENB | PARODD | CMSPAR);
-
-				mon_data_ext.flowctrl[i] = 0x00;
+				me->databits[p] = cflag & CSIZE;
+				me->stopbits[p] = cflag & CSTOPB;
+				me->parity[p] = cflag & (PARENB | PARODD |
+						CMSPAR);
@@ -1778 +1723 @@
-					mon_data_ext.flowctrl[i] |= 0x03;
+					me->flowctrl[p] |= 0x03;
@@ -1781 +1726 @@
-					mon_data_ext.flowctrl[i] |= 0x0C;
+					me->flowctrl[p] |= 0x0C;
@@ -1784,3 +1729 @@
-					mon_data_ext.fifo[i] = 1;
-				else
-					mon_data_ext.fifo[i] = 0;
+					me->fifo[p] = 1;
@@ -1788,3 +1731,2 @@
-				p = i % 4;
-				shiftbit = p * 2;
-				opmode = inb(port->opmode_ioaddr) >> shiftbit;
+				opmode = inb(port->opmode_ioaddr) >>
+						((p % 4) * 2);
@@ -1792,3 +1734 @@
-
-				mon_data_ext.iftype[i] = opmode;
-
+				me->iftype[p] = opmode;
@@ -1798,4 +1738,4 @@
-		if (copy_to_user(argp, &mon_data_ext,
-					sizeof(mon_data_ext)))
-			return -EFAULT;
-		return 0;
+		if (copy_to_user(argp, me, sizeof(*me)))
+			ret = -EFAULT;
+		kfree(me);
+		return ret;
@@ -1835 +1774,0 @@
-	struct serial_icounter_struct __user *p_cuser;
@@ -1884,15 +1822,0 @@
-	case TCSBRK:		/* SVID version: non-zero arg --> no break */
-		retval = tty_check_change(tty);
-		if (retval)
-			return retval;
-		tty_wait_until_sent(tty, 0);
-		if (!arg)
-			mxser_send_break(info, HZ / 4);	/* 1/4 second */
-		return 0;
-	case TCSBRKP:		/* support for POSIX tcsendbreak() */
-		retval = tty_check_change(tty);
-		if (retval)
-			return retval;
-		tty_wait_until_sent(tty, 0);
-		mxser_send_break(info, arg ? arg * (HZ / 10) : HZ / 4);
-		return 0;
@@ -1930 +1854,2 @@
-	case TIOCGICOUNT:
+	case TIOCGICOUNT: {
+		struct serial_icounter_struct icnt = { 0 };
@@ -1934,20 +1859,15 @@
-		p_cuser = argp;
-		if (put_user(cnow.frame, &p_cuser->frame))
-			return -EFAULT;
-		if (put_user(cnow.brk, &p_cuser->brk))
-			return -EFAULT;
-		if (put_user(cnow.overrun, &p_cuser->overrun))
-			return -EFAULT;
-		if (put_user(cnow.buf_overrun, &p_cuser->buf_overrun))
-			return -EFAULT;
-		if (put_user(cnow.parity, &p_cuser->parity))
-			return -EFAULT;
-		if (put_user(cnow.rx, &p_cuser->rx))
-			return -EFAULT;
-		if (put_user(cnow.tx, &p_cuser->tx))
-			return -EFAULT;
-		put_user(cnow.cts, &p_cuser->cts);
-		put_user(cnow.dsr, &p_cuser->dsr);
-		put_user(cnow.rng, &p_cuser->rng);
-		put_user(cnow.dcd, &p_cuser->dcd);
-		return 0;
+
+		icnt.frame = cnow.frame;
+		icnt.brk = cnow.brk;
+		icnt.overrun = cnow.overrun;
+		icnt.buf_overrun = cnow.buf_overrun;
+		icnt.parity = cnow.parity;
+		icnt.rx = cnow.rx;
+		icnt.tx = cnow.tx;
+		icnt.cts = cnow.cts;
+		icnt.dsr = cnow.dsr;
+		icnt.rng = cnow.rng;
+		icnt.dcd = cnow.dcd;
+
+		return copy_to_user(argp, &icnt, sizeof(icnt)) ? -EFAULT : 0;
+	}
@@ -1992 +1912 @@
-		if (info->tty->hw_stopped)
+		if (info->port.tty->hw_stopped)
@@ -2041 +1961 @@
-	if (info->tty->termios->c_cflag & CRTSCTS) {
+	if (info->port.tty->termios->c_cflag & CRTSCTS) {
@@ -2078 +1998 @@
-	if (info->tty->termios->c_cflag & CRTSCTS) {
+	if (info->port.tty->termios->c_cflag & CRTSCTS) {
@@ -2109 +2029 @@
-	if (info->xmit_cnt && info->xmit_buf) {
+	if (info->xmit_cnt && info->port.xmit_buf) {
@@ -2222,5 +2142,4 @@
-	info->event = 0;
-	info->count = 0;
-	info->flags &= ~ASYNC_NORMAL_ACTIVE;
-	info->tty = NULL;
-	wake_up_interruptible(&info->open_wait);
+	info->port.count = 0;
+	info->port.flags &= ~ASYNC_NORMAL_ACTIVE;
+	info->port.tty = NULL;
+	wake_up_interruptible(&info->port.open_wait);
@@ -2232 +2151 @@
-static void mxser_rs_break(struct tty_struct *tty, int break_state)
+static int mxser_rs_break(struct tty_struct *tty, int break_state)
@@ -2244,0 +2164 @@
+	return 0;
@@ -2249 +2169 @@
-	struct tty_struct *tty = port->tty;
+	struct tty_struct *tty = port->port.tty;
@@ -2305 +2225 @@
-					if (port->flags & ASYNC_SAK)
+					if (port->port.flags & ASYNC_SAK)
@@ -2336 +2256 @@
-	mxvar_log.rxcnt[port->tty->index] += cnt;
+	mxvar_log.rxcnt[port->port.tty->index] += cnt;
@@ -2357 +2277 @@
-		mxvar_log.txcnt[port->tty->index]++;
+		mxvar_log.txcnt[port->port.tty->index]++;
@@ -2364 +2284 @@
-	if (port->xmit_buf == NULL)
+	if (port->port.xmit_buf == NULL)
@@ -2367,2 +2287,2 @@
-	if ((port->xmit_cnt <= 0) || port->tty->stopped ||
-			(port->tty->hw_stopped &&
+	if ((port->xmit_cnt <= 0) || port->port.tty->stopped ||
+			(port->port.tty->hw_stopped &&
@@ -2379 +2299 @@
-		outb(port->xmit_buf[port->xmit_tail++],
+		outb(port->port.xmit_buf[port->xmit_tail++],
@@ -2385 +2305 @@
-	mxvar_log.txcnt[port->tty->index] += (cnt - port->xmit_cnt);
+	mxvar_log.txcnt[port->port.tty->index] += (cnt - port->xmit_cnt);
@@ -2392 +2312 @@
-		tty_wakeup(port->tty);
+		tty_wakeup(port->port.tty);
@@ -2443,3 +2363,3 @@
-				if (!port->tty ||
-						(port->flags & ASYNC_CLOSING) ||
-						!(port->flags &
+				if (!port->port.tty ||
+						(port->port.flags & ASYNC_CLOSING) ||
+						!(port->port.flags &
@@ -2549 +2469,2 @@
-	printk(KERN_INFO "max. baud rate = %d bps.\n", brd->ports[0].max_baud);
+	printk(KERN_INFO "mxser: max. baud rate = %d bps\n",
+			brd->ports[0].max_baud);
@@ -2552,0 +2474 @@
+		tty_port_init(&info->port);
@@ -2561 +2483 @@
-		info->flags = ASYNC_SHARE_IRQ;
+		info->port.flags = ASYNC_SHARE_IRQ;
@@ -2567,2 +2489,2 @@
-		info->close_delay = 5 * HZ / 10;
-		info->closing_wait = 30 * HZ;
+		info->port.close_delay = 5 * HZ / 10;
+		info->port.closing_wait = 30 * HZ;
@@ -2570 +2491,0 @@
-		init_waitqueue_head(&info->open_wait);
@@ -2632 +2553 @@
-			return MXSER_ERR_IRQ_CONFLIT;
+			goto err_irqconflict;
@@ -2638 +2559 @@
-			return MXSER_ERR_IRQ_CONFLIT;
+			goto err_irqconflict;
@@ -2644 +2565 @@
-			return MXSER_ERR_IRQ_CONFLIT;
+			goto err_irqconflict;
@@ -2647,2 +2568,4 @@
-	if (!irq)
-		return MXSER_ERR_IRQ;
+	if (!irq) {
+		printk(KERN_ERR "mxser: interrupt number unset\n");
+		return -EIO;
+	}
@@ -2652,2 +2575,4 @@
-	if ((regs[12] & 0x80) == 0)
-		return MXSER_ERR_VECTOR;
+	if ((regs[12] & 0x80) == 0) {
+		printk(KERN_ERR "mxser: invalid interrupt vector\n");
+		return -EIO;
+	}
@@ -2680,2 +2605,7 @@
-			"mxser(IO)"))
-		return MXSER_ERR_IOADDR;
+			"mxser(IO)")) {
+		printk(KERN_ERR "mxser: can't request ports I/O region: "
+				"0x%.8lx-0x%.8lx\n",
+				brd->ports[0].ioaddr, brd->ports[0].ioaddr +
+				8 * brd->info->nports - 1);
+		return -EIO;
+	}
@@ -2684 +2614,5 @@
-		return MXSER_ERR_VECTOR;
+		printk(KERN_ERR "mxser: can't request interrupt vector region: "
+				"0x%.8lx-0x%.8lx\n",
+				brd->ports[0].ioaddr, brd->ports[0].ioaddr +
+				8 * brd->info->nports - 1);
+		return -EIO;
@@ -2686,0 +2621,4 @@
+
+err_irqconflict:
+	printk(KERN_ERR "mxser: invalid interrupt number\n");
+	return -EIO;
@@ -2703,2 +2641,2 @@
-		printk(KERN_ERR "Too many Smartio/Industio family boards found "
-			"(maximum %d), board not configured\n", MXSER_BOARDS);
+		dev_err(&pdev->dev, "too many boards found (maximum %d), board "
+				"not configured\n", MXSER_BOARDS);
@@ -2710 +2648 @@
-	printk(KERN_INFO "Found MOXA %s board (BusNo=%d, DevNo=%d)\n",
+	dev_info(&pdev->dev, "found MOXA %s board (BusNo=%d, DevNo=%d)\n",
@@ -2716 +2654 @@
-		printk(KERN_ERR "Moxa SmartI/O PCI enable fail !\n");
+		dev_err(&pdev->dev, "PCI enable failed\n");
@@ -2818,5 +2756,2 @@
-	unsigned long cap;
-	unsigned int i, m, isaloop;
-	int retval, b;
-
-	pr_debug("Loading module mxser ...\n");
+	unsigned int b, i, m;
+	int retval;
@@ -2852,3 +2786,0 @@
-	mxvar_diagflag = 0;
-
-	m = 0;
@@ -2856,9 +2788,3 @@
-	for (isaloop = 0; isaloop < 2; isaloop++)
-		for (b = 0; b < MXSER_BOARDS && m < MXSER_BOARDS; b++) {
-			if (!isaloop)
-				cap = mxserBoardCAP[b]; /* predefined */
-			else
-				cap = ioaddr[b]; /* module param */
-
-			if (!cap)
-				continue;
+	for (m = 0, b = 0; b < MXSER_BOARDS; b++) {
+		if (!ioaddr[b])
+			continue;
@@ -2866,2 +2792,6 @@
-			brd = &mxser_boards[m];
-			retval = mxser_get_ISA_conf(cap, brd);
+		brd = &mxser_boards[m];
+		retval = mxser_get_ISA_conf(!ioaddr[b], brd);
+		if (retval <= 0) {
+			brd->info = NULL;
+			continue;
+		}
@@ -2869,21 +2799,2 @@
-			if (retval != 0)
-				printk(KERN_INFO "Found MOXA %s board "
-					"(CAP=0x%x)\n",
-					brd->info->name, ioaddr[b]);
-
-			if (retval <= 0) {
-				if (retval == MXSER_ERR_IRQ)
-					printk(KERN_ERR "Invalid interrupt "
-						"number, board not "
-						"configured\n");
-				else if (retval == MXSER_ERR_IRQ_CONFLIT)
-					printk(KERN_ERR "Invalid interrupt "
-						"number, board not "
-						"configured\n");
-				else if (retval == MXSER_ERR_VECTOR)
-					printk(KERN_ERR "Invalid interrupt "
-						"vector, board not "
-						"configured\n");
-				else if (retval == MXSER_ERR_IOADDR)
-					printk(KERN_ERR "Invalid I/O address, "
-						"board not configured\n");
+		printk(KERN_INFO "mxser: found MOXA %s board (CAP=0x%lx)\n",
+				brd->info->name, ioaddr[b]);
@@ -2891,9 +2802,5 @@
-				brd->info = NULL;
-				continue;
-			}
-
-			/* mxser_initbrd will hook ISR. */
-			if (mxser_initbrd(brd, NULL) < 0) {
-				brd->info = NULL;
-				continue;
-			}
+		/* mxser_initbrd will hook ISR. */
+		if (mxser_initbrd(brd, NULL) < 0) {
+			brd->info = NULL;
+			continue;
+		}
@@ -2901,4 +2808,3 @@
-			brd->idx = m * MXSER_PORTS_PER_BOARD;
-			for (i = 0; i < brd->info->nports; i++)
-				tty_register_device(mxvar_sdriver, brd->idx + i,
-						NULL);
+		brd->idx = m * MXSER_PORTS_PER_BOARD;
+		for (i = 0; i < brd->info->nports; i++)
+			tty_register_device(mxvar_sdriver, brd->idx + i, NULL);
@@ -2906,2 +2812,2 @@
-			m++;
-		}
+		m++;
+	}
@@ -2911 +2817 @@
-		printk(KERN_ERR "Can't register pci driver\n");
+		printk(KERN_ERR "mxser: can't register pci driver\n");
@@ -2918,2 +2823,0 @@
-	pr_debug("Done.\n");
-
@@ -2932,2 +2835,0 @@
-	pr_debug("Unloading module mxser ...\n");
-
@@ -2947,2 +2848,0 @@
-
-	pr_debug("Done.\n");
--- ./projects/linux/linux-2.6.27/drivers/char/mxser.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/char/mxser.c	2008-12-25 00:26:37.000000000 +0100
@@ -17 +17,2 @@
- *	<alan@redhat.com>. The original 1.8 code is available on www.moxa.com.
+ *	<alan@lxorguk.ukuu.org.uk>. The original 1.8 code is available on
+ *	www.moxa.com.
@@ -613 +614 @@
-static int mxser_set_baud(struct mxser_port *info, long newspd)
+static int mxser_set_baud(struct tty_struct *tty, long newspd)
@@ -614,0 +616 @@
+	struct mxser_port *info = tty->driver_data;
@@ -618,4 +620 @@
-	if (!info->port.tty || !info->port.tty->termios)
-		return -1;
-
-	if (!(info->ioaddr))
+	if (!info->ioaddr)
@@ -629 +628 @@
-		tty_encode_baud_rate(info->port.tty, 134, 134);
+		tty_encode_baud_rate(tty, 134, 134);
@@ -635 +634 @@
-		tty_encode_baud_rate(info->port.tty, baud, baud);
+		tty_encode_baud_rate(tty, baud, baud);
@@ -661 +660 @@
-	if (C_BAUD(info->port.tty) == BOTHER) {
+	if (C_BAUD(tty) == BOTHER) {
@@ -682,2 +681,2 @@
-static int mxser_change_speed(struct mxser_port *info,
-		struct ktermios *old_termios)
+static int mxser_change_speed(struct tty_struct *tty,
+					struct ktermios *old_termios)
@@ -684,0 +684 @@
+	struct mxser_port *info = tty->driver_data;
@@ -689,4 +689,2 @@
-	if (!info->port.tty || !info->port.tty->termios)
-		return ret;
-	cflag = info->port.tty->termios->c_cflag;
-	if (!(info->ioaddr))
+	cflag = tty->termios->c_cflag;
+	if (!info->ioaddr)
@@ -695,2 +693,2 @@
-	if (mxser_set_baud_method[info->port.tty->index] == 0)
-		mxser_set_baud(info, tty_get_baud_rate(info->port.tty));
+	if (mxser_set_baud_method[tty->index] == 0)
+		mxser_set_baud(tty, tty_get_baud_rate(tty));
@@ -765 +763 @@
-			if (info->port.tty->hw_stopped) {
+			if (tty->hw_stopped) {
@@ -767 +765 @@
-					info->port.tty->hw_stopped = 0;
+					tty->hw_stopped = 0;
@@ -777 +775 @@
-					tty_wakeup(info->port.tty);
+					tty_wakeup(tty);
@@ -781 +779 @@
-					info->port.tty->hw_stopped = 1;
+					tty->hw_stopped = 1;
@@ -807 +805 @@
-	if (I_INPCK(info->port.tty))
+	if (I_INPCK(tty))
@@ -809 +807 @@
-	if (I_BRKINT(info->port.tty) || I_PARMRK(info->port.tty))
+	if (I_BRKINT(tty) || I_PARMRK(tty))
@@ -814 +812 @@
-	if (I_IGNBRK(info->port.tty)) {
+	if (I_IGNBRK(tty)) {
@@ -821 +819 @@
-		if (I_IGNPAR(info->port.tty)) {
+		if (I_IGNPAR(tty)) {
@@ -833,3 +831,3 @@
-		mxser_set_must_xon1_value(info->ioaddr, START_CHAR(info->port.tty));
-		mxser_set_must_xoff1_value(info->ioaddr, STOP_CHAR(info->port.tty));
-		if (I_IXON(info->port.tty)) {
+		mxser_set_must_xon1_value(info->ioaddr, START_CHAR(tty));
+		mxser_set_must_xoff1_value(info->ioaddr, STOP_CHAR(tty));
+		if (I_IXON(tty)) {
@@ -842 +840 @@
-		if (I_IXOFF(info->port.tty)) {
+		if (I_IXOFF(tty)) {
@@ -858 +856,2 @@
-static void mxser_check_modem_status(struct mxser_port *port, int status)
+static void mxser_check_modem_status(struct tty_struct *tty,
+				struct mxser_port *port, int status)
@@ -876,0 +876 @@
+	tty = tty_port_tty_get(&port->port);
@@ -878 +878 @@
-		if (port->port.tty->hw_stopped) {
+		if (tty->hw_stopped) {
@@ -880 +880 @@
-				port->port.tty->hw_stopped = 0;
+				tty->hw_stopped = 0;
@@ -890 +890 @@
-				tty_wakeup(port->port.tty);
+				tty_wakeup(tty);
@@ -894 +894 @@
-				port->port.tty->hw_stopped = 1;
+				tty->hw_stopped = 1;
@@ -906 +906 @@
-static int mxser_startup(struct mxser_port *info)
+static int mxser_startup(struct tty_struct *tty)
@@ -907,0 +908 @@
+	struct mxser_port *info = tty->driver_data;
@@ -924,2 +925 @@
-		if (info->port.tty)
-			set_bit(TTY_IO_ERROR, &info->port.tty->flags);
+		set_bit(TTY_IO_ERROR, &tty->flags);
@@ -955,2 +955,2 @@
-			if (info->port.tty)
-				set_bit(TTY_IO_ERROR, &info->port.tty->flags);
+			if (tty)
+				set_bit(TTY_IO_ERROR, &tty->flags);
@@ -994,2 +994 @@
-	if (info->port.tty)
-		clear_bit(TTY_IO_ERROR, &info->port.tty->flags);
+	clear_bit(TTY_IO_ERROR, &tty->flags);
@@ -1001 +1000 @@
-	mxser_change_speed(info, NULL);
+	mxser_change_speed(tty, NULL);
@@ -1012 +1011 @@
-static void mxser_shutdown(struct mxser_port *info)
+static void mxser_shutdown(struct tty_struct *tty)
@@ -1013,0 +1013 @@
+	struct mxser_port *info = tty->driver_data;
@@ -1038 +1038 @@
-	if (!info->port.tty || (info->port.tty->termios->c_cflag & HUPCL))
+	if (tty->termios->c_cflag & HUPCL)
@@ -1054,2 +1054 @@
-	if (info->port.tty)
-		set_bit(TTY_IO_ERROR, &info->port.tty->flags);
+	set_bit(TTY_IO_ERROR, &tty->flags);
@@ -1087 +1086 @@
-	info->port.tty = tty;
+	tty_port_tty_set(&info->port, tty);
@@ -1094 +1093 @@
-	retval = mxser_startup(info);
+	retval = mxser_startup(tty);
@@ -1212 +1211 @@
-	mxser_shutdown(info);
+	mxser_shutdown(tty);
@@ -1218 +1217 @@
-	info->port.tty = NULL;
+	tty_port_tty_set(&info->port, NULL);
@@ -1340 +1339 @@
-static int mxser_get_serial_info(struct mxser_port *info,
+static int mxser_get_serial_info(struct tty_struct *tty,
@@ -1342,0 +1342 @@
+	struct mxser_port *info = tty->driver_data;
@@ -1345 +1345 @@
-		.line = info->port.tty->index,
+		.line = tty->index,
@@ -1360 +1360 @@
-static int mxser_set_serial_info(struct mxser_port *info,
+static int mxser_set_serial_info(struct tty_struct *tty,
@@ -1362,0 +1363 @@
+	struct mxser_port *info = tty->driver_data;
@@ -1396,2 +1397,2 @@
-		info->port.tty->low_latency =
-				(info->port.flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+		tty->low_latency = (info->port.flags & ASYNC_LOW_LATENCY)
+								? 1 : 0;
@@ -1403 +1404 @@
-			tty_encode_baud_rate(info->port.tty, baud, baud);
+			tty_encode_baud_rate(tty, baud, baud);
@@ -1414 +1415 @@
-			mxser_change_speed(info, NULL);
+			mxser_change_speed(tty, NULL);
@@ -1418 +1419 @@
-		retval = mxser_startup(info);
+		retval = mxser_startup(tty);
@@ -1464 +1465 @@
-		mxser_check_modem_status(info, status);
+		mxser_check_modem_status(tty, info, status);
@@ -1608,0 +1610 @@
+	struct tty_struct *tty;
@@ -1645,0 +1648,2 @@
+				
+				tty = tty_port_tty_get(&port->port);
@@ -1647 +1651 @@
-				if (!port->port.tty || !port->port.tty->termios)
+				if (!tty || !tty->termios)
@@ -1650,2 +1654,2 @@
-					ms.cflag = port->port.tty->termios->c_cflag;
-
+					ms.cflag = tty->termios->c_cflag;
+				tty_kref_put(tty);
@@ -1707 +1711 @@
-				me->baudrate[p] = tty_get_baud_rate(port->port.tty);
+				tty = tty_port_tty_get(&port->port);
@@ -1709 +1713 @@
-				if (!port->port.tty || !port->port.tty->termios) {
+				if (!tty || !tty->termios) {
@@ -1711,0 +1716 @@
+					me->baudrate[p] = tty_termios_baud_rate(&port->normal_termios);
@@ -1713,2 +1718,3 @@
-					cflag = port->port.tty->termios->c_cflag;
-					iflag = port->port.tty->termios->c_iflag;
+					cflag = tty->termios->c_cflag;
+					iflag = tty->termios->c_iflag;
+					me->baudrate[p] = tty_get_baud_rate(tty);
@@ -1715,0 +1722 @@
+				tty_kref_put(tty);
@@ -1825 +1832 @@
-		retval = mxser_get_serial_info(info, argp);
+		retval = mxser_get_serial_info(tty, argp);
@@ -1830 +1837 @@
-		retval = mxser_set_serial_info(info, argp);
+		retval = mxser_set_serial_info(tty, argp);
@@ -1899 +1906 @@
-		mxser_check_modem_status(info, status);
+		mxser_check_modem_status(tty, info, status);
@@ -1912 +1919 @@
-		if (info->port.tty->hw_stopped)
+		if (tty->hw_stopped)
@@ -1961 +1968 @@
-	if (info->port.tty->termios->c_cflag & CRTSCTS) {
+	if (tty->termios->c_cflag & CRTSCTS) {
@@ -1998 +2005 @@
-	if (info->port.tty->termios->c_cflag & CRTSCTS) {
+	if (tty->termios->c_cflag & CRTSCTS) {
@@ -2043 +2050 @@
-	mxser_change_speed(info, old_termios);
+	mxser_change_speed(tty, old_termios);
@@ -2141 +2148 @@
-	mxser_shutdown(info);
+	mxser_shutdown(tty);
@@ -2144 +2151 @@
-	info->port.tty = NULL;
+	tty_port_tty_set(&info->port, NULL);
@@ -2167 +2174,2 @@
-static void mxser_receive_chars(struct mxser_port *port, int *status)
+static void mxser_receive_chars(struct tty_struct *tty,
+				struct mxser_port *port, int *status)
@@ -2169 +2176,0 @@
-	struct tty_struct *tty = port->port.tty;
@@ -2177 +2184 @@
-	if ((recv_room == 0) && (!port->ldisc_stop_rx))
+	if (recv_room == 0 && !port->ldisc_stop_rx)
@@ -2179 +2185,0 @@
-
@@ -2256 +2262 @@
-	mxvar_log.rxcnt[port->port.tty->index] += cnt;
+	mxvar_log.rxcnt[tty->index] += cnt;
@@ -2270 +2276 @@
-static void mxser_transmit_chars(struct mxser_port *port)
+static void mxser_transmit_chars(struct tty_struct *tty, struct mxser_port *port)
@@ -2277 +2283 @@
-		mxvar_log.txcnt[port->port.tty->index]++;
+		mxvar_log.txcnt[tty->index]++;
@@ -2287,2 +2293,2 @@
-	if ((port->xmit_cnt <= 0) || port->port.tty->stopped ||
-			(port->port.tty->hw_stopped &&
+	if (port->xmit_cnt <= 0 || tty->stopped ||
+			(tty->hw_stopped &&
@@ -2305 +2311 @@
-	mxvar_log.txcnt[port->port.tty->index] += (cnt - port->xmit_cnt);
+	mxvar_log.txcnt[tty->index] += (cnt - port->xmit_cnt);
@@ -2311,2 +2317,2 @@
-	if (port->xmit_cnt < WAKEUP_CHARS)
-		tty_wakeup(port->port.tty);
+	if (port->xmit_cnt < WAKEUP_CHARS && tty)
+		tty_wakeup(tty);
@@ -2330,0 +2337 @@
+	struct tty_struct *tty;
@@ -2363 +2370,2 @@
-				if (!port->port.tty ||
+				tty = tty_port_tty_get(&port->port);
+				if (!tty ||
@@ -2369,0 +2378 @@
+					tty_kref_put(tty);
@@ -2390 +2399 @@
-						mxser_receive_chars(port,
+						mxser_receive_chars(tty, port,
@@ -2396 +2405 @@
-						mxser_receive_chars(port,
+						mxser_receive_chars(tty, port,
@@ -2401 +2410 @@
-					mxser_check_modem_status(port, msr);
+					mxser_check_modem_status(tty, port, msr);
@@ -2406 +2415 @@
-						mxser_transmit_chars(port);
+						mxser_transmit_chars(tty, port);
@@ -2409 +2418 @@
-						mxser_transmit_chars(port);
+						mxser_transmit_chars(tty, port);
@@ -2410,0 +2420 @@
+				tty_kref_put(tty);
--- ./projects/linux/linux-2.6.28/drivers/char/mxser.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/char/mxser.c	2009-03-24 00:12:14.000000000 +0100
@@ -544,2 +544 @@
-static int mxser_block_til_ready(struct tty_struct *tty, struct file *filp,
-		struct mxser_port *port)
+static int mxser_carrier_raised(struct tty_port *port)
@@ -547,17 +546,3 @@
-	DECLARE_WAITQUEUE(wait, current);
-	int retval;
-	int do_clocal = 0;
-	unsigned long flags;
-
-	/*
-	 * If non-blocking mode is set, or the port is not enabled,
-	 * then make the check up front and then exit.
-	 */
-	if ((filp->f_flags & O_NONBLOCK) ||
-			test_bit(TTY_IO_ERROR, &tty->flags)) {
-		port->port.flags |= ASYNC_NORMAL_ACTIVE;
-		return 0;
-	}
-
-	if (tty->termios->c_cflag & CLOCAL)
-		do_clocal = 1;
+	struct mxser_port *mp = container_of(port, struct mxser_port, port);
+	return (inb(mp->ioaddr + UART_MSR) & UART_MSR_DCD)?1:0;
+}
@@ -565,9 +550,4 @@
-	/*
-	 * Block waiting for the carrier detect and the line to become
-	 * free (i.e., not in use by the callout).  While we are in
-	 * this loop, port->port.count is dropped by one, so that
-	 * mxser_close() knows when to free things.  We restore it upon
-	 * exit, either normal or abnormal.
-	 */
-	retval = 0;
-	add_wait_queue(&port->port.open_wait, &wait);
+static void mxser_raise_dtr_rts(struct tty_port *port)
+{
+	struct mxser_port *mp = container_of(port, struct mxser_port, port);
+	unsigned long flags;
@@ -575,37 +555,4 @@
-	spin_lock_irqsave(&port->slock, flags);
-	if (!tty_hung_up_p(filp))
-		port->port.count--;
-	spin_unlock_irqrestore(&port->slock, flags);
-	port->port.blocked_open++;
-	while (1) {
-		spin_lock_irqsave(&port->slock, flags);
-		outb(inb(port->ioaddr + UART_MCR) |
-			UART_MCR_DTR | UART_MCR_RTS, port->ioaddr + UART_MCR);
-		spin_unlock_irqrestore(&port->slock, flags);
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (tty_hung_up_p(filp) || !(port->port.flags & ASYNC_INITIALIZED)) {
-			if (port->port.flags & ASYNC_HUP_NOTIFY)
-				retval = -EAGAIN;
-			else
-				retval = -ERESTARTSYS;
-			break;
-		}
-		if (!(port->port.flags & ASYNC_CLOSING) &&
-				(do_clocal ||
-				(inb(port->ioaddr + UART_MSR) & UART_MSR_DCD)))
-			break;
-		if (signal_pending(current)) {
-			retval = -ERESTARTSYS;
-			break;
-		}
-		schedule();
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&port->port.open_wait, &wait);
-	if (!tty_hung_up_p(filp))
-		port->port.count++;
-	port->port.blocked_open--;
-	if (retval)
-		return retval;
-	port->port.flags |= ASYNC_NORMAL_ACTIVE;
-	return 0;
+	spin_lock_irqsave(&mp->slock, flags);
+	outb(inb(mp->ioaddr + UART_MCR) |
+		UART_MCR_DTR | UART_MCR_RTS, mp->ioaddr + UART_MCR);
+	spin_unlock_irqrestore(&mp->slock, flags);
@@ -1090 +1037 @@
-	spin_lock_irqsave(&info->slock, flags);
+	spin_lock_irqsave(&info->port.lock, flags);
@@ -1092 +1039 @@
-	spin_unlock_irqrestore(&info->slock, flags);
+	spin_unlock_irqrestore(&info->port.lock, flags);
@@ -1097 +1044 @@
-	retval = mxser_block_til_ready(tty, filp, info);
+	retval = tty_port_block_til_ready(&info->port, tty, filp);
@@ -1135,0 +1083 @@
+	struct tty_port *port = &info->port;
@@ -1138 +1085,0 @@
-	unsigned long flags;
@@ -1145,25 +1092 @@
-	spin_lock_irqsave(&info->slock, flags);
-
-	if (tty_hung_up_p(filp)) {
-		spin_unlock_irqrestore(&info->slock, flags);
-		return;
-	}
-	if ((tty->count == 1) && (info->port.count != 1)) {
-		/*
-		 * Uh, oh.  tty->count is 1, which means that the tty
-		 * structure will be freed.  Info->port.count should always
-		 * be one in these conditions.  If it's greater than
-		 * one, we've got real problems, since it means the
-		 * serial port won't be shutdown.
-		 */
-		printk(KERN_ERR "mxser_close: bad serial port count; "
-			"tty->count is 1, info->port.count is %d\n", info->port.count);
-		info->port.count = 1;
-	}
-	if (--info->port.count < 0) {
-		printk(KERN_ERR "mxser_close: bad serial port count for "
-			"ttys%d: %d\n", tty->index, info->port.count);
-		info->port.count = 0;
-	}
-	if (info->port.count) {
-		spin_unlock_irqrestore(&info->slock, flags);
+	if (tty_port_close_start(port, tty, filp) == 0)
@@ -1171,3 +1094 @@
-	}
-	info->port.flags |= ASYNC_CLOSING;
-	spin_unlock_irqrestore(&info->slock, flags);
+
@@ -1176,0 +1098,2 @@
+	 *
+	 * FIXME: Can this go ?
@@ -1181,7 +1103,0 @@
-	 * Now we wait for the transmit buffer to clear; and we notify
-	 * the line discipline to only process XON/XOFF characters.
-	 */
-	tty->closing = 1;
-	if (info->port.closing_wait != ASYNC_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, info->port.closing_wait);
-	/*
@@ -1212 +1127,0 @@
-
@@ -1214,9 +1128,0 @@
-	tty_ldisc_flush(tty);
-
-	tty->closing = 0;
-	tty_port_tty_set(&info->port, NULL);
-	if (info->port.blocked_open) {
-		if (info->port.close_delay)
-			schedule_timeout_interruptible(info->port.close_delay);
-		wake_up_interruptible(&info->port.open_wait);
-	}
@@ -1224 +1130,4 @@
-	info->port.flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
+	/* Right now the tty_port set is done outside of the close_end helper
+	   as we don't yet have everyone using refcounts */	
+	tty_port_close_end(port, tty);
+	tty_port_tty_set(port, NULL);
@@ -2149,4 +2058 @@
-	info->port.count = 0;
-	info->port.flags &= ~ASYNC_NORMAL_ACTIVE;
-	tty_port_tty_set(&info->port, NULL);
-	wake_up_interruptible(&info->port.open_wait);
+	tty_port_hangup(&info->port);
@@ -2451,0 +2358,5 @@
+struct tty_port_operations mxser_port_ops = {
+	.carrier_raised = mxser_carrier_raised,
+	.raise_dtr_rts = mxser_raise_dtr_rts,
+};
+
@@ -2484,0 +2396 @@
+		info->port.ops = &mxser_port_ops;
--- ./projects/linux/linux-2.6.29/drivers/char/mxser.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/char/mxser.c	2009-06-27 11:32:32.000000000 +0200
@@ -823 +822,0 @@
-	tty = tty_port_tty_get(&port->port);
@@ -2715 +2714 @@
-		retval = mxser_get_ISA_conf(!ioaddr[b], brd);
+		retval = mxser_get_ISA_conf(ioaddr[b], brd);
--- ./projects/linux/linux-2.6.13/drivers/char/pcmcia/synclink_cs.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/char/pcmcia/synclink_cs.c	2005-10-28 02:02:08.000000000 +0200
@@ -4 +4 @@
- * $Id: synclink_cs.c,v 4.26 2004/08/11 19:30:02 paulkf Exp $
+ * $Id: synclink_cs.c,v 4.34 2005/09/08 13:20:54 paulkf Exp $
@@ -475 +475 @@
-static char *driver_version = "$Revision: 4.26 $";
+static char *driver_version = "$Revision: 4.34 $";
@@ -1459,0 +1460,2 @@
+	memset(&info->icount, 0, sizeof(info->icount));
+
@@ -1949,3 +1951,7 @@
-	COPY_TO_USER(err,user_icount, &info->icount, sizeof(struct mgsl_icount));
-	if (err)
-		return -EFAULT;
+	if (!user_icount) {
+		memset(&info->icount, 0, sizeof(info->icount));
+	} else {
+		COPY_TO_USER(err, user_icount, &info->icount, sizeof(struct mgsl_icount));
+		if (err)
+			return -EFAULT;
+	}
--- ./projects/linux/linux-2.6.14/drivers/char/pcmcia/synclink_cs.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/char/pcmcia/synclink_cs.c	2006-01-03 04:21:10.000000000 +0100
@@ -2997,2 +2997 @@
-	if (info->rx_buf)
-		kfree(info->rx_buf);
+	kfree(info->rx_buf);
--- ./projects/linux/linux-2.6.15/drivers/char/pcmcia/synclink_cs.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/pcmcia/synclink_cs.c	2006-03-20 06:53:29.000000000 +0100
@@ -489,7 +489 @@
-static int  mgslpc_event(event_t event, int priority,
-			 event_callback_args_t *args);
-static dev_link_t *mgslpc_attach(void);
-static void mgslpc_detach(dev_link_t *);
-
-static dev_info_t dev_info = "synclink_cs";
-static dev_link_t *dev_list = NULL;
+static void mgslpc_detach(struct pcmcia_device *p_dev);
@@ -542 +536 @@
-static dev_link_t *mgslpc_attach(void)
+static int mgslpc_attach(struct pcmcia_device *p_dev)
@@ -546,2 +539,0 @@
-    client_reg_t client_reg;
-    int ret;
@@ -555 +547 @@
-	    return NULL;
+	    return -ENOMEM;
@@ -590,14 +582,5 @@
-    /* Register with Card Services */
-    link->next = dev_list;
-    dev_list = link;
-
-    client_reg.dev_info = &dev_info;
-    client_reg.Version = 0x0210;
-    client_reg.event_callback_args.client_data = link;
-
-    ret = pcmcia_register_client(&link->handle, &client_reg);
-    if (ret != CS_SUCCESS) {
-	    cs_error(link->handle, RegisterClient, ret);
-	    mgslpc_detach(link);
-	    return NULL;
-    }
+    link->handle = p_dev;
+    p_dev->instance = link;
+
+    link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
+    mgslpc_config(link);
@@ -607 +590 @@
-    return link;
+    return 0;
@@ -739,2 +721,0 @@
-    if (link->state & DEV_STALE_LINK)
-	    mgslpc_detach(link);
@@ -743 +724 @@
-static void mgslpc_detach(dev_link_t *link)
+static void mgslpc_detach(struct pcmcia_device *p_dev)
@@ -745 +726 @@
-    dev_link_t **linkp;
+    dev_link_t *link = dev_to_instance(p_dev);
@@ -749,6 +729,0 @@
-    
-    /* find device */
-    for (linkp = &dev_list; *linkp; linkp = &(*linkp)->next)
-	    if (*linkp == link) break;
-    if (*linkp == NULL)
-	    return;
@@ -757,8 +732,2 @@
-	    /* device is configured/active, mark it so when
-	     * release() is called a proper detach() occurs.
-	     */
-	    if (debug_level >= DEBUG_LEVEL_INFO)
-		    printk(KERN_DEBUG "synclinkpc: detach postponed, '%s' "
-			   "still locked\n", link->dev->dev_name);
-	    link->state |= DEV_STALE_LINK;
-	    return;
+	    ((MGSLPC_INFO *)link->priv)->stop = 1;
+	    mgslpc_release((u_long)link);
@@ -767,6 +735,0 @@
-    /* Break the link with Card Services */
-    if (link->handle)
-	    pcmcia_deregister_client(link->handle);
-    
-    /* Unlink device structure, and free it */
-    *linkp = link->next;
@@ -776,2 +739 @@
-static int mgslpc_event(event_t event, int priority,
-			event_callback_args_t *args)
+static int mgslpc_suspend(struct pcmcia_device *dev)
@@ -779,37 +741,22 @@
-    dev_link_t *link = args->client_data;
-    MGSLPC_INFO *info = link->priv;
-    
-    if (debug_level >= DEBUG_LEVEL_INFO)
-	    printk("mgslpc_event(0x%06x)\n", event);
-    
-    switch (event) {
-    case CS_EVENT_CARD_REMOVAL:
-	    link->state &= ~DEV_PRESENT;
-	    if (link->state & DEV_CONFIG) {
-		    ((MGSLPC_INFO *)link->priv)->stop = 1;
-		    mgslpc_release((u_long)link);
-	    }
-	    break;
-    case CS_EVENT_CARD_INSERTION:
-	    link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
-	    mgslpc_config(link);
-	    break;
-    case CS_EVENT_PM_SUSPEND:
-	    link->state |= DEV_SUSPEND;
-	    /* Fall through... */
-    case CS_EVENT_RESET_PHYSICAL:
-	    /* Mark the device as stopped, to block IO until later */
-	    info->stop = 1;
-	    if (link->state & DEV_CONFIG)
-		    pcmcia_release_configuration(link->handle);
-	    break;
-    case CS_EVENT_PM_RESUME:
-	    link->state &= ~DEV_SUSPEND;
-	    /* Fall through... */
-    case CS_EVENT_CARD_RESET:
-	    if (link->state & DEV_CONFIG)
-		    pcmcia_request_configuration(link->handle, &link->conf);
-	    info->stop = 0;
-	    break;
-    }
-    return 0;
+	dev_link_t *link = dev_to_instance(dev);
+	MGSLPC_INFO *info = link->priv;
+
+	link->state |= DEV_SUSPEND;
+	info->stop = 1;
+	if (link->state & DEV_CONFIG)
+		pcmcia_release_configuration(link->handle);
+
+	return 0;
+}
+
+static int mgslpc_resume(struct pcmcia_device *dev)
+{
+	dev_link_t *link = dev_to_instance(dev);
+	MGSLPC_INFO *info = link->priv;
+
+	link->state &= ~DEV_SUSPEND;
+	if (link->state & DEV_CONFIG)
+		pcmcia_request_configuration(link->handle, &link->conf);
+	info->stop = 0;
+
+	return 0;
@@ -817,0 +765 @@
+
@@ -1062 +1010 @@
-	unsigned char data, status;
+	unsigned char data, status, flag;
@@ -1063,0 +1012 @@
+	int work = 0;
@@ -1078 +1027,2 @@
-	
+
+	tty_buffer_request_room(tty, fifo_count);
@@ -1085,4 +1034,0 @@
-		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
-			break;
-			
-		*tty->flip.char_buf_ptr = data;
@@ -1090,2 +1036 @@
-		
-		*tty->flip.flag_buf_ptr = 0;
+		flag = TTY_NORMAL;
@@ -1110 +1055 @@
-				*tty->flip.flag_buf_ptr = TTY_PARITY;
+				flag = TTY_PARITY;
@@ -1112 +1057 @@
-				*tty->flip.flag_buf_ptr = TTY_FRAME;
+				flag = TTY_FRAME;
@@ -1114,4 +1059 @@
-		
-		tty->flip.flag_buf_ptr++;
-		tty->flip.char_buf_ptr++;
-		tty->flip.count++;
+		work += tty_insert_flip_char(tty, data, flag);
@@ -1122,2 +1064,2 @@
-		printk("%s(%d):rx_ready_async count=%d\n",
-			__FILE__,__LINE__,tty->flip.count);
+		printk("%s(%d):rx_ready_async",
+			__FILE__,__LINE__);
@@ -1129 +1071 @@
-	if (tty->flip.count)
+	if (work)
@@ -3094,3 +3036,2 @@
-	.attach		= mgslpc_attach,
-	.event		= mgslpc_event,
-	.detach		= mgslpc_detach,
+	.probe		= mgslpc_attach,
+	.remove		= mgslpc_detach,
@@ -3097,0 +3039,2 @@
+	.suspend	= mgslpc_suspend,
+	.resume		= mgslpc_resume,
@@ -3141 +3083,0 @@
-	BUG_ON(dev_list != NULL);
@@ -4060 +4002 @@
-	static unsigned int count = sizeof(patterns) / sizeof(patterns[0]);
+	static unsigned int count = ARRAY_SIZE(patterns);
@@ -4071 +4013 @@
-		if ((read_reg(info, XAD1) != patterns[i]) || 
+		if ((read_reg(info, XAD1) != patterns[i]) ||
--- ./projects/linux/linux-2.6.16/drivers/char/pcmcia/synclink_cs.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/char/pcmcia/synclink_cs.c	2006-06-18 03:49:35.000000000 +0200
@@ -231 +231 @@
-	dev_link_t	      link;
+	struct pcmcia_device	*p_dev;
@@ -487 +487 @@
-static void mgslpc_config(dev_link_t *link);
+static int mgslpc_config(struct pcmcia_device *link);
@@ -536 +536 @@
-static int mgslpc_attach(struct pcmcia_device *p_dev)
+static int mgslpc_probe(struct pcmcia_device *link)
@@ -539,2 +539,2 @@
-    dev_link_t *link;
-    
+    int ret;
+
@@ -543 +543 @@
-	
+
@@ -568 +568 @@
-    link = &info->link;
+    info->p_dev = link;
@@ -570,2 +570,2 @@
-    
-    /* Initialize the dev_link_t structure */
+
+    /* Initialize the struct pcmcia_device structure */
@@ -577 +577 @@
-    
+
@@ -579 +578,0 @@
-    link->conf.Vcc = 50;
@@ -582,5 +581,3 @@
-    link->handle = p_dev;
-    p_dev->instance = link;
-
-    link->state |= DEV_PRESENT | DEV_CONFIG_PENDING;
-    mgslpc_config(link);
+    ret = mgslpc_config(link);
+    if (ret)
+	    return ret;
@@ -599 +596 @@
-static void mgslpc_config(dev_link_t *link)
+static int mgslpc_config(struct pcmcia_device *link)
@@ -601 +597,0 @@
-    client_handle_t handle = link->handle;
@@ -607 +602,0 @@
-    config_info_t conf;
@@ -620,3 +615,3 @@
-    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
-    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(handle, &tuple));
-    CS_CHECK(ParseTuple, pcmcia_parse_tuple(handle, &tuple, &parse));
+    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
+    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(link, &tuple));
+    CS_CHECK(ParseTuple, pcmcia_parse_tuple(link, &tuple, &parse));
@@ -625,7 +619,0 @@
-    
-    /* Configure card */
-    link->state |= DEV_CONFIG;
-
-    /* Look up the current Vcc */
-    CS_CHECK(GetConfigurationInfo, pcmcia_get_configuration_info(handle, &conf));
-    link->conf.Vcc = conf.Vcc;
@@ -636 +624 @@
-    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(handle, &tuple));
+    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
@@ -639,2 +627,2 @@
-    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(handle, &tuple));
-    CS_CHECK(ParseTuple, pcmcia_parse_tuple(handle, &tuple, &parse));
+    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(link, &tuple));
+    CS_CHECK(ParseTuple, pcmcia_parse_tuple(link, &tuple, &parse));
@@ -661 +649 @@
-	    CS_CHECK(RequestIO, pcmcia_request_io(link->handle, &link->io));
+	    CS_CHECK(RequestIO, pcmcia_request_io(link, &link->io));
@@ -665 +652,0 @@
-    link->conf.Vcc = 50;
@@ -673 +660 @@
-    CS_CHECK(RequestIRQ, pcmcia_request_irq(link->handle, &link->irq));
+    CS_CHECK(RequestIRQ, pcmcia_request_irq(link, &link->irq));
@@ -675 +662 @@
-    CS_CHECK(RequestConfiguration, pcmcia_request_configuration(link->handle, &link->conf));
+    CS_CHECK(RequestConfiguration, pcmcia_request_configuration(link, &link->conf));
@@ -683 +670 @@
-    link->dev = &info->node;
+    link->dev_node = &info->node;
@@ -693,3 +680 @@
-    
-    link->state &= ~DEV_CONFIG_PENDING;
-    return;
+    return 0;
@@ -698 +683 @@
-    cs_error(link->handle, last_fn, last_ret);
+    cs_error(link, last_fn, last_ret);
@@ -699,0 +685 @@
+    return -ENODEV;
@@ -708 +694 @@
-    dev_link_t *link = (dev_link_t *)arg;
+	struct pcmcia_device *link = (struct pcmcia_device *)arg;
@@ -710,6 +696,2 @@
-    if (debug_level >= DEBUG_LEVEL_INFO)
-	    printk("mgslpc_release(0x%p)\n", link);
-
-    /* Unlink the device chain */
-    link->dev = NULL;
-    link->state &= ~DEV_CONFIG;
+	if (debug_level >= DEBUG_LEVEL_INFO)
+		printk("mgslpc_release(0x%p)\n", link);
@@ -717,5 +699 @@
-    pcmcia_release_configuration(link->handle);
-    if (link->io.NumPorts1)
-	    pcmcia_release_io(link->handle, &link->io);
-    if (link->irq.AssignedIRQ)
-	    pcmcia_release_irq(link->handle, &link->irq);
+	pcmcia_disable_device(link);
@@ -724 +702 @@
-static void mgslpc_detach(struct pcmcia_device *p_dev)
+static void mgslpc_detach(struct pcmcia_device *link)
@@ -726,4 +704,2 @@
-    dev_link_t *link = dev_to_instance(p_dev);
-
-    if (debug_level >= DEBUG_LEVEL_INFO)
-	    printk("mgslpc_detach(0x%p)\n", link);
+	if (debug_level >= DEBUG_LEVEL_INFO)
+		printk("mgslpc_detach(0x%p)\n", link);
@@ -731,4 +707,2 @@
-    if (link->state & DEV_CONFIG) {
-	    ((MGSLPC_INFO *)link->priv)->stop = 1;
-	    mgslpc_release((u_long)link);
-    }
+	((MGSLPC_INFO *)link->priv)->stop = 1;
+	mgslpc_release((u_long)link);
@@ -736 +710 @@
-    mgslpc_remove_device((MGSLPC_INFO *)link->priv);
+	mgslpc_remove_device((MGSLPC_INFO *)link->priv);
@@ -739 +713 @@
-static int mgslpc_suspend(struct pcmcia_device *dev)
+static int mgslpc_suspend(struct pcmcia_device *link)
@@ -741 +714,0 @@
-	dev_link_t *link = dev_to_instance(dev);
@@ -744 +716,0 @@
-	link->state |= DEV_SUSPEND;
@@ -746,2 +717,0 @@
-	if (link->state & DEV_CONFIG)
-		pcmcia_release_configuration(link->handle);
@@ -752 +722 @@
-static int mgslpc_resume(struct pcmcia_device *dev)
+static int mgslpc_resume(struct pcmcia_device *link)
@@ -754 +723,0 @@
-	dev_link_t *link = dev_to_instance(dev);
@@ -757,3 +725,0 @@
-	link->state &= ~DEV_SUSPEND;
-	if (link->state & DEV_CONFIG)
-		pcmcia_request_configuration(link->handle, &link->conf);
@@ -1283 +1249 @@
-	if (!(info->link.state & DEV_CONFIG))
+	if (!(info->p_dev->_locked))
@@ -3036 +3002 @@
-	.probe		= mgslpc_attach,
+	.probe		= mgslpc_probe,
@@ -4184 +4150 @@
-	info->params.crc_type = new_crctype;;
+	info->params.crc_type = new_crctype;
--- ./projects/linux/linux-2.6.17/drivers/char/pcmcia/synclink_cs.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/pcmcia/synclink_cs.c	2006-09-20 05:42:06.000000000 +0200
@@ -847 +847 @@
-void bh_handler(void* Context)
+static void bh_handler(void* Context)
@@ -891 +891 @@
-void bh_transmit(MGSLPC_INFO *info)
+static void bh_transmit(MGSLPC_INFO *info)
@@ -903 +903 @@
-void bh_status(MGSLPC_INFO *info)
+static void bh_status(MGSLPC_INFO *info)
@@ -1177,2 +1177,6 @@
-	if (info->netcount)
-		hdlc_set_carrier(info->serial_signals & SerialSignal_DCD, info->netdev);
+	if (info->netcount) {
+		if (info->serial_signals & SerialSignal_DCD)
+			netif_carrier_on(info->netdev);
+		else
+			netif_carrier_off(info->netdev);
+	}
@@ -1585 +1589 @@
-	if (!tty || !info->tx_buf)
+	if (!info->tx_buf)
@@ -1652 +1656 @@
-	    !tty || !info->tx_buf)
+		!info->tx_buf)
@@ -2308 +2312 @@
-int ioctl_common(MGSLPC_INFO *info, unsigned int cmd, unsigned long arg)
+static int ioctl_common(MGSLPC_INFO *info, unsigned int cmd, unsigned long arg)
@@ -2880 +2884 @@
-int rx_alloc_buffers(MGSLPC_INFO *info)
+static int rx_alloc_buffers(MGSLPC_INFO *info)
@@ -2903 +2907 @@
-void rx_free_buffers(MGSLPC_INFO *info)
+static void rx_free_buffers(MGSLPC_INFO *info)
@@ -2909 +2913 @@
-int claim_resources(MGSLPC_INFO *info)
+static int claim_resources(MGSLPC_INFO *info)
@@ -2919 +2923 @@
-void release_resources(MGSLPC_INFO *info)
+static void release_resources(MGSLPC_INFO *info)
@@ -2931 +2935 @@
-void mgslpc_add_device(MGSLPC_INFO *info)
+static void mgslpc_add_device(MGSLPC_INFO *info)
@@ -2967 +2971 @@
-void mgslpc_remove_device(MGSLPC_INFO *remove_info)
+static void mgslpc_remove_device(MGSLPC_INFO *remove_info)
@@ -3260 +3264 @@
-void hdlc_mode(MGSLPC_INFO *info)
+static void hdlc_mode(MGSLPC_INFO *info)
@@ -3500 +3504 @@
-void rx_stop(MGSLPC_INFO *info)
+static void rx_stop(MGSLPC_INFO *info)
@@ -3513 +3517 @@
-void rx_start(MGSLPC_INFO *info)
+static void rx_start(MGSLPC_INFO *info)
@@ -3529 +3533 @@
-void tx_start(MGSLPC_INFO *info)
+static void tx_start(MGSLPC_INFO *info)
@@ -3567 +3571 @@
-void tx_stop(MGSLPC_INFO *info)
+static void tx_stop(MGSLPC_INFO *info)
@@ -3581 +3585 @@
-void reset_device(MGSLPC_INFO *info)
+static void reset_device(MGSLPC_INFO *info)
@@ -3631 +3635 @@
-void async_mode(MGSLPC_INFO *info)
+static void async_mode(MGSLPC_INFO *info)
@@ -3802 +3806 @@
-void tx_set_idle(MGSLPC_INFO *info)
+static void tx_set_idle(MGSLPC_INFO *info)
@@ -3813 +3817 @@
-void get_signals(MGSLPC_INFO *info)
+static void get_signals(MGSLPC_INFO *info)
@@ -3835 +3839 @@
-void set_signals(MGSLPC_INFO *info)
+static void set_signals(MGSLPC_INFO *info)
@@ -3859 +3863 @@
-void rx_reset_buffers(MGSLPC_INFO *info)
+static void rx_reset_buffers(MGSLPC_INFO *info)
@@ -3878 +3882 @@
-int rx_get_frame(MGSLPC_INFO *info)
+static int rx_get_frame(MGSLPC_INFO *info)
@@ -3964 +3968 @@
-BOOLEAN register_test(MGSLPC_INFO *info)
+static BOOLEAN register_test(MGSLPC_INFO *info)
@@ -3990 +3994 @@
-BOOLEAN irq_test(MGSLPC_INFO *info)
+static BOOLEAN irq_test(MGSLPC_INFO *info)
@@ -4025 +4029 @@
-int adapter_test(MGSLPC_INFO *info)
+static int adapter_test(MGSLPC_INFO *info)
@@ -4047 +4051 @@
-void trace_block(MGSLPC_INFO *info,const char* data, int count, int xmit)
+static void trace_block(MGSLPC_INFO *info,const char* data, int count, int xmit)
@@ -4082 +4086 @@
-void tx_timeout(unsigned long context)
+static void tx_timeout(unsigned long context)
@@ -4254,2 +4258,4 @@
-	hdlc_set_carrier(info->serial_signals & SerialSignal_DCD, dev);
-
+	if (info->serial_signals & SerialSignal_DCD)
+		netif_carrier_on(dev);
+	else
+		netif_carrier_off(dev);
--- ./projects/linux/linux-2.6.18/drivers/char/pcmcia/synclink_cs.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/pcmcia/synclink_cs.c	2006-11-29 22:57:37.000000000 +0100
@@ -38 +37,0 @@
-#include <linux/config.h>	
@@ -60 +58,0 @@
-#include <asm/serial.h>
@@ -421 +419 @@
-static irqreturn_t mgslpc_isr(int irq, void *dev_id, struct pt_regs * regs);
+static irqreturn_t mgslpc_isr(int irq, void *dev_id);
@@ -1239 +1236,0 @@
- * regs    interrupted processor context
@@ -1241 +1238 @@
-static irqreturn_t mgslpc_isr(int irq, void *dev_id, struct pt_regs * regs)
+static irqreturn_t mgslpc_isr(int irq, void *dev_id)
@@ -3013 +3010 @@
-static struct tty_operations mgslpc_ops = {
+static const struct tty_operations mgslpc_ops = {
--- ./projects/linux/linux-2.6.19/drivers/char/pcmcia/synclink_cs.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/pcmcia/synclink_cs.c	2007-02-04 19:44:54.000000000 +0100
@@ -78,2 +78,4 @@
-#ifdef CONFIG_HDLC_MODULE
-#define CONFIG_HDLC 1
+#if defined(CONFIG_HDLC) || (defined(CONFIG_HDLC_MODULE) && defined(CONFIG_SYNCLINK_CS_MODULE))
+#define SYNCLINK_GENERIC_HDLC 1
+#else
+#define SYNCLINK_GENERIC_HDLC 0
@@ -238 +240 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -395 +397 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -424 +426 @@
-static void bh_handler(void* Context);
+static void bh_handler(struct work_struct *work);
@@ -542 +544 @@
-    info = (MGSLPC_INFO *)kmalloc(sizeof(MGSLPC_INFO), GFP_KERNEL);
+    info = kmalloc(sizeof(MGSLPC_INFO), GFP_KERNEL);
@@ -550 +552 @@
-    INIT_WORK(&info->task, bh_handler, info);
+    INIT_WORK(&info->task, bh_handler);
@@ -607,2 +608,0 @@
-    /* read CONFIG tuple to find its configuration registers */
-    tuple.DesiredTuple = CISTPL_CONFIG;
@@ -613,5 +612,0 @@
-    CS_CHECK(GetFirstTuple, pcmcia_get_first_tuple(link, &tuple));
-    CS_CHECK(GetTupleData, pcmcia_get_tuple_data(link, &tuple));
-    CS_CHECK(ParseTuple, pcmcia_parse_tuple(link, &tuple, &parse));
-    link->conf.ConfigBase = parse.config.base;
-    link->conf.Present = parse.config.rmask[0];
@@ -845 +840 @@
-static void bh_handler(void* Context)
+static void bh_handler(struct work_struct *work)
@@ -847 +842 @@
-	MGSLPC_INFO *info = (MGSLPC_INFO*)Context;
+	MGSLPC_INFO *info = container_of(work, MGSLPC_INFO, task);
@@ -1063 +1058 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -1174 +1169 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -2383 +2378 @@
-static void mgslpc_set_termios(struct tty_struct *tty, struct termios *old_termios)
+static void mgslpc_set_termios(struct tty_struct *tty, struct ktermios *old_termios)
@@ -2963 +2958 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -2979 +2974 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -3911 +3906 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -3945 +3940 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -4101 +4096 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -4109 +4104 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
--- ./projects/linux/linux-2.6.20/drivers/char/pcmcia/synclink_cs.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/pcmcia/synclink_cs.c	2007-04-26 05:08:32.000000000 +0200
@@ -890 +890 @@
-	if (tty) {
+	if (tty)
@@ -892,2 +891,0 @@
-		wake_up_interruptible(&tty->write_wait);
-	}
@@ -1366,3 +1364 @@
-	init_timer(&info->tx_timer);
-	info->tx_timer.data = (unsigned long)info;
-	info->tx_timer.function = tx_timeout;
+	setup_timer(&info->tx_timer, tx_timeout, (unsigned long)info);
@@ -1413 +1409 @@
-	del_timer(&info->tx_timer);	
+	del_timer_sync(&info->tx_timer);
@@ -3554,2 +3550,2 @@
-			info->tx_timer.expires = jiffies + msecs_to_jiffies(5000);
-			add_timer(&info->tx_timer);	
+			mod_timer(&info->tx_timer, jiffies +
+					msecs_to_jiffies(5000));
--- ./projects/linux/linux-2.6.21/drivers/char/pcmcia/synclink_cs.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/char/pcmcia/synclink_cs.c	2007-07-09 01:32:17.000000000 +0200
@@ -45 +44,0 @@
-#include <linux/pci.h>
@@ -4172 +4171 @@
-	memcpy(info->tx_buf, skb->data, skb->len);
+	skb_copy_from_linear_data(skb, info->tx_buf, skb->len);
--- ./projects/linux/linux-2.6.22/drivers/char/pcmcia/synclink_cs.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/pcmcia/synclink_cs.c	2007-10-09 22:31:38.000000000 +0200
@@ -543 +543 @@
-    info = kmalloc(sizeof(MGSLPC_INFO), GFP_KERNEL);
+    info = kzalloc(sizeof(MGSLPC_INFO), GFP_KERNEL);
@@ -549 +548,0 @@
-    memset(info, 0, sizeof(MGSLPC_INFO));
--- ./projects/linux/linux-2.6.23/drivers/char/pcmcia/synclink_cs.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/pcmcia/synclink_cs.c	2008-01-24 23:58:37.000000000 +0100
@@ -126 +126 @@
-	int	ri_up;	
+	int	ri_up;
@@ -140 +140 @@
- 
+
@@ -149 +149 @@
-	
+
@@ -151 +151 @@
-	
+
@@ -157 +157 @@
-	unsigned char		ignore_status_mask;	
+	unsigned char		ignore_status_mask;
@@ -173 +173 @@
-	
+
@@ -176 +176 @@
-	
+
@@ -195 +195 @@
-	
+
@@ -215 +215 @@
-	
+
@@ -252 +252 @@
-    
+
@@ -301 +301 @@
-    
+
@@ -303 +303 @@
-    
+
@@ -318 +318 @@
-    
+
@@ -320 +320 @@
-    
+
@@ -324 +324 @@
-    
+
@@ -332,3 +332,3 @@
-    
-/* Register access functions */ 
-    
+
+/* Register access functions */
+
@@ -338 +338 @@
-#define read_reg16(info, reg) inw((info)->io_base + (reg))  
+#define read_reg16(info, reg) inw((info)->io_base + (reg))
@@ -340 +340 @@
-    
+
@@ -343 +343 @@
-		 (unsigned char) (read_reg(info, (reg)) | (mask)))  
+		 (unsigned char) (read_reg(info, (reg)) | (mask)))
@@ -346 +346 @@
-		 (unsigned char) (read_reg(info, (reg)) & ~(mask)))  
+		 (unsigned char) (read_reg(info, (reg)) & ~(mask)))
@@ -349,2 +349,2 @@
- */ 
-static void irq_disable(MGSLPC_INFO *info, unsigned char channel, unsigned short mask) 
+ */
+static void irq_disable(MGSLPC_INFO *info, unsigned char channel, unsigned short mask)
@@ -360 +360 @@
-static void irq_enable(MGSLPC_INFO *info, unsigned char channel, unsigned short mask) 
+static void irq_enable(MGSLPC_INFO *info, unsigned char channel, unsigned short mask)
@@ -561 +561 @@
-    info->idle_mode = HDLC_TXIDLE_FLAGS;		
+    info->idle_mode = HDLC_TXIDLE_FLAGS;
@@ -603 +603 @@
-    
+
@@ -627 +627 @@
-	
+
@@ -647 +647 @@
-    
+
@@ -756 +756 @@
-static BOOLEAN wait_command_complete(MGSLPC_INFO *info, unsigned char channel) 
+static BOOLEAN wait_command_complete(MGSLPC_INFO *info, unsigned char channel)
@@ -759 +759 @@
-	/* wait for command completion */ 
+	/* wait for command completion */
@@ -768 +768 @@
-static void issue_command(MGSLPC_INFO *info, unsigned char channel, unsigned char cmd) 
+static void issue_command(MGSLPC_INFO *info, unsigned char channel, unsigned char cmd)
@@ -778 +778 @@
-	
+
@@ -782,2 +782,2 @@
-		printk("tx_pause(%s)\n",info->device_name);	
-		
+		printk("tx_pause(%s)\n",info->device_name);
+
@@ -794 +794 @@
-	
+
@@ -798,2 +798,2 @@
-		printk("tx_release(%s)\n",info->device_name);	
-		
+		printk("tx_release(%s)\n",info->device_name);
+
@@ -813 +813 @@
-	
+
@@ -832 +832 @@
-	
+
@@ -834 +834 @@
-	
+
@@ -845 +845 @@
-		
+
@@ -849 +849 @@
-	
+
@@ -853 +853 @@
-	
+
@@ -860 +860 @@
-		
+
@@ -900 +900 @@
-/* eom: non-zero = end of frame */ 
+/* eom: non-zero = end of frame */
@@ -909 +909 @@
-	
+
@@ -923 +923 @@
-		/* end of frame, get FIFO count from RBCL register */ 
+		/* end of frame, get FIFO count from RBCL register */
@@ -928 +928 @@
-	
+
@@ -972 +972 @@
-		/* early termination, get FIFO count from RBCL register */ 
+		/* early termination, get FIFO count from RBCL register */
@@ -984 +984 @@
-	/* Flush received async data to receive data buffer. */ 
+	/* Flush received async data to receive data buffer. */
@@ -998 +998 @@
-			if (status & BIT7) 
+			if (status & BIT7)
@@ -1006 +1006 @@
-				
+
@@ -1025 +1025 @@
-			
+
@@ -1035 +1035 @@
-			
+
@@ -1043,2 +1043,2 @@
-	del_timer(&info->tx_timer);	
-	
+	del_timer(&info->tx_timer);
+
@@ -1057 +1057 @@
-	else 
+	else
@@ -1093 +1093 @@
-		
+
@@ -1223 +1223 @@
- * 	
+ *
@@ -1225 +1225 @@
- * 
+ *
@@ -1236 +1236 @@
-	if (debug_level >= DEBUG_LEVEL_ISR)	
+	if (debug_level >= DEBUG_LEVEL_ISR)
@@ -1240 +1240 @@
-		
+
@@ -1247 +1247 @@
-		if (debug_level >= DEBUG_LEVEL_ISR)	
+		if (debug_level >= DEBUG_LEVEL_ISR)
@@ -1271 +1271 @@
-			/* receive IRQs */ 
+			/* receive IRQs */
@@ -1286 +1286 @@
-					rx_ready_hdlc(info, isr & IRQ_RXEOM); 
+					rx_ready_hdlc(info, isr & IRQ_RXEOM);
@@ -1291 +1291 @@
-			/* transmit IRQs */ 
+			/* transmit IRQs */
@@ -1314,2 +1314,2 @@
-	
-	/* Request bottom half processing if there's something 
+
+	/* Request bottom half processing if there's something
@@ -1320 +1320 @@
-		if ( debug_level >= DEBUG_LEVEL_ISR )	
+		if ( debug_level >= DEBUG_LEVEL_ISR )
@@ -1328,2 +1328,2 @@
-	
-	if (debug_level >= DEBUG_LEVEL_ISR)	
+
+	if (debug_level >= DEBUG_LEVEL_ISR)
@@ -1341 +1341 @@
-	
+
@@ -1344 +1344 @@
-		
+
@@ -1347 +1347 @@
-	
+
@@ -1359 +1359 @@
-	
+
@@ -1366 +1366 @@
-	
+
@@ -1370 +1370 @@
-		
+
@@ -1380 +1380 @@
-	
+
@@ -1385 +1385 @@
-	
+
@@ -1394 +1394 @@
-	
+
@@ -1421 +1421 @@
-	
+
@@ -1426 +1426 @@
-	
+
@@ -1429,2 +1429,2 @@
-	release_resources(info);	
-	
+	release_resources(info);
+
@@ -1442 +1442 @@
-	
+
@@ -1446 +1446 @@
-	
+
@@ -1451 +1451 @@
-		
+
@@ -1453 +1453 @@
-	
+
@@ -1462 +1462 @@
-		
+
@@ -1465 +1465 @@
-		
+
@@ -1478 +1478 @@
-		
+
@@ -1482 +1482 @@
-			 
+
@@ -1491 +1491 @@
-	
+
@@ -1493 +1493 @@
-	
+
@@ -1501 +1501 @@
-	      
+
@@ -1522 +1522 @@
-	bits_per_char = info->params.data_bits + 
+	bits_per_char = info->params.data_bits +
@@ -1532 +1532 @@
-	
+
@@ -1534 +1534 @@
-		info->timeout = (32*HZ*bits_per_char) / 
+		info->timeout = (32*HZ*bits_per_char) /
@@ -1543 +1543 @@
-		
+
@@ -1550 +1550 @@
-	
+
@@ -1579 +1579 @@
-	
+
@@ -1587 +1587 @@
-	
+
@@ -1598 +1598 @@
-				
+
@@ -1602 +1602 @@
-	
+
@@ -1621 +1621 @@
- * 	
+ *
@@ -1623 +1623 @@
- * 
+ *
@@ -1627 +1627 @@
- * 	
+ *
@@ -1636 +1636 @@
-	
+
@@ -1640 +1640 @@
-	
+
@@ -1662 +1662 @@
-			
+
@@ -1681 +1681 @@
-cleanup:	
+cleanup:
@@ -1694 +1694 @@
-				
+
@@ -1709 +1709 @@
-	
+
@@ -1722 +1722 @@
-		 
+
@@ -1726 +1726 @@
-			 
+
@@ -1729 +1729 @@
-		
+
@@ -1738 +1738 @@
-			 
+
@@ -1748 +1748 @@
-	
+
@@ -1752 +1752 @@
-	
+
@@ -1755,2 +1755,2 @@
-		
-	spin_lock_irqsave(&info->lock,flags); 
+
+	spin_lock_irqsave(&info->lock,flags);
@@ -1758 +1758 @@
-	del_timer(&info->tx_timer);	
+	del_timer(&info->tx_timer);
@@ -1775 +1775 @@
-			 
+
@@ -1794 +1794 @@
-	
+
@@ -1801 +1801 @@
-	
+
@@ -1804 +1804 @@
- 
+
@@ -1819 +1819 @@
-	
+
@@ -1826 +1826 @@
-	
+
@@ -1833 +1833 @@
-	
+
@@ -1873 +1873 @@
- * 	
+ *
@@ -1875 +1875 @@
- * 
+ *
@@ -1886 +1886 @@
- 
+
@@ -1897 +1897 @@
-	
+
@@ -1901 +1901 @@
-	
+
@@ -1903 +1903 @@
-	
+
@@ -1966 +1966 @@
- 
+
@@ -1969 +1969 @@
-			
+
@@ -1985 +1985 @@
- 
+
@@ -1988 +1988 @@
-			
+
@@ -2005 +2005 @@
- 
+
@@ -2008 +2008 @@
-			
+
@@ -2022 +2022 @@
- * 	
+ *
@@ -2043 +2043 @@
-		 
+
@@ -2065 +2065 @@
-	
+
@@ -2069 +2069 @@
-	
+
@@ -2072 +2072 @@
-	
+
@@ -2074,2 +2074,2 @@
-	
-	
+
+
@@ -2082 +2082 @@
-			
+
@@ -2118 +2118 @@
-		
+
@@ -2122 +2122 @@
-	
+
@@ -2250 +2250 @@
-	
+
@@ -2254 +2254 @@
-			 
+
@@ -2261 +2261 @@
-	else 
+	else
@@ -2267 +2267 @@
- * 	
+ *
@@ -2269 +2269 @@
- * 
+ *
@@ -2274 +2274 @@
- * 	
+ *
@@ -2281 +2281 @@
-	
+
@@ -2285 +2285 @@
-	
+
@@ -2305 +2305 @@
-	
+
@@ -2366 +2366 @@
- * 	
+ *
@@ -2368 +2368 @@
- * 
+ *
@@ -2376 +2376 @@
-	
+
@@ -2380 +2380 @@
-	
+
@@ -2383 +2383 @@
-	    && (RELEVANT_IFLAG(tty->termios->c_iflag) 
+	    && (RELEVANT_IFLAG(tty->termios->c_iflag)
@@ -2397 +2397 @@
-	
+
@@ -2402 +2402 @@
- 		if (!(tty->termios->c_cflag & CRTSCTS) || 
+ 		if (!(tty->termios->c_cflag & CRTSCTS) ||
@@ -2410 +2410 @@
-	
+
@@ -2425 +2425 @@
-	
+
@@ -2429 +2429 @@
-			 
+
@@ -2435 +2435 @@
-			
+
@@ -2446 +2446 @@
-	
+
@@ -2448 +2448 @@
-	
+
@@ -2452 +2452 @@
-	
+
@@ -2454,2 +2454,2 @@
-	
-	/* set tty->closing to notify line discipline to 
+
+	/* set tty->closing to notify line discipline to
@@ -2460 +2460 @@
-	
+
@@ -2462 +2462 @@
-	
+
@@ -2469 +2469 @@
-		
+
@@ -2477 +2477 @@
-		
+
@@ -2479 +2479 @@
-	
+
@@ -2482 +2482 @@
-	
+
@@ -2489 +2489 @@
-	
+
@@ -2491 +2491 @@
-			 
+
@@ -2493,2 +2493,2 @@
-	
-cleanup:			
+
+cleanup:
@@ -2513 +2513 @@
-      
+
@@ -2519 +2519 @@
-	 
+
@@ -2521 +2521 @@
-      
+
@@ -2526,2 +2526,2 @@
-	 */ 
-       
+	 */
+
@@ -2534 +2534 @@
-		
+
@@ -2537 +2537 @@
-		
+
@@ -2556 +2556 @@
-      
+
@@ -2569 +2569 @@
-	
+
@@ -2573 +2573 @@
-			 
+
@@ -2579,2 +2579,2 @@
-	
-	info->count = 0;	
+
+	info->count = 0;
@@ -2597 +2597 @@
-	
+
@@ -2618 +2618 @@
-	 
+
@@ -2621 +2621 @@
-	
+
@@ -2633 +2633 @@
-	
+
@@ -2641 +2641 @@
-		
+
@@ -2643 +2643 @@
-		
+
@@ -2649 +2649 @@
-		
+
@@ -2653 +2653 @@
-		
+
@@ -2658 +2658 @@
-			
+
@@ -2663 +2663 @@
-		
+
@@ -2667 +2667 @@
-				 
+
@@ -2670 +2670 @@
-	
+
@@ -2673 +2673 @@
-	
+
@@ -2677 +2677 @@
-	
+
@@ -2681 +2681 @@
-			 
+
@@ -2684 +2684 @@
-		
+
@@ -2694 +2694 @@
-	/* verify range of specified line number */	
+	/* verify range of specified line number */
@@ -2708 +2708 @@
-	
+
@@ -2711 +2711 @@
-		
+
@@ -2724 +2724 @@
-	
+
@@ -2755,2 +2755,2 @@
-	
-cleanup:			
+
+cleanup:
@@ -2763 +2763 @@
-	
+
@@ -2784 +2784 @@
-	
+
@@ -2808 +2808 @@
-			ret += sprintf(buf+ret, " rxshort:%d", info->icount.rxshort);	
+			ret += sprintf(buf+ret, " rxshort:%d", info->icount.rxshort);
@@ -2823 +2823 @@
-			ret += sprintf(buf+ret, " brk:%d", info->icount.brk);	
+			ret += sprintf(buf+ret, " brk:%d", info->icount.brk);
@@ -2827 +2827 @@
-	
+
@@ -2830 +2830 @@
-	
+
@@ -2834 +2834 @@
-	
+
@@ -2846 +2846 @@
-	
+
@@ -2848 +2848 @@
-	
+
@@ -2905 +2905 @@
-	}	
+	}
@@ -2918 +2918 @@
- * 	
+ *
@@ -2926 +2926 @@
-	
+
@@ -2934 +2934 @@
-	
+
@@ -2937 +2937 @@
-	else {	
+	else {
@@ -2943 +2943 @@
-	
+
@@ -2948 +2948 @@
-	
+
@@ -3063 +3063 @@
-	
+
@@ -3084 +3084 @@
-			
+
@@ -3088 +3088 @@
-	
+
@@ -3096 +3096 @@
-static void __exit synclink_cs_exit(void) 
+static void __exit synclink_cs_exit(void)
@@ -3109,2 +3109,2 @@
-	/* note:standard BRG mode is broken in V3.2 chip 
-	 * so enhanced mode is always used 
+	/* note:standard BRG mode is broken in V3.2 chip
+	 * so enhanced mode is always used
@@ -3129 +3129 @@
-		 */ 
+		 */
@@ -3143 +3143 @@
-	
+
@@ -3155 +3155 @@
-	 */ 
+	 */
@@ -3157,2 +3157,2 @@
-	
-	/* channel B RTS is used to enable AUXCLK driver on SP505 */ 
+
+	/* channel B RTS is used to enable AUXCLK driver on SP505 */
@@ -3162 +3162 @@
-	
+
@@ -3172 +3172 @@
-	 */ 
+	 */
@@ -3174 +3174 @@
-	
+
@@ -3185 +3185 @@
-	 */ 
+	 */
@@ -3187 +3187 @@
-	
+
@@ -3199 +3199 @@
-	 */ 
+	 */
@@ -3204 +3204 @@
-	
+
@@ -3215 +3215 @@
-	 */ 
+	 */
@@ -3217 +3217 @@
-	
+
@@ -3220 +3220 @@
-	 */ 
+	 */
@@ -3227 +3227 @@
-static void loopback_enable(MGSLPC_INFO *info) 
+static void loopback_enable(MGSLPC_INFO *info)
@@ -3230,2 +3230,2 @@
-	
-	/* CCR1:02..00  CM[2..0] Clock Mode = 111 (clock mode 7) */ 
+
+	/* CCR1:02..00  CM[2..0] Clock Mode = 111 (clock mode 7) */
@@ -3234,2 +3234,2 @@
-	
-	/* CCR2:04 SSEL Clock source select, 1=submode b */ 
+
+	/* CCR2:04 SSEL Clock source select, 1=submode b */
@@ -3238,2 +3238,2 @@
-	
-	/* set LinkSpeed if available, otherwise default to 2Mbps */ 
+
+	/* set LinkSpeed if available, otherwise default to 2Mbps */
@@ -3244,2 +3244,2 @@
-	
-	/* MODE:00 TLP Test Loop, 1=loopback enabled */ 
+
+	/* MODE:00 TLP Test Loop, 1=loopback enabled */
@@ -3255 +3255 @@
-	/* disable all interrupts */ 
+	/* disable all interrupts */
@@ -3259,2 +3259,2 @@
-	
-	/* assume clock mode 0a, rcv=RxC xmt=TxC */ 
+
+	/* assume clock mode 0a, rcv=RxC xmt=TxC */
@@ -3264 +3264 @@
-		/* clock mode 7a, rcv = DPLL, xmt = DPLL */ 
+		/* clock mode 7a, rcv = DPLL, xmt = DPLL */
@@ -3268 +3268 @@
-		/* clock mode 7b, rcv = BRG, xmt = BRG */ 
+		/* clock mode 7b, rcv = BRG, xmt = BRG */
@@ -3273 +3273 @@
-			/* clock mode 6b, rcv = DPLL, xmt = BRG/16 */ 
+			/* clock mode 6b, rcv = DPLL, xmt = BRG/16 */
@@ -3277 +3277 @@
-			/* clock mode 6a, rcv = DPLL, xmt = TxC */ 
+			/* clock mode 6a, rcv = DPLL, xmt = TxC */
@@ -3281 +3281 @@
-		/* clock mode 0b, rcv = RxC, xmt = BRG */ 
+		/* clock mode 0b, rcv = RxC, xmt = BRG */
@@ -3284 +3284 @@
-	
+
@@ -3296 +3296 @@
-	 */ 
+	 */
@@ -3300,2 +3300,2 @@
-	
-	/* preserve RTS state */ 
+
+	/* preserve RTS state */
@@ -3305 +3305 @@
-	
+
@@ -3315 +3315 @@
-	 */ 
+	 */
@@ -3333 +3333 @@
-	
+
@@ -3344 +3344 @@
-	 */ 
+	 */
@@ -3347 +3347 @@
-	
+
@@ -3359 +3359 @@
-	 */ 
+	 */
@@ -3371 +3371 @@
-	
+
@@ -3383 +3383 @@
-	 */ 
+	 */
@@ -3402,2 +3402,2 @@
-	
-	/* PRE - Preamble pattern */ 
+
+	/* PRE - Preamble pattern */
@@ -3413 +3413 @@
-	
+
@@ -3424 +3424 @@
-	 */ 
+	 */
@@ -3431 +3431 @@
-	
+
@@ -3436 +3436 @@
-	 */ 
+	 */
@@ -3438 +3438 @@
-	
+
@@ -3448 +3448 @@
-	 */ 
+	 */
@@ -3459 +3459 @@
-		/* PVR[3] 1=AUTO CTS active */ 
+		/* PVR[3] 1=AUTO CTS active */
@@ -3470 +3470 @@
-	
+
@@ -3480 +3480 @@
-	 */ 
+	 */
@@ -3495,2 +3495,2 @@
-			 
-	/* MODE:03 RAC Receiver Active, 0=inactive */ 
+
+	/* MODE:03 RAC Receiver Active, 0=inactive */
@@ -3513 +3513 @@
-	/* MODE:03 RAC Receiver Active, 1=active */ 
+	/* MODE:03 RAC Receiver Active, 1=active */
@@ -3524 +3524 @@
-			 
+
@@ -3562,2 +3562,2 @@
-			 
-	del_timer(&info->tx_timer);	
+
+	del_timer(&info->tx_timer);
@@ -3573 +3573 @@
-	/* power up both channels (set BIT7) */ 
+	/* power up both channels (set BIT7) */
@@ -3578,2 +3578,2 @@
-	
-	/* disable all interrupts */ 
+
+	/* disable all interrupts */
@@ -3583 +3583 @@
-	
+
@@ -3593 +3593 @@
-	 */ 
+	 */
@@ -3595 +3595 @@
-	
+
@@ -3607 +3607 @@
-	
+
@@ -3617 +3617 @@
-	 */ 
+	 */
@@ -3625 +3625 @@
-	/* disable all interrupts */ 
+	/* disable all interrupts */
@@ -3629 +3629 @@
-	
+
@@ -3642 +3642 @@
-	 */ 
+	 */
@@ -3646,2 +3646,2 @@
-	
-	/* preserve RTS state */ 
+
+	/* preserve RTS state */
@@ -3651 +3651 @@
-	
+
@@ -3661 +3661 @@
-	 */ 
+	 */
@@ -3663 +3663 @@
-	
+
@@ -3672 +3672 @@
-	 */ 
+	 */
@@ -3674 +3674 @@
-	
+
@@ -3686 +3686 @@
-	 */ 
+	 */
@@ -3688 +3688 @@
-	
+
@@ -3695 +3695 @@
-	 */ 
+	 */
@@ -3697 +3697 @@
-	
+
@@ -3707 +3707 @@
-	 */ 
+	 */
@@ -3710 +3710 @@
-	
+
@@ -3720 +3720 @@
-	 */ 
+	 */
@@ -3735 +3735 @@
-	
+
@@ -3747 +3747 @@
-	 */ 
+	 */
@@ -3749 +3749 @@
-	
+
@@ -3753 +3753 @@
-	 */ 
+	 */
@@ -3755 +3755 @@
-	
+
@@ -3765 +3765 @@
-	 */ 
+	 */
@@ -3772,2 +3772,2 @@
-	
-	/* MODE:03 RAC Receiver Active, 1=active */ 
+
+	/* MODE:03 RAC Receiver Active, 1=active */
@@ -3778 +3778 @@
-		/* PVR[3] 1=AUTO CTS active */ 
+		/* PVR[3] 1=AUTO CTS active */
@@ -3794 +3794 @@
-	/* Note: ESCC2 only supports flags and one idle modes */ 
+	/* Note: ESCC2 only supports flags and one idle modes */
@@ -3806,2 +3806,2 @@
-	
-	/* preserve DTR and RTS */ 
+
+	/* preserve DTR and RTS */
@@ -3876 +3876 @@
-	
+
@@ -3916 +3916 @@
-			
+
@@ -3918,2 +3918,2 @@
-		trace_block(info, buf->data, framesize, 0);	
-		
+		trace_block(info, buf->data, framesize, 0);
+
@@ -3956 +3956 @@
-	static unsigned char patterns[] = 
+	static unsigned char patterns[] =
@@ -4005 +4005 @@
-	
+
@@ -4011 +4011 @@
-	
+
@@ -4045 +4045 @@
-		
+
@@ -4051 +4051 @@
-			
+
@@ -4063 +4063 @@
-		
+
@@ -4076 +4076 @@
-	
+
@@ -4089 +4089 @@
-	
+
--- ./projects/linux/linux-2.6.24/drivers/char/pcmcia/synclink_cs.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/pcmcia/synclink_cs.c	2008-04-17 04:49:44.000000000 +0200
@@ -59,0 +60 @@
+#include <linux/synclink.h>
@@ -90,2 +90,0 @@
-#include "linux/synclink.h"
-
--- ./projects/linux/linux-2.6.25/drivers/char/pcmcia/synclink_cs.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/pcmcia/synclink_cs.c	2008-07-13 23:51:29.000000000 +0200
@@ -192,2 +192,2 @@
-	int bh_running;
-	int bh_requested;
+	bool bh_running;
+	bool bh_requested;
@@ -200,2 +200,2 @@
-	int rx_enabled;
-	int rx_overflow;
+	bool rx_enabled;
+	bool rx_overflow;
@@ -203,3 +203,3 @@
-	int tx_enabled;
-	int tx_active;
-	int tx_aborting;
+	bool tx_enabled;
+	bool tx_active;
+	bool tx_aborting;
@@ -219 +219 @@
-	char irq_occurred;		/* for diagnostics use */
+	bool irq_occurred;		/* for diagnostics use */
@@ -224 +224 @@
-	BOOLEAN drop_rts_on_tx_done;
+	bool drop_rts_on_tx_done;
@@ -405,2 +405,2 @@
-static BOOLEAN register_test(MGSLPC_INFO *info);
-static BOOLEAN irq_test(MGSLPC_INFO *info);
+static bool register_test(MGSLPC_INFO *info);
+static bool irq_test(MGSLPC_INFO *info);
@@ -414 +414 @@
-static int  rx_get_frame(MGSLPC_INFO *info);
+static bool rx_get_frame(MGSLPC_INFO *info);
@@ -506 +505,0 @@
- * ldisc_flush_buffer - flush line discipline receive buffers
@@ -510,10 +508,0 @@
-static void ldisc_flush_buffer(struct tty_struct *tty)
-{
-	struct tty_ldisc *ld = tty_ldisc_ref(tty);
-	if (ld) {
-		if (ld->flush_buffer)
-			ld->flush_buffer(tty);
-		tty_ldisc_deref(ld);
-	}
-}
-
@@ -722 +711 @@
-static inline int mgslpc_paranoia_check(MGSLPC_INFO *info,
+static inline bool mgslpc_paranoia_check(MGSLPC_INFO *info,
@@ -733 +722 @@
-		return 1;
+		return true;
@@ -737 +726 @@
-		return 1;
+		return true;
@@ -741 +730 @@
-		return 1;
+		return true;
@@ -743 +732 @@
-	return 0;
+	return false;
@@ -755 +744 @@
-static BOOLEAN wait_command_complete(MGSLPC_INFO *info, unsigned char channel)
+static bool wait_command_complete(MGSLPC_INFO *info, unsigned char channel)
@@ -762 +751 @@
-			return FALSE;
+			return false;
@@ -764 +753 @@
-	return TRUE;
+	return true;
@@ -828,2 +817,2 @@
-		info->bh_running   = 0;
-		info->bh_requested = 0;
+		info->bh_running = false;
+		info->bh_requested = false;
@@ -849 +838 @@
-	info->bh_running = 1;
+	info->bh_running = true;
@@ -916 +905 @@
-		info->rx_overflow = 1;
+		info->rx_overflow = true;
@@ -1035,2 +1024,2 @@
-	info->tx_active = 0;
-	info->tx_aborting = 0;
+	info->tx_active = false;
+	info->tx_aborting = false;
@@ -1050 +1039 @@
-		info->drop_rts_on_tx_done = 0;
+		info->drop_rts_on_tx_done = false;
@@ -1084 +1073 @@
-			info->tx_active = 0;
+			info->tx_active = false;
@@ -1228 +1217 @@
-static irqreturn_t mgslpc_isr(int irq, void *dev_id)
+static irqreturn_t mgslpc_isr(int dummy, void *dev_id)
@@ -1230 +1219 @@
-	MGSLPC_INFO * info = (MGSLPC_INFO *)dev_id;
+	MGSLPC_INFO *info = dev_id;
@@ -1236,3 +1225 @@
-		printk("mgslpc_isr(%d) entry.\n", irq);
-	if (!info)
-		return IRQ_NONE;
+		printk("mgslpc_isr(%d) entry.\n", info->irq_level);
@@ -1266 +1253 @@
-				info->irq_occurred = 1;
+				info->irq_occurred = true;
@@ -1323 +1310 @@
-		info->bh_requested = 1;
+		info->bh_requested = true;
@@ -1330 +1317 @@
-		       __FILE__,__LINE__,irq);
+		       __FILE__, __LINE__, info->irq_level);
@@ -1561 +1548 @@
-static void mgslpc_put_char(struct tty_struct *tty, unsigned char ch)
+static int mgslpc_put_char(struct tty_struct *tty, unsigned char ch)
@@ -1572 +1559 @@
-		return;
+		return 0;
@@ -1575 +1562 @@
-		return;
+		return 0;
@@ -1587,0 +1575 @@
+	return 1;
@@ -1995 +1983 @@
-		info->tx_aborting = TRUE;
+		info->tx_aborting = true;
@@ -2472,2 +2460 @@
-	if (tty->driver->flush_buffer)
-		tty->driver->flush_buffer(tty);
+	mgslpc_flush_buffer(tty);
@@ -2475 +2462 @@
-	ldisc_flush_buffer(tty);
+	tty_ldisc_flush(tty);
@@ -2594 +2581,2 @@
-	int		do_clocal = 0, extra_count = 0;
+	bool		do_clocal = false;
+	bool		extra_count = false;
@@ -2609 +2597 @@
-		do_clocal = 1;
+		do_clocal = true;
@@ -2627 +2615 @@
-		extra_count = 1;
+		extra_count = true;
@@ -3498,2 +3486,2 @@
-	info->rx_enabled = 0;
-	info->rx_overflow = 0;
+	info->rx_enabled = false;
+	info->rx_overflow = false;
@@ -3509,2 +3497,2 @@
-	info->rx_enabled = 0;
-	info->rx_overflow = 0;
+	info->rx_enabled = false;
+	info->rx_overflow = false;
@@ -3515 +3503 @@
-	info->rx_enabled = 1;
+	info->rx_enabled = true;
@@ -3528 +3516 @@
-		info->drop_rts_on_tx_done = 0;
+		info->drop_rts_on_tx_done = false;
@@ -3535 +3523 @@
-				info->drop_rts_on_tx_done = 1;
+				info->drop_rts_on_tx_done = true;
@@ -3541 +3529 @@
-				info->tx_active = 1;
+				info->tx_active = true;
@@ -3545 +3533 @@
-			info->tx_active = 1;
+			info->tx_active = true;
@@ -3553 +3541 @@
-		info->tx_enabled = 1;
+		info->tx_enabled = true;
@@ -3564,2 +3552,2 @@
-	info->tx_enabled = 0;
-	info->tx_active  = 0;
+	info->tx_enabled = false;
+	info->tx_active = false;
@@ -3865 +3853 @@
- * Returns 1 if frame returned, otherwise 0
+ * Returns true if frame returned, otherwise false
@@ -3867 +3855 @@
-static int rx_get_frame(MGSLPC_INFO *info)
+static bool rx_get_frame(MGSLPC_INFO *info)
@@ -3874 +3862 @@
-	int return_frame = 0;
+	bool return_frame = false;
@@ -3877 +3865 @@
-		return 0;
+		return false;
@@ -3896 +3884 @@
-				return_frame = 1;
+				return_frame = true;
@@ -3907 +3895 @@
-		return_frame = 1;
+		return_frame = true;
@@ -3950 +3938 @@
-	return 1;
+	return true;
@@ -3953 +3941 @@
-static BOOLEAN register_test(MGSLPC_INFO *info)
+static bool register_test(MGSLPC_INFO *info)
@@ -3959 +3947 @@
-	BOOLEAN rc = TRUE;
+	bool rc = true;
@@ -3970 +3958 @@
-			rc = FALSE;
+			rc = false;
@@ -3979 +3967 @@
-static BOOLEAN irq_test(MGSLPC_INFO *info)
+static bool irq_test(MGSLPC_INFO *info)
@@ -3987 +3975 @@
-	info->testing_irq = TRUE;
+	info->testing_irq = true;
@@ -3990 +3978 @@
-	info->irq_occurred = FALSE;
+	info->irq_occurred = false;
@@ -4005 +3993 @@
-	info->testing_irq = FALSE;
+	info->testing_irq = false;
@@ -4011 +3999 @@
-	return info->irq_occurred ? TRUE : FALSE;
+	return info->irq_occurred;
@@ -4084 +4072 @@
-	info->tx_active = 0;
+	info->tx_active = false;
--- ./projects/linux/linux-2.6.26/drivers/char/pcmcia/synclink_cs.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/char/pcmcia/synclink_cs.c	2008-10-10 00:13:53.000000000 +0200
@@ -235 +234,0 @@
-	int dosyncppp;
@@ -462 +460,0 @@
-static int dosyncppp[MAX_DEVICE_COUNT] = {1,1,1,1};
@@ -468 +465,0 @@
-module_param_array(dosyncppp, int, NULL, 0);
@@ -517,2 +514,2 @@
-		if (ld->receive_buf)
-			ld->receive_buf(tty, data, flags, count);
+		if (ld->ops->receive_buf)
+			ld->ops->receive_buf(tty, data, flags, count);
@@ -2233 +2230 @@
-static void mgslpc_break(struct tty_struct *tty, int break_state)
+static int mgslpc_break(struct tty_struct *tty, int break_state)
@@ -2243 +2240 @@
-		return;
+		return -EINVAL;
@@ -2250,0 +2248 @@
+	return 0;
@@ -2917 +2914,0 @@
-		info->dosyncppp = dosyncppp[info->line];
@@ -3889,3 +3886,2 @@
-			struct net_device_stats *stats = hdlc_stats(info->netdev);
-			stats->rx_errors++;
-			stats->rx_frame_errors++;
+			info->netdev->stats.rx_errors++;
+			info->netdev->stats.rx_frame_errors++;
@@ -4147 +4142,0 @@
-	struct net_device_stats *stats = hdlc_stats(dev);
@@ -4162,2 +4157,2 @@
-	stats->tx_packets++;
-	stats->tx_bytes += skb->len;
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
@@ -4379 +4373,0 @@
-	struct net_device_stats *stats = hdlc_stats(dev);
@@ -4385,2 +4379,2 @@
-	stats->tx_errors++;
-	stats->tx_aborted_errors++;
+	dev->stats.tx_errors++;
+	dev->stats.tx_aborted_errors++;
@@ -4419 +4412,0 @@
-	struct net_device_stats *stats = hdlc_stats(dev);
@@ -4426 +4419 @@
-		stats->rx_dropped++;
+		dev->stats.rx_dropped++;
@@ -4430 +4423 @@
-	memcpy(skb_put(skb, size),buf,size);
+	memcpy(skb_put(skb, size), buf, size);
@@ -4432 +4425 @@
-	skb->protocol = hdlc_type_trans(skb, info->netdev);
+	skb->protocol = hdlc_type_trans(skb, dev);
@@ -4434,2 +4427,2 @@
-	stats->rx_packets++;
-	stats->rx_bytes += size;
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += size;
@@ -4439 +4432 @@
-	info->netdev->last_rx = jiffies;
+	dev->last_rx = jiffies;
--- ./projects/linux/linux-2.6.27/drivers/char/pcmcia/synclink_cs.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/char/pcmcia/synclink_cs.c	2008-12-25 00:26:37.000000000 +0100
@@ -557 +557 @@
-    link->irq.Attributes = IRQ_TYPE_EXCLUSIVE;
+    link->irq.Attributes = IRQ_TYPE_DYNAMIC_SHARING;
@@ -604 +604 @@
-    CS_CHECK(ParseTuple, pcmcia_parse_tuple(link, &tuple, &parse));
+    CS_CHECK(ParseTuple, pcmcia_parse_tuple(&tuple, &parse));
--- ./projects/linux/linux-2.6.28/drivers/char/pcmcia/synclink_cs.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/char/pcmcia/synclink_cs.c	2009-03-24 00:12:14.000000000 +0100
@@ -140,0 +141 @@
+	struct tty_port		port;
@@ -143,2 +143,0 @@
-	int			flags;
-	int			count;		/* count of opens */
@@ -146,2 +144,0 @@
-	unsigned short		close_delay;
-	unsigned short		closing_wait;	/* time to wait before closing */
@@ -151 +147,0 @@
-	struct tty_struct 	*tty;
@@ -154 +149,0 @@
-	int			blocked_open;	/* # of blocked opens */
@@ -173,3 +167,0 @@
-	wait_queue_head_t	open_wait;
-	wait_queue_head_t	close_wait;
-
@@ -378 +370 @@
-static void tx_start(MGSLPC_INFO *info);
+static void tx_start(MGSLPC_INFO *info, struct tty_struct *tty);
@@ -392 +384,2 @@
-static int ioctl_common(MGSLPC_INFO *info, unsigned int cmd, unsigned long arg);
+static int carrier_raised(struct tty_port *port);
+static void raise_dtr_rts(struct tty_port *port);
@@ -413 +406 @@
-static bool rx_get_frame(MGSLPC_INFO *info);
+static bool rx_get_frame(MGSLPC_INFO *info, struct tty_struct *tty);
@@ -424 +417 @@
-static void bh_transmit(MGSLPC_INFO *info);
+static void bh_transmit(MGSLPC_INFO *info, struct tty_struct *tty);
@@ -435 +428 @@
-static int set_params(MGSLPC_INFO *info, MGSL_PARAMS __user *new_params);
+static int set_params(MGSLPC_INFO *info, MGSL_PARAMS __user *new_params, struct tty_struct *tty);
@@ -438 +431 @@
-static int set_txenable(MGSLPC_INFO *info, int enable);
+static int set_txenable(MGSLPC_INFO *info, int enable, struct tty_struct *tty);
@@ -477 +470 @@
-static void mgslpc_change_params(MGSLPC_INFO *info);
+static void mgslpc_change_params(MGSLPC_INFO *info, struct tty_struct *tty);
@@ -519,0 +513,5 @@
+static const struct tty_port_operations mgslpc_port_ops = {
+	.carrier_raised = carrier_raised,
+	.raise_dtr_rts = raise_dtr_rts
+};
+
@@ -534,0 +533,2 @@
+    tty_port_init(&info->port);
+    info->port.ops = &mgslpc_port_ops;
@@ -537,4 +537,2 @@
-    info->close_delay = 5*HZ/10;
-    info->closing_wait = 30*HZ;
-    init_waitqueue_head(&info->open_wait);
-    init_waitqueue_head(&info->close_wait);
+    info->port.close_delay = 5*HZ/10;
+    info->port.closing_wait = 30*HZ;
@@ -787 +785 @@
-	 	tx_start(info);
+	 	tx_start(info, tty);
@@ -825,0 +824 @@
+	struct tty_struct *tty;
@@ -835,0 +835 @@
+	tty = tty_port_tty_get(&info->port);
@@ -847 +847 @@
-			while(rx_get_frame(info));
+			while(rx_get_frame(info, tty));
@@ -850 +850 @@
-			bh_transmit(info);
+			bh_transmit(info, tty);
@@ -861,0 +862 @@
+	tty_kref_put(tty);
@@ -867 +868 @@
-static void bh_transmit(MGSLPC_INFO *info)
+static void bh_transmit(MGSLPC_INFO *info, struct tty_struct *tty)
@@ -869 +869,0 @@
-	struct tty_struct *tty = info->tty;
@@ -948 +948 @@
-static void rx_ready_async(MGSLPC_INFO *info, int tcd)
+static void rx_ready_async(MGSLPC_INFO *info, int tcd, struct tty_struct *tty)
@@ -953 +952,0 @@
- 	struct tty_struct *tty = info->tty;
@@ -1016 +1015 @@
-static void tx_done(MGSLPC_INFO *info)
+static void tx_done(MGSLPC_INFO *info, struct tty_struct *tty)
@@ -1045 +1044 @@
-		if (info->tty->stopped || info->tty->hw_stopped) {
+		if (tty->stopped || tty->hw_stopped) {
@@ -1053 +1052 @@
-static void tx_ready(MGSLPC_INFO *info)
+static void tx_ready(MGSLPC_INFO *info, struct tty_struct *tty)
@@ -1065 +1064 @@
-		if (info->tty->stopped || info->tty->hw_stopped) {
+		if (tty->stopped || tty->hw_stopped) {
@@ -1102 +1101 @@
-static void cts_change(MGSLPC_INFO *info)
+static void cts_change(MGSLPC_INFO *info, struct tty_struct *tty)
@@ -1115,2 +1114,2 @@
-	if (info->flags & ASYNC_CTS_FLOW) {
-		if (info->tty->hw_stopped) {
+	if (info->port.flags & ASYNC_CTS_FLOW) {
+		if (tty->hw_stopped) {
@@ -1120,3 +1119,3 @@
-				if (info->tty)
-					info->tty->hw_stopped = 0;
-				tx_start(info);
+				if (tty)
+					tty->hw_stopped = 0;
+				tx_start(info, tty);
@@ -1130,2 +1129,2 @@
-				if (info->tty)
-					info->tty->hw_stopped = 1;
+				if (tty)
+					tty->hw_stopped = 1;
@@ -1139 +1138 @@
-static void dcd_change(MGSLPC_INFO *info)
+static void dcd_change(MGSLPC_INFO *info, struct tty_struct *tty)
@@ -1161 +1160 @@
-	if (info->flags & ASYNC_CHECK_CD) {
+	if (info->port.flags & ASYNC_CHECK_CD) {
@@ -1166 +1165 @@
-			wake_up_interruptible(&info->open_wait);
+			wake_up_interruptible(&info->port.open_wait);
@@ -1170,2 +1169,2 @@
-			if (info->tty)
-				tty_hangup(info->tty);
+			if (tty)
+				tty_hangup(tty);
@@ -1216,0 +1216 @@
+	struct tty_struct *tty;
@@ -1226,0 +1227,2 @@
+	tty = tty_port_tty_get(&info->port);
+
@@ -1242 +1244 @@
-				dcd_change(info);
+				dcd_change(info, tty);
@@ -1244 +1246 @@
-				cts_change(info);
+				cts_change(info, tty);
@@ -1261,2 +1263,2 @@
-				if (info->flags & ASYNC_SAK)
-					do_SAK(info->tty);
+				if (info->port.flags & ASYNC_SAK)
+					do_SAK(tty);
@@ -1271 +1273 @@
-					rx_ready_async(info, isr & IRQ_RXEOM);
+					rx_ready_async(info, isr & IRQ_RXEOM, tty);
@@ -1280 +1282 @@
-				tx_done(info);
+				tx_done(info, tty);
@@ -1284 +1286 @@
-				tx_done(info);
+				tx_done(info, tty);
@@ -1287 +1289 @@
-				tx_ready(info);
+				tx_ready(info, tty);
@@ -1310,0 +1313 @@
+	tty_kref_put(tty);
@@ -1321 +1324 @@
-static int startup(MGSLPC_INFO * info)
+static int startup(MGSLPC_INFO * info, struct tty_struct *tty)
@@ -1328 +1331 @@
-	if (info->flags & ASYNC_INITIALIZED)
+	if (info->port.flags & ASYNC_INITIALIZED)
@@ -1355,2 +1358,2 @@
-  		if (capable(CAP_SYS_ADMIN) && info->tty)
-			set_bit(TTY_IO_ERROR, &info->tty->flags);
+  		if (capable(CAP_SYS_ADMIN) && tty)
+			set_bit(TTY_IO_ERROR, &tty->flags);
@@ -1362 +1365 @@
-	mgslpc_change_params(info);
+	mgslpc_change_params(info, tty);
@@ -1364,2 +1367,2 @@
-	if (info->tty)
-		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (tty)
+		clear_bit(TTY_IO_ERROR, &tty->flags);
@@ -1367 +1370 @@
-	info->flags |= ASYNC_INITIALIZED;
+	info->port.flags |= ASYNC_INITIALIZED;
@@ -1374 +1377 @@
-static void shutdown(MGSLPC_INFO * info)
+static void shutdown(MGSLPC_INFO * info, struct tty_struct *tty)
@@ -1378 +1381 @@
-	if (!(info->flags & ASYNC_INITIALIZED))
+	if (!(info->port.flags & ASYNC_INITIALIZED))
@@ -1405 +1408 @@
- 	if (!info->tty || info->tty->termios->c_cflag & HUPCL) {
+ 	if (!tty || tty->termios->c_cflag & HUPCL) {
@@ -1414,2 +1417,2 @@
-	if (info->tty)
-		set_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (tty)
+		set_bit(TTY_IO_ERROR, &tty->flags);
@@ -1417 +1420 @@
-	info->flags &= ~ASYNC_INITIALIZED;
+	info->port.flags &= ~ASYNC_INITIALIZED;
@@ -1420 +1423 @@
-static void mgslpc_program_hw(MGSLPC_INFO *info)
+static void mgslpc_program_hw(MGSLPC_INFO *info, struct tty_struct *tty)
@@ -1446 +1449 @@
-	if (info->netcount || info->tty->termios->c_cflag & CREAD)
+	if (info->netcount || (tty && (tty->termios->c_cflag & CREAD)))
@@ -1454 +1457 @@
-static void mgslpc_change_params(MGSLPC_INFO *info)
+static void mgslpc_change_params(MGSLPC_INFO *info, struct tty_struct *tty)
@@ -1459 +1462 @@
-	if (!info->tty || !info->tty->termios)
+	if (!tty || !tty->termios)
@@ -1466 +1469 @@
-	cflag = info->tty->termios->c_cflag;
+	cflag = tty->termios->c_cflag;
@@ -1513 +1516 @@
-		info->params.data_rate = tty_get_baud_rate(info->tty);
+		info->params.data_rate = tty_get_baud_rate(tty);
@@ -1523 +1526 @@
-		info->flags |= ASYNC_CTS_FLOW;
+		info->port.flags |= ASYNC_CTS_FLOW;
@@ -1525 +1528 @@
-		info->flags &= ~ASYNC_CTS_FLOW;
+		info->port.flags &= ~ASYNC_CTS_FLOW;
@@ -1528 +1531 @@
-		info->flags &= ~ASYNC_CHECK_CD;
+		info->port.flags &= ~ASYNC_CHECK_CD;
@@ -1530 +1533 @@
-		info->flags |= ASYNC_CHECK_CD;
+		info->port.flags |= ASYNC_CHECK_CD;
@@ -1535 +1538 @@
-	if (I_INPCK(info->tty))
+	if (I_INPCK(tty))
@@ -1537 +1540 @@
-	if (I_IGNPAR(info->tty))
+	if (I_IGNPAR(tty))
@@ -1540 +1543 @@
-	mgslpc_program_hw(info);
+	mgslpc_program_hw(info, tty);
@@ -1600 +1603 @@
-	 	tx_start(info);
+	 	tx_start(info, tty);
@@ -1662 +1665 @@
-		 	tx_start(info);
+		 	tx_start(info, tty);
@@ -1767 +1770 @@
-		 	tx_start(info);
+		 	tx_start(info, tty);
@@ -1865 +1868 @@
-static int set_params(MGSLPC_INFO * info, MGSL_PARAMS __user *new_params)
+static int set_params(MGSLPC_INFO * info, MGSL_PARAMS __user *new_params, struct tty_struct *tty)
@@ -1886 +1889 @@
- 	mgslpc_change_params(info);
+ 	mgslpc_change_params(info, tty);
@@ -1947 +1950 @@
-static int set_txenable(MGSLPC_INFO * info, int enable)
+static int set_txenable(MGSLPC_INFO * info, int enable, struct tty_struct *tty)
@@ -1957 +1960 @@
-			tx_start(info);
+			tx_start(info, tty);
@@ -2265,0 +2269,5 @@
+	int error;
+	struct mgsl_icount cnow;	/* kernel counter temps */
+	struct serial_icounter_struct __user *p_cuser;	/* user space */
+	void __user *argp = (void __user *)arg;
+	unsigned long flags;
@@ -2280,11 +2287,0 @@
-	return ioctl_common(info, cmd, arg);
-}
-
-static int ioctl_common(MGSLPC_INFO *info, unsigned int cmd, unsigned long arg)
-{
-	int error;
-	struct mgsl_icount cnow;	/* kernel counter temps */
-	struct serial_icounter_struct __user *p_cuser;	/* user space */
-	void __user *argp = (void __user *)arg;
-	unsigned long flags;
-
@@ -2295 +2292 @@
-		return set_params(info, argp);
+		return set_params(info, argp, tty);
@@ -2305 +2302 @@
-		return set_txenable(info,(int)arg);
+		return set_txenable(info,(int)arg, tty);
@@ -2372 +2369 @@
-	mgslpc_change_params(info);
+	mgslpc_change_params(info, tty);
@@ -2406,0 +2404 @@
+	struct tty_port *port = &info->port;
@@ -2413,4 +2411 @@
-			 __FILE__,__LINE__, info->device_name, info->count);
-
-	if (!info->count)
-		return;
+			 __FILE__,__LINE__, info->device_name, port->count);
@@ -2418,13 +2413 @@
-	if (tty_hung_up_p(filp))
-		goto cleanup;
-
-	if ((tty->count == 1) && (info->count != 1)) {
-		/*
-		 * tty->count is 1 and the tty structure will be freed.
-		 * info->count should be one in this case.
-		 * if it's not, correct it so that the port is shutdown.
-		 */
-		printk("mgslpc_close: bad refcount; tty->count is 1, "
-		       "info->count is %d\n", info->count);
-		info->count = 1;
-	}
+	WARN_ON(!port->count);
@@ -2432,4 +2415 @@
-	info->count--;
-
-	/* if at least one open remaining, leave hardware active */
-	if (info->count)
+	if (tty_port_close_start(port, tty, filp) == 0)
@@ -2438,18 +2418 @@
-	info->flags |= ASYNC_CLOSING;
-
-	/* set tty->closing to notify line discipline to
-	 * only process XON/XOFF characters. Only the N_TTY
-	 * discipline appears to use this (ppp does not).
-	 */
-	tty->closing = 1;
-
-	/* wait for transmit data to clear all layers */
-
-	if (info->closing_wait != ASYNC_CLOSING_WAIT_NONE) {
-		if (debug_level >= DEBUG_LEVEL_INFO)
-			printk("%s(%d):mgslpc_close(%s) calling tty_wait_until_sent\n",
-				 __FILE__,__LINE__, info->device_name );
-		tty_wait_until_sent(tty, info->closing_wait);
-	}
-
- 	if (info->flags & ASYNC_INITIALIZED)
+ 	if (port->flags & ASYNC_INITIALIZED)
@@ -2461,17 +2424,4 @@
-
-	shutdown(info);
-
-	tty->closing = 0;
-	info->tty = NULL;
-
-	if (info->blocked_open) {
-		if (info->close_delay) {
-			msleep_interruptible(jiffies_to_msecs(info->close_delay));
-		}
-		wake_up_interruptible(&info->open_wait);
-	}
-
-	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-
-	wake_up_interruptible(&info->close_wait);
-
+	shutdown(info, tty);
+	
+	tty_port_close_end(port, tty);
+	tty_port_tty_set(port, NULL);
@@ -2481 +2431 @@
-			tty->driver->name, info->count);
+			tty->driver->name, port->count);
@@ -2501 +2451 @@
-	if (!(info->flags & ASYNC_INITIALIZED))
+	if (!(info->port.flags & ASYNC_INITIALIZED))
@@ -2562,7 +2512,2 @@
-	shutdown(info);
-
-	info->count = 0;
-	info->flags &= ~ASYNC_NORMAL_ACTIVE;
-	info->tty = NULL;
-
-	wake_up_interruptible(&info->open_wait);
+	shutdown(info, tty);
+	tty_port_hangup(&info->port);
@@ -2571,5 +2516 @@
-/* Block the current process until the specified port
- * is ready to be opened.
- */
-static int block_til_ready(struct tty_struct *tty, struct file *filp,
-			   MGSLPC_INFO *info)
+static int carrier_raised(struct tty_port *port)
@@ -2577,81 +2518,2 @@
-	DECLARE_WAITQUEUE(wait, current);
-	int		retval;
-	bool		do_clocal = false;
-	bool		extra_count = false;
-	unsigned long	flags;
-
-	if (debug_level >= DEBUG_LEVEL_INFO)
-		printk("%s(%d):block_til_ready on %s\n",
-			 __FILE__,__LINE__, tty->driver->name );
-
-	if (filp->f_flags & O_NONBLOCK || tty->flags & (1 << TTY_IO_ERROR)){
-		/* nonblock mode is set or port is not enabled */
-		/* just verify that callout device is not active */
-		info->flags |= ASYNC_NORMAL_ACTIVE;
-		return 0;
-	}
-
-	if (tty->termios->c_cflag & CLOCAL)
-		do_clocal = true;
-
-	/* Wait for carrier detect and the line to become
-	 * free (i.e., not in use by the callout).  While we are in
-	 * this loop, info->count is dropped by one, so that
-	 * mgslpc_close() knows when to free things.  We restore it upon
-	 * exit, either normal or abnormal.
-	 */
-
-	retval = 0;
-	add_wait_queue(&info->open_wait, &wait);
-
-	if (debug_level >= DEBUG_LEVEL_INFO)
-		printk("%s(%d):block_til_ready before block on %s count=%d\n",
-			 __FILE__,__LINE__, tty->driver->name, info->count );
-
-	spin_lock_irqsave(&info->lock, flags);
-	if (!tty_hung_up_p(filp)) {
-		extra_count = true;
-		info->count--;
-	}
-	spin_unlock_irqrestore(&info->lock, flags);
-	info->blocked_open++;
-
-	while (1) {
-		if ((tty->termios->c_cflag & CBAUD)) {
-			spin_lock_irqsave(&info->lock,flags);
-			info->serial_signals |= SerialSignal_RTS + SerialSignal_DTR;
-		 	set_signals(info);
-			spin_unlock_irqrestore(&info->lock,flags);
-		}
-
-		set_current_state(TASK_INTERRUPTIBLE);
-
-		if (tty_hung_up_p(filp) || !(info->flags & ASYNC_INITIALIZED)){
-			retval = (info->flags & ASYNC_HUP_NOTIFY) ?
-					-EAGAIN : -ERESTARTSYS;
-			break;
-		}
-
-		spin_lock_irqsave(&info->lock,flags);
-	 	get_signals(info);
-		spin_unlock_irqrestore(&info->lock,flags);
-
- 		if (!(info->flags & ASYNC_CLOSING) &&
- 		    (do_clocal || (info->serial_signals & SerialSignal_DCD)) ) {
- 			break;
-		}
-
-		if (signal_pending(current)) {
-			retval = -ERESTARTSYS;
-			break;
-		}
-
-		if (debug_level >= DEBUG_LEVEL_INFO)
-			printk("%s(%d):block_til_ready blocking on %s count=%d\n",
-				 __FILE__,__LINE__, tty->driver->name, info->count );
-
-		schedule();
-	}
-
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&info->open_wait, &wait);
+	MGSLPC_INFO *info = container_of(port, MGSLPC_INFO, port);
+	unsigned long flags;
@@ -2659,3 +2521,3 @@
-	if (extra_count)
-		info->count++;
-	info->blocked_open--;
+	spin_lock_irqsave(&info->lock,flags);
+ 	get_signals(info);
+	spin_unlock_irqrestore(&info->lock,flags);
@@ -2663,3 +2525,4 @@
-	if (debug_level >= DEBUG_LEVEL_INFO)
-		printk("%s(%d):block_til_ready after blocking on %s count=%d\n",
-			 __FILE__,__LINE__, tty->driver->name, info->count );
+	if (info->serial_signals & SerialSignal_DCD)
+		return 1;
+	return 0;
+}
@@ -2667,2 +2530,4 @@
-	if (!retval)
-		info->flags |= ASYNC_NORMAL_ACTIVE;
+static void raise_dtr_rts(struct tty_port *port)
+{
+	MGSLPC_INFO *info = container_of(port, MGSLPC_INFO, port);
+	unsigned long flags;
@@ -2670 +2535,4 @@
-	return retval;
+	spin_lock_irqsave(&info->lock,flags);
+	info->serial_signals |= SerialSignal_RTS + SerialSignal_DTR;
+	set_signals(info);
+	spin_unlock_irqrestore(&info->lock,flags);
@@ -2672,0 +2541 @@
+
@@ -2675,0 +2545 @@
+	struct tty_port *port;
@@ -2693,0 +2564 @@
+	port = &info->port;
@@ -2695 +2566 @@
-	info->tty = tty;
+	tty_port_tty_set(port, tty);
@@ -2699 +2570 @@
-			 __FILE__,__LINE__,tty->driver->name, info->count);
+			 __FILE__,__LINE__,tty->driver->name, port->count);
@@ -2702,4 +2573,4 @@
-	if (tty_hung_up_p(filp) || info->flags & ASYNC_CLOSING){
-		if (info->flags & ASYNC_CLOSING)
-			interruptible_sleep_on(&info->close_wait);
-		retval = ((info->flags & ASYNC_HUP_NOTIFY) ?
+	if (tty_hung_up_p(filp) || port->flags & ASYNC_CLOSING){
+		if (port->flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&port->close_wait);
+		retval = ((port->flags & ASYNC_HUP_NOTIFY) ?
@@ -2710 +2581 @@
-	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+	tty->low_latency = (port->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
@@ -2718 +2589,3 @@
-	info->count++;
+	spin_lock(&port->lock);
+	port->count++;
+	spin_unlock(&port->lock);
@@ -2721 +2594 @@
-	if (info->count == 1) {
+	if (port->count == 1) {
@@ -2723 +2596 @@
-		retval = startup(info);
+		retval = startup(info, tty);
@@ -2728 +2601 @@
-	retval = block_til_ready(tty, filp, info);
+	retval = tty_port_block_til_ready(&info->port, tty, filp);
@@ -2742,7 +2614,0 @@
-	if (retval) {
-		if (tty->count == 1)
-			info->tty = NULL; /* tty layer will release tty struct */
-		if(info->count)
-			info->count--;
-	}
-
@@ -3503 +3369 @@
-static void tx_start(MGSLPC_INFO *info)
+static void tx_start(MGSLPC_INFO *info, struct tty_struct *tty)
@@ -3527 +3393 @@
-				tx_ready(info);
+				tx_ready(info, tty);
@@ -3531 +3397 @@
-			tx_ready(info);
+			tx_ready(info, tty);
@@ -3852 +3718 @@
-static bool rx_get_frame(MGSLPC_INFO *info)
+static bool rx_get_frame(MGSLPC_INFO *info, struct tty_struct *tty)
@@ -3858 +3723,0 @@
-	struct tty_struct *tty = info->tty;
@@ -4078 +3943,5 @@
-		bh_transmit(info);
+	{
+		struct tty_struct *tty = tty_port_tty_get(&info->port);
+		bh_transmit(info, tty);
+		tty_kref_put(tty);
+	}
@@ -4096,0 +3966 @@
+	struct tty_struct *tty;
@@ -4101 +3971 @@
-	if (info->count)
+	if (info->port.count)
@@ -4126,2 +3996,5 @@
-	if (info->netcount)
-		mgslpc_program_hw(info);
+	if (info->netcount) {
+		tty = tty_port_tty_get(&info->port);
+		mgslpc_program_hw(info, tty);
+		tty_kref_put(tty);
+	}
@@ -4168,2 +4041,5 @@
-	if (!info->tx_active)
-	 	tx_start(info);
+	if (!info->tx_active) {
+		struct tty_struct *tty = tty_port_tty_get(&info->port);
+	 	tx_start(info, tty);
+	 	tty_kref_put(tty);
+	}
@@ -4185,0 +4062 @@
+	struct tty_struct *tty;
@@ -4198 +4075 @@
-	if (info->count != 0 || info->netcount != 0) {
+	if (info->port.count != 0 || info->netcount != 0) {
@@ -4205,0 +4083 @@
+	tty = tty_port_tty_get(&info->port);
@@ -4207 +4085,2 @@
-	if ((rc = startup(info)) != 0) {
+	if ((rc = startup(info, tty)) != 0) {
+		tty_kref_put(tty);
@@ -4213 +4091,0 @@
-
@@ -4216 +4094,2 @@
-	mgslpc_program_hw(info);
+	mgslpc_program_hw(info, tty);
+	tty_kref_put(tty);
@@ -4243,0 +4123 @@
+	struct tty_struct *tty = tty_port_tty_get(&info->port);
@@ -4252,2 +4132,2 @@
-	shutdown(info);
-
+	shutdown(info, tty);
+	tty_kref_put(tty);
@@ -4284 +4164 @@
-	if (info->count)
+	if (info->port.count)
@@ -4357,2 +4237,5 @@
-		if (info->netcount)
-			mgslpc_program_hw(info);
+		if (info->netcount) {
+			struct tty_struct *tty = tty_port_tty_get(&info->port);
+			mgslpc_program_hw(info, tty);
+			tty_kref_put(tty);
+		}
--- ./projects/linux/linux-2.6.29/drivers/char/pcmcia/synclink_cs.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/char/pcmcia/synclink_cs.c	2009-06-27 11:32:32.000000000 +0200
@@ -53,0 +54 @@
+#include <linux/seq_file.h>
@@ -2622 +2623 @@
-static inline int line_info(char *buf, MGSLPC_INFO *info)
+static inline void line_info(struct seq_file *m, MGSLPC_INFO *info)
@@ -2625 +2625,0 @@
-	int	ret;
@@ -2628 +2628 @@
-	ret = sprintf(buf, "%s:io:%04X irq:%d",
+	seq_printf(m, "%s:io:%04X irq:%d",
@@ -2652 +2652 @@
-		ret += sprintf(buf+ret, " HDLC txok:%d rxok:%d",
+		seq_printf(m, " HDLC txok:%d rxok:%d",
@@ -2655 +2655 @@
-			ret += sprintf(buf+ret, " txunder:%d", info->icount.txunder);
+			seq_printf(m, " txunder:%d", info->icount.txunder);
@@ -2657 +2657 @@
-			ret += sprintf(buf+ret, " txabort:%d", info->icount.txabort);
+			seq_printf(m, " txabort:%d", info->icount.txabort);
@@ -2659 +2659 @@
-			ret += sprintf(buf+ret, " rxshort:%d", info->icount.rxshort);
+			seq_printf(m, " rxshort:%d", info->icount.rxshort);
@@ -2661 +2661 @@
-			ret += sprintf(buf+ret, " rxlong:%d", info->icount.rxlong);
+			seq_printf(m, " rxlong:%d", info->icount.rxlong);
@@ -2663 +2663 @@
-			ret += sprintf(buf+ret, " rxover:%d", info->icount.rxover);
+			seq_printf(m, " rxover:%d", info->icount.rxover);
@@ -2665 +2665 @@
-			ret += sprintf(buf+ret, " rxcrc:%d", info->icount.rxcrc);
+			seq_printf(m, " rxcrc:%d", info->icount.rxcrc);
@@ -2667 +2667 @@
-		ret += sprintf(buf+ret, " ASYNC tx:%d rx:%d",
+		seq_printf(m, " ASYNC tx:%d rx:%d",
@@ -2670 +2670 @@
-			ret += sprintf(buf+ret, " fe:%d", info->icount.frame);
+			seq_printf(m, " fe:%d", info->icount.frame);
@@ -2672 +2672 @@
-			ret += sprintf(buf+ret, " pe:%d", info->icount.parity);
+			seq_printf(m, " pe:%d", info->icount.parity);
@@ -2674 +2674 @@
-			ret += sprintf(buf+ret, " brk:%d", info->icount.brk);
+			seq_printf(m, " brk:%d", info->icount.brk);
@@ -2676 +2676 @@
-			ret += sprintf(buf+ret, " oe:%d", info->icount.overrun);
+			seq_printf(m, " oe:%d", info->icount.overrun);
@@ -2680 +2680 @@
-	ret += sprintf(buf+ret, " %s\n", stat_buf+1);
+	seq_printf(m, " %s\n", stat_buf+1);
@@ -2682 +2682 @@
-	ret += sprintf(buf+ret, "txactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",
+	seq_printf(m, "txactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",
@@ -2685,2 +2684,0 @@
-
-	return ret;
@@ -2691,2 +2689 @@
-static int mgslpc_read_proc(char *page, char **start, off_t off, int count,
-		 int *eof, void *data)
+static int mgslpc_proc_show(struct seq_file *m, void *v)
@@ -2694,2 +2690,0 @@
-	int len = 0, l;
-	off_t	begin = 0;
@@ -2698 +2693 @@
-	len += sprintf(page, "synclink driver:%s\n", driver_version);
+	seq_printf(m, "synclink driver:%s\n", driver_version);
@@ -2702,8 +2697 @@
-		l = line_info(page + len, info);
-		len += l;
-		if (len+begin > off+count)
-			goto done;
-		if (len+begin < off) {
-			begin += len;
-			len = 0;
-		}
+		line_info(m, info);
@@ -2711,0 +2700,2 @@
+	return 0;
+}
@@ -2713,6 +2703,3 @@
-	*eof = 1;
-done:
-	if (off >= len+begin)
-		return 0;
-	*start = page + (off-begin);
-	return ((count < begin+len-off) ? count : begin+len-off);
+static int mgslpc_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, mgslpc_proc_show, NULL);
@@ -2720,0 +2708,8 @@
+static const struct file_operations mgslpc_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mgslpc_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
@@ -2864 +2858,0 @@
-	.read_proc = mgslpc_read_proc,
@@ -2870,0 +2865 @@
+	.proc_fops = &mgslpc_proc_fops,
@@ -4314,2 +4308,0 @@
-
-	dev->last_rx = jiffies;
@@ -4317,0 +4311,9 @@
+static const struct net_device_ops hdlcdev_ops = {
+	.ndo_open       = hdlcdev_open,
+	.ndo_stop       = hdlcdev_close,
+	.ndo_change_mtu = hdlc_change_mtu,
+	.ndo_start_xmit = hdlc_start_xmit,
+	.ndo_do_ioctl   = hdlcdev_ioctl,
+	.ndo_tx_timeout = hdlcdev_tx_timeout,
+};
+
@@ -4344,5 +4346,2 @@
-	dev->do_ioctl       = hdlcdev_ioctl;
-	dev->open           = hdlcdev_open;
-	dev->stop           = hdlcdev_close;
-	dev->tx_timeout     = hdlcdev_tx_timeout;
-	dev->watchdog_timeo = 10*HZ;
+	dev->netdev_ops	    = &hdlcdev_ops;
+	dev->watchdog_timeo = 10 * HZ;
--- ./projects/linux/linux-2.6.15/drivers/char/riscom8.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/riscom8.c	2006-03-20 06:53:29.000000000 +0100
@@ -48,0 +49 @@
+#include <linux/tty_flip.h>
@@ -84 +84,0 @@
-static DECLARE_MUTEX(tmp_buf_sem);
@@ -110 +110 @@
-#if 1	
+#if 1
@@ -112 +112 @@
-#else	
+#else
@@ -116 +116 @@
-#endif	
+#endif
@@ -118 +118 @@
-#define RC_NIOPORT	(sizeof(rc_ioport) / sizeof(rc_ioport[0]))
+#define RC_NIOPORT	ARRAY_SIZE(rc_ioport)
@@ -357 +357 @@
-	unsigned char ch;
+	unsigned char ch, flag;
@@ -363,6 +362,0 @@
-	if (tty->flip.count >= TTY_FLIPBUF_SIZE)  {
-		printk(KERN_WARNING "rc%d: port %d: Working around flip "
-				    "buffer overflow.\n",
-		       board_No(bp), port_No(port));
-		return;
-	}
@@ -372 +366 @@
-	if (status & RCSR_OE)  {
+	if (status & RCSR_OE)
@@ -374,5 +367,0 @@
-#if 0		
-		printk(KERN_ERR "rc%d: port %d: Overrun. Total %ld overruns\n", 
-		       board_No(bp), port_No(port), port->overrun);
-#endif		
-	}
@@ -396 +385 @@
-		*tty->flip.flag_buf_ptr++ = TTY_BREAK;
+		flag = TTY_BREAK;
@@ -401 +390 @@
-		*tty->flip.flag_buf_ptr++ = TTY_PARITY;
+		flag = TTY_PARITY;
@@ -404 +393 @@
-		*tty->flip.flag_buf_ptr++ = TTY_FRAME;
+		flag = TTY_FRAME;
@@ -407 +396 @@
-		*tty->flip.flag_buf_ptr++ = TTY_OVERRUN;
+		flag = TTY_OVERRUN;
@@ -410 +399 @@
-		*tty->flip.flag_buf_ptr++ = 0;
+		flag = TTY_NORMAL;
@@ -412,3 +401,2 @@
-	*tty->flip.char_buf_ptr++ = ch;
-	tty->flip.count++;
-	schedule_delayed_work(&tty->flip.work, 1);
+	tty_insert_flip_char(tty, ch, flag);
+	tty_flip_buffer_push(tty);
@@ -435 +423 @@
-		if (tty->flip.count >= TTY_FLIPBUF_SIZE)  {
+		if (tty_buffer_request_room(tty, 1) == 0)  {
@@ -441,3 +429 @@
-		*tty->flip.char_buf_ptr++ = rc_in(bp, CD180_RDR);
-		*tty->flip.flag_buf_ptr++ = 0;
-		tty->flip.count++;
+		tty_insert_flip_char(tty, rc_in(bp, CD180_RDR), TTY_NORMAL);
@@ -445 +431 @@
-	schedule_delayed_work(&tty->flip.work, 1);
+	tty_flip_buffer_push(tty);
--- ./projects/linux/linux-2.6.16/drivers/char/riscom8.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/char/riscom8.c	2006-06-18 03:49:35.000000000 +0200
@@ -1746,4 +1746,4 @@
-MODULE_PARM(iobase, "i");
-MODULE_PARM(iobase1, "i");
-MODULE_PARM(iobase2, "i");
-MODULE_PARM(iobase3, "i");
+module_param(iobase, int, 0);
+module_param(iobase1, int, 0);
+module_param(iobase2, int, 0);
+module_param(iobase3, int, 0);
--- ./projects/linux/linux-2.6.17/drivers/char/riscom8.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/riscom8.c	2006-09-20 05:42:06.000000000 +0200
@@ -628 +628 @@
-	error = request_irq(bp->irq, rc_interrupt, SA_INTERRUPT,
+	error = request_irq(bp->irq, rc_interrupt, IRQF_DISABLED,
@@ -1637 +1636,0 @@
-	riscom_driver->devfs_name = "tts/L";
--- ./projects/linux/linux-2.6.18/drivers/char/riscom8.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/riscom8.c	2006-11-29 22:57:37.000000000 +0100
@@ -84 +83,0 @@
-static unsigned char * tmp_buf;
@@ -554 +553 @@
-static irqreturn_t rc_interrupt(int irq, void * dev_id, struct pt_regs * regs)
+static irqreturn_t rc_interrupt(int irq, void * dev_id)
@@ -563,2 +562,2 @@
-	
-	if (!bp || !(bp->flags & RC_BOARD_ACTIVE))  {
+
+	if (!(bp->flags & RC_BOARD_ACTIVE))
@@ -566,2 +565 @@
-	}
-	
+
@@ -678,15 +676 @@
-	baud = C_BAUD(tty);
-	
-	if (baud & CBAUDEX) {
-		baud &= ~CBAUDEX;
-		if (baud < 1 || baud > 2) 
-			port->tty->termios->c_cflag &= ~CBAUDEX;
-		else
-			baud += 15;
-	}
-	if (baud == 15)  {
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
-			baud ++;
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
-			baud += 2;
-	}
+	baud = tty_get_baud_rate(tty);
@@ -697 +681 @@
-	if (!baud_table[baud])  {
+	if (!baud)  {
@@ -713 +697 @@
-	tmp = (((RC_OSCFREQ + baud_table[baud]/2) / baud_table[baud] +
+	tmp = (((RC_OSCFREQ + baud/2) / baud +
@@ -721 +705 @@
-	baud = (baud_table[baud] + 5) / 10;   /* Estimated CPS */
+	baud = (baud + 5) / 10;   /* Estimated CPS */
@@ -1141 +1125 @@
-	if (!tty || !port->xmit_buf || !tmp_buf)
+	if (!tty || !port->xmit_buf)
@@ -1600 +1584 @@
-static struct tty_operations riscom_ops = {
+static const struct tty_operations riscom_ops = {
@@ -1629,5 +1612,0 @@
-	if (!(tmp_buf = (unsigned char *) get_zeroed_page(GFP_KERNEL))) {
-		printk(KERN_ERR "rc: Couldn't get free page.\n");
-		put_tty_driver(riscom_driver);
-		return 1;
-	}
@@ -1646 +1624,0 @@
-		free_page((unsigned long)tmp_buf);
@@ -1674 +1651,0 @@
-	free_page((unsigned long)tmp_buf);
--- ./projects/linux/linux-2.6.19/drivers/char/riscom8.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/riscom8.c	2007-02-04 19:44:54.000000000 +0100
@@ -85,5 +84,0 @@
-static unsigned long baud_table[] =  {
-	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800,
-	9600, 19200, 38400, 57600, 76800, 0, 
-};
-
@@ -1519 +1514 @@
-static void do_rc_hangup(void *private_)
+static void do_rc_hangup(struct work_struct *ugly_api)
@@ -1521 +1516 @@
-	struct riscom_port	*port = (struct riscom_port *) private_;
+	struct riscom_port	*port = container_of(ugly_api, struct riscom_port, tqueue_hangup);
@@ -1547 +1542 @@
-static void rc_set_termios(struct tty_struct * tty, struct termios * old_termios)
+static void rc_set_termios(struct tty_struct * tty, struct ktermios * old_termios)
@@ -1570 +1565 @@
-static void do_softint(void *private_)
+static void do_softint(struct work_struct *ugly_api)
@@ -1572 +1567 @@
-	struct riscom_port	*port = (struct riscom_port *) private_;
+	struct riscom_port	*port = container_of(ugly_api, struct riscom_port, tqueue);
@@ -1621,0 +1617,2 @@
+	riscom_driver->init_termios.c_ispeed = 9600;
+	riscom_driver->init_termios.c_ospeed = 9600;
@@ -1635,2 +1632,2 @@
-		INIT_WORK(&rc_port[i].tqueue, do_softint, &rc_port[i]);
-		INIT_WORK(&rc_port[i].tqueue_hangup, do_rc_hangup, &rc_port[i]);
+		INIT_WORK(&rc_port[i].tqueue, do_softint);
+		INIT_WORK(&rc_port[i].tqueue_hangup, do_rc_hangup);
--- ./projects/linux/linux-2.6.20/drivers/char/riscom8.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/riscom8.c	2007-04-26 05:08:32.000000000 +0200
@@ -1232 +1231,0 @@
-	wake_up_interruptible(&tty->write_wait);
@@ -1573 +1572 @@
-	if (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &port->event)) {
+	if (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &port->event))
@@ -1575,2 +1573,0 @@
-		wake_up_interruptible(&tty->write_wait);
-	}
--- ./projects/linux/linux-2.6.21/drivers/char/riscom8.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/char/riscom8.c	2007-07-09 01:32:17.000000000 +0200
@@ -983 +983 @@
-	current->state = TASK_RUNNING;
+	__set_current_state(TASK_RUNNING);
--- ./projects/linux/linux-2.6.22/drivers/char/riscom8.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/riscom8.c	2007-10-09 22:31:38.000000000 +0200
@@ -216,8 +215,0 @@
-/* Must be called with enabled interrupts */
-static inline void rc_long_delay(unsigned long delay)
-{
-	unsigned long i;
-	
-	for (i = jiffies + delay; time_after(i,jiffies); ) ;
-}
-
@@ -234 +226 @@
-	rc_long_delay(HZ/20);                      /* Delay 0.05 sec            */
+	msleep(50);				   /* Delay 0.05 sec            */
@@ -283 +275 @@
-		rc_long_delay(HZ/20);	       		
+		msleep(50);
--- ./projects/linux/linux-2.6.23/drivers/char/riscom8.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/riscom8.c	2008-01-24 23:58:37.000000000 +0100
@@ -82 +81,0 @@
-static struct riscom_board * IRQ_to_board[16];
@@ -540 +539 @@
-static irqreturn_t rc_interrupt(int irq, void * dev_id)
+static irqreturn_t rc_interrupt(int dummy, void * dev_id)
@@ -544 +543 @@
-	struct riscom_board *bp;
+	struct riscom_board *bp = dev_id;
@@ -548,2 +546,0 @@
-	bp = IRQ_to_board[irq];
-
@@ -606 +603 @@
-static inline int rc_setup_board(struct riscom_board * bp)
+static int rc_setup_board(struct riscom_board * bp)
@@ -614 +611 @@
-			    "RISCom/8", NULL);
+			    "RISCom/8", bp);
@@ -622 +618,0 @@
-	IRQ_to_board[bp->irq] = bp;
@@ -629 +625 @@
-static inline void rc_shutdown_board(struct riscom_board *bp)
+static void rc_shutdown_board(struct riscom_board *bp)
@@ -637 +632,0 @@
-	IRQ_to_board[bp->irq] = NULL;
@@ -1597 +1591,0 @@
-	memset(IRQ_to_board, 0, sizeof(IRQ_to_board));
--- ./projects/linux/linux-2.6.24/drivers/char/riscom8.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/riscom8.c	2008-04-17 04:49:44.000000000 +0200
@@ -49,0 +50 @@
+#include <linux/spinlock.h>
@@ -80,2 +80,0 @@
-#define RS_EVENT_WRITE_WAKEUP	0
-
@@ -83,0 +83,2 @@
+static DEFINE_SPINLOCK(riscom_lock);
+
@@ -220 +221,2 @@
-	save_flags(flags); cli();
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -224 +226 @@
-	sti();
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -226 +228 @@
-	cli();
+	spin_lock_irqsave(&riscom_lock, flags);
@@ -237 +239 @@
-	restore_flags(flags);
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -313,6 +314,0 @@
-static inline void rc_mark_event(struct riscom_port * port, int event)
-{
-	set_bit(event, &port->event);
-	schedule_work(&port->tqueue);
-}
-
@@ -485 +481 @@
-		rc_mark_event(port, RS_EVENT_WRITE_WAKEUP);
+		tty_wakeup(tty);
@@ -504 +500 @@
-			schedule_work(&port->tqueue_hangup);
+			tty_hangup(tty);
@@ -513 +509 @@
-				rc_mark_event(port, RS_EVENT_WRITE_WAKEUP);
+				tty_wakeup(tty);
@@ -525 +521 @@
-				rc_mark_event(port, RS_EVENT_WRITE_WAKEUP);
+				tty_wakeup(tty);
@@ -815,3 +811,3 @@
-		
-	save_flags(flags); cli();
-		
+
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -828 +824 @@
-	restore_flags(flags);
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -903,0 +900 @@
+	unsigned long flags;
@@ -939 +936,3 @@
-	cli();
+
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -942 +941,3 @@
-	sti();
+
+	spin_unlock_irqrestore(&riscom_lock, flags);
+
@@ -945 +946,2 @@
-		cli();
+		spin_lock_irqsave(&riscom_lock, flags);
+
@@ -951 +953,3 @@
-		sti();
+
+		spin_unlock_irqrestore(&riscom_lock, flags);
+
@@ -1023,2 +1027,3 @@
-	
-	save_flags(flags); cli();
+
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -1081 +1085,0 @@
-	port->event = 0;
@@ -1091 +1095,3 @@
-out:	restore_flags(flags);
+
+out:
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1110 +1115,0 @@
-	save_flags(flags);
@@ -1112 +1117,2 @@
-		cli();		
+		spin_lock_irqsave(&riscom_lock, flags);
+
@@ -1115,4 +1121,2 @@
-		if (c <= 0) {
-			restore_flags(flags);
-			break;
-		}
+		if (c <= 0)
+			break;	/* lock continues to be held */
@@ -1123 +1127,2 @@
-		restore_flags(flags);
+
+		spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1130 +1134,0 @@
-	cli();
@@ -1137 +1141,2 @@
-	restore_flags(flags);
+
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1153 +1158 @@
-	save_flags(flags); cli();
+	spin_lock_irqsave(&riscom_lock, flags);
@@ -1161 +1166,3 @@
-out:	restore_flags(flags);
+
+out:
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1176 +1183,2 @@
-	save_flags(flags); cli();
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -1180 +1188,2 @@
-	restore_flags(flags);
+
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1215 +1224,2 @@
-	save_flags(flags); cli();
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -1217 +1227,2 @@
-	restore_flags(flags);
+
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1234 +1245,3 @@
-	save_flags(flags); cli();
+
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -1238 +1251,3 @@
-	restore_flags(flags);
+
+	spin_unlock_irqrestore(&riscom_lock, flags);
+
@@ -1259 +1274,2 @@
-	save_flags(flags); cli();
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -1273 +1289,3 @@
-	restore_flags(flags);
+
+	spin_unlock_irqrestore(&riscom_lock, flags);
+
@@ -1282 +1300,2 @@
-	save_flags(flags); cli();
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -1292 +1311,2 @@
-	restore_flags(flags);
+
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1301 +1320,0 @@
-	unsigned long flags;
@@ -1335 +1354,3 @@
-		save_flags(flags); cli();
+		unsigned long flags;
+
+		spin_lock_irqsave(&riscom_lock, flags);
@@ -1337 +1358 @@
-		restore_flags(flags);
+		spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1417,2 +1438,3 @@
-	
-	save_flags(flags); cli();
+
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -1421 +1443 @@
-	if (I_IXOFF(tty))  {
+	if (I_IXOFF(tty)) {
@@ -1427 +1449,2 @@
-	restore_flags(flags);
+
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1441 +1464,2 @@
-	save_flags(flags); cli();
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -1450 +1474,2 @@
-	restore_flags(flags);
+
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1464 +1489,2 @@
-	save_flags(flags); cli();
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -1468 +1494,2 @@
-	restore_flags(flags);
+
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1482 +1509,2 @@
-	save_flags(flags); cli();
+	spin_lock_irqsave(&riscom_lock, flags);
+
@@ -1488,2 +1515,0 @@
-	restore_flags(flags);
-}
@@ -1491,17 +1517 @@
-/*
- * This routine is called from the work queue when the interrupt
- * routine has signalled that a hangup has occurred.  The path of
- * hangup processing is:
- *
- * 	serial interrupt routine -> (workqueue) ->
- * 	do_rc_hangup() -> tty->hangup() -> rc_hangup()
- * 
- */
-static void do_rc_hangup(struct work_struct *ugly_api)
-{
-	struct riscom_port	*port = container_of(ugly_api, struct riscom_port, tqueue_hangup);
-	struct tty_struct	*tty;
-	
-	tty = port->tty;
-	if (tty)
-		tty_hangup(tty);	/* FIXME: module removal race still here */
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1521 +1530,0 @@
-	port->event = 0;
@@ -1540 +1549 @@
-	save_flags(flags); cli();
+	spin_lock_irqsave(&riscom_lock, flags);
@@ -1542 +1551 @@
-	restore_flags(flags);
+	spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1551,12 +1559,0 @@
-static void do_softint(struct work_struct *ugly_api)
-{
-	struct riscom_port	*port = container_of(ugly_api, struct riscom_port, tqueue);
-	struct tty_struct	*tty;
-	
-	if(!(tty = port->tty)) 
-		return;
-
-	if (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &port->event))
-		tty_wakeup(tty);
-}
-
@@ -1583 +1580 @@
-static inline int rc_init_drivers(void)
+static int __init rc_init_drivers(void)
@@ -1615,2 +1611,0 @@
-		INIT_WORK(&rc_port[i].tqueue, do_softint);
-		INIT_WORK(&rc_port[i].tqueue_hangup, do_rc_hangup);
@@ -1628,4 +1622,0 @@
-	unsigned long flags;
-
-	save_flags(flags);
-	cli();
@@ -1634 +1624,0 @@
-	restore_flags(flags);
@@ -1722 +1712 @@
-			rc_board[0].base = 0;
+			rc_board[i].base = 0;
--- ./projects/linux/linux-2.6.25/drivers/char/riscom8.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/riscom8.c	2008-07-13 23:51:29.000000000 +0200
@@ -7,3 +7,3 @@
- *      Linus Torvalds, Theodore T'so and others. The RISCom/8 card 
- *      programming info was obtained from various drivers for other OSes 
- *	(FreeBSD, ISC, etc), but no source code from those drivers were 
+ *      Linus Torvalds, Theodore T'so and others. The RISCom/8 card
+ *      programming info was obtained from various drivers for other OSes
+ *	(FreeBSD, ISC, etc), but no source code from those drivers were
@@ -36 +36 @@
-#include <asm/io.h>
+#include <linux/io.h>
@@ -52 +52 @@
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
@@ -60,2 +60,2 @@
-/* 
- * Crazy InteliCom/8 boards sometimes has swapped CTS & DSR signals.
+/*
+ * Crazy InteliCom/8 boards sometimes have swapped CTS & DSR signals.
@@ -63 +63 @@
- * if you are REALLY sure that your board is correct one. 
+ * if you are REALLY sure that your board is correct one.
@@ -68 +68 @@
-/* 
+/*
@@ -115 +115 @@
-static inline int rc_paranoia_check(struct riscom_port const * port,
+static int rc_paranoia_check(struct riscom_port const *port,
@@ -137 +137 @@
- * 
+ *
@@ -139 +139 @@
- * 
+ *
@@ -143 +143 @@
-static inline int board_No (struct riscom_board const * bp)
+static inline int board_No(struct riscom_board const *bp)
@@ -149 +149 @@
-static inline int port_No (struct riscom_port const * port)
+static inline int port_No(struct riscom_port const *port)
@@ -151 +151 @@
-	return RC_PORT(port - rc_port); 
+	return RC_PORT(port - rc_port);
@@ -155 +155 @@
-static inline struct riscom_board * port_Board(struct riscom_port const * port)
+static inline struct riscom_board *port_Board(struct riscom_port const *port)
@@ -161 +161,2 @@
-static inline unsigned char rc_in(struct riscom_board const * bp, unsigned short reg)
+static inline unsigned char rc_in(struct riscom_board const *bp,
+							unsigned short reg)
@@ -167 +168 @@
-static inline void rc_out(struct riscom_board const * bp, unsigned short reg,
+static inline void rc_out(struct riscom_board const *bp, unsigned short reg,
@@ -174 +175 @@
-static inline void rc_wait_CCR(struct riscom_board const * bp)
+static void rc_wait_CCR(struct riscom_board const *bp)
@@ -179 +180 @@
-	for (delay = 100000; delay; delay--) 
+	for (delay = 100000; delay; delay--)
@@ -182 +183 @@
-	
+
@@ -190 +191 @@
-static inline int rc_request_io_range(struct riscom_board * const bp)
+static int rc_request_io_range(struct riscom_board * const bp)
@@ -193,2 +194,2 @@
-	
-	for (i = 0; i < RC_NIOPORT; i++)  
+
+	for (i = 0; i < RC_NIOPORT; i++)
@@ -203 +204 @@
-	while(--i >= 0)
+	while (--i >= 0)
@@ -208 +209 @@
-static inline void rc_release_io_range(struct riscom_board * const bp)
+static void rc_release_io_range(struct riscom_board * const bp)
@@ -211,2 +212,2 @@
-	
-	for (i = 0; i < RC_NIOPORT; i++)  
+
+	for (i = 0; i < RC_NIOPORT; i++)
@@ -215 +216 @@
-	
+
@@ -217 +218 @@
-static void __init rc_init_CD180(struct riscom_board const * bp)
+static void __init rc_init_CD180(struct riscom_board const *bp)
@@ -220 +221 @@
-	
+
@@ -223,3 +224,3 @@
-	rc_out(bp, RC_CTOUT, 0);     	           /* Clear timeout             */
-	rc_wait_CCR(bp);			   /* Wait for CCR ready        */
-	rc_out(bp, CD180_CCR, CCR_HARDRESET);      /* Reset CD180 chip          */
+	rc_out(bp, RC_CTOUT, 0);     	           /* Clear timeout        */
+	rc_wait_CCR(bp);			   /* Wait for CCR ready   */
+	rc_out(bp, CD180_CCR, CCR_HARDRESET);      /* Reset CD180 chip     */
@@ -227 +228 @@
-	msleep(50);				   /* Delay 0.05 sec            */
+	msleep(50);				   /* Delay 0.05 sec       */
@@ -229,6 +230,6 @@
-	rc_out(bp, CD180_GIVR, RC_ID);             /* Set ID for this chip      */
-	rc_out(bp, CD180_GICR, 0);                 /* Clear all bits            */
-	rc_out(bp, CD180_PILR1, RC_ACK_MINT);      /* Prio for modem intr       */
-	rc_out(bp, CD180_PILR2, RC_ACK_TINT);      /* Prio for transmitter intr */
-	rc_out(bp, CD180_PILR3, RC_ACK_RINT);      /* Prio for receiver intr    */
-	
+	rc_out(bp, CD180_GIVR, RC_ID);             /* Set ID for this chip */
+	rc_out(bp, CD180_GICR, 0);                 /* Clear all bits       */
+	rc_out(bp, CD180_PILR1, RC_ACK_MINT);      /* Prio for modem intr  */
+	rc_out(bp, CD180_PILR2, RC_ACK_TINT);      /* Prio for tx intr     */
+	rc_out(bp, CD180_PILR3, RC_ACK_RINT);      /* Prio for rx intr	   */
+
@@ -238 +239 @@
-	
+
@@ -248 +249 @@
-	
+
@@ -253 +254 @@
-	
+
@@ -261 +262 @@
-	
+
@@ -267 +268 @@
-	
+
@@ -269 +270 @@
-	for (retries = 0; retries < 5 && irqs <= 0; retries++)  {
+	for (retries = 0; retries < 5 && irqs <= 0; retries++) {
@@ -271,2 +272,2 @@
-		rc_init_CD180(bp);	       		/* Reset CD180 chip       */
-		rc_out(bp, CD180_CAR, 2);               /* Select port 2          */
+		rc_init_CD180(bp);		 /* Reset CD180 chip	     */
+		rc_out(bp, CD180_CAR, 2);	 /* Select port 2	     */
@@ -274,2 +275,2 @@
-		rc_out(bp, CD180_CCR, CCR_TXEN);        /* Enable transmitter     */
-		rc_out(bp, CD180_IER, IER_TXRDY);       /* Enable tx empty intr   */
+		rc_out(bp, CD180_CCR, CCR_TXEN); /* Enable transmitter	     */
+		rc_out(bp, CD180_IER, IER_TXRDY);/* Enable tx empty intr     */
@@ -278,4 +279,4 @@
-		val1 = rc_in(bp, RC_BSR);		/* Get Board Status reg   */
-		val2 = rc_in(bp, RC_ACK_TINT);          /* ACK interrupt          */
-		rc_init_CD180(bp);	       		/* Reset CD180 again      */
-	
+		val1 = rc_in(bp, RC_BSR);	/* Get Board Status reg	     */
+		val2 = rc_in(bp, RC_ACK_TINT);  /* ACK interrupt	     */
+		rc_init_CD180(bp);	       	/* Reset CD180 again	     */
+
@@ -288 +289 @@
-	
+
@@ -296 +297 @@
-	
+
@@ -302 +303 @@
-	
+
@@ -309,2 +310,2 @@
-/* 
- * 
+/*
+ *
@@ -312 +313 @@
- * 
+ *
@@ -315,2 +316,2 @@
-static inline struct riscom_port * rc_get_port(struct riscom_board const * bp,
-					       unsigned char const * what)
+static struct riscom_port *rc_get_port(struct riscom_board const *bp,
+					       unsigned char const *what)
@@ -319,2 +320,2 @@
-	struct riscom_port * port;
-	
+	struct riscom_port *port;
+
@@ -324 +325 @@
-		if (port->flags & ASYNC_INITIALIZED)  {
+		if (port->flags & ASYNC_INITIALIZED)
@@ -326 +326,0 @@
-		}
@@ -328 +328 @@
-	printk(KERN_ERR "rc%d: %s interrupt from invalid port %d\n", 
+	printk(KERN_ERR "rc%d: %s interrupt from invalid port %d\n",
@@ -333 +333 @@
-static inline void rc_receive_exc(struct riscom_board const * bp)
+static void rc_receive_exc(struct riscom_board const *bp)
@@ -339,2 +339,3 @@
-	
-	if (!(port = rc_get_port(bp, "Receive")))
+
+	port = rc_get_port(bp, "Receive");
+	if (port == NULL)
@@ -344,2 +345,2 @@
-	
-#ifdef RC_REPORT_OVERRUN	
+
+#ifdef RC_REPORT_OVERRUN
@@ -350 +351 @@
-#else	
+#else
@@ -352 +353 @@
-#endif	
+#endif
@@ -354 +355 @@
-	if (!status)  {
+	if (!status)
@@ -356 +356,0 @@
-	}
@@ -359 +359 @@
-				    "Hardware problems ?\n", 
+				    "Hardware problems ?\n",
@@ -362 +362 @@
-		
+
@@ -369,2 +369,2 @@
-		
-	} else if (status & RCSR_PE) 
+
+	} else if (status & RCSR_PE)
@@ -372,2 +372,2 @@
-	
-	else if (status & RCSR_FE) 
+
+	else if (status & RCSR_FE)
@@ -375,2 +375,2 @@
-	
-        else if (status & RCSR_OE)
+
+	else if (status & RCSR_OE)
@@ -378 +377,0 @@
-	
@@ -381 +380 @@
-	
+
@@ -386 +385 @@
-static inline void rc_receive(struct riscom_board const * bp)
+static void rc_receive(struct riscom_board const *bp)
@@ -391,2 +390,3 @@
-	
-	if (!(port = rc_get_port(bp, "Receive")))
+
+	port = rc_get_port(bp, "Receive");
+	if (port == NULL)
@@ -394 +394 @@
-	
+
@@ -396 +396 @@
-	
+
@@ -398 +398 @@
-	
+
@@ -401,2 +401,2 @@
-#endif	
-	
+#endif
+
@@ -415 +415 @@
-static inline void rc_transmit(struct riscom_board const * bp)
+static void rc_transmit(struct riscom_board const *bp)
@@ -420,3 +420,3 @@
-	
-	
-	if (!(port = rc_get_port(bp, "Transmit")))
+
+	port = rc_get_port(bp, "Transmit");
+	if (port == NULL)
@@ -424 +424 @@
-	
+
@@ -426,2 +426,2 @@
-	
-	if (port->IER & IER_TXEMPTY)  {
+
+	if (port->IER & IER_TXEMPTY) {
@@ -434 +434 @@
-	
+
@@ -442 +442 @@
-	
+
@@ -454 +454,2 @@
-			if (!(port->break_length -= count))
+			port->break_length -= count;
+			if (port->break_length == 0)
@@ -466 +467 @@
-	
+
@@ -474 +475 @@
-	
+
@@ -484 +485 @@
-static inline void rc_check_modem(struct riscom_board const * bp)
+static void rc_check_modem(struct riscom_board const *bp)
@@ -489,2 +490,3 @@
-	
-	if (!(port = rc_get_port(bp, "Modem")))
+
+	port = rc_get_port(bp, "Modem");
+	if (port == NULL)
@@ -492 +494 @@
-	
+
@@ -494 +496 @@
-	
+
@@ -496,2 +498,2 @@
-	if (mcr & MCR_CDCHG)  {
-		if (rc_in(bp, CD180_MSVR) & MSVR_CD) 
+	if (mcr & MCR_CDCHG) {
+		if (rc_in(bp, CD180_MSVR) & MSVR_CD)
@@ -502 +504 @@
-	
+
@@ -529 +531 @@
-	
+
@@ -535 +537 @@
-static irqreturn_t rc_interrupt(int dummy, void * dev_id)
+static irqreturn_t rc_interrupt(int dummy, void *dev_id)
@@ -550 +552 @@
-		if (status & RC_BSR_TOUT) 
+		if (status & RC_BSR_TOUT)
@@ -553 +554,0 @@
-		
@@ -556 +556,0 @@
-		
@@ -565 +564,0 @@
-		
@@ -568 +566,0 @@
-		
@@ -575 +572,0 @@
-		
@@ -578,2 +575 @@
-		
-			if (ack == (RC_ID | GIVR_IT_MODEM)) 
+			if (ack == (RC_ID | GIVR_IT_MODEM))
@@ -585,3 +581 @@
-		
-		} 
-
+		}
@@ -599 +593 @@
-static int rc_setup_board(struct riscom_board * bp)
+static int rc_setup_board(struct riscom_board *bp)
@@ -603 +597 @@
-	if (bp->flags & RC_BOARD_ACTIVE) 
+	if (bp->flags & RC_BOARD_ACTIVE)
@@ -605 +599 @@
-	
+
@@ -608 +602 @@
-	if (error) 
+	if (error)
@@ -610 +604 @@
-	
+
@@ -614 +608 @@
-	
+
@@ -616 +610 @@
-	
+
@@ -625 +619 @@
-	
+
@@ -627 +621 @@
-	
+
@@ -629 +623 @@
-	
+
@@ -632 +626 @@
-	
+
@@ -636 +630 @@
- * Setting up port characteristics. 
+ * Setting up port characteristics.
@@ -641 +635 @@
-	struct tty_struct *tty;
+	struct tty_struct *tty = port->tty;
@@ -646,2 +640,2 @@
-	
-	if (!(tty = port->tty) || !tty->termios)
+
+	if (tty == NULL || tty->termios == NULL)
@@ -653 +647 @@
-	
+
@@ -655 +649 @@
-	
+
@@ -658 +652 @@
-	
+
@@ -669 +663 @@
-	
+
@@ -671 +665 @@
-	 * Now we must calculate some speed depended things 
+	 * Now we must calculate some speed depended things
@@ -673 +667 @@
-	
+
@@ -678,3 +672,3 @@
-	rc_out(bp, CD180_RBPRH, (tmp >> 8) & 0xff); 
-	rc_out(bp, CD180_TBPRH, (tmp >> 8) & 0xff); 
-	rc_out(bp, CD180_RBPRL, tmp & 0xff); 
+	rc_out(bp, CD180_RBPRH, (tmp >> 8) & 0xff);
+	rc_out(bp, CD180_TBPRH, (tmp >> 8) & 0xff);
+	rc_out(bp, CD180_RBPRL, tmp & 0xff);
@@ -682 +676 @@
-	
+
@@ -684 +678 @@
-	
+
@@ -686 +680 @@
-	tmp = ((baud + HZ/2) / HZ) * 2 - CD180_NFIFO;		
+	tmp = ((baud + HZ/2) / HZ) * 2 - CD180_NFIFO;
@@ -689 +683 @@
-	
+
@@ -694,3 +688,3 @@
-	
-	switch (C_CSIZE(tty))  {
-	 case CS5:
+
+	switch (C_CSIZE(tty)) {
+	case CS5:
@@ -699 +693 @@
-	 case CS6:
+	case CS6:
@@ -702 +696 @@
-	 case CS7:
+	case CS7:
@@ -705 +699 @@
-	 case CS8:
+	case CS8:
@@ -709,2 +703 @@
-	
-	if (C_CSTOPB(tty)) 
+	if (C_CSTOPB(tty))
@@ -712 +705 @@
-	
+
@@ -714 +707 @@
-	if (C_PARENB(tty))  {
+	if (C_PARENB(tty)) {
@@ -716 +709 @@
-		if (C_PARODD(tty)) 
+		if (C_PARODD(tty))
@@ -718 +711 @@
-		if (I_INPCK(tty)) 
+		if (I_INPCK(tty))
@@ -723 +716 @@
-	if (I_INPCK(tty)) 
+	if (I_INPCK(tty))
@@ -725 +718 @@
-	if (I_BRKINT(tty) || I_PARMRK(tty)) 
+	if (I_BRKINT(tty) || I_PARMRK(tty))
@@ -727 +720 @@
-	if (I_IGNPAR(tty)) 
+	if (I_IGNPAR(tty))
@@ -729 +722 @@
-	if (I_IGNBRK(tty))  {
+	if (I_IGNBRK(tty)) {
@@ -731 +724 @@
-		if (I_IGNPAR(tty)) 
+		if (I_IGNPAR(tty))
@@ -741 +734,2 @@
-		tty->hw_stopped = !(rc_in(bp, CD180_MSVR) & (MSVR_CTS|MSVR_DSR));
+		tty->hw_stopped = !(rc_in(bp, CD180_MSVR) &
+						(MSVR_CTS|MSVR_DSR));
@@ -764,2 +758,2 @@
-	
-	if (C_CREAD(tty)) 
+
+	if (C_CREAD(tty))
@@ -768 +762 @@
-	
+
@@ -770 +764 @@
-	cor3 |= RISCOM_RXFIFO; 
+	cor3 |= RISCOM_RXFIFO;
@@ -794 +788 @@
-	
+
@@ -797 +791 @@
-	
+
@@ -800,3 +794,2 @@
-		unsigned long tmp;
-		
-		if (!(tmp = get_zeroed_page(GFP_KERNEL)))
+		unsigned long tmp = get_zeroed_page(GFP_KERNEL);
+		if (tmp == 0)
@@ -804,2 +797 @@
-		    
-		if (port->xmit_buf) {
+		if (port->xmit_buf)
@@ -807,3 +799,2 @@
-			return -ERESTARTSYS;
-		}
-		port->xmit_buf = (unsigned char *) tmp;
+		else
+			port->xmit_buf = (unsigned char *) tmp;
@@ -811 +801,0 @@
-
@@ -814 +804 @@
-	if (port->tty) 
+	if (port->tty)
@@ -816,2 +806 @@
-		
-	if (port->count == 1) 
+	if (port->count == 1)
@@ -819 +807,0 @@
-		
@@ -823 +811 @@
-		
+
@@ -832,2 +820,2 @@
-	
-	if (!(port->flags & ASYNC_INITIALIZED)) 
+
+	if (!(port->flags & ASYNC_INITIALIZED))
@@ -835 +823 @@
-	
+
@@ -839 +827 @@
-#endif	
+#endif
@@ -843 +831 @@
-		
+
@@ -846 +834 @@
-		for (i = 0; i < 10; i++)  {
+		for (i = 0; i < 10; i++)
@@ -848 +835,0 @@
-		}
@@ -851 +838 @@
-#endif	
+#endif
@@ -857 +844,3 @@
-	if (!(tty = port->tty) || C_HUPCL(tty))  {
+	tty = port->tty;
+
+	if (tty == NULL || C_HUPCL(tty)) {
@@ -862,2 +851,2 @@
-	
-        /* Select port */
+
+	/* Select port */
@@ -871,2 +860,2 @@
-	
-	if (tty)  
+
+	if (tty)
@@ -875 +864 @@
-	
+
@@ -882 +870,0 @@
-	
@@ -887 +875 @@
-	if (!bp->count) 
+	if (!bp->count)
@@ -891,2 +879 @@
-	
-static int block_til_ready(struct tty_struct *tty, struct file * filp,
+static int block_til_ready(struct tty_struct *tty, struct file *filp,
@@ -924 +911 @@
-	if (C_CLOCAL(tty))  
+	if (C_CLOCAL(tty))
@@ -962 +949 @@
-				retval = -ERESTARTSYS;	
+				retval = -ERESTARTSYS;
@@ -981 +968 @@
-	
+
@@ -984 +971 @@
-}	
+}
@@ -986 +973 @@
-static int rc_open(struct tty_struct * tty, struct file * filp)
+static int rc_open(struct tty_struct *tty, struct file *filp)
@@ -990,3 +977,3 @@
-	struct riscom_port * port;
-	struct riscom_board * bp;
-	
+	struct riscom_port *port;
+	struct riscom_board *bp;
+
@@ -996 +983 @@
-	
+
@@ -1001,2 +988,3 @@
-	
-	if ((error = rc_setup_board(bp))) 
+
+	error = rc_setup_board(bp);
+	if (error)
@@ -1004 +992 @@
-		
+
@@ -1008,8 +996,5 @@
-	
-	if ((error = rc_setup_port(bp, port))) 
-		return error;
-	
-	if ((error = block_til_ready(tty, filp, port)))
-		return error;
-	
-	return 0;
+
+	error = rc_setup_port(bp, port);
+	if (error == 0)
+		error = block_til_ready(tty, filp, port);
+	return error;
@@ -1018 +1003,16 @@
-static void rc_close(struct tty_struct * tty, struct file * filp)
+static void rc_flush_buffer(struct tty_struct *tty)
+{
+	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	unsigned long flags;
+
+	if (rc_paranoia_check(port, tty->name, "rc_flush_buffer"))
+		return;
+
+	spin_lock_irqsave(&riscom_lock, flags);
+	port->xmit_cnt = port->xmit_head = port->xmit_tail = 0;
+	spin_unlock_irqrestore(&riscom_lock, flags);
+
+	tty_wakeup(tty);
+}
+
+static void rc_close(struct tty_struct *tty, struct file *filp)
@@ -1024 +1024 @@
-	
+
@@ -1032 +1032 @@
-	
+
@@ -1050 +1050 @@
-	 * Now we wait for the transmit buffer to clear; and we notify 
+	 * Now we wait for the transmit buffer to clear; and we notify
@@ -1073,2 +1073,2 @@
-		timeout = jiffies+HZ;
-		while(port->IER & IER_TXEMPTY)  {
+		timeout = jiffies + HZ;
+		while (port->IER & IER_TXEMPTY) {
@@ -1081,2 +1081 @@
-	if (tty->driver->flush_buffer)
-		tty->driver->flush_buffer(tty);
+	rc_flush_buffer(tty);
@@ -1088 +1087 @@
-		if (port->close_delay) {
+		if (port->close_delay)
@@ -1090 +1088,0 @@
-		}
@@ -1100 +1098 @@
-static int rc_write(struct tty_struct * tty, 
+static int rc_write(struct tty_struct *tty,
@@ -1107 +1105 @@
-				
+
@@ -1110 +1108 @@
-	
+
@@ -1147 +1145 @@
-static void rc_put_char(struct tty_struct * tty, unsigned char ch)
+static int rc_put_char(struct tty_struct *tty, unsigned char ch)
@@ -1150,0 +1149 @@
+	int ret = 0;
@@ -1153 +1152 @@
-		return;
+		return 0;
@@ -1156 +1155 @@
-		return;
+		return 0;
@@ -1159 +1158 @@
-	
+
@@ -1165,0 +1165 @@
+	ret = 1;
@@ -1168,0 +1169 @@
+	return ret;
@@ -1171 +1172 @@
-static void rc_flush_chars(struct tty_struct * tty)
+static void rc_flush_chars(struct tty_struct *tty)
@@ -1175 +1176 @@
-				
+
@@ -1178 +1179 @@
-	
+
@@ -1192 +1193 @@
-static int rc_write_room(struct tty_struct * tty)
+static int rc_write_room(struct tty_struct *tty)
@@ -1196 +1197 @@
-				
+
@@ -1209 +1210 @@
-				
+
@@ -1212,15 +1212,0 @@
-	
-	return port->xmit_cnt;
-}
-
-static void rc_flush_buffer(struct tty_struct *tty)
-{
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
-	unsigned long flags;
-				
-	if (rc_paranoia_check(port, tty->name, "rc_flush_buffer"))
-		return;
-
-	spin_lock_irqsave(&riscom_lock, flags);
-
-	port->xmit_cnt = port->xmit_head = port->xmit_tail = 0;
@@ -1228,3 +1214 @@
-	spin_unlock_irqrestore(&riscom_lock, flags);
-	
-	tty_wakeup(tty);
+	return port->xmit_cnt;
@@ -1236 +1220 @@
-	struct riscom_board * bp;
+	struct riscom_board *bp;
@@ -1241 +1225 @@
-	if (rc_paranoia_check(port, tty->name, __FUNCTION__))
+	if (rc_paranoia_check(port, tty->name, __func__))
@@ -1269 +1253 @@
-	if (rc_paranoia_check(port, tty->name, __FUNCTION__))
+	if (rc_paranoia_check(port, tty->name, __func__))
@@ -1295 +1279 @@
-static inline void rc_send_break(struct riscom_port * port, unsigned long length)
+static void rc_send_break(struct riscom_port *port, unsigned long length)
@@ -1299 +1283 @@
-	
+
@@ -1315,2 +1299,2 @@
-static inline int rc_set_serial_info(struct riscom_port * port,
-				     struct serial_struct __user * newinfo)
+static int rc_set_serial_info(struct riscom_port *port,
+				     struct serial_struct __user *newinfo)
@@ -1321 +1305 @@
-	
+
@@ -1324,2 +1308,2 @@
-	
-#if 0	
+
+#if 0
@@ -1334,2 +1318,2 @@
-#endif	
-	
+#endif
+
@@ -1338 +1322 @@
-	
+
@@ -1343 +1327 @@
-		     (port->flags & ~ASYNC_USR_MASK)))  
+		     (port->flags & ~ASYNC_USR_MASK)))
@@ -1363 +1347 @@
-static inline int rc_get_serial_info(struct riscom_port * port,
+static int rc_get_serial_info(struct riscom_port *port,
@@ -1368 +1352 @@
-	
+
@@ -1382 +1366 @@
-static int rc_ioctl(struct tty_struct * tty, struct file * filp, 
+static int rc_ioctl(struct tty_struct *tty, struct file *filp,
@@ -1384 +1367,0 @@
-		    
@@ -1388,2 +1371,2 @@
-	int retval;
-				
+	int retval = 0;
+
@@ -1392 +1375 @@
-	
+
@@ -1394 +1377 @@
-	 case TCSBRK:	/* SVID version: non-zero arg --> no break */
+	case TCSBRK:	/* SVID version: non-zero arg --> no break */
@@ -1402 +1385 @@
-	 case TCSBRKP:	/* support for POSIX tcsendbreak() */
+	case TCSBRKP:	/* support for POSIX tcsendbreak() */
@@ -1409,8 +1392,4 @@
-	 case TIOCGSOFTCAR:
-		return put_user(C_CLOCAL(tty) ? 1 : 0, (unsigned __user *)argp);
-	 case TIOCSSOFTCAR:
-		if (get_user(arg,(unsigned __user *) argp))
-			return -EFAULT;
-		tty->termios->c_cflag =
-			((tty->termios->c_cflag & ~CLOCAL) |
-			(arg ? CLOCAL : 0));
+	case TIOCGSERIAL:
+		lock_kernel();
+		retval = rc_get_serial_info(port, argp);
+		unlock_kernel();
@@ -1418,6 +1397,7 @@
-	 case TIOCGSERIAL:	
-		return rc_get_serial_info(port, argp);
-	 case TIOCSSERIAL:	
-		return rc_set_serial_info(port, argp);
-	 default:
-		return -ENOIOCTLCMD;
+	case TIOCSSERIAL:
+		lock_kernel();
+		retval = rc_set_serial_info(port, argp);
+		unlock_kernel();
+		break;
+	default:
+		retval = -ENOIOCTLCMD;
@@ -1425 +1405 @@
-	return 0;
+	return retval;
@@ -1428 +1408 @@
-static void rc_throttle(struct tty_struct * tty)
+static void rc_throttle(struct tty_struct *tty)
@@ -1433 +1413 @@
-				
+
@@ -1436 +1415,0 @@
-	
@@ -1440 +1418,0 @@
-
@@ -1449 +1426,0 @@
-
@@ -1453 +1430 @@
-static void rc_unthrottle(struct tty_struct * tty)
+static void rc_unthrottle(struct tty_struct *tty)
@@ -1458 +1435 @@
-				
+
@@ -1461 +1437,0 @@
-	
@@ -1463,2 +1438,0 @@
-	
-	spin_lock_irqsave(&riscom_lock, flags);
@@ -1465,0 +1440 @@
+	spin_lock_irqsave(&riscom_lock, flags);
@@ -1474 +1448,0 @@
-
@@ -1478 +1452 @@
-static void rc_stop(struct tty_struct * tty)
+static void rc_stop(struct tty_struct *tty)
@@ -1483 +1457 @@
-				
+
@@ -1486 +1460 @@
-	
+
@@ -1488,2 +1461,0 @@
-	
-	spin_lock_irqsave(&riscom_lock, flags);
@@ -1490,0 +1463 @@
+	spin_lock_irqsave(&riscom_lock, flags);
@@ -1494 +1466,0 @@
-
@@ -1498 +1470 @@
-static void rc_start(struct tty_struct * tty)
+static void rc_start(struct tty_struct *tty)
@@ -1503 +1475 @@
-				
+
@@ -1506 +1478 @@
-	
+
@@ -1508 +1480 @@
-	
+
@@ -1511 +1483 @@
-	if (port->xmit_cnt && port->xmit_buf && !(port->IER & IER_TXRDY))  {
+	if (port->xmit_cnt && port->xmit_buf && !(port->IER & IER_TXRDY)) {
@@ -1516 +1487,0 @@
-
@@ -1520 +1491 @@
-static void rc_hangup(struct tty_struct * tty)
+static void rc_hangup(struct tty_struct *tty)
@@ -1524 +1495 @@
-				
+
@@ -1527 +1498 @@
-	
+
@@ -1529 +1500 @@
-	
+
@@ -1537 +1508,2 @@
-static void rc_set_termios(struct tty_struct * tty, struct ktermios * old_termios)
+static void rc_set_termios(struct tty_struct *tty,
+					struct ktermios *old_termios)
@@ -1541 +1513 @@
-				
+
@@ -1544,4 +1515,0 @@
-	
-	if (tty->termios->c_cflag == old_termios->c_cflag &&
-	    tty->termios->c_iflag == old_termios->c_iflag)
-		return;
@@ -1586 +1554 @@
-	if (!riscom_driver)	
+	if (!riscom_driver)
@@ -1588 +1556 @@
-	
+
@@ -1601 +1569,2 @@
-	if ((error = tty_register_driver(riscom_driver)))  {
+	error = tty_register_driver(riscom_driver);
+	if (error != 0) {
@@ -1604,2 +1573 @@
-				"error = %d\n",
-		       error);
+				"error = %d\n", error);
@@ -1608 +1575,0 @@
-
@@ -1612,2 +1579,2 @@
-		rc_port[i].close_delay = 50 * HZ/100;
-		rc_port[i].closing_wait = 3000 * HZ/100;
+		rc_port[i].close_delay = 50 * HZ / 100;
+		rc_port[i].closing_wait = 3000 * HZ / 100;
@@ -1617 +1583,0 @@
-	
@@ -1630 +1596 @@
- * 
+ *
@@ -1636 +1602 @@
- */ 
+ */
@@ -1647 +1613 @@
-		else 
+		else
@@ -1662,2 +1628,2 @@
-/* 
- * This routine must be called by kernel at boot time 
+/*
+ * This routine must be called by kernel at boot time
@@ -1672 +1638 @@
-	if (rc_init_drivers()) 
+	if (rc_init_drivers())
@@ -1675,2 +1641,2 @@
-	for (i = 0; i < RC_NBOARD; i++) 
-		if (rc_board[i].base && !rc_probe(&rc_board[i]))  
+	for (i = 0; i < RC_NBOARD; i++)
+		if (rc_board[i].base && !rc_probe(&rc_board[i]))
@@ -1678 +1643,0 @@
-	
@@ -1705 +1670 @@
-static int __init riscom8_init_module (void)
+static int __init riscom8_init_module(void)
@@ -1711 +1676 @@
-		for(i = 0; i < RC_NBOARD; i++)
+		for (i = 0; i < RC_NBOARD; i++)
@@ -1727,2 +1692,2 @@
-	
-static void __exit riscom8_exit_module (void)
+
+static void __exit riscom8_exit_module(void)
@@ -1731 +1696 @@
-	
+
@@ -1733,2 +1698,2 @@
-	for (i = 0; i < RC_NBOARD; i++)  
-		if (rc_board[i].flags & RC_BOARD_PRESENT) 
+	for (i = 0; i < RC_NBOARD; i++)
+		if (rc_board[i].flags & RC_BOARD_PRESENT)
@@ -1736 +1701 @@
-	
+
@@ -1741 +1705,0 @@
-
--- ./projects/linux/linux-2.6.26/drivers/char/riscom8.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/char/riscom8.c	2008-10-10 00:13:53.000000000 +0200
@@ -325 +325 @@
-		if (port->flags & ASYNC_INITIALIZED)
+		if (port->port.flags & ASYNC_INITIALIZED)
@@ -344 +344 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -367 +367 @@
-		if (port->flags & ASYNC_SAK)
+		if (port->port.flags & ASYNC_SAK)
@@ -395 +395 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -425 +425 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -470 +470 @@
-		rc_out(bp, CD180_TDR, port->xmit_buf[port->xmit_tail++]);
+		rc_out(bp, CD180_TDR, port->port.xmit_buf[port->xmit_tail++]);
@@ -495 +495 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -500 +500 @@
-			wake_up_interruptible(&port->open_wait);
+			wake_up_interruptible(&port->port.open_wait);
@@ -635 +635 @@
-	struct tty_struct *tty = port->tty;
+	struct tty_struct *tty = port->port.tty;
@@ -641,3 +640,0 @@
-	if (tty == NULL || tty->termios == NULL)
-		return;
-
@@ -789 +786 @@
-	if (port->flags & ASYNC_INITIALIZED)
+	if (port->port.flags & ASYNC_INITIALIZED)
@@ -792,10 +789,3 @@
-	if (!port->xmit_buf) {
-		/* We may sleep in get_zeroed_page() */
-		unsigned long tmp = get_zeroed_page(GFP_KERNEL);
-		if (tmp == 0)
-			return -ENOMEM;
-		if (port->xmit_buf)
-			free_page(tmp);
-		else
-			port->xmit_buf = (unsigned char *) tmp;
-	}
+	if (tty_port_alloc_xmit_buf(&port->port) < 0)
+		return -ENOMEM;
+
@@ -804,3 +794,2 @@
-	if (port->tty)
-		clear_bit(TTY_IO_ERROR, &port->tty->flags);
-	if (port->count == 1)
+	clear_bit(TTY_IO_ERROR, &port->port.tty->flags);
+	if (port->port.count == 1)
@@ -810 +799 @@
-	port->flags |= ASYNC_INITIALIZED;
+	port->port.flags |= ASYNC_INITIALIZED;
@@ -817 +806,2 @@
-static void rc_shutdown_port(struct riscom_board *bp, struct riscom_port *port)
+static void rc_shutdown_port(struct tty_struct *tty,
+			struct riscom_board *bp, struct riscom_port *port)
@@ -819,3 +809 @@
-	struct tty_struct *tty;
-
-	if (!(port->flags & ASYNC_INITIALIZED))
+	if (!(port->port.flags & ASYNC_INITIALIZED))
@@ -839,8 +827,2 @@
-	if (port->xmit_buf)  {
-		free_page((unsigned long) port->xmit_buf);
-		port->xmit_buf = NULL;
-	}
-
-	tty = port->tty;
-
-	if (tty == NULL || C_HUPCL(tty)) {
+	tty_port_free_xmit_buf(&port->port);
+	if (C_HUPCL(tty)) {
@@ -861,3 +843,2 @@
-	if (tty)
-		set_bit(TTY_IO_ERROR, &tty->flags);
-	port->flags &= ~ASYNC_INITIALIZED;
+	set_bit(TTY_IO_ERROR, &tty->flags);
+	port->port.flags &= ~ASYNC_INITIALIZED;
@@ -893,3 +874,3 @@
-	if (tty_hung_up_p(filp) || port->flags & ASYNC_CLOSING) {
-		interruptible_sleep_on(&port->close_wait);
-		if (port->flags & ASYNC_HUP_NOTIFY)
+	if (tty_hung_up_p(filp) || port->port.flags & ASYNC_CLOSING) {
+		interruptible_sleep_on(&port->port.close_wait);
+		if (port->port.flags & ASYNC_HUP_NOTIFY)
@@ -907 +888 @@
-		port->flags |= ASYNC_NORMAL_ACTIVE;
+		port->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -922 +903 @@
-	add_wait_queue(&port->open_wait, &wait);
+	add_wait_queue(&port->port.open_wait, &wait);
@@ -927 +908 @@
-		port->count--;
+		port->port.count--;
@@ -931 +912 @@
-	port->blocked_open++;
+	port->port.blocked_open++;
@@ -945,2 +926,2 @@
-		    !(port->flags & ASYNC_INITIALIZED)) {
-			if (port->flags & ASYNC_HUP_NOTIFY)
+		    !(port->port.flags & ASYNC_INITIALIZED)) {
+			if (port->port.flags & ASYNC_HUP_NOTIFY)
@@ -952 +933 @@
-		if (!(port->flags & ASYNC_CLOSING) &&
+		if (!(port->port.flags & ASYNC_CLOSING) &&
@@ -962 +943 @@
-	remove_wait_queue(&port->open_wait, &wait);
+	remove_wait_queue(&port->port.open_wait, &wait);
@@ -964,2 +945,2 @@
-		port->count++;
-	port->blocked_open--;
+		port->port.count++;
+	port->port.blocked_open--;
@@ -969 +950 @@
-	port->flags |= ASYNC_NORMAL_ACTIVE;
+	port->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -993 +974 @@
-	port->count++;
+	port->port.count++;
@@ -995 +976 @@
-	port->tty = tty;
+	port->port.tty = tty;
@@ -1034 +1015 @@
-	if ((tty->count == 1) && (port->count != 1))  {
+	if ((tty->count == 1) && (port->port.count != 1))  {
@@ -1037,2 +1018,2 @@
-		       board_No(bp), port->count);
-		port->count = 1;
+		       board_No(bp), port->port.count);
+		port->port.count = 1;
@@ -1040 +1021 @@
-	if (--port->count < 0)  {
+	if (--port->port.count < 0)  {
@@ -1043,2 +1024,2 @@
-		       board_No(bp), port_No(port), port->count);
-		port->count = 0;
+		       board_No(bp), port_No(port), port->port.count);
+		port->port.count = 0;
@@ -1046 +1027 @@
-	if (port->count)
+	if (port->port.count)
@@ -1048 +1029 @@
-	port->flags |= ASYNC_CLOSING;
+	port->port.flags |= ASYNC_CLOSING;
@@ -1054,2 +1035,2 @@
-	if (port->closing_wait != ASYNC_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, port->closing_wait);
+	if (port->port.closing_wait != ASYNC_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, port->port.closing_wait);
@@ -1063 +1044 @@
-	if (port->flags & ASYNC_INITIALIZED) {
+	if (port->port.flags & ASYNC_INITIALIZED) {
@@ -1080 +1061 @@
-	rc_shutdown_port(bp, port);
+	rc_shutdown_port(tty, bp, port);
@@ -1085,5 +1066,5 @@
-	port->tty = NULL;
-	if (port->blocked_open) {
-		if (port->close_delay)
-			msleep_interruptible(jiffies_to_msecs(port->close_delay));
-		wake_up_interruptible(&port->open_wait);
+	port->port.tty = NULL;
+	if (port->port.blocked_open) {
+		if (port->port.close_delay)
+			msleep_interruptible(jiffies_to_msecs(port->port.close_delay));
+		wake_up_interruptible(&port->port.open_wait);
@@ -1091,2 +1072,2 @@
-	port->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-	wake_up_interruptible(&port->close_wait);
+	port->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
+	wake_up_interruptible(&port->port.close_wait);
@@ -1111,3 +1091,0 @@
-	if (!tty || !port->xmit_buf)
-		return 0;
-
@@ -1122 +1100 @@
-		memcpy(port->xmit_buf + port->xmit_head, buf, c);
+		memcpy(port->port.xmit_buf + port->xmit_head, buf, c);
@@ -1154,3 +1131,0 @@
-	if (!tty || !port->xmit_buf)
-		return 0;
-
@@ -1162 +1137 @@
-	port->xmit_buf[port->xmit_head++] = ch;
+	port->port.xmit_buf[port->xmit_head++] = ch;
@@ -1180,2 +1155 @@
-	if (port->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||
-	    !port->xmit_buf)
+	if (port->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped)
@@ -1279 +1253 @@
-static void rc_send_break(struct riscom_port *port, unsigned long length)
+static int rc_send_break(struct tty_struct *tty, int length)
@@ -1280,0 +1255 @@
+	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
@@ -1283,0 +1259,3 @@
+	if (length == 0 || length == -1)
+		return -EOPNOTSUPP;
+
@@ -1296,0 +1275 @@
+	return 0;
@@ -1320 +1299 @@
-	change_speed = ((port->flags & ASYNC_SPD_MASK) !=
+	change_speed = ((port->port.flags & ASYNC_SPD_MASK) !=
@@ -1324,2 +1303,2 @@
-		if ((tmp.close_delay != port->close_delay) ||
-		    (tmp.closing_wait != port->closing_wait) ||
+		if ((tmp.close_delay != port->port.close_delay) ||
+		    (tmp.closing_wait != port->port.closing_wait) ||
@@ -1327 +1306 @@
-		     (port->flags & ~ASYNC_USR_MASK)))
+		     (port->port.flags & ~ASYNC_USR_MASK)))
@@ -1329 +1308 @@
-		port->flags = ((port->flags & ~ASYNC_USR_MASK) |
+		port->port.flags = ((port->port.flags & ~ASYNC_USR_MASK) |
@@ -1332 +1311 @@
-		port->flags = ((port->flags & ~ASYNC_FLAGS) |
+		port->port.flags = ((port->port.flags & ~ASYNC_FLAGS) |
@@ -1334,2 +1313,2 @@
-		port->close_delay = tmp.close_delay;
-		port->closing_wait = tmp.closing_wait;
+		port->port.close_delay = tmp.close_delay;
+		port->port.closing_wait = tmp.closing_wait;
@@ -1358 +1337 @@
-	tmp.flags = port->flags;
+	tmp.flags = port->port.flags;
@@ -1360,2 +1339,2 @@
-	tmp.close_delay = port->close_delay * HZ/100;
-	tmp.closing_wait = port->closing_wait * HZ/100;
+	tmp.close_delay = port->port.close_delay * HZ/100;
+	tmp.closing_wait = port->port.closing_wait * HZ/100;
@@ -1371 +1350 @@
-	int retval = 0;
+	int retval;
@@ -1377,15 +1355,0 @@
-	case TCSBRK:	/* SVID version: non-zero arg --> no break */
-		retval = tty_check_change(tty);
-		if (retval)
-			return retval;
-		tty_wait_until_sent(tty, 0);
-		if (!arg)
-			rc_send_break(port, HZ/4);	/* 1/4 second */
-		break;
-	case TCSBRKP:	/* support for POSIX tcsendbreak() */
-		retval = tty_check_change(tty);
-		if (retval)
-			return retval;
-		tty_wait_until_sent(tty, 0);
-		rc_send_break(port, arg ? arg*(HZ/10) : HZ/4);
-		break;
@@ -1483 +1447 @@
-	if (port->xmit_cnt && port->xmit_buf && !(port->IER & IER_TXRDY)) {
+	if (port->xmit_cnt && port->port.xmit_buf && !(port->IER & IER_TXRDY)) {
@@ -1501,5 +1465,5 @@
-	rc_shutdown_port(bp, port);
-	port->count = 0;
-	port->flags &= ~ASYNC_NORMAL_ACTIVE;
-	port->tty = NULL;
-	wake_up_interruptible(&port->open_wait);
+	rc_shutdown_port(tty, bp, port);
+	port->port.count = 0;
+	port->port.flags &= ~ASYNC_NORMAL_ACTIVE;
+	port->port.tty = NULL;
+	wake_up_interruptible(&port->port.open_wait);
@@ -1545,0 +1510 @@
+	.break_ctl = rc_send_break,
@@ -1567 +1532 @@
-	riscom_driver->flags = TTY_DRIVER_REAL_RAW;
+	riscom_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_HARDWARE_BREAK;
@@ -1577,0 +1543 @@
+		tty_port_init(&rc_port[i].port);
@@ -1579,4 +1544,0 @@
-		rc_port[i].close_delay = 50 * HZ / 100;
-		rc_port[i].closing_wait = 3000 * HZ / 100;
-		init_waitqueue_head(&rc_port[i].open_wait);
-		init_waitqueue_head(&rc_port[i].close_wait);
--- ./projects/linux/linux-2.6.28/drivers/char/riscom8.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/char/riscom8.c	2009-03-24 00:12:14.000000000 +0100
@@ -860,2 +860 @@
-static int block_til_ready(struct tty_struct *tty, struct file *filp,
-			   struct riscom_port *port)
+static int carrier_raised(struct tty_port *port)
@@ -863,5 +862,2 @@
-	DECLARE_WAITQUEUE(wait, current);
-	struct riscom_board *bp = port_Board(port);
-	int    retval;
-	int    do_clocal = 0;
-	int    CD;
+	struct riscom_port *p = container_of(port, struct riscom_port, port);
+	struct riscom_board *bp = port_Board(p);
@@ -869,36 +865,2 @@
-
-	/*
-	 * If the device is in the middle of being closed, then block
-	 * until it's done, and then try again.
-	 */
-	if (tty_hung_up_p(filp) || port->port.flags & ASYNC_CLOSING) {
-		interruptible_sleep_on(&port->port.close_wait);
-		if (port->port.flags & ASYNC_HUP_NOTIFY)
-			return -EAGAIN;
-		else
-			return -ERESTARTSYS;
-	}
-
-	/*
-	 * If non-blocking mode is set, or the port is not enabled,
-	 * then make the check up front and then exit.
-	 */
-	if ((filp->f_flags & O_NONBLOCK) ||
-	    (tty->flags & (1 << TTY_IO_ERROR))) {
-		port->port.flags |= ASYNC_NORMAL_ACTIVE;
-		return 0;
-	}
-
-	if (C_CLOCAL(tty))
-		do_clocal = 1;
-
-	/*
-	 * Block waiting for the carrier detect and the line to become
-	 * free (i.e., not in use by the callout).  While we are in
-	 * this loop, info->count is dropped by one, so that
-	 * rs_close() knows when to free things.  We restore it upon
-	 * exit, either normal or abnormal.
-	 */
-	retval = 0;
-	add_wait_queue(&port->port.open_wait, &wait);
-
+	int CD;
+	
@@ -906,4 +868,5 @@
-
-	if (!tty_hung_up_p(filp))
-		port->port.count--;
-
+	rc_out(bp, CD180_CAR, port_No(p));
+	CD = rc_in(bp, CD180_MSVR) & MSVR_CD;
+	rc_out(bp, CD180_MSVR, MSVR_RTS);
+	bp->DTR &= ~(1u << port_No(p));
+	rc_out(bp, RC_DTR, bp->DTR);
@@ -911,41 +874 @@
-
-	port->port.blocked_open++;
-	while (1) {
-		spin_lock_irqsave(&riscom_lock, flags);
-
-		rc_out(bp, CD180_CAR, port_No(port));
-		CD = rc_in(bp, CD180_MSVR) & MSVR_CD;
-		rc_out(bp, CD180_MSVR, MSVR_RTS);
-		bp->DTR &= ~(1u << port_No(port));
-		rc_out(bp, RC_DTR, bp->DTR);
-
-		spin_unlock_irqrestore(&riscom_lock, flags);
-
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (tty_hung_up_p(filp) ||
-		    !(port->port.flags & ASYNC_INITIALIZED)) {
-			if (port->port.flags & ASYNC_HUP_NOTIFY)
-				retval = -EAGAIN;
-			else
-				retval = -ERESTARTSYS;
-			break;
-		}
-		if (!(port->port.flags & ASYNC_CLOSING) &&
-		    (do_clocal || CD))
-			break;
-		if (signal_pending(current)) {
-			retval = -ERESTARTSYS;
-			break;
-		}
-		schedule();
-	}
-	__set_current_state(TASK_RUNNING);
-	remove_wait_queue(&port->port.open_wait, &wait);
-	if (!tty_hung_up_p(filp))
-		port->port.count++;
-	port->port.blocked_open--;
-	if (retval)
-		return retval;
-
-	port->port.flags |= ASYNC_NORMAL_ACTIVE;
-	return 0;
+	return CD;
@@ -980 +903 @@
-		error = block_til_ready(tty, filp, port);
+		error = tty_port_block_til_ready(&port->port, tty, filp);
@@ -986 +909 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1001 +924 @@
-	struct riscom_port *port = (struct riscom_port *) tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1009,5 +931,0 @@
-	spin_lock_irqsave(&riscom_lock, flags);
-
-	if (tty_hung_up_p(filp))
-		goto out;
-
@@ -1015,22 +933,4 @@
-	if ((tty->count == 1) && (port->port.count != 1))  {
-		printk(KERN_INFO "rc%d: rc_close: bad port count;"
-		       " tty->count is 1, port count is %d\n",
-		       board_No(bp), port->port.count);
-		port->port.count = 1;
-	}
-	if (--port->port.count < 0)  {
-		printk(KERN_INFO "rc%d: rc_close: bad port count "
-				 "for tty%d: %d\n",
-		       board_No(bp), port_No(port), port->port.count);
-		port->port.count = 0;
-	}
-	if (port->port.count)
-		goto out;
-	port->port.flags |= ASYNC_CLOSING;
-	/*
-	 * Now we wait for the transmit buffer to clear; and we notify
-	 * the line discipline to only process XON/XOFF characters.
-	 */
-	tty->closing = 1;
-	if (port->port.closing_wait != ASYNC_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, port->port.closing_wait);
+	
+	if (tty_port_close_start(&port->port, tty, filp) == 0)
+		return;
+	
@@ -1042,0 +943,2 @@
+
+	spin_lock_irqsave(&riscom_lock, flags);
@@ -1055,0 +958 @@
+			spin_unlock_irqrestore(&riscom_lock, flags);
@@ -1056,0 +960 @@
+			spin_lock_irqsave(&riscom_lock, flags);
@@ -1063,13 +966,0 @@
-	tty_ldisc_flush(tty);
-
-	tty->closing = 0;
-	port->port.tty = NULL;
-	if (port->port.blocked_open) {
-		if (port->port.close_delay)
-			msleep_interruptible(jiffies_to_msecs(port->port.close_delay));
-		wake_up_interruptible(&port->port.open_wait);
-	}
-	port->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-	wake_up_interruptible(&port->port.close_wait);
-
-out:
@@ -1076,0 +968,2 @@
+
+	tty_port_close_end(&port->port, tty);
@@ -1082 +975 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1125 +1018 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1149 +1042 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1169 +1062 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1183 +1076 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1193 +1086 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1223 +1116 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1255 +1148 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1348 +1241 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1374 +1267 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1396 +1289 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1418 +1311 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1436 +1329 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1457 +1350 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1458,0 +1352 @@
+	unsigned long flags;
@@ -1465,0 +1360 @@
+	spin_lock_irqsave(&port->port.lock, flags);
@@ -1469,0 +1365 @@
+	spin_unlock_irqrestore(&port->port.lock, flags);
@@ -1475 +1371 @@
-	struct riscom_port *port = (struct riscom_port *)tty->driver_data;
+	struct riscom_port *port = tty->driver_data;
@@ -1512,0 +1409,5 @@
+static const struct tty_port_operations riscom_port_ops = {
+	.carrier_raised = carrier_raised,
+};
+
+
@@ -1543,0 +1445 @@
+		rc_port[i].port.ops = &riscom_port_ops;
--- ./projects/linux/linux-2.6.29/drivers/char/riscom8.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/char/riscom8.c	2009-06-27 11:32:32.000000000 +0200
@@ -50,0 +51 @@
+#include <linux/device.h>
@@ -1526,0 +1528 @@
+MODULE_ALIAS_CHARDEV_MAJOR(RISCOM8_NORMAL_MAJOR);
--- ./projects/linux/linux-2.6.15/drivers/char/serial167.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/serial167.c	2006-03-20 06:53:29.000000000 +0100
@@ -120 +120 @@
-#define NR_PORTS        (sizeof(cy_port)/sizeof(struct cyclades_port))
+#define NR_PORTS        ARRAY_SIZE(cy_port)
@@ -132 +131,0 @@
-DECLARE_MUTEX(tmp_buf_sem);
@@ -425,2 +424 @@
-	if (tty->flip.count < TTY_FLIPBUF_SIZE){
-	    tty->flip.count++;
+	if (tty_buffer_request_room(tty, 1) != 0){
@@ -429,2 +427 @@
-		    *tty->flip.flag_buf_ptr++ = TTY_BREAK;
-		    *tty->flip.char_buf_ptr++ = data;
+		    tty_insert_flip_char(tty, data, TTY_BREAK);
@@ -435,2 +432 @@
-		    *tty->flip.flag_buf_ptr++ = TTY_FRAME;
-		    *tty->flip.char_buf_ptr++ = data;
+		    tty_insert_flip_char(tty, data, TTY_FRAME);
@@ -438,2 +434 @@
-		    *tty->flip.flag_buf_ptr++ = TTY_PARITY;
-		    *tty->flip.char_buf_ptr++ = data;
+		    tty_insert_flip_char(tty, data, TTY_PARITY);
@@ -441,2 +436 @@
-		    *tty->flip.flag_buf_ptr++ = TTY_OVERRUN;
-		    *tty->flip.char_buf_ptr++ = 0;
+		    tty_insert_flip_char(tty, 0, TTY_OVERRUN);
@@ -448,5 +442,2 @@
-		    if(tty->flip.count < TTY_FLIPBUF_SIZE){
-			tty->flip.count++;
-			*tty->flip.flag_buf_ptr++ = TTY_NORMAL;
-			*tty->flip.char_buf_ptr++ = data;
-		    }
+		    tty_insert_flip_char(tty, data, TTY_NORMAL);
+		}
@@ -458,2 +449 @@
-		    *tty->flip.flag_buf_ptr++ = 0;
-		    *tty->flip.char_buf_ptr++ = 0;
+		    tty_insert_flip_char(tty, 0, TTY_NORMAL);
@@ -462,2 +452 @@
-		*tty->flip.flag_buf_ptr++ = 0;
-		*tty->flip.char_buf_ptr++ = 0;
+		    tty_insert_flip_char(tty, data, TTY_NORMAL);
@@ -695,6 +684 @@
-	    if (tty->flip.count >= TTY_FLIPBUF_SIZE){
-		continue;
-	    }
-	    tty->flip.count++;
-	    *tty->flip.flag_buf_ptr++ = TTY_NORMAL;
-	    *tty->flip.char_buf_ptr++ = data;
+	    tty_insert_flip_char(tty, data, TTY_NORMAL);
--- ./projects/linux/linux-2.6.17/drivers/char/serial167.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/serial167.c	2006-09-20 05:42:06.000000000 +0200
@@ -47 +46,0 @@
-#include <linux/config.h>
@@ -2238 +2236,0 @@
-    cy_serial_driver->devfs_name = "tts/";
--- ./projects/linux/linux-2.6.18/drivers/char/serial167.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/serial167.c	2006-11-29 22:57:37.000000000 +0100
@@ -64,0 +65 @@
+#include <linux/tty_flip.h>
@@ -122,11 +122,0 @@
- * tmp_buf is used as a temporary buffer by serial_write.  We need to
- * lock it in case the copy_from_user blocks while swapping in a page,
- * and some other program tries to do a serial write at the same time.
- * Since the lock will only come under contention when the system is
- * swapping and available memory is low, it makes sense to share one
- * buffer across all the serial ports, since it significantly saves
- * memory if large numbers of serial ports are open.
- */
-static unsigned char *tmp_buf = 0;
-
-/*
@@ -384 +374 @@
-cd2401_rxerr_interrupt(int irq, void *dev_id, struct pt_regs *fp)
+cd2401_rxerr_interrupt(int irq, void *dev_id)
@@ -441,2 +431,3 @@
-		    tty_insert_flip_char(tty, data, TTY_NORMAL);
-		}
+		    if (tty_buffer_request_room(tty, 1) != 0){
+			tty_insert_flip_char(tty, data, TTY_FRAME);
+		    }
@@ -451 +442 @@
-		    tty_insert_flip_char(tty, data, TTY_NORMAL);
+		tty_insert_flip_char(tty, data, TTY_NORMAL);
@@ -458 +449 @@
-    schedule_delayed_work(&tty->flip.work, 1);
+    tty_schedule_flip(tty);
@@ -465 +456 @@
-cd2401_modem_interrupt(int irq, void *dev_id, struct pt_regs *fp)
+cd2401_modem_interrupt(int irq, void *dev_id)
@@ -520 +511 @@
-cd2401_tx_interrupt(int irq, void *dev_id, struct pt_regs *fp)
+cd2401_tx_interrupt(int irq, void *dev_id)
@@ -640 +631 @@
-cd2401_rx_interrupt(int irq, void *dev_id, struct pt_regs *fp)
+cd2401_rx_interrupt(int irq, void *dev_id)
@@ -648,0 +640 @@
+    int len;
@@ -681 +673,2 @@
-	while(char_count--){
+	len = tty_buffer_request_room(tty, char_count);
+	while(len--){
@@ -688 +681 @@
-	schedule_delayed_work(&tty->flip.work, 1);
+	tty_schedule_flip(tty);
@@ -849 +842 @@
-	    info->xmit_buf = 0;
+	    info->xmit_buf = NULL;
@@ -1135 +1128 @@
-    if (!tty || !info->xmit_buf)
+    if (!info->xmit_buf)
@@ -1201 +1194 @@
-    if (!tty || !info->xmit_buf || !tmp_buf){
+    if (!info->xmit_buf){
@@ -1364 +1357 @@
-                           struct serial_struct * retinfo)
+                           struct serial_struct __user * retinfo)
@@ -1386 +1379 @@
-                           struct serial_struct * new_info)
+                           struct serial_struct __user * new_info)
@@ -1436 +1428,0 @@
-  unsigned int result;
@@ -1460 +1451,0 @@
-  unsigned int arg;
@@ -1515 +1506 @@
-get_mon_info(struct cyclades_port * info, struct cyclades_monitor * mon)
+get_mon_info(struct cyclades_port * info, struct cyclades_monitor __user * mon)
@@ -1528 +1519 @@
-set_threshold(struct cyclades_port * info, unsigned long *arg)
+set_threshold(struct cyclades_port * info, unsigned long __user *arg)
@@ -1545 +1536 @@
-get_threshold(struct cyclades_port * info, unsigned long *value)
+get_threshold(struct cyclades_port * info, unsigned long __user *value)
@@ -1558 +1549 @@
-set_default_threshold(struct cyclades_port * info, unsigned long *arg)
+set_default_threshold(struct cyclades_port * info, unsigned long __user *arg)
@@ -1570 +1561 @@
-get_default_threshold(struct cyclades_port * info, unsigned long *value)
+get_default_threshold(struct cyclades_port * info, unsigned long __user *value)
@@ -1576 +1567 @@
-set_timeout(struct cyclades_port * info, unsigned long *arg)
+set_timeout(struct cyclades_port * info, unsigned long __user *arg)
@@ -1593 +1584 @@
-get_timeout(struct cyclades_port * info, unsigned long *value)
+get_timeout(struct cyclades_port * info, unsigned long __user *value)
@@ -1613 +1604 @@
-get_default_timeout(struct cyclades_port * info, unsigned long *value)
+get_default_timeout(struct cyclades_port * info, unsigned long __user *value)
@@ -1624,0 +1616 @@
+  void __user *argp = (void __user *)arg;
@@ -1632 +1624 @@
-            ret_val = get_mon_info(info, (struct cyclades_monitor *)arg);
+            ret_val = get_mon_info(info, argp);
@@ -1635 +1627 @@
-	    ret_val = get_threshold(info, (unsigned long *)arg);
+	    ret_val = get_threshold(info, argp);
@@ -1638 +1630 @@
-            ret_val = set_threshold(info, (unsigned long *)arg);
+            ret_val = set_threshold(info, argp);
@@ -1641 +1633 @@
-	    ret_val = get_default_threshold(info, (unsigned long *)arg);
+	    ret_val = get_default_threshold(info, argp);
@@ -1644 +1636 @@
-            ret_val = set_default_threshold(info, (unsigned long *)arg);
+            ret_val = set_default_threshold(info, argp);
@@ -1647 +1639 @@
-	    ret_val = get_timeout(info, (unsigned long *)arg);
+	    ret_val = get_timeout(info, argp);
@@ -1650 +1642 @@
-            ret_val = set_timeout(info, (unsigned long *)arg);
+            ret_val = set_timeout(info, argp);
@@ -1653 +1645 @@
-	    ret_val = get_default_timeout(info, (unsigned long *)arg);
+	    ret_val = get_default_timeout(info, argp);
@@ -1676 +1668 @@
-            ret_val = put_user(C_CLOCAL(tty) ? 1 : 0, (unsigned long *) arg);
+            ret_val = put_user(C_CLOCAL(tty) ? 1 : 0, (unsigned long __user *) argp);
@@ -1679 +1671 @@
-            ret_val = get_user(val, (unsigned long *) arg);
+            ret_val = get_user(val, (unsigned long __user *) argp);
@@ -1686 +1678 @@
-            ret_val = get_serial_info(info, (struct serial_struct *) arg);
+            ret_val = get_serial_info(info, argp);
@@ -1689,2 +1681 @@
-            ret_val = set_serial_info(info,
-                                   (struct serial_struct *) arg);
+            ret_val = set_serial_info(info, argp);
@@ -1785 +1776 @@
-    info->tty = 0;
+    info->tty = NULL;
@@ -1986,7 +1976,0 @@
-    if (!tmp_buf) {
-	tmp_buf = (unsigned char *) get_zeroed_page(GFP_KERNEL);
-	if (!tmp_buf){
-	    return -ENOMEM;
-        }
-    }
-
@@ -2161 +2145 @@
-static struct tty_operations cy_ops = {
+static const struct tty_operations cy_ops = {
@@ -2269 +2253 @@
-		info->tty = 0;
+		info->tty = NULL;
--- ./projects/linux/linux-2.6.19/drivers/char/serial167.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/serial167.c	2007-02-04 19:44:54.000000000 +0100
@@ -709 +709 @@
-do_softint(void *private_)
+do_softint(struct work_struct *ugly_api)
@@ -711 +711 @@
-  struct cyclades_port *info = (struct cyclades_port *) private_;
+  struct cyclades_port *info = container_of(ugly_api, struct cyclades_port, tqueue);
@@ -1698 +1698 @@
-cy_set_termios(struct tty_struct *tty, struct termios * old_termios)
+cy_set_termios(struct tty_struct *tty, struct ktermios * old_termios)
@@ -2276 +2276 @@
-		INIT_WORK(&info->tqueue, do_softint, info);
+		INIT_WORK(&info->tqueue, do_softint);
--- ./projects/linux/linux-2.6.20/drivers/char/serial167.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/serial167.c	2007-04-26 05:08:32.000000000 +0200
@@ -114,5 +114,5 @@
-      /* CARD#  */
-        {-1 },      /* ttyS0 */
-        {-1 },      /* ttyS1 */
-        {-1 },      /* ttyS2 */
-        {-1 },      /* ttyS3 */
+	/* CARD#  */
+	{-1},			/* ttyS0 */
+	{-1},			/* ttyS1 */
+	{-1},			/* ttyS2 */
+	{-1},			/* ttyS3 */
@@ -119,0 +120 @@
+
@@ -131,3 +132,4 @@
-           0,    50,    75,   110,   134,   150,   200,   300,   600,  1200,
-        1800,  2400,  4800,  9600, 19200, 38400, 57600, 76800,115200,150000,
-        0};
+	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200,
+	1800, 2400, 4800, 9600, 19200, 38400, 57600, 76800, 115200, 150000,
+	0
+};
@@ -136,9 +138,11 @@
-static char baud_co[] = {  /* 25 MHz clock option table */
-        /* value =>    00    01   02    03    04 */
-        /* divide by    8    32   128   512  2048 */
-        0x00,  0x04,  0x04,  0x04,  0x04,  0x04,  0x03,  0x03,  0x03,  0x02,
-        0x02,  0x02,  0x01,  0x01,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00};
-
-static char baud_bpr[] = {  /* 25 MHz baud rate period table */
-        0x00,  0xf5,  0xa3,  0x6f,  0x5c,  0x51,  0xf5,  0xa3,  0x51,  0xa3,
-        0x6d,  0x51,  0xa3,  0x51,  0xa3,  0x51,  0x36,  0x29,  0x1b,  0x15};
+static char baud_co[] = {	/* 25 MHz clock option table */
+	/* value =>    00    01   02    03    04 */
+	/* divide by    8    32   128   512  2048 */
+	0x00, 0x04, 0x04, 0x04, 0x04, 0x04, 0x03, 0x03, 0x03, 0x02,
+	0x02, 0x02, 0x01, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
+
+static char baud_bpr[] = {	/* 25 MHz baud rate period table */
+	0x00, 0xf5, 0xa3, 0x6f, 0x5c, 0x51, 0xf5, 0xa3, 0x51, 0xa3,
+	0x6d, 0x51, 0xa3, 0x51, 0xa3, 0x51, 0x36, 0x29, 0x1b, 0x15
+};
@@ -150,3 +154,4 @@
-static u_char baud_co[] = {  /* 20 MHz clock option table */
-        0x00,  0x80,  0x80,  0x80,  0x80,  0x80,  0x80,  0x60,  0x60,  0x40,
-        0x40,  0x40,  0x20,  0x20,  0x00,  0x00,  0x00,  0x00,  0x00,  0x00};
+static u_char baud_co[] = {	/* 20 MHz clock option table */
+	0x00, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x60, 0x60, 0x40,
+	0x40, 0x40, 0x20, 0x20, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+};
@@ -155,8 +160,4 @@
-static u_char baud_bpr[] = {  /* 20 MHz baud rate period table */
-        0x00,  0xc0,  0x80,  0x58,  0x6c,  0x40,  0xc0,  0x81,  0x40,  0x81,
-        0x57,  0x40,  0x81,  0x40,  0x81,  0x40,  0x2b,  0x20,  0x15,  0x10};
-
-static u_char baud_cor4[] = {  /* receive threshold */
-        0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,  0x0a,
-        0x0a,  0x0a,  0x0a,  0x09,  0x09,  0x08,  0x08,  0x08,  0x08,  0x07};
-
+static u_char baud_bpr[] = {	/* 20 MHz baud rate period table */
+	0x00, 0xc0, 0x80, 0x58, 0x6c, 0x40, 0xc0, 0x81, 0x40, 0x81,
+	0x57, 0x40, 0x81, 0x40, 0x81, 0x40, 0x2b, 0x20, 0x15, 0x10
+};
@@ -163,0 +165,4 @@
+static u_char baud_cor4[] = {	/* receive threshold */
+	0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a, 0x0a,
+	0x0a, 0x0a, 0x0a, 0x09, 0x09, 0x08, 0x08, 0x08, 0x08, 0x07
+};
@@ -166 +171 @@
-static int startup (struct cyclades_port *);
+static int startup(struct cyclades_port *);
@@ -177 +182 @@
-void queueDebugChar (int c);
+void queueDebugChar(int c);
@@ -184,3 +189,3 @@
-	int	in;
-	int	out;
-	unsigned char	buf[DEBUG_LEN];
+	int in;
+	int out;
+	unsigned char buf[DEBUG_LEN];
@@ -199 +204 @@
-void my_udelay (long us)
+void my_udelay(long us)
@@ -210,3 +215,2 @@
-static inline int
-serial_paranoia_check(struct cyclades_port *info, char *name,
-		      const char *routine)
+static inline int serial_paranoia_check(struct cyclades_port *info, char *name,
+		const char *routine)
@@ -215,22 +219,18 @@
-    static const char *badmagic =
-	"Warning: bad magic number for serial struct (%s) in %s\n";
-    static const char *badinfo =
-	"Warning: null cyclades_port for (%s) in %s\n";
-    static const char *badrange =
-	"Warning: cyclades_port out of range for (%s) in %s\n";
-
-    if (!info) {
-	printk(badinfo, name, routine);
-	return 1;
-    }
-
-    if( (long)info < (long)(&cy_port[0])
-    || (long)(&cy_port[NR_PORTS]) < (long)info ){
-	printk(badrange, name, routine);
-	return 1;
-    }
-
-    if (info->magic != CYCLADES_MAGIC) {
-	printk(badmagic, name, routine);
-	return 1;
-    }
+	if (!info) {
+		printk("Warning: null cyclades_port for (%s) in %s\n", name,
+				routine);
+		return 1;
+	}
+
+	if ((long)info < (long)(&cy_port[0])
+	    || (long)(&cy_port[NR_PORTS]) < (long)info) {
+		printk("Warning: cyclades_port out of range for (%s) in %s\n",
+				name, routine);
+		return 1;
+	}
+
+	if (info->magic != CYCLADES_MAGIC) {
+		printk("Warning: bad magic number for serial struct (%s) in "
+				"%s\n", name, routine);
+		return 1;
+	}
@@ -239 +239 @@
-} /* serial_paranoia_check */
+}				/* serial_paranoia_check */
@@ -245,6 +245,6 @@
-void
-SP(char *data){
-  unsigned long flags;
-    local_irq_save(flags);
-        console_print(data);
-    local_irq_restore(flags);
+void SP(char *data)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+	console_print(data);
+	local_irq_restore(flags);
@@ -251,0 +252 @@
+
@@ -253,13 +254,28 @@
-void
-CP(char data){
-  unsigned long flags;
-    local_irq_save(flags);
-        scrn[0] = data;
-        console_print(scrn);
-    local_irq_restore(flags);
-}/* CP */
-
-void CP1(int data) { (data<10)?  CP(data+'0'): CP(data+'A'-10); }/* CP1 */
-void CP2(int data) { CP1((data>>4) & 0x0f); CP1( data & 0x0f); }/* CP2 */
-void CP4(int data) { CP2((data>>8) & 0xff); CP2(data & 0xff); }/* CP4 */
-void CP8(long data) { CP4((data>>16) & 0xffff); CP4(data & 0xffff); }/* CP8 */
+void CP(char data)
+{
+	unsigned long flags;
+	local_irq_save(flags);
+	scrn[0] = data;
+	console_print(scrn);
+	local_irq_restore(flags);
+}				/* CP */
+
+void CP1(int data)
+{
+	(data < 10) ? CP(data + '0') : CP(data + 'A' - 10);
+}				/* CP1 */
+void CP2(int data)
+{
+	CP1((data >> 4) & 0x0f);
+	CP1(data & 0x0f);
+}				/* CP2 */
+void CP4(int data)
+{
+	CP2((data >> 8) & 0xff);
+	CP2(data & 0xff);
+}				/* CP4 */
+void CP8(long data)
+{
+	CP4((data >> 16) & 0xffff);
+	CP4(data & 0xffff);
+}				/* CP8 */
@@ -273,2 +289 @@
-u_short
-write_cy_cmd(volatile u_char *base_addr, u_char cmd)
+u_short write_cy_cmd(volatile u_char * base_addr, u_char cmd)
@@ -276,2 +291,2 @@
-  unsigned long flags;
-  volatile int  i;
+	unsigned long flags;
+	volatile int i;
@@ -279 +294 @@
-    local_irq_save(flags);
+	local_irq_save(flags);
@@ -281,5 +296,5 @@
-	for(i = 0 ; i < 100 ; i++){
-	    if (base_addr[CyCCR] == 0){
-		break;
-	    }
-	    my_udelay(10L);
+	for (i = 0; i < 100; i++) {
+		if (base_addr[CyCCR] == 0) {
+			break;
+		}
+		my_udelay(10L);
@@ -288,4 +303,4 @@
-	    didn't finish within the "reasonable time" */
-	if ( i == 10 ) {
-	    local_irq_restore(flags);
-	    return (-1);
+	   didn't finish within the "reasonable time" */
+	if (i == 10) {
+		local_irq_restore(flags);
+		return (-1);
@@ -296,4 +311,3 @@
-    local_irq_restore(flags);
-    return(0);
-} /* write_cy_cmd */
-
+	local_irq_restore(flags);
+	return (0);
+}				/* write_cy_cmd */
@@ -304,2 +318 @@
-static void
-cy_stop(struct tty_struct *tty)
+static void cy_stop(struct tty_struct *tty)
@@ -307,4 +320,4 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
-  int channel;
-  unsigned long flags;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
+	int channel;
+	unsigned long flags;
@@ -313 +326 @@
-    printk("cy_stop %s\n", tty->name); /* */
+	printk("cy_stop %s\n", tty->name);	/* */
@@ -316,4 +329,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_stop"))
-	return;
-	
-    channel = info->line;
+	if (serial_paranoia_check(info, tty->name, "cy_stop"))
+		return;
@@ -321,4 +332 @@
-    local_irq_save(flags);
-        base_addr[CyCAR] = (u_char)(channel); /* index channel */
-        base_addr[CyIER] &= ~(CyTxMpty|CyTxRdy);
-    local_irq_restore(flags);
+	channel = info->line;
@@ -326,2 +334,5 @@
-    return;
-} /* cy_stop */
+	local_irq_save(flags);
+	base_addr[CyCAR] = (u_char) (channel);	/* index channel */
+	base_addr[CyIER] &= ~(CyTxMpty | CyTxRdy);
+	local_irq_restore(flags);
+}				/* cy_stop */
@@ -329,2 +340 @@
-static void
-cy_start(struct tty_struct *tty)
+static void cy_start(struct tty_struct *tty)
@@ -332,4 +342,4 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
-  int channel;
-  unsigned long flags;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
+	int channel;
+	unsigned long flags;
@@ -338 +348 @@
-    printk("cy_start %s\n", tty->name); /* */
+	printk("cy_start %s\n", tty->name);	/* */
@@ -341,9 +351,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_start"))
-	return;
-	
-    channel = info->line;
-
-    local_irq_save(flags);
-        base_addr[CyCAR] = (u_char)(channel);
-        base_addr[CyIER] |= CyTxMpty;
-    local_irq_restore(flags);
+	if (serial_paranoia_check(info, tty->name, "cy_start"))
+		return;
@@ -351,2 +354 @@
-    return;
-} /* cy_start */
+	channel = info->line;
@@ -353,0 +356,5 @@
+	local_irq_save(flags);
+	base_addr[CyCAR] = (u_char) (channel);
+	base_addr[CyIER] |= CyTxMpty;
+	local_irq_restore(flags);
+}				/* cy_start */
@@ -361,2 +368 @@
-static inline void
-cy_sched_event(struct cyclades_port *info, int event)
+static inline void cy_sched_event(struct cyclades_port *info, int event)
@@ -364,4 +370,3 @@
-    info->event |= 1 << event; /* remember what kind of event and who */
-    schedule_work(&info->tqueue);
-} /* cy_sched_event */
-
+	info->event |= 1 << event;	/* remember what kind of event and who */
+	schedule_work(&info->tqueue);
+}				/* cy_sched_event */
@@ -373,2 +378 @@
-static irqreturn_t
-cd2401_rxerr_interrupt(int irq, void *dev_id)
+static irqreturn_t cd2401_rxerr_interrupt(int irq, void *dev_id)
@@ -376,17 +380,17 @@
-    struct tty_struct *tty;
-    struct cyclades_port *info;
-    volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
-    unsigned char err, rfoc;
-    int channel;
-    char data;
-
-    /* determine the channel and change to that context */
-    channel = (u_short ) (base_addr[CyLICR] >> 2);
-    info = &cy_port[channel];
-    info->last_active = jiffies;
-
-    if ((err = base_addr[CyRISR]) & CyTIMEOUT) {
-	/* This is a receive timeout interrupt, ignore it */
-	base_addr[CyREOIR] = CyNOTRANS;
-	return IRQ_HANDLED;
-    }
+	struct tty_struct *tty;
+	struct cyclades_port *info;
+	volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
+	unsigned char err, rfoc;
+	int channel;
+	char data;
+
+	/* determine the channel and change to that context */
+	channel = (u_short) (base_addr[CyLICR] >> 2);
+	info = &cy_port[channel];
+	info->last_active = jiffies;
+
+	if ((err = base_addr[CyRISR]) & CyTIMEOUT) {
+		/* This is a receive timeout interrupt, ignore it */
+		base_addr[CyREOIR] = CyNOTRANS;
+		return IRQ_HANDLED;
+	}
@@ -394,2 +398,2 @@
-    /* Read a byte of data if there is any - assume the error
-     * is associated with this character */
+	/* Read a byte of data if there is any - assume the error
+	 * is associated with this character */
@@ -397,4 +401,4 @@
-    if ((rfoc = base_addr[CyRFOC]) != 0)
-	data = base_addr[CyRDR];
-    else
-	data = 0;
+	if ((rfoc = base_addr[CyRFOC]) != 0)
+		data = base_addr[CyRDR];
+	else
+		data = 0;
@@ -402,2 +406,55 @@
-    /* if there is nowhere to put the data, discard it */
-    if(info->tty == 0) {
+	/* if there is nowhere to put the data, discard it */
+	if (info->tty == 0) {
+		base_addr[CyREOIR] = rfoc ? 0 : CyNOTRANS;
+		return IRQ_HANDLED;
+	} else {		/* there is an open port for this data */
+		tty = info->tty;
+		if (err & info->ignore_status_mask) {
+			base_addr[CyREOIR] = rfoc ? 0 : CyNOTRANS;
+			return IRQ_HANDLED;
+		}
+		if (tty_buffer_request_room(tty, 1) != 0) {
+			if (err & info->read_status_mask) {
+				if (err & CyBREAK) {
+					tty_insert_flip_char(tty, data,
+							     TTY_BREAK);
+					if (info->flags & ASYNC_SAK) {
+						do_SAK(tty);
+					}
+				} else if (err & CyFRAME) {
+					tty_insert_flip_char(tty, data,
+							     TTY_FRAME);
+				} else if (err & CyPARITY) {
+					tty_insert_flip_char(tty, data,
+							     TTY_PARITY);
+				} else if (err & CyOVERRUN) {
+					tty_insert_flip_char(tty, 0,
+							     TTY_OVERRUN);
+					/*
+					   If the flip buffer itself is
+					   overflowing, we still loose
+					   the next incoming character.
+					 */
+					if (tty_buffer_request_room(tty, 1) !=
+					    0) {
+						tty_insert_flip_char(tty, data,
+								     TTY_FRAME);
+					}
+					/* These two conditions may imply */
+					/* a normal read should be done. */
+					/* else if(data & CyTIMEOUT) */
+					/* else if(data & CySPECHAR) */
+				} else {
+					tty_insert_flip_char(tty, 0,
+							     TTY_NORMAL);
+				}
+			} else {
+				tty_insert_flip_char(tty, data, TTY_NORMAL);
+			}
+		} else {
+			/* there was a software buffer overrun
+			   and nothing could be done about it!!! */
+		}
+	}
+	tty_schedule_flip(tty);
+	/* end of service */
@@ -406,73 +463,24 @@
-    }
-    else { /* there is an open port for this data */
-	tty = info->tty;
-	if(err & info->ignore_status_mask){
-	    base_addr[CyREOIR] = rfoc ? 0 : CyNOTRANS;
-	    return IRQ_HANDLED;
-	}
-	if (tty_buffer_request_room(tty, 1) != 0){
-	    if (err & info->read_status_mask){
-		if(err & CyBREAK){
-		    tty_insert_flip_char(tty, data, TTY_BREAK);
-		    if (info->flags & ASYNC_SAK){
-			do_SAK(tty);
-		    }
-		}else if(err & CyFRAME){
-		    tty_insert_flip_char(tty, data, TTY_FRAME);
-		}else if(err & CyPARITY){
-		    tty_insert_flip_char(tty, data, TTY_PARITY);
-		}else if(err & CyOVERRUN){
-		    tty_insert_flip_char(tty, 0, TTY_OVERRUN);
-		    /*
-		       If the flip buffer itself is
-		       overflowing, we still loose
-		       the next incoming character.
-		     */
-		    if (tty_buffer_request_room(tty, 1) != 0){
-			tty_insert_flip_char(tty, data, TTY_FRAME);
-		    }
-		/* These two conditions may imply */
-		/* a normal read should be done. */
-		/* else if(data & CyTIMEOUT) */
-		/* else if(data & CySPECHAR) */
-		}else{
-		    tty_insert_flip_char(tty, 0, TTY_NORMAL);
-		}
-	    }else{
-		tty_insert_flip_char(tty, data, TTY_NORMAL);
-	    }
-	}else{
-	    /* there was a software buffer overrun
-	       and nothing could be done about it!!! */
-	}
-    }
-    tty_schedule_flip(tty);
-    /* end of service */
-    base_addr[CyREOIR] = rfoc ? 0 : CyNOTRANS;
-    return IRQ_HANDLED;
-} /* cy_rxerr_interrupt */
-
-static irqreturn_t
-cd2401_modem_interrupt(int irq, void *dev_id)
-{
-    struct cyclades_port *info;
-    volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
-    int channel;
-    int mdm_change;
-    int mdm_status;
-
-
-    /* determine the channel and change to that context */
-    channel = (u_short ) (base_addr[CyLICR] >> 2);
-    info = &cy_port[channel];
-    info->last_active = jiffies;
-
-    mdm_change = base_addr[CyMISR];
-    mdm_status = base_addr[CyMSVR1];
-
-    if(info->tty == 0){ /* nowhere to put the data, ignore it */
-	;
-    }else{
-	if((mdm_change & CyDCD)
-	&& (info->flags & ASYNC_CHECK_CD)){
-	    if(mdm_status & CyDCD){
+}				/* cy_rxerr_interrupt */
+
+static irqreturn_t cd2401_modem_interrupt(int irq, void *dev_id)
+{
+	struct cyclades_port *info;
+	volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
+	int channel;
+	int mdm_change;
+	int mdm_status;
+
+	/* determine the channel and change to that context */
+	channel = (u_short) (base_addr[CyLICR] >> 2);
+	info = &cy_port[channel];
+	info->last_active = jiffies;
+
+	mdm_change = base_addr[CyMISR];
+	mdm_status = base_addr[CyMSVR1];
+
+	if (info->tty == 0) {	/* nowhere to put the data, ignore it */
+		;
+	} else {
+		if ((mdm_change & CyDCD)
+		    && (info->flags & ASYNC_CHECK_CD)) {
+			if (mdm_status & CyDCD) {
@@ -480,2 +488,2 @@
-		cy_sched_event(info, Cy_EVENT_OPEN_WAKEUP);
-	    } else {
+				cy_sched_event(info, Cy_EVENT_OPEN_WAKEUP);
+			} else {
@@ -483,2 +491,24 @@
-		cy_sched_event(info, Cy_EVENT_HANGUP);
-	    }
+				cy_sched_event(info, Cy_EVENT_HANGUP);
+			}
+		}
+		if ((mdm_change & CyCTS)
+		    && (info->flags & ASYNC_CTS_FLOW)) {
+			if (info->tty->stopped) {
+				if (mdm_status & CyCTS) {
+					/* !!! cy_start isn't used because... */
+					info->tty->stopped = 0;
+					base_addr[CyIER] |= CyTxMpty;
+					cy_sched_event(info,
+						       Cy_EVENT_WRITE_WAKEUP);
+				}
+			} else {
+				if (!(mdm_status & CyCTS)) {
+					/* !!! cy_stop isn't used because... */
+					info->tty->stopped = 1;
+					base_addr[CyIER] &=
+					    ~(CyTxMpty | CyTxRdy);
+				}
+			}
+		}
+		if (mdm_status & CyDSR) {
+		}
@@ -486,32 +516,11 @@
-	if((mdm_change & CyCTS)
-	&& (info->flags & ASYNC_CTS_FLOW)){
-	    if(info->tty->stopped){
-		if(mdm_status & CyCTS){
-		    /* !!! cy_start isn't used because... */
-		    info->tty->stopped = 0;
-        	    base_addr[CyIER] |= CyTxMpty;
-		    cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
-		}
-	    }else{
-		if(!(mdm_status & CyCTS)){
-		    /* !!! cy_stop isn't used because... */
-		    info->tty->stopped = 1;
-        	    base_addr[CyIER] &= ~(CyTxMpty|CyTxRdy);
-		}
-	    }
-	}
-	if(mdm_status & CyDSR){
-	}
-    }
-    base_addr[CyMEOIR] = 0;
-    return IRQ_HANDLED;
-} /* cy_modem_interrupt */
-
-static irqreturn_t
-cd2401_tx_interrupt(int irq, void *dev_id)
-{
-    struct cyclades_port *info;
-    volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
-    int channel;
-    int char_count, saved_cnt;
-    int outch;
+	base_addr[CyMEOIR] = 0;
+	return IRQ_HANDLED;
+}				/* cy_modem_interrupt */
+
+static irqreturn_t cd2401_tx_interrupt(int irq, void *dev_id)
+{
+	struct cyclades_port *info;
+	volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
+	int channel;
+	int char_count, saved_cnt;
+	int outch;
@@ -519,2 +528,2 @@
-    /* determine the channel and change to that context */
-    channel = (u_short ) (base_addr[CyLICR] >> 2);
+	/* determine the channel and change to that context */
+	channel = (u_short) (base_addr[CyLICR] >> 2);
@@ -523,3 +532,3 @@
-    if (channel == DEBUG_PORT) {
-	panic ("TxInt on debug port!!!");
-    }
+	if (channel == DEBUG_PORT) {
+		panic("TxInt on debug port!!!");
+	}
@@ -528 +537 @@
-    info = &cy_port[channel];
+	info = &cy_port[channel];
@@ -530,15 +539,15 @@
-    /* validate the port number (as configured and open) */
-    if( (channel < 0) || (NR_PORTS <= channel) ){
-	base_addr[CyIER] &= ~(CyTxMpty|CyTxRdy);
-	base_addr[CyTEOIR] = CyNOTRANS;
-	return IRQ_HANDLED;
-    }
-    info->last_active = jiffies;
-    if(info->tty == 0){
-	base_addr[CyIER] &= ~(CyTxMpty|CyTxRdy);
-        if (info->xmit_cnt < WAKEUP_CHARS) {
-	    cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
-        }
-	base_addr[CyTEOIR] = CyNOTRANS;
-	return IRQ_HANDLED;
-    }
+	/* validate the port number (as configured and open) */
+	if ((channel < 0) || (NR_PORTS <= channel)) {
+		base_addr[CyIER] &= ~(CyTxMpty | CyTxRdy);
+		base_addr[CyTEOIR] = CyNOTRANS;
+		return IRQ_HANDLED;
+	}
+	info->last_active = jiffies;
+	if (info->tty == 0) {
+		base_addr[CyIER] &= ~(CyTxMpty | CyTxRdy);
+		if (info->xmit_cnt < WAKEUP_CHARS) {
+			cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
+		}
+		base_addr[CyTEOIR] = CyNOTRANS;
+		return IRQ_HANDLED;
+	}
@@ -546,2 +555,2 @@
-    /* load the on-chip space available for outbound data */
-    saved_cnt = char_count = base_addr[CyTFTC];
+	/* load the on-chip space available for outbound data */
+	saved_cnt = char_count = base_addr[CyTFTC];
@@ -549,64 +558,2 @@
-    if(info->x_char) { /* send special char */
-	outch = info->x_char;
-	base_addr[CyTDR] = outch;
-	char_count--;
-	info->x_char = 0;
-    }
-
-    if (info->x_break){
-	/*  The Cirrus chip requires the "Embedded Transmit
-	    Commands" of start break, delay, and end break
-	    sequences to be sent.  The duration of the
-	    break is given in TICs, which runs at HZ
-	    (typically 100) and the PPR runs at 200 Hz,
-	    so the delay is duration * 200/HZ, and thus a
-	    break can run from 1/100 sec to about 5/4 sec.
-	    Need to check these values - RGH 141095.
-	 */
-	base_addr[CyTDR] = 0; /* start break */
-	base_addr[CyTDR] = 0x81;
-	base_addr[CyTDR] = 0; /* delay a bit */
-	base_addr[CyTDR] = 0x82;
-	base_addr[CyTDR] = info->x_break*200/HZ;
-	base_addr[CyTDR] = 0; /* terminate break */
-	base_addr[CyTDR] = 0x83;
-	char_count -= 7;
-	info->x_break = 0;
-    }
-
-    while (char_count > 0){
-	if (!info->xmit_cnt){
-	    base_addr[CyIER] &= ~(CyTxMpty|CyTxRdy);
-	    break;
-	}
-	if (info->xmit_buf == 0){
-	    base_addr[CyIER] &= ~(CyTxMpty|CyTxRdy);
-	    break;
-	}
-	if (info->tty->stopped || info->tty->hw_stopped){
-	    base_addr[CyIER] &= ~(CyTxMpty|CyTxRdy);
-	    break;
-	}
-	/* Because the Embedded Transmit Commands have been
-	   enabled, we must check to see if the escape
-	   character, NULL, is being sent.  If it is, we
-	   must ensure that there is room for it to be
-	   doubled in the output stream.  Therefore we
-	   no longer advance the pointer when the character
-	   is fetched, but rather wait until after the check
-	   for a NULL output character. (This is necessary
-	   because there may not be room for the two chars
-	   needed to send a NULL.
-	 */
-	outch = info->xmit_buf[info->xmit_tail];
-	if( outch ){
-	    info->xmit_cnt--;
-	    info->xmit_tail = (info->xmit_tail + 1)
-				      & (PAGE_SIZE - 1);
-	    base_addr[CyTDR] = outch;
-	    char_count--;
-	}else{
-	    if(char_count > 1){
-		info->xmit_cnt--;
-		info->xmit_tail = (info->xmit_tail + 1)
-					  & (PAGE_SIZE - 1);
+	if (info->x_char) {	/* send special char */
+		outch = info->x_char;
@@ -614,2 +560,0 @@
-		base_addr[CyTDR] = 0;
-		char_count--;
@@ -617,3 +562,68 @@
-	    }else{
-		break;
-	    }
+		info->x_char = 0;
+	}
+
+	if (info->x_break) {
+		/*  The Cirrus chip requires the "Embedded Transmit
+		   Commands" of start break, delay, and end break
+		   sequences to be sent.  The duration of the
+		   break is given in TICs, which runs at HZ
+		   (typically 100) and the PPR runs at 200 Hz,
+		   so the delay is duration * 200/HZ, and thus a
+		   break can run from 1/100 sec to about 5/4 sec.
+		   Need to check these values - RGH 141095.
+		 */
+		base_addr[CyTDR] = 0;	/* start break */
+		base_addr[CyTDR] = 0x81;
+		base_addr[CyTDR] = 0;	/* delay a bit */
+		base_addr[CyTDR] = 0x82;
+		base_addr[CyTDR] = info->x_break * 200 / HZ;
+		base_addr[CyTDR] = 0;	/* terminate break */
+		base_addr[CyTDR] = 0x83;
+		char_count -= 7;
+		info->x_break = 0;
+	}
+
+	while (char_count > 0) {
+		if (!info->xmit_cnt) {
+			base_addr[CyIER] &= ~(CyTxMpty | CyTxRdy);
+			break;
+		}
+		if (info->xmit_buf == 0) {
+			base_addr[CyIER] &= ~(CyTxMpty | CyTxRdy);
+			break;
+		}
+		if (info->tty->stopped || info->tty->hw_stopped) {
+			base_addr[CyIER] &= ~(CyTxMpty | CyTxRdy);
+			break;
+		}
+		/* Because the Embedded Transmit Commands have been
+		   enabled, we must check to see if the escape
+		   character, NULL, is being sent.  If it is, we
+		   must ensure that there is room for it to be
+		   doubled in the output stream.  Therefore we
+		   no longer advance the pointer when the character
+		   is fetched, but rather wait until after the check
+		   for a NULL output character. (This is necessary
+		   because there may not be room for the two chars
+		   needed to send a NULL.
+		 */
+		outch = info->xmit_buf[info->xmit_tail];
+		if (outch) {
+			info->xmit_cnt--;
+			info->xmit_tail = (info->xmit_tail + 1)
+			    & (PAGE_SIZE - 1);
+			base_addr[CyTDR] = outch;
+			char_count--;
+		} else {
+			if (char_count > 1) {
+				info->xmit_cnt--;
+				info->xmit_tail = (info->xmit_tail + 1)
+				    & (PAGE_SIZE - 1);
+				base_addr[CyTDR] = outch;
+				base_addr[CyTDR] = 0;
+				char_count--;
+				char_count--;
+			} else {
+				break;
+			}
+		}
@@ -621 +630,0 @@
-    }
@@ -623,24 +632,23 @@
-    if (info->xmit_cnt < WAKEUP_CHARS) {
-	cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
-    }
-    base_addr[CyTEOIR] = (char_count != saved_cnt) ? 0 : CyNOTRANS;
-    return IRQ_HANDLED;
-} /* cy_tx_interrupt */
-
-static irqreturn_t
-cd2401_rx_interrupt(int irq, void *dev_id)
-{
-    struct tty_struct *tty;
-    struct cyclades_port *info;
-    volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
-    int channel;
-    char data;
-    int char_count;
-    int save_cnt;
-    int len;
-
-    /* determine the channel and change to that context */
-    channel = (u_short ) (base_addr[CyLICR] >> 2);
-    info = &cy_port[channel];
-    info->last_active = jiffies;
-    save_cnt = char_count = base_addr[CyRFOC];
+	if (info->xmit_cnt < WAKEUP_CHARS) {
+		cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
+	}
+	base_addr[CyTEOIR] = (char_count != saved_cnt) ? 0 : CyNOTRANS;
+	return IRQ_HANDLED;
+}				/* cy_tx_interrupt */
+
+static irqreturn_t cd2401_rx_interrupt(int irq, void *dev_id)
+{
+	struct tty_struct *tty;
+	struct cyclades_port *info;
+	volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
+	int channel;
+	char data;
+	int char_count;
+	int save_cnt;
+	int len;
+
+	/* determine the channel and change to that context */
+	channel = (u_short) (base_addr[CyLICR] >> 2);
+	info = &cy_port[channel];
+	info->last_active = jiffies;
+	save_cnt = char_count = base_addr[CyRFOC];
@@ -649,16 +657,15 @@
-    if (channel == DEBUG_PORT) {
-	while (char_count--) {
-            data = base_addr[CyRDR];
-	    queueDebugChar(data);
-	}
-    }
-    else
-#endif
-    /* if there is nowhere to put the data, discard it */
-    if(info->tty == 0){
-	while(char_count--){
-	    data = base_addr[CyRDR];
-	}
-    }else{ /* there is an open port for this data */
-	tty = info->tty;
-	/* load # characters available from the chip */
+	if (channel == DEBUG_PORT) {
+		while (char_count--) {
+			data = base_addr[CyRDR];
+			queueDebugChar(data);
+		}
+	} else
+#endif
+		/* if there is nowhere to put the data, discard it */
+	if (info->tty == 0) {
+		while (char_count--) {
+			data = base_addr[CyRDR];
+		}
+	} else {		/* there is an open port for this data */
+		tty = info->tty;
+		/* load # characters available from the chip */
@@ -667,10 +674,10 @@
-	++info->mon.int_count;
-	info->mon.char_count += char_count;
-	if (char_count > info->mon.char_max)
-	    info->mon.char_max = char_count;
-	info->mon.char_last = char_count;
-#endif
-	len = tty_buffer_request_room(tty, char_count);
-	while(len--){
-	    data = base_addr[CyRDR];
-	    tty_insert_flip_char(tty, data, TTY_NORMAL);
+		++info->mon.int_count;
+		info->mon.char_count += char_count;
+		if (char_count > info->mon.char_max)
+			info->mon.char_max = char_count;
+		info->mon.char_last = char_count;
+#endif
+		len = tty_buffer_request_room(tty, char_count);
+		while (len--) {
+			data = base_addr[CyRDR];
+			tty_insert_flip_char(tty, data, TTY_NORMAL);
@@ -678 +685 @@
-	    udelay(10L);
+			udelay(10L);
@@ -680,7 +687,7 @@
-        }
-	tty_schedule_flip(tty);
-    }
-    /* end of service */
-    base_addr[CyREOIR] = save_cnt ? 0 : CyNOTRANS;
-    return IRQ_HANDLED;
-} /* cy_rx_interrupt */
+		}
+		tty_schedule_flip(tty);
+	}
+	/* end of service */
+	base_addr[CyREOIR] = save_cnt ? 0 : CyNOTRANS;
+	return IRQ_HANDLED;
+}				/* cy_rx_interrupt */
@@ -708,2 +715 @@
-static void
-do_softint(struct work_struct *ugly_api)
+static void do_softint(struct work_struct *ugly_api)
@@ -711,6 +717,3 @@
-  struct cyclades_port *info = container_of(ugly_api, struct cyclades_port, tqueue);
-  struct tty_struct    *tty;
-
-    tty = info->tty;
-    if (!tty)
-	return;
+	struct cyclades_port *info =
+	    container_of(ugly_api, struct cyclades_port, tqueue);
+	struct tty_struct *tty;
@@ -718,12 +721,3 @@
-    if (test_and_clear_bit(Cy_EVENT_HANGUP, &info->event)) {
-	tty_hangup(info->tty);
-	wake_up_interruptible(&info->open_wait);
-	info->flags &= ~ASYNC_NORMAL_ACTIVE;
-    }
-    if (test_and_clear_bit(Cy_EVENT_OPEN_WAKEUP, &info->event)) {
-	wake_up_interruptible(&info->open_wait);
-    }
-    if (test_and_clear_bit(Cy_EVENT_WRITE_WAKEUP, &info->event)) {
-    	tty_wakeup(tty);
-    }
-} /* do_softint */
+	tty = info->tty;
+	if (!tty)
+		return;
@@ -730,0 +725,12 @@
+	if (test_and_clear_bit(Cy_EVENT_HANGUP, &info->event)) {
+		tty_hangup(info->tty);
+		wake_up_interruptible(&info->open_wait);
+		info->flags &= ~ASYNC_NORMAL_ACTIVE;
+	}
+	if (test_and_clear_bit(Cy_EVENT_OPEN_WAKEUP, &info->event)) {
+		wake_up_interruptible(&info->open_wait);
+	}
+	if (test_and_clear_bit(Cy_EVENT_WRITE_WAKEUP, &info->event)) {
+		tty_wakeup(tty);
+	}
+}				/* do_softint */
@@ -735,2 +741 @@
-static int
-startup(struct cyclades_port * info)
+static int startup(struct cyclades_port *info)
@@ -738,3 +743,3 @@
-  unsigned long flags;
-  volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
-  int channel;
+	unsigned long flags;
+	volatile unsigned char *base_addr = (unsigned char *)BASE_ADDR;
+	int channel;
@@ -742,3 +747,3 @@
-    if (info->flags & ASYNC_INITIALIZED){
-	return 0;
-    }
+	if (info->flags & ASYNC_INITIALIZED) {
+		return 0;
+	}
@@ -746,3 +751,5 @@
-    if (!info->type){
-	if (info->tty){
-	    set_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (!info->type) {
+		if (info->tty) {
+			set_bit(TTY_IO_ERROR, &info->tty->flags);
+		}
+		return 0;
@@ -750,6 +757,5 @@
-	return 0;
-    }
-    if (!info->xmit_buf){
-	info->xmit_buf = (unsigned char *) get_zeroed_page (GFP_KERNEL);
-	if (!info->xmit_buf){
-	    return -ENOMEM;
+	if (!info->xmit_buf) {
+		info->xmit_buf = (unsigned char *)get_zeroed_page(GFP_KERNEL);
+		if (!info->xmit_buf) {
+			return -ENOMEM;
+		}
@@ -757 +762,0 @@
-    }
@@ -759 +764 @@
-    config_setup(info);
+	config_setup(info);
@@ -761 +766 @@
-    channel = info->line;
+	channel = info->line;
@@ -764 +769 @@
-    printk("startup channel %d\n", channel);
+	printk("startup channel %d\n", channel);
@@ -767,3 +772,3 @@
-    local_irq_save(flags);
-	base_addr[CyCAR] = (u_char)channel;
-	write_cy_cmd(base_addr,CyENB_RCVR|CyENB_XMTR);
+	local_irq_save(flags);
+	base_addr[CyCAR] = (u_char) channel;
+	write_cy_cmd(base_addr, CyENB_RCVR | CyENB_XMTR);
@@ -771 +776 @@
-	base_addr[CyCAR] = (u_char)channel; /* !!! Is this needed? */
+	base_addr[CyCAR] = (u_char) channel;	/* !!! Is this needed? */
@@ -777,2 +782,3 @@
-        printk("cyc: %d: raising DTR\n", __LINE__);
-        printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1], base_addr[CyMSVR2]);
+	printk("cyc: %d: raising DTR\n", __LINE__);
+	printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1],
+	       base_addr[CyMSVR2]);
@@ -784,2 +790,2 @@
-	if (info->tty){
-	    clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->tty) {
+		clear_bit(TTY_IO_ERROR, &info->tty->flags);
@@ -789 +795 @@
-    local_irq_restore(flags);
+	local_irq_restore(flags);
@@ -792 +798 @@
-    printk(" done\n");
+	printk(" done\n");
@@ -794,2 +800,2 @@
-    return 0;
-} /* startup */
+	return 0;
+}				/* startup */
@@ -797,2 +803 @@
-void
-start_xmit( struct cyclades_port *info )
+void start_xmit(struct cyclades_port *info)
@@ -800,3 +805,3 @@
-  unsigned long flags;
-  volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-  int channel;
+	unsigned long flags;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	int channel;
@@ -804,2 +809,2 @@
-    channel = info->line;
-    local_irq_save(flags);
+	channel = info->line;
+	local_irq_save(flags);
@@ -808,2 +813,2 @@
-    local_irq_restore(flags);
-} /* start_xmit */
+	local_irq_restore(flags);
+}				/* start_xmit */
@@ -815,2 +820 @@
-static void
-shutdown(struct cyclades_port * info)
+static void shutdown(struct cyclades_port *info)
@@ -818,3 +822,3 @@
-  unsigned long flags;
-  volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-  int channel;
+	unsigned long flags;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	int channel;
@@ -822 +826 @@
-    if (!(info->flags & ASYNC_INITIALIZED)){
+	if (!(info->flags & ASYNC_INITIALIZED)) {
@@ -824,2 +828,2 @@
-	return;
-    }
+		return;
+	}
@@ -827 +831 @@
-    channel = info->line;
+	channel = info->line;
@@ -830 +834 @@
-    printk("shutdown channel %d\n", channel);
+	printk("shutdown channel %d\n", channel);
@@ -833,10 +837,10 @@
-    /* !!! REALLY MUST WAIT FOR LAST CHARACTER TO BE
-       SENT BEFORE DROPPING THE LINE !!!  (Perhaps
-       set some flag that is read when XMTY happens.)
-       Other choices are to delay some fixed interval
-       or schedule some later processing.
-     */
-    local_irq_save(flags);
-	if (info->xmit_buf){
-	    free_page((unsigned long) info->xmit_buf);
-	    info->xmit_buf = NULL;
+	/* !!! REALLY MUST WAIT FOR LAST CHARACTER TO BE
+	   SENT BEFORE DROPPING THE LINE !!!  (Perhaps
+	   set some flag that is read when XMTY happens.)
+	   Other choices are to delay some fixed interval
+	   or schedule some later processing.
+	 */
+	local_irq_save(flags);
+	if (info->xmit_buf) {
+		free_page((unsigned long)info->xmit_buf);
+		info->xmit_buf = NULL;
@@ -845 +849 @@
-	base_addr[CyCAR] = (u_char)channel;
+	base_addr[CyCAR] = (u_char) channel;
@@ -847 +851 @@
-	    base_addr[CyMSVR1] = 0;
+		base_addr[CyMSVR1] = 0;
@@ -849 +853 @@
-	    base_addr[CyMSVR2] = 0;
+		base_addr[CyMSVR2] = 0;
@@ -851,2 +855,3 @@
-            printk("cyc: %d: dropping DTR\n", __LINE__);
-            printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1], base_addr[CyMSVR2]);
+		printk("cyc: %d: dropping DTR\n", __LINE__);
+		printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1],
+		       base_addr[CyMSVR2]);
@@ -854,4 +859,4 @@
-        }
-	write_cy_cmd(base_addr,CyDIS_RCVR);
-         /* it may be appropriate to clear _XMIT at
-           some later date (after testing)!!! */
+	}
+	write_cy_cmd(base_addr, CyDIS_RCVR);
+	/* it may be appropriate to clear _XMIT at
+	   some later date (after testing)!!! */
@@ -859,2 +864,2 @@
-	if (info->tty){
-	    set_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->tty) {
+		set_bit(TTY_IO_ERROR, &info->tty->flags);
@@ -863 +868 @@
-    local_irq_restore(flags);
+	local_irq_restore(flags);
@@ -866 +871 @@
-    printk(" done\n");
+	printk(" done\n");
@@ -868,2 +873 @@
-    return;
-} /* shutdown */
+}				/* shutdown */
@@ -874,2 +878 @@
-static void
-config_setup(struct cyclades_port * info)
+static void config_setup(struct cyclades_port *info)
@@ -877,14 +880,6 @@
-  unsigned long flags;
-  volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-  int channel;
-  unsigned cflag;
-  int   i;
-  unsigned char ti, need_init_chan = 0;
-
-    if (!info->tty || !info->tty->termios){
-        return;
-    }
-    if (info->line == -1){
-        return;
-    }
-    cflag = info->tty->termios->c_cflag;
+	unsigned long flags;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	int channel;
+	unsigned cflag;
+	int i;
+	unsigned char ti, need_init_chan = 0;
@@ -892,2 +887,10 @@
-    /* baud rate */
-    i = cflag & CBAUD;
+	if (!info->tty || !info->tty->termios) {
+		return;
+	}
+	if (info->line == -1) {
+		return;
+	}
+	cflag = info->tty->termios->c_cflag;
+
+	/* baud rate */
+	i = cflag & CBAUD;
@@ -903,5 +906,5 @@
-    if (i & CBAUDEX) {
-	if (i == B57600)
-	    i = 16;
-	else if(i == B115200) 
-	    i = 18;
+	if (i & CBAUDEX) {
+		if (i == B57600)
+			i = 16;
+		else if (i == B115200)
+			i = 18;
@@ -909,2 +912,2 @@
-	else if(i == B78600) 
-	    i = 17;
+		else if (i == B78600)
+			i = 17;
@@ -912,3 +915,3 @@
-	else
-	    info->tty->termios->c_cflag &= ~CBAUDEX;
-    }
+		else
+			info->tty->termios->c_cflag &= ~CBAUDEX;
+	}
@@ -916,21 +919,51 @@
-    if (i == 15) {
-	    if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
-		    i += 1;
-	    if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
-		    i += 3;
-    }
-    /* Don't ever change the speed of the console port.  It will
-     * run at the speed specified in bootinfo, or at 19.2K */
-    /* Actually, it should run at whatever speed 166Bug was using */
-    /* Note info->timeout isn't used at present */
-    if (info != serial_console_info) {
-	info->tbpr = baud_bpr[i]; /* Tx BPR */
-	info->tco = baud_co[i]; /* Tx CO */
-	info->rbpr = baud_bpr[i]; /* Rx BPR */
-	info->rco = baud_co[i] >> 5; /* Rx CO */
-	if (baud_table[i] == 134) {
-            info->timeout = (info->xmit_fifo_size*HZ*30/269) + 2;
-            /* get it right for 134.5 baud */
-	} else if (baud_table[i]) {
-            info->timeout = (info->xmit_fifo_size*HZ*15/baud_table[i]) + 2;
-        /* this needs to be propagated into the card info */
+	if (i == 15) {
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+			i += 1;
+		if ((info->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+			i += 3;
+	}
+	/* Don't ever change the speed of the console port.  It will
+	 * run at the speed specified in bootinfo, or at 19.2K */
+	/* Actually, it should run at whatever speed 166Bug was using */
+	/* Note info->timeout isn't used at present */
+	if (info != serial_console_info) {
+		info->tbpr = baud_bpr[i];	/* Tx BPR */
+		info->tco = baud_co[i];	/* Tx CO */
+		info->rbpr = baud_bpr[i];	/* Rx BPR */
+		info->rco = baud_co[i] >> 5;	/* Rx CO */
+		if (baud_table[i] == 134) {
+			info->timeout =
+			    (info->xmit_fifo_size * HZ * 30 / 269) + 2;
+			/* get it right for 134.5 baud */
+		} else if (baud_table[i]) {
+			info->timeout =
+			    (info->xmit_fifo_size * HZ * 15 / baud_table[i]) +
+			    2;
+			/* this needs to be propagated into the card info */
+		} else {
+			info->timeout = 0;
+		}
+	}
+	/* By tradition (is it a standard?) a baud rate of zero
+	   implies the line should be/has been closed.  A bit
+	   later in this routine such a test is performed. */
+
+	/* byte size and parity */
+	info->cor7 = 0;
+	info->cor6 = 0;
+	info->cor5 = 0;
+	info->cor4 = (info->default_threshold ? info->default_threshold : baud_cor4[i]);	/* receive threshold */
+	/* Following two lines added 101295, RGH. */
+	/* It is obviously wrong to access CyCORx, and not info->corx here,
+	 * try and remember to fix it later! */
+	channel = info->line;
+	base_addr[CyCAR] = (u_char) channel;
+	if (C_CLOCAL(info->tty)) {
+		if (base_addr[CyIER] & CyMdmCh)
+			base_addr[CyIER] &= ~CyMdmCh;	/* without modem intr */
+		/* ignore 1->0 modem transitions */
+		if (base_addr[CyCOR4] & (CyDSR | CyCTS | CyDCD))
+			base_addr[CyCOR4] &= ~(CyDSR | CyCTS | CyDCD);
+		/* ignore 0->1 modem transitions */
+		if (base_addr[CyCOR5] & (CyDSR | CyCTS | CyDCD))
+			base_addr[CyCOR5] &= ~(CyDSR | CyCTS | CyDCD);
@@ -938 +971,35 @@
-            info->timeout = 0;
+		if ((base_addr[CyIER] & CyMdmCh) != CyMdmCh)
+			base_addr[CyIER] |= CyMdmCh;	/* with modem intr */
+		/* act on 1->0 modem transitions */
+		if ((base_addr[CyCOR4] & (CyDSR | CyCTS | CyDCD)) !=
+		    (CyDSR | CyCTS | CyDCD))
+			base_addr[CyCOR4] |= CyDSR | CyCTS | CyDCD;
+		/* act on 0->1 modem transitions */
+		if ((base_addr[CyCOR5] & (CyDSR | CyCTS | CyDCD)) !=
+		    (CyDSR | CyCTS | CyDCD))
+			base_addr[CyCOR5] |= CyDSR | CyCTS | CyDCD;
+	}
+	info->cor3 = (cflag & CSTOPB) ? Cy_2_STOP : Cy_1_STOP;
+	info->cor2 = CyETC;
+	switch (cflag & CSIZE) {
+	case CS5:
+		info->cor1 = Cy_5_BITS;
+		break;
+	case CS6:
+		info->cor1 = Cy_6_BITS;
+		break;
+	case CS7:
+		info->cor1 = Cy_7_BITS;
+		break;
+	case CS8:
+		info->cor1 = Cy_8_BITS;
+		break;
+	}
+	if (cflag & PARENB) {
+		if (cflag & PARODD) {
+			info->cor1 |= CyPARITY_O;
+		} else {
+			info->cor1 |= CyPARITY_E;
+		}
+	} else {
+		info->cor1 |= CyPARITY_NONE;
@@ -940,63 +1007,2 @@
-    }
-    /* By tradition (is it a standard?) a baud rate of zero
-       implies the line should be/has been closed.  A bit
-       later in this routine such a test is performed. */
-
-    /* byte size and parity */
-    info->cor7 = 0;
-    info->cor6 = 0;
-    info->cor5 = 0;
-    info->cor4 = (info->default_threshold
-		  ? info->default_threshold
-		  : baud_cor4[i]); /* receive threshold */
-    /* Following two lines added 101295, RGH. */
-    /* It is obviously wrong to access CyCORx, and not info->corx here,
-     * try and remember to fix it later! */
-    channel = info->line;
-    base_addr[CyCAR] = (u_char)channel;
-    if (C_CLOCAL(info->tty)) {
-	if (base_addr[CyIER] & CyMdmCh)
-	    base_addr[CyIER] &= ~CyMdmCh; /* without modem intr */
-			       /* ignore 1->0 modem transitions */
-	if (base_addr[CyCOR4] & (CyDSR|CyCTS|CyDCD))
-	    base_addr[CyCOR4] &= ~(CyDSR|CyCTS|CyDCD);
-			       /* ignore 0->1 modem transitions */
-	if (base_addr[CyCOR5] & (CyDSR|CyCTS|CyDCD))
-	    base_addr[CyCOR5] &= ~(CyDSR|CyCTS|CyDCD);
-    } else {
-	if ((base_addr[CyIER] & CyMdmCh) != CyMdmCh)
-	    base_addr[CyIER] |= CyMdmCh; /* with modem intr */
-			       /* act on 1->0 modem transitions */
-	if ((base_addr[CyCOR4] & (CyDSR|CyCTS|CyDCD)) != (CyDSR|CyCTS|CyDCD))
-	    base_addr[CyCOR4] |= CyDSR|CyCTS|CyDCD;
-			       /* act on 0->1 modem transitions */
-	if ((base_addr[CyCOR5] & (CyDSR|CyCTS|CyDCD)) != (CyDSR|CyCTS|CyDCD))
-	    base_addr[CyCOR5] |= CyDSR|CyCTS|CyDCD;
-    }
-    info->cor3 = (cflag & CSTOPB) ? Cy_2_STOP : Cy_1_STOP;
-    info->cor2 = CyETC;
-    switch(cflag & CSIZE){
-    case CS5:
-        info->cor1 = Cy_5_BITS;
-        break;
-    case CS6:
-        info->cor1 = Cy_6_BITS;
-        break;
-    case CS7:
-        info->cor1 = Cy_7_BITS;
-        break;
-    case CS8:
-        info->cor1 = Cy_8_BITS;
-        break;
-    }
-    if (cflag & PARENB){
-        if (cflag & PARODD){
-            info->cor1 |= CyPARITY_O;
-        }else{
-            info->cor1 |= CyPARITY_E;
-        }
-    }else{
-        info->cor1 |= CyPARITY_NONE;
-    }
-	
-    /* CTS flow control flag */
+
+	/* CTS flow control flag */
@@ -1004,13 +1010,13 @@
-    /* Don't complcate matters for now! RGH 141095 */
-    if (cflag & CRTSCTS){
-	info->flags |= ASYNC_CTS_FLOW;
-	info->cor2 |= CyCtsAE;
-    }else{
-	info->flags &= ~ASYNC_CTS_FLOW;
-	info->cor2 &= ~CyCtsAE;
-    }
-#endif
-    if (cflag & CLOCAL)
-	info->flags &= ~ASYNC_CHECK_CD;
-    else
-	info->flags |= ASYNC_CHECK_CD;
+	/* Don't complcate matters for now! RGH 141095 */
+	if (cflag & CRTSCTS) {
+		info->flags |= ASYNC_CTS_FLOW;
+		info->cor2 |= CyCtsAE;
+	} else {
+		info->flags &= ~ASYNC_CTS_FLOW;
+		info->cor2 &= ~CyCtsAE;
+	}
+#endif
+	if (cflag & CLOCAL)
+		info->flags &= ~ASYNC_CHECK_CD;
+	else
+		info->flags |= ASYNC_CHECK_CD;
@@ -1028 +1034 @@
-    channel = info->line;
+	channel = info->line;
@@ -1030,2 +1036,2 @@
-    local_irq_save(flags);
-	base_addr[CyCAR] = (u_char)channel;
+	local_irq_save(flags);
+	base_addr[CyCAR] = (u_char) channel;
@@ -1035 +1041 @@
-	    base_addr[CyLICR] = channel << 2;
+		base_addr[CyLICR] = channel << 2;
@@ -1037 +1043 @@
-	    base_addr[CyLIVR] = 0x5c;
+		base_addr[CyLIVR] = 0x5c;
@@ -1039 +1045 @@
-       /* tx and rx baud rate */
+	/* tx and rx baud rate */
@@ -1042 +1048 @@
-	    need_init_chan = 1;
+		need_init_chan = 1;
@@ -1044 +1050 @@
-	    base_addr[CyTCOR] = info->tco;
+		base_addr[CyTCOR] = info->tco;
@@ -1046 +1052 @@
-	    base_addr[CyTBPR] = info->tbpr;
+		base_addr[CyTBPR] = info->tbpr;
@@ -1048 +1054 @@
-	    base_addr[CyRCOR] = info->rco;
+		base_addr[CyRCOR] = info->rco;
@@ -1050 +1056 @@
-	    base_addr[CyRBPR] = info->rbpr;
+		base_addr[CyRBPR] = info->rbpr;
@@ -1055 +1061 @@
-	    base_addr[CySCHR1] = START_CHAR(info->tty);
+		base_addr[CySCHR1] = START_CHAR(info->tty);
@@ -1057 +1063 @@
-	    base_addr[CySCHR2] = STOP_CHAR(info->tty);
+		base_addr[CySCHR2] = STOP_CHAR(info->tty);
@@ -1059 +1065 @@
-	    base_addr[CySCRL] = START_CHAR(info->tty);
+		base_addr[CySCRL] = START_CHAR(info->tty);
@@ -1061 +1067 @@
-	    base_addr[CySCRH] = START_CHAR(info->tty);
+		base_addr[CySCRH] = START_CHAR(info->tty);
@@ -1063 +1069 @@
-	    base_addr[CyCOR1] = info->cor1;
+		base_addr[CyCOR1] = info->cor1;
@@ -1065 +1071 @@
-	    base_addr[CyCOR2] = info->cor2;
+		base_addr[CyCOR2] = info->cor2;
@@ -1067 +1073 @@
-	    base_addr[CyCOR3] = info->cor3;
+		base_addr[CyCOR3] = info->cor3;
@@ -1069 +1075 @@
-	    base_addr[CyCOR4] = info->cor4;
+		base_addr[CyCOR4] = info->cor4;
@@ -1071 +1077 @@
-	    base_addr[CyCOR5] = info->cor5;
+		base_addr[CyCOR5] = info->cor5;
@@ -1073 +1079 @@
-	    base_addr[CyCOR6] = info->cor6;
+		base_addr[CyCOR6] = info->cor6;
@@ -1075 +1081 @@
-	    base_addr[CyCOR7] = info->cor7;
+		base_addr[CyCOR7] = info->cor7;
@@ -1078 +1084 @@
-	    write_cy_cmd(base_addr,CyINIT_CHAN);
+		write_cy_cmd(base_addr, CyINIT_CHAN);
@@ -1080 +1086 @@
-	base_addr[CyCAR] = (u_char)channel; /* !!! Is this needed? */
+	base_addr[CyCAR] = (u_char) channel;	/* !!! Is this needed? */
@@ -1085 +1091 @@
-	    base_addr[CyRTPRL] = ti;
+		base_addr[CyRTPRL] = ti;
@@ -1087 +1093 @@
-	    base_addr[CyRTPRH] = 0;
+		base_addr[CyRTPRH] = 0;
@@ -1090,3 +1096,3 @@
-	if(i == 0){ /* baud rate is zero, turn off line */
-	    if ((base_addr[CyMSVR2] & CyDTR) == CyDTR)
-	        base_addr[CyMSVR2] = 0;
+	if (i == 0) {		/* baud rate is zero, turn off line */
+		if ((base_addr[CyMSVR2] & CyDTR) == CyDTR)
+			base_addr[CyMSVR2] = 0;
@@ -1094,2 +1100,3 @@
-            printk("cyc: %d: dropping DTR\n", __LINE__);
-            printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1], base_addr[CyMSVR2]);
+		printk("cyc: %d: dropping DTR\n", __LINE__);
+		printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1],
+		       base_addr[CyMSVR2]);
@@ -1097,3 +1104,3 @@
-	}else{
-	    if ((base_addr[CyMSVR2] & CyDTR) != CyDTR)
-	        base_addr[CyMSVR2] = CyDTR;
+	} else {
+		if ((base_addr[CyMSVR2] & CyDTR) != CyDTR)
+			base_addr[CyMSVR2] = CyDTR;
@@ -1101,2 +1108,3 @@
-            printk("cyc: %d: raising DTR\n", __LINE__);
-            printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1], base_addr[CyMSVR2]);
+		printk("cyc: %d: raising DTR\n", __LINE__);
+		printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1],
+		       base_addr[CyMSVR2]);
@@ -1106,2 +1114,2 @@
-	if (info->tty){
-	    clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->tty) {
+		clear_bit(TTY_IO_ERROR, &info->tty->flags);
@@ -1110,3 +1118 @@
-    local_irq_restore(flags);
-
-} /* config_setup */
+	local_irq_restore(flags);
@@ -1113,0 +1120 @@
+}				/* config_setup */
@@ -1115,2 +1122 @@
-static void
-cy_put_char(struct tty_struct *tty, unsigned char ch)
+static void cy_put_char(struct tty_struct *tty, unsigned char ch)
@@ -1118,2 +1124,2 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  unsigned long flags;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	unsigned long flags;
@@ -1122 +1128 @@
-    printk("cy_put_char %s(0x%02x)\n", tty->name, ch);
+	printk("cy_put_char %s(0x%02x)\n", tty->name, ch);
@@ -1125,2 +1131,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_put_char"))
-	return;
+	if (serial_paranoia_check(info, tty->name, "cy_put_char"))
+		return;
@@ -1128,2 +1134,2 @@
-    if (!info->xmit_buf)
-	return;
+	if (!info->xmit_buf)
+		return;
@@ -1131 +1137 @@
-    local_irq_save(flags);
+	local_irq_save(flags);
@@ -1133,2 +1139,2 @@
-	    local_irq_restore(flags);
-	    return;
+		local_irq_restore(flags);
+		return;
@@ -1140,3 +1146,2 @@
-    local_irq_restore(flags);
-} /* cy_put_char */
-
+	local_irq_restore(flags);
+}				/* cy_put_char */
@@ -1144,2 +1149 @@
-static void
-cy_flush_chars(struct tty_struct *tty)
+static void cy_flush_chars(struct tty_struct *tty)
@@ -1147,5 +1151,5 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  unsigned long flags;
-  volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-  int channel;
-				
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	unsigned long flags;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	int channel;
+
@@ -1153 +1157 @@
-    printk("cy_flush_chars %s\n", tty->name); /* */
+	printk("cy_flush_chars %s\n", tty->name);	/* */
@@ -1156,2 +1160,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_flush_chars"))
-	return;
+	if (serial_paranoia_check(info, tty->name, "cy_flush_chars"))
+		return;
@@ -1159,3 +1163,3 @@
-    if (info->xmit_cnt <= 0 || tty->stopped
-    || tty->hw_stopped || !info->xmit_buf)
-	return;
+	if (info->xmit_cnt <= 0 || tty->stopped
+	    || tty->hw_stopped || !info->xmit_buf)
+		return;
@@ -1163 +1167 @@
-    channel = info->line;
+	channel = info->line;
@@ -1165 +1169 @@
-    local_irq_save(flags);
+	local_irq_save(flags);
@@ -1168,3 +1172,2 @@
-    local_irq_restore(flags);
-} /* cy_flush_chars */
-
+	local_irq_restore(flags);
+}				/* cy_flush_chars */
@@ -1178,3 +1181 @@
-static int
-cy_write(struct tty_struct * tty,
-           const unsigned char *buf, int count)
+static int cy_write(struct tty_struct *tty, const unsigned char *buf, int count)
@@ -1182,3 +1183,3 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  unsigned long flags;
-  int c, total = 0;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	unsigned long flags;
+	int c, total = 0;
@@ -1187 +1188 @@
-    printk("cy_write %s\n", tty->name); /* */
+	printk("cy_write %s\n", tty->name);	/* */
@@ -1190,34 +1191,16 @@
-    if (serial_paranoia_check(info, tty->name, "cy_write")){
-	return 0;
-    }
-	
-    if (!info->xmit_buf){
-        return 0;
-    }
-
-    while (1) {
-	    local_irq_save(flags);
-	    c = min_t(int, count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
-				      SERIAL_XMIT_SIZE - info->xmit_head));
-	    if (c <= 0) {
-		    local_irq_restore(flags);
-		    break;
-	    }
-
-	    memcpy(info->xmit_buf + info->xmit_head, buf, c);
-	    info->xmit_head = (info->xmit_head + c) & (SERIAL_XMIT_SIZE-1);
-	    info->xmit_cnt += c;
-	    local_irq_restore(flags);
-
-	    buf += c;
-	    count -= c;
-	    total += c;
-    }
-
-    if (info->xmit_cnt
-    && !tty->stopped
-    && !tty->hw_stopped ) {
-        start_xmit(info);
-    }
-    return total;
-} /* cy_write */
+	if (serial_paranoia_check(info, tty->name, "cy_write")) {
+		return 0;
+	}
+
+	if (!info->xmit_buf) {
+		return 0;
+	}
+
+	while (1) {
+		local_irq_save(flags);
+		c = min_t(int, count, min(SERIAL_XMIT_SIZE - info->xmit_cnt - 1,
+					  SERIAL_XMIT_SIZE - info->xmit_head));
+		if (c <= 0) {
+			local_irq_restore(flags);
+			break;
+		}
@@ -1224,0 +1208,5 @@
+		memcpy(info->xmit_buf + info->xmit_head, buf, c);
+		info->xmit_head =
+		    (info->xmit_head + c) & (SERIAL_XMIT_SIZE - 1);
+		info->xmit_cnt += c;
+		local_irq_restore(flags);
@@ -1226,2 +1214,12 @@
-static int
-cy_write_room(struct tty_struct *tty)
+		buf += c;
+		count -= c;
+		total += c;
+	}
+
+	if (info->xmit_cnt && !tty->stopped && !tty->hw_stopped) {
+		start_xmit(info);
+	}
+	return total;
+}				/* cy_write */
+
+static int cy_write_room(struct tty_struct *tty)
@@ -1229,3 +1227,3 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  int	ret;
-				
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	int ret;
+
@@ -1233 +1231 @@
-    printk("cy_write_room %s\n", tty->name); /* */
+	printk("cy_write_room %s\n", tty->name);	/* */
@@ -1236,8 +1234,7 @@
-    if (serial_paranoia_check(info, tty->name, "cy_write_room"))
-	return 0;
-    ret = PAGE_SIZE - info->xmit_cnt - 1;
-    if (ret < 0)
-	ret = 0;
-    return ret;
-} /* cy_write_room */
-
+	if (serial_paranoia_check(info, tty->name, "cy_write_room"))
+		return 0;
+	ret = PAGE_SIZE - info->xmit_cnt - 1;
+	if (ret < 0)
+		ret = 0;
+	return ret;
+}				/* cy_write_room */
@@ -1245,2 +1242 @@
-static int
-cy_chars_in_buffer(struct tty_struct *tty)
+static int cy_chars_in_buffer(struct tty_struct *tty)
@@ -1248,2 +1244,2 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-				
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+
@@ -1251 +1247 @@
-    printk("cy_chars_in_buffer %s %d\n", tty->name, info->xmit_cnt); /* */
+	printk("cy_chars_in_buffer %s %d\n", tty->name, info->xmit_cnt);	/* */
@@ -1254,5 +1250,2 @@
-    if (serial_paranoia_check(info, tty->name, "cy_chars_in_buffer"))
-	return 0;
-
-    return info->xmit_cnt;
-} /* cy_chars_in_buffer */
+	if (serial_paranoia_check(info, tty->name, "cy_chars_in_buffer"))
+		return 0;
@@ -1259,0 +1253,2 @@
+	return info->xmit_cnt;
+}				/* cy_chars_in_buffer */
@@ -1261,2 +1256 @@
-static void
-cy_flush_buffer(struct tty_struct *tty)
+static void cy_flush_buffer(struct tty_struct *tty)
@@ -1264,3 +1258,3 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  unsigned long flags;
-				
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	unsigned long flags;
+
@@ -1268 +1262 @@
-    printk("cy_flush_buffer %s\n", tty->name); /* */
+	printk("cy_flush_buffer %s\n", tty->name);	/* */
@@ -1271,3 +1265,3 @@
-    if (serial_paranoia_check(info, tty->name, "cy_flush_buffer"))
-	return;
-    local_irq_save(flags);
+	if (serial_paranoia_check(info, tty->name, "cy_flush_buffer"))
+		return;
+	local_irq_save(flags);
@@ -1275,4 +1269,3 @@
-    local_irq_restore(flags);
-    tty_wakeup(tty);
-} /* cy_flush_buffer */
-
+	local_irq_restore(flags);
+	tty_wakeup(tty);
+}				/* cy_flush_buffer */
@@ -1284,2 +1277 @@
-static void
-cy_throttle(struct tty_struct * tty)
+static void cy_throttle(struct tty_struct *tty)
@@ -1287,4 +1279,4 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  unsigned long flags;
-  volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-  int channel;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	unsigned long flags;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	int channel;
@@ -1293,15 +1285 @@
-  char buf[64];
-	
-    printk("throttle %s: %d....\n", tty_name(tty, buf),
-	   tty->ldisc.chars_in_buffer(tty));
-    printk("cy_throttle %s\n", tty->name);
-#endif
-
-    if (serial_paranoia_check(info, tty->name, "cy_nthrottle")){
-	    return;
-    }
-
-    if (I_IXOFF(tty)) {
-	info->x_char = STOP_CHAR(tty);
-	    /* Should use the "Send Special Character" feature!!! */
-    }
+	char buf[64];
@@ -1309 +1287,4 @@
-    channel = info->line;
+	printk("throttle %s: %d....\n", tty_name(tty, buf),
+	       tty->ldisc.chars_in_buffer(tty));
+	printk("cy_throttle %s\n", tty->name);
+#endif
@@ -1311,4 +1292,8 @@
-    local_irq_save(flags);
-	base_addr[CyCAR] = (u_char)channel;
-	base_addr[CyMSVR1] = 0;
-    local_irq_restore(flags);
+	if (serial_paranoia_check(info, tty->name, "cy_nthrottle")) {
+		return;
+	}
+
+	if (I_IXOFF(tty)) {
+		info->x_char = STOP_CHAR(tty);
+		/* Should use the "Send Special Character" feature!!! */
+	}
@@ -1316,2 +1301 @@
-    return;
-} /* cy_throttle */
+	channel = info->line;
@@ -1318,0 +1303,5 @@
+	local_irq_save(flags);
+	base_addr[CyCAR] = (u_char) channel;
+	base_addr[CyMSVR1] = 0;
+	local_irq_restore(flags);
+}				/* cy_throttle */
@@ -1320,2 +1309 @@
-static void
-cy_unthrottle(struct tty_struct * tty)
+static void cy_unthrottle(struct tty_struct *tty)
@@ -1323,4 +1311,4 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
-  unsigned long flags;
-  volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-  int channel;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	unsigned long flags;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	int channel;
@@ -1329,15 +1317 @@
-  char buf[64];
-	
-    printk("throttle %s: %d....\n", tty_name(tty, buf),
-	   tty->ldisc.chars_in_buffer(tty));
-    printk("cy_unthrottle %s\n", tty->name);
-#endif
-
-    if (serial_paranoia_check(info, tty->name, "cy_nthrottle")){
-	    return;
-    }
-
-    if (I_IXOFF(tty)) {
-	info->x_char = START_CHAR(tty);
-	/* Should use the "Send Special Character" feature!!! */
-    }
+	char buf[64];
@@ -1345 +1319,4 @@
-    channel = info->line;
+	printk("throttle %s: %d....\n", tty_name(tty, buf),
+	       tty->ldisc.chars_in_buffer(tty));
+	printk("cy_unthrottle %s\n", tty->name);
+#endif
@@ -1347,4 +1324,3 @@
-    local_irq_save(flags);
-	base_addr[CyCAR] = (u_char)channel;
-	base_addr[CyMSVR1] = CyRTS;
-    local_irq_restore(flags);
+	if (serial_paranoia_check(info, tty->name, "cy_nthrottle")) {
+		return;
+	}
@@ -1352,2 +1328,12 @@
-    return;
-} /* cy_unthrottle */
+	if (I_IXOFF(tty)) {
+		info->x_char = START_CHAR(tty);
+		/* Should use the "Send Special Character" feature!!! */
+	}
+
+	channel = info->line;
+
+	local_irq_save(flags);
+	base_addr[CyCAR] = (u_char) channel;
+	base_addr[CyMSVR1] = CyRTS;
+	local_irq_restore(flags);
+}				/* cy_unthrottle */
@@ -1356,2 +1342,2 @@
-get_serial_info(struct cyclades_port * info,
-                           struct serial_struct __user * retinfo)
+get_serial_info(struct cyclades_port *info,
+		struct serial_struct __user * retinfo)
@@ -1359 +1345 @@
-  struct serial_struct tmp;
+	struct serial_struct tmp;
@@ -1362,14 +1348,14 @@
-    if (!retinfo)
-            return -EFAULT;
-    memset(&tmp, 0, sizeof(tmp));
-    tmp.type = info->type;
-    tmp.line = info->line;
-    tmp.port = info->line;
-    tmp.irq = 0;
-    tmp.flags = info->flags;
-    tmp.baud_base = 0;          /*!!!*/
-    tmp.close_delay = info->close_delay;
-    tmp.custom_divisor = 0;     /*!!!*/
-    tmp.hub6 = 0;               /*!!!*/
-    return copy_to_user(retinfo,&tmp,sizeof(*retinfo)) ? -EFAULT : 0;
-} /* get_serial_info */
+	if (!retinfo)
+		return -EFAULT;
+	memset(&tmp, 0, sizeof(tmp));
+	tmp.type = info->type;
+	tmp.line = info->line;
+	tmp.port = info->line;
+	tmp.irq = 0;
+	tmp.flags = info->flags;
+	tmp.baud_base = 0;	/*!!! */
+	tmp.close_delay = info->close_delay;
+	tmp.custom_divisor = 0;	/*!!! */
+	tmp.hub6 = 0;		/*!!! */
+	return copy_to_user(retinfo, &tmp, sizeof(*retinfo)) ? -EFAULT : 0;
+}				/* get_serial_info */
@@ -1378,2 +1364,2 @@
-set_serial_info(struct cyclades_port * info,
-                           struct serial_struct __user * new_info)
+set_serial_info(struct cyclades_port *info,
+		struct serial_struct __user * new_info)
@@ -1381,2 +1367,2 @@
-  struct serial_struct new_serial;
-  struct cyclades_port old_info;
+	struct serial_struct new_serial;
+	struct cyclades_port old_info;
@@ -1385,25 +1371,15 @@
-    if (!new_info)
-	    return -EFAULT;
-    if (copy_from_user(&new_serial,new_info,sizeof(new_serial)))
-	    return -EFAULT;
-    old_info = *info;
-
-    if (!capable(CAP_SYS_ADMIN)) {
-	    if ((new_serial.close_delay != info->close_delay) ||
-		((new_serial.flags & ASYNC_FLAGS & ~ASYNC_USR_MASK) !=
-		 (info->flags & ASYNC_FLAGS & ~ASYNC_USR_MASK)))
-		    return -EPERM;
-	    info->flags = ((info->flags & ~ASYNC_USR_MASK) |
-			   (new_serial.flags & ASYNC_USR_MASK));
-	    goto check_and_exit;
-    }
-
-
-    /*
-     * OK, past this point, all the error checking has been done.
-     * At this point, we start making changes.....
-     */
-
-    info->flags = ((info->flags & ~ASYNC_FLAGS) |
-		    (new_serial.flags & ASYNC_FLAGS));
-    info->close_delay = new_serial.close_delay;
+	if (!new_info)
+		return -EFAULT;
+	if (copy_from_user(&new_serial, new_info, sizeof(new_serial)))
+		return -EFAULT;
+	old_info = *info;
+
+	if (!capable(CAP_SYS_ADMIN)) {
+		if ((new_serial.close_delay != info->close_delay) ||
+		    ((new_serial.flags & ASYNC_FLAGS & ~ASYNC_USR_MASK) !=
+		     (info->flags & ASYNC_FLAGS & ~ASYNC_USR_MASK)))
+			return -EPERM;
+		info->flags = ((info->flags & ~ASYNC_USR_MASK) |
+			       (new_serial.flags & ASYNC_USR_MASK));
+		goto check_and_exit;
+	}
@@ -1410,0 +1387,8 @@
+	/*
+	 * OK, past this point, all the error checking has been done.
+	 * At this point, we start making changes.....
+	 */
+
+	info->flags = ((info->flags & ~ASYNC_FLAGS) |
+		       (new_serial.flags & ASYNC_FLAGS));
+	info->close_delay = new_serial.close_delay;
@@ -1413,7 +1397,14 @@
-    if (info->flags & ASYNC_INITIALIZED){
-	config_setup(info);
-	return 0;
-    }else{
-        return startup(info);
-    }
-} /* set_serial_info */
+	if (info->flags & ASYNC_INITIALIZED) {
+		config_setup(info);
+		return 0;
+	}
+	return startup(info);
+}				/* set_serial_info */
+
+static int cy_tiocmget(struct tty_struct *tty, struct file *file)
+{
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	int channel;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	unsigned long flags;
+	unsigned char status;
@@ -1421,22 +1412,13 @@
-static int
-cy_tiocmget(struct tty_struct *tty, struct file *file)
-{
-  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
-  int channel;
-  volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-  unsigned long flags;
-  unsigned char status;
-
-    channel = info->line;
-
-    local_irq_save(flags);
-        base_addr[CyCAR] = (u_char)channel;
-        status = base_addr[CyMSVR1] | base_addr[CyMSVR2];
-    local_irq_restore(flags);
-
-    return    ((status  & CyRTS) ? TIOCM_RTS : 0)
-            | ((status  & CyDTR) ? TIOCM_DTR : 0)
-            | ((status  & CyDCD) ? TIOCM_CAR : 0)
-            | ((status  & CyDSR) ? TIOCM_DSR : 0)
-            | ((status  & CyCTS) ? TIOCM_CTS : 0);
-} /* cy_tiocmget */
+	channel = info->line;
+
+	local_irq_save(flags);
+	base_addr[CyCAR] = (u_char) channel;
+	status = base_addr[CyMSVR1] | base_addr[CyMSVR2];
+	local_irq_restore(flags);
+
+	return ((status & CyRTS) ? TIOCM_RTS : 0)
+	    | ((status & CyDTR) ? TIOCM_DTR : 0)
+	    | ((status & CyDCD) ? TIOCM_CAR : 0)
+	    | ((status & CyDSR) ? TIOCM_DSR : 0)
+	    | ((status & CyCTS) ? TIOCM_CTS : 0);
+}				/* cy_tiocmget */
@@ -1448,10 +1430,10 @@
-  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
-  int channel;
-  volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-  unsigned long flags;
-	  
-    channel = info->line;
-
-	if (set & TIOCM_RTS){
-	    local_irq_save(flags);
-		base_addr[CyCAR] = (u_char)channel;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	int channel;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	unsigned long flags;
+
+	channel = info->line;
+
+	if (set & TIOCM_RTS) {
+		local_irq_save(flags);
+		base_addr[CyCAR] = (u_char) channel;
@@ -1459 +1441 @@
-	    local_irq_restore(flags);
+		local_irq_restore(flags);
@@ -1461,3 +1443,3 @@
-	if (set & TIOCM_DTR){
-	    local_irq_save(flags);
-	    base_addr[CyCAR] = (u_char)channel;
+	if (set & TIOCM_DTR) {
+		local_irq_save(flags);
+		base_addr[CyCAR] = (u_char) channel;
@@ -1465 +1447 @@
-	    base_addr[CyMSVR2] = CyDTR;
+		base_addr[CyMSVR2] = CyDTR;
@@ -1467,2 +1449,3 @@
-            printk("cyc: %d: raising DTR\n", __LINE__);
-            printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1], base_addr[CyMSVR2]);
+		printk("cyc: %d: raising DTR\n", __LINE__);
+		printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1],
+		       base_addr[CyMSVR2]);
@@ -1470 +1453 @@
-	    local_irq_restore(flags);
+		local_irq_restore(flags);
@@ -1473,3 +1456,3 @@
-	if (clear & TIOCM_RTS){
-	    local_irq_save(flags);
-		base_addr[CyCAR] = (u_char)channel;
+	if (clear & TIOCM_RTS) {
+		local_irq_save(flags);
+		base_addr[CyCAR] = (u_char) channel;
@@ -1477 +1460 @@
-	    local_irq_restore(flags);
+		local_irq_restore(flags);
@@ -1479,3 +1462,3 @@
-	if (clear & TIOCM_DTR){
-	    local_irq_save(flags);
-	    base_addr[CyCAR] = (u_char)channel;
+	if (clear & TIOCM_DTR) {
+		local_irq_save(flags);
+		base_addr[CyCAR] = (u_char) channel;
@@ -1483 +1466 @@
-	    base_addr[CyMSVR2] = 0;
+		base_addr[CyMSVR2] = 0;
@@ -1485,2 +1468,3 @@
-            printk("cyc: %d: dropping DTR\n", __LINE__);
-            printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1], base_addr[CyMSVR2]);
+		printk("cyc: %d: dropping DTR\n", __LINE__);
+		printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1],
+		       base_addr[CyMSVR2]);
@@ -1488 +1472 @@
-	    local_irq_restore(flags);
+		local_irq_restore(flags);
@@ -1491,2 +1475,2 @@
-    return 0;
-} /* set_modem_info */
+	return 0;
+}				/* set_modem_info */
@@ -1494,10 +1478,9 @@
-static void
-send_break( struct cyclades_port * info, int duration)
-{ /* Let the transmit ISR take care of this (since it
-     requires stuffing characters into the output stream).
-   */
-    info->x_break = duration;
-    if (!info->xmit_cnt ) {
-	start_xmit(info);
-    }
-} /* send_break */
+static void send_break(struct cyclades_port *info, int duration)
+{				/* Let the transmit ISR take care of this (since it
+				   requires stuffing characters into the output stream).
+				 */
+	info->x_break = duration;
+	if (!info->xmit_cnt) {
+		start_xmit(info);
+	}
+}				/* send_break */
@@ -1506 +1489 @@
-get_mon_info(struct cyclades_port * info, struct cyclades_monitor __user * mon)
+get_mon_info(struct cyclades_port *info, struct cyclades_monitor __user * mon)
@@ -1509,7 +1492,7 @@
-   if (copy_to_user(mon, &info->mon, sizeof(struct cyclades_monitor)))
-	   return -EFAULT;
-   info->mon.int_count  = 0;
-   info->mon.char_count = 0;
-   info->mon.char_max   = 0;
-   info->mon.char_last  = 0;
-   return 0;
+	if (copy_to_user(mon, &info->mon, sizeof(struct cyclades_monitor)))
+		return -EFAULT;
+	info->mon.int_count = 0;
+	info->mon.char_count = 0;
+	info->mon.char_max = 0;
+	info->mon.char_last = 0;
+	return 0;
@@ -1518,2 +1501 @@
-static int
-set_threshold(struct cyclades_port * info, unsigned long __user *arg)
+static int set_threshold(struct cyclades_port *info, unsigned long __user * arg)
@@ -1521,12 +1503,12 @@
-   volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-   unsigned long value;
-   int channel;
-   
-   if (get_user(value, arg))
-	   return -EFAULT;
-
-   channel = info->line;
-   info->cor4 &= ~CyREC_FIFO;
-   info->cor4 |= value & CyREC_FIFO;
-   base_addr[CyCOR4] = info->cor4;
-   return 0;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	unsigned long value;
+	int channel;
+
+	if (get_user(value, arg))
+		return -EFAULT;
+
+	channel = info->line;
+	info->cor4 &= ~CyREC_FIFO;
+	info->cor4 |= value & CyREC_FIFO;
+	base_addr[CyCOR4] = info->cor4;
+	return 0;
@@ -1536 +1518 @@
-get_threshold(struct cyclades_port * info, unsigned long __user *value)
+get_threshold(struct cyclades_port *info, unsigned long __user * value)
@@ -1538,5 +1520,5 @@
-   volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-   int channel;
-   unsigned long tmp;
-   
-   channel = info->line;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	int channel;
+	unsigned long tmp;
+
+	channel = info->line;
@@ -1544,2 +1526,2 @@
-   tmp = base_addr[CyCOR4] & CyREC_FIFO;
-   return put_user(tmp,value);
+	tmp = base_addr[CyCOR4] & CyREC_FIFO;
+	return put_user(tmp, value);
@@ -1549 +1531 @@
-set_default_threshold(struct cyclades_port * info, unsigned long __user *arg)
+set_default_threshold(struct cyclades_port *info, unsigned long __user * arg)
@@ -1551 +1533 @@
-   unsigned long value;
+	unsigned long value;
@@ -1553,2 +1535,2 @@
-   if (get_user(value, arg))
-	return -EFAULT;
+	if (get_user(value, arg))
+		return -EFAULT;
@@ -1556,2 +1538,2 @@
-   info->default_threshold = value & 0x0f;
-   return 0;
+	info->default_threshold = value & 0x0f;
+	return 0;
@@ -1561 +1543 @@
-get_default_threshold(struct cyclades_port * info, unsigned long __user *value)
+get_default_threshold(struct cyclades_port *info, unsigned long __user * value)
@@ -1563 +1545 @@
-   return put_user(info->default_threshold,value);
+	return put_user(info->default_threshold, value);
@@ -1566,2 +1548 @@
-static int
-set_timeout(struct cyclades_port * info, unsigned long __user *arg)
+static int set_timeout(struct cyclades_port *info, unsigned long __user * arg)
@@ -1569,12 +1550,12 @@
-   volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-   int channel;
-   unsigned long value;
-
-   if (get_user(value, arg))
-	   return -EFAULT;
-   
-   channel = info->line;
-
-   base_addr[CyRTPRL] = value & 0xff;
-   base_addr[CyRTPRH] = (value >> 8) & 0xff;
-   return 0;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	int channel;
+	unsigned long value;
+
+	if (get_user(value, arg))
+		return -EFAULT;
+
+	channel = info->line;
+
+	base_addr[CyRTPRL] = value & 0xff;
+	base_addr[CyRTPRH] = (value >> 8) & 0xff;
+	return 0;
@@ -1583,2 +1564 @@
-static int
-get_timeout(struct cyclades_port * info, unsigned long __user *value)
+static int get_timeout(struct cyclades_port *info, unsigned long __user * value)
@@ -1586,5 +1566,5 @@
-   volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-   int channel;
-   unsigned long tmp;
-   
-   channel = info->line;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	int channel;
+	unsigned long tmp;
+
+	channel = info->line;
@@ -1592,2 +1572,2 @@
-   tmp = base_addr[CyRTPRL];
-   return put_user(tmp,value);
+	tmp = base_addr[CyRTPRL];
+	return put_user(tmp, value);
@@ -1596,2 +1576 @@
-static int
-set_default_timeout(struct cyclades_port * info, unsigned long value)
+static int set_default_timeout(struct cyclades_port *info, unsigned long value)
@@ -1599,2 +1578,2 @@
-   info->default_timeout = value & 0xff;
-   return 0;
+	info->default_timeout = value & 0xff;
+	return 0;
@@ -1604 +1583 @@
-get_default_timeout(struct cyclades_port * info, unsigned long __user *value)
+get_default_timeout(struct cyclades_port *info, unsigned long __user * value)
@@ -1606 +1585 @@
-   return put_user(info->default_timeout,value);
+	return put_user(info->default_timeout, value);
@@ -1610,2 +1589,2 @@
-cy_ioctl(struct tty_struct *tty, struct file * file,
-            unsigned int cmd, unsigned long arg)
+cy_ioctl(struct tty_struct *tty, struct file *file,
+	 unsigned int cmd, unsigned long arg)
@@ -1613,4 +1592,4 @@
-  unsigned long val;
-  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
-  int ret_val = 0;
-  void __user *argp = (void __user *)arg;
+	unsigned long val;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	int ret_val = 0;
+	void __user *argp = (void __user *)arg;
@@ -1619 +1598 @@
-    printk("cy_ioctl %s, cmd = %x arg = %lx\n", tty->name, cmd, arg); /* */
+	printk("cy_ioctl %s, cmd = %x arg = %lx\n", tty->name, cmd, arg);	/* */
@@ -1622,43 +1601,43 @@
-    switch (cmd) {
-        case CYGETMON:
-            ret_val = get_mon_info(info, argp);
-	    break;
-        case CYGETTHRESH:
-	    ret_val = get_threshold(info, argp);
- 	    break;
-        case CYSETTHRESH:
-            ret_val = set_threshold(info, argp);
-	    break;
-        case CYGETDEFTHRESH:
-	    ret_val = get_default_threshold(info, argp);
- 	    break;
-        case CYSETDEFTHRESH:
-            ret_val = set_default_threshold(info, argp);
-	    break;
-        case CYGETTIMEOUT:
-	    ret_val = get_timeout(info, argp);
- 	    break;
-        case CYSETTIMEOUT:
-            ret_val = set_timeout(info, argp);
-	    break;
-        case CYGETDEFTIMEOUT:
-	    ret_val = get_default_timeout(info, argp);
- 	    break;
-        case CYSETDEFTIMEOUT:
-            ret_val = set_default_timeout(info, (unsigned long)arg);
-	    break;
-        case TCSBRK:    /* SVID version: non-zero arg --> no break */
-	    ret_val = tty_check_change(tty);
-	    if (ret_val)
-		    break;
-            tty_wait_until_sent(tty,0);
-            if (!arg)
-                send_break(info, HZ/4); /* 1/4 second */
-            break;
-        case TCSBRKP:   /* support for POSIX tcsendbreak() */
-	    ret_val = tty_check_change(tty);
-	    if (ret_val)
-		break;
-            tty_wait_until_sent(tty,0);
-            send_break(info, arg ? arg*(HZ/10) : HZ/4);
-            break;
+	switch (cmd) {
+	case CYGETMON:
+		ret_val = get_mon_info(info, argp);
+		break;
+	case CYGETTHRESH:
+		ret_val = get_threshold(info, argp);
+		break;
+	case CYSETTHRESH:
+		ret_val = set_threshold(info, argp);
+		break;
+	case CYGETDEFTHRESH:
+		ret_val = get_default_threshold(info, argp);
+		break;
+	case CYSETDEFTHRESH:
+		ret_val = set_default_threshold(info, argp);
+		break;
+	case CYGETTIMEOUT:
+		ret_val = get_timeout(info, argp);
+		break;
+	case CYSETTIMEOUT:
+		ret_val = set_timeout(info, argp);
+		break;
+	case CYGETDEFTIMEOUT:
+		ret_val = get_default_timeout(info, argp);
+		break;
+	case CYSETDEFTIMEOUT:
+		ret_val = set_default_timeout(info, (unsigned long)arg);
+		break;
+	case TCSBRK:		/* SVID version: non-zero arg --> no break */
+		ret_val = tty_check_change(tty);
+		if (ret_val)
+			break;
+		tty_wait_until_sent(tty, 0);
+		if (!arg)
+			send_break(info, HZ / 4);	/* 1/4 second */
+		break;
+	case TCSBRKP:		/* support for POSIX tcsendbreak() */
+		ret_val = tty_check_change(tty);
+		if (ret_val)
+			break;
+		tty_wait_until_sent(tty, 0);
+		send_break(info, arg ? arg * (HZ / 10) : HZ / 4);
+		break;
@@ -1667,19 +1646,21 @@
-        case TIOCGSOFTCAR:
-            ret_val = put_user(C_CLOCAL(tty) ? 1 : 0, (unsigned long __user *) argp);
-            break;
-        case TIOCSSOFTCAR:
-            ret_val = get_user(val, (unsigned long __user *) argp);
-	    if (ret_val)
-		    break;
-            tty->termios->c_cflag =
-                    ((tty->termios->c_cflag & ~CLOCAL) | (val ? CLOCAL : 0));
-            break;
-        case TIOCGSERIAL:
-            ret_val = get_serial_info(info, argp);
-            break;
-        case TIOCSSERIAL:
-            ret_val = set_serial_info(info, argp);
-            break;
-        default:
-	    ret_val = -ENOIOCTLCMD;
-    }
+	case TIOCGSOFTCAR:
+		ret_val =
+		    put_user(C_CLOCAL(tty) ? 1 : 0,
+			     (unsigned long __user *)argp);
+		break;
+	case TIOCSSOFTCAR:
+		ret_val = get_user(val, (unsigned long __user *)argp);
+		if (ret_val)
+			break;
+		tty->termios->c_cflag =
+		    ((tty->termios->c_cflag & ~CLOCAL) | (val ? CLOCAL : 0));
+		break;
+	case TIOCGSERIAL:
+		ret_val = get_serial_info(info, argp);
+		break;
+	case TIOCSSERIAL:
+		ret_val = set_serial_info(info, argp);
+		break;
+	default:
+		ret_val = -ENOIOCTLCMD;
+	}
@@ -1688 +1669 @@
-    printk("cy_ioctl done\n");
+	printk("cy_ioctl done\n");
@@ -1691,4 +1672,2 @@
-    return ret_val;
-} /* cy_ioctl */
-
-
+	return ret_val;
+}				/* cy_ioctl */
@@ -1696,3 +1675 @@
-
-static void
-cy_set_termios(struct tty_struct *tty, struct ktermios * old_termios)
+static void cy_set_termios(struct tty_struct *tty, struct ktermios *old_termios)
@@ -1700 +1677 @@
-  struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
@@ -1703 +1680 @@
-    printk("cy_set_termios %s\n", tty->name);
+	printk("cy_set_termios %s\n", tty->name);
@@ -1706,9 +1683,9 @@
-    if (tty->termios->c_cflag == old_termios->c_cflag)
-        return;
-    config_setup(info);
-
-    if ((old_termios->c_cflag & CRTSCTS) &&
-        !(tty->termios->c_cflag & CRTSCTS)) {
-            tty->stopped = 0;
-            cy_start(tty);
-    }
+	if (tty->termios->c_cflag == old_termios->c_cflag)
+		return;
+	config_setup(info);
+
+	if ((old_termios->c_cflag & CRTSCTS) &&
+	    !(tty->termios->c_cflag & CRTSCTS)) {
+		tty->stopped = 0;
+		cy_start(tty);
+	}
@@ -1716,3 +1693,3 @@
-    if (!(old_termios->c_cflag & CLOCAL) &&
-        (tty->termios->c_cflag & CLOCAL))
-            wake_up_interruptible(&info->open_wait);
+	if (!(old_termios->c_cflag & CLOCAL) &&
+	    (tty->termios->c_cflag & CLOCAL))
+		wake_up_interruptible(&info->open_wait);
@@ -1719,0 +1697 @@
+}				/* cy_set_termios */
@@ -1721,6 +1699 @@
-    return;
-} /* cy_set_termios */
-
-
-static void
-cy_close(struct tty_struct * tty, struct file * filp)
+static void cy_close(struct tty_struct *tty, struct file *filp)
@@ -1728 +1701 @@
-  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
@@ -1732 +1705 @@
-    printk("cy_close %s\n", tty->name);
+	printk("cy_close %s\n", tty->name);
@@ -1735,4 +1708,3 @@
-    if (!info
-    || serial_paranoia_check(info, tty->name, "cy_close")){
-        return;
-    }
+	if (!info || serial_paranoia_check(info, tty->name, "cy_close")) {
+		return;
+	}
@@ -1740 +1712 @@
-    printk("cy_close %s, count = %d\n", tty->name, info->count);
+	printk("cy_close %s, count = %d\n", tty->name, info->count);
@@ -1743,12 +1715,12 @@
-    if ((tty->count == 1) && (info->count != 1)) {
-	/*
-	 * Uh, oh.  tty->count is 1, which means that the tty
-	 * structure will be freed.  Info->count should always
-	 * be one in these conditions.  If it's greater than
-	 * one, we've got real problems, since it means the
-	 * serial port won't be shutdown.
-	 */
-	printk("cy_close: bad serial port count; tty->count is 1, "
-	   "info->count is %d\n", info->count);
-	info->count = 1;
-    }
+	if ((tty->count == 1) && (info->count != 1)) {
+		/*
+		 * Uh, oh.  tty->count is 1, which means that the tty
+		 * structure will be freed.  Info->count should always
+		 * be one in these conditions.  If it's greater than
+		 * one, we've got real problems, since it means the
+		 * serial port won't be shutdown.
+		 */
+		printk("cy_close: bad serial port count; tty->count is 1, "
+		       "info->count is %d\n", info->count);
+		info->count = 1;
+	}
@@ -1756 +1728,2 @@
-    printk("cyc: %d: decrementing count to %d\n", __LINE__, info->count - 1);
+	printk("cyc: %d: decrementing count to %d\n", __LINE__,
+	       info->count - 1);
@@ -1758,3 +1731,3 @@
-    if (--info->count < 0) {
-	printk("cy_close: bad serial port count for ttys%d: %d\n",
-	       info->line, info->count);
+	if (--info->count < 0) {
+		printk("cy_close: bad serial port count for ttys%d: %d\n",
+		       info->line, info->count);
@@ -1762 +1735 @@
-    printk("cyc: %d: setting count to 0\n", __LINE__);
+		printk("cyc: %d: setting count to 0\n", __LINE__);
@@ -1764,16 +1737 @@
-	info->count = 0;
-    }
-    if (info->count)
-	return;
-    info->flags |= ASYNC_CLOSING;
-    if (info->flags & ASYNC_INITIALIZED)
-	tty_wait_until_sent(tty, 3000); /* 30 seconds timeout */
-    shutdown(info);
-    if (tty->driver->flush_buffer)
-	tty->driver->flush_buffer(tty);
-    tty_ldisc_flush(tty);
-    info->event = 0;
-    info->tty = NULL;
-    if (info->blocked_open) {
-	if (info->close_delay) {
-	    msleep_interruptible(jiffies_to_msecs(info->close_delay));
+		info->count = 0;
@@ -1781,4 +1739,20 @@
-	wake_up_interruptible(&info->open_wait);
-    }
-    info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-    wake_up_interruptible(&info->close_wait);
+	if (info->count)
+		return;
+	info->flags |= ASYNC_CLOSING;
+	if (info->flags & ASYNC_INITIALIZED)
+		tty_wait_until_sent(tty, 3000);	/* 30 seconds timeout */
+	shutdown(info);
+	if (tty->driver->flush_buffer)
+		tty->driver->flush_buffer(tty);
+	tty_ldisc_flush(tty);
+	info->event = 0;
+	info->tty = NULL;
+	if (info->blocked_open) {
+		if (info->close_delay) {
+			msleep_interruptible(jiffies_to_msecs
+					     (info->close_delay));
+		}
+		wake_up_interruptible(&info->open_wait);
+	}
+	info->flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
+	wake_up_interruptible(&info->close_wait);
@@ -1787 +1761 @@
-    printk("cy_close done\n");
+	printk("cy_close done\n");
@@ -1789,3 +1763 @@
-
-    return;
-} /* cy_close */
+}				/* cy_close */
@@ -1796,2 +1768 @@
-void
-cy_hangup(struct tty_struct *tty)
+void cy_hangup(struct tty_struct *tty)
@@ -1799,2 +1770,2 @@
-  struct cyclades_port * info = (struct cyclades_port *)tty->driver_data;
-	
+	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+
@@ -1802 +1773 @@
-    printk("cy_hangup %s\n", tty->name); /* */
+	printk("cy_hangup %s\n", tty->name);	/* */
@@ -1805,4 +1776,4 @@
-    if (serial_paranoia_check(info, tty->name, "cy_hangup"))
-	return;
-    
-    shutdown(info);
+	if (serial_paranoia_check(info, tty->name, "cy_hangup"))
+		return;
+
+	shutdown(info);
@@ -1810,2 +1781,2 @@
-    info->event = 0;
-    info->count = 0;
+	info->event = 0;
+	info->count = 0;
@@ -1813 +1784 @@
-    printk("cyc: %d: setting count to 0\n", __LINE__);
+	printk("cyc: %d: setting count to 0\n", __LINE__);
@@ -1815 +1786 @@
-    info->tty = 0;
+	info->tty = 0;
@@ -1817,5 +1788,3 @@
-    info->flags &= ~ASYNC_NORMAL_ACTIVE;
-    wake_up_interruptible(&info->open_wait);
-} /* cy_hangup */
-
-
+	info->flags &= ~ASYNC_NORMAL_ACTIVE;
+	wake_up_interruptible(&info->open_wait);
+}				/* cy_hangup */
@@ -1830,2 +1799,2 @@
-block_til_ready(struct tty_struct *tty, struct file * filp,
-                           struct cyclades_port *info)
+block_til_ready(struct tty_struct *tty, struct file *filp,
+		struct cyclades_port *info)
@@ -1833,27 +1802,18 @@
-  DECLARE_WAITQUEUE(wait, current);
-  unsigned long flags;
-  int channel;
-  int retval;
-  volatile u_char *base_addr = (u_char *)BASE_ADDR;
-
-    /*
-     * If the device is in the middle of being closed, then block
-     * until it's done, and then try again.
-     */
-    if (info->flags & ASYNC_CLOSING) {
-	interruptible_sleep_on(&info->close_wait);
-	if (info->flags & ASYNC_HUP_NOTIFY){
-	    return -EAGAIN;
-	}else{
-	    return -ERESTARTSYS;
-	}
-    }
-
-    /*
-     * If non-blocking mode is set, then make the check up front
-     * and then exit.
-     */
-    if (filp->f_flags & O_NONBLOCK) {
-	info->flags |= ASYNC_NORMAL_ACTIVE;
-	return 0;
-    }
+	DECLARE_WAITQUEUE(wait, current);
+	unsigned long flags;
+	int channel;
+	int retval;
+	volatile u_char *base_addr = (u_char *) BASE_ADDR;
+
+	/*
+	 * If the device is in the middle of being closed, then block
+	 * until it's done, and then try again.
+	 */
+	if (info->flags & ASYNC_CLOSING) {
+		interruptible_sleep_on(&info->close_wait);
+		if (info->flags & ASYNC_HUP_NOTIFY) {
+			return -EAGAIN;
+		} else {
+			return -ERESTARTSYS;
+		}
+	}
@@ -1861,9 +1821,18 @@
-    /*
-     * Block waiting for the carrier detect and the line to become
-     * free (i.e., not in use by the callout).  While we are in
-     * this loop, info->count is dropped by one, so that
-     * cy_close() knows when to free things.  We restore it upon
-     * exit, either normal or abnormal.
-     */
-    retval = 0;
-    add_wait_queue(&info->open_wait, &wait);
+	/*
+	 * If non-blocking mode is set, then make the check up front
+	 * and then exit.
+	 */
+	if (filp->f_flags & O_NONBLOCK) {
+		info->flags |= ASYNC_NORMAL_ACTIVE;
+		return 0;
+	}
+
+	/*
+	 * Block waiting for the carrier detect and the line to become
+	 * free (i.e., not in use by the callout).  While we are in
+	 * this loop, info->count is dropped by one, so that
+	 * cy_close() knows when to free things.  We restore it upon
+	 * exit, either normal or abnormal.
+	 */
+	retval = 0;
+	add_wait_queue(&info->open_wait, &wait);
@@ -1871,2 +1840,3 @@
-    printk("block_til_ready before block: %s, count = %d\n",
-	   tty->name, info->count);/**/
+	printk("block_til_ready before block: %s, count = %d\n",
+	       tty->name, info->count);
+	/**/
@@ -1874 +1844 @@
-    info->count--;
+	    info->count--;
@@ -1876 +1846 @@
-    printk("cyc: %d: decrementing count to %d\n", __LINE__, info->count);
+	printk("cyc: %d: decrementing count to %d\n", __LINE__, info->count);
@@ -1878 +1848 @@
-    info->blocked_open++;
+	info->blocked_open++;
@@ -1880 +1850 @@
-    channel = info->line;
+	channel = info->line;
@@ -1882,4 +1852,4 @@
-    while (1) {
-	local_irq_save(flags);
-	base_addr[CyCAR] = (u_char)channel;
-	base_addr[CyMSVR1] = CyRTS;
+	while (1) {
+		local_irq_save(flags);
+		base_addr[CyCAR] = (u_char) channel;
+		base_addr[CyMSVR1] = CyRTS;
@@ -1887 +1857 @@
-	base_addr[CyMSVR2] = CyDTR;
+		base_addr[CyMSVR2] = CyDTR;
@@ -1889,16 +1859,17 @@
-	printk("cyc: %d: raising DTR\n", __LINE__);
-	printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1], base_addr[CyMSVR2]);
-#endif
-	local_irq_restore(flags);
-	set_current_state(TASK_INTERRUPTIBLE);
-	if (tty_hung_up_p(filp)
-	|| !(info->flags & ASYNC_INITIALIZED) ){
-	    if (info->flags & ASYNC_HUP_NOTIFY) {
-		retval = -EAGAIN;
-	    }else{
-		retval = -ERESTARTSYS;
-	    }
-	    break;
-	}
-	local_irq_save(flags);
-	    base_addr[CyCAR] = (u_char)channel;
+		printk("cyc: %d: raising DTR\n", __LINE__);
+		printk("     status: 0x%x, 0x%x\n", base_addr[CyMSVR1],
+		       base_addr[CyMSVR2]);
+#endif
+		local_irq_restore(flags);
+		set_current_state(TASK_INTERRUPTIBLE);
+		if (tty_hung_up_p(filp)
+		    || !(info->flags & ASYNC_INITIALIZED)) {
+			if (info->flags & ASYNC_HUP_NOTIFY) {
+				retval = -EAGAIN;
+			} else {
+				retval = -ERESTARTSYS;
+			}
+			break;
+		}
+		local_irq_save(flags);
+		base_addr[CyCAR] = (u_char) channel;
@@ -1906,11 +1877,11 @@
-	    if (!(info->flags & ASYNC_CLOSING)
-	    && (C_CLOCAL(tty)
-	        || (base_addr[CyMSVR1] & CyDCD))) {
-		    local_irq_restore(flags);
-		    break;
-	    }
-	local_irq_restore(flags);
-	if (signal_pending(current)) {
-	    retval = -ERESTARTSYS;
-	    break;
-	}
+		if (!(info->flags & ASYNC_CLOSING)
+		    && (C_CLOCAL(tty)
+			|| (base_addr[CyMSVR1] & CyDCD))) {
+			local_irq_restore(flags);
+			break;
+		}
+		local_irq_restore(flags);
+		if (signal_pending(current)) {
+			retval = -ERESTARTSYS;
+			break;
+		}
@@ -1918,9 +1889,10 @@
-	printk("block_til_ready blocking: %s, count = %d\n",
-	       tty->name, info->count);/**/
-#endif
-	schedule();
-    }
-    current->state = TASK_RUNNING;
-    remove_wait_queue(&info->open_wait, &wait);
-    if (!tty_hung_up_p(filp)){
-	info->count++;
+		printk("block_til_ready blocking: %s, count = %d\n",
+		       tty->name, info->count);
+		/**/
+#endif
+		    schedule();
+	}
+	current->state = TASK_RUNNING;
+	remove_wait_queue(&info->open_wait, &wait);
+	if (!tty_hung_up_p(filp)) {
+		info->count++;
@@ -1928 +1900,2 @@
-    printk("cyc: %d: incrementing count to %d\n", __LINE__, info->count);
+		printk("cyc: %d: incrementing count to %d\n", __LINE__,
+		       info->count);
@@ -1930,2 +1903,2 @@
-    }
-    info->blocked_open--;
+	}
+	info->blocked_open--;
@@ -1933,2 +1906,3 @@
-    printk("block_til_ready after blocking: %s, count = %d\n",
-	   tty->name, info->count);/**/
+	printk("block_til_ready after blocking: %s, count = %d\n",
+	       tty->name, info->count);
+	/**/
@@ -1936,5 +1910,5 @@
-    if (retval)
-	    return retval;
-    info->flags |= ASYNC_NORMAL_ACTIVE;
-    return 0;
-} /* block_til_ready */
+	    if (retval)
+		return retval;
+	info->flags |= ASYNC_NORMAL_ACTIVE;
+	return 0;
+}				/* block_til_ready */
@@ -1946,2 +1920 @@
-int
-cy_open(struct tty_struct *tty, struct file * filp)
+int cy_open(struct tty_struct *tty, struct file *filp)
@@ -1949,2 +1922,2 @@
-  struct cyclades_port  *info;
-  int retval, line;
+	struct cyclades_port *info;
+	int retval, line;
@@ -1953,8 +1926,8 @@
-    line = tty->index;
-    if ((line < 0) || (NR_PORTS <= line)){
-        return -ENODEV;
-    }
-    info = &cy_port[line];
-    if (info->line < 0){
-        return -ENODEV;
-    }
+	line = tty->index;
+	if ((line < 0) || (NR_PORTS <= line)) {
+		return -ENODEV;
+	}
+	info = &cy_port[line];
+	if (info->line < 0) {
+		return -ENODEV;
+	}
@@ -1962 +1935 @@
-    printk("cy_open %s\n", tty->name); /* */
+	printk("cy_open %s\n", tty->name);	/* */
@@ -1964,3 +1937,3 @@
-    if (serial_paranoia_check(info, tty->name, "cy_open")){
-        return -ENODEV;
-    }
+	if (serial_paranoia_check(info, tty->name, "cy_open")) {
+		return -ENODEV;
+	}
@@ -1968 +1941,2 @@
-    printk("cy_open %s, count = %d\n", tty->name, info->count);/**/
+	printk("cy_open %s, count = %d\n", tty->name, info->count);
+	/**/
@@ -1970 +1944 @@
-    info->count++;
+	    info->count++;
@@ -1972 +1946 @@
-    printk("cyc: %d: incrementing count to %d\n", __LINE__, info->count);
+	printk("cyc: %d: incrementing count to %d\n", __LINE__, info->count);
@@ -1974,2 +1948,2 @@
-    tty->driver_data = info;
-    info->tty = tty;
+	tty->driver_data = info;
+	info->tty = tty;
@@ -1977,7 +1951,7 @@
-    /*
-     * Start up serial port
-     */
-    retval = startup(info);
-    if (retval){
-	return retval;
-    }
+	/*
+	 * Start up serial port
+	 */
+	retval = startup(info);
+	if (retval) {
+		return retval;
+	}
@@ -1985,2 +1959,2 @@
-    retval = block_til_ready(tty, filp, info);
-    if (retval) {
+	retval = block_til_ready(tty, filp, info);
+	if (retval) {
@@ -1988,2 +1962,2 @@
-	printk("cy_open returning after block_til_ready with %d\n",
-	       retval);
+		printk("cy_open returning after block_til_ready with %d\n",
+		       retval);
@@ -1991,3 +1965,2 @@
-	return retval;
-    }
-
+		return retval;
+	}
@@ -1995 +1968,2 @@
-    printk("cy_open done\n");/**/
+	printk("cy_open done\n");
+	/**/
@@ -1997,4 +1971,2 @@
-    return 0;
-} /* cy_open */
-
-
+	    return 0;
+}				/* cy_open */
@@ -2015,2 +1987 @@
-static void
-show_version(void)
+static void show_version(void)
@@ -2018,2 +1989,2 @@
-    printk("MVME166/167 cd2401 driver\n");
-} /* show_version */
+	printk("MVME166/167 cd2401 driver\n");
+}				/* show_version */
@@ -2033,2 +2004 @@
-void
-mvme167_serial_console_setup(int cflag)
+void mvme167_serial_console_setup(int cflag)
@@ -2036 +2006 @@
-	volatile unsigned char* base_addr = (u_char *)BASE_ADDR;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
@@ -2065,15 +2035,15 @@
-        my_udelay(20000L);	/* Allow time for any active o/p to complete */
-        if(base_addr[CyCCR] != 0x00){
-            local_irq_restore(flags);
-            /* printk(" chip is never idle (CCR != 0)\n"); */
-            return;
-        }
-
-        base_addr[CyCCR] = CyCHIP_RESET;	/* Reset the chip */
-        my_udelay(1000L);
-
-        if(base_addr[CyGFRCR] == 0x00){
-            local_irq_restore(flags);
-            /* printk(" chip is not responding (GFRCR stayed 0)\n"); */
-            return;
-        }
+	my_udelay(20000L);	/* Allow time for any active o/p to complete */
+	if (base_addr[CyCCR] != 0x00) {
+		local_irq_restore(flags);
+		/* printk(" chip is never idle (CCR != 0)\n"); */
+		return;
+	}
+
+	base_addr[CyCCR] = CyCHIP_RESET;	/* Reset the chip */
+	my_udelay(1000L);
+
+	if (base_addr[CyGFRCR] == 0x00) {
+		local_irq_restore(flags);
+		/* printk(" chip is not responding (GFRCR stayed 0)\n"); */
+		return;
+	}
@@ -2088,3 +2058,3 @@
-	base_addr[CyPILR1] = 0x01;    /* Interrupt level for modem change */
-	base_addr[CyPILR2] = 0x02;    /* Interrupt level for tx ints */
-	base_addr[CyPILR3] = 0x03;    /* Interrupt level for rx ints */
+	base_addr[CyPILR1] = 0x01;	/* Interrupt level for modem change */
+	base_addr[CyPILR2] = 0x02;	/* Interrupt level for tx ints */
+	base_addr[CyPILR3] = 0x03;	/* Interrupt level for rx ints */
@@ -2098,2 +2068,2 @@
-	for (ch = 3; ch >= 0 ; ch--) {
-		base_addr[CyCAR] = (u_char)ch;
+	for (ch = 3; ch >= 0; ch--) {
+		base_addr[CyCAR] = (u_char) ch;
@@ -2102 +2072 @@
-		base_addr[CyLICR] = (u_char)ch << 2;
+		base_addr[CyLICR] = (u_char) ch << 2;
@@ -2121,3 +2091,3 @@
-	        base_addr[CyMSVR1] = 0;
-	        base_addr[CyMSVR2] = 0;
-		write_cy_cmd(base_addr,CyINIT_CHAN|CyDIS_RCVR|CyDIS_XMTR);
+		base_addr[CyMSVR1] = 0;
+		base_addr[CyMSVR2] = 0;
+		write_cy_cmd(base_addr, CyINIT_CHAN | CyDIS_RCVR | CyDIS_XMTR);
@@ -2130,2 +2100,2 @@
-        base_addr[CyMSVR1] = CyRTS;
-        base_addr[CyMSVR2] = CyDTR;
+	base_addr[CyMSVR1] = CyRTS;
+	base_addr[CyMSVR2] = CyDTR;
@@ -2133 +2103 @@
-	write_cy_cmd(base_addr,CyENB_RCVR|CyENB_XMTR);
+	write_cy_cmd(base_addr, CyENB_RCVR | CyENB_XMTR);
@@ -2139 +2109 @@
-        printk("CD2401 initialised,  chip is rev 0x%02x\n", base_addr[CyGFRCR]);
+	printk("CD2401 initialised,  chip is rev 0x%02x\n", base_addr[CyGFRCR]);
@@ -2141,3 +2111,4 @@
-        	printk("  WARNING:  Failed to identify line speed, rcor=%02x,rbpr=%02x\n",
-					rcor >> 5, rbpr);
-} /* serial_console_init */
+		printk
+		    ("  WARNING:  Failed to identify line speed, rcor=%02x,rbpr=%02x\n",
+		     rcor >> 5, rbpr);
+}				/* serial_console_init */
@@ -2163,0 +2135 @@
+
@@ -2180,2 +2152 @@
-static int __init
-serial167_init(void)
+static int __init serial167_init(void)
@@ -2183,6 +2154,6 @@
-  struct cyclades_port *info;
-  int ret = 0;
-  int good_ports = 0;
-  int port_num = 0;
-  int index;
-  int DefSpeed;
+	struct cyclades_port *info;
+	int ret = 0;
+	int good_ports = 0;
+	int port_num = 0;
+	int index;
+	int DefSpeed;
@@ -2190 +2161 @@
-  struct sigaction sa;
+	struct sigaction sa;
@@ -2193,2 +2164,2 @@
-    if (!(mvme16x_config &MVME16x_CONFIG_GOT_CD2401))
-	return 0;
+	if (!(mvme16x_config & MVME16x_CONFIG_GOT_CD2401))
+		return 0;
@@ -2196,3 +2167,3 @@
-    cy_serial_driver = alloc_tty_driver(NR_PORTS);
-    if (!cy_serial_driver)
-	return -ENOMEM;
+	cy_serial_driver = alloc_tty_driver(NR_PORTS);
+	if (!cy_serial_driver)
+		return -ENOMEM;
@@ -2201 +2172 @@
-scrn[1] = '\0';
+	scrn[1] = '\0';
@@ -2204 +2175 @@
-    show_version();
+	show_version();
@@ -2206,7 +2177,7 @@
-    /* Has "console=0,9600n8" been used in bootinfo to change speed? */
-    if (serial_console_cflag)
-	DefSpeed = serial_console_cflag & 0017;
-    else {
-	DefSpeed = initial_console_speed;
-	serial_console_info = &cy_port[0];
-	serial_console_cflag = DefSpeed | CS8;
+	/* Has "console=0,9600n8" been used in bootinfo to change speed? */
+	if (serial_console_cflag)
+		DefSpeed = serial_console_cflag & 0017;
+	else {
+		DefSpeed = initial_console_speed;
+		serial_console_info = &cy_port[0];
+		serial_console_cflag = DefSpeed | CS8;
@@ -2214 +2185 @@
-	serial_console = 64; /*callout_driver.minor_start*/
+		serial_console = 64;	/*callout_driver.minor_start */
@@ -2216 +2187,3 @@
-    }
+	}
+
+	/* Initialize the tty_driver structure */
@@ -2218,10 +2191,8 @@
-    /* Initialize the tty_driver structure */
-    
-    cy_serial_driver->owner = THIS_MODULE;
-    cy_serial_driver->name = "ttyS";
-    cy_serial_driver->major = TTY_MAJOR;
-    cy_serial_driver->minor_start = 64;
-    cy_serial_driver->type = TTY_DRIVER_TYPE_SERIAL;
-    cy_serial_driver->subtype = SERIAL_TYPE_NORMAL;
-    cy_serial_driver->init_termios = tty_std_termios;
-    cy_serial_driver->init_termios.c_cflag =
+	cy_serial_driver->owner = THIS_MODULE;
+	cy_serial_driver->name = "ttyS";
+	cy_serial_driver->major = TTY_MAJOR;
+	cy_serial_driver->minor_start = 64;
+	cy_serial_driver->type = TTY_DRIVER_TYPE_SERIAL;
+	cy_serial_driver->subtype = SERIAL_TYPE_NORMAL;
+	cy_serial_driver->init_termios = tty_std_termios;
+	cy_serial_driver->init_termios.c_cflag =
@@ -2229,2 +2200,2 @@
-    cy_serial_driver->flags = TTY_DRIVER_REAL_RAW;
-    tty_set_operations(cy_serial_driver, &cy_ops);
+	cy_serial_driver->flags = TTY_DRIVER_REAL_RAW;
+	tty_set_operations(cy_serial_driver, &cy_ops);
@@ -2232,10 +2203,10 @@
-    ret = tty_register_driver(cy_serial_driver);
-    if (ret) {
-	    printk(KERN_ERR "Couldn't register MVME166/7 serial driver\n");
-	    put_tty_driver(cy_serial_driver);
-	    return ret;
-    }
-
-    port_num = 0;
-    info = cy_port;
-    for (index = 0; index < 1; index++) {
+	ret = tty_register_driver(cy_serial_driver);
+	if (ret) {
+		printk(KERN_ERR "Couldn't register MVME166/7 serial driver\n");
+		put_tty_driver(cy_serial_driver);
+		return ret;
+	}
+
+	port_num = 0;
+	info = cy_port;
+	for (index = 0; index < 1; index++) {
@@ -2243 +2214 @@
-	good_ports = 4;
+		good_ports = 4;
@@ -2245,2 +2216,2 @@
-	if(port_num < NR_PORTS){
-	    while( good_ports-- && port_num < NR_PORTS){
+		if (port_num < NR_PORTS) {
+			while (good_ports-- && port_num < NR_PORTS) {
@@ -2248,22 +2219,22 @@
-		info->magic = CYCLADES_MAGIC;
-		info->type = PORT_CIRRUS;
-		info->card = index;
-		info->line = port_num;
-		info->flags = STD_COM_FLAGS;
-		info->tty = NULL;
-		info->xmit_fifo_size = 12;
-		info->cor1 = CyPARITY_NONE|Cy_8_BITS;
-		info->cor2 = CyETC;
-		info->cor3 = Cy_1_STOP;
-		info->cor4 = 0x08; /* _very_ small receive threshold */
-		info->cor5 = 0;
-		info->cor6 = 0;
-		info->cor7 = 0;
-		info->tbpr = baud_bpr[DefSpeed]; /* Tx BPR */
-		info->tco = baud_co[DefSpeed]; /* Tx CO */
-		info->rbpr = baud_bpr[DefSpeed]; /* Rx BPR */
-		info->rco = baud_co[DefSpeed] >> 5; /* Rx CO */
-		info->close_delay = 0;
-		info->x_char = 0;
-		info->event = 0;
-		info->count = 0;
+				info->magic = CYCLADES_MAGIC;
+				info->type = PORT_CIRRUS;
+				info->card = index;
+				info->line = port_num;
+				info->flags = STD_COM_FLAGS;
+				info->tty = NULL;
+				info->xmit_fifo_size = 12;
+				info->cor1 = CyPARITY_NONE | Cy_8_BITS;
+				info->cor2 = CyETC;
+				info->cor3 = Cy_1_STOP;
+				info->cor4 = 0x08;	/* _very_ small receive threshold */
+				info->cor5 = 0;
+				info->cor6 = 0;
+				info->cor7 = 0;
+				info->tbpr = baud_bpr[DefSpeed];	/* Tx BPR */
+				info->tco = baud_co[DefSpeed];	/* Tx CO */
+				info->rbpr = baud_bpr[DefSpeed];	/* Rx BPR */
+				info->rco = baud_co[DefSpeed] >> 5;	/* Rx CO */
+				info->close_delay = 0;
+				info->x_char = 0;
+				info->event = 0;
+				info->count = 0;
@@ -2271 +2242,2 @@
-    printk("cyc: %d: setting count to 0\n", __LINE__);
+				printk("cyc: %d: setting count to 0\n",
+				       __LINE__);
@@ -2273,8 +2245,8 @@
-		info->blocked_open = 0;
-		info->default_threshold = 0;
-		info->default_timeout = 0;
-		INIT_WORK(&info->tqueue, do_softint);
-		init_waitqueue_head(&info->open_wait);
-		init_waitqueue_head(&info->close_wait);
-		/* info->session */
-		/* info->pgrp */
+				info->blocked_open = 0;
+				info->default_threshold = 0;
+				info->default_timeout = 0;
+				INIT_WORK(&info->tqueue, do_softint);
+				init_waitqueue_head(&info->open_wait);
+				init_waitqueue_head(&info->close_wait);
+				/* info->session */
+				/* info->pgrp */
@@ -2282,17 +2254,20 @@
-		info->read_status_mask = CyTIMEOUT| CySPECHAR| CyBREAK
-                                       | CyPARITY| CyFRAME| CyOVERRUN;
-		/* info->timeout */
-
-		printk("ttyS%d ", info->line);
-		port_num++;info++;
-		if(!(port_num & 7)){
-		    printk("\n               ");
-		}
-	    }
-	}
-	printk("\n");
-    }
-    while( port_num < NR_PORTS){
-	info->line = -1;
-	port_num++;info++;
-    }
+				info->read_status_mask =
+				    CyTIMEOUT | CySPECHAR | CyBREAK | CyPARITY |
+				    CyFRAME | CyOVERRUN;
+				/* info->timeout */
+
+				printk("ttyS%d ", info->line);
+				port_num++;
+				info++;
+				if (!(port_num & 7)) {
+					printk("\n               ");
+				}
+			}
+		}
+		printk("\n");
+	}
+	while (port_num < NR_PORTS) {
+		info->line = -1;
+		port_num++;
+		info++;
+	}
@@ -2300 +2275 @@
-    debug_setup();
+	debug_setup();
@@ -2302,33 +2277,27 @@
-    ret = request_irq(MVME167_IRQ_SER_ERR, cd2401_rxerr_interrupt, 0,
-				"cd2401_errors", cd2401_rxerr_interrupt);
-    if (ret) {
-	    printk(KERN_ERR "Could't get cd2401_errors IRQ");
-	    goto cleanup_serial_driver;
-    }
-
-    ret = request_irq(MVME167_IRQ_SER_MODEM, cd2401_modem_interrupt, 0,
-				"cd2401_modem", cd2401_modem_interrupt);
-    if (ret) {
-	    printk(KERN_ERR "Could't get cd2401_modem IRQ");
-	    goto cleanup_irq_cd2401_errors;
-    }
-
-    ret = request_irq(MVME167_IRQ_SER_TX, cd2401_tx_interrupt, 0,
-				"cd2401_txints", cd2401_tx_interrupt);
-    if (ret) {
-	    printk(KERN_ERR "Could't get cd2401_txints IRQ");
-	    goto cleanup_irq_cd2401_modem;
-    }
-
-    ret = request_irq(MVME167_IRQ_SER_RX, cd2401_rx_interrupt, 0,
-				"cd2401_rxints", cd2401_rx_interrupt);
-    if (ret) {
-	    printk(KERN_ERR "Could't get cd2401_rxints IRQ");
-	    goto cleanup_irq_cd2401_txints;
-    }
-
-    /* Now we have registered the interrupt handlers, allow the interrupts */
-
-    pcc2chip[PccSCCMICR] = 0x15;		/* Serial ints are level 5 */
-    pcc2chip[PccSCCTICR] = 0x15;
-    pcc2chip[PccSCCRICR] = 0x15;
+	ret = request_irq(MVME167_IRQ_SER_ERR, cd2401_rxerr_interrupt, 0,
+			  "cd2401_errors", cd2401_rxerr_interrupt);
+	if (ret) {
+		printk(KERN_ERR "Could't get cd2401_errors IRQ");
+		goto cleanup_serial_driver;
+	}
+
+	ret = request_irq(MVME167_IRQ_SER_MODEM, cd2401_modem_interrupt, 0,
+			  "cd2401_modem", cd2401_modem_interrupt);
+	if (ret) {
+		printk(KERN_ERR "Could't get cd2401_modem IRQ");
+		goto cleanup_irq_cd2401_errors;
+	}
+
+	ret = request_irq(MVME167_IRQ_SER_TX, cd2401_tx_interrupt, 0,
+			  "cd2401_txints", cd2401_tx_interrupt);
+	if (ret) {
+		printk(KERN_ERR "Could't get cd2401_txints IRQ");
+		goto cleanup_irq_cd2401_modem;
+	}
+
+	ret = request_irq(MVME167_IRQ_SER_RX, cd2401_rx_interrupt, 0,
+			  "cd2401_rxints", cd2401_rx_interrupt);
+	if (ret) {
+		printk(KERN_ERR "Could't get cd2401_rxints IRQ");
+		goto cleanup_irq_cd2401_txints;
+	}
@@ -2336 +2305 @@
-    pcc2chip[PccIMLR] = 3;			/* Allow PCC2 ints above 3!? */
+	/* Now we have registered the interrupt handlers, allow the interrupts */
@@ -2338 +2307,7 @@
-    return 0;
+	pcc2chip[PccSCCMICR] = 0x15;	/* Serial ints are level 5 */
+	pcc2chip[PccSCCTICR] = 0x15;
+	pcc2chip[PccSCCRICR] = 0x15;
+
+	pcc2chip[PccIMLR] = 3;	/* Allow PCC2 ints above 3!? */
+
+	return 0;
@@ -2340 +2315 @@
-    free_irq(MVME167_IRQ_SER_TX, cd2401_tx_interrupt);
+	free_irq(MVME167_IRQ_SER_TX, cd2401_tx_interrupt);
@@ -2342 +2317 @@
-    free_irq(MVME167_IRQ_SER_MODEM, cd2401_modem_interrupt);
+	free_irq(MVME167_IRQ_SER_MODEM, cd2401_modem_interrupt);
@@ -2344 +2319 @@
-    free_irq(MVME167_IRQ_SER_ERR, cd2401_rxerr_interrupt);
+	free_irq(MVME167_IRQ_SER_ERR, cd2401_rxerr_interrupt);
@@ -2346,5 +2321,6 @@
-    if (tty_unregister_driver(cy_serial_driver))
-	    printk(KERN_ERR "Couldn't unregister MVME166/7 serial driver\n");
-    put_tty_driver(cy_serial_driver);
-    return ret;
-} /* serial167_init */
+	if (tty_unregister_driver(cy_serial_driver))
+		printk(KERN_ERR
+		       "Couldn't unregister MVME166/7 serial driver\n");
+	put_tty_driver(cy_serial_driver);
+	return ret;
+}				/* serial167_init */
@@ -2354 +2329,0 @@
-
@@ -2356,2 +2331 @@
-static void
-show_status(int line_num)
+static void show_status(int line_num)
@@ -2359,26 +2333,4 @@
-  volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-  int channel;
-  struct cyclades_port * info;
-  unsigned long flags;
-
-    info = &cy_port[line_num];
-    channel = info->line;
-    printk("  channel %d\n", channel);/**/
-
-    printk(" cy_port\n");
-    printk("  card line flags = %d %d %x\n",
-                 info->card, info->line, info->flags);
-    printk("  *tty read_status_mask timeout xmit_fifo_size = %lx %x %x %x\n",
-                 (long)info->tty, info->read_status_mask,
-                 info->timeout, info->xmit_fifo_size);
-    printk("  cor1,cor2,cor3,cor4,cor5,cor6,cor7 = %x %x %x %x %x %x %x\n",
-             info->cor1, info->cor2, info->cor3, info->cor4, info->cor5,
-			info->cor6, info->cor7);
-    printk("  tbpr,tco,rbpr,rco = %d %d %d %d\n",
-             info->tbpr, info->tco, info->rbpr, info->rco);
-    printk("  close_delay event count = %d %d %d\n",
-             info->close_delay, info->event, info->count);
-    printk("  x_char blocked_open = %x %x\n",
-             info->x_char, info->blocked_open);
-    printk("  open_wait = %lx %lx %lx\n",
-             (long)info->open_wait);
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	int channel;
+	struct cyclades_port *info;
+	unsigned long flags;
@@ -2385,0 +2338,20 @@
+	info = &cy_port[line_num];
+	channel = info->line;
+	printk("  channel %d\n", channel);
+	/**/ printk(" cy_port\n");
+	printk("  card line flags = %d %d %x\n",
+	       info->card, info->line, info->flags);
+	printk
+	    ("  *tty read_status_mask timeout xmit_fifo_size = %lx %x %x %x\n",
+	     (long)info->tty, info->read_status_mask, info->timeout,
+	     info->xmit_fifo_size);
+	printk("  cor1,cor2,cor3,cor4,cor5,cor6,cor7 = %x %x %x %x %x %x %x\n",
+	       info->cor1, info->cor2, info->cor3, info->cor4, info->cor5,
+	       info->cor6, info->cor7);
+	printk("  tbpr,tco,rbpr,rco = %d %d %d %d\n", info->tbpr, info->tco,
+	       info->rbpr, info->rco);
+	printk("  close_delay event count = %d %d %d\n", info->close_delay,
+	       info->event, info->count);
+	printk("  x_char blocked_open = %x %x\n", info->x_char,
+	       info->blocked_open);
+	printk("  open_wait = %lx %lx %lx\n", (long)info->open_wait);
@@ -2387 +2359 @@
-    local_irq_save(flags);
+	local_irq_save(flags);
@@ -2401 +2373 @@
-	base_addr[CyCAR] = (u_char)channel;
+	base_addr[CyCAR] = (u_char) channel;
@@ -2445,2 +2417,2 @@
-    local_irq_restore(flags);
-} /* show_status */
+	local_irq_restore(flags);
+}				/* show_status */
@@ -2449 +2420,0 @@
-
@@ -2462 +2433,2 @@
-	if (ints[0] > 3 || ints[1] > 3) return;
+	if (ints[0] > 3 || ints[1] > 3)
+		return;
@@ -2468 +2440,2 @@
-	if (ints[2]) baud = ints[2];
+	if (ints[2])
+		baud = ints[2];
@@ -2472,3 +2445,5 @@
-		} while(*s >= '0' && *s <= '9');
-		if (*s) parity = *s++;
-		if (*s) bits   = *s - '0';
+		} while (*s >= '0' && *s <= '9');
+		if (*s)
+			parity = *s++;
+		if (*s)
+			bits = *s - '0';
@@ -2478,17 +2453,17 @@
-	switch(baud) {
-		case 1200:
-			cflag |= B1200;
-			break;
-		case 9600:
-			cflag |= B9600;
-			break;
-		case 19200:
-			cflag |= B19200;
-			break;
-		case 38400:
-			cflag |= B38400;
-			break;
-		case 2400:
-		default:
-			cflag |= B2400;
-			break;
+	switch (baud) {
+	case 1200:
+		cflag |= B1200;
+		break;
+	case 9600:
+		cflag |= B9600;
+		break;
+	case 19200:
+		cflag |= B19200;
+		break;
+	case 38400:
+		cflag |= B38400;
+		break;
+	case 2400:
+	default:
+		cflag |= B2400;
+		break;
@@ -2496,8 +2471,8 @@
-	switch(bits) {
-		case 7:
-			cflag |= CS7;
-			break;
-		default:
-		case 8:
-			cflag |= CS8;
-			break;
+	switch (bits) {
+	case 7:
+		cflag |= CS7;
+		break;
+	default:
+	case 8:
+		cflag |= CS8;
+		break;
@@ -2505,7 +2480,9 @@
-	switch(parity) {
-		case 'o': case 'O':
-			cflag |= PARODD;
-			break;
-		case 'e': case 'E':
-			cflag |= PARENB;
-			break;
+	switch (parity) {
+	case 'o':
+	case 'O':
+		cflag |= PARODD;
+		break;
+	case 'e':
+	case 'E':
+		cflag |= PARENB;
+		break;
@@ -2516 +2493 @@
-	serial_console = ints[1] + 64; /*callout_driver.minor_start*/
+	serial_console = ints[1] + 64;	/*callout_driver.minor_start */
@@ -2535 +2512,2 @@
-void serial167_console_write(struct console *co, const char *str, unsigned count)
+void serial167_console_write(struct console *co, const char *str,
+			     unsigned count)
@@ -2537 +2515 @@
-	volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
@@ -2550 +2528 @@
-	base_addr[CyCAR] = (u_char)port;
+	base_addr[CyCAR] = (u_char) port;
@@ -2559,2 +2537 @@
-		if (pcc2chip[PccSCCTICR] & 0x20)
-		{
+		if (pcc2chip[PccSCCTICR] & 0x20) {
@@ -2574,2 +2551 @@
-				}
-				else if (*str == '\n') {
+				} else if (*str == '\n') {
@@ -2578,2 +2554 @@
-				}
-				else {
+				} else {
@@ -2584,2 +2559 @@
-			}
-			else
+			} else
@@ -2595 +2569,2 @@
-static struct tty_driver *serial167_console_device(struct console *c, int *index)
+static struct tty_driver *serial167_console_device(struct console *c,
+						   int *index)
@@ -2601 +2575,0 @@
-
@@ -2607 +2580,0 @@
-
@@ -2609,6 +2582,6 @@
-	.name		= "ttyS",
-	.write		= serial167_console_write,
-	.device		= serial167_console_device,
-	.setup		= serial167_console_setup,
-	.flags		= CON_PRINTBUFFER,
-	.index		= -1,
+	.name = "ttyS",
+	.write = serial167_console_write,
+	.device = serial167_console_device,
+	.setup = serial167_console_setup,
+	.flags = CON_PRINTBUFFER,
+	.index = -1,
@@ -2617 +2589,0 @@
-
@@ -2621,2 +2593,2 @@
-			vme_brdtype == VME_TYPE_MVME167 ||
-			vme_brdtype == VME_TYPE_MVME177) {
+	    vme_brdtype == VME_TYPE_MVME167 ||
+	    vme_brdtype == VME_TYPE_MVME177) {
@@ -2627,0 +2600 @@
+
@@ -2631 +2604 @@
-void putDebugChar (int c)
+void putDebugChar(int c)
@@ -2633 +2606 @@
-	volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
@@ -2644 +2617 @@
-	base_addr[CyCAR] = (u_char)port;
+	base_addr[CyCAR] = (u_char) port;
@@ -2653,2 +2626 @@
-		if (pcc2chip[PccSCCTICR] & 0x20)
-		{
+		if (pcc2chip[PccSCCTICR] & 0x20) {
@@ -2661,2 +2633 @@
-			}
-			else
+			} else
@@ -2674 +2645 @@
-	volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
@@ -2696 +2667 @@
-	base_addr[CyCAR] = (u_char)port;
+	base_addr[CyCAR] = (u_char) port;
@@ -2706,2 +2677 @@
-		if (pcc2chip[PccSCCRICR] & 0x20)
-		{
+		if (pcc2chip[PccSCCRICR] & 0x20) {
@@ -2712,2 +2682 @@
-				while (cnt-- > 0)
-				{
+				while (cnt-- > 0) {
@@ -2716 +2685,3 @@
-						printk ("!! debug char is null (cnt=%d) !!", cnt);
+						printk
+						    ("!! debug char is null (cnt=%d) !!",
+						     cnt);
@@ -2718 +2689 @@
-						queueDebugChar (c);
+						queueDebugChar(c);
@@ -2723 +2694 @@
-					panic ("Debug input queue empty!");
+					panic("Debug input queue empty!");
@@ -2729,2 +2700 @@
-			}
-			else
+			} else
@@ -2742 +2712 @@
-void queueDebugChar (int c)
+void queueDebugChar(int c)
@@ -2754,2 +2724 @@
-static void
-debug_setup()
+static void debug_setup()
@@ -2757,3 +2726,3 @@
-  unsigned long flags;
-  volatile unsigned char *base_addr = (u_char *)BASE_ADDR;
-  int   i, cflag;
+	unsigned long flags;
+	volatile unsigned char *base_addr = (u_char *) BASE_ADDR;
+	int i, cflag;
@@ -2761 +2730 @@
-    cflag = B19200;
+	cflag = B19200;
@@ -2763 +2732 @@
-    local_irq_save(flags);
+	local_irq_save(flags);
@@ -2765,5 +2734,4 @@
-    for (i = 0; i < 4; i++)
-    {
-	base_addr[CyCAR] = i;
-	base_addr[CyLICR] = i << 2;
-    }
+	for (i = 0; i < 4; i++) {
+		base_addr[CyCAR] = i;
+		base_addr[CyLICR] = i << 2;
+	}
@@ -2771 +2739 @@
-    debugiq.in = debugiq.out = 0;
+	debugiq.in = debugiq.out = 0;
@@ -2773 +2741 @@
-    base_addr[CyCAR] = DEBUG_PORT;
+	base_addr[CyCAR] = DEBUG_PORT;
@@ -2775,2 +2743,2 @@
-    /* baud rate */
-    i = cflag & CBAUD;
+	/* baud rate */
+	i = cflag & CBAUD;
@@ -2778 +2746 @@
-    base_addr[CyIER] = 0;
+	base_addr[CyIER] = 0;
@@ -2780,3 +2748,3 @@
-    base_addr[CyCMR] = CyASYNC;
-    base_addr[CyLICR] = DEBUG_PORT << 2;
-    base_addr[CyLIVR] = 0x5c;
+	base_addr[CyCMR] = CyASYNC;
+	base_addr[CyLICR] = DEBUG_PORT << 2;
+	base_addr[CyLIVR] = 0x5c;
@@ -2784 +2752 @@
-    /* tx and rx baud rate */
+	/* tx and rx baud rate */
@@ -2786,4 +2754,4 @@
-    base_addr[CyTCOR] = baud_co[i];
-    base_addr[CyTBPR] = baud_bpr[i];
-    base_addr[CyRCOR] = baud_co[i] >> 5;
-    base_addr[CyRBPR] = baud_bpr[i];
+	base_addr[CyTCOR] = baud_co[i];
+	base_addr[CyTBPR] = baud_bpr[i];
+	base_addr[CyRCOR] = baud_co[i] >> 5;
+	base_addr[CyRBPR] = baud_bpr[i];
@@ -2791 +2759 @@
-    /* set line characteristics  according configuration */
+	/* set line characteristics  according configuration */
@@ -2793,11 +2761,11 @@
-    base_addr[CySCHR1] = 0;
-    base_addr[CySCHR2] = 0;
-    base_addr[CySCRL] = 0;
-    base_addr[CySCRH] = 0;
-    base_addr[CyCOR1] = Cy_8_BITS | CyPARITY_NONE;
-    base_addr[CyCOR2] = 0;
-    base_addr[CyCOR3] = Cy_1_STOP;
-    base_addr[CyCOR4] = baud_cor4[i];
-    base_addr[CyCOR5] = 0;
-    base_addr[CyCOR6] = 0;
-    base_addr[CyCOR7] = 0;
+	base_addr[CySCHR1] = 0;
+	base_addr[CySCHR2] = 0;
+	base_addr[CySCRL] = 0;
+	base_addr[CySCRH] = 0;
+	base_addr[CyCOR1] = Cy_8_BITS | CyPARITY_NONE;
+	base_addr[CyCOR2] = 0;
+	base_addr[CyCOR3] = Cy_1_STOP;
+	base_addr[CyCOR4] = baud_cor4[i];
+	base_addr[CyCOR5] = 0;
+	base_addr[CyCOR6] = 0;
+	base_addr[CyCOR7] = 0;
@@ -2805,2 +2773,2 @@
-    write_cy_cmd(base_addr,CyINIT_CHAN);
-    write_cy_cmd(base_addr,CyENB_RCVR);
+	write_cy_cmd(base_addr, CyINIT_CHAN);
+	write_cy_cmd(base_addr, CyENB_RCVR);
@@ -2808 +2776 @@
-    base_addr[CyCAR] = DEBUG_PORT; /* !!! Is this needed? */
+	base_addr[CyCAR] = DEBUG_PORT;	/* !!! Is this needed? */
@@ -2810,2 +2778,2 @@
-    base_addr[CyRTPRL] = 2;
-    base_addr[CyRTPRH] = 0;
+	base_addr[CyRTPRL] = 2;
+	base_addr[CyRTPRH] = 0;
@@ -2813,2 +2781,2 @@
-    base_addr[CyMSVR1] = CyRTS;
-    base_addr[CyMSVR2] = CyDTR;
+	base_addr[CyMSVR1] = CyRTS;
+	base_addr[CyMSVR2] = CyDTR;
@@ -2816 +2784 @@
-    base_addr[CyIER] = CyRxData;
+	base_addr[CyIER] = CyRxData;
@@ -2818 +2786 @@
-    local_irq_restore(flags);
+	local_irq_restore(flags);
@@ -2820 +2788 @@
-} /* debug_setup */
+}				/* debug_setup */
--- ./projects/linux/linux-2.6.21/drivers/char/serial167.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/char/serial167.c	2007-07-09 01:32:17.000000000 +0200
@@ -1895 +1895 @@
-	current->state = TASK_RUNNING;
+	__set_current_state(TASK_RUNNING);
--- ./projects/linux/linux-2.6.22/drivers/char/serial167.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/serial167.c	2007-10-09 22:31:38.000000000 +0200
@@ -2576,5 +2575,0 @@
-static int __init serial167_console_setup(struct console *co, char *options)
-{
-	return 0;
-}
-
@@ -2585 +2579,0 @@
-	.setup = serial167_console_setup,
--- ./projects/linux/linux-2.6.24/drivers/char/serial167.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/serial167.c	2008-04-17 04:49:44.000000000 +0200
@@ -93,2 +92,0 @@
-#define SERIAL_TYPE_NORMAL  1
-
@@ -362,12 +359,0 @@
-/*
- * This routine is used by the interrupt handler to schedule
- * processing in the software interrupt portion of the driver
- * (also known as the "bottom half").  This can be called any
- * number of times for any channel without harm.
- */
-static inline void cy_sched_event(struct cyclades_port *info, int event)
-{
-	info->event |= 1 << event;	/* remember what kind of event and who */
-	schedule_work(&info->tqueue);
-}				/* cy_sched_event */
-
@@ -488 +474 @@
-				cy_sched_event(info, Cy_EVENT_OPEN_WAKEUP);
+				wake_up_interruptible(&info->open_wait);
@@ -491 +477,3 @@
-				cy_sched_event(info, Cy_EVENT_HANGUP);
+				tty_hangup(info->tty);
+				wake_up_interruptible(&info->open_wait);
+				info->flags &= ~ASYNC_NORMAL_ACTIVE;
@@ -501,2 +489 @@
-					cy_sched_event(info,
-						       Cy_EVENT_WRITE_WAKEUP);
+					tty_wakeup(info->tty);
@@ -548,3 +534,0 @@
-		if (info->xmit_cnt < WAKEUP_CHARS) {
-			cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
-		}
@@ -632,3 +616,3 @@
-	if (info->xmit_cnt < WAKEUP_CHARS) {
-		cy_sched_event(info, Cy_EVENT_WRITE_WAKEUP);
-	}
+	if (info->xmit_cnt < WAKEUP_CHARS)
+		tty_wakeup(info->tty);
+
@@ -695,43 +678,0 @@
-/*
- * This routine is used to handle the "bottom half" processing for the
- * serial driver, known also the "software interrupt" processing.
- * This processing is done at the kernel interrupt level, after the
- * cy#/_interrupt() has returned, BUT WITH INTERRUPTS TURNED ON.  This
- * is where time-consuming activities which can not be done in the
- * interrupt driver proper are done; the interrupt driver schedules
- * them using cy_sched_event(), and they get done here.
- *
- * This is done through one level of indirection--the task queue.
- * When a hardware interrupt service routine wants service by the
- * driver's bottom half, it enqueues the appropriate tq_struct (one
- * per port) to the keventd work queue and sets a request flag
- * that the work queue be processed.
- *
- * Although this may seem unwieldy, it gives the system a way to
- * pass an argument (in this case the pointer to the cyclades_port
- * structure) to the bottom half of the driver.  Previous kernels
- * had to poll every port to see if that port needed servicing.
- */
-static void do_softint(struct work_struct *ugly_api)
-{
-	struct cyclades_port *info =
-	    container_of(ugly_api, struct cyclades_port, tqueue);
-	struct tty_struct *tty;
-
-	tty = info->tty;
-	if (!tty)
-		return;
-
-	if (test_and_clear_bit(Cy_EVENT_HANGUP, &info->event)) {
-		tty_hangup(info->tty);
-		wake_up_interruptible(&info->open_wait);
-		info->flags &= ~ASYNC_NORMAL_ACTIVE;
-	}
-	if (test_and_clear_bit(Cy_EVENT_OPEN_WAKEUP, &info->event)) {
-		wake_up_interruptible(&info->open_wait);
-	}
-	if (test_and_clear_bit(Cy_EVENT_WRITE_WAKEUP, &info->event)) {
-		tty_wakeup(tty);
-	}
-}				/* do_softint */
-
@@ -1748 +1688,0 @@
-	info->event = 0;
@@ -2239 +2178,0 @@
-				info->event = 0;
@@ -2248 +2186,0 @@
-				INIT_WORK(&info->tqueue, do_softint);
--- ./projects/linux/linux-2.6.25/drivers/char/serial167.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/serial167.c	2008-07-13 23:51:29.000000000 +0200
@@ -1063 +1063 @@
-static void cy_put_char(struct tty_struct *tty, unsigned char ch)
+static int cy_put_char(struct tty_struct *tty, unsigned char ch)
@@ -1073 +1073 @@
-		return;
+		return 0;
@@ -1076 +1076 @@
-		return;
+		return 0;
@@ -1081 +1081 @@
-		return;
+		return 0;
@@ -1087,0 +1088 @@
+	return 1;
@@ -1541,0 +1543,2 @@
+	lock_kernel();
+
@@ -1587,12 +1589,0 @@
-	case TIOCGSOFTCAR:
-		ret_val =
-		    put_user(C_CLOCAL(tty) ? 1 : 0,
-			     (unsigned long __user *)argp);
-		break;
-	case TIOCSSOFTCAR:
-		ret_val = get_user(val, (unsigned long __user *)argp);
-		if (ret_val)
-			break;
-		tty->termios->c_cflag =
-		    ((tty->termios->c_cflag & ~CLOCAL) | (val ? CLOCAL : 0));
-		break;
@@ -1607,0 +1599 @@
+	unlock_kernel();
@@ -1686,2 +1678 @@
-	if (tty->driver->flush_buffer)
-		tty->driver->flush_buffer(tty);
+	cy_flush_buffer(tty);
--- ./projects/linux/linux-2.6.27/drivers/char/serial167.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/char/serial167.c	2008-12-25 00:26:37.000000000 +0100
@@ -421 +421 @@
-					   overflowing, we still loose
+					   overflowing, we still lose
--- ./projects/linux/linux-2.6.28/drivers/char/serial167.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/char/serial167.c	2009-03-24 00:12:14.000000000 +0100
@@ -318 +318 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -340 +340 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1065 +1065 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1093 +1093 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1125 +1125 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1169 +1169 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1186 +1186 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1200 +1200 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1221 +1221 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1253 +1253 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1348 +1348 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1372 +1372 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1535 +1535 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1610 +1610 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1634 +1634 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
@@ -1701 +1701 @@
-	struct cyclades_port *info = (struct cyclades_port *)tty->driver_data;
+	struct cyclades_port *info = tty->driver_data;
--- ./projects/linux/linux-2.6.14/drivers/char/specialix.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/char/specialix.c	2006-01-03 04:21:10.000000000 +0100
@@ -41,2 +41,2 @@
- * Revision 1.1:  April 14th 1997. 
- *                Incorporated Richard Hudsons suggestions, 
+ * Revision 1.1:  April 14th 1997.
+ *                Incorporated Richard Hudsons suggestions,
@@ -46,2 +46,2 @@
- * Revision 1.3:  April 17th 1997 
- *                Backported to 2.0. (Compatibility macros). 
+ * Revision 1.3:  April 17th 1997
+ *                Backported to 2.0. (Compatibility macros).
@@ -49,2 +49,2 @@
- *                Fixed DTR/RTS bug that caused the card to indicate 
- *                "don't send data" to a modem after the password prompt.  
+ *                Fixed DTR/RTS bug that caused the card to indicate
+ *                "don't send data" to a modem after the password prompt.
@@ -53 +53 @@
- *                fixed a minor typo in the header file, cleanup a little. 
+ *                fixed a minor typo in the header file, cleanup a little.
@@ -63,2 +63,2 @@
- * Revision 1.10: Oct 22  1999 / Jan 21 2000. 
- *                Added stuff for setserial. 
+ * Revision 1.10: Oct 22  1999 / Jan 21 2000.
+ *                Added stuff for setserial.
@@ -66 +66 @@
- * 
+ *
@@ -93 +92,0 @@
-#include <linux/version.h>
@@ -157 +156 @@
-/* 
+/*
@@ -191 +190 @@
-	9600, 19200, 38400, 57600, 115200, 0, 
+	9600, 19200, 38400, 57600, 115200, 0,
@@ -219 +218 @@
- 
+
@@ -234 +233 @@
- * 
+ *
@@ -236 +235 @@
- * 
+ *
@@ -249 +248 @@
-	return SX_PORT(port - sx_port); 
+	return SX_PORT(port - sx_port);
@@ -312 +311 @@
-	
+
@@ -332 +331 @@
-	
+
@@ -341 +340 @@
-static inline int sx_check_io_range(struct specialix_board * bp)
+static inline int sx_request_io_range(struct specialix_board * bp)
@@ -343,9 +342,3 @@
-	return check_region (bp->base, SX_IO_SPACE);
-}
-
-
-static inline void sx_request_io_range(struct specialix_board * bp)
-{
-	request_region(bp->base, 
-	               bp->flags&SX_BOARD_IS_PCI?SX_PCI_IO_SPACE:SX_IO_SPACE,
-	               "specialix IO8+" );
+	return request_region(bp->base,
+		bp->flags & SX_BOARD_IS_PCI ? SX_PCI_IO_SPACE : SX_IO_SPACE,
+		"specialix IO8+") == NULL;
@@ -357 +350 @@
-	release_region(bp->base, 
+	release_region(bp->base,
@@ -361 +354 @@
-	
+
@@ -363 +356 @@
-/* Ugly. Very ugly. Don't use this for anything else than initialization 
+/* Ugly. Very ugly. Don't use this for anything else than initialization
@@ -368 +361 @@
-	
+
@@ -381 +374 @@
-	if (bp->flags & SX_BOARD_IS_PCI) 
+	if (bp->flags & SX_BOARD_IS_PCI)
@@ -423 +416 @@
-	
+
@@ -451 +444 @@
-		if (sx_in_off (bp, reg) & bit) 
+		if (sx_in_off (bp, reg) & bit)
@@ -475 +468 @@
-		sx_interrupt (((struct specialix_board *)data)->irq, 
+		sx_interrupt (((struct specialix_board *)data)->irq,
@@ -498 +491 @@
-	if (sx_check_io_range(bp)) {
+	if (sx_request_io_range(bp)) {
@@ -512 +505 @@
-	
+
@@ -515,0 +509 @@
+		sx_release_io_range(bp);
@@ -520 +514 @@
-	/* Check the DSR lines that Specialix uses as board 
+	/* Check the DSR lines that Specialix uses as board
@@ -534,0 +529 @@
+		sx_release_io_range(bp);
@@ -549 +544 @@
-		sx_long_delay(HZ/20);	       		
+		sx_long_delay(HZ/20);
@@ -564,2 +559,2 @@
-		        val1, val2, val3); 
-	
+		        val1, val2, val3);
+
@@ -567 +562 @@
-	
+
@@ -571,0 +567 @@
+		sx_release_io_range(bp);
@@ -581,0 +578 @@
+		sx_release_io_range(bp);
@@ -583 +580 @@
-		return -EIO;
+		return 1;
@@ -588 +585 @@
-	
+
@@ -594 +591 @@
-	   CD1865 rev A   0x83      1  -- Do not use!!! Does not work. 
+	   CD1865 rev A   0x83      1  -- Do not use!!! Does not work.
@@ -626,2 +623,2 @@
-/* 
- * 
+/*
+ *
@@ -660 +657 @@
-	printk(KERN_INFO "sx%d: %s interrupt from invalid port %d\n", 
+	printk(KERN_INFO "sx%d: %s interrupt from invalid port %d\n",
@@ -684 +681 @@
-	
+
@@ -710 +707 @@
-		printk(KERN_INFO "sx%d: port %d: Receiver timeout. Hardware problems ?\n", 
+		printk(KERN_INFO "sx%d: port %d: Receiver timeout. Hardware problems ?\n",
@@ -714 +711 @@
-		
+
@@ -721,2 +718,2 @@
-		
-	} else if (status & RCSR_PE) 
+
+	} else if (status & RCSR_PE)
@@ -724,2 +721,2 @@
-	
-	else if (status & RCSR_FE) 
+
+	else if (status & RCSR_FE)
@@ -727 +724 @@
-	
+
@@ -730 +727 @@
-	
+
@@ -733 +730 @@
-	
+
@@ -749 +746 @@
-	
+
@@ -756 +753 @@
-	
+
@@ -760 +757 @@
-	
+
@@ -790 +787 @@
-	
+
@@ -799 +796 @@
-	
+
@@ -808 +805 @@
-	
+
@@ -834 +831 @@
-	
+
@@ -842 +839 @@
-	
+
@@ -865 +862 @@
-	
+
@@ -867 +864 @@
-	
+
@@ -882 +879 @@
-	
+
@@ -909 +906 @@
-	
+
@@ -943 +940 @@
-	                                    SRSR_MREQint)))) {	
+	                                    SRSR_MREQint)))) {
@@ -954 +951 @@
-		
+
@@ -966 +963 @@
-			if (ack == (SX_ID | GIVR_IT_MODEM)) 
+			if (ack == (SX_ID | GIVR_IT_MODEM))
@@ -971,2 +968,2 @@
-		
-		} 
+
+		}
@@ -1029 +1026 @@
-	if (bp->flags & SX_BOARD_ACTIVE) 
+	if (bp->flags & SX_BOARD_ACTIVE)
@@ -1037 +1034 @@
-	if (error) 
+	if (error)
@@ -1058 +1055 @@
-	
+
@@ -1071 +1068 @@
- * Setting up port characteristics. 
+ * Setting up port characteristics.
@@ -1106 +1103 @@
-	
+
@@ -1109 +1106 @@
-		if (baud < 1 || baud > 2) 
+		if (baud < 1 || baud > 2)
@@ -1120,2 +1117,2 @@
-	
-	
+
+
@@ -1130 +1127 @@
-		} 
+		}
@@ -1140 +1137 @@
-	
+
@@ -1142 +1139 @@
-	 * Now we must calculate some speed depended things 
+	 * Now we must calculate some speed depended things
@@ -1155 +1152 @@
-	if ((tmp < 0x10) && time_before(again, jiffies)) { 
+	if ((tmp < 0x10) && time_before(again, jiffies)) {
@@ -1167 +1164 @@
-			        "Read specialix.txt for more info.\n", 
+			        "Read specialix.txt for more info.\n",
@@ -1172,3 +1169,3 @@
-	sx_out(bp, CD186x_RBPRH, (tmp >> 8) & 0xff); 
-	sx_out(bp, CD186x_TBPRH, (tmp >> 8) & 0xff); 
-	sx_out(bp, CD186x_RBPRL, tmp & 0xff); 
+	sx_out(bp, CD186x_RBPRH, (tmp >> 8) & 0xff);
+	sx_out(bp, CD186x_TBPRH, (tmp >> 8) & 0xff);
+	sx_out(bp, CD186x_RBPRL, tmp & 0xff);
@@ -1180 +1177 @@
-	} else 
+	} else
@@ -1184 +1181 @@
-	tmp = ((baud + HZ/2) / HZ) * 2 - CD186x_NFIFO;		
+	tmp = ((baud + HZ/2) / HZ) * 2 - CD186x_NFIFO;
@@ -1187 +1184 @@
-	
+
@@ -1208,2 +1205,2 @@
-	
-	if (C_CSTOPB(tty)) 
+
+	if (C_CSTOPB(tty))
@@ -1211 +1208 @@
-	
+
@@ -1215 +1212 @@
-		if (C_PARODD(tty)) 
+		if (C_PARODD(tty))
@@ -1217 +1214 @@
-		if (I_INPCK(tty)) 
+		if (I_INPCK(tty))
@@ -1222 +1219 @@
-	if (I_INPCK(tty)) 
+	if (I_INPCK(tty))
@@ -1224 +1221 @@
-	if (I_BRKINT(tty) || I_PARMRK(tty)) 
+	if (I_BRKINT(tty) || I_PARMRK(tty))
@@ -1226 +1223 @@
-	if (I_IGNPAR(tty)) 
+	if (I_IGNPAR(tty))
@@ -1230 +1227 @@
-		if (I_IGNPAR(tty)) 
+		if (I_IGNPAR(tty))
@@ -1244 +1241 @@
-		port->COR2 |= COR2_CTSAE; 
+		port->COR2 |= COR2_CTSAE;
@@ -1267,2 +1264,2 @@
-	
-	if (C_CREAD(tty)) 
+
+	if (C_CREAD(tty))
@@ -1271 +1268 @@
-	
+
@@ -1314 +1311 @@
-	
+
@@ -1318 +1315 @@
-		
+
@@ -1331 +1328 @@
-		
+
@@ -1334 +1331 @@
-	if (port->tty) 
+	if (port->tty)
@@ -1343 +1340 @@
-		
+
@@ -1355 +1352 @@
-	
+
@@ -1362 +1359 @@
-	
+
@@ -1397,2 +1394,2 @@
-	
-	if (!bp->count) 
+
+	if (!bp->count)
@@ -1403 +1400 @@
-	
+
@@ -1430 +1427 @@
-	
+
@@ -1480 +1477 @@
-				retval = -ERESTARTSYS;	
+				retval = -ERESTARTSYS;
@@ -1509 +1506 @@
-}	
+}
@@ -1529 +1526 @@
-	
+
@@ -1560 +1557 @@
-	
+
@@ -1577 +1574 @@
-	
+
@@ -1590 +1587 @@
-	
+
@@ -1610 +1607 @@
-	 * Now we wait for the transmit buffer to clear; and we notify 
+	 * Now we wait for the transmit buffer to clear; and we notify
@@ -1684 +1681 @@
-static int sx_write(struct tty_struct * tty, 
+static int sx_write(struct tty_struct * tty,
@@ -1697 +1694 @@
-	
+
@@ -1827 +1824 @@
-	
+
@@ -1884 +1881 @@
-		result  = /*   (status & MSVR_RTS) ? */ TIOCM_DTR /* : 0) */ 
+		result  = /*   (status & MSVR_RTS) ? */ TIOCM_DTR /* : 0) */
@@ -1890 +1887 @@
-		result  = /*   (status & MSVR_RTS) ? */ TIOCM_RTS /* : 0) */ 
+		result  = /*   (status & MSVR_RTS) ? */ TIOCM_RTS /* : 0) */
@@ -1958 +1955 @@
-	
+
@@ -1999,2 +1996,2 @@
-	
-#if 0	
+
+#if 0
@@ -2011 +2008 @@
-#endif	
+#endif
@@ -2016 +2013 @@
-	
+
@@ -2048 +2045 @@
-	
+
@@ -2077 +2074 @@
-static int sx_ioctl(struct tty_struct * tty, struct file * filp, 
+static int sx_ioctl(struct tty_struct * tty, struct file * filp,
@@ -2090 +2087 @@
-	
+
@@ -2132 +2129 @@
-	 case TIOCSSERIAL:	
+	 case TIOCSSERIAL:
@@ -2156 +2153 @@
-	
+
@@ -2158 +2155 @@
-	
+
@@ -2160 +2157 @@
-	if (SX_CRTSCTS (tty)) 
+	if (SX_CRTSCTS (tty))
@@ -2165 +2162 @@
-		   handshake anyway, even when hardware handshake is off. 
+		   handshake anyway, even when hardware handshake is off.
@@ -2196 +2193 @@
-				
+
@@ -2201 +2198 @@
-	
+
@@ -2203 +2200 @@
-	
+
@@ -2237 +2234 @@
-	
+
@@ -2244 +2241 @@
-	
+
@@ -2264 +2261 @@
-				
+
@@ -2269 +2266 @@
-	
+
@@ -2271 +2268 @@
-	
+
@@ -2293 +2290 @@
- * 
+ *
@@ -2299 +2296 @@
-	
+
@@ -2322 +2319 @@
-	
+
@@ -2324 +2321 @@
-	
+
@@ -2349 +2346 @@
-				
+
@@ -2352 +2349 @@
-	
+
@@ -2423 +2420 @@
-	
+
@@ -2460 +2457 @@
-	
+
@@ -2475,2 +2472,2 @@
-/* 
- * This routine must be called by kernel at boot time 
+/*
+ * This routine must be called by kernel at boot time
@@ -2492 +2489 @@
-	
+
@@ -2501 +2498 @@
-	for (i = 0; i < SX_NBOARD; i++) 
+	for (i = 0; i < SX_NBOARD; i++)
@@ -2515,2 +2512,2 @@
-			pdev = pci_find_device (PCI_VENDOR_ID_SPECIALIX, 
-			                        PCI_DEVICE_ID_SPECIALIX_IO8, 
+			pdev = pci_find_device (PCI_VENDOR_ID_SPECIALIX,
+			                        PCI_DEVICE_ID_SPECIALIX_IO8,
@@ -2560,2 +2557,2 @@
- * You should specify the IRQs too in that case "irq=....,...". 
- * 
+ * You should specify the IRQs too in that case "irq=....,...".
+ *
@@ -2563 +2560 @@
- * only use 4 different interrupts. 
+ * only use 4 different interrupts.
@@ -2586 +2583 @@
-	
+
@@ -2590 +2587 @@
-	
+
@@ -2595 +2592 @@
-		if (sx_board[i].flags & SX_BOARD_PRESENT) 
+		if (sx_board[i].flags & SX_BOARD_PRESENT)
--- ./projects/linux/linux-2.6.15/drivers/char/specialix.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/specialix.c	2006-03-20 06:53:29.000000000 +0100
@@ -87,0 +88 @@
+#include <linux/tty_flip.h>
@@ -186 +186,0 @@
-static DECLARE_MUTEX(tmp_buf_sem);
@@ -668 +668 @@
-	unsigned char ch;
+	unsigned char ch, flag;
@@ -679,2 +678,0 @@
-	dprintk (SX_DEBUG_RX, "port: %p count: %d BUFF_SIZE: %d\n",
-		 port,  tty->flip.count, TTY_FLIPBUF_SIZE);
@@ -694 +692 @@
-	if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
+	if (tty_buffer_request_room(tty, 1) == 0) {
@@ -715 +713 @@
-		*tty->flip.flag_buf_ptr++ = TTY_BREAK;
+		flag = TTY_BREAK;
@@ -720 +718 @@
-		*tty->flip.flag_buf_ptr++ = TTY_PARITY;
+		flag = TTY_PARITY;
@@ -723 +721 @@
-		*tty->flip.flag_buf_ptr++ = TTY_FRAME;
+		flag = TTY_FRAME;
@@ -726 +724 @@
-		*tty->flip.flag_buf_ptr++ = TTY_OVERRUN;
+		flag = TTY_OVERRUN;
@@ -729,5 +727 @@
-		*tty->flip.flag_buf_ptr++ = 0;
-
-	*tty->flip.char_buf_ptr++ = ch;
-	tty->flip.count++;
-	schedule_delayed_work(&tty->flip.work, 1);
+		flag = TTY_NORMAL;
@@ -734,0 +729,2 @@
+	if(tty_insert_flip_char(tty, ch, flag))
+		tty_flip_buffer_push(tty);
@@ -758,11 +754 @@
-	while (count--) {
-		if (tty->flip.count >= TTY_FLIPBUF_SIZE) {
-			printk(KERN_INFO "sx%d: port %d: Working around flip buffer overflow.\n",
-			       board_No(bp), port_No(port));
-			break;
-		}
-		*tty->flip.char_buf_ptr++ = sx_in(bp, CD186x_RDR);
-		*tty->flip.flag_buf_ptr++ = 0;
-		tty->flip.count++;
-	}
-	schedule_delayed_work(&tty->flip.work, 1);
+	tty_buffer_request_room(tty, count);
@@ -769,0 +756,3 @@
+	while (count--)
+		tty_insert_flip_char(tty, sx_in(bp, CD186x_RDR), TTY_NORMAL);
+	tty_flip_buffer_push(tty);
@@ -2569,2 +2557,0 @@
-	init_MUTEX(&tmp_buf_sem); /* Init de the semaphore - pvdl */
-
--- ./projects/linux/linux-2.6.17/drivers/char/specialix.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/specialix.c	2006-09-20 05:42:06.000000000 +0200
@@ -78 +77,0 @@
-#include <linux/config.h>
@@ -1019 +1018 @@
-		error = request_irq(bp->irq, sx_interrupt, SA_INTERRUPT | SA_SHIRQ, "specialix IO8+", bp);
+		error = request_irq(bp->irq, sx_interrupt, IRQF_DISABLED | IRQF_SHARED, "specialix IO8+", bp);
@@ -1021 +1020 @@
-		error = request_irq(bp->irq, sx_interrupt, SA_INTERRUPT, "specialix IO8+", bp);
+		error = request_irq(bp->irq, sx_interrupt, IRQF_DISABLED, "specialix IO8+", bp);
@@ -1686 +1685 @@
-	if (!tty || !port->xmit_buf || !tmp_buf) {
+	if (!port->xmit_buf || !tmp_buf) {
@@ -1736 +1735 @@
-	if (!tty || !port->xmit_buf) {
+	if (!port->xmit_buf) {
@@ -2480 +2479 @@
-		sx_board[i].lock = SPIN_LOCK_UNLOCKED;
+		spin_lock_init(&sx_board[i].lock);
@@ -2587,0 +2587,6 @@
+static struct pci_device_id specialx_pci_tbl[] __devinitdata = {
+	{ PCI_DEVICE(PCI_VENDOR_ID_SPECIALIX, PCI_DEVICE_ID_SPECIALIX_IO8) },
+	{ }
+};
+MODULE_DEVICE_TABLE(pci, specialx_pci_tbl);
+
--- ./projects/linux/linux-2.6.18/drivers/char/specialix.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/specialix.c	2006-11-29 22:57:37.000000000 +0100
@@ -185,6 +184,0 @@
-static unsigned char * tmp_buf;
-
-static unsigned long baud_table[] =  {
-	0, 50, 75, 110, 134, 150, 200, 300, 600, 1200, 1800, 2400, 4800,
-	9600, 19200, 38400, 57600, 115200, 0,
-};
@@ -204 +198 @@
-static irqreturn_t sx_interrupt(int irq, void * dev_id, struct pt_regs * regs);
+static irqreturn_t sx_interrupt(int irq, void * dev_id);
@@ -901 +895 @@
-static irqreturn_t sx_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t sx_interrupt(int irq, void *dev_id)
@@ -916 +910 @@
-	if (!bp || !(bp->flags & SX_BOARD_ACTIVE)) {
+	if (!(bp->flags & SX_BOARD_ACTIVE)) {
@@ -1090 +1084 @@
-	baud = C_BAUD(tty);
+	baud = tty_get_baud_rate(tty);
@@ -1092,8 +1086 @@
-	if (baud & CBAUDEX) {
-		baud &= ~CBAUDEX;
-		if (baud < 1 || baud > 2)
-			port->tty->termios->c_cflag &= ~CBAUDEX;
-		else
-			baud += 15;
-	}
-	if (baud == 15) {
+	if (baud == 38400) {
@@ -1101 +1088 @@
-			baud ++;
+			baud = 57600;
@@ -1103 +1090 @@
-			baud += 2;
+			baud = 115200;
@@ -1106,2 +1093 @@
-
-	if (!baud_table[baud]) {
+	if (!baud) {
@@ -1137 +1123 @@
-		tmp = (((SX_OSCFREQ + baud_table[baud]/2) / baud_table[baud] +
+		tmp = (((SX_OSCFREQ + baud/2) / baud +
@@ -1162 +1148 @@
-	if (port->custom_divisor) {
+	if (port->custom_divisor)
@@ -1164,3 +1150 @@
-		baud = ( baud + 5 ) / 10;
-	} else
-		baud = (baud_table[baud] + 5) / 10;   /* Estimated CPS */
+	baud = (baud + 5) / 10;		/* Estimated CPS */
@@ -1685 +1669 @@
-	if (!port->xmit_buf || !tmp_buf) {
+	if (!port->xmit_buf) {
@@ -2375 +2359 @@
-static struct tty_operations sx_ops = {
+static const struct tty_operations sx_ops = {
@@ -2409,6 +2392,0 @@
-	if (!(tmp_buf = (unsigned char *) get_zeroed_page(GFP_KERNEL))) {
-		printk(KERN_ERR "sx: Couldn't get free page.\n");
-		put_tty_driver(specialix_driver);
-		func_exit();
-		return 1;
-	}
@@ -2428 +2405,0 @@
-		free_page((unsigned long)tmp_buf);
@@ -2454 +2430,0 @@
-	free_page((unsigned long)tmp_buf);
--- ./projects/linux/linux-2.6.19/drivers/char/specialix.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/specialix.c	2007-02-04 19:44:54.000000000 +0100
@@ -2264 +2264 @@
-static void do_sx_hangup(void *private_)
+static void do_sx_hangup(struct work_struct *work)
@@ -2266 +2266,2 @@
-	struct specialix_port	*port = (struct specialix_port *) private_;
+	struct specialix_port	*port =
+		container_of(work, struct specialix_port, tqueue_hangup);
@@ -2313 +2314 @@
-static void sx_set_termios(struct tty_struct * tty, struct termios * old_termios)
+static void sx_set_termios(struct tty_struct * tty, struct ktermios * old_termios)
@@ -2339 +2340 @@
-static void do_softint(void *private_)
+static void do_softint(struct work_struct *work)
@@ -2341 +2342,2 @@
-	struct specialix_port	*port = (struct specialix_port *) private_;
+	struct specialix_port	*port =
+		container_of(work, struct specialix_port, tqueue);
@@ -2400,0 +2403,2 @@
+	specialix_driver->init_termios.c_ispeed = 9600;
+	specialix_driver->init_termios.c_ospeed = 9600;
@@ -2414,2 +2418,2 @@
-		INIT_WORK(&sx_port[i].tqueue, do_softint, &sx_port[i]);
-		INIT_WORK(&sx_port[i].tqueue_hangup, do_sx_hangup, &sx_port[i]);
+		INIT_WORK(&sx_port[i].tqueue, do_softint);
+		INIT_WORK(&sx_port[i].tqueue_hangup, do_sx_hangup);
@@ -2476 +2480 @@
-			pdev = pci_find_device (PCI_VENDOR_ID_SPECIALIX,
+			pdev = pci_get_device (PCI_VENDOR_ID_SPECIALIX,
@@ -2491,0 +2496,3 @@
+		/* May exit pci_get sequence early with lots of boards */
+		if (pdev != NULL)
+			pci_dev_put(pdev);
--- ./projects/linux/linux-2.6.20/drivers/char/specialix.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/specialix.c	2007-04-26 05:08:32.000000000 +0200
@@ -462 +462 @@
-		              (void*)data, NULL);
+				(void*)data);
@@ -464,2 +464 @@
-	missed_irq_timer.expires = jiffies + sx_poll;
-	add_timer (&missed_irq_timer);
+	mod_timer(&missed_irq_timer, jiffies + sx_poll);
@@ -600,5 +599,2 @@
-	init_timer (&missed_irq_timer);
-	missed_irq_timer.function = missed_irq;
-	missed_irq_timer.data = (unsigned long) bp;
-	missed_irq_timer.expires = jiffies + sx_poll;
-	add_timer (&missed_irq_timer);
+	setup_timer(&missed_irq_timer, missed_irq, (unsigned long)bp);
+	mod_timer(&missed_irq_timer, jiffies + sx_poll);
@@ -2353 +2349 @@
-	if (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &port->event)) {
+	if (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &port->event))
@@ -2355,2 +2350,0 @@
-		//wake_up_interruptible(&tty->write_wait);
-	}
@@ -2564 +2558 @@
-	del_timer (&missed_irq_timer);
+	del_timer_sync(&missed_irq_timer);
--- ./projects/linux/linux-2.6.22/drivers/char/specialix.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/specialix.c	2007-10-09 22:31:38.000000000 +0200
@@ -348,12 +347,0 @@
-/* Must be called with enabled interrupts */
-/* Ugly. Very ugly. Don't use this for anything else than initialization
-   code */
-static inline void sx_long_delay(unsigned long delay)
-{
-	unsigned long i;
-
-	for (i = jiffies + delay; time_after(i, jiffies); ) ;
-}
-
-
-
@@ -400 +388 @@
-	sx_long_delay(HZ/20);                      /* Delay 0.05 sec            */
+	msleep(50);					/* Delay 0.05 sec            */
@@ -536 +524 @@
-		sx_long_delay(HZ/20);
+		msleep(50);
--- ./projects/linux/linux-2.6.24/drivers/char/specialix.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/specialix.c	2008-04-17 04:49:44.000000000 +0200
@@ -181,3 +180,0 @@
-#undef RS_EVENT_WRITE_WAKEUP
-#define RS_EVENT_WRITE_WAKEUP	0
-
@@ -605,11 +601,0 @@
-static inline void sx_mark_event(struct specialix_port * port, int event)
-{
-	func_enter();
-
-	set_bit(event, &port->event);
-	schedule_work(&port->tqueue);
-
-	func_exit();
-}
-
-
@@ -812 +798 @@
-		sx_mark_event(port, RS_EVENT_WRITE_WAKEUP);
+ 		tty_wakeup(tty);
@@ -842 +828 @@
-			schedule_work(&port->tqueue_hangup);
+			tty_hangup(tty);
@@ -852 +838 @@
-				sx_mark_event(port, RS_EVENT_WRITE_WAKEUP);
+				tty_wakeup(tty);
@@ -864 +850 @@
-				sx_mark_event(port, RS_EVENT_WRITE_WAKEUP);
+				tty_wakeup(tty);
@@ -1621 +1606,0 @@
-	port->event = 0;
@@ -2127 +2111,0 @@
-		spin_unlock_irqrestore(&bp->lock, flags);
@@ -2238,26 +2221,0 @@
-
-/*
- * This routine is called from the work-queue when the interrupt
- * routine has signalled that a hangup has occurred.  The path of
- * hangup processing is:
- *
- * 	serial interrupt routine -> (workqueue) ->
- * 	do_sx_hangup() -> tty->hangup() -> sx_hangup()
- *
- */
-static void do_sx_hangup(struct work_struct *work)
-{
-	struct specialix_port	*port =
-		container_of(work, struct specialix_port, tqueue_hangup);
-	struct tty_struct	*tty;
-
-	func_enter();
-
-	tty = port->tty;
-	if (tty)
-		tty_hangup(tty);	/* FIXME: module removal race here */
-
-	func_exit();
-}
-
-
@@ -2281 +2238,0 @@
-	port->event = 0;
@@ -2323,20 +2279,0 @@
-
-static void do_softint(struct work_struct *work)
-{
-	struct specialix_port	*port =
-		container_of(work, struct specialix_port, tqueue);
-	struct tty_struct	*tty;
-
-	func_enter();
-
-	if(!(tty = port->tty)) {
-		func_exit();
-		return;
-	}
-
-	if (test_and_clear_bit(RS_EVENT_WRITE_WAKEUP, &port->event))
- 		tty_wakeup(tty);
-
-	func_exit();
-}
-
@@ -2400,2 +2336,0 @@
-		INIT_WORK(&sx_port[i].tqueue, do_softint);
-		INIT_WORK(&sx_port[i].tqueue_hangup, do_sx_hangup);
--- ./projects/linux/linux-2.6.25/drivers/char/specialix.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/specialix.c	2008-07-13 23:51:29.000000000 +0200
@@ -134,2 +134,2 @@
-#define func_enter() dprintk (SX_DEBUG_FLOW, "io8: enter %s\n",__FUNCTION__)
-#define func_exit()  dprintk (SX_DEBUG_FLOW, "io8: exit  %s\n", __FUNCTION__)
+#define func_enter() dprintk (SX_DEBUG_FLOW, "io8: enter %s\n",__func__)
+#define func_exit()  dprintk (SX_DEBUG_FLOW, "io8: exit  %s\n", __func__)
@@ -446,2 +446 @@
-		sx_interrupt (((struct specialix_board *)data)->irq,
-				(void*)data);
+		sx_interrupt (-1, bp);
@@ -865 +864 @@
-static irqreturn_t sx_interrupt(int irq, void *dev_id)
+static irqreturn_t sx_interrupt(int dummy, void *dev_id)
@@ -869 +868 @@
-	struct specialix_board *bp;
+	struct specialix_board *bp = dev_id;
@@ -876 +874,0 @@
-	bp = dev_id;
@@ -879 +877 @@
-	dprintk (SX_DEBUG_FLOW, "enter %s port %d room: %ld\n", __FUNCTION__, port_No(sx_get_port(bp, "INT")), SERIAL_XMIT_SIZE - sx_get_port(bp, "ITN")->xmit_cnt - 1);
+	dprintk (SX_DEBUG_FLOW, "enter %s port %d room: %ld\n", __func__, port_No(sx_get_port(bp, "INT")), SERIAL_XMIT_SIZE - sx_get_port(bp, "ITN")->xmit_cnt - 1);
@@ -881 +879 @@
-		dprintk (SX_DEBUG_IRQ, "sx: False interrupt. irq %d.\n", irq);
+		dprintk (SX_DEBUG_IRQ, "sx: False interrupt. irq %d.\n", bp->irq);
@@ -1508,0 +1507,21 @@
+static void sx_flush_buffer(struct tty_struct *tty)
+{
+	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	unsigned long flags;
+	struct specialix_board  * bp;
+
+	func_enter();
+
+	if (sx_paranoia_check(port, tty->name, "sx_flush_buffer")) {
+		func_exit();
+		return;
+	}
+
+	bp = port_Board(port);
+	spin_lock_irqsave(&port->lock, flags);
+	port->xmit_cnt = port->xmit_head = port->xmit_tail = 0;
+	spin_unlock_irqrestore(&port->lock, flags);
+	tty_wakeup(tty);
+
+	func_exit();
+}
@@ -1602,2 +1621 @@
-	if (tty->driver->flush_buffer)
-		tty->driver->flush_buffer(tty);
+	sx_flush_buffer(tty);
@@ -1675 +1693 @@
-static void sx_put_char(struct tty_struct * tty, unsigned char ch)
+static int sx_put_char(struct tty_struct * tty, unsigned char ch)
@@ -1685 +1703 @@
-		return;
+		return 0;
@@ -1690 +1708 @@
-		return;
+		return 0;
@@ -1700 +1718 @@
-		return;
+		return 0;
@@ -1708,0 +1727 @@
+	return 1;
@@ -1775,22 +1793,0 @@
-static void sx_flush_buffer(struct tty_struct *tty)
-{
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
-	unsigned long flags;
-	struct specialix_board  * bp;
-
-	func_enter();
-
-	if (sx_paranoia_check(port, tty->name, "sx_flush_buffer")) {
-		func_exit();
-		return;
-	}
-
-	bp = port_Board(port);
-	spin_lock_irqsave(&port->lock, flags);
-	port->xmit_cnt = port->xmit_head = port->xmit_tail = 0;
-	spin_unlock_irqrestore(&port->lock, flags);
-	tty_wakeup(tty);
-
-	func_exit();
-}
-
@@ -1808 +1805 @@
-	if (sx_paranoia_check(port, tty->name, __FUNCTION__)) {
+	if (sx_paranoia_check(port, tty->name, __func__)) {
@@ -1850 +1847 @@
-	if (sx_paranoia_check(port, tty->name, __FUNCTION__)) {
+	if (sx_paranoia_check(port, tty->name, __func__)) {
@@ -1927,6 +1924 @@
-	/*
-	if (!access_ok(VERIFY_READ, (void *) newinfo, sizeof(tmp))) {
-		func_exit();
-		return -EFAULT;
-	}
-	*/
+
@@ -1938,12 +1930 @@
-#if 0
-	if ((tmp.irq != bp->irq) ||
-	    (tmp.port != bp->base) ||
-	    (tmp.type != PORT_CIRRUS) ||
-	    (tmp.baud_base != (SX_OSCFREQ + CD186x_TPC/2) / CD186x_TPC) ||
-	    (tmp.custom_divisor != 0) ||
-	    (tmp.xmit_fifo_size != CD186x_NFIFO) ||
-	    (tmp.flags & ~SPECIALIX_LEGAL_FLAGS)) {
-		func_exit();
-		return -EINVAL;
-	}
-#endif
+	lock_kernel();
@@ -1960,0 +1942 @@
+			unlock_kernel();
@@ -1976,0 +1959 @@
+	unlock_kernel();
@@ -1989,5 +1971,0 @@
-	/*
-	if (!access_ok(VERIFY_WRITE, (void *) retinfo, sizeof(tmp)))
-		return -EFAULT;
-	*/
-
@@ -1994,0 +1973 @@
+	lock_kernel();
@@ -2004,0 +1984 @@
+	unlock_kernel();
@@ -2050,17 +2029,0 @@
-	 case TIOCGSOFTCAR:
-		 if (put_user(C_CLOCAL(tty)?1:0, (unsigned long __user *)argp)) {
-			 func_exit();
-			 return -EFAULT;
-		 }
-		 func_exit();
-		return 0;
-	 case TIOCSSOFTCAR:
-		 if (get_user(arg, (unsigned long __user *) argp)) {
-			 func_exit();
-			 return -EFAULT;
-		 }
-		tty->termios->c_cflag =
-			((tty->termios->c_cflag & ~CLOCAL) |
-			(arg ? CLOCAL : 0));
-		func_exit();
-		return 0;
--- ./projects/linux/linux-2.6.26/drivers/char/specialix.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/char/specialix.c	2008-10-10 00:13:53.000000000 +0200
@@ -80 +80 @@
-#include <asm/io.h>
+#include <linux/io.h>
@@ -95 +95 @@
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
@@ -112,0 +113 @@
+static int sx_rtscts;
@@ -115 +116 @@
-#define dprintk(f, str...) if (sx_debug & f) printk (str)
+#define dprintk(f, str...) if (sx_debug & f) printk(str)
@@ -134,4 +135,2 @@
-#define func_enter() dprintk (SX_DEBUG_FLOW, "io8: enter %s\n",__func__)
-#define func_exit()  dprintk (SX_DEBUG_FLOW, "io8: exit  %s\n", __func__)
-
-#define jiffies_from_ms(a) ((((a) * HZ)/1000)+1)
+#define func_enter() dprintk(SX_DEBUG_FLOW, "io8: enter %s\n", __func__)
+#define func_exit()  dprintk(SX_DEBUG_FLOW, "io8: exit  %s\n", __func__)
@@ -145,11 +143,0 @@
-/* Do I trust the IRQ from the card? (enabeling it doesn't seem to help)
-   When the IRQ routine leaves the chip in a state that is keeps on
-   requiring attention, the timer doesn't help either. */
-#undef SPECIALIX_TIMER
-
-#ifdef SPECIALIX_TIMER
-static int sx_poll = HZ;
-#endif
-
-
-
@@ -165,10 +152,0 @@
-#ifdef CONFIG_SPECIALIX_RTSCTS
-#define SX_CRTSCTS(bla) 1
-#else
-#define SX_CRTSCTS(tty) C_CRTSCTS(tty)
-#endif
-
-
-/* Used to be outb (0xff, 0x80); */
-#define short_pause() udelay (1)
-
@@ -193,8 +171 @@
-#ifdef SPECIALIX_TIMER
-static struct timer_list missed_irq_timer;
-static irqreturn_t sx_interrupt(int irq, void * dev_id);
-#endif
-
-
-
-static inline int sx_paranoia_check(struct specialix_port const * port,
+static int sx_paranoia_check(struct specialix_port const *port,
@@ -204,4 +175,4 @@
-	static const char *badmagic =
-		KERN_ERR "sx: Warning: bad specialix port magic number for device %s in %s\n";
-	static const char *badinfo =
-		KERN_ERR "sx: Warning: null specialix port for device %s in %s\n";
+	static const char *badmagic = KERN_ERR
+	  "sx: Warning: bad specialix port magic number for device %s in %s\n";
+	static const char *badinfo = KERN_ERR
+	  "sx: Warning: null specialix port for device %s in %s\n";
@@ -229 +200 @@
-static inline int board_No (struct specialix_board * bp)
+static inline int board_No(struct specialix_board *bp)
@@ -236 +207 @@
-static inline int port_No (struct specialix_port const * port)
+static inline int port_No(struct specialix_port const *port)
@@ -243 +214,2 @@
-static inline struct specialix_board * port_Board(struct specialix_port const * port)
+static inline struct specialix_board *port_Board(
+					struct specialix_port const *port)
@@ -250 +222,2 @@
-static inline unsigned char sx_in(struct specialix_board  * bp, unsigned short reg)
+static inline unsigned char sx_in(struct specialix_board *bp,
+							unsigned short reg)
@@ -253,2 +226,2 @@
-	outb (reg | 0x80, bp->base + SX_ADDR_REG);
-	return inb  (bp->base + SX_DATA_REG);
+	outb(reg | 0x80, bp->base + SX_ADDR_REG);
+	return inb(bp->base + SX_DATA_REG);
@@ -259 +232 @@
-static inline void sx_out(struct specialix_board  * bp, unsigned short reg,
+static inline void sx_out(struct specialix_board *bp, unsigned short reg,
@@ -263,2 +236,2 @@
-	outb (reg | 0x80, bp->base + SX_ADDR_REG);
-	outb (val, bp->base + SX_DATA_REG);
+	outb(reg | 0x80, bp->base + SX_ADDR_REG);
+	outb(val, bp->base + SX_DATA_REG);
@@ -269 +242,2 @@
-static inline unsigned char sx_in_off(struct specialix_board  * bp, unsigned short reg)
+static inline unsigned char sx_in_off(struct specialix_board *bp,
+				unsigned short reg)
@@ -272,2 +246,2 @@
-	outb (reg, bp->base + SX_ADDR_REG);
-	return inb  (bp->base + SX_DATA_REG);
+	outb(reg, bp->base + SX_ADDR_REG);
+	return inb(bp->base + SX_DATA_REG);
@@ -278,2 +252,2 @@
-static inline void sx_out_off(struct specialix_board  * bp, unsigned short reg,
-			  unsigned char val)
+static inline void sx_out_off(struct specialix_board  *bp,
+				unsigned short reg, unsigned char val)
@@ -282,2 +256,2 @@
-	outb (reg, bp->base + SX_ADDR_REG);
-	outb (val, bp->base + SX_DATA_REG);
+	outb(reg, bp->base + SX_ADDR_REG);
+	outb(val, bp->base + SX_DATA_REG);
@@ -288 +262 @@
-static inline void sx_wait_CCR(struct specialix_board  * bp)
+static void sx_wait_CCR(struct specialix_board  *bp)
@@ -299 +273 @@
-		udelay (1);
+		udelay(1);
@@ -307 +281 @@
-static inline void sx_wait_CCR_off(struct specialix_board  * bp)
+static void sx_wait_CCR_off(struct specialix_board  *bp)
@@ -319 +293 @@
-		udelay (1);
+		udelay(1);
@@ -330 +304 @@
-static inline int sx_request_io_range(struct specialix_board * bp)
+static int sx_request_io_range(struct specialix_board *bp)
@@ -338 +312 @@
-static inline void sx_release_io_range(struct specialix_board * bp)
+static void sx_release_io_range(struct specialix_board *bp)
@@ -340,2 +314,2 @@
-	release_region(bp->base,
-	               bp->flags&SX_BOARD_IS_PCI?SX_PCI_IO_SPACE:SX_IO_SPACE);
+	release_region(bp->base, bp->flags & SX_BOARD_IS_PCI ?
+					SX_PCI_IO_SPACE : SX_IO_SPACE);
@@ -346 +320 @@
-static int sx_set_irq ( struct specialix_board *bp)
+static int sx_set_irq(struct specialix_board *bp)
@@ -356,6 +330,15 @@
-	case 15: virq = 0;break;
-	case 12: virq = 1;break;
-	case 11: virq = 2;break;
-	case 9:  virq = 3;break;
-	default: printk (KERN_ERR "Speclialix: cannot set irq to %d.\n", bp->irq);
-	         return 0;
+	case 15:
+		virq = 0;
+		break;
+	case 12:
+		virq = 1;
+		break;
+	case 11:
+		virq = 2;
+		break;
+	case 9:
+		virq = 3;
+		break;
+	default:printk(KERN_ERR
+			    "Speclialix: cannot set irq to %d.\n", bp->irq);
+		return 0;
@@ -364 +347 @@
-	for (i=0;i<2;i++) {
+	for (i = 0; i < 2; i++) {
@@ -374 +357 @@
-static int sx_init_CD186x(struct specialix_board  * bp)
+static int sx_init_CD186x(struct specialix_board  *bp)
@@ -393 +376 @@
-	sx_out_off(bp, CD186x_SRCR, sx_in (bp, CD186x_SRCR) | SRCR_REGACKEN);
+	sx_out_off(bp, CD186x_SRCR, sx_in(bp, CD186x_SRCR) | SRCR_REGACKEN);
@@ -402 +385 @@
-	if (!sx_set_irq (bp)) {
+	if (!sx_set_irq(bp)) {
@@ -404 +387 @@
-		printk (KERN_ERR "Cannot set irq to %d.\n", bp->irq);
+		printk(KERN_ERR "Cannot set irq to %d.\n", bp->irq);
@@ -413 +396 @@
-static int read_cross_byte (struct specialix_board *bp, int reg, int bit)
+static int read_cross_byte(struct specialix_board *bp, int reg, int bit)
@@ -420,3 +403,3 @@
-	for (i=0, t=0;i<8;i++) {
-		sx_out_off (bp, CD186x_CAR, i);
-		if (sx_in_off (bp, reg) & bit)
+	for (i = 0, t = 0; i < 8; i++) {
+		sx_out_off(bp, CD186x_CAR, i);
+		if (sx_in_off(bp, reg) & bit)
@@ -431,23 +413,0 @@
-#ifdef SPECIALIX_TIMER
-void missed_irq (unsigned long data)
-{
-	unsigned char irq;
-	unsigned long flags;
-	struct specialix_board  *bp = (struct specialix_board *)data;
-
-	spin_lock_irqsave(&bp->lock, flags);
-	irq = sx_in ((struct specialix_board *)data, CD186x_SRSR) &
-	                                            (SRSR_RREQint |
-	                                             SRSR_TREQint |
-	                                             SRSR_MREQint);
-	spin_unlock_irqrestore(&bp->lock, flags);
-	if (irq) {
-		printk (KERN_INFO "Missed interrupt... Calling int from timer. \n");
-		sx_interrupt (-1, bp);
-	}
-	mod_timer(&missed_irq_timer, jiffies + sx_poll);
-}
-#endif
-
-
-
@@ -458,4 +417,0 @@
-#if 0
-	int irqs = 0;
-	int retries;
-#endif
@@ -474 +430 @@
-	short_pause ();
+	udelay(1);
@@ -478 +434 @@
-	short_pause ();
+	udelay(1);
@@ -482,3 +438,4 @@
-	if ((val1 != 0x5a) || (val2 != 0xa5)) {
-		printk(KERN_INFO "sx%d: specialix IO8+ Board at 0x%03x not found.\n",
-		       board_No(bp), bp->base);
+	if (val1 != 0x5a || val2 != 0xa5) {
+		printk(KERN_INFO
+			"sx%d: specialix IO8+ Board at 0x%03x not found.\n",
+						board_No(bp), bp->base);
@@ -492,4 +449,5 @@
-	val1 = read_cross_byte (bp, CD186x_MSVR, MSVR_DSR);
-	val2 = read_cross_byte (bp, CD186x_MSVR, MSVR_RTS);
-	dprintk (SX_DEBUG_INIT, "sx%d: DSR lines are: %02x, rts lines are: %02x\n",
-	        board_No(bp),  val1, val2);
+	val1 = read_cross_byte(bp, CD186x_MSVR, MSVR_DSR);
+	val2 = read_cross_byte(bp, CD186x_MSVR, MSVR_RTS);
+	dprintk(SX_DEBUG_INIT,
+			"sx%d: DSR lines are: %02x, rts lines are: %02x\n",
+					board_No(bp), val1, val2);
@@ -503 +461,2 @@
-		printk(KERN_INFO "sx%d: specialix IO8+ ID %02x at 0x%03x not found (%02x).\n",
+		printk(KERN_INFO
+		  "sx%d: specialix IO8+ ID %02x at 0x%03x not found (%02x).\n",
@@ -511,41 +469,0 @@
-#if 0
-	/* It's time to find IRQ for this board */
-	for (retries = 0; retries < 5 && irqs <= 0; retries++) {
-		irqs = probe_irq_on();
-		sx_init_CD186x(bp);	       		/* Reset CD186x chip       */
-		sx_out(bp, CD186x_CAR, 2);               /* Select port 2          */
-		sx_wait_CCR(bp);
-		sx_out(bp, CD186x_CCR, CCR_TXEN);        /* Enable transmitter     */
-		sx_out(bp, CD186x_IER, IER_TXRDY);       /* Enable tx empty intr   */
-		msleep(50);
-		irqs = probe_irq_off(irqs);
-
-		dprintk (SX_DEBUG_INIT, "SRSR = %02x, ", sx_in(bp, CD186x_SRSR));
-		dprintk (SX_DEBUG_INIT, "TRAR = %02x, ", sx_in(bp, CD186x_TRAR));
-		dprintk (SX_DEBUG_INIT, "GIVR = %02x, ", sx_in(bp, CD186x_GIVR));
-		dprintk (SX_DEBUG_INIT, "GICR = %02x, ", sx_in(bp, CD186x_GICR));
-		dprintk (SX_DEBUG_INIT, "\n");
-
-		/* Reset CD186x again      */
-		if (!sx_init_CD186x(bp)) {
-			/* Hmmm. This is dead code anyway. */
-		}
-
-		dprintk (SX_DEBUG_INIT "val1 = %02x, val2 = %02x, val3 = %02x.\n",
-		        val1, val2, val3);
-
-	}
-
-#if 0
-	if (irqs <= 0) {
-		printk(KERN_ERR "sx%d: Can't find IRQ for specialix IO8+ board at 0x%03x.\n",
-		       board_No(bp), bp->base);
-		sx_release_io_range(bp);
-		func_exit();
-		return 1;
-	}
-#endif
-	printk (KERN_INFO "Started with irq=%d, but now have irq=%d.\n", bp->irq, irqs);
-	if (irqs > 0)
-		bp->irq = irqs;
-#endif
@@ -563 +481 @@
-	                  GFRCR     SRCR bit 7
+			  GFRCR     SRCR bit 7
@@ -573,5 +491,19 @@
-	case 0x82:chip = 1864;rev='A';break;
-	case 0x83:chip = 1865;rev='A';break;
-	case 0x84:chip = 1865;rev='B';break;
-	case 0x85:chip = 1865;rev='C';break; /* Does not exist at this time */
-	default:chip=-1;rev='x';
+	case 0x82:
+		chip = 1864;
+		rev = 'A';
+		break;
+	case 0x83:
+		chip = 1865;
+		rev = 'A';
+		break;
+	case 0x84:
+		chip = 1865;
+		rev = 'B';
+		break;
+	case 0x85:
+		chip = 1865;
+		rev = 'C';
+		break; /* Does not exist at this time */
+	default:
+		chip = -1;
+		rev = 'x';
@@ -580,11 +512,5 @@
-	dprintk (SX_DEBUG_INIT, " GFCR = 0x%02x\n", sx_in_off(bp, CD186x_GFRCR) );
-
-#ifdef SPECIALIX_TIMER
-	setup_timer(&missed_irq_timer, missed_irq, (unsigned long)bp);
-	mod_timer(&missed_irq_timer, jiffies + sx_poll);
-#endif
-
-	printk(KERN_INFO"sx%d: specialix IO8+ board detected at 0x%03x, IRQ %d, CD%d Rev. %c.\n",
-	       board_No(bp),
-	       bp->base, bp->irq,
-	       chip, rev);
+	dprintk(SX_DEBUG_INIT, " GFCR = 0x%02x\n", sx_in_off(bp, CD186x_GFRCR));
+
+	printk(KERN_INFO
+    "sx%d: specialix IO8+ board detected at 0x%03x, IRQ %d, CD%d Rev. %c.\n",
+				board_No(bp), bp->base, bp->irq, chip, rev);
@@ -601,2 +527,2 @@
-static inline struct specialix_port * sx_get_port(struct specialix_board * bp,
-					       unsigned char const * what)
+static struct specialix_port *sx_get_port(struct specialix_board *bp,
+					       unsigned char const *what)
@@ -605 +531 @@
-	struct specialix_port * port = NULL;
+	struct specialix_port *port = NULL;
@@ -608 +534 @@
-	dprintk (SX_DEBUG_CHAN, "channel: %d\n", channel);
+	dprintk(SX_DEBUG_CHAN, "channel: %d\n", channel);
@@ -611 +537,3 @@
-		dprintk (SX_DEBUG_CHAN, "port: %d %p flags: 0x%x\n",board_No(bp) * SX_NPORT + channel,  port, port->flags & ASYNC_INITIALIZED);
+		dprintk(SX_DEBUG_CHAN, "port: %d %p flags: 0x%lx\n",
+			board_No(bp) * SX_NPORT + channel,  port,
+			port->port.flags & ASYNC_INITIALIZED);
@@ -613,2 +541,2 @@
-		if (port->flags & ASYNC_INITIALIZED) {
-			dprintk (SX_DEBUG_CHAN, "port: %d %p\n", channel, port);
+		if (port->port.flags & ASYNC_INITIALIZED) {
+			dprintk(SX_DEBUG_CHAN, "port: %d %p\n", channel, port);
@@ -625 +553 @@
-static inline void sx_receive_exc(struct specialix_board * bp)
+static void sx_receive_exc(struct specialix_board *bp)
@@ -636 +564 @@
-		dprintk (SX_DEBUG_RX, "Hmm, couldn't find port.\n");
+		dprintk(SX_DEBUG_RX, "Hmm, couldn't find port.\n");
@@ -640 +568 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -644 +572 @@
-	dprintk (SX_DEBUG_RX, "status: 0x%x\n", status);
+	dprintk(SX_DEBUG_RX, "status: 0x%x\n", status);
@@ -647,2 +575,3 @@
-		dprintk(SX_DEBUG_FIFO, "sx%d: port %d: Overrun. Total %ld overruns.\n",
-		       board_No(bp), port_No(port), port->overrun);
+		dprintk(SX_DEBUG_FIFO,
+			"sx%d: port %d: Overrun. Total %ld overruns.\n",
+				board_No(bp), port_No(port), port->overrun);
@@ -655,2 +584,3 @@
-		dprintk(SX_DEBUG_FIFO, "sx%d: port %d: Working around flip buffer overflow.\n",
-		       board_No(bp), port_No(port));
+		dprintk(SX_DEBUG_FIFO,
+		    "sx%d: port %d: Working around flip buffer overflow.\n",
+					board_No(bp), port_No(port));
@@ -667,2 +597,3 @@
-		printk(KERN_INFO "sx%d: port %d: Receiver timeout. Hardware problems ?\n",
-		       board_No(bp), port_No(port));
+		printk(KERN_INFO
+		    "sx%d: port %d: Receiver timeout. Hardware problems ?\n",
+					board_No(bp), port_No(port));
@@ -676 +607 @@
-		if (port->flags & ASYNC_SAK)
+		if (port->port.flags & ASYNC_SAK)
@@ -691 +622 @@
-	if(tty_insert_flip_char(tty, ch, flag))
+	if (tty_insert_flip_char(tty, ch, flag))
@@ -697 +628 @@
-static inline void sx_receive(struct specialix_board * bp)
+static void sx_receive(struct specialix_board *bp)
@@ -705,2 +636,3 @@
-	if (!(port = sx_get_port(bp, "Receive"))) {
-		dprintk (SX_DEBUG_RX, "Hmm, couldn't find port.\n");
+	port = sx_get_port(bp, "Receive");
+	if (port == NULL) {
+		dprintk(SX_DEBUG_RX, "Hmm, couldn't find port.\n");
@@ -710 +642 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -713 +645 @@
-	dprintk (SX_DEBUG_RX, "port: %p: count: %d\n", port, count);
+	dprintk(SX_DEBUG_RX, "port: %p: count: %d\n", port, count);
@@ -725 +657 @@
-static inline void sx_transmit(struct specialix_board * bp)
+static void sx_transmit(struct specialix_board *bp)
@@ -732 +664,2 @@
-	if (!(port = sx_get_port(bp, "Transmit"))) {
+	port = sx_get_port(bp, "Transmit");
+	if (port == NULL) {
@@ -736,2 +669,2 @@
-	dprintk (SX_DEBUG_TX, "port: %p\n", port);
-	tty = port->tty;
+	dprintk(SX_DEBUG_TX, "port: %p\n", port);
+	tty = port->port.tty;
@@ -768 +701,2 @@
-			if (!(port->break_length -= count))
+			port->break_length -= count;
+			if (port->break_length == 0)
@@ -797 +731 @@
- 		tty_wakeup(tty);
+		tty_wakeup(tty);
@@ -803 +737 @@
-static inline void sx_check_modem(struct specialix_board * bp)
+static void sx_check_modem(struct specialix_board *bp)
@@ -810,2 +744,3 @@
-	dprintk (SX_DEBUG_SIGNALS, "Modem intr. ");
-	if (!(port = sx_get_port(bp, "Modem")))
+	dprintk(SX_DEBUG_SIGNALS, "Modem intr. ");
+	port = sx_get_port(bp, "Modem");
+	if (port == NULL)
@@ -814 +749 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -817 +751,0 @@
-	printk ("mcr = %02x.\n", mcr);
@@ -820 +754 @@
-		dprintk (SX_DEBUG_SIGNALS, "CD just changed... ");
+		dprintk(SX_DEBUG_SIGNALS, "CD just changed... ");
@@ -823,2 +757,2 @@
-			dprintk (SX_DEBUG_SIGNALS, "Waking up guys in open.\n");
-			wake_up_interruptible(&port->open_wait);
+			dprintk(SX_DEBUG_SIGNALS, "Waking up guys in open.\n");
+			wake_up_interruptible(&port->port.open_wait);
@@ -826 +760 @@
-			dprintk (SX_DEBUG_SIGNALS, "Sending HUP.\n");
+			dprintk(SX_DEBUG_SIGNALS, "Sending HUP.\n");
@@ -877 +811,3 @@
-	dprintk (SX_DEBUG_FLOW, "enter %s port %d room: %ld\n", __func__, port_No(sx_get_port(bp, "INT")), SERIAL_XMIT_SIZE - sx_get_port(bp, "ITN")->xmit_cnt - 1);
+	dprintk(SX_DEBUG_FLOW, "enter %s port %d room: %ld\n", __func__,
+		port_No(sx_get_port(bp, "INT")),
+		SERIAL_XMIT_SIZE - sx_get_port(bp, "ITN")->xmit_cnt - 1);
@@ -879 +815,2 @@
-		dprintk (SX_DEBUG_IRQ, "sx: False interrupt. irq %d.\n", bp->irq);
+		dprintk(SX_DEBUG_IRQ, "sx: False interrupt. irq %d.\n",
+								bp->irq);
@@ -887,4 +824,5 @@
-	while ((++loop < 16) && (status = (sx_in(bp, CD186x_SRSR) &
-	                                   (SRSR_RREQint |
-		                            SRSR_TREQint |
-	                                    SRSR_MREQint)))) {
+	while (++loop < 16) {
+		status = sx_in(bp, CD186x_SRSR) &
+				(SRSR_RREQint | SRSR_TREQint | SRSR_MREQint);
+		if (status == 0)
+			break;
@@ -899,2 +837,3 @@
-				printk(KERN_ERR "sx%d: status: 0x%x Bad receive ack 0x%02x.\n",
-				       board_No(bp), status, ack);
+				printk(KERN_ERR
+				"sx%d: status: 0x%x Bad receive ack 0x%02x.\n",
+						board_No(bp), status, ack);
@@ -909 +848,2 @@
-				       board_No(bp), status, ack, port_No (sx_get_port (bp, "Int")));
+					board_No(bp), status, ack,
+					port_No(sx_get_port(bp, "Int")));
@@ -916 +856,2 @@
-				printk(KERN_ERR "sx%d: status: 0x%x Bad modem ack 0x%02x.\n",
+				printk(KERN_ERR
+				  "sx%d: status: 0x%x Bad modem ack 0x%02x.\n",
@@ -924 +865 @@
-	outb (bp->reg, bp->base + SX_ADDR_REG);
+	outb(bp->reg, bp->base + SX_ADDR_REG);
@@ -935 +876 @@
-static void turn_ints_off (struct specialix_board *bp)
+static void turn_ints_off(struct specialix_board *bp)
@@ -940,7 +880,0 @@
-	if (bp->flags & SX_BOARD_IS_PCI) {
-		/* This was intended for enabeling the interrupt on the
-		 * PCI card. However it seems that it's already enabled
-		 * and as PCI interrupts can be shared, there is no real
-		 * reason to have to turn it off. */
-	}
-
@@ -948 +882 @@
-	(void) sx_in_off (bp, 0); /* Turn off interrupts. */
+	(void) sx_in_off(bp, 0); /* Turn off interrupts. */
@@ -954 +888 @@
-static void turn_ints_on (struct specialix_board *bp)
+static void turn_ints_on(struct specialix_board *bp)
@@ -960,3 +893,0 @@
-	if (bp->flags & SX_BOARD_IS_PCI) {
-		/* play with the PCI chip. See comment above. */
-	}
@@ -964 +895 @@
-	(void) sx_in (bp, 0); /* Turn ON interrupts. */
+	(void) sx_in(bp, 0); /* Turn ON interrupts. */
@@ -972 +903 @@
-static inline int sx_setup_board(struct specialix_board * bp)
+static int sx_setup_board(struct specialix_board *bp)
@@ -980 +911,2 @@
-		error = request_irq(bp->irq, sx_interrupt, IRQF_DISABLED | IRQF_SHARED, "specialix IO8+", bp);
+		error = request_irq(bp->irq, sx_interrupt,
+			IRQF_DISABLED | IRQF_SHARED, "specialix IO8+", bp);
@@ -982 +914,2 @@
-		error = request_irq(bp->irq, sx_interrupt, IRQF_DISABLED, "specialix IO8+", bp);
+		error = request_irq(bp->irq, sx_interrupt,
+			IRQF_DISABLED, "specialix IO8+", bp);
@@ -987 +920 @@
-	turn_ints_on (bp);
+	turn_ints_on(bp);
@@ -995 +928 @@
-static inline void sx_shutdown_board(struct specialix_board *bp)
+static void sx_shutdown_board(struct specialix_board *bp)
@@ -1006,2 +939,2 @@
-	dprintk (SX_DEBUG_IRQ, "Freeing IRQ%d for board %d.\n",
-		 bp->irq, board_No (bp));
+	dprintk(SX_DEBUG_IRQ, "Freeing IRQ%d for board %d.\n",
+		 bp->irq, board_No(bp));
@@ -1009,4 +942 @@
-
-	turn_ints_off (bp);
-
-
+	turn_ints_off(bp);
@@ -1015,0 +946,6 @@
+static unsigned int sx_crtscts(struct tty_struct *tty)
+{
+	if (sx_rtscts)
+		return C_CRTSCTS(tty);
+	return 1;
+}
@@ -1021 +957,2 @@
-static void sx_change_speed(struct specialix_board *bp, struct specialix_port *port)
+static void sx_change_speed(struct specialix_board *bp,
+						struct specialix_port *port)
@@ -1033 +970,2 @@
-	if (!(tty = port->tty) || !tty->termios) {
+	tty = port->port.tty;
+	if (!tty || !tty->termios) {
@@ -1046 +984 @@
-	if (SX_CRTSCTS(tty))
+	if (sx_crtscts(tty))
@@ -1051 +989 @@
-	dprintk (SX_DEBUG_TERMIOS, "sx: got MSVR=%02x.\n", port->MSVR);
+	dprintk(SX_DEBUG_TERMIOS, "sx: got MSVR=%02x.\n", port->MSVR);
@@ -1055 +993 @@
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+		if ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
@@ -1057 +995 @@
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+		if ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
@@ -1063,3 +1001,3 @@
-		dprintk (SX_DEBUG_TERMIOS, "Dropping DTR...  Hmm....\n");
-		if (!SX_CRTSCTS (tty)) {
-			port -> MSVR &= ~ MSVR_DTR;
+		dprintk(SX_DEBUG_TERMIOS, "Dropping DTR...  Hmm....\n");
+		if (!sx_crtscts(tty)) {
+			port->MSVR &= ~MSVR_DTR;
@@ -1067 +1005 @@
-			sx_out(bp, CD186x_MSVR, port->MSVR );
+			sx_out(bp, CD186x_MSVR, port->MSVR);
@@ -1069,3 +1007,2 @@
-		}
-		else
-			dprintk (SX_DEBUG_TERMIOS, "Can't drop DTR: no DTR.\n");
+		} else
+			dprintk(SX_DEBUG_TERMIOS, "Can't drop DTR: no DTR.\n");
@@ -1075,3 +1012,2 @@
-		if (!SX_CRTSCTS (tty)) {
-			port ->MSVR |= MSVR_DTR;
-		}
+		if (!sx_crtscts(tty))
+			port->MSVR |= MSVR_DTR;
@@ -1086,4 +1022,5 @@
-	if ( tmp )
-		printk (KERN_INFO "sx%d: Using custom baud rate divisor %ld. \n"
-		                  "This is an untested option, please be carefull.\n",
-		                  port_No (port), tmp);
+	if (tmp)
+		printk(KERN_INFO
+			"sx%d: Using custom baud rate divisor %ld. \n"
+			"This is an untested option, please be careful.\n",
+							port_No(port), tmp);
@@ -1091,2 +1028,2 @@
-		tmp = (((SX_OSCFREQ + baud/2) / baud +
-		         CD186x_TPC/2) / CD186x_TPC);
+		tmp = (((SX_OSCFREQ + baud/2) / baud + CD186x_TPC/2) /
+								CD186x_TPC);
@@ -1094 +1031 @@
-	if ((tmp < 0x10) && time_before(again, jiffies)) {
+	if (tmp < 0x10 && time_before(again, jiffies)) {
@@ -1098,4 +1035,4 @@
-			printk (KERN_INFO "sx%d: Baud rate divisor is %ld. \n"
-			        "Performance degradation is possible.\n"
-			        "Read specialix.txt for more info.\n",
-			        port_No (port), tmp);
+			printk(KERN_INFO "sx%d: Baud rate divisor is %ld. \n"
+				"Performance degradation is possible.\n"
+				"Read specialix.txt for more info.\n",
+						port_No(port), tmp);
@@ -1103,5 +1040,3 @@
-			printk (KERN_INFO "sx%d: Baud rate divisor is %ld. \n"
-			        "Warning: overstressing Cirrus chip. "
-			        "This might not work.\n"
-			        "Read specialix.txt for more info.\n",
-			        port_No (port), tmp);
+			printk(KERN_INFO "sx%d: Baud rate divisor is %ld. \n"
+		"Warning: overstressing Cirrus chip. This might not work.\n"
+		"Read specialix.txt for more info.\n", port_No(port), tmp);
@@ -1117 +1052,2 @@
-		baud = (SX_OSCFREQ + port->custom_divisor/2) / port->custom_divisor;
+		baud = (SX_OSCFREQ + port->custom_divisor/2) /
+							port->custom_divisor;
@@ -1132 +1068 @@
-	 case CS5:
+	case CS5:
@@ -1135 +1071 @@
-	 case CS6:
+	case CS6:
@@ -1138 +1074 @@
-	 case CS7:
+	case CS7:
@@ -1141 +1077 @@
-	 case CS8:
+	case CS8:
@@ -1178 +1114,2 @@
-		tty->hw_stopped = !(sx_in(bp, CD186x_MSVR) & (MSVR_CTS|MSVR_DSR));
+		tty->hw_stopped = !(sx_in(bp, CD186x_MSVR) &
+							(MSVR_CTS|MSVR_DSR));
@@ -1222 +1159,2 @@
-	dprintk (SX_DEBUG_TERMIOS, "Mcor1 = %02x, mcor2 = %02x.\n", mcor1, mcor2);
+	dprintk(SX_DEBUG_TERMIOS, "Mcor1 = %02x, mcor2 = %02x.\n",
+								mcor1, mcor2);
@@ -1241 +1179,2 @@
-static int sx_setup_port(struct specialix_board *bp, struct specialix_port *port)
+static int sx_setup_port(struct specialix_board *bp,
+						struct specialix_port *port)
@@ -1247 +1186 @@
-	if (port->flags & ASYNC_INITIALIZED) {
+	if (port->port.flags & ASYNC_INITIALIZED) {
@@ -1256 +1195,2 @@
-		if (!(tmp = get_zeroed_page(GFP_KERNEL))) {
+		tmp = get_zeroed_page(GFP_KERNEL);
+		if (tmp == 0L) {
@@ -1271,2 +1211,2 @@
-	if (port->tty)
-		clear_bit(TTY_IO_ERROR, &port->tty->flags);
+	if (port->port.tty)
+		clear_bit(TTY_IO_ERROR, &port->port.tty->flags);
@@ -1276 +1216 @@
-	port->flags |= ASYNC_INITIALIZED;
+	port->port.flags |= ASYNC_INITIALIZED;
@@ -1287 +1227,2 @@
-static void sx_shutdown_port(struct specialix_board *bp, struct specialix_port *port)
+static void sx_shutdown_port(struct specialix_board *bp,
+						struct specialix_port *port)
@@ -1295 +1236 @@
-	if (!(port->flags & ASYNC_INITIALIZED)) {
+	if (!(port->port.flags & ASYNC_INITIALIZED)) {
@@ -1301,3 +1242,4 @@
-		dprintk(SX_DEBUG_FIFO, "sx%d: port %d: %ld overruns, FIFO hits [ ",
-			board_No(bp), port_No(port), port->overrun);
-		for (i = 0; i < 10; i++) {
+		dprintk(SX_DEBUG_FIFO,
+			"sx%d: port %d: %ld overruns, FIFO hits [ ",
+				board_No(bp), port_No(port), port->overrun);
+		for (i = 0; i < 10; i++)
@@ -1305 +1246,0 @@
-		}
@@ -1318 +1259,2 @@
-	if (!(tty = port->tty) || C_HUPCL(tty)) {
+	tty = port->port.tty;
+	if (tty == NULL || C_HUPCL(tty)) {
@@ -1333 +1275 @@
-	port->flags &= ~ASYNC_INITIALIZED;
+	port->port.flags &= ~ASYNC_INITIALIZED;
@@ -1341,2 +1283,2 @@
-static int block_til_ready(struct tty_struct *tty, struct file * filp,
-                           struct specialix_port *port)
+static int block_til_ready(struct tty_struct *tty, struct file *filp,
+						struct specialix_port *port)
@@ -1357,3 +1299,3 @@
-	if (tty_hung_up_p(filp) || port->flags & ASYNC_CLOSING) {
-		interruptible_sleep_on(&port->close_wait);
-		if (port->flags & ASYNC_HUP_NOTIFY) {
+	if (tty_hung_up_p(filp) || port->port.flags & ASYNC_CLOSING) {
+		interruptible_sleep_on(&port->port.close_wait);
+		if (port->port.flags & ASYNC_HUP_NOTIFY) {
@@ -1374 +1316 @@
-		port->flags |= ASYNC_NORMAL_ACTIVE;
+		port->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -1390 +1332 @@
-	add_wait_queue(&port->open_wait, &wait);
+	add_wait_queue(&port->port.open_wait, &wait);
@@ -1392,3 +1334,2 @@
-	if (!tty_hung_up_p(filp)) {
-		port->count--;
-	}
+	if (!tty_hung_up_p(filp))
+		port->port.count--;
@@ -1396 +1337 @@
-	port->blocked_open++;
+	port->port.blocked_open++;
@@ -1401 +1342 @@
-		if (SX_CRTSCTS (tty)) {
+		if (sx_crtscts(tty)) {
@@ -1404 +1345 @@
-			sx_out (bp, CD186x_MSVR, port->MSVR);
+			sx_out(bp, CD186x_MSVR, port->MSVR);
@@ -1408 +1349 @@
-			sx_out (bp, CD186x_MSVR, port->MSVR);
+			sx_out(bp, CD186x_MSVR, port->MSVR);
@@ -1413,2 +1354,2 @@
-		    !(port->flags & ASYNC_INITIALIZED)) {
-			if (port->flags & ASYNC_HUP_NOTIFY)
+		    !(port->port.flags & ASYNC_INITIALIZED)) {
+			if (port->port.flags & ASYNC_HUP_NOTIFY)
@@ -1420 +1361 @@
-		if (!(port->flags & ASYNC_CLOSING) &&
+		if (!(port->port.flags & ASYNC_CLOSING) &&
@@ -1431 +1372 @@
-	remove_wait_queue(&port->open_wait, &wait);
+	remove_wait_queue(&port->port.open_wait, &wait);
@@ -1433,4 +1374,3 @@
-	if (!tty_hung_up_p(filp)) {
-		port->count++;
-	}
-	port->blocked_open--;
+	if (!tty_hung_up_p(filp))
+		port->port.count++;
+	port->port.blocked_open--;
@@ -1443 +1383 @@
-	port->flags |= ASYNC_NORMAL_ACTIVE;
+	port->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -1449 +1389 @@
-static int sx_open(struct tty_struct * tty, struct file * filp)
+static int sx_open(struct tty_struct *tty, struct file *filp)
@@ -1453,2 +1393,2 @@
-	struct specialix_port * port;
-	struct specialix_board * bp;
+	struct specialix_port *port;
+	struct specialix_board *bp;
@@ -1471 +1411 @@
-		port->hits[i]=0;
+		port->hits[i] = 0;
@@ -1473,2 +1413,3 @@
-	dprintk (SX_DEBUG_OPEN, "Board = %d, bp = %p, port = %p, portno = %d.\n",
-	        board, bp, port, SX_PORT(tty->index));
+	dprintk(SX_DEBUG_OPEN,
+			"Board = %d, bp = %p, port = %p, portno = %d.\n",
+				 board, bp, port, SX_PORT(tty->index));
@@ -1481 +1422,2 @@
-	if ((error = sx_setup_board(bp))) {
+	error = sx_setup_board(bp);
+	if (error) {
@@ -1487 +1429 @@
-	port->count++;
+	port->port.count++;
@@ -1490 +1432 @@
-	port->tty = tty;
+	port->port.tty = tty;
@@ -1493 +1435,2 @@
-	if ((error = sx_setup_port(bp, port))) {
+	error = sx_setup_port(bp, port);
+	if (error) {
@@ -1498 +1441,2 @@
-	if ((error = block_til_ready(tty, filp, port))) {
+	error = block_til_ready(tty, filp, port);
+	if (error) {
@@ -1511 +1455 @@
-	struct specialix_board  * bp;
+	struct specialix_board  *bp;
@@ -1529 +1473 @@
-static void sx_close(struct tty_struct * tty, struct file * filp)
+static void sx_close(struct tty_struct *tty, struct file *filp)
@@ -1531 +1475 @@
-	struct specialix_port *port = (struct specialix_port *) tty->driver_data;
+	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
@@ -1550 +1494 @@
-	if ((tty->count == 1) && (port->count != 1)) {
+	if (tty->count == 1 && port->port.count != 1) {
@@ -1553,2 +1497,2 @@
-		       board_No(bp), port->count);
-		port->count = 1;
+		       board_No(bp), port->port.count);
+		port->port.count = 1;
@@ -1557,2 +1501,2 @@
-	if (port->count > 1) {
-		port->count--;
+	if (port->port.count > 1) {
+		port->port.count--;
@@ -1566 +1510 @@
-	port->flags |= ASYNC_CLOSING;
+	port->port.flags |= ASYNC_CLOSING;
@@ -1573,4 +1517,3 @@
-	dprintk (SX_DEBUG_OPEN, "Closing\n");
-	if (port->closing_wait != ASYNC_CLOSING_WAIT_NONE) {
-		tty_wait_until_sent(tty, port->closing_wait);
-	}
+	dprintk(SX_DEBUG_OPEN, "Closing\n");
+	if (port->port.closing_wait != ASYNC_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, port->port.closing_wait);
@@ -1583 +1526 @@
-	dprintk (SX_DEBUG_OPEN, "Closed\n");
+	dprintk(SX_DEBUG_OPEN, "Closed\n");
@@ -1585 +1528 @@
-	if (port->flags & ASYNC_INITIALIZED) {
+	if (port->port.flags & ASYNC_INITIALIZED) {
@@ -1598,2 +1541,2 @@
-		while(port->IER & IER_TXEMPTY) {
-			set_current_state (TASK_INTERRUPTIBLE);
+		while (port->IER & IER_TXEMPTY) {
+			set_current_state(TASK_INTERRUPTIBLE);
@@ -1602 +1545 @@
-				printk (KERN_INFO "Timeout waiting for close\n");
+				printk(KERN_INFO "Timeout waiting for close\n");
@@ -1610,2 +1553,3 @@
-		printk(KERN_ERR "sx%d: sx_shutdown_port: bad board count: %d port: %d\n",
-		       board_No(bp), bp->count, tty->index);
+		printk(KERN_ERR
+		    "sx%d: sx_shutdown_port: bad board count: %d port: %d\n",
+				board_No(bp), bp->count, tty->index);
@@ -1614,4 +1558,5 @@
-	if (--port->count < 0) {
-		printk(KERN_ERR "sx%d: sx_close: bad port count for tty%d: %d\n",
-		       board_No(bp), port_No(port), port->count);
-		port->count = 0;
+	if (--port->port.count < 0) {
+		printk(KERN_ERR
+			"sx%d: sx_close: bad port count for tty%d: %d\n",
+				board_No(bp), port_No(port), port->port.count);
+		port->port.count = 0;
@@ -1625 +1570 @@
-	port->tty = NULL;
+	port->port.tty = NULL;
@@ -1627,5 +1572,5 @@
-	if (port->blocked_open) {
-		if (port->close_delay) {
-			msleep_interruptible(jiffies_to_msecs(port->close_delay));
-		}
-		wake_up_interruptible(&port->open_wait);
+	if (port->port.blocked_open) {
+		if (port->port.close_delay)
+			msleep_interruptible(
+				jiffies_to_msecs(port->port.close_delay));
+		wake_up_interruptible(&port->port.open_wait);
@@ -1633,2 +1578,2 @@
-	port->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-	wake_up_interruptible(&port->close_wait);
+	port->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
+	wake_up_interruptible(&port->port.close_wait);
@@ -1640,2 +1585,2 @@
-static int sx_write(struct tty_struct * tty,
-                    const unsigned char *buf, int count)
+static int sx_write(struct tty_struct *tty,
+					const unsigned char *buf, int count)
@@ -1693 +1638 @@
-static int sx_put_char(struct tty_struct * tty, unsigned char ch)
+static int sx_put_char(struct tty_struct *tty, unsigned char ch)
@@ -1697 +1642 @@
-	struct specialix_board  * bp;
+	struct specialix_board  *bp;
@@ -1705 +1650 @@
-	dprintk (SX_DEBUG_TX, "check tty: %p %p\n", tty, port->xmit_buf);
+	dprintk(SX_DEBUG_TX, "check tty: %p %p\n", tty, port->xmit_buf);
@@ -1713,2 +1658,3 @@
-	dprintk (SX_DEBUG_TX, "xmit_cnt: %d xmit_buf: %p\n", port->xmit_cnt, port->xmit_buf);
-	if ((port->xmit_cnt >= SERIAL_XMIT_SIZE - 1) || (!port->xmit_buf)) {
+	dprintk(SX_DEBUG_TX, "xmit_cnt: %d xmit_buf: %p\n",
+					port->xmit_cnt, port->xmit_buf);
+	if (port->xmit_cnt >= SERIAL_XMIT_SIZE - 1 || !port->xmit_buf) {
@@ -1716 +1662 @@
-		dprintk (SX_DEBUG_TX, "Exit size\n");
+		dprintk(SX_DEBUG_TX, "Exit size\n");
@@ -1720 +1666 @@
-	dprintk (SX_DEBUG_TX, "Handle xmit: %p %p\n", port, port->xmit_buf);
+	dprintk(SX_DEBUG_TX, "Handle xmit: %p %p\n", port, port->xmit_buf);
@@ -1731 +1677 @@
-static void sx_flush_chars(struct tty_struct * tty)
+static void sx_flush_chars(struct tty_struct *tty)
@@ -1735 +1681 @@
-	struct specialix_board  * bp = port_Board(port);
+	struct specialix_board  *bp = port_Board(port);
@@ -1758 +1704 @@
-static int sx_write_room(struct tty_struct * tty)
+static int sx_write_room(struct tty_struct *tty)
@@ -1793,2 +1738,0 @@
-
-
@@ -1798 +1742 @@
-	struct specialix_board * bp;
+	struct specialix_board *bp;
@@ -1811 +1755 @@
-	spin_lock_irqsave (&bp->lock, flags);
+	spin_lock_irqsave(&bp->lock, flags);
@@ -1815,9 +1759,8 @@
-	dprintk (SX_DEBUG_INIT, "Got msvr[%d] = %02x, car = %d.\n",
-		port_No(port), status, sx_in (bp, CD186x_CAR));
-	dprintk (SX_DEBUG_INIT, "sx_port = %p, port = %p\n", sx_port, port);
-	if (SX_CRTSCTS(port->tty)) {
-		result  = /*   (status & MSVR_RTS) ? */ TIOCM_DTR /* : 0) */
-		          |   ((status & MSVR_DTR) ? TIOCM_RTS : 0)
-		          |   ((status & MSVR_CD)  ? TIOCM_CAR : 0)
-		          |/* ((status & MSVR_DSR) ? */ TIOCM_DSR /* : 0) */
-		          |   ((status & MSVR_CTS) ? TIOCM_CTS : 0);
+	dprintk(SX_DEBUG_INIT, "Got msvr[%d] = %02x, car = %d.\n",
+			port_No(port), status, sx_in(bp, CD186x_CAR));
+	dprintk(SX_DEBUG_INIT, "sx_port = %p, port = %p\n", sx_port, port);
+	if (sx_crtscts(port->port.tty)) {
+		result  = TIOCM_DTR | TIOCM_DSR
+			  |   ((status & MSVR_DTR) ? TIOCM_RTS : 0)
+			  |   ((status & MSVR_CD)  ? TIOCM_CAR : 0)
+			  |   ((status & MSVR_CTS) ? TIOCM_CTS : 0);
@@ -1825,5 +1768,4 @@
-		result  = /*   (status & MSVR_RTS) ? */ TIOCM_RTS /* : 0) */
-		          |   ((status & MSVR_DTR) ? TIOCM_DTR : 0)
-		          |   ((status & MSVR_CD)  ? TIOCM_CAR : 0)
-		          |/* ((status & MSVR_DSR) ? */ TIOCM_DSR /* : 0) */
-		          |   ((status & MSVR_CTS) ? TIOCM_CTS : 0);
+		result  = TIOCM_RTS | TIOCM_DSR
+			  |   ((status & MSVR_DTR) ? TIOCM_DTR : 0)
+			  |   ((status & MSVR_CD)  ? TIOCM_CAR : 0)
+			  |   ((status & MSVR_CTS) ? TIOCM_CTS : 0);
@@ -1855,6 +1797 @@
-   /*	if (set & TIOCM_RTS)
-		port->MSVR |= MSVR_RTS; */
-   /*   if (set & TIOCM_DTR)
-		port->MSVR |= MSVR_DTR; */
-
-	if (SX_CRTSCTS(port->tty)) {
+	if (sx_crtscts(port->port.tty)) {
@@ -1867,6 +1804 @@
-
-  /*	if (clear & TIOCM_RTS)
-		port->MSVR &= ~MSVR_RTS; */
-  /*    if (clear & TIOCM_DTR)
-		port->MSVR &= ~MSVR_DTR; */
-	if (SX_CRTSCTS(port->tty)) {
+	if (sx_crtscts(port->port.tty)) {
@@ -1889 +1821 @@
-static inline void sx_send_break(struct specialix_port * port, unsigned long length)
+static int sx_send_break(struct tty_struct *tty, int length)
@@ -1890,0 +1823 @@
+	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
@@ -1894,0 +1828,2 @@
+	if (length == 0 || length == -1)
+		return -EOPNOTSUPP;
@@ -1896 +1831 @@
-	spin_lock_irqsave (&port->lock, flags);
+	spin_lock_irqsave(&port->lock, flags);
@@ -1905 +1840 @@
-	spin_unlock_irqrestore (&port->lock, flags);
+	spin_unlock_irqrestore(&port->lock, flags);
@@ -1912,0 +1848 @@
+	return 0;
@@ -1916,2 +1852,2 @@
-static inline int sx_set_serial_info(struct specialix_port * port,
-                                     struct serial_struct __user * newinfo)
+static int sx_set_serial_info(struct specialix_port *port,
+					struct serial_struct __user *newinfo)
@@ -1932 +1868 @@
-	change_speed = ((port->flags & ASYNC_SPD_MASK) !=
+	change_speed = ((port->port.flags & ASYNC_SPD_MASK) !=
@@ -1937,2 +1873,2 @@
-		if ((tmp.close_delay != port->close_delay) ||
-		    (tmp.closing_wait != port->closing_wait) ||
+		if ((tmp.close_delay != port->port.close_delay) ||
+		    (tmp.closing_wait != port->port.closing_wait) ||
@@ -1940 +1876 @@
-		     (port->flags & ~ASYNC_USR_MASK))) {
+		     (port->port.flags & ~ASYNC_USR_MASK))) {
@@ -1945,2 +1881,2 @@
-		port->flags = ((port->flags & ~ASYNC_USR_MASK) |
-		                  (tmp.flags & ASYNC_USR_MASK));
+		port->port.flags = ((port->port.flags & ~ASYNC_USR_MASK) |
+						(tmp.flags & ASYNC_USR_MASK));
@@ -1949,4 +1885,4 @@
-		port->flags = ((port->flags & ~ASYNC_FLAGS) |
-		                  (tmp.flags & ASYNC_FLAGS));
-		port->close_delay = tmp.close_delay;
-		port->closing_wait = tmp.closing_wait;
+		port->port.flags = ((port->port.flags & ~ASYNC_FLAGS) |
+						(tmp.flags & ASYNC_FLAGS));
+		port->port.close_delay = tmp.close_delay;
+		port->port.closing_wait = tmp.closing_wait;
@@ -1955 +1891 @@
-	if (change_speed) {
+	if (change_speed)
@@ -1957 +1893 @@
-	}
+
@@ -1964 +1900 @@
-static inline int sx_get_serial_info(struct specialix_port * port,
+static int sx_get_serial_info(struct specialix_port *port,
@@ -1978 +1914 @@
-	tmp.flags = port->flags;
+	tmp.flags = port->port.flags;
@@ -1980,2 +1916,2 @@
-	tmp.close_delay = port->close_delay * HZ/100;
-	tmp.closing_wait = port->closing_wait * HZ/100;
+	tmp.close_delay = port->port.close_delay * HZ/100;
+	tmp.closing_wait = port->port.closing_wait * HZ/100;
@@ -1995,2 +1931,2 @@
-static int sx_ioctl(struct tty_struct * tty, struct file * filp,
-                    unsigned int cmd, unsigned long arg)
+static int sx_ioctl(struct tty_struct *tty, struct file *filp,
+				unsigned int cmd, unsigned long arg)
@@ -1999 +1934,0 @@
-	int retval;
@@ -2010,18 +1945 @@
-	 case TCSBRK:	/* SVID version: non-zero arg --> no break */
-		retval = tty_check_change(tty);
-		if (retval) {
-			func_exit();
-			return retval;
-		}
-		tty_wait_until_sent(tty, 0);
-		if (!arg)
-			sx_send_break(port, HZ/4);	/* 1/4 second */
-		return 0;
-	 case TCSBRKP:	/* support for POSIX tcsendbreak() */
-		retval = tty_check_change(tty);
-		if (retval) {
-			func_exit();
-			return retval;
-		}
-		tty_wait_until_sent(tty, 0);
-		sx_send_break(port, arg ? arg*(HZ/10) : HZ/4);
+	case TIOCGSERIAL:
@@ -2029,3 +1946,0 @@
-		return 0;
-	 case TIOCGSERIAL:
-		 func_exit();
@@ -2033,2 +1948,2 @@
-	 case TIOCSSERIAL:
-		 func_exit();
+	case TIOCSSERIAL:
+		func_exit();
@@ -2036,2 +1951,2 @@
-	 default:
-		 func_exit();
+	default:
+		func_exit();
@@ -2045 +1960 @@
-static void sx_throttle(struct tty_struct * tty)
+static void sx_throttle(struct tty_struct *tty)
@@ -2061 +1976 @@
-	if (SX_CRTSCTS (tty))
+	if (sx_crtscts(tty))
@@ -2068,2 +1983,3 @@
-		printk (KERN_ERR "sx%d: Need to throttle, but can't (hardware hs is off)\n",
-	                 port_No (port));
+		printk(KERN_ERR
+		   "sx%d: Need to throttle, but can't (hardware hs is off)\n",
+							port_No(port));
@@ -2089 +2005 @@
-static void sx_unthrottle(struct tty_struct * tty)
+static void sx_unthrottle(struct tty_struct *tty)
@@ -2106 +2022 @@
-	if (SX_CRTSCTS(tty)) {
+	if (sx_crtscts(tty))
@@ -2108 +2024 @@
-	} /* Else clause: see remark in "sx_throttle"... */
+	/* Else clause: see remark in "sx_throttle"... */
@@ -2130 +2046 @@
-static void sx_stop(struct tty_struct * tty)
+static void sx_stop(struct tty_struct *tty)
@@ -2157 +2073 @@
-static void sx_start(struct tty_struct * tty)
+static void sx_start(struct tty_struct *tty)
@@ -2185 +2101 @@
-static void sx_hangup(struct tty_struct * tty)
+static void sx_hangup(struct tty_struct *tty)
@@ -2202 +2118 @@
-	bp->count -= port->count;
+	bp->count -= port->port.count;
@@ -2204,2 +2120,3 @@
-		printk(KERN_ERR "sx%d: sx_hangup: bad board count: %d port: %d\n",
-			board_No(bp), bp->count, tty->index);
+		printk(KERN_ERR
+			"sx%d: sx_hangup: bad board count: %d port: %d\n",
+					board_No(bp), bp->count, tty->index);
@@ -2208,3 +2125,3 @@
-	port->count = 0;
-	port->flags &= ~ASYNC_NORMAL_ACTIVE;
-	port->tty = NULL;
+	port->port.count = 0;
+	port->port.flags &= ~ASYNC_NORMAL_ACTIVE;
+	port->port.tty = NULL;
@@ -2212 +2129 @@
-	wake_up_interruptible(&port->open_wait);
+	wake_up_interruptible(&port->port.open_wait);
@@ -2218 +2135,2 @@
-static void sx_set_termios(struct tty_struct * tty, struct ktermios * old_termios)
+static void sx_set_termios(struct tty_struct *tty,
+					struct ktermios *old_termios)
@@ -2222 +2140 @@
-	struct specialix_board  * bp;
+	struct specialix_board  *bp;
@@ -2227,4 +2144,0 @@
-	if (tty->termios->c_cflag == old_termios->c_cflag &&
-	    tty->termios->c_iflag == old_termios->c_iflag)
-		return;
-
@@ -2260,0 +2175 @@
+	.break_ctl = sx_send_break,
@@ -2287 +2202,2 @@
-	specialix_driver->flags = TTY_DRIVER_REAL_RAW;
+	specialix_driver->flags = TTY_DRIVER_REAL_RAW |
+						TTY_DRIVER_HARDWARE_BREAK;
@@ -2290 +2206,2 @@
-	if ((error = tty_register_driver(specialix_driver))) {
+	error = tty_register_driver(specialix_driver);
+	if (error) {
@@ -2292,2 +2209,3 @@
-		printk(KERN_ERR "sx: Couldn't register specialix IO8+ driver, error = %d\n",
-		       error);
+		printk(KERN_ERR
+		  "sx: Couldn't register specialix IO8+ driver, error = %d\n",
+								error);
@@ -2300,4 +2218 @@
-		sx_port[i].close_delay = 50 * HZ/100;
-		sx_port[i].closing_wait = 3000 * HZ/100;
-		init_waitqueue_head(&sx_port[i].open_wait);
-		init_waitqueue_head(&sx_port[i].close_wait);
+		tty_port_init(&sx_port[i].port);
@@ -2332,5 +2247,5 @@
-#ifdef CONFIG_SPECIALIX_RTSCTS
-	printk (KERN_INFO "sx: DTR/RTS pin is always RTS.\n");
-#else
-	printk (KERN_INFO "sx: DTR/RTS pin is RTS when CRTSCTS is on.\n");
-#endif
+	if (sx_rtscts)
+		printk(KERN_INFO
+			"sx: DTR/RTS pin is RTS when CRTSCTS is on.\n");
+	else
+		printk(KERN_INFO "sx: DTR/RTS pin is always RTS.\n");
@@ -2354 +2269 @@
-		i=0;
+		i = 0;
@@ -2360,4 +2275,4 @@
-			pdev = pci_get_device (PCI_VENDOR_ID_SPECIALIX,
-			                        PCI_DEVICE_ID_SPECIALIX_IO8,
-			                        pdev);
-			if (!pdev) break;
+			pdev = pci_get_device(PCI_VENDOR_ID_SPECIALIX,
+					PCI_DEVICE_ID_SPECIALIX_IO8, pdev);
+			if (!pdev)
+				break;
@@ -2370 +2285 @@
-			sx_board[i].base = pci_resource_start (pdev, 2);
+			sx_board[i].base = pci_resource_start(pdev, 2);
@@ -2374 +2289 @@
-				found ++;
+				found++;
@@ -2394,2 +2309 @@
-
-static int irq [SX_NBOARD] = {0,};
+static int irq[SX_NBOARD] = {0,};
@@ -2399,0 +2314 @@
+module_param(sx_rtscts, int, 0);
@@ -2401,3 +2315,0 @@
-#ifdef SPECIALIX_TIMER
-module_param(sx_poll, int, 0);
-#endif
@@ -2421 +2333 @@
-		for(i = 0; i < SX_NBOARD; i++) {
+		for (i = 0; i < SX_NBOARD; i++) {
@@ -2424 +2336 @@
-			sx_board[i].count= 0;
+			sx_board[i].count = 0;
@@ -2443,4 +2354,0 @@
-#ifdef SPECIALIX_TIMER
-	del_timer_sync(&missed_irq_timer);
-#endif
-
--- ./projects/linux/linux-2.6.27/drivers/char/specialix.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/char/specialix.c	2008-12-25 00:26:37.000000000 +0100
@@ -75 +75 @@
- * Documentation/specialix.txt
+ * Documentation/serial/specialix.txt
--- ./projects/linux/linux-2.6.28/drivers/char/specialix.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/char/specialix.c	2009-03-24 00:12:14.000000000 +0100
@@ -1453 +1453 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -1475 +1475 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -1588 +1588 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -1640 +1640 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -1679 +1679 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -1706 +1706 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -1727 +1727 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -1741 +1741 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -1783 +1783 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -1823 +1823 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -1934 +1934 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -1962 +1962 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -2007 +2007 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -2048 +2048 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -2075 +2075 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -2103 +2103 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
@@ -2138 +2138 @@
-	struct specialix_port *port = (struct specialix_port *)tty->driver_data;
+	struct specialix_port *port = tty->driver_data;
--- ./projects/linux/linux-2.6.29/drivers/char/specialix.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/char/specialix.c	2009-06-27 11:32:32.000000000 +0200
@@ -2367,0 +2368 @@
+MODULE_ALIAS_CHARDEV_MAJOR(SPECIALIX_NORMAL_MAJOR);
--- ./projects/linux/linux-2.6.13/drivers/char/synclink.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/char/synclink.c	2005-10-28 02:02:08.000000000 +0200
@@ -4 +4 @@
- * $Id: synclink.c,v 4.28 2004/08/11 19:30:01 paulkf Exp $
+ * $Id: synclink.c,v 4.37 2005/09/07 13:13:19 paulkf Exp $
@@ -144,3 +144,3 @@
-	u16 count;	/* buffer size/data count */
-	u16 status;	/* Control/status field */
-	u16 rcc;	/* character count field */
+	volatile u16 count;	/* buffer size/data count */
+	volatile u16 status;	/* Control/status field */
+	volatile u16 rcc;	/* character count field */
@@ -899 +899 @@
-static char *driver_version = "$Revision: 4.28 $";
+static char *driver_version = "$Revision: 4.37 $";
@@ -1816,0 +1817,2 @@
+	memset(&info->icount, 0, sizeof(info->icount));
+
@@ -2473,6 +2475,6 @@
-	COPY_TO_USER(err,user_icount, &info->icount, sizeof(struct mgsl_icount));
-	if (err) {
-		if ( debug_level >= DEBUG_LEVEL_INFO )
-			printk( "%s(%d):mgsl_get_stats(%s) user buffer copy failed\n",
-				__FILE__,__LINE__,info->device_name);
-		return -EFAULT;
+	if (!user_icount) {
+		memset(&info->icount, 0, sizeof(info->icount));
+	} else {
+		COPY_TO_USER(err, user_icount, &info->icount, sizeof(struct mgsl_icount));
+		if (err)
+			return -EFAULT;
@@ -6151,0 +6154,5 @@
+	if (info->params.loopback) {
+		info->loopback_bits = 0x300;
+		outw(0x0300, info->io_base + CCAR);
+	}
+
--- ./projects/linux/linux-2.6.14/drivers/char/synclink.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/char/synclink.c	2006-01-03 04:21:10.000000000 +0100
@@ -4 +4 @@
- * $Id: synclink.c,v 4.37 2005/09/07 13:13:19 paulkf Exp $
+ * $Id: synclink.c,v 4.38 2005/11/07 16:30:34 paulkf Exp $
@@ -103,0 +104 @@
+#include <linux/dma-mapping.h>
@@ -150,0 +152 @@
+	dma_addr_t dma_addr;
@@ -236 +238,2 @@
-	unsigned long buffer_list_phys;
+	u32 buffer_list_phys;
+	dma_addr_t buffer_list_dma_addr;
@@ -899 +902 @@
-static char *driver_version = "$Revision: 4.37 $";
+static char *driver_version = "$Revision: 4.38 $";
@@ -3814,2 +3817,2 @@
-		info->buffer_list = kmalloc(BUFFERLISTSIZE, GFP_KERNEL | GFP_DMA);
-		if ( info->buffer_list == NULL )
+		info->buffer_list = dma_alloc_coherent(NULL, BUFFERLISTSIZE, &info->buffer_list_dma_addr, GFP_KERNEL);
+		if (info->buffer_list == NULL)
@@ -3817,2 +3820 @@
-			
-		info->buffer_list_phys = isa_virt_to_bus(info->buffer_list);
+		info->buffer_list_phys = (u32)(info->buffer_list_dma_addr);
@@ -3885,2 +3887,2 @@
-	if ( info->buffer_list && info->bus_type != MGSL_BUS_TYPE_PCI )
-		kfree(info->buffer_list);
+	if (info->buffer_list && info->bus_type != MGSL_BUS_TYPE_PCI)
+		dma_free_coherent(NULL, BUFFERLISTSIZE, info->buffer_list, info->buffer_list_dma_addr);
@@ -3913 +3915 @@
-	unsigned long phys_addr;
+	u32 phys_addr;
@@ -3925,3 +3927,2 @@
-			BufferList[i].virt_addr = 
-				kmalloc(DMABUFFERSIZE, GFP_KERNEL | GFP_DMA);
-			if ( BufferList[i].virt_addr == NULL )
+			BufferList[i].virt_addr = dma_alloc_coherent(NULL, DMABUFFERSIZE, &BufferList[i].dma_addr, GFP_KERNEL);
+			if (BufferList[i].virt_addr == NULL)
@@ -3929 +3930 @@
-			phys_addr = isa_virt_to_bus(BufferList[i].virt_addr);
+			phys_addr = (u32)(BufferList[i].dma_addr);
@@ -3960 +3961 @@
-					kfree(BufferList[i].virt_addr);
+					dma_free_coherent(NULL, DMABUFFERSIZE, BufferList[i].virt_addr, BufferList[i].dma_addr);
@@ -4018,3 +4019 @@
-	if ( info->intermediate_rxbuffer )
-		kfree(info->intermediate_rxbuffer);
-
+	kfree(info->intermediate_rxbuffer);
@@ -4074,4 +4073,2 @@
-		if ( info->tx_holding_buffers[i].buffer ) {
-				kfree(info->tx_holding_buffers[i].buffer);
-				info->tx_holding_buffers[i].buffer=NULL;
-		}
+		kfree(info->tx_holding_buffers[i].buffer);
+		info->tx_holding_buffers[i].buffer = NULL;
--- ./projects/linux/linux-2.6.15/drivers/char/synclink.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/synclink.c	2006-03-20 06:53:29.000000000 +0100
@@ -954 +953,0 @@
-static DECLARE_MUTEX(tmp_buf_sem);
@@ -1469,0 +1469 @@
+	int work = 0;
@@ -1489,0 +1490,2 @@
+		int flag;
+
@@ -1501,4 +1502,0 @@
-		if (tty->flip.count >= TTY_FLIPBUF_SIZE)
-			continue;
-			
-		*tty->flip.char_buf_ptr = DataByte;
@@ -1507 +1505 @@
-		*tty->flip.flag_buf_ptr = 0;
+		flag = 0;
@@ -1533 +1531 @@
-				*tty->flip.flag_buf_ptr = TTY_BREAK;
+				flag = TTY_BREAK;
@@ -1537 +1535 @@
-				*tty->flip.flag_buf_ptr = TTY_PARITY;
+				flag = TTY_PARITY;
@@ -1539,13 +1537 @@
-				*tty->flip.flag_buf_ptr = TTY_FRAME;
-			if (status & RXSTATUS_OVERRUN) {
-				/* Overrun is special, since it's
-				 * reported immediately, and doesn't
-				 * affect the current character
-				 */
-				if (tty->flip.count < TTY_FLIPBUF_SIZE) {
-					tty->flip.count++;
-					tty->flip.flag_buf_ptr++;
-					tty->flip.char_buf_ptr++;
-					*tty->flip.flag_buf_ptr = TTY_OVERRUN;
-				}
-			}
+				flag = TTY_FRAME;
@@ -1553,4 +1539,8 @@
-		
-		tty->flip.flag_buf_ptr++;
-		tty->flip.char_buf_ptr++;
-		tty->flip.count++;
+		tty_insert_flip_char(tty, DataByte, flag);
+		if (status & RXSTATUS_OVERRUN) {
+			/* Overrun is special, since it's
+			 * reported immediately, and doesn't
+			 * affect the current character
+			 */
+			work += tty_insert_flip_char(tty, 0, TTY_OVERRUN);
+		}
@@ -1560,2 +1549,0 @@
-		printk("%s(%d):mgsl_isr_receive_data flip count=%d\n",
-			__FILE__,__LINE__,tty->flip.count);
@@ -1567 +1555 @@
-	if ( tty->flip.count )
+	if(work)
@@ -7061 +7049 @@
-	static unsigned int Patterncount = sizeof(BitPatterns)/sizeof(unsigned short);
+	static unsigned int Patterncount = ARRAY_SIZE(BitPatterns);
@@ -7504,3 +7492,3 @@
-	static unsigned long BitPatterns[] = { 0x0, 0x55555555, 0xaaaaaaaa,
-											0x66666666, 0x99999999, 0xffffffff, 0x12345678 };
-	unsigned long Patterncount = sizeof(BitPatterns)/sizeof(unsigned long);
+	static unsigned long BitPatterns[] =
+		{ 0x0, 0x55555555, 0xaaaaaaaa, 0x66666666, 0x99999999, 0xffffffff, 0x12345678 };
+	unsigned long Patterncount = ARRAY_SIZE(BitPatterns);
--- ./projects/linux/linux-2.6.16/drivers/char/synclink.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/char/synclink.c	2006-06-18 03:49:35.000000000 +0200
@@ -944,11 +943,0 @@
-/*
- * tmp_buf is used as a temporary buffer by mgsl_write.  We need to
- * lock it in case the COPY_FROM_USER blocks while swapping in a page,
- * and some other program tries to do a serial write at the same time.
- * Since the lock will only come under contention when the system is
- * swapping and available memory is low, it makes sense to share one
- * buffer across all the serial ioports, since it significantly saves
- * memory if large numbers of serial ports are open.
- */
-static unsigned char *tmp_buf;
-
@@ -2153 +2142 @@
-	if (!tty || !info->xmit_buf || !tmp_buf)
+	if (!tty || !info->xmit_buf)
@@ -3441 +3429,0 @@
-	unsigned long		page;
@@ -3475,12 +3462,0 @@
-	if (!tmp_buf) {
-		page = get_zeroed_page(GFP_KERNEL);
-		if (!page) {
-			retval = -ENOMEM;
-			goto cleanup;
-		}
-		if (tmp_buf)
-			free_page(page);
-		else
-			tmp_buf = (unsigned char *) page;
-	}
-	
@@ -4505,5 +4480,0 @@
-	if (tmp_buf) {
-		free_page((unsigned long) tmp_buf);
-		tmp_buf = NULL;
-	}
-	
@@ -6028 +5999 @@
-	 * to 0 to aviod the situation where the FIFO contains fewer bytes
+	 * to 0 to avoid the situation where the FIFO contains fewer bytes
@@ -7773 +7744 @@
-	info->params.crc_type = new_crctype;;
+	info->params.crc_type = new_crctype;
--- ./projects/linux/linux-2.6.17/drivers/char/synclink.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/synclink.c	2006-09-20 05:42:06.000000000 +0200
@@ -1347,2 +1347,6 @@
-			if (info->netcount)
-				hdlc_set_carrier(status & MISCSTATUS_DCD, info->netdev);
+			if (info->netcount) {
+				if (status & MISCSTATUS_DCD)
+					netif_carrier_on(info->netdev);
+				else
+					netif_carrier_off(info->netdev);
+			}
@@ -7847,2 +7851,4 @@
-	hdlc_set_carrier(info->serial_signals & SerialSignal_DCD, dev);
-
+	if (info->serial_signals & SerialSignal_DCD)
+		netif_carrier_on(dev);
+	else
+		netif_carrier_off(dev);
@@ -8153 +8159 @@
-	info->irq_flags = SA_SHIRQ;
+	info->irq_flags = IRQF_SHARED;
--- ./projects/linux/linux-2.6.18/drivers/char/synclink.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/synclink.c	2006-11-29 22:57:37.000000000 +0100
@@ -66 +65,0 @@
-#include <linux/config.h>	
@@ -90 +88,0 @@
-#include <asm/serial.h>
@@ -138,2 +136,2 @@
-#define BUFFERLISTSIZE (PAGE_SIZE)
-#define DMABUFFERSIZE (PAGE_SIZE)
+#define BUFFERLISTSIZE 4096
+#define DMABUFFERSIZE 4096
@@ -1703 +1700,0 @@
- * 	regs		interrupted processor context
@@ -1707 +1704 @@
-static irqreturn_t mgsl_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+static irqreturn_t mgsl_interrupt(int irq, void *dev_id)
@@ -4363 +4360 @@
-static struct tty_operations mgsl_ops = {
+static const struct tty_operations mgsl_ops = {
--- ./projects/linux/linux-2.6.19/drivers/char/synclink.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/synclink.c	2007-02-04 19:44:54.000000000 +0100
@@ -104,2 +104,4 @@
-#ifdef CONFIG_HDLC_MODULE
-#define CONFIG_HDLC 1
+#if defined(CONFIG_HDLC) || (defined(CONFIG_HDLC_MODULE) && defined(CONFIG_SYNCLINK_MODULE))
+#define SYNCLINK_GENERIC_HDLC 1
+#else
+#define SYNCLINK_GENERIC_HDLC 0
@@ -323 +325 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -731 +733 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -805 +807 @@
-static void mgsl_bh_handler(void* Context);
+static void mgsl_bh_handler(struct work_struct *work);
@@ -1074 +1076 @@
-static void mgsl_bh_handler(void* Context)
+static void mgsl_bh_handler(struct work_struct *work)
@@ -1076 +1078,2 @@
-	struct mgsl_struct *info = (struct mgsl_struct*)Context;
+	struct mgsl_struct *info =
+		container_of(work, struct mgsl_struct, task);
@@ -1279 +1282 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -1344 +1347 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -3060 +3063 @@
-static void mgsl_set_termios(struct tty_struct *tty, struct termios *old_termios)
+static void mgsl_set_termios(struct tty_struct *tty, struct ktermios *old_termios)
@@ -4315 +4318 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -4332 +4335 @@
-	info = (struct mgsl_struct *)kmalloc(sizeof(struct mgsl_struct),
+	info = kmalloc(sizeof(struct mgsl_struct),
@@ -4340 +4343 @@
-		INIT_WORK(&info->task, mgsl_bh_handler, info);
+		INIT_WORK(&info->task, mgsl_bh_handler);
@@ -4404,0 +4408,2 @@
+	serial_driver->init_termios.c_ispeed = 9600;
+	serial_driver->init_termios.c_ospeed = 9600;
@@ -4473 +4478 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -6647 +6652 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -6723 +6728 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -7627 +7632 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -7703 +7708 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
--- ./projects/linux/linux-2.6.20/drivers/char/synclink.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/synclink.c	2007-04-26 05:08:32.000000000 +0200
@@ -1151 +1151 @@
-	if (tty) {
+	if (tty)
@@ -1153,2 +1152,0 @@
-		wake_up_interruptible(&tty->write_wait);
-	}
@@ -1803,3 +1801 @@
-	init_timer(&info->tx_timer);
-	info->tx_timer.data = (unsigned long)info;
-	info->tx_timer.function = mgsl_tx_timeout;
+	setup_timer(&info->tx_timer, mgsl_tx_timeout, (unsigned long)info);
@@ -1856 +1852 @@
-	del_timer(&info->tx_timer);	
+	del_timer_sync(&info->tx_timer);
@@ -2343 +2338,0 @@
-	wake_up_interruptible(&tty->write_wait);
@@ -5716,2 +5711,2 @@
-			info->tx_timer.expires = jiffies + msecs_to_jiffies(5000);
-			add_timer(&info->tx_timer);	
+			mod_timer(&info->tx_timer, jiffies +
+					msecs_to_jiffies(5000));
--- ./projects/linux/linux-2.6.21/drivers/char/synclink.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/char/synclink.c	2007-07-09 01:32:17.000000000 +0200
@@ -4013 +4013,5 @@
-		if ( info->tx_holding_buffers[i].buffer == NULL )
+		if (info->tx_holding_buffers[i].buffer == NULL) {
+			for (--i; i >= 0; i--) {
+				kfree(info->tx_holding_buffers[i].buffer);
+				info->tx_holding_buffers[i].buffer = NULL;
+			}
@@ -4014,0 +4019 @@
+		}
--- ./projects/linux/linux-2.6.22/drivers/char/synclink.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/synclink.c	2007-10-09 22:31:38.000000000 +0200
@@ -163,2 +162,0 @@
-#define RELEVANT_IFLAG(iflag) (iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
-
@@ -3067,6 +3064,0 @@
-	/* just return if nothing has changed */
-	if ((tty->termios->c_cflag == old_termios->c_cflag)
-	    && (RELEVANT_IFLAG(tty->termios->c_iflag) 
-		== RELEVANT_IFLAG(old_termios->c_iflag)))
-	  return;
-
@@ -4335 +4327 @@
-	info = kmalloc(sizeof(struct mgsl_struct),
+	info = kzalloc(sizeof(struct mgsl_struct),
@@ -4341 +4332,0 @@
-		memset(info, 0, sizeof(struct mgsl_struct));
--- ./projects/linux/linux-2.6.23/drivers/char/synclink.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/synclink.c	2008-01-24 23:58:37.000000000 +0100
@@ -84 +83,0 @@
-
@@ -86 +84,0 @@
-
@@ -89,2 +86,0 @@
-
-#include <linux/delay.h>
--- ./projects/linux/linux-2.6.24/drivers/char/synclink.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/synclink.c	2008-04-17 04:49:44.000000000 +0200
@@ -87,0 +88 @@
+#include <linux/synclink.h>
@@ -113,2 +113,0 @@
-#include "linux/synclink.h"
-
@@ -1547 +1546 @@
- * 	Service a miscellaneos interrupt source.
+ * 	Service a miscellaneous interrupt source.
--- ./projects/linux/linux-2.6.25/drivers/char/synclink.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/synclink.c	2008-07-13 23:51:29.000000000 +0200
@@ -221 +221 @@
-	int bh_running;		/* Protection from multiple */
+	bool bh_running;		/* Protection from multiple */
@@ -223 +223 @@
-	int bh_requested;
+	bool bh_requested;
@@ -253,3 +253,3 @@
-	int rx_enabled;
-	int rx_overflow;
-	int rx_rcc_underrun;
+	bool rx_enabled;
+	bool rx_overflow;
+	bool rx_rcc_underrun;
@@ -257,2 +257,2 @@
-	int tx_enabled;
-	int tx_active;
+	bool tx_enabled;
+	bool tx_active;
@@ -272 +272 @@
-	int io_addr_requested;		/* nonzero if I/O address requested */
+	bool io_addr_requested;		/* true if I/O address requested */
@@ -276 +276 @@
-	int irq_requested;		/* nonzero if IRQ requested */
+	bool irq_requested;		/* true if IRQ requested */
@@ -279 +279 @@
-	int dma_requested;		/* nonzero if dma channel requested */
+	bool dma_requested;		/* true if dma channel requested */
@@ -289 +289 @@
-	int irq_occurred;		/* for diagnostics use */
+	bool irq_occurred;		/* for diagnostics use */
@@ -296 +296 @@
-	int shared_mem_requested;
+	bool shared_mem_requested;
@@ -301 +301 @@
-	int lcr_mem_requested;
+	bool lcr_mem_requested;
@@ -306 +306 @@
-	BOOLEAN drop_rts_on_tx_done;
+	bool drop_rts_on_tx_done;
@@ -308,2 +308,2 @@
-	BOOLEAN loopmode_insert_requested;
-	BOOLEAN	loopmode_send_done_requested;
+	bool loopmode_insert_requested;
+	bool loopmode_send_done_requested;
@@ -755,4 +755,4 @@
-static BOOLEAN mgsl_register_test( struct mgsl_struct *info );
-static BOOLEAN mgsl_irq_test( struct mgsl_struct *info );
-static BOOLEAN mgsl_dma_test( struct mgsl_struct *info );
-static BOOLEAN mgsl_memory_test( struct mgsl_struct *info );
+static bool mgsl_register_test( struct mgsl_struct *info );
+static bool mgsl_irq_test( struct mgsl_struct *info );
+static bool mgsl_dma_test( struct mgsl_struct *info );
+static bool mgsl_memory_test( struct mgsl_struct *info );
@@ -773,2 +773,2 @@
-static int  mgsl_get_rx_frame( struct mgsl_struct *info );
-static int  mgsl_get_raw_rx_frame( struct mgsl_struct *info );
+static bool mgsl_get_rx_frame( struct mgsl_struct *info );
+static bool mgsl_get_raw_rx_frame( struct mgsl_struct *info );
@@ -794 +794 @@
-static int load_next_tx_holding_buffer(struct mgsl_struct *info);
+static bool load_next_tx_holding_buffer(struct mgsl_struct *info);
@@ -850 +850 @@
-static int pci_registered;
+static bool pci_registered;
@@ -1057,2 +1057,2 @@
-		info->bh_running   = 0;
-		info->bh_requested = 0;
+		info->bh_running = false;
+		info->bh_requested = false;
@@ -1082 +1082 @@
-	info->bh_running = 1;
+	info->bh_running = true;
@@ -1116 +1116 @@
-	int (*get_rx_frame)(struct mgsl_struct *info) =
+	bool (*get_rx_frame)(struct mgsl_struct *info) =
@@ -1190 +1190 @@
-	 	info->loopmode_insert_requested = FALSE;
+	 	info->loopmode_insert_requested = false;
@@ -1260 +1260 @@
-	info->tx_active = 0;
+	info->tx_active = false;
@@ -1270 +1270 @@
-		info->drop_rts_on_tx_done = 0;
+		info->drop_rts_on_tx_done = false;
@@ -1406 +1406 @@
-		info->irq_occurred = 1;
+		info->irq_occurred = true;
@@ -1434 +1434 @@
-		info->tx_active = 0;
+		info->tx_active = false;
@@ -1571 +1571 @@
-		info->rx_rcc_underrun = 1;
+		info->rx_rcc_underrun = true;
@@ -1629 +1629 @@
-		info->rx_overflow = 1;
+		info->rx_overflow = true;
@@ -1698 +1698 @@
-static irqreturn_t mgsl_interrupt(int irq, void *dev_id)
+static irqreturn_t mgsl_interrupt(int dummy, void *dev_id)
@@ -1700 +1700 @@
-	struct mgsl_struct * info;
+	struct mgsl_struct *info = dev_id;
@@ -1705,2 +1705,2 @@
-		printk("%s(%d):mgsl_interrupt(%d)entry.\n",
-			__FILE__,__LINE__,irq);
+		printk(KERN_DEBUG "%s(%d):mgsl_interrupt(%d)entry.\n",
+			__FILE__, __LINE__, info->irq_level);
@@ -1708,4 +1707,0 @@
-	info = (struct mgsl_struct *)dev_id;	
-	if (!info)
-		return IRQ_NONE;
-		
@@ -1735,2 +1731,2 @@
-			printk(KERN_ERR"%s(%d):%s isr overflow irq=%d\n",
-				__FILE__,__LINE__,info->device_name, irq);
+			printk(KERN_ERR "%s(%d):%s isr overflow irq=%d\n",
+				__FILE__, __LINE__, info->device_name, info->irq_level);
@@ -1752 +1748 @@
-		info->bh_requested = 1;
+		info->bh_requested = true;
@@ -1758,2 +1754,3 @@
-		printk("%s(%d):mgsl_interrupt(%d)exit.\n",
-			__FILE__,__LINE__,irq);
+		printk(KERN_DEBUG "%s(%d):mgsl_interrupt(%d)exit.\n",
+			__FILE__, __LINE__, info->irq_level);
+
@@ -2032 +2029 @@
-static void mgsl_put_char(struct tty_struct *tty, unsigned char ch)
+static int mgsl_put_char(struct tty_struct *tty, unsigned char ch)
@@ -2034 +2031 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -2035,0 +2033 @@
+	int ret = 0;
@@ -2037,3 +2035,3 @@
-	if ( debug_level >= DEBUG_LEVEL_INFO ) {
-		printk( "%s(%d):mgsl_put_char(%d) on %s\n",
-			__FILE__,__LINE__,ch,info->device_name);
+	if (debug_level >= DEBUG_LEVEL_INFO) {
+		printk(KERN_DEBUG "%s(%d):mgsl_put_char(%d) on %s\n",
+			__FILE__, __LINE__, ch, info->device_name);
@@ -2043 +2041 @@
-		return;
+		return 0;
@@ -2046 +2044 @@
-		return;
+		return 0;
@@ -2048,3 +2046 @@
-	spin_lock_irqsave(&info->irq_spinlock,flags);
-	
-	if ( (info->params.mode == MGSL_MODE_ASYNC ) || !info->tx_active ) {
+	spin_lock_irqsave(&info->irq_spinlock, flags);
@@ -2051,0 +2048 @@
+	if ((info->params.mode == MGSL_MODE_ASYNC ) || !info->tx_active) {
@@ -2055,0 +2053 @@
+			ret = 1;
@@ -2058,2 +2056,2 @@
-	
-	spin_unlock_irqrestore(&info->irq_spinlock,flags);
+	spin_unlock_irqrestore(&info->irq_spinlock, flags);
+	return ret;
@@ -2947,0 +2946 @@
+	int ret;
@@ -2962 +2961,4 @@
-	return mgsl_ioctl_common(info, cmd, arg);
+	lock_kernel();
+	ret = mgsl_ioctl_common(info, cmd, arg);
+	unlock_kernel();
+	return ret;
@@ -3159,2 +3161 @@
-	if (tty->driver->flush_buffer)
-		tty->driver->flush_buffer(tty);
+	mgsl_flush_buffer(tty);
@@ -3223 +3224,2 @@
-       
+
+	lock_kernel();
@@ -3252,0 +3255 @@
+	unlock_kernel();
@@ -3309 +3312,2 @@
-	int		do_clocal = 0, extra_count = 0;
+	bool		do_clocal = false;
+	bool		extra_count = false;
@@ -3323 +3327 @@
-		do_clocal = 1;
+		do_clocal = true;
@@ -3341 +3345 @@
-		extra_count = 1;
+		extra_count = true;
@@ -4049 +4053 @@
- * Return Value:	1 if next buffered tx request loaded
+ * Return Value:	true if next buffered tx request loaded
@@ -4051 +4055 @@
- * 			0 otherwise
+ * 			false otherwise
@@ -4053 +4057 @@
-static int load_next_tx_holding_buffer(struct mgsl_struct *info)
+static bool load_next_tx_holding_buffer(struct mgsl_struct *info)
@@ -4055 +4059 @@
-	int ret = 0;
+	bool ret = false;
@@ -4079 +4083 @@
-			ret = 1;
+			ret = true;
@@ -4125 +4129 @@
-	info->io_addr_requested = 1;
+	info->io_addr_requested = true;
@@ -4133 +4137 @@
-	info->irq_requested = 1;
+	info->irq_requested = true;
@@ -4141 +4145 @@
-		info->shared_mem_requested = 1;
+		info->shared_mem_requested = true;
@@ -4147 +4151 @@
-		info->lcr_mem_requested = 1;
+		info->lcr_mem_requested = true;
@@ -4149 +4153,2 @@
-		info->memory_base = ioremap(info->phys_memory_base,0x40000);
+		info->memory_base = ioremap_nocache(info->phys_memory_base,
+								0x40000);
@@ -4162 +4167,2 @@
-		info->lcr_base = ioremap(info->phys_lcr_base,PAGE_SIZE) + info->lcr_offset;
+		info->lcr_base = ioremap_nocache(info->phys_lcr_base,
+								PAGE_SIZE);
@@ -4167,0 +4174 @@
+		info->lcr_base += info->lcr_offset;
@@ -4178 +4185 @@
-		info->dma_requested = 1;
+		info->dma_requested = true;
@@ -4206 +4213 @@
-		info->irq_requested = 0;
+		info->irq_requested = false;
@@ -4211 +4218 @@
-		info->dma_requested = 0;
+		info->dma_requested = false;
@@ -4219 +4226 @@
-		info->io_addr_requested = 0;
+		info->io_addr_requested = false;
@@ -4223 +4230 @@
-		info->shared_mem_requested = 0;
+		info->shared_mem_requested = false;
@@ -4227 +4234 @@
-		info->lcr_mem_requested = 0;
+		info->lcr_mem_requested = false;
@@ -4492 +4499 @@
-		pci_registered = 1;
+		pci_registered = true;
@@ -4685 +4692 @@
-	int PreSL1660;
+	bool PreSL1660;
@@ -4698,5 +4705 @@
-	if ( RegValue == IUSC_PRE_SL1660 )
-		PreSL1660 = 1;
-	else
-		PreSL1660 = 0;
-	
+	PreSL1660 = (RegValue == IUSC_PRE_SL1660);
@@ -5388,3 +5391,3 @@
-	int start_of_frame_found = FALSE;
-	int end_of_frame_found = FALSE;
-	int reprogram_dma = FALSE;
+	bool start_of_frame_found = false;
+	bool end_of_frame_found = false;
+	bool reprogram_dma = false;
@@ -5416 +5419 @@
-			start_of_frame_found = TRUE;
+			start_of_frame_found = true;
@@ -5418 +5421 @@
-			end_of_frame_found = FALSE;
+			end_of_frame_found = false;
@@ -5429,2 +5432,2 @@
-			start_of_frame_found = FALSE;
-			end_of_frame_found = TRUE;
+			start_of_frame_found = false;
+			end_of_frame_found = true;
@@ -5445,2 +5448,2 @@
-			start_of_frame_found = FALSE;
-			reprogram_dma = TRUE;
+			start_of_frame_found = false;
+			reprogram_dma = true;
@@ -5472 +5475 @@
-		reprogram_dma = TRUE;
+		reprogram_dma = true;
@@ -5542,3 +5545,3 @@
-	info->rx_enabled = 0;
-	info->rx_overflow = 0;
-	info->rx_rcc_underrun = 0;
+	info->rx_enabled = false;
+	info->rx_overflow = false;
+	info->rx_rcc_underrun = false;
@@ -5607 +5610 @@
-	info->rx_enabled = 1;
+	info->rx_enabled = true;
@@ -5634 +5637 @@
-		info->drop_rts_on_tx_done = 0;
+		info->drop_rts_on_tx_done = false;
@@ -5641 +5644 @@
-				info->drop_rts_on_tx_done = 1;
+				info->drop_rts_on_tx_done = true;
@@ -5705 +5708 @@
-		info->tx_active = 1;
+		info->tx_active = true;
@@ -5709 +5712 @@
-		info->tx_enabled = 1;
+		info->tx_enabled = true;
@@ -5741,2 +5744,2 @@
-	info->tx_enabled = 0;
-	info->tx_active  = 0;
+	info->tx_enabled = false;
+	info->tx_active = false;
@@ -6526 +6529 @@
-	int Done = 0;
+	bool Done = false;
@@ -6540 +6543 @@
-			Done = 1;
+			Done = true;
@@ -6565 +6568 @@
- * Return Value:	1 if frame returned, otherwise 0
+ * Return Value:	true if frame returned, otherwise false
@@ -6567 +6570 @@
-static int mgsl_get_rx_frame(struct mgsl_struct *info)
+static bool mgsl_get_rx_frame(struct mgsl_struct *info)
@@ -6573 +6576 @@
-	int ReturnCode = 0;
+	bool ReturnCode = false;
@@ -6576 +6579 @@
-	int return_frame = 0;
+	bool return_frame = false;
@@ -6635 +6638 @@
-				return_frame = 1;
+				return_frame = true;
@@ -6646 +6649 @@
-		return_frame = 1;
+		return_frame = true;
@@ -6725 +6728 @@
-	ReturnCode = 1;
+	ReturnCode = true;
@@ -6764 +6767 @@
- * Return Value:	1 if frame returned, otherwise 0
+ * Return Value:	true if frame returned, otherwise false
@@ -6766 +6769 @@
-static int mgsl_get_raw_rx_frame(struct mgsl_struct *info)
+static bool mgsl_get_raw_rx_frame(struct mgsl_struct *info)
@@ -6772 +6775 @@
-	int ReturnCode = 0;
+	bool ReturnCode = false;
@@ -6897 +6900 @@
-		ReturnCode = 1;
+		ReturnCode = true;
@@ -7006 +7009 @@
- * Return Value:		TRUE if test passed, otherwise FALSE
+ * Return Value:		true if test passed, otherwise false
@@ -7008 +7011 @@
-static BOOLEAN mgsl_register_test( struct mgsl_struct *info )
+static bool mgsl_register_test( struct mgsl_struct *info )
@@ -7014 +7017 @@
-	BOOLEAN rc = TRUE;
+	bool rc = true;
@@ -7025 +7028 @@
-		rc = FALSE;
+		rc = false;
@@ -7028 +7031 @@
-	if ( rc == TRUE ){
+	if ( rc ){
@@ -7046 +7049 @@
-				rc = FALSE;
+				rc = false;
@@ -7062 +7065 @@
- * Return Value:	TRUE if test passed, otherwise FALSE
+ * Return Value:	true if test passed, otherwise false
@@ -7064 +7067 @@
-static BOOLEAN mgsl_irq_test( struct mgsl_struct *info )
+static bool mgsl_irq_test( struct mgsl_struct *info )
@@ -7074 +7077 @@
-	 * The ISR sets irq_occurred to 1. 
+	 * The ISR sets irq_occurred to true.
@@ -7077 +7080 @@
-	info->irq_occurred = FALSE;
+	info->irq_occurred = false;
@@ -7103,4 +7106 @@
-	if ( !info->irq_occurred ) 
-		return FALSE;
-	else
-		return TRUE;
+	return info->irq_occurred;
@@ -7117 +7117 @@
- * Return Value:	TRUE if test passed, otherwise FALSE
+ * Return Value:	true if test passed, otherwise false
@@ -7119 +7119 @@
-static BOOLEAN mgsl_dma_test( struct mgsl_struct *info )
+static bool mgsl_dma_test( struct mgsl_struct *info )
@@ -7126 +7126 @@
-	BOOLEAN rc = TRUE;
+	bool rc = true;
@@ -7239 +7239 @@
-			rc = FALSE;
+			rc = false;
@@ -7295 +7295 @@
-			rc = FALSE;
+			rc = false;
@@ -7315 +7315 @@
-	if ( rc == TRUE )
+	if ( rc )
@@ -7343 +7343 @@
-				rc = FALSE;
+				rc = false;
@@ -7354 +7354 @@
-	if ( rc == TRUE ){
+	if ( rc ){
@@ -7357 +7357 @@
-			rc = FALSE;
+			rc = false;
@@ -7360 +7360 @@
-	if ( rc == TRUE ) {
+	if ( rc ) {
@@ -7370 +7370 @@
-				rc = FALSE;
+				rc = false;
@@ -7378 +7378 @@
-	if ( rc == TRUE ) {
+	if ( rc ) {
@@ -7384 +7384 @@
-			rc = FALSE;
+			rc = false;
@@ -7388 +7388 @@
-				rc = FALSE;
+				rc = false;
@@ -7451 +7451 @@
- * Return Value:	TRUE if test passed, otherwise FALSE
+ * Return Value:	true if test passed, otherwise false
@@ -7453 +7453 @@
-static BOOLEAN mgsl_memory_test( struct mgsl_struct *info )
+static bool mgsl_memory_test( struct mgsl_struct *info )
@@ -7463 +7463 @@
-		return TRUE;
+		return true;
@@ -7472 +7472 @@
-			return FALSE;
+			return false;
@@ -7487 +7487 @@
-			return FALSE;
+			return false;
@@ -7493 +7493 @@
-	return TRUE;
+	return true;
@@ -7610 +7610 @@
-	info->tx_active = 0;
+	info->tx_active = false;
@@ -7638 +7638 @@
-			info->loopmode_send_done_requested = TRUE;
+			info->loopmode_send_done_requested = true;
@@ -7652 +7652 @@
- 	info->loopmode_send_done_requested = FALSE;
+ 	info->loopmode_send_done_requested = false;
@@ -7674 +7674 @@
- 	info->loopmode_insert_requested = TRUE;
+ 	info->loopmode_insert_requested = true;
--- ./projects/linux/linux-2.6.26/drivers/char/synclink.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/char/synclink.c	2008-10-10 00:13:53.000000000 +0200
@@ -183,2 +183 @@
-	int			flags;
-	int			count;		/* count of opens */
+	struct tty_port		port;
@@ -187,2 +185,0 @@
-	unsigned short		close_delay;
-	unsigned short		closing_wait;	/* time to wait before closing */
@@ -192 +188,0 @@
-	struct tty_struct 	*tty;
@@ -195 +190,0 @@
-	int			blocked_open;	/* # of blocked opens */
@@ -203,3 +197,0 @@
-	wait_queue_head_t	open_wait;
-	wait_queue_head_t	close_wait;
-	
@@ -315 +306,0 @@
-	int dosyncppp;
@@ -879 +869,0 @@
-static int dosyncppp[MAX_TOTAL_DEVICES];
@@ -890 +879,0 @@
-module_param_array(dosyncppp, int, NULL, 0);
@@ -978,2 +967,2 @@
-		if (ld->receive_buf)
-			ld->receive_buf(tty, data, flags, count);
+		if (ld->ops->receive_buf)
+			ld->ops->receive_buf(tty, data, flags, count);
@@ -1137 +1126 @@
-	struct tty_struct *tty = info->tty;
+	struct tty_struct *tty = info->port.tty;
@@ -1279 +1268 @@
-		if (info->tty->stopped || info->tty->hw_stopped) {
+		if (info->port.tty->stopped || info->port.tty->hw_stopped) {
@@ -1360 +1349 @@
-		if ( (info->flags & ASYNC_CHECK_CD) && 
+		if ( (info->port.flags & ASYNC_CHECK_CD) && 
@@ -1366 +1355 @@
-				wake_up_interruptible(&info->open_wait);
+				wake_up_interruptible(&info->port.open_wait);
@@ -1370,2 +1359,2 @@
-				if (info->tty)
-					tty_hangup(info->tty);
+				if (info->port.tty)
+					tty_hangup(info->port.tty);
@@ -1375 +1364 @@
-		if ( (info->flags & ASYNC_CTS_FLOW) && 
+		if ( (info->port.flags & ASYNC_CTS_FLOW) && 
@@ -1377 +1366 @@
-			if (info->tty->hw_stopped) {
+			if (info->port.tty->hw_stopped) {
@@ -1381,2 +1370,2 @@
-					if (info->tty)
-						info->tty->hw_stopped = 0;
+					if (info->port.tty)
+						info->port.tty->hw_stopped = 0;
@@ -1391,2 +1380,2 @@
-					if (info->tty)
-						info->tty->hw_stopped = 1;
+					if (info->port.tty)
+						info->port.tty->hw_stopped = 1;
@@ -1426 +1415 @@
-	if (info->tty->stopped || info->tty->hw_stopped) {
+	if (info->port.tty->stopped || info->port.tty->hw_stopped) {
@@ -1456 +1445 @@
- 	struct tty_struct *tty = info->tty;
+ 	struct tty_struct *tty = info->port.tty;
@@ -1517 +1506 @@
-				if (info->flags & ASYNC_SAK)
+				if (info->port.flags & ASYNC_SAK)
@@ -1774 +1763 @@
-	if (info->flags & ASYNC_INITIALIZED)
+	if (info->port.flags & ASYNC_INITIALIZED)
@@ -1801,2 +1790,2 @@
-  		if (capable(CAP_SYS_ADMIN) && info->tty)
-			set_bit(TTY_IO_ERROR, &info->tty->flags);
+  		if (capable(CAP_SYS_ADMIN) && info->port.tty)
+			set_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -1810,2 +1799,2 @@
-	if (info->tty)
-		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->port.tty)
+		clear_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -1813 +1802 @@
-	info->flags |= ASYNC_INITIALIZED;
+	info->port.flags |= ASYNC_INITIALIZED;
@@ -1830 +1819 @@
-	if (!(info->flags & ASYNC_INITIALIZED))
+	if (!(info->port.flags & ASYNC_INITIALIZED))
@@ -1867 +1856 @@
- 	if (!info->tty || info->tty->termios->c_cflag & HUPCL) {
+ 	if (!info->port.tty || info->port.tty->termios->c_cflag & HUPCL) {
@@ -1876,2 +1865,2 @@
-	if (info->tty)
-		set_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->port.tty)
+		set_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -1879 +1868 @@
-	info->flags &= ~ASYNC_INITIALIZED;
+	info->port.flags &= ~ASYNC_INITIALIZED;
@@ -1911 +1900 @@
-	if (info->netcount || info->tty->termios->c_cflag & CREAD)
+	if (info->netcount || info->port.tty->termios->c_cflag & CREAD)
@@ -1924 +1913 @@
-	if (!info->tty || !info->tty->termios)
+	if (!info->port.tty || !info->port.tty->termios)
@@ -1931 +1920 @@
-	cflag = info->tty->termios->c_cflag;
+	cflag = info->port.tty->termios->c_cflag;
@@ -1979 +1968 @@
-		info->params.data_rate = tty_get_baud_rate(info->tty);
+		info->params.data_rate = tty_get_baud_rate(info->port.tty);
@@ -1988 +1977 @@
-		info->flags |= ASYNC_CTS_FLOW;
+		info->port.flags |= ASYNC_CTS_FLOW;
@@ -1990 +1979 @@
-		info->flags &= ~ASYNC_CTS_FLOW;
+		info->port.flags &= ~ASYNC_CTS_FLOW;
@@ -1993 +1982 @@
-		info->flags &= ~ASYNC_CHECK_CD;
+		info->port.flags &= ~ASYNC_CHECK_CD;
@@ -1995 +1984 @@
-		info->flags |= ASYNC_CHECK_CD;
+		info->port.flags |= ASYNC_CHECK_CD;
@@ -2000 +1989 @@
-	if (I_INPCK(info->tty))
+	if (I_INPCK(info->port.tty))
@@ -2002 +1991 @@
- 	if (I_BRKINT(info->tty) || I_PARMRK(info->tty))
+ 	if (I_BRKINT(info->port.tty) || I_PARMRK(info->port.tty))
@@ -2005 +1994 @@
-	if (I_IGNPAR(info->tty))
+	if (I_IGNPAR(info->port.tty))
@@ -2007 +1996 @@
-	if (I_IGNBRK(info->tty)) {
+	if (I_IGNBRK(info->port.tty)) {
@@ -2012 +2001 @@
-		if (I_IGNPAR(info->tty))
+		if (I_IGNPAR(info->port.tty))
@@ -2908 +2897 @@
- * Return Value:	None
+ * Return Value:	error code
@@ -2910 +2899 @@
-static void mgsl_break(struct tty_struct *tty, int break_state)
+static int mgsl_break(struct tty_struct *tty, int break_state)
@@ -2920 +2909 @@
-		return;
+		return -EINVAL;
@@ -2927,0 +2917 @@
+	return 0;
@@ -3116 +3106 @@
-			 __FILE__,__LINE__, info->device_name, info->count);
+			 __FILE__,__LINE__, info->device_name, info->port.count);
@@ -3118 +3108 @@
-	if (!info->count)
+	if (!info->port.count)
@@ -3124 +3114 @@
-	if ((tty->count == 1) && (info->count != 1)) {
+	if ((tty->count == 1) && (info->port.count != 1)) {
@@ -3127 +3117 @@
-		 * info->count should be one in this case.
+		 * info->port.count should be one in this case.
@@ -3131,2 +3121,2 @@
-		       "info->count is %d\n", info->count);
-		info->count = 1;
+		       "info->port.count is %d\n", info->port.count);
+		info->port.count = 1;
@@ -3135 +3125 @@
-	info->count--;
+	info->port.count--;
@@ -3138 +3128 @@
-	if (info->count)
+	if (info->port.count)
@@ -3141 +3131 @@
-	info->flags |= ASYNC_CLOSING;
+	info->port.flags |= ASYNC_CLOSING;
@@ -3151 +3141 @@
-	if (info->closing_wait != ASYNC_CLOSING_WAIT_NONE) {
+	if (info->port.closing_wait != ASYNC_CLOSING_WAIT_NONE) {
@@ -3155 +3145 @@
-		tty_wait_until_sent(tty, info->closing_wait);
+		tty_wait_until_sent(tty, info->port.closing_wait);
@@ -3158 +3148 @@
- 	if (info->flags & ASYNC_INITIALIZED)
+ 	if (info->port.flags & ASYNC_INITIALIZED)
@@ -3168 +3158 @@
-	info->tty = NULL;
+	info->port.tty = NULL;
@@ -3170,3 +3160,3 @@
-	if (info->blocked_open) {
-		if (info->close_delay) {
-			msleep_interruptible(jiffies_to_msecs(info->close_delay));
+	if (info->port.blocked_open) {
+		if (info->port.close_delay) {
+			msleep_interruptible(jiffies_to_msecs(info->port.close_delay));
@@ -3174 +3164 @@
-		wake_up_interruptible(&info->open_wait);
+		wake_up_interruptible(&info->port.open_wait);
@@ -3177 +3167 @@
-	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
+	info->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
@@ -3179 +3169 @@
-	wake_up_interruptible(&info->close_wait);
+	wake_up_interruptible(&info->port.close_wait);
@@ -3184 +3174 @@
-			tty->driver->name, info->count);
+			tty->driver->name, info->port.count);
@@ -3214 +3204 @@
-	if (!(info->flags & ASYNC_INITIALIZED))
+	if (!(info->port.flags & ASYNC_INITIALIZED))
@@ -3286,3 +3276,3 @@
-	info->count = 0;	
-	info->flags &= ~ASYNC_NORMAL_ACTIVE;
-	info->tty = NULL;
+	info->port.count = 0;	
+	info->port.flags &= ~ASYNC_NORMAL_ACTIVE;
+	info->port.tty = NULL;
@@ -3290 +3280 @@
-	wake_up_interruptible(&info->open_wait);
+	wake_up_interruptible(&info->port.open_wait);
@@ -3322 +3312 @@
-		info->flags |= ASYNC_NORMAL_ACTIVE;
+		info->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -3331 +3321 @@
-	 * this loop, info->count is dropped by one, so that
+	 * this loop, info->port.count is dropped by one, so that
@@ -3337 +3327 @@
-	add_wait_queue(&info->open_wait, &wait);
+	add_wait_queue(&info->port.open_wait, &wait);
@@ -3341 +3331 @@
-			 __FILE__,__LINE__, tty->driver->name, info->count );
+			 __FILE__,__LINE__, tty->driver->name, info->port.count );
@@ -3346 +3336 @@
-		info->count--;
+		info->port.count--;
@@ -3349 +3339 @@
-	info->blocked_open++;
+	info->port.blocked_open++;
@@ -3361,2 +3351,2 @@
-		if (tty_hung_up_p(filp) || !(info->flags & ASYNC_INITIALIZED)){
-			retval = (info->flags & ASYNC_HUP_NOTIFY) ?
+		if (tty_hung_up_p(filp) || !(info->port.flags & ASYNC_INITIALIZED)){
+			retval = (info->port.flags & ASYNC_HUP_NOTIFY) ?
@@ -3371 +3361 @@
- 		if (!(info->flags & ASYNC_CLOSING) &&
+ 		if (!(info->port.flags & ASYNC_CLOSING) &&
@@ -3383 +3373 @@
-				 __FILE__,__LINE__, tty->driver->name, info->count );
+				 __FILE__,__LINE__, tty->driver->name, info->port.count );
@@ -3389 +3379 @@
-	remove_wait_queue(&info->open_wait, &wait);
+	remove_wait_queue(&info->port.open_wait, &wait);
@@ -3392,2 +3382,2 @@
-		info->count++;
-	info->blocked_open--;
+		info->port.count++;
+	info->port.blocked_open--;
@@ -3397 +3387 @@
-			 __FILE__,__LINE__, tty->driver->name, info->count );
+			 __FILE__,__LINE__, tty->driver->name, info->port.count );
@@ -3400 +3390 @@
-		info->flags |= ASYNC_NORMAL_ACTIVE;
+		info->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -3438 +3428 @@
-	info->tty = tty;
+	info->port.tty = tty;
@@ -3442 +3432 @@
-			 __FILE__,__LINE__,tty->driver->name, info->count);
+			 __FILE__,__LINE__,tty->driver->name, info->port.count);
@@ -3445,4 +3435,4 @@
-	if (tty_hung_up_p(filp) || info->flags & ASYNC_CLOSING){
-		if (info->flags & ASYNC_CLOSING)
-			interruptible_sleep_on(&info->close_wait);
-		retval = ((info->flags & ASYNC_HUP_NOTIFY) ?
+	if (tty_hung_up_p(filp) || info->port.flags & ASYNC_CLOSING){
+		if (info->port.flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&info->port.close_wait);
+		retval = ((info->port.flags & ASYNC_HUP_NOTIFY) ?
@@ -3453 +3443 @@
-	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+	info->port.tty->low_latency = (info->port.flags & ASYNC_LOW_LATENCY) ? 1 : 0;
@@ -3461 +3451 @@
-	info->count++;
+	info->port.count++;
@@ -3464 +3454 @@
-	if (info->count == 1) {
+	if (info->port.count == 1) {
@@ -3487,3 +3477,3 @@
-			info->tty = NULL; /* tty layer will release tty struct */
-		if(info->count)
-			info->count--;
+			info->port.tty = NULL; /* tty layer will release tty struct */
+		if(info->port.count)
+			info->port.count--;
@@ -4268 +4257,0 @@
-		info->dosyncppp = dosyncppp[info->line];
@@ -4334,0 +4324 @@
+		tty_port_init(&info->port);
@@ -4338,4 +4328,2 @@
-		info->close_delay = 5*HZ/10;
-		info->closing_wait = 30*HZ;
-		init_waitqueue_head(&info->open_wait);
-		init_waitqueue_head(&info->close_wait);
+		info->port.close_delay = 5*HZ/10;
+		info->port.closing_wait = 30*HZ;
@@ -6578 +6566 @@
-	struct tty_struct *tty = info->tty;
+	struct tty_struct *tty = info->port.tty;
@@ -6643,3 +6631,2 @@
-			struct net_device_stats *stats = hdlc_stats(info->netdev);
-			stats->rx_errors++;
-			stats->rx_frame_errors++;
+			info->netdev->stats.rx_errors++;
+			info->netdev->stats.rx_frame_errors++;
@@ -6777 +6764 @@
-	struct tty_struct *tty = info->tty;
+	struct tty_struct *tty = info->port.tty;
@@ -7714 +7701 @@
-	if (info->count)
+	if (info->port.count)
@@ -7756 +7742,0 @@
-	struct net_device_stats *stats = hdlc_stats(dev);
@@ -7770,2 +7756,2 @@
-	stats->tx_packets++;
-	stats->tx_bytes += skb->len;
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
@@ -7811 +7797 @@
-	if (info->count != 0 || info->netcount != 0) {
+	if (info->port.count != 0 || info->netcount != 0) {
@@ -7897 +7883 @@
-	if (info->count)
+	if (info->port.count)
@@ -7987 +7972,0 @@
-	struct net_device_stats *stats = hdlc_stats(dev);
@@ -7993,2 +7978,2 @@
-	stats->tx_errors++;
-	stats->tx_aborted_errors++;
+	dev->stats.tx_errors++;
+	dev->stats.tx_aborted_errors++;
@@ -8027 +8011,0 @@
-	struct net_device_stats *stats = hdlc_stats(dev);
@@ -8030 +8014 @@
-		printk("hdlcdev_rx(%s)\n",dev->name);
+		printk("hdlcdev_rx(%s)\n", dev->name);
@@ -8033,2 +8017,3 @@
-		printk(KERN_NOTICE "%s: can't alloc skb, dropping packet\n", dev->name);
-		stats->rx_dropped++;
+		printk(KERN_NOTICE "%s: can't alloc skb, dropping packet\n",
+		       dev->name);
+		dev->stats.rx_dropped++;
@@ -8038 +8023 @@
-	memcpy(skb_put(skb, size),buf,size);
+	memcpy(skb_put(skb, size), buf, size);
@@ -8040 +8025 @@
-	skb->protocol = hdlc_type_trans(skb, info->netdev);
+	skb->protocol = hdlc_type_trans(skb, dev);
@@ -8042,2 +8027,2 @@
-	stats->rx_packets++;
-	stats->rx_bytes += size;
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += size;
@@ -8047 +8032 @@
-	info->netdev->last_rx = jiffies;
+	dev->last_rx = jiffies;
--- ./projects/linux/linux-2.6.28/drivers/char/synclink.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/char/synclink.c	2009-03-24 00:12:14.000000000 +0100
@@ -980 +980 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -1003 +1003 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -2060 +2060 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -2112 +2112 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -2235 +2235 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -2270 +2270 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -2304 +2304 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -2332 +2332 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -2361 +2361 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -2391 +2391 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -2844 +2844 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -2870 +2870 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -2901 +2901 @@
-	struct mgsl_struct * info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct * info = tty->driver_data;
@@ -2935 +2935 @@
-	struct mgsl_struct * info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct * info = tty->driver_data;
@@ -3045 +3045 @@
-	struct mgsl_struct *info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct *info = tty->driver_data;
@@ -3099 +3099 @@
-	struct mgsl_struct * info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct * info = tty->driver_data;
@@ -3107,3 +3106,0 @@
-			 
-	if (!info->port.count)
-		return;
@@ -3111 +3108 @@
-	if (tty_hung_up_p(filp))
+	if (tty_port_close_start(&info->port, tty, filp) == 0)			 
@@ -3114,34 +3110,0 @@
-	if ((tty->count == 1) && (info->port.count != 1)) {
-		/*
-		 * tty->count is 1 and the tty structure will be freed.
-		 * info->port.count should be one in this case.
-		 * if it's not, correct it so that the port is shutdown.
-		 */
-		printk("mgsl_close: bad refcount; tty->count is 1, "
-		       "info->port.count is %d\n", info->port.count);
-		info->port.count = 1;
-	}
-	
-	info->port.count--;
-	
-	/* if at least one open remaining, leave hardware active */
-	if (info->port.count)
-		goto cleanup;
-	
-	info->port.flags |= ASYNC_CLOSING;
-	
-	/* set tty->closing to notify line discipline to 
-	 * only process XON/XOFF characters. Only the N_TTY
-	 * discipline appears to use this (ppp does not).
-	 */
-	tty->closing = 1;
-	
-	/* wait for transmit data to clear all layers */
-	
-	if (info->port.closing_wait != ASYNC_CLOSING_WAIT_NONE) {
-		if (debug_level >= DEBUG_LEVEL_INFO)
-			printk("%s(%d):mgsl_close(%s) calling tty_wait_until_sent\n",
-				 __FILE__,__LINE__, info->device_name );
-		tty_wait_until_sent(tty, info->port.closing_wait);
-	}
-		
@@ -3150 +3112,0 @@
-
@@ -3152 +3113,0 @@
-
@@ -3154 +3114,0 @@
-		
@@ -3156,2 +3116,2 @@
-	
-	tty->closing = 0;
+
+	tty_port_close_end(&info->port, tty);	
@@ -3159,12 +3118,0 @@
-	
-	if (info->port.blocked_open) {
-		if (info->port.close_delay) {
-			msleep_interruptible(jiffies_to_msecs(info->port.close_delay));
-		}
-		wake_up_interruptible(&info->port.open_wait);
-	}
-	
-	info->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-			 
-	wake_up_interruptible(&info->port.close_wait);
-	
@@ -3191 +3139 @@
-	struct mgsl_struct * info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct * info = tty->driver_data;
@@ -3264 +3212 @@
-	struct mgsl_struct * info = (struct mgsl_struct *)tty->driver_data;
+	struct mgsl_struct * info = tty->driver_data;
@@ -3283,0 +3232,29 @@
+/*
+ * carrier_raised()
+ *
+ *	Return true if carrier is raised
+ */
+
+static int carrier_raised(struct tty_port *port)
+{
+	unsigned long flags;
+	struct mgsl_struct *info = container_of(port, struct mgsl_struct, port);
+	
+	spin_lock_irqsave(&info->irq_spinlock, flags);
+ 	usc_get_serial_signals(info);
+	spin_unlock_irqrestore(&info->irq_spinlock, flags);
+	return (info->serial_signals & SerialSignal_DCD) ? 1 : 0;
+}
+
+static void raise_dtr_rts(struct tty_port *port)
+{
+	struct mgsl_struct *info = container_of(port, struct mgsl_struct, port);
+	unsigned long flags;
+
+	spin_lock_irqsave(&info->irq_spinlock,flags);
+	info->serial_signals |= SerialSignal_RTS + SerialSignal_DTR;
+ 	usc_set_serial_signals(info);
+	spin_unlock_irqrestore(&info->irq_spinlock,flags);
+}
+
+
@@ -3304,0 +3282,2 @@
+	int		dcd;
+	struct tty_port *port = &info->port;
@@ -3312 +3291 @@
-		info->port.flags |= ASYNC_NORMAL_ACTIVE;
+		port->flags |= ASYNC_NORMAL_ACTIVE;
@@ -3321 +3300 @@
-	 * this loop, info->port.count is dropped by one, so that
+	 * this loop, port->count is dropped by one, so that
@@ -3327 +3306 @@
-	add_wait_queue(&info->port.open_wait, &wait);
+	add_wait_queue(&port->open_wait, &wait);
@@ -3331 +3310 @@
-			 __FILE__,__LINE__, tty->driver->name, info->port.count );
+			 __FILE__,__LINE__, tty->driver->name, port->count );
@@ -3336 +3315 @@
-		info->port.count--;
+		port->count--;
@@ -3339 +3318 @@
-	info->port.blocked_open++;
+	port->blocked_open++;
@@ -3342,6 +3321,2 @@
-		if (tty->termios->c_cflag & CBAUD) {
-			spin_lock_irqsave(&info->irq_spinlock,flags);
-			info->serial_signals |= SerialSignal_RTS + SerialSignal_DTR;
-		 	usc_set_serial_signals(info);
-			spin_unlock_irqrestore(&info->irq_spinlock,flags);
-		}
+		if (tty->termios->c_cflag & CBAUD)
+			tty_port_raise_dtr_rts(port);
@@ -3351,2 +3326,2 @@
-		if (tty_hung_up_p(filp) || !(info->port.flags & ASYNC_INITIALIZED)){
-			retval = (info->port.flags & ASYNC_HUP_NOTIFY) ?
+		if (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)){
+			retval = (port->flags & ASYNC_HUP_NOTIFY) ?
@@ -3357,3 +3332 @@
-		spin_lock_irqsave(&info->irq_spinlock,flags);
-	 	usc_get_serial_signals(info);
-		spin_unlock_irqrestore(&info->irq_spinlock,flags);
+		dcd = tty_port_carrier_raised(&info->port);
@@ -3361,2 +3334 @@
- 		if (!(info->port.flags & ASYNC_CLOSING) &&
- 		    (do_clocal || (info->serial_signals & SerialSignal_DCD)) ) {
+ 		if (!(port->flags & ASYNC_CLOSING) && (do_clocal || dcd))
@@ -3364 +3335,0 @@
-		}
@@ -3373 +3344 @@
-				 __FILE__,__LINE__, tty->driver->name, info->port.count );
+				 __FILE__,__LINE__, tty->driver->name, port->count );
@@ -3379 +3350 @@
-	remove_wait_queue(&info->port.open_wait, &wait);
+	remove_wait_queue(&port->open_wait, &wait);
@@ -3380,0 +3352 @@
+	/* FIXME: Racy on hangup during close wait */
@@ -3382,2 +3354,2 @@
-		info->port.count++;
-	info->port.blocked_open--;
+		port->count++;
+	port->blocked_open--;
@@ -3387 +3359 @@
-			 __FILE__,__LINE__, tty->driver->name, info->port.count );
+			 __FILE__,__LINE__, tty->driver->name, port->count );
@@ -3390 +3362 @@
-		info->port.flags |= ASYNC_NORMAL_ACTIVE;
+		port->flags |= ASYNC_NORMAL_ACTIVE;
@@ -4306,0 +4279,6 @@
+static const struct tty_port_operations mgsl_port_ops = {
+	.carrier_raised = carrier_raised,
+	.raise_dtr_rts = raise_dtr_rts,
+};
+
+
@@ -4324,0 +4303 @@
+		info->port.ops = &mgsl_port_ops;
--- ./projects/linux/linux-2.6.29/drivers/char/synclink.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/char/synclink.c	2009-06-27 11:32:32.000000000 +0200
@@ -81,0 +82 @@
+#include <linux/seq_file.h>
@@ -3462 +3463 @@
-static inline int line_info(char *buf, struct mgsl_struct *info)
+static inline void line_info(struct seq_file *m, struct mgsl_struct *info)
@@ -3465 +3465,0 @@
-	int	ret;
@@ -3469 +3469 @@
-		ret = sprintf(buf, "%s:PCI io:%04X irq:%d mem:%08X lcr:%08X",
+		seq_printf(m, "%s:PCI io:%04X irq:%d mem:%08X lcr:%08X",
@@ -3473 +3473 @@
-		ret = sprintf(buf, "%s:(E)ISA io:%04X irq:%d dma:%d",
+		seq_printf(m, "%s:(E)ISA io:%04X irq:%d dma:%d",
@@ -3500 +3500 @@
-		ret += sprintf(buf+ret, " HDLC txok:%d rxok:%d",
+		seq_printf(m, " HDLC txok:%d rxok:%d",
@@ -3503 +3503 @@
-			ret += sprintf(buf+ret, " txunder:%d", info->icount.txunder);
+			seq_printf(m, " txunder:%d", info->icount.txunder);
@@ -3505 +3505 @@
-			ret += sprintf(buf+ret, " txabort:%d", info->icount.txabort);
+			seq_printf(m, " txabort:%d", info->icount.txabort);
@@ -3507 +3507 @@
-			ret += sprintf(buf+ret, " rxshort:%d", info->icount.rxshort);	
+			seq_printf(m, " rxshort:%d", info->icount.rxshort);
@@ -3509 +3509 @@
-			ret += sprintf(buf+ret, " rxlong:%d", info->icount.rxlong);
+			seq_printf(m, " rxlong:%d", info->icount.rxlong);
@@ -3511 +3511 @@
-			ret += sprintf(buf+ret, " rxover:%d", info->icount.rxover);
+			seq_printf(m, " rxover:%d", info->icount.rxover);
@@ -3513 +3513 @@
-			ret += sprintf(buf+ret, " rxcrc:%d", info->icount.rxcrc);
+			seq_printf(m, " rxcrc:%d", info->icount.rxcrc);
@@ -3515 +3515 @@
-		ret += sprintf(buf+ret, " ASYNC tx:%d rx:%d",
+		seq_printf(m, " ASYNC tx:%d rx:%d",
@@ -3518 +3518 @@
-			ret += sprintf(buf+ret, " fe:%d", info->icount.frame);
+			seq_printf(m, " fe:%d", info->icount.frame);
@@ -3520 +3520 @@
-			ret += sprintf(buf+ret, " pe:%d", info->icount.parity);
+			seq_printf(m, " pe:%d", info->icount.parity);
@@ -3522 +3522 @@
-			ret += sprintf(buf+ret, " brk:%d", info->icount.brk);	
+			seq_printf(m, " brk:%d", info->icount.brk);
@@ -3524 +3524 @@
-			ret += sprintf(buf+ret, " oe:%d", info->icount.overrun);
+			seq_printf(m, " oe:%d", info->icount.overrun);
@@ -3528 +3528 @@
-	ret += sprintf(buf+ret, " %s\n", stat_buf+1);
+	seq_printf(m, " %s\n", stat_buf+1);
@@ -3530 +3530 @@
-	ret += sprintf(buf+ret, "txactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",
+	seq_printf(m, "txactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",
@@ -3547 +3547 @@
-	ret += sprintf(buf+ret, "tcsr=%04X tdmr=%04X ticr=%04X rcsr=%04X rdmr=%04X\n"
+	seq_printf(m, "tcsr=%04X tdmr=%04X ticr=%04X rcsr=%04X rdmr=%04X\n"
@@ -3552,4 +3552 @@
-	
-	return ret;
-	
-}	/* end of line_info() */
+}
@@ -3557,16 +3554,2 @@
-/* mgsl_read_proc()
- * 
- * Called to print information about devices
- * 
- * Arguments:
- * 	page	page of memory to hold returned info
- * 	start	
- * 	off
- * 	count
- * 	eof
- * 	data
- * 	
- * Return Value:
- */
-static int mgsl_read_proc(char *page, char **start, off_t off, int count,
-		 int *eof, void *data)
+/* Called to print information about devices */
+static int mgsl_proc_show(struct seq_file *m, void *v)
@@ -3574,2 +3556,0 @@
-	int len = 0, l;
-	off_t	begin = 0;
@@ -3578 +3559 @@
-	len += sprintf(page, "synclink driver:%s\n", driver_version);
+	seq_printf(m, "synclink driver:%s\n", driver_version);
@@ -3582,8 +3563 @@
-		l = line_info(page + len, info);
-		len += l;
-		if (len+begin > off+count)
-			goto done;
-		if (len+begin < off) {
-			begin += len;
-			len = 0;
-		}
+		line_info(m, info);
@@ -3591,0 +3566,2 @@
+	return 0;
+}
@@ -3593,8 +3569,12 @@
-	*eof = 1;
-done:
-	if (off >= len+begin)
-		return 0;
-	*start = page + (off-begin);
-	return ((count < begin+len-off) ? count : begin+len-off);
-	
-}	/* end of mgsl_read_proc() */
+static int mgsl_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, mgsl_proc_show, NULL);
+}
+
+static const struct file_operations mgsl_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= mgsl_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
@@ -4338 +4317,0 @@
- 	.read_proc = mgsl_read_proc,
@@ -4344,0 +4324 @@
+	.proc_fops = &mgsl_proc_fops,
@@ -8010,2 +7989,0 @@
-
-	dev->last_rx = jiffies;
@@ -8013,0 +7992,9 @@
+static const struct net_device_ops hdlcdev_ops = {
+	.ndo_open       = hdlcdev_open,
+	.ndo_stop       = hdlcdev_close,
+	.ndo_change_mtu = hdlc_change_mtu,
+	.ndo_start_xmit = hdlc_start_xmit,
+	.ndo_do_ioctl   = hdlcdev_ioctl,
+	.ndo_tx_timeout = hdlcdev_tx_timeout,
+};
+
@@ -8041,5 +8028,2 @@
-	dev->do_ioctl       = hdlcdev_ioctl;
-	dev->open           = hdlcdev_open;
-	dev->stop           = hdlcdev_close;
-	dev->tx_timeout     = hdlcdev_tx_timeout;
-	dev->watchdog_timeo = 10*HZ;
+	dev->netdev_ops     = &hdlcdev_ops;
+	dev->watchdog_timeo = 10 * HZ;
--- ./projects/linux/linux-2.6.16/drivers/char/synclink_gt.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/char/synclink_gt.c	2006-06-18 03:49:35.000000000 +0200
@@ -2 +2 @@
- * $Id: synclink_gt.c,v 4.22 2006/01/09 20:16:06 paulkf Exp $
+ * $Id: synclink_gt.c,v 4.25 2006/02/06 21:20:33 paulkf Exp $
@@ -95 +95 @@
-static char *driver_version  = "$Revision: 4.22 $";
+static char *driver_version  = "$Revision: 4.25 $";
@@ -190,0 +191,14 @@
+ * conditional wait facility
+ */
+struct cond_wait {
+	struct cond_wait *next;
+	wait_queue_head_t q;
+	wait_queue_t wait;
+	unsigned int data;
+};
+static void init_cond_wait(struct cond_wait *w, unsigned int data);
+static void add_cond_wait(struct cond_wait **head, struct cond_wait *w);
+static void remove_cond_wait(struct cond_wait **head, struct cond_wait *w);
+static void flush_cond_wait(struct cond_wait **head);
+
+/*
@@ -271,0 +286,3 @@
+	unsigned int            gpio_present;
+	struct cond_wait        *gpio_wait_q;
+
@@ -381,0 +399,5 @@
+#define JCR   0x04 /* JTAG control */
+#define IODR  0x08 /* GPIO direction */
+#define IOER  0x0c /* GPIO interrupt enable */
+#define IOVR  0x10 /* GPIO value */
+#define IOSR  0x14 /* GPIO interrupt status */
@@ -505,0 +528,3 @@
+static int  set_gpio(struct slgt_info *info, struct gpio_desc __user *gpio);
+static int  get_gpio(struct slgt_info *info, struct gpio_desc __user *gpio);
+static int  wait_gpio(struct slgt_info *info, struct gpio_desc __user *gpio);
@@ -1114,0 +1140,6 @@
+	case MGSL_IOCSGPIO:
+		return set_gpio(info, argp);
+	case MGSL_IOCGGPIO:
+		return get_gpio(info, argp);
+	case MGSL_IOCWAITGPIO:
+		return wait_gpio(info, argp);
@@ -1368 +1399 @@
-	info->params.crc_type = new_crctype;;
+	info->params.crc_type = new_crctype;
@@ -1765,4 +1795,0 @@
-			if (tty && chars) {
-				tty_flip_buffer_push(tty);
-				chars = 0;
-			}
@@ -2160,0 +2188,18 @@
+static void isr_gpio(struct slgt_info *info, unsigned int changed, unsigned int state)
+{
+	struct cond_wait *w, *prev;
+
+	/* wake processes waiting for specific transitions */
+	for (w = info->gpio_wait_q, prev = NULL ; w != NULL ; w = w->next) {
+		if (w->data & changed) {
+			w->data = state;
+			wake_up_interruptible(&w->q);
+			if (prev != NULL)
+				prev->next = w->next;
+			else
+				info->gpio_wait_q = w->next;
+		} else
+			prev = w;
+	}
+}
+
@@ -2195,0 +2241,16 @@
+	if (info->gpio_present) {
+		unsigned int state;
+		unsigned int changed;
+		while ((changed = rd_reg32(info, IOSR)) != 0) {
+			DBGISR(("%s iosr=%08x\n", info->device_name, changed));
+			/* read latched state of GPIO signals */
+			state = rd_reg32(info, IOVR);
+			/* clear pending GPIO interrupt bits */
+			wr_reg32(info, IOSR, changed);
+			for (i=0 ; i < info->port_count ; i++) {
+				if (info->port_array[i] != NULL)
+					isr_gpio(info->port_array[i], changed, state);
+			}
+		}
+	}
+
@@ -2278,0 +2340,2 @@
+	flush_cond_wait(&info->gpio_wait_q);
+
@@ -2652,0 +2716,169 @@
+/*
+ * set general purpose IO pin state and direction
+ *
+ * user_gpio fields:
+ * state   each bit indicates a pin state
+ * smask   set bit indicates pin state to set
+ * dir     each bit indicates a pin direction (0=input, 1=output)
+ * dmask   set bit indicates pin direction to set
+ */
+static int set_gpio(struct slgt_info *info, struct gpio_desc __user *user_gpio)
+{
+ 	unsigned long flags;
+	struct gpio_desc gpio;
+	__u32 data;
+
+	if (!info->gpio_present)
+		return -EINVAL;
+	if (copy_from_user(&gpio, user_gpio, sizeof(gpio)))
+		return -EFAULT;
+	DBGINFO(("%s set_gpio state=%08x smask=%08x dir=%08x dmask=%08x\n",
+		 info->device_name, gpio.state, gpio.smask,
+		 gpio.dir, gpio.dmask));
+
+	spin_lock_irqsave(&info->lock,flags);
+	if (gpio.dmask) {
+		data = rd_reg32(info, IODR);
+		data |= gpio.dmask & gpio.dir;
+		data &= ~(gpio.dmask & ~gpio.dir);
+		wr_reg32(info, IODR, data);
+	}
+	if (gpio.smask) {
+		data = rd_reg32(info, IOVR);
+		data |= gpio.smask & gpio.state;
+		data &= ~(gpio.smask & ~gpio.state);
+		wr_reg32(info, IOVR, data);
+	}
+	spin_unlock_irqrestore(&info->lock,flags);
+
+	return 0;
+}
+
+/*
+ * get general purpose IO pin state and direction
+ */
+static int get_gpio(struct slgt_info *info, struct gpio_desc __user *user_gpio)
+{
+	struct gpio_desc gpio;
+	if (!info->gpio_present)
+		return -EINVAL;
+	gpio.state = rd_reg32(info, IOVR);
+	gpio.smask = 0xffffffff;
+	gpio.dir   = rd_reg32(info, IODR);
+	gpio.dmask = 0xffffffff;
+	if (copy_to_user(user_gpio, &gpio, sizeof(gpio)))
+		return -EFAULT;
+	DBGINFO(("%s get_gpio state=%08x dir=%08x\n",
+		 info->device_name, gpio.state, gpio.dir));
+	return 0;
+}
+
+/*
+ * conditional wait facility
+ */
+static void init_cond_wait(struct cond_wait *w, unsigned int data)
+{
+	init_waitqueue_head(&w->q);
+	init_waitqueue_entry(&w->wait, current);
+	w->data = data;
+}
+
+static void add_cond_wait(struct cond_wait **head, struct cond_wait *w)
+{
+	set_current_state(TASK_INTERRUPTIBLE);
+	add_wait_queue(&w->q, &w->wait);
+	w->next = *head;
+	*head = w;
+}
+
+static void remove_cond_wait(struct cond_wait **head, struct cond_wait *cw)
+{
+	struct cond_wait *w, *prev;
+	remove_wait_queue(&cw->q, &cw->wait);
+	set_current_state(TASK_RUNNING);
+	for (w = *head, prev = NULL ; w != NULL ; prev = w, w = w->next) {
+		if (w == cw) {
+			if (prev != NULL)
+				prev->next = w->next;
+			else
+				*head = w->next;
+			break;
+		}
+	}
+}
+
+static void flush_cond_wait(struct cond_wait **head)
+{
+	while (*head != NULL) {
+		wake_up_interruptible(&(*head)->q);
+		*head = (*head)->next;
+	}
+}
+
+/*
+ * wait for general purpose I/O pin(s) to enter specified state
+ *
+ * user_gpio fields:
+ * state - bit indicates target pin state
+ * smask - set bit indicates watched pin
+ *
+ * The wait ends when at least one watched pin enters the specified
+ * state. When 0 (no error) is returned, user_gpio->state is set to the
+ * state of all GPIO pins when the wait ends.
+ *
+ * Note: Each pin may be a dedicated input, dedicated output, or
+ * configurable input/output. The number and configuration of pins
+ * varies with the specific adapter model. Only input pins (dedicated
+ * or configured) can be monitored with this function.
+ */
+static int wait_gpio(struct slgt_info *info, struct gpio_desc __user *user_gpio)
+{
+ 	unsigned long flags;
+	int rc = 0;
+	struct gpio_desc gpio;
+	struct cond_wait wait;
+	u32 state;
+
+	if (!info->gpio_present)
+		return -EINVAL;
+	if (copy_from_user(&gpio, user_gpio, sizeof(gpio)))
+		return -EFAULT;
+	DBGINFO(("%s wait_gpio() state=%08x smask=%08x\n",
+		 info->device_name, gpio.state, gpio.smask));
+	/* ignore output pins identified by set IODR bit */
+	if ((gpio.smask &= ~rd_reg32(info, IODR)) == 0)
+		return -EINVAL;
+	init_cond_wait(&wait, gpio.smask);
+
+	spin_lock_irqsave(&info->lock, flags);
+	/* enable interrupts for watched pins */
+	wr_reg32(info, IOER, rd_reg32(info, IOER) | gpio.smask);
+	/* get current pin states */
+	state = rd_reg32(info, IOVR);
+
+	if (gpio.smask & ~(state ^ gpio.state)) {
+		/* already in target state */
+		gpio.state = state;
+	} else {
+		/* wait for target state */
+		add_cond_wait(&info->gpio_wait_q, &wait);
+		spin_unlock_irqrestore(&info->lock, flags);
+		schedule();
+		if (signal_pending(current))
+			rc = -ERESTARTSYS;
+		else
+			gpio.state = wait.data;
+		spin_lock_irqsave(&info->lock, flags);
+		remove_cond_wait(&info->gpio_wait_q, &wait);
+	}
+
+	/* disable all GPIO interrupts if no waiting processes */
+	if (info->gpio_wait_q == NULL)
+		wr_reg32(info, IOER, 0);
+	spin_unlock_irqrestore(&info->lock,flags);
+
+	if ((rc == 0) && copy_to_user(user_gpio, &gpio, sizeof(gpio)))
+		rc = -EFAULT;
+	return rc;
+}
+
@@ -3169 +3401 @@
-			for (i=1 ; i < port_count ; i++)
+			for (i=1 ; i < port_count ; i++) {
@@ -3170,0 +3403,2 @@
+				port_array[i]->gpio_present = port_array[0]->gpio_present;
+			}
@@ -4304 +4538 @@
-
+	info->gpio_present = (rd_reg32(info, JCR) & BIT5) ? 1 : 0;
--- ./projects/linux/linux-2.6.17/drivers/char/synclink_gt.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/synclink_gt.c	2006-09-20 05:42:06.000000000 +0200
@@ -49 +48,0 @@
-#include <linux/config.h>
@@ -103,0 +103 @@
+	{PCI_VENDOR_ID_MICROGATE, SYNCLINK_GT2_DEVICE_ID, PCI_ANY_ID, PCI_ANY_ID,},
@@ -394,2 +394,2 @@
-#define MASK_FRAMING BIT2
-#define MASK_BREAK   BIT3
+#define MASK_FRAMING BIT0
+#define MASK_BREAK   BIT14
@@ -873 +873 @@
-	if (!tty || !info->tx_buf)
+	if (!info->tx_buf)
@@ -927 +927 @@
-	if (!tty || !info->tx_buf)
+	if (!info->tx_buf)
@@ -1500,2 +1500,4 @@
-	hdlc_set_carrier(info->signals & SerialSignal_DCD, dev);
-
+	if (info->signals & SerialSignal_DCD)
+		netif_carrier_on(dev);
+	else
+		netif_carrier_off(dev);
@@ -1801,2 +1803,2 @@
-			if ((status = *(p+1) & (BIT9 + BIT8))) {
-				if (status & BIT9)
+			if ((status = *(p+1) & (BIT1 + BIT0))) {
+				if (status & BIT1)
@@ -1804 +1806 @@
-				else if (status & BIT8)
+				else if (status & BIT0)
@@ -1809 +1811 @@
-				if (status & BIT9)
+				if (status & BIT1)
@@ -1811 +1813 @@
-				else if (status & BIT8)
+				else if (status & BIT0)
@@ -2000,2 +2002,6 @@
-	if (info->netcount)
-		hdlc_set_carrier(info->signals & SerialSignal_DCD, info->netdev);
+	if (info->netcount) {
+		if (info->signals & SerialSignal_DCD)
+			netif_carrier_on(info->netdev);
+		else
+			netif_carrier_off(info->netdev);
+	}
@@ -2518 +2524,2 @@
-	tx_set_idle(info);
+	if (info->params.mode != MGSL_MODE_ASYNC)
+		tx_set_idle(info);
@@ -3079 +3086 @@
-	info->tmp_rbuf = kmalloc(info->max_frame_size, GFP_KERNEL);
+	info->tmp_rbuf = kmalloc(info->max_frame_size + 5, GFP_KERNEL);
@@ -3278,0 +3286,3 @@
+	case SYNCLINK_GT2_DEVICE_ID:
+		devstr = "GT2";
+		break;
@@ -3342 +3352 @@
-		info->irq_flags = SA_SHIRQ;
+		info->irq_flags = IRQF_SHARED;
@@ -3356 +3366,3 @@
-	if (pdev->device == SYNCLINK_GT4_DEVICE_ID)
+	if (pdev->device == SYNCLINK_GT2_DEVICE_ID)
+		port_count = 2;
+	else if (pdev->device == SYNCLINK_GT4_DEVICE_ID)
@@ -3943,2 +3954,0 @@
-	tx_set_idle(info);
-
@@ -4015 +4025 @@
-	switch (info->params.crc_type)
+	switch (info->params.crc_type & HDLC_CRC_MASK)
@@ -4076 +4086 @@
-	switch (info->params.crc_type)
+	switch (info->params.crc_type & HDLC_CRC_MASK)
@@ -4178 +4188,2 @@
-	unsigned char val = 0xff;
+	unsigned char val;
+	unsigned short tcr;
@@ -4180,9 +4191,29 @@
-	switch(info->idle_mode)
-	{
-	case HDLC_TXIDLE_FLAGS:          val = 0x7e; break;
-	case HDLC_TXIDLE_ALT_ZEROS_ONES: val = 0xaa; break;
-	case HDLC_TXIDLE_ZEROS:          val = 0x00; break;
-	case HDLC_TXIDLE_ONES:           val = 0xff; break;
-	case HDLC_TXIDLE_ALT_MARK_SPACE: val = 0xaa; break;
-	case HDLC_TXIDLE_SPACE:          val = 0x00; break;
-	case HDLC_TXIDLE_MARK:           val = 0xff; break;
+	/* if preamble enabled (tcr[6] == 1) then tx idle size = 8 bits
+	 * else tcr[5:4] = tx idle size: 00 = 8 bits, 01 = 16 bits
+	 */
+	tcr = rd_reg16(info, TCR);
+	if (info->idle_mode & HDLC_TXIDLE_CUSTOM_16) {
+		/* disable preamble, set idle size to 16 bits */
+		tcr = (tcr & ~(BIT6 + BIT5)) | BIT4;
+		/* MSB of 16 bit idle specified in tx preamble register (TPR) */
+		wr_reg8(info, TPR, (unsigned char)((info->idle_mode >> 8) & 0xff));
+	} else if (!(tcr & BIT6)) {
+		/* preamble is disabled, set idle size to 8 bits */
+		tcr &= ~(BIT5 + BIT4);
+	}
+	wr_reg16(info, TCR, tcr);
+
+	if (info->idle_mode & (HDLC_TXIDLE_CUSTOM_8 | HDLC_TXIDLE_CUSTOM_16)) {
+		/* LSB of custom tx idle specified in tx idle register */
+		val = (unsigned char)(info->idle_mode & 0xff);
+	} else {
+		/* standard 8 bit idle patterns */
+		switch(info->idle_mode)
+		{
+		case HDLC_TXIDLE_FLAGS:          val = 0x7e; break;
+		case HDLC_TXIDLE_ALT_ZEROS_ONES:
+		case HDLC_TXIDLE_ALT_MARK_SPACE: val = 0xaa; break;
+		case HDLC_TXIDLE_ZEROS:
+		case HDLC_TXIDLE_SPACE:          val = 0x00; break;
+		default:                         val = 0xff;
+		}
@@ -4315,0 +4347,6 @@
+	unsigned int crc_size = 0;
+
+	switch (info->params.crc_type & HDLC_CRC_MASK) {
+	case HDLC_CRC_16_CCITT: crc_size = 2; break;
+	case HDLC_CRC_32_CCITT: crc_size = 4; break;
+	}
@@ -4360 +4397 @@
-	if (info->params.crc_type == HDLC_CRC_NONE)
+	if ((info->params.crc_type & HDLC_CRC_MASK) == HDLC_CRC_NONE)
@@ -4369,5 +4406,2 @@
-	if (framesize < 2 || status & (BIT1+BIT0)) {
-		if (framesize < 2 || (status & BIT0))
-			info->icount.rxshort++;
-		else
-			info->icount.rxcrc++;
+	if (framesize < (2 + crc_size) || status & BIT0) {
+		info->icount.rxshort++;
@@ -4374,0 +4409,5 @@
+	} else if (status & BIT1) {
+		info->icount.rxcrc++;
+		if (!(info->params.crc_type & HDLC_CRC_RETURN_EX))
+			framesize = 0;
+	}
@@ -4377,12 +4416,4 @@
-		{
-			struct net_device_stats *stats = hdlc_stats(info->netdev);
-			stats->rx_errors++;
-			stats->rx_frame_errors++;
-		}
-#endif
-	} else {
-		/* adjust frame size for CRC, if any */
-		if (info->params.crc_type == HDLC_CRC_16_CCITT)
-			framesize -= 2;
-		else if (info->params.crc_type == HDLC_CRC_32_CCITT)
-			framesize -= 4;
+	if (framesize == 0) {
+		struct net_device_stats *stats = hdlc_stats(info->netdev);
+		stats->rx_errors++;
+		stats->rx_frame_errors++;
@@ -4389,0 +4421 @@
+#endif
@@ -4396 +4428,6 @@
-		if (framesize > info->max_frame_size)
+		if (!(info->params.crc_type & HDLC_CRC_RETURN_EX)) {
+			framesize -= crc_size;
+			crc_size = 0;
+		}
+
+		if (framesize > info->max_frame_size + crc_size)
@@ -4415,0 +4453,5 @@
+			if (info->params.crc_type & HDLC_CRC_RETURN_EX) {
+				*p = (status & BIT1) ? RX_CRC_ERROR : RX_OK;
+				framesize++;
+			}
+
@@ -4674 +4716 @@
-	if ((info->init_error = register_test(info)) < 0) {
+	if (register_test(info) < 0) {
@@ -4677 +4719 @@
-	} else if ((info->init_error = irq_test(info)) < 0) {
+	} else if (irq_test(info) < 0) {
@@ -4680 +4722 @@
-	} else if ((info->init_error = loopback_test(info)) < 0) {
+	} else if (loopback_test(info) < 0) {
--- ./projects/linux/linux-2.6.18/drivers/char/synclink_gt.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/synclink_gt.c	2006-11-29 22:57:37.000000000 +0100
@@ -2 +2 @@
- * $Id: synclink_gt.c,v 4.25 2006/02/06 21:20:33 paulkf Exp $
+ * $Id: synclink_gt.c,v 4.36 2006/08/28 20:47:14 paulkf Exp $
@@ -94 +94 @@
-static char *driver_version  = "$Revision: 4.25 $";
+static char *driver_version  = "$Revision: 4.36 $";
@@ -99 +99 @@
-#define MAX_DEVICES 12
+#define MAX_DEVICES 32
@@ -464 +464 @@
-static void hdlc_mode(struct slgt_info *info);
+static void sync_mode(struct slgt_info *info);
@@ -494 +494 @@
-static irqreturn_t slgt_interrupt(int irq, void *dev_id, struct pt_regs * regs);
+static irqreturn_t slgt_interrupt(int irq, void *dev_id);
@@ -884 +884,3 @@
-	if (info->params.mode == MGSL_MODE_RAW) {
+	if (info->params.mode == MGSL_MODE_RAW ||
+	    info->params.mode == MGSL_MODE_MONOSYNC ||
+	    info->params.mode == MGSL_MODE_BISYNC) {
@@ -1899,0 +1902,2 @@
+			case MGSL_MODE_MONOSYNC:
+			case MGSL_MODE_BISYNC:
@@ -2216 +2219,0 @@
- * 	regs	interrupted processor context
@@ -2218 +2221 @@
-static irqreturn_t slgt_interrupt(int irq, void *dev_id, struct pt_regs * regs)
+static irqreturn_t slgt_interrupt(int irq, void *dev_id)
@@ -2365,2 +2368 @@
-	if (info->params.mode == MGSL_MODE_HDLC ||
-	    info->params.mode == MGSL_MODE_RAW ||
+	if (info->params.mode != MGSL_MODE_ASYNC ||
@@ -2368 +2370 @@
-		hdlc_mode(info);
+		sync_mode(info);
@@ -2566,0 +2569,4 @@
+		else if (enable == 2) {
+			/* force hunt mode (write 1 to RCR[3]) */
+			wr_reg16(info, RCR, rd_reg16(info, RCR) | BIT3);
+		}
@@ -3437 +3443 @@
-static struct tty_operations ops = {
+static const struct tty_operations ops = {
@@ -3751 +3757 @@
-			(unsigned short)(rd_reg16(info, TCR) | BIT1));
+			 (unsigned short)((rd_reg16(info, TCR) | BIT1) & ~BIT2));
@@ -3778 +3784,4 @@
-				if (info->params.mode == MGSL_MODE_RAW)
+				switch(info->params.mode) {
+				case MGSL_MODE_RAW:
+				case MGSL_MODE_MONOSYNC:
+				case MGSL_MODE_BISYNC:
@@ -3780 +3789,2 @@
-				else
+					break;
+				default:
@@ -3781,0 +3792 @@
+				}
@@ -3784 +3795 @@
-			if (info->params.mode != MGSL_MODE_RAW) {
+			if (info->params.mode == MGSL_MODE_HDLC) {
@@ -3817 +3827,0 @@
-	wr_reg16(info, TCR, val);                  /* clear reset */
@@ -3985 +3995 @@
-static void hdlc_mode(struct slgt_info *info)
+static void sync_mode(struct slgt_info *info)
@@ -3995 +4005 @@
-	 * 15..13  mode, 000=HDLC 001=raw sync
+	 * 15..13  mode, 000=HDLC 001=raw 010=async 011=monosync 100=bisync
@@ -4009,2 +4019,5 @@
-	if (info->params.mode == MGSL_MODE_RAW)
-		val |= BIT13;
+	switch(info->params.mode) {
+	case MGSL_MODE_MONOSYNC: val |= BIT14 + BIT13; break;
+	case MGSL_MODE_BISYNC:   val |= BIT15; break;
+	case MGSL_MODE_RAW:      val |= BIT13; break;
+	}
@@ -4061 +4074 @@
-	 * 15..13  mode, 000=HDLC 001=raw sync
+	 * 15..13  mode, 000=HDLC 001=raw 010=async 011=monosync 100=bisync
@@ -4072,2 +4085,5 @@
-	if (info->params.mode == MGSL_MODE_RAW)
-		val |= BIT13;
+	switch(info->params.mode) {
+	case MGSL_MODE_MONOSYNC: val |= BIT14 + BIT13; break;
+	case MGSL_MODE_BISYNC:   val |= BIT15; break;
+	case MGSL_MODE_RAW:      val |= BIT13; break;
+	}
@@ -4312 +4328,4 @@
-		if (info->params.mode == MGSL_MODE_RAW)
+		switch(info->params.mode) {
+		case MGSL_MODE_RAW:
+		case MGSL_MODE_MONOSYNC:
+		case MGSL_MODE_BISYNC:
@@ -4314 +4333,2 @@
-		else
+			break;
+		default:
@@ -4315,0 +4336 @@
+		}
@@ -4479,0 +4501 @@
+	unsigned int count;
@@ -4483,4 +4505,14 @@
-	DBGDATA(info, info->rbufs[i].buf, desc_count(info->rbufs[i]), "rx");
-	DBGINFO(("rx_get_buf size=%d\n", desc_count(info->rbufs[i])));
-	ldisc_receive_buf(info->tty, info->rbufs[i].buf,
-			  info->flag_buf, desc_count(info->rbufs[i]));
+	count = desc_count(info->rbufs[i]);
+	switch(info->params.mode) {
+	case MGSL_MODE_MONOSYNC:
+	case MGSL_MODE_BISYNC:
+		/* ignore residue in byte synchronous modes */
+		if (desc_residue(info->rbufs[i]))
+			count--;
+		break;
+	}
+	DBGDATA(info, info->rbufs[i].buf, count, "rx");
+	DBGINFO(("rx_get_buf size=%d\n", count));
+	if (count)
+		ldisc_receive_buf(info->tty, info->rbufs[i].buf,
+				  info->flag_buf, count);
@@ -4552,2 +4584,7 @@
-		if (!size && info->params.mode != MGSL_MODE_RAW)
-			set_desc_eof(*d, 1); /* HDLC: set EOF of last desc */
+		/*
+		 * set EOF bit for last buffer of HDLC frame or
+		 * for every buffer in raw mode
+		 */
+		if ((!size && info->params.mode == MGSL_MODE_HDLC) ||
+		    info->params.mode == MGSL_MODE_RAW)
+			set_desc_eof(*d, 1);
--- ./projects/linux/linux-2.6.19/drivers/char/synclink_gt.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/synclink_gt.c	2007-02-04 19:44:54.000000000 +0100
@@ -86,2 +86,4 @@
-#ifdef CONFIG_HDLC_MODULE
-#define CONFIG_HDLC 1
+#if defined(CONFIG_HDLC) || (defined(CONFIG_HDLC_MODULE) && defined(CONFIG_SYNCLINK_GT_MODULE))
+#define SYNCLINK_GENERIC_HDLC 1
+#else
+#define SYNCLINK_GENERIC_HDLC 0
@@ -152 +154 @@
-static void set_termios(struct tty_struct *tty, struct termios *old_termios);
+static void set_termios(struct tty_struct *tty, struct ktermios *old_termios);
@@ -174 +176 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -362 +364 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -488 +490 @@
-static void bh_handler(void* context);
+static void bh_handler(struct work_struct *work);
@@ -817 +819 @@
-static void set_termios(struct tty_struct *tty, struct termios *old_termios)
+static void set_termios(struct tty_struct *tty, struct ktermios *old_termios)
@@ -1357 +1359 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -1881 +1883 @@
-static void bh_handler(void* context)
+static void bh_handler(struct work_struct *work)
@@ -1883 +1885 @@
-	struct slgt_info *info = context;
+	struct slgt_info *info = container_of(work, struct slgt_info, task);
@@ -2005 +2007 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -2183 +2185 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -3309 +3311 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -3329 +3331 @@
-		INIT_WORK(&info->task, bh_handler, info);
+		INIT_WORK(&info->task, bh_handler);
@@ -3491 +3493 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -3524,0 +3527 @@
+		pci_unregister_driver(&pci_driver);
@@ -3545,0 +3549,2 @@
+	serial_driver->init_termios.c_ispeed = 9600;
+	serial_driver->init_termios.c_ospeed = 9600;
@@ -4436 +4441 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -4479 +4484 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -4782 +4787 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -4802 +4807 @@
-	bh_handler(info);
+	bh_handler(&info->task);
--- ./projects/linux/linux-2.6.20/drivers/char/synclink_gt.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/synclink_gt.c	2007-04-26 05:08:32.000000000 +0200
@@ -1048 +1047,0 @@
-	wake_up_interruptible(&tty->write_wait);
@@ -1829,2 +1828 @@
-			info->rx_timer.expires = jiffies + 1;
-			add_timer(&info->rx_timer);
+			mod_timer(&info->rx_timer, jiffies + 1);
@@ -1936 +1934 @@
-	if (tty) {
+	if (tty)
@@ -1938,2 +1935,0 @@
-		wake_up_interruptible(&tty->write_wait);
-	}
@@ -3346,7 +3342,2 @@
-		init_timer(&info->tx_timer);
-		info->tx_timer.data = (unsigned long)info;
-		info->tx_timer.function = tx_timeout;
-
-		init_timer(&info->rx_timer);
-		info->rx_timer.data = (unsigned long)info;
-		info->rx_timer.function = rx_timeout;
+		setup_timer(&info->tx_timer, tx_timeout, (unsigned long)info);
+		setup_timer(&info->rx_timer, rx_timeout, (unsigned long)info);
@@ -3800,4 +3791,3 @@
-			if (info->params.mode == MGSL_MODE_HDLC) {
-				info->tx_timer.expires = jiffies + msecs_to_jiffies(5000);
-				add_timer(&info->tx_timer);
-			}
+			if (info->params.mode == MGSL_MODE_HDLC)
+				mod_timer(&info->tx_timer, jiffies +
+						msecs_to_jiffies(5000));
--- ./projects/linux/linux-2.6.21/drivers/char/synclink_gt.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/char/synclink_gt.c	2007-07-09 01:32:17.000000000 +0200
@@ -1173,0 +1174,106 @@
+ * support for 32 bit ioctl calls on 64 bit systems
+ */
+#ifdef CONFIG_COMPAT
+static long get_params32(struct slgt_info *info, struct MGSL_PARAMS32 __user *user_params)
+{
+	struct MGSL_PARAMS32 tmp_params;
+
+	DBGINFO(("%s get_params32\n", info->device_name));
+	tmp_params.mode            = (compat_ulong_t)info->params.mode;
+	tmp_params.loopback        = info->params.loopback;
+	tmp_params.flags           = info->params.flags;
+	tmp_params.encoding        = info->params.encoding;
+	tmp_params.clock_speed     = (compat_ulong_t)info->params.clock_speed;
+	tmp_params.addr_filter     = info->params.addr_filter;
+	tmp_params.crc_type        = info->params.crc_type;
+	tmp_params.preamble_length = info->params.preamble_length;
+	tmp_params.preamble        = info->params.preamble;
+	tmp_params.data_rate       = (compat_ulong_t)info->params.data_rate;
+	tmp_params.data_bits       = info->params.data_bits;
+	tmp_params.stop_bits       = info->params.stop_bits;
+	tmp_params.parity          = info->params.parity;
+	if (copy_to_user(user_params, &tmp_params, sizeof(struct MGSL_PARAMS32)))
+		return -EFAULT;
+	return 0;
+}
+
+static long set_params32(struct slgt_info *info, struct MGSL_PARAMS32 __user *new_params)
+{
+	struct MGSL_PARAMS32 tmp_params;
+
+	DBGINFO(("%s set_params32\n", info->device_name));
+	if (copy_from_user(&tmp_params, new_params, sizeof(struct MGSL_PARAMS32)))
+		return -EFAULT;
+
+	spin_lock(&info->lock);
+	info->params.mode            = tmp_params.mode;
+	info->params.loopback        = tmp_params.loopback;
+	info->params.flags           = tmp_params.flags;
+	info->params.encoding        = tmp_params.encoding;
+	info->params.clock_speed     = tmp_params.clock_speed;
+	info->params.addr_filter     = tmp_params.addr_filter;
+	info->params.crc_type        = tmp_params.crc_type;
+	info->params.preamble_length = tmp_params.preamble_length;
+	info->params.preamble        = tmp_params.preamble;
+	info->params.data_rate       = tmp_params.data_rate;
+	info->params.data_bits       = tmp_params.data_bits;
+	info->params.stop_bits       = tmp_params.stop_bits;
+	info->params.parity          = tmp_params.parity;
+	spin_unlock(&info->lock);
+
+ 	change_params(info);
+
+	return 0;
+}
+
+static long slgt_compat_ioctl(struct tty_struct *tty, struct file *file,
+			 unsigned int cmd, unsigned long arg)
+{
+	struct slgt_info *info = tty->driver_data;
+	int rc = -ENOIOCTLCMD;
+
+	if (sanity_check(info, tty->name, "compat_ioctl"))
+		return -ENODEV;
+	DBGINFO(("%s compat_ioctl() cmd=%08X\n", info->device_name, cmd));
+
+	switch (cmd) {
+
+	case MGSL_IOCSPARAMS32:
+		rc = set_params32(info, compat_ptr(arg));
+		break;
+
+	case MGSL_IOCGPARAMS32:
+		rc = get_params32(info, compat_ptr(arg));
+		break;
+
+	case MGSL_IOCGPARAMS:
+	case MGSL_IOCSPARAMS:
+	case MGSL_IOCGTXIDLE:
+	case MGSL_IOCGSTATS:
+	case MGSL_IOCWAITEVENT:
+	case MGSL_IOCGIF:
+	case MGSL_IOCSGPIO:
+	case MGSL_IOCGGPIO:
+	case MGSL_IOCWAITGPIO:
+	case TIOCGICOUNT:
+		rc = ioctl(tty, file, cmd, (unsigned long)(compat_ptr(arg)));
+		break;
+
+	case MGSL_IOCSTXIDLE:
+	case MGSL_IOCTXENABLE:
+	case MGSL_IOCRXENABLE:
+	case MGSL_IOCTXABORT:
+	case TIOCMIWAIT:
+	case MGSL_IOCSIF:
+		rc = ioctl(tty, file, cmd, arg);
+		break;
+	}
+
+	DBGINFO(("%s compat_ioctl() cmd=%08X rc=%d\n", info->device_name, cmd, rc));
+	return rc;
+}
+#else
+#define slgt_compat_ioctl NULL
+#endif /* ifdef CONFIG_COMPAT */
+
+/*
@@ -3417,0 +3524,3 @@
+
+	for (i=0; i < port_count; ++i)
+		tty_register_device(serial_driver, port_array[i]->line, &(port_array[i]->pdev->dev));
@@ -3445,0 +3555 @@
+	.compat_ioctl = slgt_compat_ioctl,
@@ -3468,0 +3579,2 @@
+		for (info=slgt_device_list ; info != NULL ; info=info->next_device)
+			tty_unregister_device(serial_driver, info->line);
@@ -3509,13 +3620,0 @@
-	slgt_device_count = 0;
-	if ((rc = pci_register_driver(&pci_driver)) < 0) {
-		printk("%s pci_register_driver error=%d\n", driver_name, rc);
-		return rc;
-	}
-	pci_registered = 1;
-
-	if (!slgt_device_list) {
-		printk("%s no devices found\n",driver_name);
-		pci_unregister_driver(&pci_driver);
-		return -ENODEV;
-	}
-
@@ -3524,2 +3623,2 @@
-		rc = -ENOMEM;
-		goto error;
+		printk("%s can't allocate tty driver\n", driver_name);
+		return -ENOMEM;
@@ -3542 +3641 @@
-	serial_driver->flags = TTY_DRIVER_REAL_RAW;
+	serial_driver->flags = TTY_DRIVER_REAL_RAW | TTY_DRIVER_DYNAMIC_DEV;
@@ -3554,0 +3654,10 @@
+	slgt_device_count = 0;
+	if ((rc = pci_register_driver(&pci_driver)) < 0) {
+		printk("%s pci_register_driver error=%d\n", driver_name, rc);
+		goto error;
+	}
+	pci_registered = 1;
+
+	if (!slgt_device_list)
+		printk("%s no devices found\n",driver_name);
+
--- ./projects/linux/linux-2.6.22/drivers/char/synclink_gt.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/synclink_gt.c	2007-10-09 22:31:38.000000000 +0200
@@ -2 +2 @@
- * $Id: synclink_gt.c,v 4.36 2006/08/28 20:47:14 paulkf Exp $
+ * $Id: synclink_gt.c,v 4.50 2007/07/25 19:29:25 paulkf Exp $
@@ -96 +96 @@
-static char *driver_version  = "$Revision: 4.36 $";
+static char *driver_version  = "$Revision: 4.50 $";
@@ -147,2 +146,0 @@
-#define RELEVANT_IFLAG(iflag) (iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
-
@@ -481,0 +480 @@
+static void tdma_start(struct slgt_info *info);
@@ -826,6 +824,0 @@
-	/* just return if nothing has changed */
-	if ((tty->termios->c_cflag == old_termios->c_cflag)
-	    && (RELEVANT_IFLAG(tty->termios->c_iflag)
-		== RELEVANT_IFLAG(old_termios->c_iflag)))
-		return;
-
@@ -914,0 +908,2 @@
+		else
+			tdma_start(info);
@@ -1572,0 +1568,3 @@
+	if (!try_module_get(THIS_MODULE))
+		return -EBUSY;
+
@@ -1641,0 +1640 @@
+	module_put(THIS_MODULE);
@@ -3425 +3424 @@
-	info = kmalloc(sizeof(struct slgt_info), GFP_KERNEL);
+	info = kzalloc(sizeof(struct slgt_info), GFP_KERNEL);
@@ -3431 +3429,0 @@
-		memset(info, 0, sizeof(struct slgt_info));
@@ -3883,17 +3880,0 @@
-
-			if (!(rd_reg32(info, TDCSR) & BIT0)) {
-				/* tx DMA stopped, restart tx DMA */
-				tdma_reset(info);
-				/* set 1st descriptor address */
-				wr_reg32(info, TDDAR, info->tbufs[info->tbuf_start].pdesc);
-				switch(info->params.mode) {
-				case MGSL_MODE_RAW:
-				case MGSL_MODE_MONOSYNC:
-				case MGSL_MODE_BISYNC:
-					wr_reg32(info, TDCSR, BIT2 + BIT0); /* IRQ + DMA enable */
-					break;
-				default:
-					wr_reg32(info, TDCSR, BIT0); /* DMA enable */
-				}
-			}
-
@@ -3904,4 +3884,0 @@
-			tdma_reset(info);
-			/* set 1st descriptor address */
-			wr_reg32(info, TDDAR, info->tbufs[info->tbuf_start].pdesc);
-
@@ -3912,3 +3888,0 @@
-
-			/* enable tx DMA */
-			wr_reg32(info, TDCSR, BIT0);
@@ -3916 +3890 @@
-
+		tdma_start(info);
@@ -3920,0 +3895,38 @@
+/*
+ * start transmit DMA if inactive and there are unsent buffers
+ */
+static void tdma_start(struct slgt_info *info)
+{
+	unsigned int i;
+
+	if (rd_reg32(info, TDCSR) & BIT0)
+		return;
+
+	/* transmit DMA inactive, check for unsent buffers */
+	i = info->tbuf_start;
+	while (!desc_count(info->tbufs[i])) {
+		if (++i == info->tbuf_count)
+			i = 0;
+		if (i == info->tbuf_current)
+			return;
+	}
+	info->tbuf_start = i;
+
+	/* there are unsent buffers, start transmit DMA */
+
+	/* reset needed if previous error condition */
+	tdma_reset(info);
+
+	/* set 1st descriptor address */
+	wr_reg32(info, TDDAR, info->tbufs[info->tbuf_start].pdesc);
+	switch(info->params.mode) {
+	case MGSL_MODE_RAW:
+	case MGSL_MODE_MONOSYNC:
+	case MGSL_MODE_BISYNC:
+		wr_reg32(info, TDCSR, BIT2 + BIT0); /* IRQ + DMA enable */
+		break;
+	default:
+		wr_reg32(info, TDCSR, BIT0); /* DMA enable */
+	}
+}
+
@@ -4654,2 +4666,2 @@
-	/* last buffer with zero count may be in use, assume it is */
-	if (count)
+	/* if tx DMA active, last zero count buffer is in use */
+	if (count && (rd_reg32(info, TDCSR) & BIT0))
--- ./projects/linux/linux-2.6.23/drivers/char/synclink_gt.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/synclink_gt.c	2008-01-24 23:58:37.000000000 +0100
@@ -209,4 +209,4 @@
-	unsigned short count;
-	unsigned short status;
-	unsigned int pbuf;  /* physical address of data buffer */
-	unsigned int next;  /* physical address of next descriptor */
+	__le16 count;
+	__le16 status;
+	__le32 pbuf;  /* physical address of data buffer */
+	__le32 next;  /* physical address of next descriptor */
--- ./projects/linux/linux-2.6.24/drivers/char/synclink_gt.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/synclink_gt.c	2008-04-17 04:49:44.000000000 +0200
@@ -75,0 +76 @@
+#include <linux/synclink.h>
@@ -84,2 +84,0 @@
-#include "linux/synclink.h"
-
@@ -2043 +2042 @@
-static void dsr_change(struct slgt_info *info)
+static void dsr_change(struct slgt_info *info, unsigned short status)
@@ -2045 +2044,7 @@
-	get_signals(info);
+	if (status & BIT3) {
+		info->signals |= SerialSignal_DSR;
+		info->input_signal_events.dsr_up++;
+	} else {
+		info->signals &= ~SerialSignal_DSR;
+		info->input_signal_events.dsr_down++;
+	}
@@ -2052,4 +2056,0 @@
-	if (info->signals & SerialSignal_DSR)
-		info->input_signal_events.dsr_up++;
-	else
-		info->input_signal_events.dsr_down++;
@@ -2061 +2062 @@
-static void cts_change(struct slgt_info *info)
+static void cts_change(struct slgt_info *info, unsigned short status)
@@ -2063 +2064,7 @@
-	get_signals(info);
+	if (status & BIT2) {
+		info->signals |= SerialSignal_CTS;
+		info->input_signal_events.cts_up++;
+	} else {
+		info->signals &= ~SerialSignal_CTS;
+		info->input_signal_events.cts_down++;
+	}
@@ -2070,4 +2076,0 @@
-	if (info->signals & SerialSignal_CTS)
-		info->input_signal_events.cts_up++;
-	else
-		info->input_signal_events.cts_down++;
@@ -2094 +2097 @@
-static void dcd_change(struct slgt_info *info)
+static void dcd_change(struct slgt_info *info, unsigned short status)
@@ -2096 +2099,7 @@
-	get_signals(info);
+	if (status & BIT1) {
+		info->signals |= SerialSignal_DCD;
+		info->input_signal_events.dcd_up++;
+	} else {
+		info->signals &= ~SerialSignal_DCD;
+		info->input_signal_events.dcd_down++;
+	}
@@ -2103,5 +2111,0 @@
-	if (info->signals & SerialSignal_DCD) {
-		info->input_signal_events.dcd_up++;
-	} else {
-		info->input_signal_events.dcd_down++;
-	}
@@ -2130 +2134 @@
-static void ri_change(struct slgt_info *info)
+static void ri_change(struct slgt_info *info, unsigned short status)
@@ -2132 +2136,7 @@
-	get_signals(info);
+	if (status & BIT0) {
+		info->signals |= SerialSignal_RI;
+		info->input_signal_events.ri_up++;
+	} else {
+		info->signals &= ~SerialSignal_RI;
+		info->input_signal_events.ri_down++;
+	}
@@ -2138,6 +2148 @@
-	info->icount.dcd++;
-	if (info->signals & SerialSignal_RI) {
-		info->input_signal_events.ri_up++;
-	} else {
-		info->input_signal_events.ri_down++;
-	}
+	info->icount.rng++;
@@ -2194 +2199 @@
-		dsr_change(info);
+		dsr_change(info, status);
@@ -2196 +2201 @@
-		cts_change(info);
+		cts_change(info, status);
@@ -2198 +2203 @@
-		dcd_change(info);
+		dcd_change(info, status);
@@ -2200 +2205 @@
-		ri_change(info);
+		ri_change(info, status);
--- ./projects/linux/linux-2.6.25/drivers/char/synclink_gt.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/synclink_gt.c	2008-07-13 23:51:29.000000000 +0200
@@ -120 +120 @@
-static int pci_registered;
+static bool pci_registered;
@@ -154 +154 @@
-static void put_char(struct tty_struct *tty, unsigned char ch);
+static int put_char(struct tty_struct *tty, unsigned char ch);
@@ -292,2 +292,2 @@
-	int bh_requested;
-	int bh_running;
+	bool bh_requested;
+	bool bh_running;
@@ -296,2 +296,2 @@
-	int irq_requested;	/* nonzero if IRQ requested */
-	int irq_occurred;	/* for diagnostics use */
+	bool irq_requested;	/* true if IRQ requested */
+	bool irq_occurred;	/* for diagnostics use */
@@ -307 +307 @@
-	int reg_addr_requested;
+	bool reg_addr_requested;
@@ -318,2 +318,2 @@
-	int rx_enabled;
-	int rx_restart;
+	bool rx_enabled;
+	bool rx_restart;
@@ -321,2 +321,2 @@
-	int tx_enabled;
-	int tx_active;
+	bool tx_enabled;
+	bool tx_active;
@@ -332 +332 @@
-	BOOLEAN drop_rts_on_tx_done;
+	bool drop_rts_on_tx_done;
@@ -470,2 +470,2 @@
-static int  rx_get_frame(struct slgt_info *info);
-static int  rx_get_buf(struct slgt_info *info);
+static bool rx_get_frame(struct slgt_info *info);
+static bool rx_get_buf(struct slgt_info *info);
@@ -494 +493,0 @@
-static irqreturn_t slgt_interrupt(int irq, void *dev_id);
@@ -775,2 +774 @@
-	if (tty->driver->flush_buffer)
-		tty->driver->flush_buffer(tty);
+	flush_buffer(tty);
@@ -917 +915 @@
-static void put_char(struct tty_struct *tty, unsigned char ch)
+static int put_char(struct tty_struct *tty, unsigned char ch)
@@ -920,0 +919 @@
+	int ret = 0;
@@ -923 +922 @@
-		return;
+		return 0;
@@ -926 +925 @@
-		return;
+		return 0;
@@ -928 +927 @@
-	if (!info->tx_active && (info->tx_count < info->max_frame_size))
+	if (!info->tx_active && (info->tx_count < info->max_frame_size)) {
@@ -929,0 +929,2 @@
+		ret = 1;
+	}
@@ -930,0 +932 @@
+	return ret;
@@ -970,0 +973,2 @@
+	lock_kernel();
+
@@ -987,0 +992 @@
+	unlock_kernel();
@@ -1100,0 +1106 @@
+	int ret;
@@ -1111,0 +1118,2 @@
+	lock_kernel();
+
@@ -1114 +1122,2 @@
-		return get_params(info, argp);
+		ret = get_params(info, argp);
+		break;
@@ -1116 +1125,2 @@
-		return set_params(info, argp);
+		ret = set_params(info, argp);
+		break;
@@ -1118 +1128,2 @@
-		return get_txidle(info, argp);
+		ret = get_txidle(info, argp);
+		break;
@@ -1120 +1131,2 @@
-		return set_txidle(info, (int)arg);
+		ret = set_txidle(info, (int)arg);
+		break;
@@ -1122 +1134,2 @@
-		return tx_enable(info, (int)arg);
+		ret = tx_enable(info, (int)arg);
+		break;
@@ -1124 +1137,2 @@
-		return rx_enable(info, (int)arg);
+		ret = rx_enable(info, (int)arg);
+		break;
@@ -1126 +1140,2 @@
-		return tx_abort(info);
+		ret = tx_abort(info);
+		break;
@@ -1128 +1143,2 @@
-		return get_stats(info, argp);
+		ret = get_stats(info, argp);
+		break;
@@ -1130 +1146,2 @@
-		return wait_mgsl_event(info, argp);
+		ret = wait_mgsl_event(info, argp);
+		break;
@@ -1132 +1149,2 @@
-		return modem_input_wait(info,(int)arg);
+		ret = modem_input_wait(info,(int)arg);
+		break;
@@ -1134 +1152,2 @@
-		return get_interface(info, argp);
+		ret = get_interface(info, argp);
+		break;
@@ -1136 +1155,2 @@
-		return set_interface(info,(int)arg);
+		ret = set_interface(info,(int)arg);
+		break;
@@ -1138 +1158,2 @@
-		return set_gpio(info, argp);
+		ret = set_gpio(info, argp);
+		break;
@@ -1140 +1161,2 @@
-		return get_gpio(info, argp);
+		ret = get_gpio(info, argp);
+		break;
@@ -1142 +1164,2 @@
-		return wait_gpio(info, argp);
+		ret = wait_gpio(info, argp);
+		break;
@@ -1159,2 +1182,3 @@
-			return -EFAULT;
-		return 0;
+			ret = -EFAULT;
+		ret = 0;
+		break;
@@ -1162 +1186 @@
-		return -ENOIOCTLCMD;
+		ret = -ENOIOCTLCMD;
@@ -1164 +1188,2 @@
-	return 0;
+	unlock_kernel();
+	return ret;
@@ -1972,2 +1997,2 @@
-		info->bh_running   = 0;
-		info->bh_requested = 0;
+		info->bh_running = false;
+		info->bh_requested = false;
@@ -1992 +2017 @@
-	info->bh_running = 1;
+	info->bh_running = true;
@@ -2162 +2187 @@
-	info->irq_occurred = 1;
+	info->irq_occurred = true;
@@ -2229 +2254 @@
-		info->rx_restart = 1;
+		info->rx_restart = true;
@@ -2280 +2305 @@
-		info->tx_active = 0;
+		info->tx_active = false;
@@ -2287 +2312 @@
-			info->drop_rts_on_tx_done = 0;
+			info->drop_rts_on_tx_done = false;
@@ -2329 +2354 @@
-static irqreturn_t slgt_interrupt(int irq, void *dev_id)
+static irqreturn_t slgt_interrupt(int dummy, void *dev_id)
@@ -2331 +2356 @@
-	struct slgt_info *info;
+	struct slgt_info *info = dev_id;
@@ -2335,5 +2360 @@
-	DBGISR(("slgt_interrupt irq=%d entry\n", irq));
-
-	info = dev_id;
-	if (!info)
-		return IRQ_NONE;
+	DBGISR(("slgt_interrupt irq=%d entry\n", info->irq_level));
@@ -2345 +2366 @@
-		info->irq_occurred = 1;
+		info->irq_occurred = true;
@@ -2382 +2403 @@
-			port->bh_requested = 1;
+			port->bh_requested = true;
@@ -2388 +2409 @@
-	DBGISR(("slgt_interrupt irq=%d exit\n", irq));
+	DBGISR(("slgt_interrupt irq=%d exit\n", info->irq_level));
@@ -3118 +3139,2 @@
-	int		do_clocal = 0, extra_count = 0;
+	bool		do_clocal = false;
+	bool		extra_count = false;
@@ -3130 +3152 @@
-		do_clocal = 1;
+		do_clocal = true;
@@ -3144 +3166 @@
-		extra_count = 1;
+		extra_count = true;
@@ -3329 +3351 @@
-		info->reg_addr_requested = 1;
+		info->reg_addr_requested = true;
@@ -3331 +3353 @@
-	info->reg_addr = ioremap(info->phys_reg_addr, SLGT_REG_SIZE);
+	info->reg_addr = ioremap_nocache(info->phys_reg_addr, SLGT_REG_SIZE);
@@ -3349 +3371 @@
-		info->irq_requested = 0;
+		info->irq_requested = false;
@@ -3354 +3376 @@
-		info->reg_addr_requested = 0;
+		info->reg_addr_requested = false;
@@ -3519 +3541 @@
-			port_array[0]->irq_requested = 1;
+			port_array[0]->irq_requested = true;
@@ -3662 +3684 @@
-	pci_registered = 1;
+	pci_registered = true;
@@ -3820,2 +3842,2 @@
-	info->rx_enabled = 0;
-	info->rx_restart = 0;
+	info->rx_enabled = false;
+	info->rx_restart = false;
@@ -3857,2 +3879,2 @@
-	info->rx_restart = 0;
-	info->rx_enabled = 1;
+	info->rx_restart = false;
+	info->rx_enabled = true;
@@ -3866 +3888 @@
-		info->tx_enabled = TRUE;
+		info->tx_enabled = true;
@@ -3870 +3892 @@
-		info->drop_rts_on_tx_done = 0;
+		info->drop_rts_on_tx_done = false;
@@ -3878 +3900 @@
-					info->drop_rts_on_tx_done = 1;
+					info->drop_rts_on_tx_done = true;
@@ -3896 +3918 @@
-		info->tx_active = 1;
+		info->tx_active = true;
@@ -3957,2 +3979,2 @@
-	info->tx_enabled = 0;
-	info->tx_active  = 0;
+	info->tx_enabled = false;
+	info->tx_active = false;
@@ -4478 +4500 @@
- * return 1 if frame available, otherwise 0
+ * return true if frame available, otherwise false
@@ -4480 +4502 @@
-static int rx_get_frame(struct slgt_info *info)
+static bool rx_get_frame(struct slgt_info *info)
@@ -4485 +4506,0 @@
-	int rc = 0;
@@ -4609 +4630 @@
-	rc = 1;
+	return true;
@@ -4612 +4633 @@
-	return rc;
+	return false;
@@ -4617 +4638 @@
- * return 1 if buffer available, otherwise 0
+ * return true if buffer available, otherwise false
@@ -4619 +4640 @@
-static int rx_get_buf(struct slgt_info *info)
+static bool rx_get_buf(struct slgt_info *info)
@@ -4625 +4646 @@
-		return 0;
+		return false;
@@ -4641 +4662 @@
-	return 1;
+	return true;
@@ -4766 +4787 @@
-	info->irq_occurred = FALSE;
+	info->irq_occurred = false;
@@ -4899 +4920 @@
-	info->tx_active = 0;
+	info->tx_active = false;
--- ./projects/linux/linux-2.6.26/drivers/char/synclink_gt.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/char/synclink_gt.c	2008-10-10 00:13:53.000000000 +0200
@@ -50 +49,0 @@
-#include <linux/version.h>
@@ -131 +129,0 @@
-static int dosyncppp[MAX_DEVICES];
@@ -136 +133,0 @@
-module_param_array(dosyncppp, int, NULL, 0);
@@ -141 +137,0 @@
-MODULE_PARM_DESC(dosyncppp, "Enable synchronous net device, 0=disable 1=enable");
@@ -168 +164 @@
-static void set_break(struct tty_struct *tty, int break_state);
+static int set_break(struct tty_struct *tty, int break_state);
@@ -216,0 +213 @@
+	unsigned short buf_count;
@@ -246,0 +244 @@
+	struct tty_port port;
@@ -251 +248,0 @@
-	int flags;
@@ -263 +259,0 @@
-	int			count;		/* count of opens */
@@ -265,2 +260,0 @@
-	unsigned short		close_delay;
-	unsigned short		closing_wait;	/* time to wait before closing */
@@ -270 +263,0 @@
-	struct tty_struct 	*tty;
@@ -273 +265,0 @@
-	int			blocked_open;	/* # of blocked opens */
@@ -277,3 +268,0 @@
-	wait_queue_head_t	open_wait;
-	wait_queue_head_t	close_wait;
-
@@ -313 +302 @@
-	unsigned int raw_rx_size;
+	unsigned int rbuf_fill_level;
@@ -359 +347,0 @@
-	int dosyncppp;
@@ -476,0 +465 @@
+static unsigned int tbuf_bytes(struct slgt_info *info);
@@ -524 +513 @@
-static void set_break(struct tty_struct *tty, int break_state);
+static int set_break(struct tty_struct *tty, int break_state);
@@ -644,2 +633,2 @@
-		if (ld->receive_buf)
-			ld->receive_buf(tty, data, flags, count);
+		if (ld->ops->receive_buf)
+			ld->ops->receive_buf(tty, data, flags, count);
@@ -675 +664 @@
-	info->tty = tty;
+	info->port.tty = tty;
@@ -677 +666 @@
-	DBGINFO(("%s open, old ref count = %d\n", info->device_name, info->count));
+	DBGINFO(("%s open, old ref count = %d\n", info->device_name, info->port.count));
@@ -680,4 +669,4 @@
-	if (tty_hung_up_p(filp) || info->flags & ASYNC_CLOSING){
-		if (info->flags & ASYNC_CLOSING)
-			interruptible_sleep_on(&info->close_wait);
-		retval = ((info->flags & ASYNC_HUP_NOTIFY) ?
+	if (tty_hung_up_p(filp) || info->port.flags & ASYNC_CLOSING){
+		if (info->port.flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&info->port.close_wait);
+		retval = ((info->port.flags & ASYNC_HUP_NOTIFY) ?
@@ -688 +677 @@
-	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+	info->port.tty->low_latency = (info->port.flags & ASYNC_LOW_LATENCY) ? 1 : 0;
@@ -696 +685 @@
-	info->count++;
+	info->port.count++;
@@ -699 +688 @@
-	if (info->count == 1) {
+	if (info->port.count == 1) {
@@ -717,3 +706,3 @@
-			info->tty = NULL; /* tty layer will release tty struct */
-		if(info->count)
-			info->count--;
+			info->port.tty = NULL; /* tty layer will release tty struct */
+		if(info->port.count)
+			info->port.count--;
@@ -732 +721 @@
-	DBGINFO(("%s close entry, count=%d\n", info->device_name, info->count));
+	DBGINFO(("%s close entry, count=%d\n", info->device_name, info->port.count));
@@ -734 +723 @@
-	if (!info->count)
+	if (!info->port.count)
@@ -740 +729 @@
-	if ((tty->count == 1) && (info->count != 1)) {
+	if ((tty->count == 1) && (info->port.count != 1)) {
@@ -743 +732 @@
-		 * info->count should be one in this case.
+		 * info->port.count should be one in this case.
@@ -747,2 +736,2 @@
-		       "info->count=%d\n", info->device_name, info->count));
-		info->count = 1;
+		       "info->port.count=%d\n", info->device_name, info->port.count));
+		info->port.count = 1;
@@ -751 +740 @@
-	info->count--;
+	info->port.count--;
@@ -754 +743 @@
-	if (info->count)
+	if (info->port.count)
@@ -757 +746 @@
-	info->flags |= ASYNC_CLOSING;
+	info->port.flags |= ASYNC_CLOSING;
@@ -767 +756 @@
-	if (info->closing_wait != ASYNC_CLOSING_WAIT_NONE) {
+	if (info->port.closing_wait != ASYNC_CLOSING_WAIT_NONE) {
@@ -769 +758 @@
-		tty_wait_until_sent(tty, info->closing_wait);
+		tty_wait_until_sent(tty, info->port.closing_wait);
@@ -772 +761 @@
- 	if (info->flags & ASYNC_INITIALIZED)
+ 	if (info->port.flags & ASYNC_INITIALIZED)
@@ -780 +769 @@
-	info->tty = NULL;
+	info->port.tty = NULL;
@@ -782,3 +771,3 @@
-	if (info->blocked_open) {
-		if (info->close_delay) {
-			msleep_interruptible(jiffies_to_msecs(info->close_delay));
+	if (info->port.blocked_open) {
+		if (info->port.close_delay) {
+			msleep_interruptible(jiffies_to_msecs(info->port.close_delay));
@@ -786 +775 @@
-		wake_up_interruptible(&info->open_wait);
+		wake_up_interruptible(&info->port.open_wait);
@@ -789 +778 @@
-	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
+	info->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
@@ -791 +780 @@
-	wake_up_interruptible(&info->close_wait);
+	wake_up_interruptible(&info->port.close_wait);
@@ -794 +783 @@
-	DBGINFO(("%s close exit, count=%d\n", tty->driver->name, info->count));
+	DBGINFO(("%s close exit, count=%d\n", tty->driver->name, info->port.count));
@@ -808,3 +797,3 @@
-	info->count = 0;
-	info->flags &= ~ASYNC_NORMAL_ACTIVE;
-	info->tty = NULL;
+	info->port.count = 0;
+	info->port.flags &= ~ASYNC_NORMAL_ACTIVE;
+	info->port.tty = NULL;
@@ -812 +801 @@
-	wake_up_interruptible(&info->open_wait);
+	wake_up_interruptible(&info->port.open_wait);
@@ -859,0 +849 @@
+	unsigned int bufs_needed;
@@ -876,18 +866,4 @@
-	if (info->params.mode == MGSL_MODE_RAW ||
-	    info->params.mode == MGSL_MODE_MONOSYNC ||
-	    info->params.mode == MGSL_MODE_BISYNC) {
-		unsigned int bufs_needed = (count/DMABUFSIZE);
-		unsigned int bufs_free = free_tbuf_count(info);
-		if (count % DMABUFSIZE)
-			++bufs_needed;
-		if (bufs_needed > bufs_free)
-			goto cleanup;
-	} else {
-		if (info->tx_active)
-			goto cleanup;
-		if (info->tx_count) {
-			/* send accumulated data from send_char() calls */
-			/* as frame and wait before accepting more data. */
-			tx_load(info, info->tx_buf, info->tx_count);
-			goto start;
-		}
+	if (!info->tx_active && info->tx_count) {
+		/* send accumulated data from send_char() */
+		tx_load(info, info->tx_buf, info->tx_count);
+		goto start;
@@ -894,0 +871,5 @@
+	bufs_needed = (count/DMABUFSIZE);
+	if (count % DMABUFSIZE)
+		++bufs_needed;
+	if (bufs_needed > free_tbuf_count(info))
+		goto cleanup;
@@ -962 +943 @@
-	if (!(info->flags & ASYNC_INITIALIZED))
+	if (!(info->port.flags & ASYNC_INITIALIZED))
@@ -1406,0 +1388 @@
+	int count;
@@ -1409,2 +1391,3 @@
-	DBGINFO(("%s chars_in_buffer()=%d\n", info->device_name, info->tx_count));
-	return info->tx_count;
+	count = tbuf_bytes(info);
+	DBGINFO(("%s chars_in_buffer()=%d\n", info->device_name, count));
+	return count;
@@ -1463 +1446 @@
-static void set_break(struct tty_struct *tty, int break_state)
+static int set_break(struct tty_struct *tty, int break_state)
@@ -1470 +1453 @@
-		return;
+		return -EINVAL;
@@ -1480,0 +1464 @@
+	return 0;
@@ -1503 +1487 @@
-	if (info->count)
+	if (info->port.count)
@@ -1547 +1530,0 @@
-	struct net_device_stats *stats = hdlc_stats(dev);
@@ -1560,2 +1543,2 @@
-	stats->tx_packets++;
-	stats->tx_bytes += skb->len;
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
@@ -1603 +1586 @@
-	if (info->count != 0 || info->netcount != 0) {
+	if (info->port.count != 0 || info->netcount != 0) {
@@ -1688 +1671 @@
-	if (info->count)
+	if (info->port.count)
@@ -1778 +1760,0 @@
-	struct net_device_stats *stats = hdlc_stats(dev);
@@ -1783,2 +1765,2 @@
-	stats->tx_errors++;
-	stats->tx_aborted_errors++;
+	dev->stats.tx_errors++;
+	dev->stats.tx_aborted_errors++;
@@ -1817 +1798,0 @@
-	struct net_device_stats *stats = hdlc_stats(dev);
@@ -1823 +1804 @@
-		stats->rx_dropped++;
+		dev->stats.rx_dropped++;
@@ -1827 +1808 @@
-	memcpy(skb_put(skb, size),buf,size);
+	memcpy(skb_put(skb, size), buf, size);
@@ -1829 +1810 @@
-	skb->protocol = hdlc_type_trans(skb, info->netdev);
+	skb->protocol = hdlc_type_trans(skb, dev);
@@ -1831,2 +1812,2 @@
-	stats->rx_packets++;
-	stats->rx_bytes += size;
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += size;
@@ -1836 +1817 @@
-	info->netdev->last_rx = jiffies;
+	dev->last_rx = jiffies;
@@ -1909 +1890 @@
- 	struct tty_struct *tty = info->tty;
+ 	struct tty_struct *tty = info->port.tty;
@@ -2060 +2041 @@
-	struct tty_struct *tty = info->tty;
+	struct tty_struct *tty = info->port.tty;
@@ -2106,3 +2087,3 @@
-	if (info->flags & ASYNC_CTS_FLOW) {
-		if (info->tty) {
-			if (info->tty->hw_stopped) {
+	if (info->port.flags & ASYNC_CTS_FLOW) {
+		if (info->port.tty) {
+			if (info->port.tty->hw_stopped) {
@@ -2110 +2091 @@
-		 			info->tty->hw_stopped = 0;
+		 			info->port.tty->hw_stopped = 0;
@@ -2116 +2097 @@
-		 			info->tty->hw_stopped = 1;
+		 			info->port.tty->hw_stopped = 1;
@@ -2149 +2130 @@
-	if (info->flags & ASYNC_CHECK_CD) {
+	if (info->port.flags & ASYNC_CHECK_CD) {
@@ -2151 +2132 @@
-			wake_up_interruptible(&info->open_wait);
+			wake_up_interruptible(&info->port.open_wait);
@@ -2153,2 +2134,2 @@
-			if (info->tty)
-				tty_hangup(info->tty);
+			if (info->port.tty)
+				tty_hangup(info->port.tty);
@@ -2197 +2178 @@
-			if (info->tty) {
+			if (info->port.tty) {
@@ -2200,3 +2181,3 @@
-						tty_insert_flip_char(info->tty, 0, TTY_BREAK);
-						if (info->flags & ASYNC_SAK)
-							do_SAK(info->tty);
+						tty_insert_flip_char(info->port.tty, 0, TTY_BREAK);
+						if (info->port.flags & ASYNC_SAK)
+							do_SAK(info->port.tty);
@@ -2322 +2303 @@
-			if (info->tty && (info->tty->stopped || info->tty->hw_stopped)) {
+			if (info->port.tty && (info->port.tty->stopped || info->port.tty->hw_stopped)) {
@@ -2398 +2379 @@
-		if (port && (port->count || port->netcount) &&
+		if (port && (port->port.count || port->netcount) &&
@@ -2417 +2398 @@
-	if (info->flags & ASYNC_INITIALIZED)
+	if (info->port.flags & ASYNC_INITIALIZED)
@@ -2435,2 +2416,2 @@
-	if (info->tty)
-		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->port.tty)
+		clear_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -2438 +2419 @@
-	info->flags |= ASYNC_INITIALIZED;
+	info->port.flags |= ASYNC_INITIALIZED;
@@ -2450 +2431 @@
-	if (!(info->flags & ASYNC_INITIALIZED))
+	if (!(info->port.flags & ASYNC_INITIALIZED))
@@ -2473 +2454 @@
- 	if (!info->tty || info->tty->termios->c_cflag & HUPCL) {
+ 	if (!info->port.tty || info->port.tty->termios->c_cflag & HUPCL) {
@@ -2482,2 +2463,2 @@
-	if (info->tty)
-		set_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->port.tty)
+		set_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -2485 +2466 @@
-	info->flags &= ~ASYNC_INITIALIZED;
+	info->port.flags &= ~ASYNC_INITIALIZED;
@@ -2514 +2495 @@
-	    (info->tty && info->tty->termios->c_cflag & CREAD))
+	    (info->port.tty && info->port.tty->termios->c_cflag & CREAD))
@@ -2528 +2509 @@
-	if (!info->tty || !info->tty->termios)
+	if (!info->port.tty || !info->port.tty->termios)
@@ -2532 +2513 @@
-	cflag = info->tty->termios->c_cflag;
+	cflag = info->port.tty->termios->c_cflag;
@@ -2564 +2545 @@
-	info->params.data_rate = tty_get_baud_rate(info->tty);
+	info->params.data_rate = tty_get_baud_rate(info->port.tty);
@@ -2573 +2554 @@
-		info->flags |= ASYNC_CTS_FLOW;
+		info->port.flags |= ASYNC_CTS_FLOW;
@@ -2575 +2556 @@
-		info->flags &= ~ASYNC_CTS_FLOW;
+		info->port.flags &= ~ASYNC_CTS_FLOW;
@@ -2578 +2559 @@
-		info->flags &= ~ASYNC_CHECK_CD;
+		info->port.flags &= ~ASYNC_CHECK_CD;
@@ -2580 +2561 @@
-		info->flags |= ASYNC_CHECK_CD;
+		info->port.flags |= ASYNC_CHECK_CD;
@@ -2585 +2566 @@
-	if (I_INPCK(info->tty))
+	if (I_INPCK(info->port.tty))
@@ -2587 +2568 @@
- 	if (I_BRKINT(info->tty) || I_PARMRK(info->tty))
+ 	if (I_BRKINT(info->port.tty) || I_PARMRK(info->port.tty))
@@ -2589 +2570 @@
-	if (I_IGNPAR(info->tty))
+	if (I_IGNPAR(info->port.tty))
@@ -2591 +2572 @@
-	if (I_IGNBRK(info->tty)) {
+	if (I_IGNBRK(info->port.tty)) {
@@ -2596 +2577 @@
-		if (I_IGNPAR(info->tty))
+		if (I_IGNPAR(info->port.tty))
@@ -2693 +2674,2 @@
-	DBGINFO(("%s rx_enable(%d)\n", info->device_name, enable));
+	unsigned int rbuf_fill_level;
+	DBGINFO(("%s rx_enable(%08x)\n", info->device_name, enable));
@@ -2694,0 +2677,22 @@
+	/*
+	 * enable[31..16] = receive DMA buffer fill level
+	 * 0 = noop (leave fill level unchanged)
+	 * fill level must be multiple of 4 and <= buffer size
+	 */
+	rbuf_fill_level = ((unsigned int)enable) >> 16;
+	if (rbuf_fill_level) {
+		if ((rbuf_fill_level > DMABUFSIZE) || (rbuf_fill_level % 4)) {
+			spin_unlock_irqrestore(&info->lock, flags);
+			return -EINVAL;
+		}
+		info->rbuf_fill_level = rbuf_fill_level;
+		rx_stop(info); /* restart receiver to use new fill level */
+	}
+
+	/*
+	 * enable[1..0] = receiver enable command
+	 * 0 = disable
+	 * 1 = enable
+	 * 2 = enable or force hunt mode if already enabled
+	 */
+	enable &= 3;
@@ -3147 +3151 @@
-		info->flags |= ASYNC_NORMAL_ACTIVE;
+		info->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -3156 +3160 @@
-	 * this loop, info->count is dropped by one, so that
+	 * this loop, info->port.count is dropped by one, so that
@@ -3162 +3166 @@
-	add_wait_queue(&info->open_wait, &wait);
+	add_wait_queue(&info->port.open_wait, &wait);
@@ -3167 +3171 @@
-		info->count--;
+		info->port.count--;
@@ -3170 +3174 @@
-	info->blocked_open++;
+	info->port.blocked_open++;
@@ -3182,2 +3186,2 @@
-		if (tty_hung_up_p(filp) || !(info->flags & ASYNC_INITIALIZED)){
-			retval = (info->flags & ASYNC_HUP_NOTIFY) ?
+		if (tty_hung_up_p(filp) || !(info->port.flags & ASYNC_INITIALIZED)){
+			retval = (info->port.flags & ASYNC_HUP_NOTIFY) ?
@@ -3192 +3196 @@
- 		if (!(info->flags & ASYNC_CLOSING) &&
+ 		if (!(info->port.flags & ASYNC_CLOSING) &&
@@ -3207 +3211 @@
-	remove_wait_queue(&info->open_wait, &wait);
+	remove_wait_queue(&info->port.open_wait, &wait);
@@ -3210,2 +3214,2 @@
-		info->count++;
-	info->blocked_open--;
+		info->port.count++;
+	info->port.blocked_open--;
@@ -3214 +3218 @@
-		info->flags |= ASYNC_NORMAL_ACTIVE;
+		info->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -3399 +3402,0 @@
-		info->dosyncppp = dosyncppp[info->line];
@@ -3456,0 +3460 @@
+		tty_port_init(&info->port);
@@ -3460,5 +3464,3 @@
-		info->raw_rx_size = DMABUFSIZE;
-		info->close_delay = 5*HZ/10;
-		info->closing_wait = 30*HZ;
-		init_waitqueue_head(&info->open_wait);
-		init_waitqueue_head(&info->close_wait);
+		info->rbuf_fill_level = DMABUFSIZE;
+		info->port.close_delay = 5*HZ/10;
+		info->port.closing_wait = 30*HZ;
@@ -3949,9 +3951 @@
-	switch(info->params.mode) {
-	case MGSL_MODE_RAW:
-	case MGSL_MODE_MONOSYNC:
-	case MGSL_MODE_BISYNC:
-		wr_reg32(info, TDCSR, BIT2 + BIT0); /* IRQ + DMA enable */
-		break;
-	default:
-		wr_reg32(info, TDCSR, BIT0); /* DMA enable */
-	}
+	wr_reg32(info, TDCSR, BIT2 + BIT0); /* IRQ + DMA enable */
@@ -4160 +4154 @@
-	val = 0;
+	val = BIT2;
@@ -4432,0 +4427,2 @@
+	if (info->if_mode & MGSL_INTERFACE_MSB_FIRST)
+		val |= BIT4;
@@ -4471,10 +4467 @@
-		switch(info->params.mode) {
-		case MGSL_MODE_RAW:
-		case MGSL_MODE_MONOSYNC:
-		case MGSL_MODE_BISYNC:
-			set_desc_count(info->rbufs[i], info->raw_rx_size);
-			break;
-		default:
-			set_desc_count(info->rbufs[i], DMABUFSIZE);
-		}
-
+		set_desc_count(info->rbufs[i], info->rbuf_fill_level);
@@ -4508 +4495 @@
-	struct tty_struct *tty = info->tty;
+	struct tty_struct *tty = info->port.tty;
@@ -4580,3 +4567,2 @@
-		struct net_device_stats *stats = hdlc_stats(info->netdev);
-		stats->rx_errors++;
-		stats->rx_frame_errors++;
+		info->netdev->stats.rx_errors++;
+		info->netdev->stats.rx_frame_errors++;
@@ -4588 +4574 @@
-	DBGDATA(info, info->rbufs[start].buf, min_t(int, framesize, DMABUFSIZE), "rx");
+	DBGDATA(info, info->rbufs[start].buf, min_t(int, framesize, info->rbuf_fill_level), "rx");
@@ -4608 +4594 @@
-				int partial_count = min(copy_count, DMABUFSIZE);
+				int partial_count = min_t(int, copy_count, info->rbuf_fill_level);
@@ -4659 +4645 @@
-		ldisc_receive_buf(info->tty, info->rbufs[i].buf,
+		ldisc_receive_buf(info->port.tty, info->rbufs[i].buf,
@@ -4699,0 +4686,50 @@
+ * return number of bytes in unsent transmit DMA buffers
+ * and the serial controller tx FIFO
+ */
+static unsigned int tbuf_bytes(struct slgt_info *info)
+{
+	unsigned int total_count = 0;
+	unsigned int i = info->tbuf_current;
+	unsigned int reg_value;
+	unsigned int count;
+	unsigned int active_buf_count = 0;
+
+	/*
+	 * Add descriptor counts for all tx DMA buffers.
+	 * If count is zero (cleared by DMA controller after read),
+	 * the buffer is complete or is actively being read from.
+	 *
+	 * Record buf_count of last buffer with zero count starting
+	 * from current ring position. buf_count is mirror
+	 * copy of count and is not cleared by serial controller.
+	 * If DMA controller is active, that buffer is actively
+	 * being read so add to total.
+	 */
+	do {
+		count = desc_count(info->tbufs[i]);
+		if (count)
+			total_count += count;
+		else if (!total_count)
+			active_buf_count = info->tbufs[i].buf_count;
+		if (++i == info->tbuf_count)
+			i = 0;
+	} while (i != info->tbuf_current);
+
+	/* read tx DMA status register */
+	reg_value = rd_reg32(info, TDCSR);
+
+	/* if tx DMA active, last zero count buffer is in use */
+	if (reg_value & BIT0)
+		total_count += active_buf_count;
+
+	/* add tx FIFO count = reg_value[15..8] */
+	total_count += (reg_value >> 8) & 0xff;
+
+	/* if transmitter active add one byte for shift register */
+	if (info->tx_active)
+		total_count++;
+
+	return total_count;
+}
+
+/*
@@ -4736,0 +4773 @@
+		d->buf_count = count;
@@ -4768 +4805 @@
-	struct tty_struct *oldtty = info->tty;
+	struct tty_struct *oldtty = info->port.tty;
@@ -4772 +4809 @@
-	info->tty = NULL;
+	info->port.tty = NULL;
@@ -4800 +4837 @@
-	info->tty = oldtty;
+	info->port.tty = oldtty;
@@ -4840 +4877 @@
-	struct tty_struct *oldtty = info->tty;
+	struct tty_struct *oldtty = info->port.tty;
@@ -4848 +4885 @@
-	info->tty = NULL;
+	info->port.tty = NULL;
@@ -4886 +4923 @@
-	info->tty = oldtty;
+	info->port.tty = oldtty;
--- ./projects/linux/linux-2.6.28/drivers/char/synclink_gt.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/char/synclink_gt.c	2009-03-24 00:12:14.000000000 +0100
@@ -2,2 +1,0 @@
- * $Id: synclink_gt.c,v 4.50 2007/07/25 19:29:25 paulkf Exp $
- *
@@ -94 +91,0 @@
-static char *driver_version  = "$Revision: 4.50 $";
@@ -723,21 +720 @@
-	if (!info->port.count)
-		return;
-
-	if (tty_hung_up_p(filp))
-		goto cleanup;
-
-	if ((tty->count == 1) && (info->port.count != 1)) {
-		/*
-		 * tty->count is 1 and the tty structure will be freed.
-		 * info->port.count should be one in this case.
-		 * if it's not, correct it so that the port is shutdown.
-		 */
-		DBGERR(("%s close: bad refcount; tty->count=1, "
-		       "info->port.count=%d\n", info->device_name, info->port.count));
-		info->port.count = 1;
-	}
-
-	info->port.count--;
-
-	/* if at least one open remaining, leave hardware active */
-	if (info->port.count)
+	if (tty_port_close_start(&info->port, tty, filp) == 0)
@@ -746,15 +722,0 @@
-	info->port.flags |= ASYNC_CLOSING;
-
-	/* set tty->closing to notify line discipline to
-	 * only process XON/XOFF characters. Only the N_TTY
-	 * discipline appears to use this (ppp does not).
-	 */
-	tty->closing = 1;
-
-	/* wait for transmit data to clear all layers */
-
-	if (info->port.closing_wait != ASYNC_CLOSING_WAIT_NONE) {
-		DBGINFO(("%s call tty_wait_until_sent\n", info->device_name));
-		tty_wait_until_sent(tty, info->port.closing_wait);
-	}
-
@@ -768 +730 @@
-	tty->closing = 0;
+	tty_port_close_end(&info->port, tty);
@@ -770,12 +731,0 @@
-
-	if (info->port.blocked_open) {
-		if (info->port.close_delay) {
-			msleep_interruptible(jiffies_to_msecs(info->port.close_delay));
-		}
-		wake_up_interruptible(&info->port.open_wait);
-	}
-
-	info->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-
-	wake_up_interruptible(&info->port.close_wait);
-
@@ -1359 +1309 @@
-	len += sprintf(page, "synclink_gt driver:%s\n", driver_version);
+	len += sprintf(page, "synclink_gt driver\n");
@@ -2491 +2441 @@
-	slgt_irq_on(info, IRQ_DCD | IRQ_CTS | IRQ_DSR);
+	slgt_irq_on(info, IRQ_DCD | IRQ_CTS | IRQ_DSR | IRQ_RI);
@@ -3134,0 +3085,23 @@
+static int carrier_raised(struct tty_port *port)
+{
+	unsigned long flags;
+	struct slgt_info *info = container_of(port, struct slgt_info, port);
+
+	spin_lock_irqsave(&info->lock,flags);
+ 	get_signals(info);
+	spin_unlock_irqrestore(&info->lock,flags);
+	return (info->signals & SerialSignal_DCD) ? 1 : 0;
+}
+
+static void raise_dtr_rts(struct tty_port *port)
+{
+	unsigned long flags;
+	struct slgt_info *info = container_of(port, struct slgt_info, port);
+
+	spin_lock_irqsave(&info->lock,flags);
+	info->signals |= SerialSignal_RTS + SerialSignal_DTR;
+ 	set_signals(info);
+	spin_unlock_irqrestore(&info->lock,flags);
+}
+
+
@@ -3145,0 +3119,2 @@
+	int		cd;
+	struct tty_port *port = &info->port;
@@ -3151 +3126 @@
-		info->port.flags |= ASYNC_NORMAL_ACTIVE;
+		port->flags |= ASYNC_NORMAL_ACTIVE;
@@ -3160 +3135 @@
-	 * this loop, info->port.count is dropped by one, so that
+	 * this loop, port->count is dropped by one, so that
@@ -3166 +3141 @@
-	add_wait_queue(&info->port.open_wait, &wait);
+	add_wait_queue(&port->open_wait, &wait);
@@ -3171 +3146 @@
-		info->port.count--;
+		port->count--;
@@ -3174 +3149 @@
-	info->port.blocked_open++;
+	port->blocked_open++;
@@ -3177,6 +3152,2 @@
-		if ((tty->termios->c_cflag & CBAUD)) {
-			spin_lock_irqsave(&info->lock,flags);
-			info->signals |= SerialSignal_RTS + SerialSignal_DTR;
-		 	set_signals(info);
-			spin_unlock_irqrestore(&info->lock,flags);
-		}
+		if ((tty->termios->c_cflag & CBAUD))
+			tty_port_raise_dtr_rts(port);
@@ -3186,2 +3157,2 @@
-		if (tty_hung_up_p(filp) || !(info->port.flags & ASYNC_INITIALIZED)){
-			retval = (info->port.flags & ASYNC_HUP_NOTIFY) ?
+		if (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)){
+			retval = (port->flags & ASYNC_HUP_NOTIFY) ?
@@ -3192,3 +3163 @@
-		spin_lock_irqsave(&info->lock,flags);
-	 	get_signals(info);
-		spin_unlock_irqrestore(&info->lock,flags);
+		cd = tty_port_carrier_raised(port);
@@ -3196,2 +3165 @@
- 		if (!(info->port.flags & ASYNC_CLOSING) &&
- 		    (do_clocal || (info->signals & SerialSignal_DCD)) ) {
+ 		if (!(port->flags & ASYNC_CLOSING) && (do_clocal || cd ))
@@ -3199 +3166,0 @@
-		}
@@ -3211 +3178 @@
-	remove_wait_queue(&info->port.open_wait, &wait);
+	remove_wait_queue(&port->open_wait, &wait);
@@ -3214,2 +3181,2 @@
-		info->port.count++;
-	info->port.blocked_open--;
+		port->count++;
+	port->blocked_open--;
@@ -3218 +3185 @@
-		info->port.flags |= ASYNC_NORMAL_ACTIVE;
+		port->flags |= ASYNC_NORMAL_ACTIVE;
@@ -3446,0 +3414,5 @@
+static const struct tty_port_operations slgt_port_ops = {
+	.carrier_raised = carrier_raised,
+	.raise_dtr_rts = raise_dtr_rts,
+};
+
@@ -3460,0 +3433 @@
+		info->port.ops = &slgt_port_ops;
@@ -3603 +3576 @@
-	printk("unload %s %s\n", driver_name, driver_version);
+	printk(KERN_INFO "unload %s\n", driver_name);
@@ -3646 +3619 @@
- 	printk("%s %s\n", driver_name, driver_version);
+	printk(KERN_INFO "%s\n", driver_name);
@@ -3677,3 +3650,2 @@
- 	printk("%s %s, tty major#%d\n",
-		driver_name, driver_version,
-		serial_driver->major);
+	printk(KERN_INFO "%s, tty major#%d\n",
+	       driver_name, serial_driver->major);
--- ./projects/linux/linux-2.6.29/drivers/char/synclink_gt.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/char/synclink_gt.c	2009-06-27 11:32:32.000000000 +0200
@@ -62,0 +63 @@
+#include <linux/seq_file.h>
@@ -157 +157,0 @@
-static int  read_proc(char *page, char **start, off_t off, int count,int *eof, void *data);
@@ -300,0 +301 @@
+	unsigned int base_clock;
@@ -1159,13 +1160,17 @@
-	info->params.mode            = tmp_params.mode;
-	info->params.loopback        = tmp_params.loopback;
-	info->params.flags           = tmp_params.flags;
-	info->params.encoding        = tmp_params.encoding;
-	info->params.clock_speed     = tmp_params.clock_speed;
-	info->params.addr_filter     = tmp_params.addr_filter;
-	info->params.crc_type        = tmp_params.crc_type;
-	info->params.preamble_length = tmp_params.preamble_length;
-	info->params.preamble        = tmp_params.preamble;
-	info->params.data_rate       = tmp_params.data_rate;
-	info->params.data_bits       = tmp_params.data_bits;
-	info->params.stop_bits       = tmp_params.stop_bits;
-	info->params.parity          = tmp_params.parity;
+	if (tmp_params.mode == MGSL_MODE_BASE_CLOCK) {
+		info->base_clock = tmp_params.clock_speed;
+	} else {
+		info->params.mode            = tmp_params.mode;
+		info->params.loopback        = tmp_params.loopback;
+		info->params.flags           = tmp_params.flags;
+		info->params.encoding        = tmp_params.encoding;
+		info->params.clock_speed     = tmp_params.clock_speed;
+		info->params.addr_filter     = tmp_params.addr_filter;
+		info->params.crc_type        = tmp_params.crc_type;
+		info->params.preamble_length = tmp_params.preamble_length;
+		info->params.preamble        = tmp_params.preamble;
+		info->params.data_rate       = tmp_params.data_rate;
+		info->params.data_bits       = tmp_params.data_bits;
+		info->params.stop_bits       = tmp_params.stop_bits;
+		info->params.parity          = tmp_params.parity;
+	}
@@ -1174 +1179 @@
- 	change_params(info);
+	program_hw(info);
@@ -1232 +1237 @@
-static inline int line_info(char *buf, struct slgt_info *info)
+static inline void line_info(struct seq_file *m, struct slgt_info *info)
@@ -1235 +1239,0 @@
-	int ret;
@@ -1238 +1242 @@
-	ret = sprintf(buf, "%s: IO=%08X IRQ=%d MaxFrameSize=%u\n",
+	seq_printf(m, "%s: IO=%08X IRQ=%d MaxFrameSize=%u\n",
@@ -1263 +1267 @@
-		ret += sprintf(buf+ret, "\tHDLC txok:%d rxok:%d",
+		seq_printf(m, "\tHDLC txok:%d rxok:%d",
@@ -1266 +1270 @@
-			ret += sprintf(buf+ret, " txunder:%d", info->icount.txunder);
+			seq_printf(m, " txunder:%d", info->icount.txunder);
@@ -1268 +1272 @@
-			ret += sprintf(buf+ret, " txabort:%d", info->icount.txabort);
+			seq_printf(m, " txabort:%d", info->icount.txabort);
@@ -1270 +1274 @@
-			ret += sprintf(buf+ret, " rxshort:%d", info->icount.rxshort);
+			seq_printf(m, " rxshort:%d", info->icount.rxshort);
@@ -1272 +1276 @@
-			ret += sprintf(buf+ret, " rxlong:%d", info->icount.rxlong);
+			seq_printf(m, " rxlong:%d", info->icount.rxlong);
@@ -1274 +1278 @@
-			ret += sprintf(buf+ret, " rxover:%d", info->icount.rxover);
+			seq_printf(m, " rxover:%d", info->icount.rxover);
@@ -1276 +1280 @@
-			ret += sprintf(buf+ret, " rxcrc:%d", info->icount.rxcrc);
+			seq_printf(m, " rxcrc:%d", info->icount.rxcrc);
@@ -1278 +1282 @@
-		ret += sprintf(buf+ret, "\tASYNC tx:%d rx:%d",
+		seq_printf(m, "\tASYNC tx:%d rx:%d",
@@ -1281 +1285 @@
-			ret += sprintf(buf+ret, " fe:%d", info->icount.frame);
+			seq_printf(m, " fe:%d", info->icount.frame);
@@ -1283 +1287 @@
-			ret += sprintf(buf+ret, " pe:%d", info->icount.parity);
+			seq_printf(m, " pe:%d", info->icount.parity);
@@ -1285 +1289 @@
-			ret += sprintf(buf+ret, " brk:%d", info->icount.brk);
+			seq_printf(m, " brk:%d", info->icount.brk);
@@ -1287 +1291 @@
-			ret += sprintf(buf+ret, " oe:%d", info->icount.overrun);
+			seq_printf(m, " oe:%d", info->icount.overrun);
@@ -1291 +1295 @@
-	ret += sprintf(buf+ret, " %s\n", stat_buf+1);
+	seq_printf(m, " %s\n", stat_buf+1);
@@ -1293 +1297 @@
-	ret += sprintf(buf+ret, "\ttxactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",
+	seq_printf(m, "\ttxactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",
@@ -1296,2 +1299,0 @@
-
-	return ret;
@@ -1302,2 +1304 @@
-static int read_proc(char *page, char **start, off_t off, int count,
-		     int *eof, void *data)
+static int synclink_gt_proc_show(struct seq_file *m, void *v)
@@ -1305,2 +1305,0 @@
-	int len = 0, l;
-	off_t	begin = 0;
@@ -1309 +1308 @@
-	len += sprintf(page, "synclink_gt driver\n");
+	seq_puts(m, "synclink_gt driver\n");
@@ -1313,8 +1312 @@
-		l = line_info(page + len, info);
-		len += l;
-		if (len+begin > off+count)
-			goto done;
-		if (len+begin < off) {
-			begin += len;
-			len = 0;
-		}
+		line_info(m, info);
@@ -1322,0 +1315,2 @@
+	return 0;
+}
@@ -1324,6 +1318,3 @@
-	*eof = 1;
-done:
-	if (off >= len+begin)
-		return 0;
-	*start = page + (off-begin);
-	return ((count < begin+len-off) ? count : begin+len-off);
+static int synclink_gt_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, synclink_gt_proc_show, NULL);
@@ -1331,0 +1323,8 @@
+static const struct file_operations synclink_gt_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= synclink_gt_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
@@ -1766,2 +1764,0 @@
-
-	dev->last_rx = jiffies;
@@ -1769,0 +1767,9 @@
+static const struct net_device_ops hdlcdev_ops = {
+	.ndo_open       = hdlcdev_open,
+	.ndo_stop       = hdlcdev_close,
+	.ndo_change_mtu = hdlc_change_mtu,
+	.ndo_start_xmit = hdlc_start_xmit,
+	.ndo_do_ioctl   = hdlcdev_ioctl,
+	.ndo_tx_timeout = hdlcdev_tx_timeout,
+};
+
@@ -1797,5 +1803,2 @@
-	dev->do_ioctl       = hdlcdev_ioctl;
-	dev->open           = hdlcdev_open;
-	dev->stop           = hdlcdev_close;
-	dev->tx_timeout     = hdlcdev_tx_timeout;
-	dev->watchdog_timeo = 10*HZ;
+	dev->netdev_ops	    = &hdlcdev_ops;
+	dev->watchdog_timeo = 10 * HZ;
@@ -2564 +2567,4 @@
-	memcpy(&info->params, &tmp_params, sizeof(MGSL_PARAMS));
+	if (tmp_params.mode == MGSL_MODE_BASE_CLOCK)
+		info->base_clock = tmp_params.clock_speed;
+	else
+		memcpy(&info->params, &tmp_params, sizeof(MGSL_PARAMS));
@@ -2567 +2573 @@
- 	change_params(info);
+	program_hw(info);
@@ -3436,0 +3443 @@
+		info->base_clock = 14745600;
@@ -3561 +3567,0 @@
- 	.read_proc = read_proc,
@@ -3567,0 +3574 @@
+	.proc_fops = &synclink_gt_proc_fops,
@@ -3784 +3791 @@
-	static unsigned int osc = 14745600;
+	unsigned int osc = info->base_clock;
@@ -4088 +4095 @@
-	 * 03  reserved, must be zero
+	 * 03  0=16x sampling, 1=8x sampling
@@ -4093,0 +4101,11 @@
+	/* JCR[8] : 1 = x8 async mode feature available */
+	if ((rd_reg32(info, JCR) & BIT8) && info->params.data_rate &&
+	    ((info->base_clock < (info->params.data_rate * 16)) ||
+	     (info->base_clock % (info->params.data_rate * 16)))) {
+		/* use 8x sampling */
+		val |= BIT3;
+		set_rate(info, info->params.data_rate * 8);
+	} else {
+		/* use 16x sampling */
+		set_rate(info, info->params.data_rate * 16);
+	}
@@ -4098,2 +4115,0 @@
-	set_rate(info, info->params.data_rate * 16);
-
--- ./projects/linux/linux-2.6.13/drivers/char/synclinkmp.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/char/synclinkmp.c	2005-10-28 02:02:08.000000000 +0200
@@ -2 +2 @@
- * $Id: synclinkmp.c,v 4.34 2005/03/04 15:07:10 paulkf Exp $
+ * $Id: synclinkmp.c,v 4.38 2005/07/15 13:29:44 paulkf Exp $
@@ -58 +57,0 @@
-#include <asm/serial.h>
@@ -490 +489 @@
-static char *driver_version = "$Revision: 4.34 $";
+static char *driver_version = "$Revision: 4.38 $";
@@ -559 +557,0 @@
-static int  map_status(int signals);
@@ -648 +646 @@
-static u32 lcr1_brdr_value = 0x00800029;
+static u32 lcr1_brdr_value = 0x00800028;
@@ -2752,0 +2751,2 @@
+	memset(&info->icount, 0, sizeof(info->icount));
+
@@ -2956,6 +2956,6 @@
-	COPY_TO_USER(err,user_icount, &info->icount, sizeof(struct mgsl_icount));
-	if (err) {
-		if ( debug_level >= DEBUG_LEVEL_INFO )
-			printk( "%s(%d):%s get_stats() user buffer copy failed\n",
-				__FILE__,__LINE__,info->device_name);
-		return -EFAULT;
+	if (!user_icount) {
+		memset(&info->icount, 0, sizeof(info->icount));
+	} else {
+		COPY_TO_USER(err, user_icount, &info->icount, sizeof(struct mgsl_icount));
+		if (err)
+			return -EFAULT;
@@ -3112,10 +3111,0 @@
-static int map_status(int signals)
-{
-	/* Map status bits to API event bits */
-
-	return ((signals & SerialSignal_DSR) ? MgslEvent_DsrActive : MgslEvent_DsrInactive) +
-	       ((signals & SerialSignal_CTS) ? MgslEvent_CtsActive : MgslEvent_CtsInactive) +
-	       ((signals & SerialSignal_DCD) ? MgslEvent_DcdActive : MgslEvent_DcdInactive) +
-	       ((signals & SerialSignal_RI)  ? MgslEvent_RiActive : MgslEvent_RiInactive);
-}
-
@@ -3148 +3138 @@
-	s = map_status(info->serial_signals);
+	s = info->serial_signals;
@@ -4492 +4482 @@
-	 * 01..00  CNCT<1..0> Channel connection, 0=normal
+	 * 01..00  CNCT<1..0> Channel connection, 00=normal 11=local loopback
@@ -4496,0 +4487,2 @@
+	if (info->params.loopback)
+		RegValue |= (BIT1 + BIT0);
@@ -4577,3 +4568,0 @@
-
-	if (info->params.loopback)
-		enable_loopback(info,1);
--- ./projects/linux/linux-2.6.14/drivers/char/synclinkmp.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/char/synclinkmp.c	2006-01-03 04:21:10.000000000 +0100
@@ -2790,4 +2790,2 @@
-	if (info->tx_buf) {
-		kfree(info->tx_buf);
-		info->tx_buf = NULL;
-	}
+	kfree(info->tx_buf);
+	info->tx_buf = NULL;
@@ -3613,2 +3611 @@
-	if (info->tmp_rx_buf)
-		kfree(info->tmp_rx_buf);
+	kfree(info->tmp_rx_buf);
--- ./projects/linux/linux-2.6.15/drivers/char/synclinkmp.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/synclinkmp.c	2006-03-20 06:53:29.000000000 +0100
@@ -2199 +2199 @@
-						*tty->flip.flag_buf_ptr = TTY_BREAK;
+						tty_insert_flip_char(tty, 0, TTY_BREAK);
@@ -2242,0 +2243,2 @@
+		int flag = 0;
+		int over = 0;
@@ -2245,8 +2246,0 @@
-		if ( tty ) {
-			if (tty->flip.count >= TTY_FLIPBUF_SIZE)
-				continue;
-
-			*tty->flip.char_buf_ptr = DataByte;
-			*tty->flip.flag_buf_ptr = 0;
-		}
-
@@ -2275 +2269 @@
-					*tty->flip.flag_buf_ptr = TTY_PARITY;
+					flag = TTY_PARITY;
@@ -2277 +2271 @@
-					*tty->flip.flag_buf_ptr = TTY_FRAME;
+					flag = TTY_FRAME;
@@ -2283,6 +2277 @@
-					if (tty->flip.count < TTY_FLIPBUF_SIZE) {
-						tty->flip.count++;
-						tty->flip.flag_buf_ptr++;
-						tty->flip.char_buf_ptr++;
-						*tty->flip.flag_buf_ptr = TTY_OVERRUN;
-					}
+					over = 1;
@@ -2294,3 +2283,3 @@
-			tty->flip.flag_buf_ptr++;
-			tty->flip.char_buf_ptr++;
-			tty->flip.count++;
+			tty_insert_flip_char(tty, DataByte, flag);
+			if (over)
+				tty_insert_flip_char(tty, 0, TTY_OVERRUN);
@@ -2301,3 +2289,0 @@
-		printk("%s(%d):%s isr_rxrdy() flip count=%d\n",
-			__FILE__,__LINE__,info->device_name,
-			tty ? tty->flip.count : 0);
@@ -2310 +2296 @@
-	if ( tty && tty->flip.count )
+	if ( tty )
@@ -5107 +5093 @@
-	static unsigned int count = sizeof(testval)/sizeof(unsigned char);
+	static unsigned int count = ARRAY_SIZE(testval);
@@ -5425 +5411 @@
-	unsigned long count = sizeof(testval)/sizeof(unsigned long);
+	unsigned long count = ARRAY_SIZE(testval);
--- ./projects/linux/linux-2.6.16/drivers/char/synclinkmp.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/char/synclinkmp.c	2006-06-18 03:49:35.000000000 +0200
@@ -1653 +1653 @@
-	info->params.crc_type = new_crctype;;
+	info->params.crc_type = new_crctype;
--- ./projects/linux/linux-2.6.17/drivers/char/synclinkmp.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/synclinkmp.c	2006-09-20 05:42:06.000000000 +0200
@@ -37 +36,0 @@
-#include <linux/config.h>
@@ -991 +990 @@
-	if (!tty || !info->tx_buf)
+	if (!info->tx_buf)
@@ -1070 +1069 @@
-	if (!tty || !info->tx_buf)
+	if (!info->tx_buf)
@@ -1756,2 +1755,4 @@
-	hdlc_set_carrier(info->serial_signals & SerialSignal_DCD, dev);
-
+	if (info->serial_signals & SerialSignal_DCD)
+		netif_carrier_on(dev);
+	else
+		netif_carrier_off(dev);
@@ -2526,2 +2527,6 @@
-			if (info->netcount)
-				hdlc_set_carrier(status & SerialSignal_DCD, info->netdev);
+			if (info->netcount) {
+				if (status & SerialSignal_DCD)
+					netif_carrier_on(info->netdev);
+				else
+					netif_carrier_off(info->netdev);
+			}
@@ -3839 +3844 @@
-		info->irq_flags = SA_SHIRQ;
+		info->irq_flags = IRQF_SHARED;
--- ./projects/linux/linux-2.6.18/drivers/char/synclinkmp.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/synclinkmp.c	2006-11-29 22:57:37.000000000 +0100
@@ -2599,2 +2599 @@
-static irqreturn_t synclinkmp_interrupt(int irq, void *dev_id,
-					struct pt_regs *regs)
+static irqreturn_t synclinkmp_interrupt(int irq, void *dev_id)
@@ -3932 +3931 @@
-static struct tty_operations ops = {
+static const struct tty_operations ops = {
--- ./projects/linux/linux-2.6.19/drivers/char/synclinkmp.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/synclinkmp.c	2007-02-04 19:44:54.000000000 +0100
@@ -70,2 +70,4 @@
-#ifdef CONFIG_HDLC_MODULE
-#define CONFIG_HDLC 1
+#if defined(CONFIG_HDLC) || (defined(CONFIG_HDLC_MODULE) && defined(CONFIG_SYNCLINKMP_MODULE))
+#define SYNCLINK_GENERIC_HDLC 1
+#else
+#define SYNCLINK_GENERIC_HDLC 0
@@ -283 +285 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -520 +522 @@
-static void set_termios(struct tty_struct *tty, struct termios *old_termios);
+static void set_termios(struct tty_struct *tty, struct ktermios *old_termios);
@@ -539 +541 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -605 +607 @@
-static void bh_handler(void* Context);
+static void bh_handler(struct work_struct *work);
@@ -919 +921 @@
-static void set_termios(struct tty_struct *tty, struct termios *old_termios)
+static void set_termios(struct tty_struct *tty, struct ktermios *old_termios)
@@ -1610 +1612 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -2066 +2068 @@
-void bh_handler(void* Context)
+void bh_handler(struct work_struct *work)
@@ -2068 +2070 @@
-	SLMP_INFO *info = (SLMP_INFO*)Context;
+	SLMP_INFO *info = container_of(work, SLMP_INFO, task);
@@ -2342 +2344 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -2526 +2528 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -2731 +2733 @@
-		info->tx_buf = (unsigned char *)kmalloc(info->max_frame_size, GFP_KERNEL);
+		info->tx_buf = kmalloc(info->max_frame_size, GFP_KERNEL);
@@ -3786 +3788 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -3799 +3801 @@
-	info = (SLMP_INFO *)kmalloc(sizeof(SLMP_INFO),
+	info = kmalloc(sizeof(SLMP_INFO),
@@ -3808 +3810 @@
-		INIT_WORK(&info->task, bh_handler, info);
+		INIT_WORK(&info->task, bh_handler);
@@ -3980 +3982 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -4034,0 +4037,2 @@
+	serial_driver->init_termios.c_ispeed = 9600;
+	serial_driver->init_termios.c_ospeed = 9600;
@@ -4982 +4986 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -5023 +5027 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
@@ -5534 +5538 @@
-#ifdef CONFIG_HDLC
+#if SYNCLINK_GENERIC_HDLC
--- ./projects/linux/linux-2.6.20/drivers/char/synclinkmp.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/synclinkmp.c	2007-04-26 05:08:32.000000000 +0200
@@ -1261 +1260,0 @@
-	wake_up_interruptible(&tty->write_wait);
@@ -2130 +2129 @@
-	if (tty) {
+	if (tty)
@@ -2132,2 +2130,0 @@
-		wake_up_interruptible(&tty->write_wait);
-	}
@@ -2750,2 +2747 @@
-	info->status_timer.expires = jiffies + msecs_to_jiffies(10);
-	add_timer(&info->status_timer);
+	mod_timer(&info->status_timer, jiffies + msecs_to_jiffies(10));
@@ -3847,7 +3843,3 @@
-		init_timer(&info->tx_timer);
-		info->tx_timer.data = (unsigned long)info;
-		info->tx_timer.function = tx_timeout;
-
-		init_timer(&info->status_timer);
-		info->status_timer.data = (unsigned long)info;
-		info->status_timer.function = status_timeout;
+		setup_timer(&info->tx_timer, tx_timeout, (unsigned long)info);
+		setup_timer(&info->status_timer, status_timeout,
+				(unsigned long)info);
@@ -4297,2 +4289,2 @@
-			info->tx_timer.expires = jiffies + msecs_to_jiffies(5000);
-			add_timer(&info->tx_timer);
+			mod_timer(&info->tx_timer, jiffies +
+					msecs_to_jiffies(5000));
@@ -5580,4 +5572 @@
-	info->status_timer.data = (unsigned long)info;
-	info->status_timer.function = status_timeout;
-	info->status_timer.expires = jiffies + msecs_to_jiffies(10);
-	add_timer(&info->status_timer);
+	mod_timer(&info->status_timer, jiffies + msecs_to_jiffies(10));
--- ./projects/linux/linux-2.6.22/drivers/char/synclinkmp.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/synclinkmp.c	2007-10-09 22:31:38.000000000 +0200
@@ -138,2 +137,0 @@
-#define RELEVANT_IFLAG(iflag) (iflag & (IGNBRK|BRKINT|IGNPAR|PARMRK|INPCK))
-
@@ -930,6 +927,0 @@
-	/* just return if nothing has changed */
-	if ((tty->termios->c_cflag == old_termios->c_cflag)
-	    && (RELEVANT_IFLAG(tty->termios->c_iflag)
-		== RELEVANT_IFLAG(old_termios->c_iflag)))
-	  return;
-
@@ -3797 +3789 @@
-	info = kmalloc(sizeof(SLMP_INFO),
+	info = kzalloc(sizeof(SLMP_INFO),
@@ -3804 +3795,0 @@
-		memset(info, 0, sizeof(SLMP_INFO));
--- ./projects/linux/linux-2.6.24/drivers/char/synclinkmp.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/synclinkmp.c	2008-04-17 04:49:44.000000000 +0200
@@ -68,0 +69 @@
+#include <linux/synclink.h>
@@ -83,2 +83,0 @@
-#include "linux/synclink.h"
-
--- ./projects/linux/linux-2.6.25/drivers/char/synclinkmp.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/synclinkmp.c	2008-07-13 23:51:29.000000000 +0200
@@ -191 +191 @@
-	int bh_running;				/* Protection from multiple */
+	bool bh_running;				/* Protection from multiple */
@@ -193 +193 @@
-	int bh_requested;
+	bool bh_requested;
@@ -216,2 +216,2 @@
-	int rx_enabled;
-	int rx_overflow;
+	bool rx_enabled;
+	bool rx_overflow;
@@ -219,2 +219,2 @@
-	int tx_enabled;
-	int tx_active;
+	bool tx_enabled;
+	bool tx_active;
@@ -241 +241 @@
-	int irq_requested;			/* nonzero if IRQ requested */
+	bool irq_requested;			/* true if IRQ requested */
@@ -247 +247 @@
-	int irq_occurred;			/* for diagnostics use */
+	bool irq_occurred;			/* for diagnostics use */
@@ -258 +258 @@
-	int sca_base_requested;
+	bool sca_base_requested;
@@ -268 +268 @@
-	int sca_statctrl_requested;
+	bool sca_statctrl_requested;
@@ -273 +273 @@
-	BOOLEAN drop_rts_on_tx_done;
+	bool drop_rts_on_tx_done;
@@ -522 +522 @@
-static void put_char(struct tty_struct *tty, unsigned char ch);
+static int put_char(struct tty_struct *tty, unsigned char ch);
@@ -574,4 +574,4 @@
-static int  init_adapter(SLMP_INFO *info);
-static int  register_test(SLMP_INFO *info);
-static int  irq_test(SLMP_INFO *info);
-static int  loopback_test(SLMP_INFO *info);
+static bool init_adapter(SLMP_INFO *info);
+static bool register_test(SLMP_INFO *info);
+static bool irq_test(SLMP_INFO *info);
+static bool loopback_test(SLMP_INFO *info);
@@ -579 +579 @@
-static int  memory_test(SLMP_INFO *info);
+static bool memory_test(SLMP_INFO *info);
@@ -590 +590 @@
-static int  rx_get_frame(SLMP_INFO *info);
+static bool rx_get_frame(SLMP_INFO *info);
@@ -865,2 +865 @@
-	if (tty->driver->flush_buffer)
-		tty->driver->flush_buffer(tty);
+	flush_buffer(tty);
@@ -1049 +1048 @@
-static void put_char(struct tty_struct *tty, unsigned char ch)
+static int put_char(struct tty_struct *tty, unsigned char ch)
@@ -1052,0 +1052 @@
+	int ret = 0;
@@ -1060 +1060 @@
-		return;
+		return 0;
@@ -1063 +1063 @@
-		return;
+		return 0;
@@ -1074,0 +1075 @@
+			ret = 1;
@@ -1078,0 +1080 @@
+	return ret;
@@ -1121,0 +1124,2 @@
+	lock_kernel();
+
@@ -1163,0 +1168 @@
+	unlock_kernel();
@@ -1178,0 +1184 @@
+	lock_kernel();
@@ -1185,0 +1192 @@
+	unlock_kernel();
@@ -1306 +1313 @@
-static int ioctl(struct tty_struct *tty, struct file *file,
+static int do_ioctl(struct tty_struct *tty, struct file *file,
@@ -1395,0 +1403,10 @@
+static int ioctl(struct tty_struct *tty, struct file *file,
+		 unsigned int cmd, unsigned long arg)
+{
+	int ret;
+	lock_kernel();
+	ret = do_ioctl(tty, file, cmd, arg);
+	unlock_kernel();
+	return ret;
+}
+
@@ -1476 +1493 @@
-int read_proc(char *page, char **start, off_t off, int count,
+static int read_proc(char *page, char **start, off_t off, int count,
@@ -2027 +2044 @@
-int bh_action(SLMP_INFO *info)
+static int bh_action(SLMP_INFO *info)
@@ -2047,2 +2064,2 @@
-		info->bh_running   = 0;
-		info->bh_requested = 0;
+		info->bh_running = false;
+		info->bh_requested = false;
@@ -2058 +2075 @@
-void bh_handler(struct work_struct *work)
+static void bh_handler(struct work_struct *work)
@@ -2070 +2087 @@
-	info->bh_running = 1;
+	info->bh_running = true;
@@ -2103 +2120 @@
-void bh_receive(SLMP_INFO *info)
+static void bh_receive(SLMP_INFO *info)
@@ -2112 +2129 @@
-void bh_transmit(SLMP_INFO *info)
+static void bh_transmit(SLMP_INFO *info)
@@ -2124 +2141 @@
-void bh_status(SLMP_INFO *info)
+static void bh_status(SLMP_INFO *info)
@@ -2136 +2153 @@
-void isr_timer(SLMP_INFO * info)
+static void isr_timer(SLMP_INFO * info)
@@ -2155 +2172 @@
-	info->irq_occurred = TRUE;
+	info->irq_occurred = true;
@@ -2162 +2179 @@
-void isr_rxint(SLMP_INFO * info)
+static void isr_rxint(SLMP_INFO * info)
@@ -2221 +2238 @@
-void isr_rxrdy(SLMP_INFO * info)
+static void isr_rxrdy(SLMP_INFO * info)
@@ -2235 +2252 @@
-		int over = 0;
+		bool over = false;
@@ -2268 +2285 @@
-					over = 1;
+					over = true;
@@ -2321 +2338 @@
-		info->tx_active = 0;
+		info->tx_active = false;
@@ -2328 +2345 @@
-			info->drop_rts_on_tx_done = 0;
+			info->drop_rts_on_tx_done = false;
@@ -2351 +2368 @@
-void isr_txint(SLMP_INFO * info)
+static void isr_txint(SLMP_INFO * info)
@@ -2379 +2396 @@
-void isr_txrdy(SLMP_INFO * info)
+static void isr_txrdy(SLMP_INFO * info)
@@ -2401 +2418 @@
-		info->tx_active = 0;
+		info->tx_active = false;
@@ -2410 +2427 @@
-void isr_rxdmaok(SLMP_INFO * info)
+static void isr_rxdmaok(SLMP_INFO * info)
@@ -2427 +2444 @@
-void isr_rxdmaerror(SLMP_INFO * info)
+static void isr_rxdmaerror(SLMP_INFO * info)
@@ -2441 +2458 @@
-	info->rx_overflow = TRUE;
+	info->rx_overflow = true;
@@ -2445 +2462 @@
-void isr_txdmaok(SLMP_INFO * info)
+static void isr_txdmaok(SLMP_INFO * info)
@@ -2463 +2480 @@
-void isr_txdmaerror(SLMP_INFO * info)
+static void isr_txdmaerror(SLMP_INFO * info)
@@ -2480 +2497 @@
-void isr_io_pin( SLMP_INFO *info, u16 status )
+static void isr_io_pin( SLMP_INFO *info, u16 status )
@@ -2589 +2606 @@
-static irqreturn_t synclinkmp_interrupt(int irq, void *dev_id)
+static irqreturn_t synclinkmp_interrupt(int dummy, void *dev_id)
@@ -2591 +2608 @@
-	SLMP_INFO * info;
+	SLMP_INFO *info = dev_id;
@@ -2600,6 +2617,2 @@
-		printk("%s(%d): synclinkmp_interrupt(%d)entry.\n",
-			__FILE__,__LINE__,irq);
-
-	info = (SLMP_INFO *)dev_id;
-	if (!info)
-		return IRQ_NONE;
+		printk(KERN_DEBUG "%s(%d): synclinkmp_interrupt(%d)entry.\n",
+			__FILE__, __LINE__, info->irq_level);
@@ -2618,3 +2631,3 @@
-			printk("%s(%d):%s status0=%02x, dmastatus0=%02x, timerstatus0=%02x\n",
-				__FILE__,__LINE__,info->device_name,
-				status0,dmastatus0,timerstatus0);
+			printk(KERN_DEBUG "%s(%d):%s status0=%02x, dmastatus0=%02x, timerstatus0=%02x\n",
+				__FILE__, __LINE__, info->device_name,
+				status0, dmastatus0, timerstatus0);
@@ -2698 +2711 @@
-			port->bh_requested = 1;
+			port->bh_requested = true;
@@ -2705,2 +2718,2 @@
-		printk("%s(%d):synclinkmp_interrupt(%d)exit.\n",
-			__FILE__,__LINE__,irq);
+		printk(KERN_DEBUG "%s(%d):synclinkmp_interrupt(%d)exit.\n",
+			__FILE__, __LINE__, info->irq_level);
@@ -3327 +3340,2 @@
-	int		do_clocal = 0, extra_count = 0;
+	bool		do_clocal = false;
+	bool		extra_count = false;
@@ -3342 +3356 @@
-		do_clocal = 1;
+		do_clocal = true;
@@ -3360 +3374 @@
-		extra_count = 1;
+		extra_count = true;
@@ -3420 +3434 @@
-int alloc_dma_bufs(SLMP_INFO *info)
+static int alloc_dma_bufs(SLMP_INFO *info)
@@ -3494 +3508 @@
-int alloc_buf_list(SLMP_INFO *info)
+static int alloc_buf_list(SLMP_INFO *info)
@@ -3553 +3567 @@
-int alloc_frame_bufs(SLMP_INFO *info, SCADESC *buf_list,SCADESC_EX *buf_list_ex,int count)
+static int alloc_frame_bufs(SLMP_INFO *info, SCADESC *buf_list,SCADESC_EX *buf_list_ex,int count)
@@ -3570 +3584 @@
-void free_dma_bufs(SLMP_INFO *info)
+static void free_dma_bufs(SLMP_INFO *info)
@@ -3580 +3594 @@
-int alloc_tmp_rx_buf(SLMP_INFO *info)
+static int alloc_tmp_rx_buf(SLMP_INFO *info)
@@ -3588 +3602 @@
-void free_tmp_rx_buf(SLMP_INFO *info)
+static void free_tmp_rx_buf(SLMP_INFO *info)
@@ -3594 +3608 @@
-int claim_resources(SLMP_INFO *info)
+static int claim_resources(SLMP_INFO *info)
@@ -3603 +3617 @@
-		info->shared_mem_requested = 1;
+		info->shared_mem_requested = true;
@@ -3612 +3626 @@
-		info->lcr_mem_requested = 1;
+		info->lcr_mem_requested = true;
@@ -3621 +3635 @@
-		info->sca_base_requested = 1;
+		info->sca_base_requested = true;
@@ -3630 +3644 @@
-		info->sca_statctrl_requested = 1;
+		info->sca_statctrl_requested = true;
@@ -3632 +3646,2 @@
-	info->memory_base = ioremap(info->phys_memory_base,SCA_MEM_SIZE);
+	info->memory_base = ioremap_nocache(info->phys_memory_base,
+								SCA_MEM_SIZE);
@@ -3640 +3655 @@
-	info->lcr_base = ioremap(info->phys_lcr_base,PAGE_SIZE);
+	info->lcr_base = ioremap_nocache(info->phys_lcr_base, PAGE_SIZE);
@@ -3649 +3664 @@
-	info->sca_base = ioremap(info->phys_sca_base,PAGE_SIZE);
+	info->sca_base = ioremap_nocache(info->phys_sca_base, PAGE_SIZE);
@@ -3658 +3673,2 @@
-	info->statctrl_base = ioremap(info->phys_statctrl_base,PAGE_SIZE);
+	info->statctrl_base = ioremap_nocache(info->phys_statctrl_base,
+								PAGE_SIZE);
@@ -3681 +3697 @@
-void release_resources(SLMP_INFO *info)
+static void release_resources(SLMP_INFO *info)
@@ -3689 +3705 @@
-		info->irq_requested = 0;
+		info->irq_requested = false;
@@ -3694 +3710 @@
-		info->shared_mem_requested = 0;
+		info->shared_mem_requested = false;
@@ -3698 +3714 @@
-		info->lcr_mem_requested = 0;
+		info->lcr_mem_requested = false;
@@ -3702 +3718 @@
-		info->sca_base_requested = 0;
+		info->sca_base_requested = false;
@@ -3706 +3722 @@
-		info->sca_statctrl_requested = 0;
+		info->sca_statctrl_requested = false;
@@ -3737 +3753 @@
-void add_device(SLMP_INFO *info)
+static void add_device(SLMP_INFO *info)
@@ -3860 +3876 @@
-void device_init(int adapter_num, struct pci_dev *pdev)
+static void device_init(int adapter_num, struct pci_dev *pdev)
@@ -3909 +3925 @@
-			port_array[0]->irq_requested = 1;
+			port_array[0]->irq_requested = true;
@@ -4054 +4070 @@
-void enable_loopback(SLMP_INFO *info, int enable)
+static void enable_loopback(SLMP_INFO *info, int enable)
@@ -4101 +4117 @@
-void set_rate( SLMP_INFO *info, u32 data_rate )
+static void set_rate( SLMP_INFO *info, u32 data_rate )
@@ -4147 +4163 @@
-void rx_stop(SLMP_INFO *info)
+static void rx_stop(SLMP_INFO *info)
@@ -4162,2 +4178,2 @@
-	info->rx_enabled = 0;
-	info->rx_overflow = 0;
+	info->rx_enabled = false;
+	info->rx_overflow = false;
@@ -4168 +4184 @@
-void rx_start(SLMP_INFO *info)
+static void rx_start(SLMP_INFO *info)
@@ -4218,2 +4234,2 @@
-	info->rx_overflow = FALSE;
-	info->rx_enabled = 1;
+	info->rx_overflow = false;
+	info->rx_enabled = true;
@@ -4225 +4241 @@
-void tx_start(SLMP_INFO *info)
+static void tx_start(SLMP_INFO *info)
@@ -4234 +4250 @@
-		info->tx_enabled = TRUE;
+		info->tx_enabled = true;
@@ -4243 +4259 @@
-		info->drop_rts_on_tx_done = 0;
+		info->drop_rts_on_tx_done = false;
@@ -4252 +4268 @@
-					info->drop_rts_on_tx_done = 1;
+					info->drop_rts_on_tx_done = true;
@@ -4289 +4305 @@
-		info->tx_active = 1;
+		info->tx_active = true;
@@ -4295 +4311 @@
-void tx_stop( SLMP_INFO *info )
+static void tx_stop( SLMP_INFO *info )
@@ -4315,2 +4331,2 @@
-	info->tx_enabled = 0;
-	info->tx_active  = 0;
+	info->tx_enabled = false;
+	info->tx_active = false;
@@ -4322 +4338 @@
-void tx_load_fifo(SLMP_INFO *info)
+static void tx_load_fifo(SLMP_INFO *info)
@@ -4371 +4387 @@
-void reset_port(SLMP_INFO *info)
+static void reset_port(SLMP_INFO *info)
@@ -4395 +4411 @@
-void reset_adapter(SLMP_INFO *info)
+static void reset_adapter(SLMP_INFO *info)
@@ -4407 +4423 @@
-void async_mode(SLMP_INFO *info)
+static void async_mode(SLMP_INFO *info)
@@ -4546 +4562 @@
-void hdlc_mode(SLMP_INFO *info)
+static void hdlc_mode(SLMP_INFO *info)
@@ -4748 +4764 @@
-void tx_set_idle(SLMP_INFO *info)
+static void tx_set_idle(SLMP_INFO *info)
@@ -4768 +4784 @@
-void get_signals(SLMP_INFO *info)
+static void get_signals(SLMP_INFO *info)
@@ -4797 +4813 @@
-void set_signals(SLMP_INFO *info)
+static void set_signals(SLMP_INFO *info)
@@ -4826 +4842 @@
-void rx_reset_buffers(SLMP_INFO *info)
+static void rx_reset_buffers(SLMP_INFO *info)
@@ -4837 +4853 @@
-void rx_free_frame_buffers(SLMP_INFO *info, unsigned int first, unsigned int last)
+static void rx_free_frame_buffers(SLMP_INFO *info, unsigned int first, unsigned int last)
@@ -4839 +4855 @@
-	int done = 0;
+	bool done = false;
@@ -4846 +4862 @@
-	                done = 1;
+	                done = true;
@@ -4863 +4879 @@
- * Return Value:	1 if frame returned, otherwise 0
+ * Return Value:	true if frame returned, otherwise false
@@ -4865 +4881 @@
-int rx_get_frame(SLMP_INFO *info)
+static bool rx_get_frame(SLMP_INFO *info)
@@ -4870 +4886 @@
-	int ReturnCode = 0;
+	bool ReturnCode = false;
@@ -5021 +5037 @@
-	ReturnCode = 1;
+	ReturnCode = true;
@@ -5040 +5056 @@
-void tx_load_dma_buffer(SLMP_INFO *info, const char *buf, unsigned int count)
+static void tx_load_dma_buffer(SLMP_INFO *info, const char *buf, unsigned int count)
@@ -5080 +5096 @@
-int register_test(SLMP_INFO *info)
+static bool register_test(SLMP_INFO *info)
@@ -5085 +5101 @@
-	int rc = TRUE;
+	bool rc = true;
@@ -5108 +5124 @@
-			rc = FALSE;
+			rc = false;
@@ -5119 +5135 @@
-int irq_test(SLMP_INFO *info)
+static bool irq_test(SLMP_INFO *info)
@@ -5131 +5147 @@
-	info->irq_occurred = FALSE;
+	info->irq_occurred = false;
@@ -5170 +5186 @@
-static int sca_init(SLMP_INFO *info)
+static bool sca_init(SLMP_INFO *info)
@@ -5206 +5222 @@
-	return TRUE;
+	return true;
@@ -5211 +5227 @@
-int init_adapter(SLMP_INFO *info)
+static bool init_adapter(SLMP_INFO *info)
@@ -5264 +5280 @@
-	return TRUE;
+	return true;
@@ -5270 +5286 @@
-int loopback_test(SLMP_INFO *info)
+static bool loopback_test(SLMP_INFO *info)
@@ -5277 +5293 @@
-	int rc = FALSE;
+	bool rc = false;
@@ -5311 +5327 @@
-			rc = TRUE;
+			rc = true;
@@ -5317,4 +5333,4 @@
-	if (rc == TRUE &&
-		( info->tmp_rx_buf_count != count ||
-		  memcmp(buf, info->tmp_rx_buf,count))) {
-		rc = FALSE;
+	if (rc &&
+	    ( info->tmp_rx_buf_count != count ||
+	      memcmp(buf, info->tmp_rx_buf,count))) {
+		rc = false;
@@ -5335 +5351 @@
-int adapter_test( SLMP_INFO *info )
+static int adapter_test( SLMP_INFO *info )
@@ -5397 +5413 @@
-int memory_test(SLMP_INFO *info)
+static bool memory_test(SLMP_INFO *info)
@@ -5411 +5427 @@
-			return FALSE;
+			return false;
@@ -5426 +5442 @@
-			return FALSE;
+			return false;
@@ -5431 +5447 @@
-	return TRUE;
+	return true;
@@ -5449 +5465 @@
-void load_pci_memory(SLMP_INFO *info, char* dest, const char* src, unsigned short count)
+static void load_pci_memory(SLMP_INFO *info, char* dest, const char* src, unsigned short count)
@@ -5468 +5484 @@
-void trace_block(SLMP_INFO *info,const char* data, int count, int xmit)
+static void trace_block(SLMP_INFO *info,const char* data, int count, int xmit)
@@ -5503 +5519 @@
-void tx_timeout(unsigned long context)
+static void tx_timeout(unsigned long context)
@@ -5515 +5531 @@
-	info->tx_active = 0;
+	info->tx_active = false;
@@ -5530 +5546 @@
-void status_timeout(unsigned long context)
+static void status_timeout(unsigned long context)
@@ -5581 +5597 @@
-unsigned char read_reg(SLMP_INFO * info, unsigned char Addr)
+static unsigned char read_reg(SLMP_INFO * info, unsigned char Addr)
@@ -5586 +5602 @@
-void write_reg(SLMP_INFO * info, unsigned char Addr, unsigned char Value)
+static void write_reg(SLMP_INFO * info, unsigned char Addr, unsigned char Value)
@@ -5592 +5608 @@
-u16 read_reg16(SLMP_INFO * info, unsigned char Addr)
+static u16 read_reg16(SLMP_INFO * info, unsigned char Addr)
@@ -5598 +5614 @@
-void write_reg16(SLMP_INFO * info, unsigned char Addr, u16 Value)
+static void write_reg16(SLMP_INFO * info, unsigned char Addr, u16 Value)
@@ -5604 +5620 @@
-unsigned char read_status_reg(SLMP_INFO * info)
+static unsigned char read_status_reg(SLMP_INFO * info)
@@ -5610 +5626 @@
-void write_control_reg(SLMP_INFO * info)
+static void write_control_reg(SLMP_INFO * info)
--- ./projects/linux/linux-2.6.26/drivers/char/synclinkmp.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/char/synclinkmp.c	2008-10-10 00:13:53.000000000 +0200
@@ -154,2 +154 @@
-	int			flags;
-	int			count;		/* count of opens */
+	struct tty_port		port;
@@ -162 +160,0 @@
-	struct tty_struct 	*tty;
@@ -165 +162,0 @@
-	int			blocked_open;	/* # of blocked opens */
@@ -175,3 +171,0 @@
-	wait_queue_head_t	open_wait;
-	wait_queue_head_t	close_wait;
-
@@ -279 +272,0 @@
-	int dosyncppp;
@@ -465 +458 @@
-static int break_on_load=0;
+static int break_on_load = 0;
@@ -471 +464 @@
-static int ttymajor=0;
+static int ttymajor = 0;
@@ -478 +470,0 @@
-static int dosyncppp[MAX_DEVICES] = {0,};
@@ -484 +475,0 @@
-module_param_array(dosyncppp, int, NULL, 0);
@@ -536 +527 @@
-static void set_break(struct tty_struct *tty, int break_state);
+static int set_break(struct tty_struct *tty, int break_state);
@@ -561 +552 @@
-static void set_break(struct tty_struct *tty, int break_state);
+static int  set_break(struct tty_struct *tty, int break_state);
@@ -715,2 +706,2 @@
-		if (ld->receive_buf)
-			ld->receive_buf(tty, data, flags, count);
+		if (ld->ops->receive_buf)
+			ld->ops->receive_buf(tty, data, flags, count);
@@ -750 +741 @@
-	info->tty = tty;
+	info->port.tty = tty;
@@ -754 +745 @@
-			 __FILE__,__LINE__,tty->driver->name, info->count);
+			 __FILE__,__LINE__,tty->driver->name, info->port.count);
@@ -757,4 +748,4 @@
-	if (tty_hung_up_p(filp) || info->flags & ASYNC_CLOSING){
-		if (info->flags & ASYNC_CLOSING)
-			interruptible_sleep_on(&info->close_wait);
-		retval = ((info->flags & ASYNC_HUP_NOTIFY) ?
+	if (tty_hung_up_p(filp) || info->port.flags & ASYNC_CLOSING){
+		if (info->port.flags & ASYNC_CLOSING)
+			interruptible_sleep_on(&info->port.close_wait);
+		retval = ((info->port.flags & ASYNC_HUP_NOTIFY) ?
@@ -765 +756 @@
-	info->tty->low_latency = (info->flags & ASYNC_LOW_LATENCY) ? 1 : 0;
+	info->port.tty->low_latency = (info->port.flags & ASYNC_LOW_LATENCY) ? 1 : 0;
@@ -773 +764 @@
-	info->count++;
+	info->port.count++;
@@ -776 +767 @@
-	if (info->count == 1) {
+	if (info->port.count == 1) {
@@ -799,3 +790,3 @@
-			info->tty = NULL; /* tty layer will release tty struct */
-		if(info->count)
-			info->count--;
+			info->port.tty = NULL; /* tty layer will release tty struct */
+		if(info->port.count)
+			info->port.count--;
@@ -819 +810 @@
-			 __FILE__,__LINE__, info->device_name, info->count);
+			 __FILE__,__LINE__, info->device_name, info->port.count);
@@ -821 +812 @@
-	if (!info->count)
+	if (!info->port.count)
@@ -827 +818 @@
-	if ((tty->count == 1) && (info->count != 1)) {
+	if ((tty->count == 1) && (info->port.count != 1)) {
@@ -830 +821 @@
-		 * info->count should be one in this case.
+		 * info->port.count should be one in this case.
@@ -834,3 +825,3 @@
-		       "info->count is %d\n",
-			 __FILE__,__LINE__, info->device_name, info->count);
-		info->count = 1;
+		       "info->port.count is %d\n",
+			 __FILE__,__LINE__, info->device_name, info->port.count);
+		info->port.count = 1;
@@ -839 +830 @@
-	info->count--;
+	info->port.count--;
@@ -842 +833 @@
-	if (info->count)
+	if (info->port.count)
@@ -845 +836 @@
-	info->flags |= ASYNC_CLOSING;
+	info->port.flags |= ASYNC_CLOSING;
@@ -855 +846 @@
-	if (info->closing_wait != ASYNC_CLOSING_WAIT_NONE) {
+	if (info->port.closing_wait != ASYNC_CLOSING_WAIT_NONE) {
@@ -859 +850 @@
-		tty_wait_until_sent(tty, info->closing_wait);
+		tty_wait_until_sent(tty, info->port.closing_wait);
@@ -862 +853 @@
- 	if (info->flags & ASYNC_INITIALIZED)
+ 	if (info->port.flags & ASYNC_INITIALIZED)
@@ -872 +863 @@
-	info->tty = NULL;
+	info->port.tty = NULL;
@@ -874,3 +865,3 @@
-	if (info->blocked_open) {
-		if (info->close_delay) {
-			msleep_interruptible(jiffies_to_msecs(info->close_delay));
+	if (info->port.blocked_open) {
+		if (info->port.close_delay) {
+			msleep_interruptible(jiffies_to_msecs(info->port.close_delay));
@@ -878 +869 @@
-		wake_up_interruptible(&info->open_wait);
+		wake_up_interruptible(&info->port.open_wait);
@@ -881 +872 @@
-	info->flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
+	info->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
@@ -883 +874 @@
-	wake_up_interruptible(&info->close_wait);
+	wake_up_interruptible(&info->port.close_wait);
@@ -888 +879 @@
-			tty->driver->name, info->count);
+			tty->driver->name, info->port.count);
@@ -908,3 +899,3 @@
-	info->count = 0;
-	info->flags &= ~ASYNC_NORMAL_ACTIVE;
-	info->tty = NULL;
+	info->port.count = 0;
+	info->port.flags &= ~ASYNC_NORMAL_ACTIVE;
+	info->port.tty = NULL;
@@ -912 +903 @@
-	wake_up_interruptible(&info->open_wait);
+	wake_up_interruptible(&info->port.open_wait);
@@ -1126 +1117 @@
-	if (!(info->flags & ASYNC_INITIALIZED))
+	if (!(info->port.flags & ASYNC_INITIALIZED))
@@ -1596 +1587 @@
-static void set_break(struct tty_struct *tty, int break_state)
+static int set_break(struct tty_struct *tty, int break_state)
@@ -1607 +1598 @@
-		return;
+		return -EINVAL;
@@ -1616,0 +1608 @@
+	return 0;
@@ -1639 +1631 @@
-	if (info->count)
+	if (info->port.count)
@@ -1681 +1672,0 @@
-	struct net_device_stats *stats = hdlc_stats(dev);
@@ -1695,2 +1686,2 @@
-	stats->tx_packets++;
-	stats->tx_bytes += skb->len;
+	dev->stats.tx_packets++;
+	dev->stats.tx_bytes += skb->len;
@@ -1736 +1727 @@
-	if (info->count != 0 || info->netcount != 0) {
+	if (info->port.count != 0 || info->netcount != 0) {
@@ -1822 +1813 @@
-	if (info->count)
+	if (info->port.count)
@@ -1912 +1902,0 @@
-	struct net_device_stats *stats = hdlc_stats(dev);
@@ -1918,2 +1908,2 @@
-	stats->tx_errors++;
-	stats->tx_aborted_errors++;
+	dev->stats.tx_errors++;
+	dev->stats.tx_aborted_errors++;
@@ -1952 +1941,0 @@
-	struct net_device_stats *stats = hdlc_stats(dev);
@@ -1958,2 +1947,3 @@
-		printk(KERN_NOTICE "%s: can't alloc skb, dropping packet\n", dev->name);
-		stats->rx_dropped++;
+		printk(KERN_NOTICE "%s: can't alloc skb, dropping packet\n",
+		       dev->name);
+		dev->stats.rx_dropped++;
@@ -1963 +1953 @@
-	memcpy(skb_put(skb, size),buf,size);
+	memcpy(skb_put(skb, size), buf, size);
@@ -1965 +1955 @@
-	skb->protocol = hdlc_type_trans(skb, info->netdev);
+	skb->protocol = hdlc_type_trans(skb, dev);
@@ -1967,2 +1957,2 @@
-	stats->rx_packets++;
-	stats->rx_bytes += size;
+	dev->stats.rx_packets++;
+	dev->stats.rx_bytes += size;
@@ -1972 +1962 @@
-	info->netdev->last_rx = jiffies;
+	dev->last_rx = jiffies;
@@ -2131 +2121 @@
-	struct tty_struct *tty = info->tty;
+	struct tty_struct *tty = info->port.tty;
@@ -2181 +2171 @@
- 	struct tty_struct *tty = info->tty;
+ 	struct tty_struct *tty = info->port.tty;
@@ -2208 +2198 @@
-						if (info->flags & ASYNC_SAK)
+						if (info->port.flags & ASYNC_SAK)
@@ -2242 +2232 @@
- 	struct tty_struct *tty = info->tty;
+ 	struct tty_struct *tty = info->port.tty;
@@ -2355 +2345 @@
-			if (info->tty && (info->tty->stopped || info->tty->hw_stopped)) {
+			if (info->port.tty && (info->port.tty->stopped || info->port.tty->hw_stopped)) {
@@ -2410 +2400 @@
-	if (info->tty && (info->tty->stopped || info->tty->hw_stopped)) {
+	if (info->port.tty && (info->port.tty->stopped || info->port.tty->hw_stopped)) {
@@ -2557 +2547 @@
-		if ( (info->flags & ASYNC_CHECK_CD) &&
+		if ( (info->port.flags & ASYNC_CHECK_CD) &&
@@ -2563 +2553 @@
-				wake_up_interruptible(&info->open_wait);
+				wake_up_interruptible(&info->port.open_wait);
@@ -2567,2 +2557,2 @@
-				if (info->tty)
-					tty_hangup(info->tty);
+				if (info->port.tty)
+					tty_hangup(info->port.tty);
@@ -2572 +2562 @@
-		if ( (info->flags & ASYNC_CTS_FLOW) &&
+		if ( (info->port.flags & ASYNC_CTS_FLOW) &&
@@ -2574,2 +2564,2 @@
-			if ( info->tty ) {
-				if (info->tty->hw_stopped) {
+			if ( info->port.tty ) {
+				if (info->port.tty->hw_stopped) {
@@ -2579 +2569 @@
-			 			info->tty->hw_stopped = 0;
+			 			info->port.tty->hw_stopped = 0;
@@ -2588 +2578 @@
-			 			info->tty->hw_stopped = 1;
+			 			info->port.tty->hw_stopped = 1;
@@ -2704 +2694 @@
-		if ( port && (port->count || port->netcount) &&
+		if ( port && (port->port.count || port->netcount) &&
@@ -2730 +2720 @@
-	if (info->flags & ASYNC_INITIALIZED)
+	if (info->port.flags & ASYNC_INITIALIZED)
@@ -2753,2 +2743,2 @@
-	if (info->tty)
-		clear_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->port.tty)
+		clear_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -2756 +2746 @@
-	info->flags |= ASYNC_INITIALIZED;
+	info->port.flags |= ASYNC_INITIALIZED;
@@ -2767 +2757 @@
-	if (!(info->flags & ASYNC_INITIALIZED))
+	if (!(info->port.flags & ASYNC_INITIALIZED))
@@ -2789 +2779 @@
- 	if (!info->tty || info->tty->termios->c_cflag & HUPCL) {
+ 	if (!info->port.tty || info->port.tty->termios->c_cflag & HUPCL) {
@@ -2796,2 +2786,2 @@
-	if (info->tty)
-		set_bit(TTY_IO_ERROR, &info->tty->flags);
+	if (info->port.tty)
+		set_bit(TTY_IO_ERROR, &info->port.tty->flags);
@@ -2799 +2789 @@
-	info->flags &= ~ASYNC_INITIALIZED;
+	info->port.flags &= ~ASYNC_INITIALIZED;
@@ -2830 +2820 @@
-	if (info->netcount || (info->tty && info->tty->termios->c_cflag & CREAD) )
+	if (info->netcount || (info->port.tty && info->port.tty->termios->c_cflag & CREAD) )
@@ -2843 +2833 @@
-	if (!info->tty || !info->tty->termios)
+	if (!info->port.tty || !info->port.tty->termios)
@@ -2850 +2840 @@
-	cflag = info->tty->termios->c_cflag;
+	cflag = info->port.tty->termios->c_cflag;
@@ -2898 +2888 @@
-		info->params.data_rate = tty_get_baud_rate(info->tty);
+		info->params.data_rate = tty_get_baud_rate(info->port.tty);
@@ -2908 +2898 @@
-		info->flags |= ASYNC_CTS_FLOW;
+		info->port.flags |= ASYNC_CTS_FLOW;
@@ -2910 +2900 @@
-		info->flags &= ~ASYNC_CTS_FLOW;
+		info->port.flags &= ~ASYNC_CTS_FLOW;
@@ -2913 +2903 @@
-		info->flags &= ~ASYNC_CHECK_CD;
+		info->port.flags &= ~ASYNC_CHECK_CD;
@@ -2915 +2905 @@
-		info->flags |= ASYNC_CHECK_CD;
+		info->port.flags |= ASYNC_CHECK_CD;
@@ -2920 +2910 @@
-	if (I_INPCK(info->tty))
+	if (I_INPCK(info->port.tty))
@@ -2922 +2912 @@
- 	if (I_BRKINT(info->tty) || I_PARMRK(info->tty))
+ 	if (I_BRKINT(info->port.tty) || I_PARMRK(info->port.tty))
@@ -2924 +2914 @@
-	if (I_IGNPAR(info->tty))
+	if (I_IGNPAR(info->port.tty))
@@ -2926 +2916 @@
-	if (I_IGNBRK(info->tty)) {
+	if (I_IGNBRK(info->port.tty)) {
@@ -2931 +2921 @@
-		if (I_IGNPAR(info->tty))
+		if (I_IGNPAR(info->port.tty))
@@ -3351 +3341 @@
-		info->flags |= ASYNC_NORMAL_ACTIVE;
+		info->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -3360 +3350 @@
-	 * this loop, info->count is dropped by one, so that
+	 * this loop, info->port.count is dropped by one, so that
@@ -3366 +3356 @@
-	add_wait_queue(&info->open_wait, &wait);
+	add_wait_queue(&info->port.open_wait, &wait);
@@ -3370 +3360 @@
-			 __FILE__,__LINE__, tty->driver->name, info->count );
+			 __FILE__,__LINE__, tty->driver->name, info->port.count );
@@ -3375 +3365 @@
-		info->count--;
+		info->port.count--;
@@ -3378 +3368 @@
-	info->blocked_open++;
+	info->port.blocked_open++;
@@ -3390,2 +3380,2 @@
-		if (tty_hung_up_p(filp) || !(info->flags & ASYNC_INITIALIZED)){
-			retval = (info->flags & ASYNC_HUP_NOTIFY) ?
+		if (tty_hung_up_p(filp) || !(info->port.flags & ASYNC_INITIALIZED)){
+			retval = (info->port.flags & ASYNC_HUP_NOTIFY) ?
@@ -3400 +3390 @@
- 		if (!(info->flags & ASYNC_CLOSING) &&
+ 		if (!(info->port.flags & ASYNC_CLOSING) &&
@@ -3412 +3402 @@
-				 __FILE__,__LINE__, tty->driver->name, info->count );
+				 __FILE__,__LINE__, tty->driver->name, info->port.count );
@@ -3418 +3408 @@
-	remove_wait_queue(&info->open_wait, &wait);
+	remove_wait_queue(&info->port.open_wait, &wait);
@@ -3421,2 +3411,2 @@
-		info->count++;
-	info->blocked_open--;
+		info->port.count++;
+	info->port.blocked_open--;
@@ -3426 +3416 @@
-			 __FILE__,__LINE__, tty->driver->name, info->count );
+			 __FILE__,__LINE__, tty->driver->name, info->port.count );
@@ -3429 +3419 @@
-		info->flags |= ASYNC_NORMAL_ACTIVE;
+		info->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -3762 +3751,0 @@
-		info->dosyncppp = dosyncppp[info->line];
@@ -3810,0 +3800 @@
+		tty_port_init(&info->port);
@@ -3814,4 +3804,2 @@
-		info->close_delay = 5*HZ/10;
-		info->closing_wait = 30*HZ;
-		init_waitqueue_head(&info->open_wait);
-		init_waitqueue_head(&info->close_wait);
+		info->port.close_delay = 5*HZ/10;
+		info->port.closing_wait = 30*HZ;
@@ -4888 +4876 @@
-	struct tty_struct *tty = info->tty;
+	struct tty_struct *tty = info->port.tty;
@@ -4986,3 +4974,2 @@
-			struct net_device_stats *stats = hdlc_stats(info->netdev);
-			stats->rx_errors++;
-			stats->rx_frame_errors++;
+			info->netdev->stats.rx_errors++;
+			info->netdev->stats.rx_frame_errors++;
@@ -5296 +5283 @@
-	struct tty_struct *oldtty = info->tty;
+	struct tty_struct *oldtty = info->port.tty;
@@ -5300 +5287 @@
-	info->tty = NULL;
+	info->port.tty = NULL;
@@ -5344 +5331 @@
-	info->tty = oldtty;
+	info->port.tty = oldtty;
--- ./projects/linux/linux-2.6.28/drivers/char/synclinkmp.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/char/synclinkmp.c	2009-03-24 00:12:14.000000000 +0100
@@ -560,0 +561 @@
+static int carrier_raised(struct tty_port *port);
@@ -803 +804 @@
-	SLMP_INFO * info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO * info = tty->driver_data;
@@ -812,22 +813 @@
-	if (!info->port.count)
-		return;
-
-	if (tty_hung_up_p(filp))
-		goto cleanup;
-
-	if ((tty->count == 1) && (info->port.count != 1)) {
-		/*
-		 * tty->count is 1 and the tty structure will be freed.
-		 * info->port.count should be one in this case.
-		 * if it's not, correct it so that the port is shutdown.
-		 */
-		printk("%s(%d):%s close: bad refcount; tty->count is 1, "
-		       "info->port.count is %d\n",
-			 __FILE__,__LINE__, info->device_name, info->port.count);
-		info->port.count = 1;
-	}
-
-	info->port.count--;
-
-	/* if at least one open remaining, leave hardware active */
-	if (info->port.count)
+	if (tty_port_close_start(&info->port, tty, filp) == 0)
@@ -835,18 +815 @@
-
-	info->port.flags |= ASYNC_CLOSING;
-
-	/* set tty->closing to notify line discipline to
-	 * only process XON/XOFF characters. Only the N_TTY
-	 * discipline appears to use this (ppp does not).
-	 */
-	tty->closing = 1;
-
-	/* wait for transmit data to clear all layers */
-
-	if (info->port.closing_wait != ASYNC_CLOSING_WAIT_NONE) {
-		if (debug_level >= DEBUG_LEVEL_INFO)
-			printk("%s(%d):%s close() calling tty_wait_until_sent\n",
-				 __FILE__,__LINE__, info->device_name );
-		tty_wait_until_sent(tty, info->port.closing_wait);
-	}
-
+		
@@ -857 +819,0 @@
-
@@ -859 +820,0 @@
-
@@ -862 +823 @@
-	tty->closing = 0;
+	tty_port_close_end(&info->port, tty);
@@ -864,12 +824,0 @@
-
-	if (info->port.blocked_open) {
-		if (info->port.close_delay) {
-			msleep_interruptible(jiffies_to_msecs(info->port.close_delay));
-		}
-		wake_up_interruptible(&info->port.open_wait);
-	}
-
-	info->port.flags &= ~(ASYNC_NORMAL_ACTIVE|ASYNC_CLOSING);
-
-	wake_up_interruptible(&info->port.close_wait);
-
@@ -887 +836 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -910 +859 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -963 +912 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -1041 +990 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -1078 +1027 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -1102 +1051 @@
-	SLMP_INFO * info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO * info = tty->driver_data;
@@ -1169 +1118 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -1196 +1145 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -1235 +1184 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -1257 +1206 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -1277 +1226 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -1307 +1256 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -1518 +1467 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -1534 +1483 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -1559 +1508 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -1590 +1539 @@
-	SLMP_INFO * info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO * info = tty->driver_data;
@@ -3272 +3221 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -3298 +3247 @@
-	SLMP_INFO *info = (SLMP_INFO *)tty->driver_data;
+	SLMP_INFO *info = tty->driver_data;
@@ -3320,0 +3270,8 @@
+static int carrier_raised(struct tty_port *port)
+{
+	SLMP_INFO *info = container_of(port, SLMP_INFO, port);
+	unsigned long flags;
+
+	spin_lock_irqsave(&info->lock,flags);
+ 	get_signals(info);
+	spin_unlock_irqrestore(&info->lock,flags);
@@ -3321,0 +3279,13 @@
+	return (info->serial_signals & SerialSignal_DCD) ? 1 : 0;
+}
+
+static void raise_dtr_rts(struct tty_port *port)
+{
+	SLMP_INFO *info = container_of(port, SLMP_INFO, port);
+	unsigned long flags;
+
+	spin_lock_irqsave(&info->lock,flags);
+	info->serial_signals |= SerialSignal_RTS + SerialSignal_DTR;
+ 	set_signals(info);
+	spin_unlock_irqrestore(&info->lock,flags);
+}
@@ -3332,0 +3303,2 @@
+	int		cd;
+	struct tty_port *port = &info->port;
@@ -3341 +3313 @@
-		info->port.flags |= ASYNC_NORMAL_ACTIVE;
+		port->flags |= ASYNC_NORMAL_ACTIVE;
@@ -3350 +3322 @@
-	 * this loop, info->port.count is dropped by one, so that
+	 * this loop, port->count is dropped by one, so that
@@ -3356 +3328 @@
-	add_wait_queue(&info->port.open_wait, &wait);
+	add_wait_queue(&port->open_wait, &wait);
@@ -3360 +3332 @@
-			 __FILE__,__LINE__, tty->driver->name, info->port.count );
+			 __FILE__,__LINE__, tty->driver->name, port->count );
@@ -3365 +3337 @@
-		info->port.count--;
+		port->count--;
@@ -3368 +3340 @@
-	info->port.blocked_open++;
+	port->blocked_open++;
@@ -3371,6 +3343,2 @@
-		if ((tty->termios->c_cflag & CBAUD)) {
-			spin_lock_irqsave(&info->lock,flags);
-			info->serial_signals |= SerialSignal_RTS + SerialSignal_DTR;
-		 	set_signals(info);
-			spin_unlock_irqrestore(&info->lock,flags);
-		}
+		if (tty->termios->c_cflag & CBAUD)
+			tty_port_raise_dtr_rts(port);
@@ -3380,2 +3348,2 @@
-		if (tty_hung_up_p(filp) || !(info->port.flags & ASYNC_INITIALIZED)){
-			retval = (info->port.flags & ASYNC_HUP_NOTIFY) ?
+		if (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)){
+			retval = (port->flags & ASYNC_HUP_NOTIFY) ?
@@ -3386,3 +3354 @@
-		spin_lock_irqsave(&info->lock,flags);
-	 	get_signals(info);
-		spin_unlock_irqrestore(&info->lock,flags);
+		cd = tty_port_carrier_raised(port);
@@ -3390,2 +3356 @@
- 		if (!(info->port.flags & ASYNC_CLOSING) &&
- 		    (do_clocal || (info->serial_signals & SerialSignal_DCD)) ) {
+ 		if (!(port->flags & ASYNC_CLOSING) && (do_clocal || cd))
@@ -3393 +3357,0 @@
-		}
@@ -3402 +3366 @@
-				 __FILE__,__LINE__, tty->driver->name, info->port.count );
+				 __FILE__,__LINE__, tty->driver->name, port->count );
@@ -3408 +3372 @@
-	remove_wait_queue(&info->port.open_wait, &wait);
+	remove_wait_queue(&port->open_wait, &wait);
@@ -3411,2 +3375,2 @@
-		info->port.count++;
-	info->port.blocked_open--;
+		port->count++;
+	port->blocked_open--;
@@ -3416 +3380 @@
-			 __FILE__,__LINE__, tty->driver->name, info->port.count );
+			 __FILE__,__LINE__, tty->driver->name, port->count );
@@ -3419 +3383 @@
-		info->port.flags |= ASYNC_NORMAL_ACTIVE;
+		port->flags |= ASYNC_NORMAL_ACTIVE;
@@ -3784,0 +3749,5 @@
+static const struct tty_port_operations port_ops = {
+	.carrier_raised = carrier_raised,
+	.raise_dtr_rts = raise_dtr_rts,
+};
+
@@ -3800,0 +3770 @@
+		info->port.ops = &port_ops;
@@ -3942,0 +3913 @@
+
--- ./projects/linux/linux-2.6.29/drivers/char/synclinkmp.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/char/synclinkmp.c	2009-06-27 11:32:32.000000000 +0200
@@ -52,0 +53 @@
+#include <linux/seq_file.h>
@@ -523 +523,0 @@
-static int  read_proc(char *page, char **start, off_t off, int count,int *eof, void *data);
@@ -1357 +1357 @@
-static inline int line_info(char *buf, SLMP_INFO *info)
+static inline void line_info(struct seq_file *m, SLMP_INFO *info)
@@ -1360 +1359,0 @@
-	int	ret;
@@ -1363 +1362 @@
-	ret = sprintf(buf, "%s: SCABase=%08x Mem=%08X StatusControl=%08x LCR=%08X\n"
+	seq_printf(m, "%s: SCABase=%08x Mem=%08X StatusControl=%08x LCR=%08X\n"
@@ -1394 +1393 @@
-		ret += sprintf(buf+ret, "\tHDLC txok:%d rxok:%d",
+		seq_printf(m, "\tHDLC txok:%d rxok:%d",
@@ -1397 +1396 @@
-			ret += sprintf(buf+ret, " txunder:%d", info->icount.txunder);
+			seq_printf(m, " txunder:%d", info->icount.txunder);
@@ -1399 +1398 @@
-			ret += sprintf(buf+ret, " txabort:%d", info->icount.txabort);
+			seq_printf(m, " txabort:%d", info->icount.txabort);
@@ -1401 +1400 @@
-			ret += sprintf(buf+ret, " rxshort:%d", info->icount.rxshort);
+			seq_printf(m, " rxshort:%d", info->icount.rxshort);
@@ -1403 +1402 @@
-			ret += sprintf(buf+ret, " rxlong:%d", info->icount.rxlong);
+			seq_printf(m, " rxlong:%d", info->icount.rxlong);
@@ -1405 +1404 @@
-			ret += sprintf(buf+ret, " rxover:%d", info->icount.rxover);
+			seq_printf(m, " rxover:%d", info->icount.rxover);
@@ -1407 +1406 @@
-			ret += sprintf(buf+ret, " rxlong:%d", info->icount.rxcrc);
+			seq_printf(m, " rxlong:%d", info->icount.rxcrc);
@@ -1409 +1408 @@
-		ret += sprintf(buf+ret, "\tASYNC tx:%d rx:%d",
+		seq_printf(m, "\tASYNC tx:%d rx:%d",
@@ -1412 +1411 @@
-			ret += sprintf(buf+ret, " fe:%d", info->icount.frame);
+			seq_printf(m, " fe:%d", info->icount.frame);
@@ -1414 +1413 @@
-			ret += sprintf(buf+ret, " pe:%d", info->icount.parity);
+			seq_printf(m, " pe:%d", info->icount.parity);
@@ -1416 +1415 @@
-			ret += sprintf(buf+ret, " brk:%d", info->icount.brk);
+			seq_printf(m, " brk:%d", info->icount.brk);
@@ -1418 +1417 @@
-			ret += sprintf(buf+ret, " oe:%d", info->icount.overrun);
+			seq_printf(m, " oe:%d", info->icount.overrun);
@@ -1422 +1421 @@
-	ret += sprintf(buf+ret, " %s\n", stat_buf+1);
+	seq_printf(m, " %s\n", stat_buf+1);
@@ -1424 +1423 @@
-	ret += sprintf(buf+ret, "\ttxactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",
+	seq_printf(m, "\ttxactive=%d bh_req=%d bh_run=%d pending_bh=%x\n",
@@ -1427,2 +1425,0 @@
-
-	return ret;
@@ -1433,2 +1430 @@
-static int read_proc(char *page, char **start, off_t off, int count,
-	      int *eof, void *data)
+static int synclinkmp_proc_show(struct seq_file *m, void *v)
@@ -1436,2 +1431,0 @@
-	int len = 0, l;
-	off_t	begin = 0;
@@ -1440 +1434 @@
-	len += sprintf(page, "synclinkmp driver:%s\n", driver_version);
+	seq_printf(m, "synclinkmp driver:%s\n", driver_version);
@@ -1444,8 +1438 @@
-		l = line_info(page + len, info);
-		len += l;
-		if (len+begin > off+count)
-			goto done;
-		if (len+begin < off) {
-			begin += len;
-			len = 0;
-		}
+		line_info(m, info);
@@ -1453,0 +1441,2 @@
+	return 0;
+}
@@ -1455,6 +1444,3 @@
-	*eof = 1;
-done:
-	if (off >= len+begin)
-		return 0;
-	*start = page + (off-begin);
-	return ((count < begin+len-off) ? count : begin+len-off);
+static int synclinkmp_proc_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, synclinkmp_proc_show, NULL);
@@ -1462,0 +1449,8 @@
+static const struct file_operations synclinkmp_proc_fops = {
+	.owner		= THIS_MODULE,
+	.open		= synclinkmp_proc_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+};
+
@@ -1910,2 +1903,0 @@
-
-	dev->last_rx = jiffies;
@@ -1913,0 +1906,9 @@
+static const struct net_device_ops hdlcdev_ops = {
+	.ndo_open       = hdlcdev_open,
+	.ndo_stop       = hdlcdev_close,
+	.ndo_change_mtu = hdlc_change_mtu,
+	.ndo_start_xmit = hdlc_start_xmit,
+	.ndo_do_ioctl   = hdlcdev_ioctl,
+	.ndo_tx_timeout = hdlcdev_tx_timeout,
+};
+
@@ -1941,5 +1942,2 @@
-	dev->do_ioctl       = hdlcdev_ioctl;
-	dev->open           = hdlcdev_open;
-	dev->stop           = hdlcdev_close;
-	dev->tx_timeout     = hdlcdev_tx_timeout;
-	dev->watchdog_timeo = 10*HZ;
+	dev->netdev_ops	    = &hdlcdev_ops;
+	dev->watchdog_timeo = 10 * HZ;
@@ -3904 +3901,0 @@
- 	.read_proc = read_proc,
@@ -3910,0 +3908 @@
+	.proc_fops = &synclinkmp_proc_fops,
--- ./projects/linux/linux-2.6.13/drivers/cpufreq/cpufreq.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/cpufreq/cpufreq.c	2005-10-28 02:02:08.000000000 +0200
@@ -630 +630 @@
-		goto err_out;
+		goto err_out_driver_exit;
@@ -675,0 +676,4 @@
+err_out_driver_exit:
+	if (cpufreq_driver->exit)
+		cpufreq_driver->exit(policy);
+
--- ./projects/linux/linux-2.6.14/drivers/cpufreq/cpufreq.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/cpufreq/cpufreq.c	2006-01-03 04:21:10.000000000 +0100
@@ -6,0 +7,3 @@
+ *  Oct 2005 - Ashok Raj <ashok.raj@intel.com>
+ *         		Added handling for CPU hotplug
+ *
@@ -38,8 +40,0 @@
-
-/* we keep a copy of all ->add'ed CPU's struct sys_device here;
- * as it is only accessed in ->add and ->remove, no lock or reference
- * count is necessary.
- */
-static struct sys_device	*cpu_sys_devices[NR_CPUS];
-
-
@@ -576,0 +572,3 @@
+	if (cpu_is_offline(cpu))
+		return 0;
+
@@ -585 +582,0 @@
-		cpu_sys_devices[cpu] = sys_dev;
@@ -598 +595 @@
-	policy = kmalloc(sizeof(struct cpufreq_policy), GFP_KERNEL);
+	policy = kzalloc(sizeof(struct cpufreq_policy), GFP_KERNEL);
@@ -603 +599,0 @@
-	memset(policy, 0, sizeof(struct cpufreq_policy));
@@ -660 +655,0 @@
-	cpu_sys_devices[cpu] = sys_dev;
@@ -685 +680 @@
- module_out:
+module_out:
@@ -701,0 +697 @@
+	struct sys_device *cpu_sys_dev;
@@ -713 +708,0 @@
-		cpu_sys_devices[cpu] = NULL;
@@ -728 +722,0 @@
-		cpu_sys_devices[cpu] = NULL;
@@ -735 +728,0 @@
-	cpu_sys_devices[cpu] = NULL;
@@ -764 +757,2 @@
-			sysfs_remove_link(&cpu_sys_devices[j]->kobj, "cpufreq");
+			cpu_sys_dev = get_cpu_sysdev(j);
+			sysfs_remove_link(&cpu_sys_dev->kobj, "cpufreq");
@@ -775 +768,0 @@
-	cpufreq_driver->target = NULL;
@@ -1121,0 +1115 @@
+
@@ -1126,0 +1121 @@
+
@@ -1127,0 +1123 @@
+
@@ -1132 +1127,0 @@
-
@@ -1418,0 +1414,39 @@
+static int __cpuinit cpufreq_cpu_callback(struct notifier_block *nfb,
+					unsigned long action, void *hcpu)
+{
+	unsigned int cpu = (unsigned long)hcpu;
+	struct cpufreq_policy *policy;
+	struct sys_device *sys_dev;
+
+	sys_dev = get_cpu_sysdev(cpu);
+
+	if (sys_dev) {
+		switch (action) {
+		case CPU_ONLINE:
+			cpufreq_add_dev(sys_dev);
+			break;
+		case CPU_DOWN_PREPARE:
+			/*
+			 * We attempt to put this cpu in lowest frequency
+			 * possible before going down. This will permit
+			 * hardware-managed P-State to switch other related
+			 * threads to min or higher speeds if possible.
+			 */
+			policy = cpufreq_cpu_data[cpu];
+			if (policy) {
+				cpufreq_driver_target(policy, policy->min,
+						CPUFREQ_RELATION_H);
+			}
+			break;
+		case CPU_DEAD:
+			cpufreq_remove_dev(sys_dev);
+			break;
+		}
+	}
+	return NOTIFY_OK;
+}
+
+static struct notifier_block cpufreq_cpu_notifier =
+{
+    .notifier_call = cpufreq_cpu_callback,
+};
@@ -1478,0 +1513 @@
+		register_cpu_notifier(&cpufreq_cpu_notifier);
@@ -1509,0 +1545 @@
+	unregister_cpu_notifier(&cpufreq_cpu_notifier);
--- ./projects/linux/linux-2.6.15/drivers/cpufreq/cpufreq.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/cpufreq/cpufreq.c	2006-03-20 06:53:29.000000000 +0100
@@ -28,0 +29 @@
+#include <linux/mutex.h>
@@ -37,2 +38,2 @@
-static struct cpufreq_driver   	*cpufreq_driver;
-static struct cpufreq_policy	*cpufreq_cpu_data[NR_CPUS];
+static struct cpufreq_driver *cpufreq_driver;
+static struct cpufreq_policy *cpufreq_cpu_data[NR_CPUS];
@@ -44 +44,0 @@
-static inline void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci);
@@ -53,3 +53,3 @@
-static struct notifier_block    *cpufreq_policy_notifier_list;
-static struct notifier_block    *cpufreq_transition_notifier_list;
-static DECLARE_RWSEM		(cpufreq_notifier_rwsem);
+static struct notifier_block *cpufreq_policy_notifier_list;
+static struct notifier_block *cpufreq_transition_notifier_list;
+static DECLARE_RWSEM (cpufreq_notifier_rwsem);
@@ -59 +59 @@
-static DECLARE_MUTEX		(cpufreq_governor_sem);
+static DEFINE_MUTEX (cpufreq_governor_mutex);
@@ -61 +61 @@
-struct cpufreq_policy * cpufreq_cpu_get(unsigned int cpu)
+struct cpufreq_policy *cpufreq_cpu_get(unsigned int cpu)
@@ -88 +87,0 @@
-
@@ -90 +88,0 @@
-
@@ -93 +91 @@
- err_out_put_module:
+err_out_put_module:
@@ -95 +93 @@
- err_out_unlock:
+err_out_unlock:
@@ -97 +95 @@
- err_out:
+err_out:
@@ -101,0 +100 @@
+
@@ -130 +129 @@
-static inline void cpufreq_debug_enable_ratelimit(void)
+static void cpufreq_debug_enable_ratelimit(void)
@@ -140 +139 @@
-static inline void cpufreq_debug_disable_ratelimit(void)
+static void cpufreq_debug_disable_ratelimit(void)
@@ -209 +208 @@
-static inline void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci)
+static void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci)
@@ -232 +231,2 @@
- * cpufreq_notify_transition - call notifier chain and adjust_jiffies on frequency transition
+ * cpufreq_notify_transition - call notifier chain and adjust_jiffies
+ * on frequency transition.
@@ -234,2 +234,3 @@
- * This function calls the transition notifiers and the "adjust_jiffies" function. It is called
- * twice on all CPU frequency changes that have external effects. 
+ * This function calls the transition notifiers and the "adjust_jiffies"
+ * function. It is called twice on all CPU frequency changes that have
+ * external effects. 
@@ -238,0 +240,2 @@
+	struct cpufreq_policy *policy;
+
@@ -242 +245,2 @@
-	dprintk("notification %u of frequency transition to %u kHz\n", state, freqs->new);
+	dprintk("notification %u of frequency transition to %u kHz\n",
+		state, freqs->new);
@@ -244,0 +249,2 @@
+
+	policy = cpufreq_cpu_data[freqs->cpu];
@@ -245,0 +252 @@
+
@@ -247,2 +254,3 @@
-		/* detect if the driver reported a value as "old frequency" which
-		 * is not equal to what the cpufreq core thinks is "old frequency".
+		/* detect if the driver reported a value as "old frequency" 
+		 * which is not equal to what the cpufreq core thinks is
+		 * "old frequency".
@@ -251,8 +259,6 @@
-			if ((likely(cpufreq_cpu_data[freqs->cpu])) &&
-			    (likely(cpufreq_cpu_data[freqs->cpu]->cpu == freqs->cpu)) &&
-			    (likely(cpufreq_cpu_data[freqs->cpu]->cur)) &&
-			    (unlikely(freqs->old != cpufreq_cpu_data[freqs->cpu]->cur)))
-			{
-				dprintk(KERN_WARNING "Warning: CPU frequency is %u, "
-				       "cpufreq assumed %u kHz.\n", freqs->old, cpufreq_cpu_data[freqs->cpu]->cur);
-				freqs->old = cpufreq_cpu_data[freqs->cpu]->cur;
+			if ((policy) && (policy->cpu == freqs->cpu) &&
+			    (policy->cur) && (policy->cur != freqs->old)) {
+				dprintk(KERN_WARNING "Warning: CPU frequency is"
+					" %u, cpufreq assumed %u kHz.\n",
+					freqs->old, policy->cur);
+				freqs->old = policy->cur;
@@ -261 +267,2 @@
-		notifier_call_chain(&cpufreq_transition_notifier_list, CPUFREQ_PRECHANGE, freqs);
+		notifier_call_chain(&cpufreq_transition_notifier_list,
+					CPUFREQ_PRECHANGE, freqs);
@@ -263,0 +271 @@
+
@@ -266,4 +274,4 @@
-		notifier_call_chain(&cpufreq_transition_notifier_list, CPUFREQ_POSTCHANGE, freqs);
-		if ((likely(cpufreq_cpu_data[freqs->cpu])) && 
-		    (likely(cpufreq_cpu_data[freqs->cpu]->cpu == freqs->cpu)))
-			cpufreq_cpu_data[freqs->cpu]->cur = freqs->new;
+		notifier_call_chain(&cpufreq_transition_notifier_list,
+					CPUFREQ_POSTCHANGE, freqs);
+		if (likely(policy) && likely(policy->cpu == freqs->cpu))
+			policy->cur = freqs->new;
@@ -301 +309 @@
-		down(&cpufreq_governor_sem);
+		mutex_lock(&cpufreq_governor_mutex);
@@ -307 +315 @@
-				up(&cpufreq_governor_sem);
+				mutex_unlock(&cpufreq_governor_mutex);
@@ -311,2 +319,2 @@
-	out:
-		up(&cpufreq_governor_sem);
+out:
+		mutex_unlock(&cpufreq_governor_mutex);
@@ -418 +425,0 @@
-
@@ -449 +456 @@
- out:
+out:
@@ -604 +611,2 @@
-	init_MUTEX_LOCKED(&policy->lock);
+	mutex_init(&policy->lock);
+	mutex_lock(&policy->lock);
@@ -613,0 +622 @@
+		mutex_unlock(&policy->lock);
@@ -625 +634,2 @@
-	if (ret)
+	if (ret) {
+		mutex_unlock(&policy->lock);
@@ -627 +637 @@
-
+	}
@@ -645 +655 @@
-	up(&policy->lock);
+	mutex_unlock(&policy->lock);
@@ -766 +776 @@
-	down(&data->lock);
+	mutex_lock(&data->lock);
@@ -769 +779 @@
-	up(&data->lock);
+	mutex_unlock(&data->lock);
@@ -789 +798,0 @@
-
@@ -825,0 +835,24 @@
+ * cpufreq_quick_get - get the CPU frequency (in kHz) frpm policy->cur
+ * @cpu: CPU number
+ *
+ * This is the last known freq, without actually getting it from the driver.
+ * Return value will be same as what is shown in scaling_cur_freq in sysfs.
+ */
+unsigned int cpufreq_quick_get(unsigned int cpu)
+{
+	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+	unsigned int ret = 0;
+
+	if (policy) {
+		mutex_lock(&policy->lock);
+		ret = policy->cur;
+		mutex_unlock(&policy->lock);
+		cpufreq_cpu_put(policy);
+	}
+
+	return (ret);
+}
+EXPORT_SYMBOL(cpufreq_quick_get);
+
+
+/** 
@@ -842 +875 @@
-	down(&policy->lock);
+	mutex_lock(&policy->lock);
@@ -846,2 +879 @@
-	if (ret && policy->cur && !(cpufreq_driver->flags & CPUFREQ_CONST_LOOPS)) 
-	{
+	if (ret && policy->cur && !(cpufreq_driver->flags & CPUFREQ_CONST_LOOPS)) {
@@ -855 +887 @@
-	up(&policy->lock);
+	mutex_unlock(&policy->lock);
@@ -857 +889 @@
- out:
+out:
@@ -938 +970 @@
- out:
+out:
@@ -1138 +1170 @@
-	down(&policy->lock);
+	mutex_lock(&policy->lock);
@@ -1142 +1174 @@
-	up(&policy->lock);
+	mutex_unlock(&policy->lock);
@@ -1145 +1176,0 @@
-
@@ -1179 +1210 @@
-	down(&policy->lock);
+	mutex_lock(&policy->lock);
@@ -1181 +1212 @@
-	up(&policy->lock);
+	mutex_unlock(&policy->lock);
@@ -1184 +1214,0 @@
-
@@ -1197 +1227 @@
-	down(&cpufreq_governor_sem);
+	mutex_lock(&cpufreq_governor_mutex);
@@ -1201 +1231 @@
-			up(&cpufreq_governor_sem);
+			mutex_unlock(&cpufreq_governor_mutex);
@@ -1207,2 +1237 @@
- 	up(&cpufreq_governor_sem);
-
+ 	mutex_unlock(&cpufreq_governor_mutex);
@@ -1219 +1248 @@
-	down(&cpufreq_governor_sem);
+	mutex_lock(&cpufreq_governor_mutex);
@@ -1221 +1250 @@
-	up(&cpufreq_governor_sem);
+	mutex_unlock(&cpufreq_governor_mutex);
@@ -1248 +1277 @@
-	down(&cpu_policy->lock);
+	mutex_lock(&cpu_policy->lock);
@@ -1250 +1279 @@
-	up(&cpu_policy->lock);
+	mutex_unlock(&cpu_policy->lock);
@@ -1253 +1281,0 @@
-
@@ -1267,3 +1295 @@
-	memcpy(&policy->cpuinfo, 
-	       &data->cpuinfo, 
-	       sizeof(struct cpufreq_cpuinfo));
+	memcpy(&policy->cpuinfo, &data->cpuinfo, sizeof(struct cpufreq_cpuinfo));
@@ -1300,2 +1326,2 @@
-	data->min    = policy->min;
-	data->max    = policy->max;
+	data->min = policy->min;
+	data->max = policy->max;
@@ -1338 +1364 @@
- error_out:
+error_out:
@@ -1362 +1388 @@
-	down(&data->lock);
+	mutex_lock(&data->lock);
@@ -1370 +1396 @@
-	up(&data->lock);
+	mutex_unlock(&data->lock);
@@ -1394 +1420 @@
-	down(&data->lock);
+	mutex_lock(&data->lock);
@@ -1397,3 +1423 @@
-	memcpy(&policy, 
-	       data,
-	       sizeof(struct cpufreq_policy));
+	memcpy(&policy, data, sizeof(struct cpufreq_policy));
@@ -1404,0 +1429,13 @@
+	/* BIOS might change freq behind our back
+	  -> ask driver for current freq and notify governors about a change */
+	if (cpufreq_driver->get) {
+		policy.cur = cpufreq_driver->get(cpu);
+		if (!data->cur) {
+			dprintk("Driver did not initialize current freq");
+			data->cur = policy.cur;
+		} else {
+			if (data->cur != policy.cur)
+				cpufreq_out_of_sync(cpu, data->cur, policy.cur);
+		}
+	}
+
@@ -1407 +1444 @@
-	up(&data->lock);
+	mutex_unlock(&data->lock);
--- ./projects/linux/linux-2.6.16/drivers/cpufreq/cpufreq.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/cpufreq/cpufreq.c	2006-06-18 03:49:35.000000000 +0200
@@ -8 +8,3 @@
- *         		Added handling for CPU hotplug
+ *	Added handling for CPU hotplug
+ *  Feb 2006 - Jacob Shin <jacob.shin@amd.com>
+ *	Fix handling for CPU hotplug -- affected CPUs
@@ -47,2 +49,2 @@
- * Two notifier lists: the "policy" list is involved in the 
- * validation process for a new CPU frequency policy; the 
+ * Two notifier lists: the "policy" list is involved in the
+ * validation process for a new CPU frequency policy; the
@@ -53,3 +55,2 @@
-static struct notifier_block *cpufreq_policy_notifier_list;
-static struct notifier_block *cpufreq_transition_notifier_list;
-static DECLARE_RWSEM (cpufreq_notifier_rwsem);
+static BLOCKING_NOTIFIER_HEAD(cpufreq_policy_notifier_list);
+static BLOCKING_NOTIFIER_HEAD(cpufreq_transition_notifier_list);
@@ -154 +155 @@
-	
+
@@ -201 +202 @@
- * systems as each CPU might be scaled differently. So, use the arch 
+ * systems as each CPU might be scaled differently. So, use the arch
@@ -236 +237 @@
- * external effects. 
+ * external effects.
@@ -248,2 +248,0 @@
-	down_read(&cpufreq_notifier_rwsem);
-
@@ -254 +253 @@
-		/* detect if the driver reported a value as "old frequency" 
+		/* detect if the driver reported a value as "old frequency"
@@ -267,2 +266,2 @@
-		notifier_call_chain(&cpufreq_transition_notifier_list,
-					CPUFREQ_PRECHANGE, freqs);
+		blocking_notifier_call_chain(&cpufreq_transition_notifier_list,
+				CPUFREQ_PRECHANGE, freqs);
@@ -274,2 +273,2 @@
-		notifier_call_chain(&cpufreq_transition_notifier_list,
-					CPUFREQ_POSTCHANGE, freqs);
+		blocking_notifier_call_chain(&cpufreq_transition_notifier_list,
+				CPUFREQ_POSTCHANGE, freqs);
@@ -280 +278,0 @@
-	up_read(&cpufreq_notifier_rwsem);
@@ -324 +321,0 @@
-EXPORT_SYMBOL_GPL(cpufreq_parse_governor);
@@ -338,5 +335,5 @@
-#define show_one(file_name, object)		 			\
-static ssize_t show_##file_name 					\
-(struct cpufreq_policy * policy, char *buf)				\
-{									\
-	return sprintf (buf, "%u\n", policy->object);			\
+#define show_one(file_name, object)			\
+static ssize_t show_##file_name				\
+(struct cpufreq_policy * policy, char *buf)		\
+{							\
+	return sprintf (buf, "%u\n", policy->object);	\
@@ -350,0 +348,2 @@
+static int __cpufreq_set_policy(struct cpufreq_policy *data, struct cpufreq_policy *policy);
+
@@ -369 +368,4 @@
-	ret = cpufreq_set_policy(&new_policy);				\
+	mutex_lock(&policy->lock);					\
+	ret = __cpufreq_set_policy(policy, &new_policy);		\
+	policy->user_policy.object = policy->object;			\
+	mutex_unlock(&policy->lock);					\
@@ -407,2 +409,2 @@
-static ssize_t store_scaling_governor (struct cpufreq_policy * policy, 
-				       const char *buf, size_t count) 
+static ssize_t store_scaling_governor (struct cpufreq_policy * policy,
+				       const char *buf, size_t count)
@@ -425 +427,9 @@
-	ret = cpufreq_set_policy(&new_policy);
+	/* Do not use cpufreq_set_policy here or the user_policy.max
+	   will be wrongly overridden */
+	mutex_lock(&policy->lock);
+	ret = __cpufreq_set_policy(policy, &new_policy);
+
+	policy->user_policy.policy = policy->policy;
+	policy->user_policy.governor = policy->governor;
+	mutex_unlock(&policy->lock);
+
@@ -531 +541 @@
-static ssize_t store(struct kobject * kobj, struct attribute * attr, 
+static ssize_t store(struct kobject * kobj, struct attribute * attr,
@@ -567 +577 @@
- * Adds the cpufreq interface for a CPU device. 
+ * Adds the cpufreq interface for a CPU device.
@@ -575,0 +586 @@
+	struct sys_device *cpu_sys_dev;
@@ -577,0 +589,3 @@
+#ifdef CONFIG_SMP
+	struct cpufreq_policy *managed_policy;
+#endif
@@ -590,2 +604 @@
-		dprintk("CPU already managed, adding link\n");
-		sysfs_create_link(&sys_dev->kobj, &policy->kobj, "cpufreq");
+		cpufreq_cpu_put(policy);
@@ -625,0 +639,26 @@
+#ifdef CONFIG_SMP
+	for_each_cpu_mask(j, policy->cpus) {
+		if (cpu == j)
+			continue;
+
+		/* check for existing affected CPUs.  They may not be aware
+		 * of it due to CPU Hotplug.
+		 */
+		managed_policy = cpufreq_cpu_get(j);
+		if (unlikely(managed_policy)) {
+			spin_lock_irqsave(&cpufreq_driver_lock, flags);
+			managed_policy->cpus = policy->cpus;
+			cpufreq_cpu_data[cpu] = managed_policy;
+			spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
+
+			dprintk("CPU already managed, adding link\n");
+			sysfs_create_link(&sys_dev->kobj,
+					  &managed_policy->kobj, "cpufreq");
+
+			cpufreq_debug_enable_ratelimit();
+			mutex_unlock(&policy->lock);
+			ret = 0;
+			goto err_out_driver_exit; /* call driver->exit() */
+		}
+	}
+#endif
@@ -652,0 +692,15 @@
+
+	/* symlink affected CPUs */
+	for_each_cpu_mask(j, policy->cpus) {
+		if (j == cpu)
+			continue;
+		if (!cpu_online(j))
+			continue;
+
+		dprintk("CPU %u already managed, adding link\n", j);
+		cpufreq_cpu_get(cpu);
+		cpu_sys_dev = get_cpu_sysdev(j);
+		sysfs_create_link(&cpu_sys_dev->kobj, &policy->kobj,
+				  "cpufreq");
+	}
+
@@ -656 +710 @@
-	
+
@@ -658 +711,0 @@
-	
@@ -668 +721 @@
-	
+
@@ -727 +780 @@
-	 * only need to unlink, put and exit 
+	 * only need to unlink, put and exit
@@ -730,0 +784 @@
+		cpu_clear(cpu, data->cpus);
@@ -743 +797 @@
- 		return -EFAULT;
+		return -EFAULT;
@@ -786 +840 @@
-	 * not referenced anymore by anybody before we proceed with 
+	 * not referenced anymore by anybody before we proceed with
@@ -834 +888 @@
-/** 
+/**
@@ -858 +912 @@
-/** 
+/**
@@ -963 +1017 @@
-		notifier_call_chain(&cpufreq_transition_notifier_list,
+		blocking_notifier_call_chain(&cpufreq_transition_notifier_list,
@@ -1044 +1098,2 @@
-			notifier_call_chain(&cpufreq_transition_notifier_list,
+			blocking_notifier_call_chain(
+					&cpufreq_transition_notifier_list,
@@ -1075 +1130 @@
- *	Add a driver to one of two lists: either a list of drivers that 
+ *	Add a driver to one of two lists: either a list of drivers that
@@ -1081 +1136 @@
- *	notifier_chain_register.
+ *	blocking_notifier_chain_register.
@@ -1087 +1141,0 @@
-	down_write(&cpufreq_notifier_rwsem);
@@ -1090 +1144,2 @@
-		ret = notifier_chain_register(&cpufreq_transition_notifier_list, nb);
+		ret = blocking_notifier_chain_register(
+				&cpufreq_transition_notifier_list, nb);
@@ -1093 +1148,2 @@
-		ret = notifier_chain_register(&cpufreq_policy_notifier_list, nb);
+		ret = blocking_notifier_chain_register(
+				&cpufreq_policy_notifier_list, nb);
@@ -1098 +1153,0 @@
-	up_write(&cpufreq_notifier_rwsem);
@@ -1113 +1168 @@
- *	notifier_chain_unregister.
+ *	blocking_notifier_chain_unregister.
@@ -1119 +1173,0 @@
-	down_write(&cpufreq_notifier_rwsem);
@@ -1122 +1176,2 @@
-		ret = notifier_chain_unregister(&cpufreq_transition_notifier_list, nb);
+		ret = blocking_notifier_chain_unregister(
+				&cpufreq_transition_notifier_list, nb);
@@ -1125 +1180,2 @@
-		ret = notifier_chain_unregister(&cpufreq_policy_notifier_list, nb);
+		ret = blocking_notifier_chain_unregister(
+				&cpufreq_policy_notifier_list, nb);
@@ -1130 +1185,0 @@
-	up_write(&cpufreq_notifier_rwsem);
@@ -1228 +1283 @@
-	
+
@@ -1237 +1292 @@
- 	mutex_unlock(&cpufreq_governor_mutex);
+	mutex_unlock(&cpufreq_governor_mutex);
@@ -1302,2 +1356,0 @@
-	down_read(&cpufreq_notifier_rwsem);
-
@@ -1305,2 +1358,2 @@
-	notifier_call_chain(&cpufreq_policy_notifier_list, CPUFREQ_ADJUST,
-			    policy);
+	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
+			CPUFREQ_ADJUST, policy);
@@ -1309,2 +1362,2 @@
-	notifier_call_chain(&cpufreq_policy_notifier_list, CPUFREQ_INCOMPATIBLE,
-			    policy);
+	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
+			CPUFREQ_INCOMPATIBLE, policy);
@@ -1315,2 +1368 @@
-	if (ret) {
-		up_read(&cpufreq_notifier_rwsem);
+	if (ret)
@@ -1318 +1369,0 @@
-	}
@@ -1321,4 +1372,2 @@
-	notifier_call_chain(&cpufreq_policy_notifier_list, CPUFREQ_NOTIFY,
-			    policy);
-
-	up_read(&cpufreq_notifier_rwsem);
+	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
+			CPUFREQ_NOTIFY, policy);
@@ -1451 +1500 @@
-static int __cpuinit cpufreq_cpu_callback(struct notifier_block *nfb,
+static int cpufreq_cpu_callback(struct notifier_block *nfb,
@@ -1500 +1549 @@
- *   Registers a CPU Frequency driver to this core code. This code 
+ *   Registers a CPU Frequency driver to this core code. This code
@@ -1502 +1551 @@
- * (and isn't unregistered in the meantime). 
+ * (and isn't unregistered in the meantime).
@@ -1563 +1612 @@
- *    Unregister the current CPUFreq driver. Only call this if you have 
+ *    Unregister the current CPUFreq driver. Only call this if you have
--- ./projects/linux/linux-2.6.17/drivers/cpufreq/cpufreq.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/cpufreq/cpufreq.c	2006-09-20 05:42:06.000000000 +0200
@@ -18 +17,0 @@
-#include <linux/config.h>
@@ -260 +259 @@
-				dprintk(KERN_WARNING "Warning: CPU frequency is"
+				dprintk("Warning: CPU frequency is"
@@ -287,0 +287,11 @@
+static struct cpufreq_governor *__find_governor(const char *str_governor)
+{
+	struct cpufreq_governor *t;
+
+	list_for_each_entry(t, &cpufreq_governor_list, governor_list)
+		if (!strnicmp(str_governor,t->name,CPUFREQ_NAME_LEN))
+			return t;
+
+	return NULL;
+}
+
@@ -293,0 +304,2 @@
+	int err = -EINVAL;
+
@@ -295 +307,2 @@
-		return -EINVAL;
+		goto out;
+
@@ -299 +312 @@
-			return 0;
+			err = 0;
@@ -302 +315 @@
-			return 0;
+			err = 0;
@@ -304,2 +317 @@
-		return -EINVAL;
-	} else {
+	} else if (cpufreq_driver->target) {
@@ -306,0 +319 @@
+
@@ -308,5 +321,9 @@
-		if (!cpufreq_driver || !cpufreq_driver->target)
-			goto out;
-		list_for_each_entry(t, &cpufreq_governor_list, governor_list) {
-			if (!strnicmp(str_governor,t->name,CPUFREQ_NAME_LEN)) {
-				*governor = t;
+
+		t = __find_governor(str_governor);
+
+		if (t == NULL) {
+			char *name = kasprintf(GFP_KERNEL, "cpufreq_%s", str_governor);
+
+			if (name) {
+				int ret;
+
@@ -314 +331,5 @@
-				return 0;
+				ret = request_module(name);
+				mutex_lock(&cpufreq_governor_mutex);
+
+				if (ret == 0)
+					t = __find_governor(str_governor);
@@ -315,0 +337,2 @@
+
+			kfree(name);
@@ -317 +340,6 @@
-out:
+
+		if (t != NULL) {
+			*governor = t;
+			err = 0;
+		}
+
@@ -320 +348,2 @@
-	return -EINVAL;
+  out:
+	return err;
@@ -367,0 +397 @@
+	lock_cpu_hotplug();						\
@@ -371,0 +402 @@
+	unlock_cpu_hotplug();						\
@@ -426,0 +458,2 @@
+	lock_cpu_hotplug();
+
@@ -435,0 +469,2 @@
+	unlock_cpu_hotplug();
+
@@ -877 +912 @@
-	dprintk(KERN_WARNING "Warning: CPU frequency out of sync: cpufreq and timing "
+	dprintk("Warning: CPU frequency out of sync: cpufreq and timing "
@@ -1009 +1044 @@
-			dprintk(KERN_DEBUG "Warning: CPU frequency is %u, "
+			dprintk("Warning: CPU frequency is %u, "
@@ -1090 +1125 @@
-				dprintk(KERN_WARNING "Warning: CPU frequency"
+				dprintk("Warning: CPU frequency"
@@ -1196,0 +1232 @@
+/* Must be called with lock_cpu_hotplug held */
@@ -1203 +1238,0 @@
-	lock_cpu_hotplug();
@@ -1209,2 +1243,0 @@
-	unlock_cpu_hotplug();
-
@@ -1224,0 +1258 @@
+	lock_cpu_hotplug();
@@ -1229,0 +1264 @@
+	unlock_cpu_hotplug();
@@ -1235,0 +1271,4 @@
+/*
+ * Locking: Must be called with the lock_cpu_hotplug() lock held
+ * when "event" is CPUFREQ_GOV_LIMITS
+ */
@@ -1257,18 +1295,0 @@
-int cpufreq_governor(unsigned int cpu, unsigned int event)
-{
-	int ret = 0;
-	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
-
-	if (!policy)
-		return -EINVAL;
-
-	mutex_lock(&policy->lock);
-	ret = __cpufreq_governor(policy, event);
-	mutex_unlock(&policy->lock);
-
-	cpufreq_cpu_put(policy);
-	return ret;
-}
-EXPORT_SYMBOL_GPL(cpufreq_governor);
-
-
@@ -1277 +1298 @@
-	struct cpufreq_governor *t;
+	int err;
@@ -1284,5 +1305,4 @@
-	list_for_each_entry(t, &cpufreq_governor_list, governor_list) {
-		if (!strnicmp(governor->name,t->name,CPUFREQ_NAME_LEN)) {
-			mutex_unlock(&cpufreq_governor_mutex);
-			return -EBUSY;
-		}
+	err = -EBUSY;
+	if (__find_governor(governor->name) == NULL) {
+		err = 0;
+		list_add(&governor->governor_list, &cpufreq_governor_list);
@@ -1290 +1309,0 @@
-	list_add(&governor->governor_list, &cpufreq_governor_list);
@@ -1293 +1312 @@
-	return 0;
+	return err;
@@ -1341,0 +1361,3 @@
+/*
+ * Locking: Must be called with the lock_cpu_hotplug() lock held
+ */
@@ -1351,0 +1374,5 @@
+	if (policy->min > data->min && policy->min > policy->max) {
+		ret = -EINVAL;
+		goto error_out;
+	}
+
@@ -1435,0 +1463,2 @@
+	lock_cpu_hotplug();
+
@@ -1445,0 +1475,2 @@
+
+	unlock_cpu_hotplug();
@@ -1468,0 +1500 @@
+	lock_cpu_hotplug();
@@ -1494 +1526 @@
-
+	unlock_cpu_hotplug();
@@ -1499,0 +1532 @@
+#ifdef CONFIG_HOTPLUG_CPU
@@ -1535 +1568 @@
-static struct notifier_block cpufreq_cpu_notifier =
+static struct notifier_block __cpuinitdata cpufreq_cpu_notifier =
@@ -1538,0 +1572 @@
+#endif /* CONFIG_HOTPLUG_CPU */
@@ -1599 +1633 @@
-		register_cpu_notifier(&cpufreq_cpu_notifier);
+		register_hotcpu_notifier(&cpufreq_cpu_notifier);
@@ -1631 +1665 @@
-	unregister_cpu_notifier(&cpufreq_cpu_notifier);
+	unregister_hotcpu_notifier(&cpufreq_cpu_notifier);
--- ./projects/linux/linux-2.6.18/drivers/cpufreq/cpufreq.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/cpufreq/cpufreq.c	2006-11-29 22:57:37.000000000 +0100
@@ -35 +35 @@
- * The "cpufreq driver" - the arch- or hardware-dependend low
+ * The "cpufreq driver" - the arch- or hardware-dependent low
@@ -55 +55 @@
-static BLOCKING_NOTIFIER_HEAD(cpufreq_transition_notifier_list);
+static struct srcu_notifier_head cpufreq_transition_notifier_list;
@@ -56,0 +57,6 @@
+static int __init init_cpufreq_transition_notifier_list(void)
+{
+	srcu_init_notifier_head(&cpufreq_transition_notifier_list);
+	return 0;
+}
+pure_initcall(init_cpufreq_transition_notifier_list);
@@ -265 +271 @@
-		blocking_notifier_call_chain(&cpufreq_transition_notifier_list,
+		srcu_notifier_call_chain(&cpufreq_transition_notifier_list,
@@ -272 +278 @@
-		blocking_notifier_call_chain(&cpufreq_transition_notifier_list,
+		srcu_notifier_call_chain(&cpufreq_transition_notifier_list,
@@ -997 +1003 @@
-	dprintk("resuming cpu %u\n", cpu);
+	dprintk("suspending cpu %u\n", cpu);
@@ -1052 +1058 @@
-		blocking_notifier_call_chain(&cpufreq_transition_notifier_list,
+		srcu_notifier_call_chain(&cpufreq_transition_notifier_list,
@@ -1133 +1139 @@
-			blocking_notifier_call_chain(
+			srcu_notifier_call_chain(
@@ -1179 +1185 @@
-		ret = blocking_notifier_chain_register(
+		ret = srcu_notifier_chain_register(
@@ -1211 +1217 @@
-		ret = blocking_notifier_chain_unregister(
+		ret = srcu_notifier_chain_unregister(
--- ./projects/linux/linux-2.6.19/drivers/cpufreq/cpufreq.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/cpufreq/cpufreq.c	2007-02-04 19:44:54.000000000 +0100
@@ -32 +32,2 @@
-#define dprintk(msg...) cpufreq_debug_printk(CPUFREQ_DEBUG_CORE, "cpufreq-core", msg)
+#define dprintk(msg...) cpufreq_debug_printk(CPUFREQ_DEBUG_CORE, \
+						"cpufreq-core", msg)
@@ -45 +46 @@
-static void handle_update(void *data);
+static void handle_update(struct work_struct *work);
@@ -154 +155,2 @@
-void cpufreq_debug_printk(unsigned int type, const char *prefix, const char *fmt, ...)
+void cpufreq_debug_printk(unsigned int type, const char *prefix,
+							const char *fmt, ...)
@@ -164 +166,2 @@
-		if (!disable_ratelimit && debug_ratelimit && !printk_ratelimit()) {
+		if (!disable_ratelimit && debug_ratelimit
+					&& !printk_ratelimit()) {
@@ -185 +188,2 @@
-MODULE_PARM_DESC(debug, "CPUfreq debugging: add 1 to debug core, 2 to debug drivers, and 4 to debug governors.");
+MODULE_PARM_DESC(debug, "CPUfreq debugging: add 1 to debug core,"
+			" 2 to debug drivers, and 4 to debug governors.");
@@ -188 +192,2 @@
-MODULE_PARM_DESC(debug_ratelimit, "CPUfreq debugging: set to 0 to disable ratelimiting.");
+MODULE_PARM_DESC(debug_ratelimit, "CPUfreq debugging:"
+					" set to 0 to disable ratelimiting.");
@@ -222 +227,2 @@
-		dprintk("saving %lu as reference value for loops_per_jiffy; freq is %u kHz\n", l_p_j_ref, l_p_j_ref_freq);
+		dprintk("saving %lu as reference value for loops_per_jiffy;"
+			"freq is %u kHz\n", l_p_j_ref, l_p_j_ref_freq);
@@ -227,2 +233,4 @@
-		loops_per_jiffy = cpufreq_scale(l_p_j_ref, l_p_j_ref_freq, ci->new);
-		dprintk("scaling loops_per_jiffy to %lu for frequency %u kHz\n", loops_per_jiffy, ci->new);
+		loops_per_jiffy = cpufreq_scale(l_p_j_ref, l_p_j_ref_freq,
+								ci->new);
+		dprintk("scaling loops_per_jiffy to %lu"
+			"for frequency %u kHz\n", loops_per_jiffy, ci->new);
@@ -232 +240,4 @@
-static inline void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci) { return; }
+static inline void adjust_jiffies(unsigned long val, struct cpufreq_freqs *ci)
+{
+	return;
+}
@@ -319 +330,2 @@
-		} else if (!strnicmp(str_governor, "powersave", CPUFREQ_NAME_LEN)) {
+		} else if (!strnicmp(str_governor, "powersave",
+						CPUFREQ_NAME_LEN)) {
@@ -331 +343,2 @@
-			char *name = kasprintf(GFP_KERNEL, "cpufreq_%s", str_governor);
+			char *name = kasprintf(GFP_KERNEL, "cpufreq_%s",
+								str_governor);
@@ -364 +377,2 @@
- * cpufreq_per_cpu_attr_read() / show_##file_name() - print out cpufreq information
+ * cpufreq_per_cpu_attr_read() / show_##file_name() -
+ * print out cpufreq information
@@ -383 +397,2 @@
-static int __cpufreq_set_policy(struct cpufreq_policy *data, struct cpufreq_policy *policy);
+static int __cpufreq_set_policy(struct cpufreq_policy *data,
+				struct cpufreq_policy *policy);
@@ -419 +434,2 @@
-static ssize_t show_cpuinfo_cur_freq (struct cpufreq_policy * policy, char *buf)
+static ssize_t show_cpuinfo_cur_freq (struct cpufreq_policy * policy,
+							char *buf)
@@ -431 +447,2 @@
-static ssize_t show_scaling_governor (struct cpufreq_policy * policy, char *buf)
+static ssize_t show_scaling_governor (struct cpufreq_policy * policy,
+							char *buf)
@@ -461 +478,2 @@
-	if (cpufreq_parse_governor(str_governor, &new_policy.policy, &new_policy.governor))
+	if (cpufreq_parse_governor(str_governor, &new_policy.policy,
+						&new_policy.governor))
@@ -477 +495,4 @@
-	return ret ? ret : count;
+	if (ret)
+		return ret;
+	else
+		return count;
@@ -491 +512 @@
-static ssize_t show_scaling_available_governors (struct cpufreq_policy * policy,
+static ssize_t show_scaling_available_governors (struct cpufreq_policy *policy,
@@ -577 +598,5 @@
-	ret = fattr->show ? fattr->show(policy,buf) : -EIO;
+	if (fattr->show)
+		ret = fattr->show(policy, buf);
+	else
+		ret = -EIO;
+
@@ -591 +616,5 @@
-	ret = fattr->store ? fattr->store(policy,buf,count) : -EIO;
+	if (fattr->store)
+		ret = fattr->store(policy, buf, count);
+	else
+		ret = -EIO;
+
@@ -668 +697 @@
-	INIT_WORK(&policy->update, handle_update, (void *)(long)cpu);
+	INIT_WORK(&policy->update, handle_update);
@@ -696,2 +725,7 @@
-			sysfs_create_link(&sys_dev->kobj,
-					  &managed_policy->kobj, "cpufreq");
+			ret = sysfs_create_link(&sys_dev->kobj,
+						&managed_policy->kobj,
+						"cpufreq");
+			if (ret) {
+				mutex_unlock(&policy->lock);
+				goto err_out_driver_exit;
+			}
@@ -744,2 +778,6 @@
-		sysfs_create_link(&cpu_sys_dev->kobj, &policy->kobj,
-				  "cpufreq");
+		ret = sysfs_create_link(&cpu_sys_dev->kobj, &policy->kobj,
+					"cpufreq");
+		if (ret) {
+			mutex_unlock(&policy->lock);
+			goto err_out_unregister;
+		}
@@ -898 +936 @@
-static void handle_update(void *data)
+static void handle_update(struct work_struct *work)
@@ -900 +938,3 @@
-	unsigned int cpu = (unsigned int)(long)data;
+	struct cpufreq_policy *policy =
+		container_of(work, struct cpufreq_policy, update);
+	unsigned int cpu = policy->cpu;
@@ -914 +954,2 @@
-static void cpufreq_out_of_sync(unsigned int cpu, unsigned int old_freq, unsigned int new_freq)
+static void cpufreq_out_of_sync(unsigned int cpu, unsigned int old_freq,
+				unsigned int new_freq)
@@ -930 +971 @@
- * cpufreq_quick_get - get the CPU frequency (in kHz) frpm policy->cur
+ * cpufreq_quick_get - get the CPU frequency (in kHz) from policy->cur
@@ -939 +980 @@
-	unsigned int ret = 0;
+	unsigned int ret_freq = 0;
@@ -943 +984 @@
-		ret = policy->cur;
+		ret_freq = policy->cur;
@@ -948 +989 @@
-	return (ret);
+	return (ret_freq);
@@ -962 +1003 @@
-	unsigned int ret = 0;
+	unsigned int ret_freq = 0;
@@ -972 +1013 @@
-	ret = cpufreq_driver->get(cpu);
+	ret_freq = cpufreq_driver->get(cpu);
@@ -974,4 +1015,6 @@
-	if (ret && policy->cur && !(cpufreq_driver->flags & CPUFREQ_CONST_LOOPS)) {
-		/* verify no discrepancy between actual and saved value exists */
-		if (unlikely(ret != policy->cur)) {
-			cpufreq_out_of_sync(cpu, policy->cur, ret);
+	if (ret_freq && policy->cur &&
+		!(cpufreq_driver->flags & CPUFREQ_CONST_LOOPS)) {
+		/* verify no discrepancy between actual and
+					saved value exists */
+		if (unlikely(ret_freq != policy->cur)) {
+			cpufreq_out_of_sync(cpu, policy->cur, ret_freq);
@@ -987 +1030 @@
-	return (ret);
+	return (ret_freq);
@@ -999 +1042 @@
-	unsigned int ret = 0;
+	int ret = 0;
@@ -1081 +1124 @@
-	unsigned int ret = 0;
+	int ret = 0;
@@ -1276,0 +1320,20 @@
+int cpufreq_driver_getavg(struct cpufreq_policy *policy)
+{
+	int ret = 0;
+
+	policy = cpufreq_cpu_get(policy->cpu);
+	if (!policy)
+		return -EINVAL;
+
+	mutex_lock(&policy->lock);
+
+	if (cpu_online(policy->cpu) && cpufreq_driver->getavg)
+		ret = cpufreq_driver->getavg(policy->cpu);
+
+	mutex_unlock(&policy->lock);
+
+	cpufreq_cpu_put(policy);
+	return ret;
+}
+EXPORT_SYMBOL_GPL(cpufreq_driver_getavg);
+
@@ -1282 +1345,2 @@
-static int __cpufreq_governor(struct cpufreq_policy *policy, unsigned int event)
+static int __cpufreq_governor(struct cpufreq_policy *policy,
+					unsigned int event)
@@ -1289 +1353,2 @@
-	dprintk("__cpufreq_governor for CPU %u, event %u\n", policy->cpu, event);
+	dprintk("__cpufreq_governor for CPU %u, event %u\n",
+						policy->cpu, event);
@@ -1292 +1357,2 @@
-	/* we keep one module reference alive for each CPU governed by this CPU */
+	/* we keep one module reference alive for
+			each CPU governed by this CPU */
@@ -1367,0 +1434,2 @@
+ * data   : current policy.
+ * policy : policy to be set.
@@ -1370 +1438,2 @@
-static int __cpufreq_set_policy(struct cpufreq_policy *data, struct cpufreq_policy *policy)
+static int __cpufreq_set_policy(struct cpufreq_policy *data,
+				struct cpufreq_policy *policy)
@@ -1378 +1447,2 @@
-	memcpy(&policy->cpuinfo, &data->cpuinfo, sizeof(struct cpufreq_cpuinfo));
+	memcpy(&policy->cpuinfo, &data->cpuinfo,
+				sizeof(struct cpufreq_cpuinfo));
@@ -1411 +1481,2 @@
-	dprintk("new min and max freqs are %u - %u kHz\n", data->min, data->max);
+	dprintk("new min and max freqs are %u - %u kHz\n",
+					data->min, data->max);
@@ -1432 +1503,2 @@
-				dprintk("starting governor %s failed\n", data->governor->name);
+				dprintk("starting governor %s failed\n",
+							data->governor->name);
@@ -1435 +1507,2 @@
-					__cpufreq_governor(data, CPUFREQ_GOV_START);
+					__cpufreq_governor(data,
+							   CPUFREQ_GOV_START);
@@ -1525 +1598,2 @@
-				cpufreq_out_of_sync(cpu, data->cur, policy.cur);
+				cpufreq_out_of_sync(cpu, data->cur,
+								policy.cur);
@@ -1538 +1611,0 @@
-#ifdef CONFIG_HOTPLUG_CPU
@@ -1578 +1650,0 @@
-#endif /* CONFIG_HOTPLUG_CPU */
@@ -1629,2 +1701,4 @@
-			dprintk("no CPU initialized for driver %s\n", driver_data->name);
-			sysdev_driver_unregister(&cpu_sysdev_class, &cpufreq_sysdev_driver);
+			dprintk("no CPU initialized for driver %s\n",
+							driver_data->name);
+			sysdev_driver_unregister(&cpu_sysdev_class,
+						&cpufreq_sysdev_driver);
--- ./projects/linux/linux-2.6.20/drivers/cpufreq/cpufreq.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/cpufreq/cpufreq.c	2007-04-26 05:08:32.000000000 +0200
@@ -43,0 +44,58 @@
+/*
+ * cpu_policy_rwsem is a per CPU reader-writer semaphore designed to cure
+ * all cpufreq/hotplug/workqueue/etc related lock issues.
+ *
+ * The rules for this semaphore:
+ * - Any routine that wants to read from the policy structure will
+ *   do a down_read on this semaphore.
+ * - Any routine that will write to the policy structure and/or may take away
+ *   the policy altogether (eg. CPU hotplug), will hold this lock in write
+ *   mode before doing so.
+ *
+ * Additional rules:
+ * - All holders of the lock should check to make sure that the CPU they
+ *   are concerned with are online after they get the lock.
+ * - Governor routines that can be called in cpufreq hotplug path should not
+ *   take this sem as top level hotplug notifier handler takes this.
+ */
+static DEFINE_PER_CPU(int, policy_cpu);
+static DEFINE_PER_CPU(struct rw_semaphore, cpu_policy_rwsem);
+
+#define lock_policy_rwsem(mode, cpu)					\
+int lock_policy_rwsem_##mode						\
+(int cpu)								\
+{									\
+	int policy_cpu = per_cpu(policy_cpu, cpu);			\
+	BUG_ON(policy_cpu == -1);					\
+	down_##mode(&per_cpu(cpu_policy_rwsem, policy_cpu));		\
+	if (unlikely(!cpu_online(cpu))) {				\
+		up_##mode(&per_cpu(cpu_policy_rwsem, policy_cpu));	\
+		return -1;						\
+	}								\
+									\
+	return 0;							\
+}
+
+lock_policy_rwsem(read, cpu);
+EXPORT_SYMBOL_GPL(lock_policy_rwsem_read);
+
+lock_policy_rwsem(write, cpu);
+EXPORT_SYMBOL_GPL(lock_policy_rwsem_write);
+
+void unlock_policy_rwsem_read(int cpu)
+{
+	int policy_cpu = per_cpu(policy_cpu, cpu);
+	BUG_ON(policy_cpu == -1);
+	up_read(&per_cpu(cpu_policy_rwsem, policy_cpu));
+}
+EXPORT_SYMBOL_GPL(unlock_policy_rwsem_read);
+
+void unlock_policy_rwsem_write(int cpu)
+{
+	int policy_cpu = per_cpu(policy_cpu, cpu);
+	BUG_ON(policy_cpu == -1);
+	up_write(&per_cpu(cpu_policy_rwsem, policy_cpu));
+}
+EXPORT_SYMBOL_GPL(unlock_policy_rwsem_write);
+
+
@@ -45,0 +104 @@
+static unsigned int __cpufreq_get(unsigned int cpu);
@@ -418,2 +476,0 @@
-	lock_cpu_hotplug();						\
-	mutex_lock(&policy->lock);					\
@@ -422,2 +478,0 @@
-	mutex_unlock(&policy->lock);					\
-	unlock_cpu_hotplug();						\
@@ -437 +492 @@
-	unsigned int cur_freq = cpufreq_get(policy->cpu);
+	unsigned int cur_freq = __cpufreq_get(policy->cpu);
@@ -482,2 +536,0 @@
-	lock_cpu_hotplug();
-
@@ -486 +538,0 @@
-	mutex_lock(&policy->lock);
@@ -491,3 +542,0 @@
-	mutex_unlock(&policy->lock);
-
-	unlock_cpu_hotplug();
@@ -597,0 +647,4 @@
+
+	if (lock_policy_rwsem_read(policy->cpu) < 0)
+		return -EINVAL;
+
@@ -602,0 +656,2 @@
+	unlock_policy_rwsem_read(policy->cpu);
+
@@ -615,0 +671,4 @@
+
+	if (lock_policy_rwsem_write(policy->cpu) < 0)
+		return -EINVAL;
+
@@ -620,0 +680,2 @@
+	unlock_policy_rwsem_write(policy->cpu);
+
@@ -694,2 +755,4 @@
-	mutex_init(&policy->lock);
-	mutex_lock(&policy->lock);
+	/* Initially set CPU itself as the policy_cpu */
+	per_cpu(policy_cpu, cpu) = cpu;
+	lock_policy_rwsem_write(cpu);
+
@@ -705 +768 @@
-		mutex_unlock(&policy->lock);
+		unlock_policy_rwsem_write(cpu);
@@ -718,0 +782,8 @@
+
+			/* Set proper policy_cpu */
+			unlock_policy_rwsem_write(cpu);
+			per_cpu(policy_cpu, cpu) = managed_policy->cpu;
+
+			if (lock_policy_rwsem_write(cpu) < 0)
+				goto err_out_driver_exit;
+
@@ -729 +800 @@
-				mutex_unlock(&policy->lock);
+				unlock_policy_rwsem_write(cpu);
@@ -734 +804,0 @@
-			mutex_unlock(&policy->lock);
@@ -735,0 +806 @@
+			unlock_policy_rwsem_write(cpu);
@@ -749 +820 @@
-		mutex_unlock(&policy->lock);
+		unlock_policy_rwsem_write(cpu);
@@ -764 +835 @@
-	for_each_cpu_mask(j, policy->cpus)
+	for_each_cpu_mask(j, policy->cpus) {
@@ -765,0 +837,2 @@
+		per_cpu(policy_cpu, j) = policy->cpu;
+	}
@@ -781 +854 @@
-			mutex_unlock(&policy->lock);
+			unlock_policy_rwsem_write(cpu);
@@ -788 +861 @@
-	mutex_unlock(&policy->lock);
+	unlock_policy_rwsem_write(cpu);
@@ -829 +902 @@
- * cpufreq_remove_dev - remove a CPU device
+ * __cpufreq_remove_dev - remove a CPU device
@@ -831,0 +905,2 @@
+ * Caller should already have policy_rwsem in write mode for this CPU.
+ * This routine frees the rwsem before returning.
@@ -833 +908 @@
-static int cpufreq_remove_dev (struct sys_device * sys_dev)
+static int __cpufreq_remove_dev (struct sys_device * sys_dev)
@@ -851,0 +927 @@
+		unlock_policy_rwsem_write(cpu);
@@ -867,0 +944 @@
+		unlock_policy_rwsem_write(cpu);
@@ -875,0 +953 @@
+		unlock_policy_rwsem_write(cpu);
@@ -909 +986,0 @@
-	mutex_lock(&data->lock);
@@ -912 +989,2 @@
-	mutex_unlock(&data->lock);
+
+	unlock_policy_rwsem_write(cpu);
@@ -935,0 +1014,16 @@
+static int cpufreq_remove_dev (struct sys_device * sys_dev)
+{
+	unsigned int cpu = sys_dev->id;
+	int retval;
+
+	if (cpu_is_offline(cpu))
+		return 0;
+
+	if (unlikely(lock_policy_rwsem_write(cpu)))
+		BUG();
+
+	retval = __cpufreq_remove_dev(sys_dev);
+	return retval;
+}
+
+
@@ -983 +1077,3 @@
-		mutex_lock(&policy->lock);
+		if (unlikely(lock_policy_rwsem_read(cpu)))
+			return ret_freq;
+
@@ -985 +1081,2 @@
-		mutex_unlock(&policy->lock);
+
+		unlock_policy_rwsem_read(cpu);
@@ -994,7 +1091 @@
-/**
- * cpufreq_get - get the current CPU frequency (in kHz)
- * @cpu: CPU number
- *
- * Get the CPU current (static) CPU frequency
- */
-unsigned int cpufreq_get(unsigned int cpu)
+static unsigned int __cpufreq_get(unsigned int cpu)
@@ -1002 +1093 @@
-	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
+	struct cpufreq_policy *policy = cpufreq_cpu_data[cpu];
@@ -1005,3 +1095,0 @@
-	if (!policy)
-		return 0;
-
@@ -1009,3 +1097 @@
-		goto out;
-
-	mutex_lock(&policy->lock);
+		return (ret_freq);
@@ -1025 +1111,2 @@
-	mutex_unlock(&policy->lock);
+	return (ret_freq);
+}
@@ -1027,2 +1114,10 @@
-out:
-	cpufreq_cpu_put(policy);
+/**
+ * cpufreq_get - get the current CPU frequency (in kHz)
+ * @cpu: CPU number
+ *
+ * Get the CPU current (static) CPU frequency
+ */
+unsigned int cpufreq_get(unsigned int cpu)
+{
+	unsigned int ret_freq = 0;
+	struct cpufreq_policy *policy = cpufreq_cpu_get(cpu);
@@ -1029,0 +1125,13 @@
+	if (!policy)
+		goto out;
+
+	if (unlikely(lock_policy_rwsem_read(cpu)))
+		goto out_policy;
+
+	ret_freq = __cpufreq_get(cpu);
+
+	unlock_policy_rwsem_read(cpu);
+
+out_policy:
+	cpufreq_cpu_put(policy);
+out:
@@ -1281 +1388,0 @@
-/* Must be called with lock_cpu_hotplug held */
@@ -1307,2 +1414,2 @@
-	lock_cpu_hotplug();
-	mutex_lock(&policy->lock);
+	if (unlikely(lock_policy_rwsem_write(policy->cpu)))
+		return -EINVAL;
@@ -1312,2 +1419 @@
-	mutex_unlock(&policy->lock);
-	unlock_cpu_hotplug();
+	unlock_policy_rwsem_write(policy->cpu);
@@ -1320 +1426 @@
-int cpufreq_driver_getavg(struct cpufreq_policy *policy)
+int __cpufreq_driver_getavg(struct cpufreq_policy *policy)
@@ -1328,2 +1433,0 @@
-	mutex_lock(&policy->lock);
-
@@ -1333,2 +1436,0 @@
-	mutex_unlock(&policy->lock);
-
@@ -1338 +1440 @@
-EXPORT_SYMBOL_GPL(cpufreq_driver_getavg);
+EXPORT_SYMBOL_GPL(__cpufreq_driver_getavg);
@@ -1341 +1442,0 @@
- * Locking: Must be called with the lock_cpu_hotplug() lock held
@@ -1423 +1523,0 @@
-	mutex_lock(&cpu_policy->lock);
@@ -1425 +1524,0 @@
-	mutex_unlock(&cpu_policy->lock);
@@ -1436 +1534,0 @@
- * Locking: Must be called with the lock_cpu_hotplug() lock held
@@ -1542 +1640,2 @@
-	lock_cpu_hotplug();
+	if (unlikely(lock_policy_rwsem_write(policy->cpu)))
+		return -EINVAL;
@@ -1544,2 +1642,0 @@
-	/* lock this CPU */
-	mutex_lock(&data->lock);
@@ -1553 +1650 @@
-	mutex_unlock(&data->lock);
+	unlock_policy_rwsem_write(policy->cpu);
@@ -1555 +1651,0 @@
-	unlock_cpu_hotplug();
@@ -1579,2 +1675,2 @@
-	lock_cpu_hotplug();
-	mutex_lock(&data->lock);
+	if (unlikely(lock_policy_rwsem_write(cpu)))
+		return -EINVAL;
@@ -1605,2 +1701,2 @@
-	mutex_unlock(&data->lock);
-	unlock_cpu_hotplug();
+	unlock_policy_rwsem_write(cpu);
+
@@ -1616 +1711,0 @@
-	struct cpufreq_policy *policy;
@@ -1617,0 +1713 @@
+	struct cpufreq_policy *policy;
@@ -1620 +1715,0 @@
-
@@ -1627,6 +1722,3 @@
-			/*
-			 * We attempt to put this cpu in lowest frequency
-			 * possible before going down. This will permit
-			 * hardware-managed P-State to switch other related
-			 * threads to min or higher speeds if possible.
-			 */
+			if (unlikely(lock_policy_rwsem_write(cpu)))
+				BUG();
+
@@ -1635 +1727 @@
-				cpufreq_driver_target(policy, policy->min,
+				__cpufreq_driver_target(policy, policy->min,
@@ -1637,0 +1730 @@
+			__cpufreq_remove_dev(sys_dev);
@@ -1639,2 +1732,2 @@
-		case CPU_DEAD:
-			cpufreq_remove_dev(sys_dev);
+		case CPU_DOWN_FAILED:
+			cpufreq_add_dev(sys_dev);
@@ -1753,0 +1847,13 @@
+
+static int __init cpufreq_core_init(void)
+{
+	int cpu;
+
+	for_each_possible_cpu(cpu) {
+		per_cpu(policy_cpu, cpu) = -1;
+		init_rwsem(&per_cpu(cpu_policy_rwsem, cpu));
+	}
+	return 0;
+}
+
+core_initcall(cpufreq_core_init);
--- ./projects/linux/linux-2.6.21/drivers/cpufreq/cpufreq.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/cpufreq/cpufreq.c	2007-07-09 01:32:17.000000000 +0200
@@ -770,0 +771,3 @@
+	policy->user_policy.min = policy->cpuinfo.min_freq;
+	policy->user_policy.max = policy->cpuinfo.max_freq;
+	policy->user_policy.governor = policy->governor;
@@ -861 +863,0 @@
-	unlock_policy_rwsem_write(cpu);
@@ -864 +866,5 @@
-	ret = cpufreq_set_policy(&new_policy);
+	ret = __cpufreq_set_policy(policy, &new_policy);
+	policy->user_policy.policy = policy->policy;
+
+	unlock_policy_rwsem_write(cpu);
+
@@ -1623,37 +1628,0 @@
- *	cpufreq_set_policy - set a new CPUFreq policy
- *	@policy: policy to be set.
- *
- *	Sets a new CPU frequency and voltage scaling policy.
- */
-int cpufreq_set_policy(struct cpufreq_policy *policy)
-{
-	int ret = 0;
-	struct cpufreq_policy *data;
-
-	if (!policy)
-		return -EINVAL;
-
-	data = cpufreq_cpu_get(policy->cpu);
-	if (!data)
-		return -EINVAL;
-
-	if (unlikely(lock_policy_rwsem_write(policy->cpu)))
-		return -EINVAL;
-
-
-	ret = __cpufreq_set_policy(data, policy);
-	data->user_policy.min = data->min;
-	data->user_policy.max = data->max;
-	data->user_policy.policy = data->policy;
-	data->user_policy.governor = data->governor;
-
-	unlock_policy_rwsem_write(policy->cpu);
-
-	cpufreq_cpu_put(data);
-
-	return ret;
-}
-EXPORT_SYMBOL(cpufreq_set_policy);
-
-
-/**
@@ -1718,0 +1688 @@
+		case CPU_ONLINE_FROZEN:
@@ -1721,0 +1692 @@
+		case CPU_DOWN_PREPARE_FROZEN:
@@ -1732,0 +1704 @@
+		case CPU_DOWN_FAILED_FROZEN:
--- ./projects/linux/linux-2.6.22/drivers/cpufreq/cpufreq.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/cpufreq/cpufreq.c	2007-10-09 22:31:38.000000000 +0200
@@ -41,0 +42,4 @@
+#ifdef CONFIG_HOTPLUG_CPU
+/* This one keeps track of the previously set governor of a removed CPU */
+static struct cpufreq_governor *cpufreq_cpu_governor[NR_CPUS];
+#endif
@@ -773 +776,0 @@
-	policy->user_policy.governor = policy->governor;
@@ -775,0 +779,9 @@
+
+#ifdef CONFIG_HOTPLUG_CPU
+	if (cpufreq_cpu_governor[cpu]){
+		policy->governor = cpufreq_cpu_governor[cpu];
+		dprintk("Restoring governor %s for cpu %d\n",
+		       policy->governor->name, cpu);
+	}
+#endif
+
@@ -829 +841,3 @@
-		sysfs_create_file(&policy->kobj, &((*drv_attr)->attr));
+		ret = sysfs_create_file(&policy->kobj, &((*drv_attr)->attr));
+		if (ret)
+			goto err_out_driver_exit;
@@ -832,4 +846,10 @@
-	if (cpufreq_driver->get)
-		sysfs_create_file(&policy->kobj, &cpuinfo_cur_freq.attr);
-	if (cpufreq_driver->target)
-		sysfs_create_file(&policy->kobj, &scaling_cur_freq.attr);
+	if (cpufreq_driver->get){
+		ret = sysfs_create_file(&policy->kobj, &cpuinfo_cur_freq.attr);
+		if (ret)
+			goto err_out_driver_exit;
+	}
+	if (cpufreq_driver->target){
+		ret = sysfs_create_file(&policy->kobj, &scaling_cur_freq.attr);
+		if (ret)
+			goto err_out_driver_exit;
+	}
@@ -867,0 +888 @@
+	policy->user_policy.governor = policy->governor;
@@ -963,0 +985,5 @@
+
+#ifdef CONFIG_HOTPLUG_CPU
+	cpufreq_cpu_governor[cpu] = data->governor;
+#endif
+
@@ -983,0 +1010,3 @@
+#ifdef CONFIG_HOTPLUG_CPU
+			cpufreq_cpu_governor[j] = data->governor;
+#endif
@@ -1682 +1710,0 @@
-	struct cpufreq_policy *policy;
@@ -1696,5 +1723,0 @@
-			policy = cpufreq_cpu_data[cpu];
-			if (policy) {
-				__cpufreq_driver_target(policy, policy->min,
-						CPUFREQ_RELATION_H);
-			}
--- ./projects/linux/linux-2.6.23/drivers/cpufreq/cpufreq.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/cpufreq/cpufreq.c	2008-01-24 23:58:37.000000000 +0100
@@ -765,0 +766,2 @@
+	/* Set governor before ->init, so that driver could check it */
+	policy->governor = CPUFREQ_DEFAULT_GOVERNOR;
@@ -831 +833 @@
-	strlcpy(policy->kobj.name, "cpufreq", KOBJ_NAME_LEN);
+	kobject_set_name(&policy->kobj, "cpufreq");
@@ -842 +844,2 @@
-		if (ret)
+		if (ret) {
+			unlock_policy_rwsem_write(cpu);
@@ -843,0 +847 @@
+		}
@@ -848 +852,2 @@
-		if (ret)
+		if (ret) {
+			unlock_policy_rwsem_write(cpu);
@@ -849,0 +855 @@
+		}
@@ -853 +859,2 @@
-		if (ret)
+		if (ret) {
+			unlock_policy_rwsem_write(cpu);
@@ -854,0 +862 @@
+		}
@@ -1112,3 +1119,0 @@
-		if (unlikely(lock_policy_rwsem_read(cpu)))
-			return ret_freq;
-
@@ -1116,2 +1120,0 @@
-
-		unlock_policy_rwsem_read(cpu);
@@ -1485,0 +1489,25 @@
+	/* Only must be defined when default governor is known to have latency
+	   restrictions, like e.g. conservative or ondemand.
+	   That this is the case is already ensured in Kconfig
+	*/
+#ifdef CONFIG_CPU_FREQ_GOV_PERFORMANCE
+	struct cpufreq_governor *gov = &cpufreq_gov_performance;
+#else
+	struct cpufreq_governor *gov = NULL;
+#endif
+
+	if (policy->governor->max_transition_latency &&
+	    policy->cpuinfo.transition_latency >
+	    policy->governor->max_transition_latency) {
+		if (!gov)
+			return -EINVAL;
+		else {
+			printk(KERN_WARNING "%s governor failed, too long"
+			       " transition latency of HW, fallback"
+			       " to %s governor\n",
+			       policy->governor->name,
+			       gov->name);
+			policy->governor = gov;
+		}
+	}
+
@@ -1706 +1734 @@
-static int cpufreq_cpu_callback(struct notifier_block *nfb,
+static int __cpuinit cpufreq_cpu_callback(struct notifier_block *nfb,
--- ./projects/linux/linux-2.6.24/drivers/cpufreq/cpufreq.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/cpufreq/cpufreq.c	2008-04-17 04:49:44.000000000 +0200
@@ -290 +290 @@
-		dprintk("saving %lu as reference value for loops_per_jiffy;"
+		dprintk("saving %lu as reference value for loops_per_jiffy; "
@@ -298 +298 @@
-		dprintk("scaling loops_per_jiffy to %lu"
+		dprintk("scaling loops_per_jiffy to %lu "
@@ -603,0 +604,25 @@
+static ssize_t store_scaling_setspeed(struct cpufreq_policy *policy,
+		const char *buf, size_t count)
+{
+	unsigned int freq = 0;
+	unsigned int ret;
+
+	if (!policy->governor->store_setspeed)
+		return -EINVAL;
+
+	ret = sscanf(buf, "%u", &freq);
+	if (ret != 1)
+		return -EINVAL;
+
+	policy->governor->store_setspeed(policy, freq);
+
+	return count;
+}
+
+static ssize_t show_scaling_setspeed(struct cpufreq_policy *policy, char *buf)
+{
+	if (!policy->governor->show_setspeed)
+		return sprintf(buf, "<unsupported>\n");
+
+	return policy->governor->show_setspeed(policy, buf);
+}
@@ -626,0 +652 @@
+define_one_rw(scaling_setspeed);
@@ -636,0 +663 @@
+	&scaling_setspeed.attr,
@@ -647 +674 @@
-	ssize_t ret;
+	ssize_t ret = -EINVAL;
@@ -650 +677 @@
-		return -EINVAL;
+		goto no_policy;
@@ -653 +680 @@
-		return -EINVAL;
+		goto fail;
@@ -661 +688 @@
-
+fail:
@@ -662,0 +690 @@
+no_policy:
@@ -671 +699 @@
-	ssize_t ret;
+	ssize_t ret = -EINVAL;
@@ -674 +702 @@
-		return -EINVAL;
+		goto no_policy;
@@ -677 +705 @@
-		return -EINVAL;
+		goto fail;
@@ -685 +713 @@
-
+fail:
@@ -686,0 +715 @@
+no_policy:
@@ -831,5 +860,2 @@
-	policy->kobj.parent = &sys_dev->kobj;
-	policy->kobj.ktype = &ktype_cpufreq;
-	kobject_set_name(&policy->kobj, "cpufreq");
-
-	ret = kobject_register(&policy->kobj);
+	ret = kobject_init_and_add(&policy->kobj, &ktype_cpufreq, &sys_dev->kobj,
+				   "cpufreq");
@@ -904,0 +931 @@
+	kobject_uevent(&policy->kobj, KOBJ_ADD);
@@ -918 +945 @@
-	kobject_unregister(&policy->kobj);
+	kobject_put(&policy->kobj);
@@ -984,8 +1010,0 @@
-
-	if (!kobject_get(&data->kobj)) {
-		spin_unlock_irqrestore(&cpufreq_driver_lock, flags);
-		cpufreq_debug_enable_ratelimit();
-		unlock_policy_rwsem_write(cpu);
-		return -EFAULT;
-	}
-
@@ -1035,2 +1053,0 @@
-	kobject_unregister(&data->kobj);
-
@@ -1320 +1337 @@
-				dprintk("Warning: CPU frequency"
+				dprintk("Warning: CPU frequency "
@@ -1611 +1628 @@
-	if (policy->min > data->min && policy->min > policy->max) {
+	if (policy->min > data->max || policy->max < data->min) {
@@ -1763 +1780 @@
-static struct notifier_block __cpuinitdata cpufreq_cpu_notifier =
+static struct notifier_block __refdata cpufreq_cpu_notifier =
--- ./projects/linux/linux-2.6.25/drivers/cpufreq/cpufreq.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/cpufreq/cpufreq.c	2008-07-13 23:51:29.000000000 +0200
@@ -120,0 +121 @@
+static bool init_cpufreq_transition_notifier_list_called;
@@ -123,0 +125 @@
+	init_cpufreq_transition_notifier_list_called = true;
@@ -219 +221 @@
-							const char *fmt, ...)
+			const char *fmt, ...)
@@ -381 +383 @@
-static int cpufreq_parse_governor (char *str_governor, unsigned int *policy,
+static int cpufreq_parse_governor(char *str_governor, unsigned int *policy,
@@ -413 +415 @@
-				ret = request_module(name);
+				ret = request_module("%s", name);
@@ -449 +451 @@
-(struct cpufreq_policy * policy, char *buf)		\
+(struct cpufreq_policy *policy, char *buf)		\
@@ -468 +470 @@
-(struct cpufreq_policy * policy, const char *buf, size_t count)		\
+(struct cpufreq_policy *policy, const char *buf, size_t count)		\
@@ -493,2 +495,2 @@
-static ssize_t show_cpuinfo_cur_freq (struct cpufreq_policy * policy,
-							char *buf)
+static ssize_t show_cpuinfo_cur_freq(struct cpufreq_policy *policy,
+					char *buf)
@@ -506,2 +508 @@
-static ssize_t show_scaling_governor (struct cpufreq_policy * policy,
-							char *buf)
+static ssize_t show_scaling_governor(struct cpufreq_policy *policy, char *buf)
@@ -522,2 +523,2 @@
-static ssize_t store_scaling_governor (struct cpufreq_policy * policy,
-				       const char *buf, size_t count)
+static ssize_t store_scaling_governor(struct cpufreq_policy *policy,
+					const char *buf, size_t count)
@@ -557 +558 @@
-static ssize_t show_scaling_driver (struct cpufreq_policy * policy, char *buf)
+static ssize_t show_scaling_driver(struct cpufreq_policy *policy, char *buf)
@@ -565,2 +566,2 @@
-static ssize_t show_scaling_available_governors (struct cpufreq_policy *policy,
-				char *buf)
+static ssize_t show_scaling_available_governors(struct cpufreq_policy *policy,
+						char *buf)
@@ -585,4 +586,2 @@
-/**
- * show_affected_cpus - show the CPUs affected by each transition
- */
-static ssize_t show_affected_cpus (struct cpufreq_policy * policy, char *buf)
+
+static ssize_t show_cpus(cpumask_t mask, char *buf)
@@ -593 +592 @@
-	for_each_cpu_mask(cpu, policy->cpus) {
+	for_each_cpu_mask(cpu, mask) {
@@ -603,0 +603,19 @@
+/**
+ * show_related_cpus - show the CPUs affected by each transition even if
+ * hw coordination is in use
+ */
+static ssize_t show_related_cpus(struct cpufreq_policy *policy, char *buf)
+{
+	if (cpus_empty(policy->related_cpus))
+		return show_cpus(policy->cpus, buf);
+	return show_cpus(policy->related_cpus, buf);
+}
+
+/**
+ * show_affected_cpus - show the CPUs affected by each transition
+ */
+static ssize_t show_affected_cpus(struct cpufreq_policy *policy, char *buf)
+{
+	return show_cpus(policy->cpus, buf);
+}
+
@@ -605 +623 @@
-		const char *buf, size_t count)
+					const char *buf, size_t count)
@@ -610 +628 @@
-	if (!policy->governor->store_setspeed)
+	if (!policy->governor || !policy->governor->store_setspeed)
@@ -624 +642 @@
-	if (!policy->governor->show_setspeed)
+	if (!policy->governor || !policy->governor->show_setspeed)
@@ -647,0 +666 @@
+define_one_ro(related_cpus);
@@ -654 +673 @@
-static struct attribute * default_attrs[] = {
+static struct attribute *default_attrs[] = {
@@ -659,0 +679 @@
+	&related_cpus.attr,
@@ -670 +690 @@
-static ssize_t show(struct kobject * kobj, struct attribute * attr ,char * buf)
+static ssize_t show(struct kobject *kobj, struct attribute *attr ,char *buf)
@@ -672,2 +692,2 @@
-	struct cpufreq_policy * policy = to_policy(kobj);
-	struct freq_attr * fattr = to_attr(attr);
+	struct cpufreq_policy *policy = to_policy(kobj);
+	struct freq_attr *fattr = to_attr(attr);
@@ -694,2 +714,2 @@
-static ssize_t store(struct kobject * kobj, struct attribute * attr,
-		     const char * buf, size_t count)
+static ssize_t store(struct kobject *kobj, struct attribute *attr,
+		     const char *buf, size_t count)
@@ -697,2 +717,2 @@
-	struct cpufreq_policy * policy = to_policy(kobj);
-	struct freq_attr * fattr = to_attr(attr);
+	struct cpufreq_policy *policy = to_policy(kobj);
+	struct freq_attr *fattr = to_attr(attr);
@@ -719 +739 @@
-static void cpufreq_sysfs_release(struct kobject * kobj)
+static void cpufreq_sysfs_release(struct kobject *kobj)
@@ -721 +741 @@
-	struct cpufreq_policy * policy = to_policy(kobj);
+	struct cpufreq_policy *policy = to_policy(kobj);
@@ -743 +763 @@
-static int cpufreq_add_dev (struct sys_device * sys_dev)
+static int cpufreq_add_dev(struct sys_device *sys_dev)
@@ -803 +822,0 @@
-		unlock_policy_rwsem_write(cpu);
@@ -826 +845 @@
-		managed_policy = cpufreq_cpu_get(j);
+		managed_policy = cpufreq_cpu_get(j);		// FIXME: Where is this released?  What about error paths?
@@ -845,2 +864 @@
-			if (ret) {
-				unlock_policy_rwsem_write(cpu);
+			if (ret)
@@ -848 +865,0 @@
-			}
@@ -852 +868,0 @@
-			unlock_policy_rwsem_write(cpu);
@@ -862,2 +878 @@
-	if (ret) {
-		unlock_policy_rwsem_write(cpu);
+	if (ret)
@@ -865 +880 @@
-	}
+
@@ -870,2 +885 @@
-		if (ret) {
-			unlock_policy_rwsem_write(cpu);
+		if (ret)
@@ -873 +886,0 @@
-		}
@@ -876 +889 @@
-	if (cpufreq_driver->get){
+	if (cpufreq_driver->get) {
@@ -878,2 +891 @@
-		if (ret) {
-			unlock_policy_rwsem_write(cpu);
+		if (ret)
@@ -881 +892,0 @@
-		}
@@ -883 +894 @@
-	if (cpufreq_driver->target){
+	if (cpufreq_driver->target) {
@@ -885,2 +896 @@
-		if (ret) {
-			unlock_policy_rwsem_write(cpu);
+		if (ret)
@@ -888 +897,0 @@
-		}
@@ -910,2 +919 @@
-		if (ret) {
-			unlock_policy_rwsem_write(cpu);
+		if (ret)
@@ -913 +920,0 @@
-		}
@@ -924,2 +930,0 @@
-	unlock_policy_rwsem_write(cpu);
-
@@ -930,0 +936,2 @@
+	unlock_policy_rwsem_write(cpu);
+
@@ -952,0 +960 @@
+	unlock_policy_rwsem_write(cpu);
@@ -970 +978 @@
-static int __cpufreq_remove_dev (struct sys_device * sys_dev)
+static int __cpufreq_remove_dev(struct sys_device *sys_dev)
@@ -1074 +1082 @@
-static int cpufreq_remove_dev (struct sys_device * sys_dev)
+static int cpufreq_remove_dev(struct sys_device *sys_dev)
@@ -1141 +1149 @@
-	return (ret_freq);
+	return ret_freq;
@@ -1152 +1160 @@
-		return (ret_freq);
+		return ret_freq;
@@ -1166 +1174 @@
-	return (ret_freq);
+	return ret_freq;
@@ -1193 +1201 @@
-	return (ret_freq);
+	return ret_freq;
@@ -1202 +1210 @@
-static int cpufreq_suspend(struct sys_device * sysdev, pm_message_t pmsg)
+static int cpufreq_suspend(struct sys_device *sysdev, pm_message_t pmsg)
@@ -1224,4 +1232,2 @@
-	if (unlikely(cpu_policy->cpu != cpu)) {
-		cpufreq_cpu_put(cpu_policy);
-		return 0;
-	}
+	if (unlikely(cpu_policy->cpu != cpu))
+		goto out;
@@ -1234,2 +1240 @@
-			cpufreq_cpu_put(cpu_policy);
-			return ret;
+			goto out;
@@ -1239 +1243,0 @@
-
@@ -1273 +1277 @@
-	return 0;
+	return ret;
@@ -1284 +1288 @@
-static int cpufreq_resume(struct sys_device * sysdev)
+static int cpufreq_resume(struct sys_device *sysdev)
@@ -1305,4 +1309,2 @@
-	if (unlikely(cpu_policy->cpu != cpu)) {
-		cpufreq_cpu_put(cpu_policy);
-		return 0;
-	}
+	if (unlikely(cpu_policy->cpu != cpu))
+		goto fail;
@@ -1315,2 +1317 @@
-			cpufreq_cpu_put(cpu_policy);
-			return ret;
+			goto fail;
@@ -1355,0 +1357 @@
+fail:
@@ -1388,0 +1391,2 @@
+	WARN_ON(!init_cpufreq_transition_notifier_list_called);
+
@@ -1851 +1855 @@
-	return (ret);
+	return ret;
--- ./projects/linux/linux-2.6.26/drivers/cpufreq/cpufreq.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/cpufreq/cpufreq.c	2008-10-10 00:13:53.000000000 +0200
@@ -41 +41 @@
-static struct cpufreq_policy *cpufreq_cpu_data[NR_CPUS];
+static DEFINE_PER_CPU(struct cpufreq_policy *, cpufreq_cpu_data);
@@ -44 +44 @@
-static struct cpufreq_governor *cpufreq_cpu_governor[NR_CPUS];
+static DEFINE_PER_CPU(struct cpufreq_governor *, cpufreq_cpu_governor);
@@ -138 +138 @@
-	if (cpu >= NR_CPUS)
+	if (cpu >= nr_cpu_ids)
@@ -152 +152 @@
-	data = cpufreq_cpu_data[cpu];
+	data = per_cpu(cpufreq_cpu_data, cpu);
@@ -330 +330 @@
-	policy = cpufreq_cpu_data[freqs->cpu];
+	policy = per_cpu(cpufreq_cpu_data, freqs->cpu);
@@ -592 +592 @@
-	for_each_cpu_mask(cpu, mask) {
+	for_each_cpu_mask_nr(cpu, mask) {
@@ -827,0 +828,3 @@
+	blocking_notifier_call_chain(&cpufreq_policy_notifier_list,
+				     CPUFREQ_START, policy);
+
@@ -831,2 +834,2 @@
-	if (cpufreq_cpu_governor[cpu]){
-		policy->governor = cpufreq_cpu_governor[cpu];
+	if (per_cpu(cpufreq_cpu_governor, cpu)) {
+		policy->governor = per_cpu(cpufreq_cpu_governor, cpu);
@@ -838 +841 @@
-	for_each_cpu_mask(j, policy->cpus) {
+	for_each_cpu_mask_nr(j, policy->cpus) {
@@ -857 +860 @@
-			cpufreq_cpu_data[cpu] = managed_policy;
+			per_cpu(cpufreq_cpu_data, cpu) = managed_policy;
@@ -901,2 +904,2 @@
-	for_each_cpu_mask(j, policy->cpus) {
-		cpufreq_cpu_data[j] = policy;
+	for_each_cpu_mask_nr(j, policy->cpus) {
+		per_cpu(cpufreq_cpu_data, j) = policy;
@@ -908 +911 @@
-	for_each_cpu_mask(j, policy->cpus) {
+	for_each_cpu_mask_nr(j, policy->cpus) {
@@ -948,2 +951,2 @@
-	for_each_cpu_mask(j, policy->cpus)
-		cpufreq_cpu_data[j] = NULL;
+	for_each_cpu_mask_nr(j, policy->cpus)
+		per_cpu(cpufreq_cpu_data, j) = NULL;
@@ -992 +995 @@
-	data = cpufreq_cpu_data[cpu];
+	data = per_cpu(cpufreq_cpu_data, cpu);
@@ -1000 +1003 @@
-	cpufreq_cpu_data[cpu] = NULL;
+	per_cpu(cpufreq_cpu_data, cpu) = NULL;
@@ -1022 +1025 @@
-	cpufreq_cpu_governor[cpu] = data->governor;
+	per_cpu(cpufreq_cpu_governor, cpu) = data->governor;
@@ -1027,2 +1030,2 @@
-	 * cpufreq_cpu_data[] while holding the lock, and remove the sysfs
-	 * links afterwards.
+	 * per_cpu(cpufreq_cpu_data) while holding the lock, and remove
+	 * the sysfs links afterwards.
@@ -1031 +1034 @@
-		for_each_cpu_mask(j, data->cpus) {
+		for_each_cpu_mask_nr(j, data->cpus) {
@@ -1034 +1037 @@
-			cpufreq_cpu_data[j] = NULL;
+			per_cpu(cpufreq_cpu_data, j) = NULL;
@@ -1041 +1044 @@
-		for_each_cpu_mask(j, data->cpus) {
+		for_each_cpu_mask_nr(j, data->cpus) {
@@ -1046 +1049 @@
-			cpufreq_cpu_governor[j] = data->governor;
+			per_cpu(cpufreq_cpu_governor, j) = data->governor;
@@ -1156 +1159 @@
-	struct cpufreq_policy *policy = cpufreq_cpu_data[cpu];
+	struct cpufreq_policy *policy = per_cpu(cpufreq_cpu_data, cpu);
@@ -1825 +1828,2 @@
-	ret = sysdev_driver_register(&cpu_sysdev_class,&cpufreq_sysdev_driver);
+	ret = sysdev_driver_register(&cpu_sysdev_class,
+					&cpufreq_sysdev_driver);
@@ -1832,2 +1836,2 @@
-		for (i=0; i<NR_CPUS; i++)
-			if (cpufreq_cpu_data[i])
+		for (i = 0; i < nr_cpu_ids; i++)
+			if (cpu_possible(i) && per_cpu(cpufreq_cpu_data, i)) {
@@ -1834,0 +1839,2 @@
+				break;
+			}
--- ./projects/linux/linux-2.6.27/drivers/cpufreq/cpufreq.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/cpufreq/cpufreq.c	2008-12-25 00:26:37.000000000 +0100
@@ -1470 +1470 @@
-	int ret;
+	int ret = -EINVAL;
@@ -1474 +1474 @@
-		return -EINVAL;
+		goto no_policy;
@@ -1477 +1477 @@
-		return -EINVAL;
+		goto fail;
@@ -1482,0 +1483 @@
+fail:
@@ -1483,0 +1485 @@
+no_policy:
@@ -1488 +1490 @@
-int __cpufreq_driver_getavg(struct cpufreq_policy *policy)
+int __cpufreq_driver_getavg(struct cpufreq_policy *policy, unsigned int cpu)
@@ -1496,2 +1498,2 @@
-	if (cpu_online(policy->cpu) && cpufreq_driver->getavg)
-		ret = cpufreq_driver->getavg(policy->cpu);
+	if (cpu_online(cpu) && cpufreq_driver->getavg)
+		ret = cpufreq_driver->getavg(policy, cpu);
@@ -1720 +1722 @@
-	int ret = 0;
+	int ret;
@@ -1722,2 +1724,4 @@
-	if (!data)
-		return -ENODEV;
+	if (!data) {
+		ret = -ENODEV;
+		goto no_policy;
+	}
@@ -1725,2 +1729,4 @@
-	if (unlikely(lock_policy_rwsem_write(cpu)))
-		return -EINVAL;
+	if (unlikely(lock_policy_rwsem_write(cpu))) {
+		ret = -EINVAL;
+		goto fail;
+	}
@@ -1752,0 +1759 @@
+fail:
@@ -1753,0 +1761 @@
+no_policy:
--- ./projects/linux/linux-2.6.28/drivers/cpufreq/cpufreq.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/cpufreq/cpufreq.c	2009-03-24 00:12:14.000000000 +0100
@@ -587 +587 @@
-static ssize_t show_cpus(cpumask_t mask, char *buf)
+static ssize_t show_cpus(const struct cpumask *mask, char *buf)
@@ -592 +592 @@
-	for_each_cpu_mask_nr(cpu, mask) {
+	for_each_cpu(cpu, mask) {
@@ -609 +609 @@
-	if (cpus_empty(policy->related_cpus))
+	if (cpumask_empty(policy->related_cpus))
@@ -803,0 +804,11 @@
+	if (!alloc_cpumask_var(&policy->cpus, GFP_KERNEL)) {
+		kfree(policy);
+		ret = -ENOMEM;
+		goto nomem_out;
+	}
+	if (!alloc_cpumask_var(&policy->related_cpus, GFP_KERNEL)) {
+		free_cpumask_var(policy->cpus);
+		kfree(policy);
+		ret = -ENOMEM;
+		goto nomem_out;
+	}
@@ -806 +817 @@
-	policy->cpus = cpumask_of_cpu(cpu);
+	cpumask_copy(policy->cpus, cpumask_of(cpu));
@@ -825,2 +836,2 @@
-	policy->user_policy.min = policy->cpuinfo.min_freq;
-	policy->user_policy.max = policy->cpuinfo.max_freq;
+	policy->user_policy.min = policy->min;
+	policy->user_policy.max = policy->max;
@@ -841 +852 @@
-	for_each_cpu_mask_nr(j, policy->cpus) {
+	for_each_cpu(j, policy->cpus) {
@@ -859 +870 @@
-			managed_policy->cpus = policy->cpus;
+			cpumask_copy(managed_policy->cpus, policy->cpus);
@@ -904 +915 @@
-	for_each_cpu_mask_nr(j, policy->cpus) {
+	for_each_cpu(j, policy->cpus) {
@@ -911 +922 @@
-	for_each_cpu_mask_nr(j, policy->cpus) {
+	for_each_cpu(j, policy->cpus) {
@@ -951 +962 @@
-	for_each_cpu_mask_nr(j, policy->cpus)
+	for_each_cpu(j, policy->cpus)
@@ -1012 +1023 @@
-		cpu_clear(cpu, data->cpus);
+		cpumask_clear_cpu(cpu, data->cpus);
@@ -1033,2 +1044,2 @@
-	if (unlikely(cpus_weight(data->cpus) > 1)) {
-		for_each_cpu_mask_nr(j, data->cpus) {
+	if (unlikely(cpumask_weight(data->cpus) > 1)) {
+		for_each_cpu(j, data->cpus) {
@@ -1043,2 +1054,2 @@
-	if (unlikely(cpus_weight(data->cpus) > 1)) {
-		for_each_cpu_mask_nr(j, data->cpus) {
+	if (unlikely(cpumask_weight(data->cpus) > 1)) {
+		for_each_cpu(j, data->cpus) {
@@ -1077,0 +1089,2 @@
+	free_cpumask_var(data->related_cpus);
+	free_cpumask_var(data->cpus);
@@ -1078,0 +1092 @@
+	per_cpu(cpufreq_cpu_data, cpu) = NULL;
--- ./projects/linux/linux-2.6.29/drivers/cpufreq/cpufreq.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/cpufreq/cpufreq.c	2009-06-27 11:32:32.000000000 +0200
@@ -107 +107,2 @@
-static int __cpufreq_governor(struct cpufreq_policy *policy, unsigned int event);
+static int __cpufreq_governor(struct cpufreq_policy *policy,
+		unsigned int event);
@@ -131 +132 @@
-static DEFINE_MUTEX (cpufreq_governor_mutex);
+static DEFINE_MUTEX(cpufreq_governor_mutex);
@@ -374 +375 @@
-		if (!strnicmp(str_governor,t->name,CPUFREQ_NAME_LEN))
+		if (!strnicmp(str_governor, t->name, CPUFREQ_NAME_LEN))
@@ -432 +433 @@
-  out:
+out:
@@ -437,4 +437,0 @@
-/* drivers/base/cpu.c */
-extern struct sysdev_class cpu_sysdev_class;
-
-
@@ -453 +450 @@
-	return sprintf (buf, "%u\n", policy->object);	\
+	return sprintf(buf, "%u\n", policy->object);	\
@@ -457,0 +455 @@
+show_one(cpuinfo_transition_latency, cpuinfo.transition_latency);
@@ -479 +477 @@
-	ret = sscanf (buf, "%u", &new_policy.object);			\
+	ret = sscanf(buf, "%u", &new_policy.object);			\
@@ -489,2 +487,2 @@
-store_one(scaling_min_freq,min);
-store_one(scaling_max_freq,max);
+store_one(scaling_min_freq, min);
+store_one(scaling_max_freq, max);
@@ -510 +508 @@
-	if(policy->policy == CPUFREQ_POLICY_POWERSAVE)
+	if (policy->policy == CPUFREQ_POLICY_POWERSAVE)
@@ -515 +513,2 @@
-		return scnprintf(buf, CPUFREQ_NAME_LEN, "%s\n", policy->governor->name);
+		return scnprintf(buf, CPUFREQ_NAME_LEN, "%s\n",
+				policy->governor->name);
@@ -534 +533 @@
-	ret = sscanf (buf, "%15s", str_governor);
+	ret = sscanf(buf, "%15s", str_governor);
@@ -578 +577,2 @@
-		if (i >= (ssize_t) ((PAGE_SIZE / sizeof(char)) - (CPUFREQ_NAME_LEN + 2)))
+		if (i >= (ssize_t) ((PAGE_SIZE / sizeof(char))
+		    - (CPUFREQ_NAME_LEN + 2)))
@@ -597 +597 @@
-		    break;
+			break;
@@ -662,0 +663 @@
+define_one_ro(cpuinfo_transition_latency);
@@ -675,0 +677 @@
+	&cpuinfo_transition_latency.attr,
@@ -687,2 +689,2 @@
-#define to_policy(k) container_of(k,struct cpufreq_policy,kobj)
-#define to_attr(a) container_of(a,struct freq_attr,attr)
+#define to_policy(k) container_of(k, struct cpufreq_policy, kobj)
+#define to_attr(a) container_of(a, struct freq_attr, attr)
@@ -690 +692 @@
-static ssize_t show(struct kobject *kobj, struct attribute *attr ,char *buf)
+static ssize_t show(struct kobject *kobj, struct attribute *attr, char *buf)
@@ -809 +811 @@
-	if (!alloc_cpumask_var(&policy->related_cpus, GFP_KERNEL)) {
+	if (!zalloc_cpumask_var(&policy->related_cpus, GFP_KERNEL)) {
@@ -856,2 +858,2 @@
-		/* check for existing affected CPUs.  They may not be aware
-		 * of it due to CPU Hotplug.
+		/* Check for existing affected CPUs.
+		 * They may not be aware of it due to CPU Hotplug.
@@ -859 +861 @@
-		managed_policy = cpufreq_cpu_get(j);		// FIXME: Where is this released?  What about error paths?
+		managed_policy = cpufreq_cpu_get(j);		/* FIXME: Where is this released?  What about error paths? */
@@ -1070,0 +1073,2 @@
+	unlock_policy_rwsem_write(cpu);
+
@@ -1074,2 +1077,0 @@
-	unlock_policy_rwsem_write(cpu);
-
@@ -1130,2 +1132,2 @@
- *	We adjust to current frequency first, and need to clean up later. So either call
- *	to cpufreq_update_policy() or schedule handle_update()).
+ *	We adjust to current frequency first, and need to clean up later.
+ *	So either call to cpufreq_update_policy() or schedule handle_update()).
@@ -1613 +1615,2 @@
- * @policy: struct cpufreq_policy into which the current cpufreq_policy is written
+ * @policy: struct cpufreq_policy into which the current cpufreq_policy
+ *	is written
--- ./projects/linux/linux-2.6.27/drivers/gpu/drm/drm_lock.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/gpu/drm/drm_lock.c	2008-12-25 00:26:37.000000000 +0100
@@ -157,2 +156,0 @@
-	unsigned long irqflags;
-	void (*tasklet_func)(struct drm_device *);
@@ -166,7 +163,0 @@
-	spin_lock_irqsave(&dev->tasklet_lock, irqflags);
-	tasklet_func = dev->locked_tasklet_func;
-	dev->locked_tasklet_func = NULL;
-	spin_unlock_irqrestore(&dev->tasklet_lock, irqflags);
-	if (tasklet_func != NULL)
-		tasklet_func(dev);
-
@@ -234,0 +226 @@
+EXPORT_SYMBOL(drm_lock_take);
@@ -301,0 +294 @@
+EXPORT_SYMBOL(drm_lock_free);
--- ./projects/linux/linux-2.6.28/drivers/gpu/drm/drm_lock.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/gpu/drm/drm_lock.c	2009-03-24 00:12:14.000000000 +0100
@@ -54,0 +55 @@
+	struct drm_master *master = file_priv->master;
@@ -67 +68 @@
-		  dev->lock.hw_lock->lock, lock->flags);
+		  master->lock.hw_lock->lock, lock->flags);
@@ -73,4 +74,5 @@
-	add_wait_queue(&dev->lock.lock_queue, &entry);
-	spin_lock_bh(&dev->lock.spinlock);
-	dev->lock.user_waiters++;
-	spin_unlock_bh(&dev->lock.spinlock);
+	add_wait_queue(&master->lock.lock_queue, &entry);
+	spin_lock_bh(&master->lock.spinlock);
+	master->lock.user_waiters++;
+	spin_unlock_bh(&master->lock.spinlock);
+
@@ -79 +81 @@
-		if (!dev->lock.hw_lock) {
+		if (!master->lock.hw_lock) {
@@ -80,0 +83 @@
+			send_sig(SIGTERM, current, 0);
@@ -84,3 +87,3 @@
-		if (drm_lock_take(&dev->lock, lock->context)) {
-			dev->lock.file_priv = file_priv;
-			dev->lock.lock_time = jiffies;
+		if (drm_lock_take(&master->lock, lock->context)) {
+			master->lock.file_priv = file_priv;
+			master->lock.lock_time = jiffies;
@@ -94 +97 @@
-			ret = -ERESTARTSYS;
+			ret = -EINTR;
@@ -98,3 +101,3 @@
-	spin_lock_bh(&dev->lock.spinlock);
-	dev->lock.user_waiters--;
-	spin_unlock_bh(&dev->lock.spinlock);
+	spin_lock_bh(&master->lock.spinlock);
+	master->lock.user_waiters--;
+	spin_unlock_bh(&master->lock.spinlock);
@@ -102 +105 @@
-	remove_wait_queue(&dev->lock.lock_queue, &entry);
+	remove_wait_queue(&master->lock.lock_queue, &entry);
@@ -111 +114 @@
-	if (!file_priv->master) {
+	if (!file_priv->is_master) {
@@ -118 +121 @@
-		dev->sigdata.lock = dev->lock.hw_lock;
+		dev->sigdata.lock = master->lock.hw_lock;
@@ -156,0 +160 @@
+	struct drm_master *master = file_priv->master;
@@ -172 +176 @@
-		if (drm_lock_free(&dev->lock,lock->context)) {
+		if (drm_lock_free(&master->lock, lock->context)) {
@@ -382,3 +386,4 @@
-	return (file_priv->lock_count && dev->lock.hw_lock &&
-		_DRM_LOCK_IS_HELD(dev->lock.hw_lock->lock) &&
-		dev->lock.file_priv == file_priv);
+	struct drm_master *master = file_priv->master;
+	return (file_priv->lock_count && master->lock.hw_lock &&
+		_DRM_LOCK_IS_HELD(master->lock.hw_lock->lock) &&
+		master->lock.file_priv == file_priv);
--- ./projects/linux/linux-2.6.27/drivers/gpu/drm/i915/i915_drv.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/gpu/drm/i915/i915_drv.c	2008-12-25 00:26:37.000000000 +0100
@@ -41,201 +40,0 @@
-enum pipe {
-    PIPE_A = 0,
-    PIPE_B,
-};
-
-static bool i915_pipe_enabled(struct drm_device *dev, enum pipe pipe)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-
-	if (pipe == PIPE_A)
-		return (I915_READ(DPLL_A) & DPLL_VCO_ENABLE);
-	else
-		return (I915_READ(DPLL_B) & DPLL_VCO_ENABLE);
-}
-
-static void i915_save_palette(struct drm_device *dev, enum pipe pipe)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	unsigned long reg = (pipe == PIPE_A ? PALETTE_A : PALETTE_B);
-	u32 *array;
-	int i;
-
-	if (!i915_pipe_enabled(dev, pipe))
-		return;
-
-	if (pipe == PIPE_A)
-		array = dev_priv->save_palette_a;
-	else
-		array = dev_priv->save_palette_b;
-
-	for(i = 0; i < 256; i++)
-		array[i] = I915_READ(reg + (i << 2));
-}
-
-static void i915_restore_palette(struct drm_device *dev, enum pipe pipe)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	unsigned long reg = (pipe == PIPE_A ? PALETTE_A : PALETTE_B);
-	u32 *array;
-	int i;
-
-	if (!i915_pipe_enabled(dev, pipe))
-		return;
-
-	if (pipe == PIPE_A)
-		array = dev_priv->save_palette_a;
-	else
-		array = dev_priv->save_palette_b;
-
-	for(i = 0; i < 256; i++)
-		I915_WRITE(reg + (i << 2), array[i]);
-}
-
-static u8 i915_read_indexed(u16 index_port, u16 data_port, u8 reg)
-{
-	outb(reg, index_port);
-	return inb(data_port);
-}
-
-static u8 i915_read_ar(u16 st01, u8 reg, u16 palette_enable)
-{
-	inb(st01);
-	outb(palette_enable | reg, VGA_AR_INDEX);
-	return inb(VGA_AR_DATA_READ);
-}
-
-static void i915_write_ar(u8 st01, u8 reg, u8 val, u16 palette_enable)
-{
-	inb(st01);
-	outb(palette_enable | reg, VGA_AR_INDEX);
-	outb(val, VGA_AR_DATA_WRITE);
-}
-
-static void i915_write_indexed(u16 index_port, u16 data_port, u8 reg, u8 val)
-{
-	outb(reg, index_port);
-	outb(val, data_port);
-}
-
-static void i915_save_vga(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	int i;
-	u16 cr_index, cr_data, st01;
-
-	/* VGA color palette registers */
-	dev_priv->saveDACMASK = inb(VGA_DACMASK);
-	/* DACCRX automatically increments during read */
-	outb(0, VGA_DACRX);
-	/* Read 3 bytes of color data from each index */
-	for (i = 0; i < 256 * 3; i++)
-		dev_priv->saveDACDATA[i] = inb(VGA_DACDATA);
-
-	/* MSR bits */
-	dev_priv->saveMSR = inb(VGA_MSR_READ);
-	if (dev_priv->saveMSR & VGA_MSR_CGA_MODE) {
-		cr_index = VGA_CR_INDEX_CGA;
-		cr_data = VGA_CR_DATA_CGA;
-		st01 = VGA_ST01_CGA;
-	} else {
-		cr_index = VGA_CR_INDEX_MDA;
-		cr_data = VGA_CR_DATA_MDA;
-		st01 = VGA_ST01_MDA;
-	}
-
-	/* CRT controller regs */
-	i915_write_indexed(cr_index, cr_data, 0x11,
-			   i915_read_indexed(cr_index, cr_data, 0x11) &
-			   (~0x80));
-	for (i = 0; i <= 0x24; i++)
-		dev_priv->saveCR[i] =
-			i915_read_indexed(cr_index, cr_data, i);
-	/* Make sure we don't turn off CR group 0 writes */
-	dev_priv->saveCR[0x11] &= ~0x80;
-
-	/* Attribute controller registers */
-	inb(st01);
-	dev_priv->saveAR_INDEX = inb(VGA_AR_INDEX);
-	for (i = 0; i <= 0x14; i++)
-		dev_priv->saveAR[i] = i915_read_ar(st01, i, 0);
-	inb(st01);
-	outb(dev_priv->saveAR_INDEX, VGA_AR_INDEX);
-	inb(st01);
-
-	/* Graphics controller registers */
-	for (i = 0; i < 9; i++)
-		dev_priv->saveGR[i] =
-			i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, i);
-
-	dev_priv->saveGR[0x10] =
-		i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x10);
-	dev_priv->saveGR[0x11] =
-		i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x11);
-	dev_priv->saveGR[0x18] =
-		i915_read_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x18);
-
-	/* Sequencer registers */
-	for (i = 0; i < 8; i++)
-		dev_priv->saveSR[i] =
-			i915_read_indexed(VGA_SR_INDEX, VGA_SR_DATA, i);
-}
-
-static void i915_restore_vga(struct drm_device *dev)
-{
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	int i;
-	u16 cr_index, cr_data, st01;
-
-	/* MSR bits */
-	outb(dev_priv->saveMSR, VGA_MSR_WRITE);
-	if (dev_priv->saveMSR & VGA_MSR_CGA_MODE) {
-		cr_index = VGA_CR_INDEX_CGA;
-		cr_data = VGA_CR_DATA_CGA;
-		st01 = VGA_ST01_CGA;
-	} else {
-		cr_index = VGA_CR_INDEX_MDA;
-		cr_data = VGA_CR_DATA_MDA;
-		st01 = VGA_ST01_MDA;
-	}
-
-	/* Sequencer registers, don't write SR07 */
-	for (i = 0; i < 7; i++)
-		i915_write_indexed(VGA_SR_INDEX, VGA_SR_DATA, i,
-				   dev_priv->saveSR[i]);
-
-	/* CRT controller regs */
-	/* Enable CR group 0 writes */
-	i915_write_indexed(cr_index, cr_data, 0x11, dev_priv->saveCR[0x11]);
-	for (i = 0; i <= 0x24; i++)
-		i915_write_indexed(cr_index, cr_data, i, dev_priv->saveCR[i]);
-
-	/* Graphics controller regs */
-	for (i = 0; i < 9; i++)
-		i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, i,
-				   dev_priv->saveGR[i]);
-
-	i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x10,
-			   dev_priv->saveGR[0x10]);
-	i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x11,
-			   dev_priv->saveGR[0x11]);
-	i915_write_indexed(VGA_GR_INDEX, VGA_GR_DATA, 0x18,
-			   dev_priv->saveGR[0x18]);
-
-	/* Attribute controller registers */
-	inb(st01);
-	for (i = 0; i <= 0x14; i++)
-		i915_write_ar(st01, i, dev_priv->saveAR[i], 0);
-	inb(st01); /* switch back to index mode */
-	outb(dev_priv->saveAR_INDEX | 0x20, VGA_AR_INDEX);
-	inb(st01);
-
-	/* VGA color palette registers */
-	outb(dev_priv->saveDACMASK, VGA_DACMASK);
-	/* DACCRX automatically increments during read */
-	outb(0, VGA_DACWX);
-	/* Read 3 bytes of color data from each index */
-	for (i = 0; i < 256 * 3; i++)
-		outb(dev_priv->saveDACDATA[i], VGA_DACDATA);
-
-}
-
@@ -245 +43,0 @@
-	int i;
@@ -257,63 +54,0 @@
-	pci_read_config_byte(dev->pdev, LBB, &dev_priv->saveLBB);
-
-	/* Display arbitration control */
-	dev_priv->saveDSPARB = I915_READ(DSPARB);
-
-	/* Pipe & plane A info */
-	dev_priv->savePIPEACONF = I915_READ(PIPEACONF);
-	dev_priv->savePIPEASRC = I915_READ(PIPEASRC);
-	dev_priv->saveFPA0 = I915_READ(FPA0);
-	dev_priv->saveFPA1 = I915_READ(FPA1);
-	dev_priv->saveDPLL_A = I915_READ(DPLL_A);
-	if (IS_I965G(dev))
-		dev_priv->saveDPLL_A_MD = I915_READ(DPLL_A_MD);
-	dev_priv->saveHTOTAL_A = I915_READ(HTOTAL_A);
-	dev_priv->saveHBLANK_A = I915_READ(HBLANK_A);
-	dev_priv->saveHSYNC_A = I915_READ(HSYNC_A);
-	dev_priv->saveVTOTAL_A = I915_READ(VTOTAL_A);
-	dev_priv->saveVBLANK_A = I915_READ(VBLANK_A);
-	dev_priv->saveVSYNC_A = I915_READ(VSYNC_A);
-	dev_priv->saveBCLRPAT_A = I915_READ(BCLRPAT_A);
-
-	dev_priv->saveDSPACNTR = I915_READ(DSPACNTR);
-	dev_priv->saveDSPASTRIDE = I915_READ(DSPASTRIDE);
-	dev_priv->saveDSPASIZE = I915_READ(DSPASIZE);
-	dev_priv->saveDSPAPOS = I915_READ(DSPAPOS);
-	dev_priv->saveDSPABASE = I915_READ(DSPABASE);
-	if (IS_I965G(dev)) {
-		dev_priv->saveDSPASURF = I915_READ(DSPASURF);
-		dev_priv->saveDSPATILEOFF = I915_READ(DSPATILEOFF);
-	}
-	i915_save_palette(dev, PIPE_A);
-	dev_priv->savePIPEASTAT = I915_READ(I915REG_PIPEASTAT);
-
-	/* Pipe & plane B info */
-	dev_priv->savePIPEBCONF = I915_READ(PIPEBCONF);
-	dev_priv->savePIPEBSRC = I915_READ(PIPEBSRC);
-	dev_priv->saveFPB0 = I915_READ(FPB0);
-	dev_priv->saveFPB1 = I915_READ(FPB1);
-	dev_priv->saveDPLL_B = I915_READ(DPLL_B);
-	if (IS_I965G(dev))
-		dev_priv->saveDPLL_B_MD = I915_READ(DPLL_B_MD);
-	dev_priv->saveHTOTAL_B = I915_READ(HTOTAL_B);
-	dev_priv->saveHBLANK_B = I915_READ(HBLANK_B);
-	dev_priv->saveHSYNC_B = I915_READ(HSYNC_B);
-	dev_priv->saveVTOTAL_B = I915_READ(VTOTAL_B);
-	dev_priv->saveVBLANK_B = I915_READ(VBLANK_B);
-	dev_priv->saveVSYNC_B = I915_READ(VSYNC_B);
-	dev_priv->saveBCLRPAT_A = I915_READ(BCLRPAT_A);
-
-	dev_priv->saveDSPBCNTR = I915_READ(DSPBCNTR);
-	dev_priv->saveDSPBSTRIDE = I915_READ(DSPBSTRIDE);
-	dev_priv->saveDSPBSIZE = I915_READ(DSPBSIZE);
-	dev_priv->saveDSPBPOS = I915_READ(DSPBPOS);
-	dev_priv->saveDSPBBASE = I915_READ(DSPBBASE);
-	if (IS_I965GM(dev) || IS_IGD_GM(dev)) {
-		dev_priv->saveDSPBSURF = I915_READ(DSPBSURF);
-		dev_priv->saveDSPBTILEOFF = I915_READ(DSPBTILEOFF);
-	}
-	i915_save_palette(dev, PIPE_B);
-	dev_priv->savePIPEBSTAT = I915_READ(I915REG_PIPEBSTAT);
-
-	/* CRT state */
-	dev_priv->saveADPA = I915_READ(ADPA);
@@ -321,50 +56 @@
-	/* LVDS state */
-	dev_priv->savePP_CONTROL = I915_READ(PP_CONTROL);
-	dev_priv->savePFIT_PGM_RATIOS = I915_READ(PFIT_PGM_RATIOS);
-	dev_priv->saveBLC_PWM_CTL = I915_READ(BLC_PWM_CTL);
-	if (IS_I965G(dev))
-		dev_priv->saveBLC_PWM_CTL2 = I915_READ(BLC_PWM_CTL2);
-	if (IS_MOBILE(dev) && !IS_I830(dev))
-		dev_priv->saveLVDS = I915_READ(LVDS);
-	if (!IS_I830(dev) && !IS_845G(dev))
-		dev_priv->savePFIT_CONTROL = I915_READ(PFIT_CONTROL);
-	dev_priv->saveLVDSPP_ON = I915_READ(LVDSPP_ON);
-	dev_priv->saveLVDSPP_OFF = I915_READ(LVDSPP_OFF);
-	dev_priv->savePP_CYCLE = I915_READ(PP_CYCLE);
-
-	/* FIXME: save TV & SDVO state */
-
-	/* FBC state */
-	dev_priv->saveFBC_CFB_BASE = I915_READ(FBC_CFB_BASE);
-	dev_priv->saveFBC_LL_BASE = I915_READ(FBC_LL_BASE);
-	dev_priv->saveFBC_CONTROL2 = I915_READ(FBC_CONTROL2);
-	dev_priv->saveFBC_CONTROL = I915_READ(FBC_CONTROL);
-
-	/* Interrupt state */
-	dev_priv->saveIIR = I915_READ(I915REG_INT_IDENTITY_R);
-	dev_priv->saveIER = I915_READ(I915REG_INT_ENABLE_R);
-	dev_priv->saveIMR = I915_READ(I915REG_INT_MASK_R);
-
-	/* VGA state */
-	dev_priv->saveVCLK_DIVISOR_VGA0 = I915_READ(VCLK_DIVISOR_VGA0);
-	dev_priv->saveVCLK_DIVISOR_VGA1 = I915_READ(VCLK_DIVISOR_VGA1);
-	dev_priv->saveVCLK_POST_DIV = I915_READ(VCLK_POST_DIV);
-	dev_priv->saveVGACNTRL = I915_READ(VGACNTRL);
-
-	/* Clock gating state */
-	dev_priv->saveD_STATE = I915_READ(D_STATE);
-	dev_priv->saveDSPCLK_GATE_D = I915_READ(DSPCLK_GATE_D);
-
-	/* Cache mode state */
-	dev_priv->saveCACHE_MODE_0 = I915_READ(CACHE_MODE_0);
-
-	/* Memory Arbitration state */
-	dev_priv->saveMI_ARB_STATE = I915_READ(MI_ARB_STATE);
-
-	/* Scratch space */
-	for (i = 0; i < 16; i++) {
-		dev_priv->saveSWF0[i] = I915_READ(SWF0 + (i << 2));
-		dev_priv->saveSWF1[i] = I915_READ(SWF10 + (i << 2));
-	}
-	for (i = 0; i < 3; i++)
-		dev_priv->saveSWF2[i] = I915_READ(SWF30 + (i << 2));
+	i915_save_state(dev);
@@ -372 +58 @@
-	i915_save_vga(dev);
+	intel_opregion_free(dev);
@@ -385,3 +70,0 @@
-	struct drm_i915_private *dev_priv = dev->dev_private;
-	int i;
-
@@ -394,138 +77 @@
-	pci_write_config_byte(dev->pdev, LBB, dev_priv->saveLBB);
-
-	I915_WRITE(DSPARB, dev_priv->saveDSPARB);
-
-	/* Pipe & plane A info */
-	/* Prime the clock */
-	if (dev_priv->saveDPLL_A & DPLL_VCO_ENABLE) {
-		I915_WRITE(DPLL_A, dev_priv->saveDPLL_A &
-			   ~DPLL_VCO_ENABLE);
-		udelay(150);
-	}
-	I915_WRITE(FPA0, dev_priv->saveFPA0);
-	I915_WRITE(FPA1, dev_priv->saveFPA1);
-	/* Actually enable it */
-	I915_WRITE(DPLL_A, dev_priv->saveDPLL_A);
-	udelay(150);
-	if (IS_I965G(dev))
-		I915_WRITE(DPLL_A_MD, dev_priv->saveDPLL_A_MD);
-	udelay(150);
-
-	/* Restore mode */
-	I915_WRITE(HTOTAL_A, dev_priv->saveHTOTAL_A);
-	I915_WRITE(HBLANK_A, dev_priv->saveHBLANK_A);
-	I915_WRITE(HSYNC_A, dev_priv->saveHSYNC_A);
-	I915_WRITE(VTOTAL_A, dev_priv->saveVTOTAL_A);
-	I915_WRITE(VBLANK_A, dev_priv->saveVBLANK_A);
-	I915_WRITE(VSYNC_A, dev_priv->saveVSYNC_A);
-	I915_WRITE(BCLRPAT_A, dev_priv->saveBCLRPAT_A);
-
-	/* Restore plane info */
-	I915_WRITE(DSPASIZE, dev_priv->saveDSPASIZE);
-	I915_WRITE(DSPAPOS, dev_priv->saveDSPAPOS);
-	I915_WRITE(PIPEASRC, dev_priv->savePIPEASRC);
-	I915_WRITE(DSPABASE, dev_priv->saveDSPABASE);
-	I915_WRITE(DSPASTRIDE, dev_priv->saveDSPASTRIDE);
-	if (IS_I965G(dev)) {
-		I915_WRITE(DSPASURF, dev_priv->saveDSPASURF);
-		I915_WRITE(DSPATILEOFF, dev_priv->saveDSPATILEOFF);
-	}
-
-	I915_WRITE(PIPEACONF, dev_priv->savePIPEACONF);
-
-	i915_restore_palette(dev, PIPE_A);
-	/* Enable the plane */
-	I915_WRITE(DSPACNTR, dev_priv->saveDSPACNTR);
-	I915_WRITE(DSPABASE, I915_READ(DSPABASE));
-
-	/* Pipe & plane B info */
-	if (dev_priv->saveDPLL_B & DPLL_VCO_ENABLE) {
-		I915_WRITE(DPLL_B, dev_priv->saveDPLL_B &
-			   ~DPLL_VCO_ENABLE);
-		udelay(150);
-	}
-	I915_WRITE(FPB0, dev_priv->saveFPB0);
-	I915_WRITE(FPB1, dev_priv->saveFPB1);
-	/* Actually enable it */
-	I915_WRITE(DPLL_B, dev_priv->saveDPLL_B);
-	udelay(150);
-	if (IS_I965G(dev))
-		I915_WRITE(DPLL_B_MD, dev_priv->saveDPLL_B_MD);
-	udelay(150);
-
-	/* Restore mode */
-	I915_WRITE(HTOTAL_B, dev_priv->saveHTOTAL_B);
-	I915_WRITE(HBLANK_B, dev_priv->saveHBLANK_B);
-	I915_WRITE(HSYNC_B, dev_priv->saveHSYNC_B);
-	I915_WRITE(VTOTAL_B, dev_priv->saveVTOTAL_B);
-	I915_WRITE(VBLANK_B, dev_priv->saveVBLANK_B);
-	I915_WRITE(VSYNC_B, dev_priv->saveVSYNC_B);
-	I915_WRITE(BCLRPAT_B, dev_priv->saveBCLRPAT_B);
-
-	/* Restore plane info */
-	I915_WRITE(DSPBSIZE, dev_priv->saveDSPBSIZE);
-	I915_WRITE(DSPBPOS, dev_priv->saveDSPBPOS);
-	I915_WRITE(PIPEBSRC, dev_priv->savePIPEBSRC);
-	I915_WRITE(DSPBBASE, dev_priv->saveDSPBBASE);
-	I915_WRITE(DSPBSTRIDE, dev_priv->saveDSPBSTRIDE);
-	if (IS_I965G(dev)) {
-		I915_WRITE(DSPBSURF, dev_priv->saveDSPBSURF);
-		I915_WRITE(DSPBTILEOFF, dev_priv->saveDSPBTILEOFF);
-	}
-
-	I915_WRITE(PIPEBCONF, dev_priv->savePIPEBCONF);
-
-	i915_restore_palette(dev, PIPE_B);
-	/* Enable the plane */
-	I915_WRITE(DSPBCNTR, dev_priv->saveDSPBCNTR);
-	I915_WRITE(DSPBBASE, I915_READ(DSPBBASE));
-
-	/* CRT state */
-	I915_WRITE(ADPA, dev_priv->saveADPA);
-
-	/* LVDS state */
-	if (IS_I965G(dev))
-		I915_WRITE(BLC_PWM_CTL2, dev_priv->saveBLC_PWM_CTL2);
-	if (IS_MOBILE(dev) && !IS_I830(dev))
-		I915_WRITE(LVDS, dev_priv->saveLVDS);
-	if (!IS_I830(dev) && !IS_845G(dev))
-		I915_WRITE(PFIT_CONTROL, dev_priv->savePFIT_CONTROL);
-
-	I915_WRITE(PFIT_PGM_RATIOS, dev_priv->savePFIT_PGM_RATIOS);
-	I915_WRITE(BLC_PWM_CTL, dev_priv->saveBLC_PWM_CTL);
-	I915_WRITE(LVDSPP_ON, dev_priv->saveLVDSPP_ON);
-	I915_WRITE(LVDSPP_OFF, dev_priv->saveLVDSPP_OFF);
-	I915_WRITE(PP_CYCLE, dev_priv->savePP_CYCLE);
-	I915_WRITE(PP_CONTROL, dev_priv->savePP_CONTROL);
-
-	/* FIXME: restore TV & SDVO state */
-
-	/* FBC info */
-	I915_WRITE(FBC_CFB_BASE, dev_priv->saveFBC_CFB_BASE);
-	I915_WRITE(FBC_LL_BASE, dev_priv->saveFBC_LL_BASE);
-	I915_WRITE(FBC_CONTROL2, dev_priv->saveFBC_CONTROL2);
-	I915_WRITE(FBC_CONTROL, dev_priv->saveFBC_CONTROL);
-
-	/* VGA state */
-	I915_WRITE(VGACNTRL, dev_priv->saveVGACNTRL);
-	I915_WRITE(VCLK_DIVISOR_VGA0, dev_priv->saveVCLK_DIVISOR_VGA0);
-	I915_WRITE(VCLK_DIVISOR_VGA1, dev_priv->saveVCLK_DIVISOR_VGA1);
-	I915_WRITE(VCLK_POST_DIV, dev_priv->saveVCLK_POST_DIV);
-	udelay(150);
-
-	/* Clock gating state */
-	I915_WRITE (D_STATE, dev_priv->saveD_STATE);
-	I915_WRITE (DSPCLK_GATE_D, dev_priv->saveDSPCLK_GATE_D);
-
-	/* Cache mode state */
-	I915_WRITE (CACHE_MODE_0, dev_priv->saveCACHE_MODE_0 | 0xffff0000);
-
-	/* Memory arbitration state */
-	I915_WRITE (MI_ARB_STATE, dev_priv->saveMI_ARB_STATE | 0xffff0000);
-
-	for (i = 0; i < 16; i++) {
-		I915_WRITE(SWF0 + (i << 2), dev_priv->saveSWF0[i]);
-		I915_WRITE(SWF10 + (i << 2), dev_priv->saveSWF1[i+7]);
-	}
-	for (i = 0; i < 3; i++)
-		I915_WRITE(SWF30 + (i << 2), dev_priv->saveSWF2[i]);
+	i915_restore_state(dev);
@@ -533 +79 @@
-	i915_restore_vga(dev);
+	intel_opregion_init(dev);
@@ -544,2 +90 @@
-	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_IRQ_VBL |
-	    DRIVER_IRQ_VBL2,
+	    DRIVER_HAVE_IRQ | DRIVER_IRQ_SHARED | DRIVER_GEM,
@@ -547,0 +93 @@
+	.open = i915_driver_open,
@@ -549,0 +96 @@
+	.postclose = i915_driver_postclose,
@@ -553,2 +100,3 @@
-	.vblank_wait = i915_driver_vblank_wait,
-	.vblank_wait2 = i915_driver_vblank_wait2,
+	.get_vblank_counter = i915_get_vblank_counter,
+	.enable_vblank = i915_enable_vblank,
+	.disable_vblank = i915_disable_vblank,
@@ -561,0 +110,4 @@
+	.proc_init = i915_gem_proc_init,
+	.proc_cleanup = i915_gem_proc_cleanup,
+	.gem_init_object = i915_gem_init_object,
+	.gem_free_object = i915_gem_free_object,
--- ./projects/linux/linux-2.6.28/drivers/gpu/drm/i915/i915_drv.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/gpu/drm/i915/i915_drv.c	2009-03-24 00:12:14.000000000 +0100
@@ -29,0 +30 @@
+#include <linux/device.h>
@@ -35,0 +37,7 @@
+#include <linux/console.h>
+
+static unsigned int i915_modeset = -1;
+module_param_named(modeset, i915_modeset, int, 0400);
+
+unsigned int i915_fbpercrtc = 0;
+module_param_named(fbpercrtc, i915_fbpercrtc, int, 0400);
@@ -40,0 +49,4 @@
+#if defined(CONFIG_DRM_I915_KMS)
+MODULE_DEVICE_TABLE(pci, pciidlist);
+#endif
+
@@ -57,0 +70,8 @@
+	/* If KMS is active, we do the leavevt stuff here */
+	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
+		if (i915_gem_idle(dev))
+			dev_err(&dev->pdev->dev,
+				"GEM idle failed, resume may fail\n");
+		drm_irq_uninstall(dev);
+	}
+
@@ -70,0 +91,3 @@
+	struct drm_i915_private *dev_priv = dev->dev_private;
+	int ret = 0;
+
@@ -81 +104,14 @@
-	return 0;
+	/* KMS EnterVT equivalent */
+	if (drm_core_check_feature(dev, DRIVER_MODESET)) {
+		mutex_lock(&dev->struct_mutex);
+		dev_priv->mm.suspended = 0;
+
+		ret = i915_gem_init_ringbuffer(dev);
+		if (ret != 0)
+			ret = -1;
+		mutex_unlock(&dev->struct_mutex);
+
+		drm_irq_install(dev);
+	}
+
+	return ret;
@@ -83,0 +120,6 @@
+static struct vm_operations_struct i915_gem_vm_ops = {
+	.fault = i915_gem_fault,
+	.open = drm_gem_vm_open,
+	.close = drm_gem_vm_close,
+};
+
@@ -100 +141,0 @@
-	.get_vblank_counter = i915_get_vblank_counter,
@@ -109,0 +151,2 @@
+	.master_create = i915_master_create,
+	.master_destroy = i915_master_destroy,
@@ -113,0 +157 @@
+	.gem_vm_ops = &i915_gem_vm_ops,
@@ -120 +164 @@
-		 .mmap = drm_mmap,
+		 .mmap = drm_gem_mmap,
@@ -143,0 +188,22 @@
+
+	/*
+	 * If CONFIG_DRM_I915_KMS is set, default to KMS unless
+	 * explicitly disabled with the module pararmeter.
+	 *
+	 * Otherwise, just follow the parameter (defaulting to off).
+	 *
+	 * Allow optional vga_text_mode_force boot option to override
+	 * the default behavior.
+	 */
+#if defined(CONFIG_DRM_I915_KMS)
+	if (i915_modeset != 0)
+		driver.driver_features |= DRIVER_MODESET;
+#endif
+	if (i915_modeset == 1)
+		driver.driver_features |= DRIVER_MODESET;
+
+#ifdef CONFIG_VGA_CONSOLE
+	if (vgacon_text_force() && i915_modeset == -1)
+		driver.driver_features &= ~DRIVER_MODESET;
+#endif
+
--- ./projects/linux/linux-2.6.29/drivers/gpu/drm/i915/i915_drv.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/gpu/drm/i915/i915_drv.c	2009-06-27 11:32:32.000000000 +0200
@@ -44,0 +45,2 @@
+static struct drm_driver driver;
+
@@ -78 +80 @@
-	intel_opregion_free(dev);
+	intel_opregion_free(dev, 1);
@@ -102 +104 @@
-	intel_opregion_init(dev);
+	intel_opregion_init(dev, 1);
@@ -119,0 +122,30 @@
+static int __devinit
+i915_pci_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
+{
+	return drm_get_dev(pdev, ent, &driver);
+}
+
+static void
+i915_pci_remove(struct pci_dev *pdev)
+{
+	struct drm_device *dev = pci_get_drvdata(pdev);
+
+	drm_put_dev(dev);
+}
+
+static int
+i915_pci_suspend(struct pci_dev *pdev, pm_message_t state)
+{
+	struct drm_device *dev = pci_get_drvdata(pdev);
+
+	return i915_suspend(dev, state);
+}
+
+static int
+i915_pci_resume(struct pci_dev *pdev)
+{
+	struct drm_device *dev = pci_get_drvdata(pdev);
+
+	return i915_resume(dev);
+}
+
@@ -153,2 +185,4 @@
-	.proc_init = i915_gem_proc_init,
-	.proc_cleanup = i915_gem_proc_cleanup,
+#if defined(CONFIG_DEBUG_FS)
+	.debugfs_init = i915_gem_debugfs_init,
+	.debugfs_cleanup = i915_gem_debugfs_cleanup,
+#endif
@@ -174,0 +209,6 @@
+		 .probe = i915_pci_probe,
+		 .remove = i915_pci_remove,
+#ifdef CONFIG_PM
+		 .resume = i915_pci_resume,
+		 .suspend = i915_pci_suspend,
+#endif
--- ./projects/linux/linux-2.6.20/drivers/hid/hid-core.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/hid/hid-core.c	2007-04-26 05:08:32.000000000 +0200
@@ -21 +20,0 @@
-#include <linux/sched.h>
@@ -30,3 +29 @@
-
-#undef DEBUG
-#undef DEBUG_DATA
+#include <linux/vmalloc.h>
@@ -35,0 +33 @@
+#include <linux/hid-debug.h>
@@ -660 +658 @@
-	if (!(parser = kzalloc(sizeof(struct hid_parser), GFP_KERNEL))) {
+	if (!(parser = vmalloc(sizeof(struct hid_parser)))) {
@@ -665,0 +664 @@
+	memset(parser, 0, sizeof(struct hid_parser));
@@ -673 +671,0 @@
-			kfree(device->collection);
@@ -675 +673 @@
-			kfree(parser);
+			vfree(parser);
@@ -682 +679,0 @@
-			kfree(device->collection);
@@ -684 +681 @@
-			kfree(parser);
+			vfree(parser);
@@ -691 +687,0 @@
-				kfree(device->collection);
@@ -693 +689 @@
-				kfree(parser);
+				vfree(parser);
@@ -698 +693,0 @@
-				kfree(device->collection);
@@ -700 +695 @@
-				kfree(parser);
+				vfree(parser);
@@ -703 +698 @@
-			kfree(parser);
+			vfree(parser);
@@ -709 +703,0 @@
-	kfree(device->collection);
@@ -711 +705 @@
-	kfree(parser);
+	vfree(parser);
@@ -764,2 +758 @@
-	x = get_unaligned((u64 *) report);
-	x = le64_to_cpu(x);
+	x = le64_to_cpu(get_unaligned((__le64 *) report));
@@ -780 +773 @@
-	u64 x;
+	__le64 x;
@@ -791 +784 @@
-	x = get_unaligned((u64 *)report);
+	x = get_unaligned((__le64 *)report);
@@ -794 +787 @@
-	put_unaligned(x, (u64 *) report);
+	put_unaligned(x, (__le64 *) report);
@@ -884,4 +876,0 @@
-	/* make sure the unused bits in the last byte are zeros */
-	if (count > 0 && size > 0)
-		data[(count*size-1)/8] = 0;
-
@@ -954 +943 @@
-#ifdef DEBUG_DATA
+#ifdef CONFIG_HID_DEBUG
@@ -964 +953 @@
-#ifdef DEBUG_DATA
+#ifdef CONFIG_HID_DEBUG
@@ -983 +972 @@
-		return -1;
+		memset(data + size, 0, rsize - size);
--- ./projects/linux/linux-2.6.21/drivers/hid/hid-core.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/hid/hid-core.c	2007-07-09 01:32:17.000000000 +0200
@@ -7 +7 @@
- *  Copyright (c) 2006 Jiri Kosina
+ *  Copyright (c) 2006-2007 Jiri Kosina
@@ -23 +22,0 @@
-#include <linux/smp_lock.h>
@@ -40 +39 @@
-#define DRIVER_AUTHOR "Andreas Gal, Vojtech Pavlik"
+#define DRIVER_AUTHOR "Andreas Gal, Vojtech Pavlik, Jiri Kosina"
@@ -874,0 +874 @@
+	unsigned bitsused = offset + count * size;
@@ -876,0 +877,4 @@
+	/* make sure the unused bits in the last byte are zeros */
+	if (count > 0 && size > 0 && (bitsused % 8) != 0)
+		data[(bitsused-1)/8] &= (1 << (bitsused % 8)) - 1;
+
--- ./projects/linux/linux-2.6.22/drivers/hid/hid-core.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/hid/hid-core.c	2007-10-09 22:31:38.000000000 +0200
@@ -42,0 +43,7 @@
+#ifdef CONFIG_HID_DEBUG
+int hid_debug = 0;
+module_param_named(debug, hid_debug, bool, 0600);
+MODULE_PARM_DESC(debug, "Turn HID debugging mode on and off");
+EXPORT_SYMBOL_GPL(hid_debug);
+#endif
+
@@ -81 +88 @@
-		dbg("too many fields in report");
+		dbg_hid("too many fields in report\n");
@@ -109 +116 @@
-		dbg("collection stack overflow");
+		dbg_hid("collection stack overflow\n");
@@ -117 +124 @@
-			dbg("failed to reallocate collection array");
+			dbg_hid("failed to reallocate collection array\n");
@@ -153 +160 @@
-		dbg("collection stack underflow");
+		dbg_hid("collection stack underflow\n");
@@ -181 +188 @@
-		dbg("usage index exceeded");
+		dbg_hid("usage index exceeded\n");
@@ -205 +212 @@
-		dbg("hid_register_report failed");
+		dbg_hid("hid_register_report failed\n");
@@ -210 +217 @@
-		dbg("logical range invalid %d %d", parser->global.logical_minimum, parser->global.logical_maximum);
+		dbg_hid("logical range invalid %d %d\n", parser->global.logical_minimum, parser->global.logical_maximum);
@@ -290 +297 @@
-				dbg("global enviroment stack overflow");
+				dbg_hid("global enviroment stack overflow\n");
@@ -301 +308 @@
-				dbg("global enviroment stack underflow");
+				dbg_hid("global enviroment stack underflow\n");
@@ -345 +352 @@
-				dbg("invalid report_size %d", parser->global.report_size);
+				dbg_hid("invalid report_size %d\n", parser->global.report_size);
@@ -352 +359 @@
-				dbg("invalid report_count %d", parser->global.report_count);
+				dbg_hid("invalid report_count %d\n", parser->global.report_count);
@@ -359 +366 @@
-				dbg("report_id 0 is invalid");
+				dbg_hid("report_id 0 is invalid\n");
@@ -365 +372 @@
-			dbg("unknown global tag 0x%x", item->tag);
+			dbg_hid("unknown global tag 0x%x\n", item->tag);
@@ -380 +387 @@
-		dbg("item data expected for local item");
+		dbg_hid("item data expected for local item\n");
@@ -398 +405 @@
-					dbg("nested delimiters");
+					dbg_hid("nested delimiters\n");
@@ -405 +412 @@
-					dbg("bogus close delimiter");
+					dbg_hid("bogus close delimiter\n");
@@ -415 +422 @@
-				dbg("alternative usage ignored");
+				dbg_hid("alternative usage ignored\n");
@@ -427 +434 @@
-				dbg("alternative usage ignored");
+				dbg_hid("alternative usage ignored\n");
@@ -440 +447 @@
-				dbg("alternative usage ignored");
+				dbg_hid("alternative usage ignored\n");
@@ -449 +456 @@
-					dbg("hid_add_usage failed\n");
+					dbg_hid("hid_add_usage failed\n");
@@ -456 +463 @@
-			dbg("unknown local item tag 0x%x", item->tag);
+			dbg_hid("unknown local item tag 0x%x\n", item->tag);
@@ -490 +497 @@
-			dbg("unknown main item tag 0x%x", item->tag);
+			dbg_hid("unknown main item tag 0x%x\n", item->tag);
@@ -505 +512 @@
-	dbg("reserved item type, tag 0x%x", item->tag);
+	dbg_hid("reserved item type, tag 0x%x\n", item->tag);
@@ -670 +677 @@
-			dbg("unexpected long global item");
+			dbg_hid("unexpected long global item\n");
@@ -677 +684 @@
-			dbg("item %u %u %u %u parsing failed\n",
+			dbg_hid("item %u %u %u %u parsing failed\n",
@@ -686 +693 @@
-				dbg("unbalanced collection at end of report description");
+				dbg_hid("unbalanced collection at end of report description\n");
@@ -692 +699 @@
-				dbg("unbalanced delimiter at end of report description");
+				dbg_hid("unbalanced delimiter at end of report description\n");
@@ -702 +709 @@
-	dbg("item fetching failed at offset %d\n", (int)(end - start));
+	dbg_hid("item fetching failed at offset %d\n", (int)(end - start));
@@ -918 +925 @@
-		dbg("offset (%d) exceeds report_count (%d)", offset, field->report_count);
+		dbg_hid("offset (%d) exceeds report_count (%d)\n", offset, field->report_count);
@@ -924 +931 @@
-			dbg("value %d is out of range", value);
+			dbg_hid("value %d is out of range\n", value);
@@ -937 +944 @@
-	int n, rsize;
+	int n, rsize, i;
@@ -943 +950 @@
-		dbg("empty report");
+		dbg_hid("empty report\n");
@@ -947,3 +954 @@
-#ifdef CONFIG_HID_DEBUG
-	printk(KERN_DEBUG __FILE__ ": report (size %u) (%snumbered)\n", size, report_enum->numbered ? "" : "un");
-#endif
+	dbg_hid("report (size %u) (%snumbered)\n", size, report_enum->numbered ? "" : "un");
@@ -957,9 +962,5 @@
-#ifdef CONFIG_HID_DEBUG
-	{
-		int i;
-		printk(KERN_DEBUG __FILE__ ": report %d (size %u) = ", n, size);
-		for (i = 0; i < size; i++)
-			printk(" %02x", data[i]);
-		printk("\n");
-	}
-#endif
+	/* dump the report descriptor */
+	dbg_hid("report %d (size %u) = ", n, size);
+	for (i = 0; i < size; i++)
+		dbg_hid_line(" %02x", data[i]);
+	dbg_hid_line("\n");
@@ -968 +969 @@
-		dbg("undefined report_id %d received", n);
+		dbg_hid("undefined report_id %d received\n", n);
@@ -975 +976 @@
-		dbg("report %d is too short, (%d < %d)", report->id, size, rsize);
+		dbg_hid("report %d is too short, (%d < %d)\n", report->id, size, rsize);
--- ./projects/linux/linux-2.6.23/drivers/hid/hid-core.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/hid/hid-core.c	2008-01-24 23:58:37.000000000 +0100
@@ -32,0 +33 @@
+#include <linux/hidraw.h>
@@ -981,0 +983,2 @@
+	if (hid->claimed & HID_CLAIMED_HIDRAW)
+		hidraw_report_event(hid, data, size);
@@ -992,0 +996,13 @@
+static int __init hid_init(void)
+{
+	return hidraw_init();
+}
+
+static void __exit hid_exit(void)
+{
+	hidraw_exit();
+}
+
+module_init(hid_init);
+module_exit(hid_exit);
+
--- ./projects/linux/linux-2.6.24/drivers/hid/hid-core.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/hid/hid-core.c	2008-04-17 04:49:44.000000000 +0200
@@ -28,0 +29 @@
+#include <linux/sched.h>
@@ -761 +762,3 @@
-	WARN_ON(n > 32);
+	if (n > 32)
+		printk(KERN_WARNING "HID: extract() called with n (%d) > 32! (%s)\n",
+				n, current->comm);
@@ -783,2 +786,7 @@
-	WARN_ON(n > 32);
-
+	if (n > 32)
+		printk(KERN_WARNING "HID: implement() called with n (%d) > 32! (%s)\n",
+				n, current->comm);
+
+	if (value > m)
+		printk(KERN_WARNING "HID: implement() called with too large value %d! (%s)\n",
+				value, current->comm);
@@ -963 +971 @@
-	/* dump the report descriptor */
+	/* dump the report */
--- ./projects/linux/linux-2.6.25/drivers/hid/hid-core.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/hid/hid-core.c	2008-07-13 23:51:29.000000000 +0200
@@ -47,2 +47,2 @@
-module_param_named(debug, hid_debug, bool, 0600);
-MODULE_PARM_DESC(debug, "Turn HID debugging mode on and off");
+module_param_named(debug, hid_debug, int, 0600);
+MODULE_PARM_DESC(debug, "HID debugging (0=off, 1=probing info, 2=continuous data dumping)");
@@ -100 +100 @@
-	field->value = (unsigned *)(field->usage + usages);
+	field->value = (s32 *)(field->usage + usages);
@@ -609 +609 @@
-			item->data.u16 = le16_to_cpu(get_unaligned((__le16*)start));
+			item->data.u16 = get_unaligned_le16(start);
@@ -617 +617 @@
-			item->data.u32 = le32_to_cpu(get_unaligned((__le32*)start));
+			item->data.u32 = get_unaligned_le32(start);
@@ -768 +768 @@
-	x = le64_to_cpu(get_unaligned((__le64 *) report));
+	x = get_unaligned_le64(report);
@@ -833 +833,2 @@
-void hid_input_field(struct hid_device *hid, struct hid_field *field, __u8 *data, int interrupt)
+static void hid_input_field(struct hid_device *hid, struct hid_field *field,
+			    __u8 *data, int interrupt)
@@ -879 +879,0 @@
-EXPORT_SYMBOL_GPL(hid_input_field);
@@ -991,2 +991,7 @@
-	if (hid->claimed & HID_CLAIMED_HIDRAW)
-		hidraw_report_event(hid, data, size);
+	if (hid->claimed & HID_CLAIMED_HIDRAW) {
+		/* numbered reports need to be passed with the report num */
+		if (report_enum->numbered)
+			hidraw_report_event(hid, data - 1, size + 1);
+		else
+			hidraw_report_event(hid, data, size);
+	}
--- ./projects/linux/linux-2.6.26/drivers/hid/hid-core.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/hid/hid-core.c	2008-10-10 00:13:53.000000000 +0200
@@ -783 +783 @@
-	__le64 x;
+	u64 x;
@@ -799,4 +799,4 @@
-	x = get_unaligned((__le64 *)report);
-	x &= cpu_to_le64(~(m << offset));
-	x |= cpu_to_le64(((u64) value) << offset);
-	put_unaligned(x, (__le64 *) report);
+	x = get_unaligned_le64(report);
+	x &= ~(m << offset);
+	x |= ((u64)value) << offset;
+	put_unaligned_le64(x, report);
--- ./projects/linux/linux-2.6.27/drivers/hid/hid-core.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/hid/hid-core.c	2008-12-25 00:26:37.000000000 +0100
@@ -35,0 +36,2 @@
+#include "hid-ids.h"
+
@@ -271,3 +273,3 @@
-		case 1: return item->data.u8;
-		case 2: return item->data.u16;
-		case 4: return item->data.u32;
+	case 1: return item->data.u8;
+	case 2: return item->data.u16;
+	case 4: return item->data.u32;
@@ -281,3 +283,3 @@
-		case 1: return item->data.s8;
-		case 2: return item->data.s16;
-		case 4: return item->data.s32;
+	case 1: return item->data.s8;
+	case 2: return item->data.s16;
+	case 4: return item->data.s32;
@@ -294,0 +297 @@
+	case HID_GLOBAL_ITEM_TAG_PUSH:
@@ -296,10 +299,4 @@
-		case HID_GLOBAL_ITEM_TAG_PUSH:
-
-			if (parser->global_stack_ptr == HID_GLOBAL_STACK_SIZE) {
-				dbg_hid("global enviroment stack overflow\n");
-				return -1;
-			}
-
-			memcpy(parser->global_stack + parser->global_stack_ptr++,
-				&parser->global, sizeof(struct hid_global));
-			return 0;
+		if (parser->global_stack_ptr == HID_GLOBAL_STACK_SIZE) {
+			dbg_hid("global enviroment stack overflow\n");
+			return -1;
+		}
@@ -307 +304,3 @@
-		case HID_GLOBAL_ITEM_TAG_POP:
+		memcpy(parser->global_stack + parser->global_stack_ptr++,
+			&parser->global, sizeof(struct hid_global));
+		return 0;
@@ -309,4 +308 @@
-			if (!parser->global_stack_ptr) {
-				dbg_hid("global enviroment stack underflow\n");
-				return -1;
-			}
+	case HID_GLOBAL_ITEM_TAG_POP:
@@ -314,3 +310,4 @@
-			memcpy(&parser->global, parser->global_stack + --parser->global_stack_ptr,
-				sizeof(struct hid_global));
-			return 0;
+		if (!parser->global_stack_ptr) {
+			dbg_hid("global enviroment stack underflow\n");
+			return -1;
+		}
@@ -318,3 +315,3 @@
-		case HID_GLOBAL_ITEM_TAG_USAGE_PAGE:
-			parser->global.usage_page = item_udata(item);
-			return 0;
+		memcpy(&parser->global, parser->global_stack +
+			--parser->global_stack_ptr, sizeof(struct hid_global));
+		return 0;
@@ -322,3 +319,3 @@
-		case HID_GLOBAL_ITEM_TAG_LOGICAL_MINIMUM:
-			parser->global.logical_minimum = item_sdata(item);
-			return 0;
+	case HID_GLOBAL_ITEM_TAG_USAGE_PAGE:
+		parser->global.usage_page = item_udata(item);
+		return 0;
@@ -326,6 +323,3 @@
-		case HID_GLOBAL_ITEM_TAG_LOGICAL_MAXIMUM:
-			if (parser->global.logical_minimum < 0)
-				parser->global.logical_maximum = item_sdata(item);
-			else
-				parser->global.logical_maximum = item_udata(item);
-			return 0;
+	case HID_GLOBAL_ITEM_TAG_LOGICAL_MINIMUM:
+		parser->global.logical_minimum = item_sdata(item);
+		return 0;
@@ -333,3 +327,6 @@
-		case HID_GLOBAL_ITEM_TAG_PHYSICAL_MINIMUM:
-			parser->global.physical_minimum = item_sdata(item);
-			return 0;
+	case HID_GLOBAL_ITEM_TAG_LOGICAL_MAXIMUM:
+		if (parser->global.logical_minimum < 0)
+			parser->global.logical_maximum = item_sdata(item);
+		else
+			parser->global.logical_maximum = item_udata(item);
+		return 0;
@@ -337,6 +334,3 @@
-		case HID_GLOBAL_ITEM_TAG_PHYSICAL_MAXIMUM:
-			if (parser->global.physical_minimum < 0)
-				parser->global.physical_maximum = item_sdata(item);
-			else
-				parser->global.physical_maximum = item_udata(item);
-			return 0;
+	case HID_GLOBAL_ITEM_TAG_PHYSICAL_MINIMUM:
+		parser->global.physical_minimum = item_sdata(item);
+		return 0;
@@ -344,3 +338,6 @@
-		case HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT:
-			parser->global.unit_exponent = item_sdata(item);
-			return 0;
+	case HID_GLOBAL_ITEM_TAG_PHYSICAL_MAXIMUM:
+		if (parser->global.physical_minimum < 0)
+			parser->global.physical_maximum = item_sdata(item);
+		else
+			parser->global.physical_maximum = item_udata(item);
+		return 0;
@@ -348,3 +345,3 @@
-		case HID_GLOBAL_ITEM_TAG_UNIT:
-			parser->global.unit = item_udata(item);
-			return 0;
+	case HID_GLOBAL_ITEM_TAG_UNIT_EXPONENT:
+		parser->global.unit_exponent = item_sdata(item);
+		return 0;
@@ -352,6 +349,3 @@
-		case HID_GLOBAL_ITEM_TAG_REPORT_SIZE:
-			if ((parser->global.report_size = item_udata(item)) > 32) {
-				dbg_hid("invalid report_size %d\n", parser->global.report_size);
-				return -1;
-			}
-			return 0;
+	case HID_GLOBAL_ITEM_TAG_UNIT:
+		parser->global.unit = item_udata(item);
+		return 0;
@@ -359,6 +353,8 @@
-		case HID_GLOBAL_ITEM_TAG_REPORT_COUNT:
-			if ((parser->global.report_count = item_udata(item)) > HID_MAX_USAGES) {
-				dbg_hid("invalid report_count %d\n", parser->global.report_count);
-				return -1;
-			}
-			return 0;
+	case HID_GLOBAL_ITEM_TAG_REPORT_SIZE:
+		parser->global.report_size = item_udata(item);
+		if (parser->global.report_size > 32) {
+			dbg_hid("invalid report_size %d\n",
+					parser->global.report_size);
+			return -1;
+		}
+		return 0;
@@ -366,6 +362,8 @@
-		case HID_GLOBAL_ITEM_TAG_REPORT_ID:
-			if ((parser->global.report_id = item_udata(item)) == 0) {
-				dbg_hid("report_id 0 is invalid\n");
-				return -1;
-			}
-			return 0;
+	case HID_GLOBAL_ITEM_TAG_REPORT_COUNT:
+		parser->global.report_count = item_udata(item);
+		if (parser->global.report_count > HID_MAX_USAGES) {
+			dbg_hid("invalid report_count %d\n",
+					parser->global.report_count);
+			return -1;
+		}
+		return 0;
@@ -373,2 +371,4 @@
-		default:
-			dbg_hid("unknown global tag 0x%x\n", item->tag);
+	case HID_GLOBAL_ITEM_TAG_REPORT_ID:
+		parser->global.report_id = item_udata(item);
+		if (parser->global.report_id == 0) {
+			dbg_hid("report_id 0 is invalid\n");
@@ -375,0 +376,6 @@
+		}
+		return 0;
+
+	default:
+		dbg_hid("unknown global tag 0x%x\n", item->tag);
+		return -1;
@@ -395,0 +402 @@
+	case HID_LOCAL_ITEM_TAG_DELIMITER:
@@ -397,21 +404,10 @@
-		case HID_LOCAL_ITEM_TAG_DELIMITER:
-
-			if (data) {
-				/*
-				 * We treat items before the first delimiter
-				 * as global to all usage sets (branch 0).
-				 * In the moment we process only these global
-				 * items and the first delimiter set.
-				 */
-				if (parser->local.delimiter_depth != 0) {
-					dbg_hid("nested delimiters\n");
-					return -1;
-				}
-				parser->local.delimiter_depth++;
-				parser->local.delimiter_branch++;
-			} else {
-				if (parser->local.delimiter_depth < 1) {
-					dbg_hid("bogus close delimiter\n");
-					return -1;
-				}
-				parser->local.delimiter_depth--;
+		if (data) {
+			/*
+			 * We treat items before the first delimiter
+			 * as global to all usage sets (branch 0).
+			 * In the moment we process only these global
+			 * items and the first delimiter set.
+			 */
+			if (parser->local.delimiter_depth != 0) {
+				dbg_hid("nested delimiters\n");
+				return -1;
@@ -419,7 +415,6 @@
-			return 1;
-
-		case HID_LOCAL_ITEM_TAG_USAGE:
-
-			if (parser->local.delimiter_branch > 1) {
-				dbg_hid("alternative usage ignored\n");
-				return 0;
+			parser->local.delimiter_depth++;
+			parser->local.delimiter_branch++;
+		} else {
+			if (parser->local.delimiter_depth < 1) {
+				dbg_hid("bogus close delimiter\n");
+				return -1;
@@ -426,0 +422,3 @@
+			parser->local.delimiter_depth--;
+		}
+		return 1;
@@ -428,2 +426 @@
-			if (item->size <= 2)
-				data = (parser->global.usage_page << 16) + data;
+	case HID_LOCAL_ITEM_TAG_USAGE:
@@ -431 +428,4 @@
-			return hid_add_usage(parser, data);
+		if (parser->local.delimiter_branch > 1) {
+			dbg_hid("alternative usage ignored\n");
+			return 0;
+		}
@@ -433 +433,2 @@
-		case HID_LOCAL_ITEM_TAG_USAGE_MINIMUM:
+		if (item->size <= 2)
+			data = (parser->global.usage_page << 16) + data;
@@ -435,4 +436 @@
-			if (parser->local.delimiter_branch > 1) {
-				dbg_hid("alternative usage ignored\n");
-				return 0;
-			}
+		return hid_add_usage(parser, data);
@@ -440,2 +438 @@
-			if (item->size <= 2)
-				data = (parser->global.usage_page << 16) + data;
+	case HID_LOCAL_ITEM_TAG_USAGE_MINIMUM:
@@ -443 +440,2 @@
-			parser->local.usage_minimum = data;
+		if (parser->local.delimiter_branch > 1) {
+			dbg_hid("alternative usage ignored\n");
@@ -444,0 +443 @@
+		}
@@ -446 +445,2 @@
-		case HID_LOCAL_ITEM_TAG_USAGE_MAXIMUM:
+		if (item->size <= 2)
+			data = (parser->global.usage_page << 16) + data;
@@ -448,4 +448,2 @@
-			if (parser->local.delimiter_branch > 1) {
-				dbg_hid("alternative usage ignored\n");
-				return 0;
-			}
+		parser->local.usage_minimum = data;
+		return 0;
@@ -453,2 +451 @@
-			if (item->size <= 2)
-				data = (parser->global.usage_page << 16) + data;
+	case HID_LOCAL_ITEM_TAG_USAGE_MAXIMUM:
@@ -456,5 +453,2 @@
-			for (n = parser->local.usage_minimum; n <= data; n++)
-				if (hid_add_usage(parser, n)) {
-					dbg_hid("hid_add_usage failed\n");
-					return -1;
-				}
+		if (parser->local.delimiter_branch > 1) {
+			dbg_hid("alternative usage ignored\n");
@@ -461,0 +456 @@
+		}
@@ -463 +458,2 @@
-		default:
+		if (item->size <= 2)
+			data = (parser->global.usage_page << 16) + data;
@@ -465,2 +461,11 @@
-			dbg_hid("unknown local item tag 0x%x\n", item->tag);
-			return 0;
+		for (n = parser->local.usage_minimum; n <= data; n++)
+			if (hid_add_usage(parser, n)) {
+				dbg_hid("hid_add_usage failed\n");
+				return -1;
+			}
+		return 0;
+
+	default:
+
+		dbg_hid("unknown local item tag 0x%x\n", item->tag);
+		return 0;
@@ -483,18 +488,18 @@
-		case HID_MAIN_ITEM_TAG_BEGIN_COLLECTION:
-			ret = open_collection(parser, data & 0xff);
-			break;
-		case HID_MAIN_ITEM_TAG_END_COLLECTION:
-			ret = close_collection(parser);
-			break;
-		case HID_MAIN_ITEM_TAG_INPUT:
-			ret = hid_add_field(parser, HID_INPUT_REPORT, data);
-			break;
-		case HID_MAIN_ITEM_TAG_OUTPUT:
-			ret = hid_add_field(parser, HID_OUTPUT_REPORT, data);
-			break;
-		case HID_MAIN_ITEM_TAG_FEATURE:
-			ret = hid_add_field(parser, HID_FEATURE_REPORT, data);
-			break;
-		default:
-			dbg_hid("unknown main item tag 0x%x\n", item->tag);
-			ret = 0;
+	case HID_MAIN_ITEM_TAG_BEGIN_COLLECTION:
+		ret = open_collection(parser, data & 0xff);
+		break;
+	case HID_MAIN_ITEM_TAG_END_COLLECTION:
+		ret = close_collection(parser);
+		break;
+	case HID_MAIN_ITEM_TAG_INPUT:
+		ret = hid_add_field(parser, HID_INPUT_REPORT, data);
+		break;
+	case HID_MAIN_ITEM_TAG_OUTPUT:
+		ret = hid_add_field(parser, HID_OUTPUT_REPORT, data);
+		break;
+	case HID_MAIN_ITEM_TAG_FEATURE:
+		ret = hid_add_field(parser, HID_FEATURE_REPORT, data);
+		break;
+	default:
+		dbg_hid("unknown main item tag 0x%x\n", item->tag);
+		ret = 0;
@@ -537 +542 @@
-void hid_free_device(struct hid_device *device)
+static void hid_device_release(struct device *dev)
@@ -539 +544,2 @@
-	unsigned i,j;
+	struct hid_device *device = container_of(dev, struct hid_device, dev);
+	unsigned i, j;
@@ -555 +560,0 @@
-EXPORT_SYMBOL_GPL(hid_free_device);
@@ -595,0 +601,2 @@
+	case 0:
+		return start;
@@ -597,2 +604,12 @@
-		case 0:
-			return start;
+	case 1:
+		if ((end - start) < 1)
+			return NULL;
+		item->data.u8 = *start++;
+		return start;
+
+	case 2:
+		if ((end - start) < 2)
+			return NULL;
+		item->data.u16 = get_unaligned_le16(start);
+		start = (__u8 *)((__le16 *)start + 1);
+		return start;
@@ -600,20 +617,7 @@
-		case 1:
-			if ((end - start) < 1)
-				return NULL;
-			item->data.u8 = *start++;
-			return start;
-
-		case 2:
-			if ((end - start) < 2)
-				return NULL;
-			item->data.u16 = get_unaligned_le16(start);
-			start = (__u8 *)((__le16 *)start + 1);
-			return start;
-
-		case 3:
-			item->size++;
-			if ((end - start) < 4)
-				return NULL;
-			item->data.u32 = get_unaligned_le32(start);
-			start = (__u8 *)((__le32 *)start + 1);
-			return start;
+	case 3:
+		item->size++;
+		if ((end - start) < 4)
+			return NULL;
+		item->data.u32 = get_unaligned_le32(start);
+		start = (__u8 *)((__le32 *)start + 1);
+		return start;
@@ -625 +629,7 @@
-/*
+/**
+ * hid_parse_report - parse device report
+ *
+ * @device: hid device
+ * @start: report start
+ * @size: report size
+ *
@@ -627,0 +638 @@
+ * 0 returned on success, otherwise nonzero error value.
@@ -629,2 +640,2 @@
-
-struct hid_device *hid_parse_report(__u8 *start, unsigned size)
+int hid_parse_report(struct hid_device *device, __u8 *start,
+		unsigned size)
@@ -632 +642,0 @@
-	struct hid_device *device;
@@ -636 +646 @@
-	unsigned i;
+	int ret;
@@ -645,2 +655,2 @@
-	if (!(device = kzalloc(sizeof(struct hid_device), GFP_KERNEL)))
-		return NULL;
+	if (device->driver->report_fixup)
+		device->driver->report_fixup(device, start, size);
@@ -648,15 +658,3 @@
-	if (!(device->collection = kzalloc(sizeof(struct hid_collection) *
-				   HID_DEFAULT_NUM_COLLECTIONS, GFP_KERNEL))) {
-		kfree(device);
-		return NULL;
-	}
-	device->collection_size = HID_DEFAULT_NUM_COLLECTIONS;
-
-	for (i = 0; i < HID_REPORT_TYPES; i++)
-		INIT_LIST_HEAD(&device->report_enum[i].report_list);
-
-	if (!(device->rdesc = kmalloc(size, GFP_KERNEL))) {
-		kfree(device->collection);
-		kfree(device);
-		return NULL;
-	}
+	device->rdesc = kmalloc(size, GFP_KERNEL);
+	if (device->rdesc == NULL)
+		return -ENOMEM;
@@ -666,5 +664,4 @@
-	if (!(parser = vmalloc(sizeof(struct hid_parser)))) {
-		kfree(device->rdesc);
-		kfree(device->collection);
-		kfree(device);
-		return NULL;
+	parser = vmalloc(sizeof(struct hid_parser));
+	if (!parser) {
+		ret = -ENOMEM;
+		goto err;
@@ -671,0 +669 @@
+
@@ -675,0 +674 @@
+	ret = -EINVAL;
@@ -680,3 +679 @@
-			hid_free_device(device);
-			vfree(parser);
-			return NULL;
+			goto err;
@@ -688,3 +685 @@
-			hid_free_device(device);
-			vfree(parser);
-			return NULL;
+			goto err;
@@ -696,3 +691 @@
-				hid_free_device(device);
-				vfree(parser);
-				return NULL;
+				goto err;
@@ -702,3 +695 @@
-				hid_free_device(device);
-				vfree(parser);
-				return NULL;
+				goto err;
@@ -707 +698 @@
-			return device;
+			return 0;
@@ -712 +703 @@
-	hid_free_device(device);
+err:
@@ -714 +705 @@
-	return NULL;
+	return ret;
@@ -727,3 +718,3 @@
-		case 8:  return ((__s8)value);
-		case 16: return ((__s16)value);
-		case 32: return ((__s32)value);
+	case 8:  return ((__s8)value);
+	case 16: return ((__s16)value);
+	case 32: return ((__s32)value);
@@ -818 +809,51 @@
-static void hid_process_event(struct hid_device *hid, struct hid_field *field, struct hid_usage *usage, __s32 value, int interrupt)
+/**
+ * hid_match_report - check if driver's raw_event should be called
+ *
+ * @hid: hid device
+ * @report_type: type to match against
+ *
+ * compare hid->driver->report_table->report_type to report->type
+ */
+static int hid_match_report(struct hid_device *hid, struct hid_report *report)
+{
+	const struct hid_report_id *id = hid->driver->report_table;
+
+	if (!id) /* NULL means all */
+		return 1;
+
+	for (; id->report_type != HID_TERMINATOR; id++)
+		if (id->report_type == HID_ANY_ID ||
+				id->report_type == report->type)
+			return 1;
+	return 0;
+}
+
+/**
+ * hid_match_usage - check if driver's event should be called
+ *
+ * @hid: hid device
+ * @usage: usage to match against
+ *
+ * compare hid->driver->usage_table->usage_{type,code} to
+ * usage->usage_{type,code}
+ */
+static int hid_match_usage(struct hid_device *hid, struct hid_usage *usage)
+{
+	const struct hid_usage_id *id = hid->driver->usage_table;
+
+	if (!id) /* NULL means all */
+		return 1;
+
+	for (; id->usage_type != HID_ANY_ID - 1; id++)
+		if ((id->usage_hid == HID_ANY_ID ||
+				id->usage_hid == usage->hid) &&
+				(id->usage_type == HID_ANY_ID ||
+				id->usage_type == usage->type) &&
+				(id->usage_code == HID_ANY_ID ||
+				 id->usage_code == usage->code))
+			return 1;
+	return 0;
+}
+
+static void hid_process_event(struct hid_device *hid, struct hid_field *field,
+		struct hid_usage *usage, __s32 value, int interrupt)
@@ -819,0 +861,3 @@
+	struct hid_driver *hdrv = hid->driver;
+	int ret;
+
@@ -820,0 +865,11 @@
+
+	if (hdrv && hdrv->event && hid_match_usage(hid, usage)) {
+		ret = hdrv->event(hid, field, usage, value);
+		if (ret != 0) {
+			if (ret < 0)
+				dbg_hid("%s's event failed with %d\n",
+						hdrv->name, ret);
+			return;
+		}
+	}
+
@@ -948,0 +1004,72 @@
+static struct hid_report *hid_get_report(struct hid_report_enum *report_enum,
+		const u8 *data)
+{
+	struct hid_report *report;
+	unsigned int n = 0;	/* Normally report number is 0 */
+
+	/* Device uses numbered reports, data[0] is report number */
+	if (report_enum->numbered)
+		n = *data;
+
+	report = report_enum->report_id_hash[n];
+	if (report == NULL)
+		dbg_hid("undefined report_id %u received\n", n);
+
+	return report;
+}
+
+void hid_report_raw_event(struct hid_device *hid, int type, u8 *data, int size,
+		int interrupt)
+{
+	struct hid_report_enum *report_enum = hid->report_enum + type;
+	struct hid_report *report;
+	unsigned int a;
+	int rsize, csize = size;
+	u8 *cdata = data;
+
+	report = hid_get_report(report_enum, data);
+	if (!report)
+		return;
+
+	if (report_enum->numbered) {
+		cdata++;
+		csize--;
+	}
+
+	rsize = ((report->size - 1) >> 3) + 1;
+
+	if (csize < rsize) {
+		dbg_hid("report %d is too short, (%d < %d)\n", report->id,
+				csize, rsize);
+		memset(cdata + csize, 0, rsize - csize);
+	}
+
+	if ((hid->claimed & HID_CLAIMED_HIDDEV) && hid->hiddev_report_event)
+		hid->hiddev_report_event(hid, report);
+	if (hid->claimed & HID_CLAIMED_HIDRAW) {
+		/* numbered reports need to be passed with the report num */
+		if (report_enum->numbered)
+			hidraw_report_event(hid, data - 1, size + 1);
+		else
+			hidraw_report_event(hid, data, size);
+	}
+
+	for (a = 0; a < report->maxfield; a++)
+		hid_input_field(hid, report->field[a], cdata, interrupt);
+
+	if (hid->claimed & HID_CLAIMED_INPUT)
+		hidinput_report_event(hid, report);
+}
+EXPORT_SYMBOL_GPL(hid_report_raw_event);
+
+/**
+ * hid_input_report - report data from lower layer (usb, bt...)
+ *
+ * @hid: hid device
+ * @type: HID report type (HID_*_REPORT)
+ * @data: report contents
+ * @size: size of data parameter
+ * @interrupt: called from atomic?
+ *
+ * This is data entry for lower layers.
+ */
@@ -951,0 +1079 @@
+	struct hid_driver *hdrv = hid->driver;
@@ -953 +1081,2 @@
-	int n, rsize, i;
+	unsigned int i;
+	int ret;
@@ -955 +1084 @@
-	if (!hid)
+	if (!hid || !hid->driver)
@@ -965,5 +1094,3 @@
-	n = 0;                          /* Normally report number is 0 */
-	if (report_enum->numbered) {    /* Device uses numbered reports, data[0] is report number */
-		n = *data++;
-		size--;
-	}
+	report = hid_get_report(report_enum, data);
+	if (!report)
+		return -1;
@@ -972 +1099 @@
-	dbg_hid("report %d (size %u) = ", n, size);
+	dbg_hid("report %d (size %u) = ", report->id, size);
@@ -977,3 +1104,4 @@
-	if (!(report = report_enum->report_id_hash[n])) {
-		dbg_hid("undefined report_id %d received\n", n);
-		return -1;
+	if (hdrv && hdrv->raw_event && hid_match_report(hid, report)) {
+		ret = hdrv->raw_event(hid, report, data, size);
+		if (ret != 0)
+			return ret < 0 ? ret : 0;
@@ -982 +1110,34 @@
-	rsize = ((report->size - 1) >> 3) + 1;
+	hid_report_raw_event(hid, type, data, size, interrupt);
+
+	return 0;
+}
+EXPORT_SYMBOL_GPL(hid_input_report);
+
+static bool hid_match_one_id(struct hid_device *hdev,
+		const struct hid_device_id *id)
+{
+	return id->bus == hdev->bus &&
+		(id->vendor == HID_ANY_ID || id->vendor == hdev->vendor) &&
+		(id->product == HID_ANY_ID || id->product == hdev->product);
+}
+
+static const struct hid_device_id *hid_match_id(struct hid_device *hdev,
+		const struct hid_device_id *id)
+{
+	for (; id->bus; id++)
+		if (hid_match_one_id(hdev, id))
+			return id;
+
+	return NULL;
+}
+
+static const struct hid_device_id hid_hiddev_list[] = {
+	{ HID_USB_DEVICE(USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_MGE, USB_DEVICE_ID_MGE_UPS1) },
+	{ }
+};
+
+static bool hid_hiddev(struct hid_device *hdev)
+{
+	return !!hid_match_id(hdev, hid_hiddev_list);
+}
@@ -984,3 +1145,30 @@
-	if (size < rsize) {
-		dbg_hid("report %d is too short, (%d < %d)\n", report->id, size, rsize);
-		memset(data + size, 0, rsize - size);
+int hid_connect(struct hid_device *hdev, unsigned int connect_mask)
+{
+	static const char *types[] = { "Device", "Pointer", "Mouse", "Device",
+		"Joystick", "Gamepad", "Keyboard", "Keypad",
+		"Multi-Axis Controller"
+	};
+	const char *type, *bus;
+	char buf[64];
+	unsigned int i;
+	int len;
+
+	if (hdev->bus != BUS_USB)
+		connect_mask &= ~HID_CONNECT_HIDDEV;
+	if (hid_hiddev(hdev))
+		connect_mask |= HID_CONNECT_HIDDEV_FORCE;
+
+	if ((connect_mask & HID_CONNECT_HIDINPUT) && !hidinput_connect(hdev,
+				connect_mask & HID_CONNECT_HIDINPUT_FORCE))
+		hdev->claimed |= HID_CLAIMED_INPUT;
+	if ((connect_mask & HID_CONNECT_HIDDEV) && hdev->hiddev_connect &&
+			!hdev->hiddev_connect(hdev,
+				connect_mask & HID_CONNECT_HIDDEV_FORCE))
+		hdev->claimed |= HID_CLAIMED_HIDDEV;
+	if ((connect_mask & HID_CONNECT_HIDRAW) && !hidraw_connect(hdev))
+		hdev->claimed |= HID_CLAIMED_HIDRAW;
+
+	if (!hdev->claimed) {
+		dev_err(&hdev->dev, "claimed by neither input, hiddev nor "
+				"hidraw\n");
+		return -ENODEV;
@@ -989,8 +1177,23 @@
-	if ((hid->claimed & HID_CLAIMED_HIDDEV) && hid->hiddev_report_event)
-		hid->hiddev_report_event(hid, report);
-	if (hid->claimed & HID_CLAIMED_HIDRAW) {
-		/* numbered reports need to be passed with the report num */
-		if (report_enum->numbered)
-			hidraw_report_event(hid, data - 1, size + 1);
-		else
-			hidraw_report_event(hid, data, size);
+	if ((hdev->claimed & HID_CLAIMED_INPUT) &&
+			(connect_mask & HID_CONNECT_FF) && hdev->ff_init)
+		hdev->ff_init(hdev);
+
+	len = 0;
+	if (hdev->claimed & HID_CLAIMED_INPUT)
+		len += sprintf(buf + len, "input");
+	if (hdev->claimed & HID_CLAIMED_HIDDEV)
+		len += sprintf(buf + len, "%shiddev%d", len ? "," : "",
+				hdev->minor);
+	if (hdev->claimed & HID_CLAIMED_HIDRAW)
+		len += sprintf(buf + len, "%shidraw%d", len ? "," : "",
+				((struct hidraw *)hdev->hidraw)->minor);
+
+	type = "Device";
+	for (i = 0; i < hdev->maxcollection; i++) {
+		struct hid_collection *col = &hdev->collection[i];
+		if (col->type == HID_COLLECTION_APPLICATION &&
+		   (col->usage & HID_USAGE_PAGE) == HID_UP_GENDESK &&
+		   (col->usage & 0xffff) < ARRAY_SIZE(types)) {
+			type = types[col->usage & 0xffff];
+			break;
+		}
@@ -999,2 +1202,10 @@
-	for (n = 0; n < report->maxfield; n++)
-		hid_input_field(hid, report->field[n], data, interrupt);
+	switch (hdev->bus) {
+	case BUS_USB:
+		bus = "USB";
+		break;
+	case BUS_BLUETOOTH:
+		bus = "BLUETOOTH";
+		break;
+	default:
+		bus = "<UNKNOWN>";
+	}
@@ -1002,2 +1213,3 @@
-	if (hid->claimed & HID_CLAIMED_INPUT)
-		hidinput_report_event(hid, report);
+	dev_info(&hdev->dev, "%s: %s HID v%x.%02x %s [%s] on %s\n",
+			buf, bus, hdev->version >> 8, hdev->version & 0xff,
+			type, hdev->name, hdev->phys);
@@ -1007 +1219,502 @@
-EXPORT_SYMBOL_GPL(hid_input_report);
+EXPORT_SYMBOL_GPL(hid_connect);
+
+static const struct hid_device_id hid_blacklist[] = {
+	{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_WCP32PU) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_A4TECH, USB_DEVICE_ID_A4TECH_X5_005D) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_ATV_IRCONTROL) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_IRCONTROL4) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_MIGHTYMOUSE) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_ANSI) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_FOUNTAIN_ISO) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ANSI) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_ISO) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER_JIS) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ANSI) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_ISO) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DEVICE_ID_APPLE_GEYSER3_JIS) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_APPLE, USB_DE