--- ./projects/linux/linux-2.6.24/arch/arm/mach-pxa/mfp.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/arm/mach-pxa/mfp.c	2008-04-17 04:49:44.000000000 +0200
@@ -19,0 +20 @@
+#include <linux/sysdev.h>
@@ -22,0 +24,2 @@
+#include <asm/arch/mfp-pxa3xx.h>
+#include <asm/arch/pxa3xx-regs.h>
@@ -30,0 +34,8 @@
+
+struct pxa3xx_mfp_pin {
+	unsigned long	config;		/* -1 for not configured */
+	unsigned long	mfpr_off;	/* MFPRxx Register offset */
+	unsigned long	mfpr_run;	/* Run-Mode Register Value */
+	unsigned long	mfpr_lpm;	/* Low Power Mode Register Value */
+};
+
@@ -32,0 +44,26 @@
+/* mapping of MFP_LPM_* definitions to MFPR_LPM_* register bits */
+const static unsigned long mfpr_lpm[] = {
+	MFPR_LPM_INPUT,
+	MFPR_LPM_DRIVE_LOW,
+	MFPR_LPM_DRIVE_HIGH,
+	MFPR_LPM_PULL_LOW,
+	MFPR_LPM_PULL_HIGH,
+	MFPR_LPM_FLOAT,
+};
+
+/* mapping of MFP_PULL_* definitions to MFPR_PULL_* register bits */
+const static unsigned long mfpr_pull[] = {
+	MFPR_PULL_NONE,
+	MFPR_PULL_LOW,
+	MFPR_PULL_HIGH,
+	MFPR_PULL_BOTH,
+};
+
+/* mapping of MFP_LPM_EDGE_* definitions to MFPR_EDGE_* register bits */
+const static unsigned long mfpr_edge[] = {
+	MFPR_EDGE_NONE,
+	MFPR_EDGE_RISE,
+	MFPR_EDGE_FALL,
+	MFPR_EDGE_BOTH,
+};
+
@@ -38,0 +76,2 @@
+#define mfp_configured(p)	((p)->config != -1)
+
@@ -45 +84 @@
-static inline void __mfp_config(int pin, unsigned long val)
+static inline void __mfp_config_run(struct pxa3xx_mfp_pin *p)
@@ -47 +86,3 @@
-	unsigned long off = mfp_table[pin].mfpr_off;
+	if (mfp_configured(p))
+		mfpr_writel(p->mfpr_off, p->mfpr_run);
+}
@@ -49,2 +90,9 @@
-	mfp_table[pin].mfpr_val = val;
-	mfpr_writel(off, val);
+static inline void __mfp_config_lpm(struct pxa3xx_mfp_pin *p)
+{
+	if (mfp_configured(p)) {
+		unsigned long mfpr_clr = (p->mfpr_run & ~MFPR_EDGE_BOTH) | MFPR_EDGE_CLEAR;
+		if (mfpr_clr != p->mfpr_run)
+			mfpr_writel(p->mfpr_off, mfpr_clr);
+		if (p->mfpr_lpm != mfpr_clr)
+			mfpr_writel(p->mfpr_off, p->mfpr_lpm);
+	}
@@ -53 +101 @@
-void pxa3xx_mfp_config(mfp_cfg_t *mfp_cfgs, int num)
+void pxa3xx_mfp_config(unsigned long *mfp_cfgs, int num)
@@ -55,3 +103,2 @@
-	int i, pin;
-	unsigned long val, flags;
-	mfp_cfg_t *mfp_cfg = mfp_cfgs;
+	unsigned long flags;
+	int i;
@@ -61,3 +108,4 @@
-	for (i = 0; i < num; i++, mfp_cfg++) {
-		pin = MFP_CFG_PIN(*mfp_cfg);
-		val = MFP_CFG_VAL(*mfp_cfg);
+	for (i = 0; i < num; i++, mfp_cfgs++) {
+		unsigned long tmp, c = *mfp_cfgs;
+		struct pxa3xx_mfp_pin *p;
+		int pin, af, drv, lpm, edge, pull;
@@ -64,0 +113 @@
+		pin = MFP_PIN(c);
@@ -65,0 +115,21 @@
+		p = &mfp_table[pin];
+
+		af  = MFP_AF(c);
+		drv = MFP_DS(c);
+		lpm = MFP_LPM_STATE(c);
+		edge = MFP_LPM_EDGE(c);
+		pull = MFP_PULL(c);
+
+		/* run-mode pull settings will conflict with MFPR bits of
+		 * low power mode state,  calculate mfpr_run and mfpr_lpm
+		 * individually if pull != MFP_PULL_NONE
+		 */
+		tmp = MFPR_AF_SEL(af) | MFPR_DRIVE(drv);
+
+		if (likely(pull == MFP_PULL_NONE)) {
+			p->mfpr_run = tmp | mfpr_lpm[lpm] | mfpr_edge[edge];
+			p->mfpr_lpm = p->mfpr_run;
+		} else {
+			p->mfpr_lpm = tmp | mfpr_lpm[lpm] | mfpr_edge[edge];
+			p->mfpr_run = tmp | mfpr_pull[pull];
+		}
@@ -67 +137 @@
-		__mfp_config(pin, val);
+		p->config = c; __mfp_config_run(p);
@@ -99,111 +168,0 @@
-void pxa3xx_mfp_set_afds(int mfp, int af, int ds)
-{
-	uint32_t mfpr_off, mfpr_val;
-	unsigned long flags;
-
-	BUG_ON(mfp >= MFP_PIN_MAX);
-
-	spin_lock_irqsave(&mfp_spin_lock, flags);
-	mfpr_off = mfp_table[mfp].mfpr_off;
-
-	mfpr_val = mfpr_readl(mfpr_off);
-	mfpr_val &= ~(MFPR_AF_MASK | MFPR_DRV_MASK);
-	mfpr_val |= (((af & 0x7) << MFPR_ALT_OFFSET) |
-		     ((ds & 0x7) << MFPR_DRV_OFFSET));
-
-	mfpr_writel(mfpr_off, mfpr_val);
-	mfpr_sync();
-
-	spin_unlock_irqrestore(&mfp_spin_lock, flags);
-}
-
-void pxa3xx_mfp_set_rdh(int mfp, int rdh)
-{
-	uint32_t mfpr_off, mfpr_val;
-	unsigned long flags;
-
-	BUG_ON(mfp >= MFP_PIN_MAX);
-
-	spin_lock_irqsave(&mfp_spin_lock, flags);
-
-	mfpr_off = mfp_table[mfp].mfpr_off;
-
-	mfpr_val = mfpr_readl(mfpr_off);
-	mfpr_val &= ~MFPR_RDH_MASK;
-
-	if (likely(rdh))
-		mfpr_val |= (1u << MFPR_SS_OFFSET);
-
-	mfpr_writel(mfpr_off, mfpr_val);
-	mfpr_sync();
-
-	spin_unlock_irqrestore(&mfp_spin_lock, flags);
-}
-
-void pxa3xx_mfp_set_lpm(int mfp, int lpm)
-{
-	uint32_t mfpr_off, mfpr_val;
-	unsigned long flags;
-
-	BUG_ON(mfp >= MFP_PIN_MAX);
-
-	spin_lock_irqsave(&mfp_spin_lock, flags);
-
-	mfpr_off = mfp_table[mfp].mfpr_off;
-	mfpr_val = mfpr_readl(mfpr_off);
-	mfpr_val &= ~MFPR_LPM_MASK;
-
-	if (lpm & 0x1) mfpr_val |= 1u << MFPR_SON_OFFSET;
-	if (lpm & 0x2) mfpr_val |= 1u << MFPR_SD_OFFSET;
-	if (lpm & 0x4) mfpr_val |= 1u << MFPR_PU_OFFSET;
-	if (lpm & 0x8) mfpr_val |= 1u << MFPR_PD_OFFSET;
-	if (lpm &0x10) mfpr_val |= 1u << MFPR_PS_OFFSET;
-
-	mfpr_writel(mfpr_off, mfpr_val);
-	mfpr_sync();
-
-	spin_unlock_irqrestore(&mfp_spin_lock, flags);
-}
-
-void pxa3xx_mfp_set_pull(int mfp, int pull)
-{
-	uint32_t mfpr_off, mfpr_val;
-	unsigned long flags;
-
-	BUG_ON(mfp >= MFP_PIN_MAX);
-
-	spin_lock_irqsave(&mfp_spin_lock, flags);
-
-	mfpr_off = mfp_table[mfp].mfpr_off;
-	mfpr_val = mfpr_readl(mfpr_off);
-	mfpr_val &= ~MFPR_PULL_MASK;
-	mfpr_val |= ((pull & 0x7u) << MFPR_PD_OFFSET);
-
-	mfpr_writel(mfpr_off, mfpr_val);
-	mfpr_sync();
-
-	spin_unlock_irqrestore(&mfp_spin_lock, flags);
-}
-
-void pxa3xx_mfp_set_edge(int mfp, int edge)
-{
-	uint32_t mfpr_off, mfpr_val;
-	unsigned long flags;
-
-	BUG_ON(mfp >= MFP_PIN_MAX);
-
-	spin_lock_irqsave(&mfp_spin_lock, flags);
-
-	mfpr_off = mfp_table[mfp].mfpr_off;
-	mfpr_val = mfpr_readl(mfpr_off);
-
-	mfpr_val &= ~MFPR_EDGE_MASK;
-	mfpr_val |= (edge & 0x3u) << MFPR_ERE_OFFSET;
-	mfpr_val |= (!edge & 0x1) << MFPR_EC_OFFSET;
-
-	mfpr_writel(mfpr_off, mfpr_val);
-	mfpr_sync();
-
-	spin_unlock_irqrestore(&mfp_spin_lock, flags);
-}
-
@@ -224 +183,2 @@
-			mfp_table[i].mfpr_val = 0;
+			mfp_table[i].mfpr_run = 0;
+			mfp_table[i].mfpr_lpm = 0;
@@ -234 +194,59 @@
-	memset(mfp_table, 0, sizeof(mfp_table));
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(mfp_table); i++)
+		mfp_table[i].config = -1;
+}
+
+#ifdef CONFIG_PM
+/*
+ * Configure the MFPs appropriately for suspend/resume.
+ * FIXME: this should probably depend on which system state we're
+ * entering - for instance, we might not want to place MFP pins in
+ * a pull-down mode if they're an active low chip select, and we're
+ * just entering standby.
+ */
+static int pxa3xx_mfp_suspend(struct sys_device *d, pm_message_t state)
+{
+	int pin;
+
+	for (pin = 0; pin < ARRAY_SIZE(mfp_table); pin++) {
+		struct pxa3xx_mfp_pin *p = &mfp_table[pin];
+		__mfp_config_lpm(p);
+	}
+	return 0;
+}
+
+static int pxa3xx_mfp_resume(struct sys_device *d)
+{
+	int pin;
+
+	for (pin = 0; pin < ARRAY_SIZE(mfp_table); pin++) {
+		struct pxa3xx_mfp_pin *p = &mfp_table[pin];
+		__mfp_config_run(p);
+	}
+
+	/* clear RDH bit when MFP settings are restored
+	 *
+	 * NOTE: the last 3 bits DxS are write-1-to-clear so carefully
+	 * preserve them here in case they will be referenced later
+	 */
+	ASCR &= ~(ASCR_RDH | ASCR_D1S | ASCR_D2S | ASCR_D3S);
+
+	return 0;
+}
+
+static struct sysdev_class mfp_sysclass = {
+	.name		= "mfp",
+	.suspend	= pxa3xx_mfp_suspend,
+	.resume 	= pxa3xx_mfp_resume,
+};
+
+static struct sys_device mfp_device = {
+	.id		= 0,
+	.cls		= &mfp_sysclass,
+};
+
+static int __init mfp_init_devicefs(void)
+{
+	sysdev_class_register(&mfp_sysclass);
+	return sysdev_register(&mfp_device);
@@ -235,0 +254,2 @@
+device_initcall(mfp_init_devicefs);
+#endif
--- ./projects/linux/linux-2.6.13/arch/ia64/kernel/acpi.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/arch/ia64/kernel/acpi.c	2005-10-28 02:02:08.000000000 +0200
@@ -77,2 +77,2 @@
-u16 ia64_acpiid_to_sapicid[MAX_SAPICS] =
-	{ [0 ... MAX_SAPICS - 1] = -1 };
+u16 ia64_acpiid_to_sapicid[MAX_SAPICS] = {[0 ... MAX_SAPICS - 1] = -1 };
+
@@ -81,2 +81 @@
-const char *
-acpi_get_sysname (void)
+const char *acpi_get_sysname(void)
@@ -92 +91,2 @@
-		printk(KERN_ERR "ACPI 2.0 RSDP not found, default to \"dig\"\n");
+		printk(KERN_ERR
+		       "ACPI 2.0 RSDP not found, default to \"dig\"\n");
@@ -96 +96 @@
-	rsdp = (struct acpi20_table_rsdp *) __va(rsdp_phys);
+	rsdp = (struct acpi20_table_rsdp *)__va(rsdp_phys);
@@ -98 +98,2 @@
-		printk(KERN_ERR "ACPI 2.0 RSDP signature incorrect, default to \"dig\"\n");
+		printk(KERN_ERR
+		       "ACPI 2.0 RSDP signature incorrect, default to \"dig\"\n");
@@ -102 +103 @@
-	xsdt = (struct acpi_table_xsdt *) __va(rsdp->xsdt_address);
+	xsdt = (struct acpi_table_xsdt *)__va(rsdp->xsdt_address);
@@ -105 +106,2 @@
-		printk(KERN_ERR "ACPI 2.0 XSDT signature incorrect, default to \"dig\"\n");
+		printk(KERN_ERR
+		       "ACPI 2.0 XSDT signature incorrect, default to \"dig\"\n");
@@ -111,2 +113 @@
-	}
-	else if (!strcmp(hdr->oem_id, "SGI")) {
+	} else if (!strcmp(hdr->oem_id, "SGI")) {
@@ -134 +135 @@
-#ifdef CONFIG_ACPI_BOOT
+#ifdef CONFIG_ACPI
@@ -149,2 +150 @@
-int
-acpi_request_vector (u32 int_type)
+int acpi_request_vector(u32 int_type)
@@ -158 +158,2 @@
-		printk(KERN_ERR "acpi_request_vector(): invalid interrupt type\n");
+		printk(KERN_ERR
+		       "acpi_request_vector(): invalid interrupt type\n");
@@ -162,2 +163 @@
-char *
-__acpi_map_table (unsigned long phys_addr, unsigned long size)
+char *__acpi_map_table(unsigned long phys_addr, unsigned long size)
@@ -172,5 +172,4 @@
-static int			total_cpus __initdata;
-static int			available_cpus __initdata;
-struct acpi_table_madt *	acpi_madt __initdata;
-static u8			has_8259;
-
+static int total_cpus __initdata;
+static int available_cpus __initdata;
+struct acpi_table_madt *acpi_madt __initdata;
+static u8 has_8259;
@@ -179,2 +178,2 @@
-acpi_parse_lapic_addr_ovr (
-	acpi_table_entry_header *header, const unsigned long end)
+acpi_parse_lapic_addr_ovr(acpi_table_entry_header * header,
+			  const unsigned long end)
@@ -184 +183 @@
-	lapic = (struct acpi_table_lapic_addr_ovr *) header;
+	lapic = (struct acpi_table_lapic_addr_ovr *)header;
@@ -196 +194,0 @@
-
@@ -198 +196 @@
-acpi_parse_lsapic (acpi_table_entry_header *header, const unsigned long end)
+acpi_parse_lsapic(acpi_table_entry_header * header, const unsigned long end)
@@ -202 +200 @@
-	lsapic = (struct acpi_table_lsapic *) header;
+	lsapic = (struct acpi_table_lsapic *)header;
@@ -209 +207,2 @@
-		smp_boot_data.cpu_phys_id[available_cpus] = (lsapic->id << 8) | lsapic->eid;
+		smp_boot_data.cpu_phys_id[available_cpus] =
+		    (lsapic->id << 8) | lsapic->eid;
@@ -211 +210,2 @@
-		ia64_acpiid_to_sapicid[lsapic->acpi_id] = (lsapic->id << 8) | lsapic->eid;
+		ia64_acpiid_to_sapicid[lsapic->acpi_id] =
+		    (lsapic->id << 8) | lsapic->eid;
@@ -219 +218,0 @@
-
@@ -221 +220 @@
-acpi_parse_lapic_nmi (acpi_table_entry_header *header, const unsigned long end)
+acpi_parse_lapic_nmi(acpi_table_entry_header * header, const unsigned long end)
@@ -225 +224 @@
-	lacpi_nmi = (struct acpi_table_lapic_nmi*) header;
+	lacpi_nmi = (struct acpi_table_lapic_nmi *)header;
@@ -234 +232,0 @@
-
@@ -236 +234 @@
-acpi_parse_iosapic (acpi_table_entry_header *header, const unsigned long end)
+acpi_parse_iosapic(acpi_table_entry_header * header, const unsigned long end)
@@ -240 +238 @@
-	iosapic = (struct acpi_table_iosapic *) header;
+	iosapic = (struct acpi_table_iosapic *)header;
@@ -248 +245,0 @@
-
@@ -250,2 +247,2 @@
-acpi_parse_plat_int_src (
-	acpi_table_entry_header *header, const unsigned long end)
+acpi_parse_plat_int_src(acpi_table_entry_header * header,
+			const unsigned long end)
@@ -256 +253 @@
-	plintsrc = (struct acpi_table_plat_int_src *) header;
+	plintsrc = (struct acpi_table_plat_int_src *)header;
@@ -270,2 +267,6 @@
-						(plintsrc->flags.polarity == 1) ? IOSAPIC_POL_HIGH : IOSAPIC_POL_LOW,
-						(plintsrc->flags.trigger == 1) ? IOSAPIC_EDGE : IOSAPIC_LEVEL);
+						(plintsrc->flags.polarity ==
+						 1) ? IOSAPIC_POL_HIGH :
+						IOSAPIC_POL_LOW,
+						(plintsrc->flags.trigger ==
+						 1) ? IOSAPIC_EDGE :
+						IOSAPIC_LEVEL);
@@ -286 +286,0 @@
-
@@ -325,2 +325,2 @@
-acpi_parse_int_src_ovr (
-	acpi_table_entry_header *header, const unsigned long end)
+acpi_parse_int_src_ovr(acpi_table_entry_header * header,
+		       const unsigned long end)
@@ -330 +330 @@
-	p = (struct acpi_table_int_src_ovr *) header;
+	p = (struct acpi_table_int_src_ovr *)header;
@@ -336,2 +336,4 @@
-				 (p->flags.polarity == 1) ? IOSAPIC_POL_HIGH : IOSAPIC_POL_LOW,
-				 (p->flags.trigger == 1) ? IOSAPIC_EDGE : IOSAPIC_LEVEL);
+				 (p->flags.polarity ==
+				  1) ? IOSAPIC_POL_HIGH : IOSAPIC_POL_LOW,
+				 (p->flags.trigger ==
+				  1) ? IOSAPIC_EDGE : IOSAPIC_LEVEL);
@@ -341 +342,0 @@
-
@@ -343 +344 @@
-acpi_parse_nmi_src (acpi_table_entry_header *header, const unsigned long end)
+acpi_parse_nmi_src(acpi_table_entry_header * header, const unsigned long end)
@@ -347 +348 @@
-	nmi_src = (struct acpi_table_nmi_src*) header;
+	nmi_src = (struct acpi_table_nmi_src *)header;
@@ -356,2 +357 @@
-static void __init
-acpi_madt_oem_check (char *oem_id, char *oem_table_id)
+static void __init acpi_madt_oem_check(char *oem_id, char *oem_table_id)
@@ -359,2 +359 @@
-	if (!strncmp(oem_id, "IBM", 3) &&
-	    (!strncmp(oem_table_id, "SERMOW", 6))) {
+	if (!strncmp(oem_id, "IBM", 3) && (!strncmp(oem_table_id, "SERMOW", 6))) {
@@ -373,2 +372 @@
-static int __init
-acpi_parse_madt (unsigned long phys_addr, unsigned long size)
+static int __init acpi_parse_madt(unsigned long phys_addr, unsigned long size)
@@ -379 +377 @@
-	acpi_madt = (struct acpi_table_madt *) __va(phys_addr);
+	acpi_madt = (struct acpi_table_madt *)__va(phys_addr);
@@ -385 +383 @@
-	has_8259 = 1; /* Firmware on old Itanium systems is broken */
+	has_8259 = 1;		/* Firmware on old Itanium systems is broken */
@@ -399 +397 @@
-		acpi_madt->header.oem_table_id);
+			    acpi_madt->header.oem_table_id);
@@ -404 +401,0 @@
-
@@ -411 +408 @@
-static int __initdata srat_num_cpus;			/* number of cpus */
+static int __initdata srat_num_cpus;	/* number of cpus */
@@ -424,2 +421 @@
-void __init
-acpi_numa_slit_init (struct acpi_table_slit *slit)
+void __init acpi_numa_slit_init(struct acpi_table_slit *slit)
@@ -430 +426 @@
-		+ slit->localities * slit->localities;
+	    + slit->localities * slit->localities;
@@ -432 +428,2 @@
-		printk(KERN_ERR "ACPI 2.0 SLIT: size mismatch: %d expected, %d actual\n",
+		printk(KERN_ERR
+		       "ACPI 2.0 SLIT: size mismatch: %d expected, %d actual\n",
@@ -441 +438 @@
-acpi_numa_processor_affinity_init (struct acpi_table_processor_affinity *pa)
+acpi_numa_processor_affinity_init(struct acpi_table_processor_affinity *pa)
@@ -446 +443,2 @@
-	node_cpuid[srat_num_cpus].phys_id = (pa->apic_id << 8) | (pa->lsapic_eid);
+	node_cpuid[srat_num_cpus].phys_id =
+	    (pa->apic_id << 8) | (pa->lsapic_eid);
@@ -453 +451 @@
-acpi_numa_memory_affinity_init (struct acpi_table_memory_affinity *ma)
+acpi_numa_memory_affinity_init(struct acpi_table_memory_affinity *ma)
@@ -490,2 +488 @@
-void __init
-acpi_numa_arch_fixup (void)
+void __init acpi_numa_arch_fixup(void)
@@ -537,2 +534,4 @@
-	printk(KERN_INFO "Number of logical nodes in system = %d\n", num_online_nodes());
-	printk(KERN_INFO "Number of memory chunks in system = %d\n", num_node_memblks);
+	printk(KERN_INFO "Number of logical nodes in system = %d\n",
+	       num_online_nodes());
+	printk(KERN_INFO "Number of memory chunks in system = %d\n",
+	       num_node_memblks);
@@ -540 +539,2 @@
-	if (!slit_table) return;
+	if (!slit_table)
+		return;
@@ -542 +542 @@
-	for (i=0; i<slit_table->localities; i++) {
+	for (i = 0; i < slit_table->localities; i++) {
@@ -546 +546 @@
-		for (j=0; j<slit_table->localities; j++) {
+		for (j = 0; j < slit_table->localities; j++) {
@@ -551 +551 @@
-				slit_table->entry[i*slit_table->localities + j];
+			    slit_table->entry[i * slit_table->localities + j];
@@ -559 +559 @@
-			printk("%03d ", node_distance(i,j));
+		    printk("%03d ", node_distance(i, j));
@@ -564 +564 @@
-#endif /* CONFIG_ACPI_NUMA */
+#endif				/* CONFIG_ACPI_NUMA */
@@ -566,2 +566,5 @@
-unsigned int
-acpi_register_gsi (u32 gsi, int edge_level, int active_high_low)
+/*
+ * success: return IRQ number (>=0)
+ * failure: return < 0
+ */
+int acpi_register_gsi(u32 gsi, int edge_level, int active_high_low)
@@ -573,2 +576,6 @@
-			(active_high_low == ACPI_ACTIVE_HIGH) ? IOSAPIC_POL_HIGH : IOSAPIC_POL_LOW,
-			(edge_level == ACPI_EDGE_SENSITIVE) ? IOSAPIC_EDGE : IOSAPIC_LEVEL);
+				     (active_high_low ==
+				      ACPI_ACTIVE_HIGH) ? IOSAPIC_POL_HIGH :
+				     IOSAPIC_POL_LOW,
+				     (edge_level ==
+				      ACPI_EDGE_SENSITIVE) ? IOSAPIC_EDGE :
+				     IOSAPIC_LEVEL);
@@ -575,0 +583 @@
+
@@ -578,3 +586 @@
-#ifdef CONFIG_ACPI_DEALLOCATE_IRQ
-void
-acpi_unregister_gsi (u32 gsi)
+void acpi_unregister_gsi(u32 gsi)
@@ -583,0 +590 @@
+
@@ -585 +591,0 @@
-#endif /* CONFIG_ACPI_DEALLOCATE_IRQ */
@@ -587,2 +593 @@
-static int __init
-acpi_parse_fadt (unsigned long phys_addr, unsigned long size)
+static int __init acpi_parse_fadt(unsigned long phys_addr, unsigned long size)
@@ -596 +601 @@
-	fadt_header = (struct acpi_table_header *) __va(phys_addr);
+	fadt_header = (struct acpi_table_header *)__va(phys_addr);
@@ -598 +603 @@
-		return -ENODEV;		/* Only deal with ACPI 2.0 FADT */
+		return -ENODEV;	/* Only deal with ACPI 2.0 FADT */
@@ -600 +605 @@
-	fadt = (struct fadt_descriptor_rev2 *) fadt_header;
+	fadt = (struct fadt_descriptor_rev2 *)fadt_header;
@@ -612,3 +617 @@
-
-unsigned long __init
-acpi_find_rsdp (void)
+unsigned long __init acpi_find_rsdp(void)
@@ -621 +624,2 @@
-		printk(KERN_WARNING PREFIX "v1.0/r0.71 tables no longer supported\n");
+		printk(KERN_WARNING PREFIX
+		       "v1.0/r0.71 tables no longer supported\n");
@@ -625,3 +629 @@
-
-int __init
-acpi_boot_init (void)
+int __init acpi_boot_init(void)
@@ -645,2 +647,9 @@
-	if (acpi_table_parse_madt(ACPI_MADT_LAPIC_ADDR_OVR, acpi_parse_lapic_addr_ovr, 0) < 0)
-		printk(KERN_ERR PREFIX "Error parsing LAPIC address override entry\n");
+	if (acpi_table_parse_madt
+	    (ACPI_MADT_LAPIC_ADDR_OVR, acpi_parse_lapic_addr_ovr, 0) < 0)
+		printk(KERN_ERR PREFIX
+		       "Error parsing LAPIC address override entry\n");
+
+	if (acpi_table_parse_madt(ACPI_MADT_LSAPIC, acpi_parse_lsapic, NR_CPUS)
+	    < 1)
+		printk(KERN_ERR PREFIX
+		       "Error parsing MADT - no LAPIC entries\n");
@@ -648,4 +657,2 @@
-	if (acpi_table_parse_madt(ACPI_MADT_LSAPIC, acpi_parse_lsapic, NR_CPUS) < 1)
-		printk(KERN_ERR PREFIX "Error parsing MADT - no LAPIC entries\n");
-
-	if (acpi_table_parse_madt(ACPI_MADT_LAPIC_NMI, acpi_parse_lapic_nmi, 0) < 0)
+	if (acpi_table_parse_madt(ACPI_MADT_LAPIC_NMI, acpi_parse_lapic_nmi, 0)
+	    < 0)
@@ -656,2 +663,4 @@
-	if (acpi_table_parse_madt(ACPI_MADT_IOSAPIC, acpi_parse_iosapic, NR_IOSAPICS) < 1)
-		printk(KERN_ERR PREFIX "Error parsing MADT - no IOSAPIC entries\n");
+	if (acpi_table_parse_madt
+	    (ACPI_MADT_IOSAPIC, acpi_parse_iosapic, NR_IOSAPICS) < 1)
+		printk(KERN_ERR PREFIX
+		       "Error parsing MADT - no IOSAPIC entries\n");
@@ -661,5 +670,10 @@
-	if (acpi_table_parse_madt(ACPI_MADT_PLAT_INT_SRC, acpi_parse_plat_int_src, ACPI_MAX_PLATFORM_INTERRUPTS) < 0)
-		printk(KERN_ERR PREFIX "Error parsing platform interrupt source entry\n");
-
-	if (acpi_table_parse_madt(ACPI_MADT_INT_SRC_OVR, acpi_parse_int_src_ovr, 0) < 0)
-		printk(KERN_ERR PREFIX "Error parsing interrupt source overrides entry\n");
+	if (acpi_table_parse_madt
+	    (ACPI_MADT_PLAT_INT_SRC, acpi_parse_plat_int_src,
+	     ACPI_MAX_PLATFORM_INTERRUPTS) < 0)
+		printk(KERN_ERR PREFIX
+		       "Error parsing platform interrupt source entry\n");
+
+	if (acpi_table_parse_madt
+	    (ACPI_MADT_INT_SRC_OVR, acpi_parse_int_src_ovr, 0) < 0)
+		printk(KERN_ERR PREFIX
+		       "Error parsing interrupt source overrides entry\n");
@@ -669 +683 @@
-  skip_madt:
+      skip_madt:
@@ -684,2 +698,3 @@
-		smp_boot_data.cpu_phys_id[available_cpus] = hard_smp_processor_id();
-		available_cpus = 1; /* We've got at least one of these, no? */
+		smp_boot_data.cpu_phys_id[available_cpus] =
+		    hard_smp_processor_id();
+		available_cpus = 1;	/* We've got at least one of these, no? */
@@ -694,2 +709,4 @@
-			if (smp_boot_data.cpu_phys_id[cpu] != hard_smp_processor_id())
-				node_cpuid[i++].phys_id = smp_boot_data.cpu_phys_id[cpu];
+			if (smp_boot_data.cpu_phys_id[cpu] !=
+			    hard_smp_processor_id())
+				node_cpuid[i++].phys_id =
+				    smp_boot_data.cpu_phys_id[cpu];
@@ -703 +720,2 @@
-	printk(KERN_INFO "%d CPUs available, %d CPUs total\n", available_cpus, total_cpus);
+	printk(KERN_INFO "%d CPUs available, %d CPUs total\n", available_cpus,
+	       total_cpus);
@@ -707,2 +725 @@
-int
-acpi_gsi_to_irq (u32 gsi, unsigned int *irq)
+int acpi_gsi_to_irq(u32 gsi, unsigned int *irq)
@@ -729,2 +746 @@
-int
-acpi_map_cpu2node(acpi_handle handle, int cpu, long physid)
+int acpi_map_cpu2node(acpi_handle handle, int cpu, long physid)
@@ -733 +749 @@
-	int 			pxm_id;
+	int pxm_id;
@@ -741,2 +757 @@
-	node_cpuid[cpu].nid = (pxm_id < 0) ? 0:
-			pxm_to_nid_map[pxm_id];
+	node_cpuid[cpu].nid = (pxm_id < 0) ? 0 : pxm_to_nid_map[pxm_id];
@@ -744 +759 @@
-	node_cpuid[cpu].phys_id =  physid;
+	node_cpuid[cpu].phys_id = physid;
@@ -746 +761 @@
-	return(0);
+	return (0);
@@ -749,3 +764 @@
-
-int
-acpi_map_lsapic(acpi_handle handle, int *pcpu)
+int acpi_map_lsapic(acpi_handle handle, int *pcpu)
@@ -753 +766 @@
-	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
@@ -759 +772 @@
- 
+
@@ -763 +776 @@
-	if (!buffer.length ||  !buffer.pointer)
+	if (!buffer.length || !buffer.pointer)
@@ -765 +778 @@
- 
+
@@ -781 +794 @@
-	physid = ((lsapic->id <<8) | (lsapic->eid));
+	physid = ((lsapic->id << 8) | (lsapic->eid));
@@ -789 +802 @@
-	if(cpu >= NR_CPUS)
+	if (cpu >= NR_CPUS)
@@ -794 +807 @@
- 	cpu_set(cpu, cpu_present_map);
+	cpu_set(cpu, cpu_present_map);
@@ -799 +812 @@
-	return(0);
+	return (0);
@@ -801 +813,0 @@
-EXPORT_SYMBOL(acpi_map_lsapic);
@@ -802,0 +815 @@
+EXPORT_SYMBOL(acpi_map_lsapic);
@@ -804,2 +817 @@
-int
-acpi_unmap_lsapic(int cpu)
+int acpi_unmap_lsapic(int cpu)
@@ -809,6 +821,6 @@
-	for (i=0; i<MAX_SAPICS; i++) {
- 		if (ia64_acpiid_to_sapicid[i] == ia64_cpu_to_sapicid[cpu]) {
- 			ia64_acpiid_to_sapicid[i] = -1;
- 			break;
- 		}
- 	}
+	for (i = 0; i < MAX_SAPICS; i++) {
+		if (ia64_acpiid_to_sapicid[i] == ia64_cpu_to_sapicid[cpu]) {
+			ia64_acpiid_to_sapicid[i] = -1;
+			break;
+		}
+	}
@@ -816 +828 @@
-	cpu_clear(cpu,cpu_present_map);
+	cpu_clear(cpu, cpu_present_map);
@@ -822 +834 @@
-	return(0);
+	return (0);
@@ -823,0 +836 @@
+
@@ -825,2 +838 @@
-#endif /* CONFIG_ACPI_HOTPLUG_CPU */
- 
+#endif				/* CONFIG_ACPI_HOTPLUG_CPU */
@@ -830 +842 @@
-acpi_map_iosapic (acpi_handle handle, u32 depth, void *context, void **ret)
+acpi_map_iosapic(acpi_handle handle, u32 depth, void *context, void **ret)
@@ -832 +844 @@
-	struct acpi_buffer buffer = {ACPI_ALLOCATE_BUFFER, NULL};
+	struct acpi_buffer buffer = { ACPI_ALLOCATE_BUFFER, NULL };
@@ -881 +893 @@
-#endif /* CONFIG_NUMA */
+#endif				/* CONFIG_NUMA */
@@ -883,2 +895 @@
-int
-acpi_register_ioapic (acpi_handle handle, u64 phys_addr, u32 gsi_base)
+int acpi_register_ioapic(acpi_handle handle, u64 phys_addr, u32 gsi_base)
@@ -891 +902 @@
-#if CONFIG_ACPI_NUMA
+#ifdef CONFIG_ACPI_NUMA
@@ -893 +904 @@
-#endif /* CONFIG_ACPI_NUMA */
+#endif				/* CONFIG_ACPI_NUMA */
@@ -896,0 +908 @@
+
@@ -899,2 +911 @@
-int
-acpi_unregister_ioapic (acpi_handle handle, u32 gsi_base)
+int acpi_unregister_ioapic(acpi_handle handle, u32 gsi_base)
@@ -903,0 +915 @@
+
@@ -906 +918 @@
-#endif /* CONFIG_ACPI_BOOT */
+#endif				/* CONFIG_ACPI */
--- ./projects/linux/linux-2.6.14/arch/ia64/kernel/acpi.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/arch/ia64/kernel/acpi.c	2006-01-03 04:21:10.000000000 +0100
@@ -841 +841 @@
-acpi_status __devinit
+static acpi_status __devinit
@@ -893 +893,10 @@
-#endif				/* CONFIG_NUMA */
+
+static int __init
+acpi_map_iosapics (void)
+{
+	acpi_get_devices(NULL, acpi_map_iosapic, NULL, NULL);
+	return 0;
+}
+
+fs_initcall(acpi_map_iosapics);
+#endif				/* CONFIG_ACPI_NUMA */
--- ./projects/linux/linux-2.6.15/arch/ia64/kernel/acpi.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/arch/ia64/kernel/acpi.c	2006-03-20 06:53:29.000000000 +0100
@@ -570 +570 @@
-int acpi_register_gsi(u32 gsi, int edge_level, int active_high_low)
+int acpi_register_gsi(u32 gsi, int triggering, int polarity)
@@ -576 +576 @@
-				     (active_high_low ==
+				     (polarity ==
@@ -579 +579 @@
-				     (edge_level ==
+				     (triggering ==
@@ -763,0 +764,53 @@
+int additional_cpus __initdata = -1;
+
+static __init int setup_additional_cpus(char *s)
+{
+	if (s)
+		additional_cpus = simple_strtol(s, NULL, 0);
+
+	return 0;
+}
+
+early_param("additional_cpus", setup_additional_cpus);
+
+/*
+ * cpu_possible_map should be static, it cannot change as cpu's
+ * are onlined, or offlined. The reason is per-cpu data-structures
+ * are allocated by some modules at init time, and dont expect to
+ * do this dynamically on cpu arrival/departure.
+ * cpu_present_map on the other hand can change dynamically.
+ * In case when cpu_hotplug is not compiled, then we resort to current
+ * behaviour, which is cpu_possible == cpu_present.
+ * - Ashok Raj
+ *
+ * Three ways to find out the number of additional hotplug CPUs:
+ * - If the BIOS specified disabled CPUs in ACPI/mptables use that.
+ * - The user can overwrite it with additional_cpus=NUM
+ * - Otherwise don't reserve additional CPUs.
+ */
+__init void prefill_possible_map(void)
+{
+	int i;
+	int possible, disabled_cpus;
+
+	disabled_cpus = total_cpus - available_cpus;
+
+ 	if (additional_cpus == -1) {
+ 		if (disabled_cpus > 0)
+			additional_cpus = disabled_cpus;
+ 		else
+			additional_cpus = 0;
+ 	}
+
+	possible = available_cpus + additional_cpus;
+
+	if (possible > NR_CPUS)
+		possible = NR_CPUS;
+
+	printk(KERN_INFO "SMP: Allowing %d CPUs, %d hotplug CPUs\n",
+		possible, max((possible - available_cpus), 0));
+
+	for (i = 0; i < possible; i++)
+		cpu_set(i, cpu_possible_map);
+}
+
--- ./projects/linux/linux-2.6.16/arch/ia64/kernel/acpi.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/arch/ia64/kernel/acpi.c	2006-06-18 03:49:35.000000000 +0200
@@ -286,0 +287 @@
+#ifdef CONFIG_HOTPLUG_CPU
@@ -289,0 +291 @@
+	extern unsigned int force_cpei_retarget;
@@ -296,4 +298,7 @@
-	if (cpe_vector > 0 && !acpi_cpei_override)
-		return 0;
-	else
-		return 1;
+	if (cpe_vector > 0) {
+		if (acpi_cpei_override || force_cpei_retarget)
+			return 1;
+		else
+			return 0;
+	}
+	return 1;
@@ -317,0 +323 @@
+#endif
@@ -416,0 +423,20 @@
+static int get_processor_proximity_domain(struct acpi_table_processor_affinity *pa)
+{
+	int pxm;
+
+	pxm = pa->proximity_domain;
+	if (ia64_platform_is("sn2"))
+		pxm += pa->reserved[0] << 8;
+	return pxm;
+}
+
+static int get_memory_proximity_domain(struct acpi_table_memory_affinity *ma)
+{
+	int pxm;
+
+	pxm = ma->proximity_domain;
+	if (ia64_platform_is("sn2"))
+		pxm += ma->reserved1[0] << 8;
+	return pxm;
+}
+
@@ -439,0 +466,7 @@
+	int pxm;
+
+	if (!pa->flags.enabled)
+		return;
+
+	pxm = get_processor_proximity_domain(pa);
+
@@ -441 +474 @@
-	pxm_bit_set(pa->proximity_domain);
+	pxm_bit_set(pxm);
@@ -446 +479 @@
-	node_cpuid[srat_num_cpus].nid = pa->proximity_domain;
+	node_cpuid[srat_num_cpus].nid = pxm;
@@ -454 +487 @@
-	u8 pxm;
+	int pxm;
@@ -457 +490 @@
-	pxm = ma->proximity_domain;
+	pxm = get_memory_proximity_domain(ma);
@@ -621,3 +654,3 @@
-	if (efi.acpi20)
-		rsdp_phys = __pa(efi.acpi20);
-	else if (efi.acpi)
+	if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
+		rsdp_phys = efi.acpi20;
+	else if (efi.acpi != EFI_INVALID_TABLE_ADDR)
--- ./projects/linux/linux-2.6.17/arch/ia64/kernel/acpi.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/ia64/kernel/acpi.c	2006-09-20 05:42:06.000000000 +0200
@@ -35 +34,0 @@
-#include <linux/config.h>
@@ -59 +58 @@
-		((acpi_table_entry_header *)entry)->length != sizeof(*entry))
+		((acpi_table_entry_header *)entry)->length < sizeof(*entry))
@@ -71,2 +69,0 @@
-static unsigned int __initdata acpi_madt_rev;
-
@@ -245,0 +243,2 @@
+static unsigned int __initdata acpi_madt_rev;
+
@@ -418,3 +416,0 @@
-/* maps to convert between proximity domain and logical node ID */
-int __devinitdata pxm_to_nid_map[MAX_PXM_DOMAINS];
-int __initdata nid_to_pxm_map[MAX_NUMNODES];
@@ -536,3 +531,0 @@
-	/* calculate total number of nodes in system from PXM bitmap */
-	memset(pxm_to_nid_map, -1, sizeof(pxm_to_nid_map));
-	memset(nid_to_pxm_map, -1, sizeof(nid_to_pxm_map));
@@ -542,3 +535 @@
-			int nid = num_online_nodes();
-			pxm_to_nid_map[i] = nid;
-			nid_to_pxm_map[nid] = i;
+			int nid = acpi_map_pxm_to_node(i);
@@ -551 +542 @@
-		node_memblk[i].nid = pxm_to_nid_map[node_memblk[i].nid];
+		node_memblk[i].nid = pxm_to_node(node_memblk[i].nid);
@@ -565 +556 @@
-		node_cpuid[i].nid = pxm_to_nid_map[node_cpuid[i].nid];
+		node_cpuid[i].nid = pxm_to_node(node_cpuid[i].nid);
@@ -578 +569 @@
-		node_from = pxm_to_nid_map[i];
+		node_from = pxm_to_node(i);
@@ -582 +573 @@
-			node_to = pxm_to_nid_map[j];
+			node_to = pxm_to_node(j);
@@ -629 +620 @@
-	struct fadt_descriptor_rev2 *fadt;
+	struct fadt_descriptor *fadt;
@@ -638 +629 @@
-	fadt = (struct fadt_descriptor_rev2 *)fadt_header;
+	fadt = (struct fadt_descriptor *)fadt_header;
@@ -788 +779 @@
-	 * domain and would have initialized pxm_to_nid_map[pxm_id] && pxm_flag
+	 * domain and would have initialized pxm_to_node(pxm_id) && pxm_flag
@@ -790 +781 @@
-	node_cpuid[cpu].nid = (pxm_id < 0) ? 0 : pxm_to_nid_map[pxm_id];
+	node_cpuid[cpu].nid = (pxm_id < 0) ? 0 : pxm_to_node(pxm_id);
@@ -868 +859 @@
-		acpi_os_free(buffer.pointer);
+		kfree(buffer.pointer);
@@ -876 +867 @@
-		acpi_os_free(buffer.pointer);
+		kfree(buffer.pointer);
@@ -882 +873 @@
-	acpi_os_free(buffer.pointer);
+	kfree(buffer.pointer);
@@ -946 +937 @@
-		acpi_os_free(buffer.pointer);
+		kfree(buffer.pointer);
@@ -953 +944 @@
-		acpi_os_free(buffer.pointer);
+		kfree(buffer.pointer);
@@ -959 +950 @@
-	acpi_os_free(buffer.pointer);
+	kfree(buffer.pointer);
@@ -969 +960 @@
-	node = pxm_to_nid_map[pxm];
+	node = pxm_to_node(pxm);
--- ./projects/linux/linux-2.6.18/arch/ia64/kernel/acpi.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/ia64/kernel/acpi.c	2006-11-29 22:57:37.000000000 +0100
@@ -67,3 +66,0 @@
-unsigned char acpi_kbd_controller_present = 1;
-unsigned char acpi_legacy_devices;
-
@@ -631,6 +627,0 @@
-	if (!(fadt->iapc_boot_arch & BAF_8042_KEYBOARD_CONTROLLER))
-		acpi_kbd_controller_present = 0;
-
-	if (fadt->iapc_boot_arch & BAF_LEGACY_DEVICES)
-		acpi_legacy_devices = 1;
-
@@ -773,0 +765 @@
+	int nid;
@@ -776 +767,0 @@
-
@@ -778,2 +769,5 @@
-	 * Assuming that the container driver would have set the proximity
-	 * domain and would have initialized pxm_to_node(pxm_id) && pxm_flag
+	 * We don't have cpu-only-node hotadd. But if the system equips
+	 * SRAT table, pxm is already found and node is ready.
+  	 * So, just pxm_to_nid(pxm) is OK.
+	 * This code here is for the system which doesn't have full SRAT
+  	 * table for possible cpus.
@@ -781,2 +775 @@
-	node_cpuid[cpu].nid = (pxm_id < 0) ? 0 : pxm_to_node(pxm_id);
-
+	nid = acpi_map_pxm_to_node(pxm_id);
@@ -783,0 +777 @@
+	node_cpuid[cpu].nid = nid;
--- ./projects/linux/linux-2.6.19/arch/ia64/kernel/acpi.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/arch/ia64/kernel/acpi.c	2007-02-04 19:44:54.000000000 +0100
@@ -592,0 +593,3 @@
+	if (acpi_irq_model == ACPI_IRQ_MODEL_PLATFORM)
+		return gsi;
+
@@ -608,0 +612,3 @@
+	if (acpi_irq_model == ACPI_IRQ_MODEL_PLATFORM)
+		return;
+
--- ./projects/linux/linux-2.6.20/arch/ia64/kernel/acpi.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/arch/ia64/kernel/acpi.c	2007-04-26 05:08:32.000000000 +0200
@@ -58 +58 @@
-		((acpi_table_entry_header *)entry)->length < sizeof(*entry))
+		((struct acpi_subtable_header *)entry)->length < sizeof(*entry))
@@ -70,5 +69,0 @@
-#define MAX_SAPICS 256
-u16 ia64_acpiid_to_sapicid[MAX_SAPICS] = {[0 ... MAX_SAPICS - 1] = -1 };
-
-EXPORT_SYMBOL(ia64_acpiid_to_sapicid);
-
@@ -79 +74 @@
-	struct acpi20_table_rsdp *rsdp;
+	struct acpi_table_rsdp *rsdp;
@@ -90,2 +85,2 @@
-	rsdp = (struct acpi20_table_rsdp *)__va(rsdp_phys);
-	if (strncmp(rsdp->signature, RSDP_SIG, sizeof(RSDP_SIG) - 1)) {
+	rsdp = (struct acpi_table_rsdp *)__va(rsdp_phys);
+	if (strncmp(rsdp->signature, ACPI_SIG_RSDP, sizeof(ACPI_SIG_RSDP) - 1)) {
@@ -97 +92 @@
-	xsdt = (struct acpi_table_xsdt *)__va(rsdp->xsdt_address);
+	xsdt = (struct acpi_table_xsdt *)__va(rsdp->xsdt_physical_address);
@@ -99 +94 @@
-	if (strncmp(hdr->signature, XSDT_SIG, sizeof(XSDT_SIG) - 1)) {
+	if (strncmp(hdr->signature, ACPI_SIG_XSDT, sizeof(ACPI_SIG_XSDT) - 1)) {
@@ -172 +167 @@
-acpi_parse_lapic_addr_ovr(acpi_table_entry_header * header,
+acpi_parse_lapic_addr_ovr(struct acpi_subtable_header * header,
@@ -175 +170 @@
-	struct acpi_table_lapic_addr_ovr *lapic;
+	struct acpi_madt_local_apic_override *lapic;
@@ -177 +172 @@
-	lapic = (struct acpi_table_lapic_addr_ovr *)header;
+	lapic = (struct acpi_madt_local_apic_override *)header;
@@ -190 +185 @@
-acpi_parse_lsapic(acpi_table_entry_header * header, const unsigned long end)
+acpi_parse_lsapic(struct acpi_subtable_header * header, const unsigned long end)
@@ -192 +187 @@
-	struct acpi_table_lsapic *lsapic;
+	struct acpi_madt_local_sapic *lsapic;
@@ -194 +189 @@
-	lsapic = (struct acpi_table_lsapic *)header;
+	lsapic = (struct acpi_madt_local_sapic *)header;
@@ -196,2 +191 @@
-	if (BAD_MADT_ENTRY(lsapic, end))
-		return -EINVAL;
+	/*Skip BAD_MADT_ENTRY check, as lsapic size could vary */
@@ -199 +193 @@
-	if (lsapic->flags.enabled) {
+	if (lsapic->lapic_flags & ACPI_MADT_ENABLED) {
@@ -204,2 +197,0 @@
-		ia64_acpiid_to_sapicid[lsapic->acpi_id] =
-		    (lsapic->id << 8) | lsapic->eid;
@@ -214 +206 @@
-acpi_parse_lapic_nmi(acpi_table_entry_header * header, const unsigned long end)
+acpi_parse_lapic_nmi(struct acpi_subtable_header * header, const unsigned long end)
@@ -216 +208 @@
-	struct acpi_table_lapic_nmi *lacpi_nmi;
+	struct acpi_madt_local_apic_nmi *lacpi_nmi;
@@ -218 +210 @@
-	lacpi_nmi = (struct acpi_table_lapic_nmi *)header;
+	lacpi_nmi = (struct acpi_madt_local_apic_nmi *)header;
@@ -228 +220 @@
-acpi_parse_iosapic(acpi_table_entry_header * header, const unsigned long end)
+acpi_parse_iosapic(struct acpi_subtable_header * header, const unsigned long end)
@@ -230 +222 @@
-	struct acpi_table_iosapic *iosapic;
+	struct acpi_madt_io_sapic *iosapic;
@@ -232 +224 @@
-	iosapic = (struct acpi_table_iosapic *)header;
+	iosapic = (struct acpi_madt_io_sapic *)header;
@@ -243 +235 @@
-acpi_parse_plat_int_src(acpi_table_entry_header * header,
+acpi_parse_plat_int_src(struct acpi_subtable_header * header,
@@ -246 +238 @@
-	struct acpi_table_plat_int_src *plintsrc;
+	struct acpi_madt_interrupt_source *plintsrc;
@@ -249 +241 @@
-	plintsrc = (struct acpi_table_plat_int_src *)header;
+	plintsrc = (struct acpi_madt_interrupt_source *)header;
@@ -260 +252 @@
-						plintsrc->iosapic_vector,
+						plintsrc->io_sapic_vector,
@@ -263,6 +255,6 @@
-						(plintsrc->flags.polarity ==
-						 1) ? IOSAPIC_POL_HIGH :
-						IOSAPIC_POL_LOW,
-						(plintsrc->flags.trigger ==
-						 1) ? IOSAPIC_EDGE :
-						IOSAPIC_LEVEL);
+						((plintsrc->inti_flags & ACPI_MADT_POLARITY_MASK) ==
+						 ACPI_MADT_POLARITY_ACTIVE_HIGH) ?
+						IOSAPIC_POL_HIGH : IOSAPIC_POL_LOW,
+						((plintsrc->inti_flags & ACPI_MADT_TRIGGER_MASK) ==
+						 ACPI_MADT_TRIGGER_EDGE) ?
+						IOSAPIC_EDGE : IOSAPIC_LEVEL);
@@ -272 +264 @@
-		acpi_cpei_override = plintsrc->plint_flags.cpei_override_flag;
+		acpi_cpei_override = plintsrc->flags & ACPI_MADT_CPEI_OVERRIDE;
@@ -327 +319 @@
-acpi_parse_int_src_ovr(acpi_table_entry_header * header,
+acpi_parse_int_src_ovr(struct acpi_subtable_header * header,
@@ -330 +322 @@
-	struct acpi_table_int_src_ovr *p;
+	struct acpi_madt_interrupt_override *p;
@@ -332 +324 @@
-	p = (struct acpi_table_int_src_ovr *)header;
+	p = (struct acpi_madt_interrupt_override *)header;
@@ -337,5 +329,7 @@
-	iosapic_override_isa_irq(p->bus_irq, p->global_irq,
-				 (p->flags.polarity ==
-				  1) ? IOSAPIC_POL_HIGH : IOSAPIC_POL_LOW,
-				 (p->flags.trigger ==
-				  1) ? IOSAPIC_EDGE : IOSAPIC_LEVEL);
+	iosapic_override_isa_irq(p->source_irq, p->global_irq,
+				 ((p->inti_flags & ACPI_MADT_POLARITY_MASK) ==
+				  ACPI_MADT_POLARITY_ACTIVE_HIGH) ?
+				 IOSAPIC_POL_HIGH : IOSAPIC_POL_LOW,
+				 ((p->inti_flags & ACPI_MADT_TRIGGER_MASK) ==
+				 ACPI_MADT_TRIGGER_EDGE) ?
+				 IOSAPIC_EDGE : IOSAPIC_LEVEL);
@@ -346 +340 @@
-acpi_parse_nmi_src(acpi_table_entry_header * header, const unsigned long end)
+acpi_parse_nmi_src(struct acpi_subtable_header * header, const unsigned long end)
@@ -348 +342 @@
-	struct acpi_table_nmi_src *nmi_src;
+	struct acpi_madt_nmi_source *nmi_src;
@@ -350 +344 @@
-	nmi_src = (struct acpi_table_nmi_src *)header;
+	nmi_src = (struct acpi_madt_nmi_source *)header;
@@ -374 +368 @@
-static int __init acpi_parse_madt(unsigned long phys_addr, unsigned long size)
+static int __init acpi_parse_madt(struct acpi_table_header *table)
@@ -376 +370 @@
-	if (!phys_addr || !size)
+	if (!table)
@@ -379 +373 @@
-	acpi_madt = (struct acpi_table_madt *)__va(phys_addr);
+	acpi_madt = (struct acpi_table_madt *)table;
@@ -387 +381 @@
-	has_8259 = acpi_madt->flags.pcat_compat;
+	has_8259 = acpi_madt->flags & ACPI_MADT_PCAT_COMPAT;
@@ -393,2 +387,2 @@
-	if (acpi_madt->lapic_address)
-		ipi_base_addr = ioremap(acpi_madt->lapic_address, 0);
+	if (acpi_madt->address)
+		ipi_base_addr = ioremap(acpi_madt->address, 0);
@@ -416 +410 @@
-static int get_processor_proximity_domain(struct acpi_table_processor_affinity *pa)
+static int get_processor_proximity_domain(struct acpi_srat_cpu_affinity *pa)
@@ -420 +414 @@
-	pxm = pa->proximity_domain;
+	pxm = pa->proximity_domain_lo;
@@ -422 +416 @@
-		pxm += pa->reserved[0] << 8;
+		pxm += pa->proximity_domain_hi[0] << 8;
@@ -426 +420 @@
-static int get_memory_proximity_domain(struct acpi_table_memory_affinity *ma)
+static int get_memory_proximity_domain(struct acpi_srat_mem_affinity *ma)
@@ -431,2 +425,3 @@
-	if (ia64_platform_is("sn2"))
-		pxm += ma->reserved1[0] << 8;
+	if (!ia64_platform_is("sn2"))
+		pxm &= 0xff;
+
@@ -445 +440 @@
-	    + slit->localities * slit->localities;
+	    + slit->locality_count * slit->locality_count;
@@ -457 +452 @@
-acpi_numa_processor_affinity_init(struct acpi_table_processor_affinity *pa)
+acpi_numa_processor_affinity_init(struct acpi_srat_cpu_affinity *pa)
@@ -461 +456 @@
-	if (!pa->flags.enabled)
+	if (!(pa->flags & ACPI_SRAT_CPU_ENABLED))
@@ -470 +465 @@
-	    (pa->apic_id << 8) | (pa->lsapic_eid);
+	    (pa->apic_id << 8) | (pa->local_sapic_eid);
@@ -477 +472 @@
-acpi_numa_memory_affinity_init(struct acpi_table_memory_affinity *ma)
+acpi_numa_memory_affinity_init(struct acpi_srat_mem_affinity *ma)
@@ -486,4 +481,2 @@
-	paddr = ma->base_addr_hi;
-	paddr = (paddr << 32) | ma->base_addr_lo;
-	size = ma->length_hi;
-	size = (size << 32) | ma->length_lo;
+	paddr = ma->base_address;
+	size = ma->length;
@@ -492 +485 @@
-	if (!ma->flags.enabled)
+	if (!(ma->flags & ACPI_SRAT_MEM_ENABLED))
@@ -563 +556 @@
-	for (i = 0; i < slit_table->localities; i++) {
+	for (i = 0; i < slit_table->locality_count; i++) {
@@ -567 +560 @@
-		for (j = 0; j < slit_table->localities; j++) {
+		for (j = 0; j < slit_table->locality_count; j++) {
@@ -572 +565 @@
-			    slit_table->entry[i * slit_table->localities + j];
+			    slit_table->entry[i * slit_table->locality_count + j];
@@ -620 +613 @@
-static int __init acpi_parse_fadt(unsigned long phys_addr, unsigned long size)
+static int __init acpi_parse_fadt(struct acpi_table_header *table)
@@ -623 +616 @@
-	struct fadt_descriptor *fadt;
+	struct acpi_table_fadt *fadt;
@@ -625 +618 @@
-	if (!phys_addr || !size)
+	if (!table)
@@ -628 +621 @@
-	fadt_header = (struct acpi_table_header *)__va(phys_addr);
+	fadt_header = (struct acpi_table_header *)table;
@@ -632 +625 @@
-	fadt = (struct fadt_descriptor *)fadt_header;
+	fadt = (struct acpi_table_fadt *)fadt_header;
@@ -634 +627 @@
-	acpi_register_gsi(fadt->sci_int, ACPI_LEVEL_SENSITIVE, ACPI_ACTIVE_LOW);
+	acpi_register_gsi(fadt->sci_interrupt, ACPI_LEVEL_SENSITIVE, ACPI_ACTIVE_LOW);
@@ -661 +654 @@
-	if (acpi_table_parse(ACPI_APIC, acpi_parse_madt) < 1) {
+	if (acpi_table_parse(ACPI_SIG_MADT, acpi_parse_madt)) {
@@ -669 +662 @@
-	    (ACPI_MADT_LAPIC_ADDR_OVR, acpi_parse_lapic_addr_ovr, 0) < 0)
+	    (ACPI_MADT_TYPE_LOCAL_APIC_OVERRIDE, acpi_parse_lapic_addr_ovr, 0) < 0)
@@ -673 +666 @@
-	if (acpi_table_parse_madt(ACPI_MADT_LSAPIC, acpi_parse_lsapic, NR_CPUS)
+	if (acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_SAPIC, acpi_parse_lsapic, NR_CPUS)
@@ -678 +671 @@
-	if (acpi_table_parse_madt(ACPI_MADT_LAPIC_NMI, acpi_parse_lapic_nmi, 0)
+	if (acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_APIC_NMI, acpi_parse_lapic_nmi, 0)
@@ -685 +678 @@
-	    (ACPI_MADT_IOSAPIC, acpi_parse_iosapic, NR_IOSAPICS) < 1)
+	    (ACPI_MADT_TYPE_IO_SAPIC, acpi_parse_iosapic, NR_IOSAPICS) < 1)
@@ -692 +685 @@
-	    (ACPI_MADT_PLAT_INT_SRC, acpi_parse_plat_int_src,
+	    (ACPI_MADT_TYPE_INTERRUPT_SOURCE, acpi_parse_plat_int_src,
@@ -698 +691 @@
-	    (ACPI_MADT_INT_SRC_OVR, acpi_parse_int_src_ovr, 0) < 0)
+	    (ACPI_MADT_TYPE_INTERRUPT_OVERRIDE, acpi_parse_int_src_ovr, 0) < 0)
@@ -702 +695 @@
-	if (acpi_table_parse_madt(ACPI_MADT_NMI_SRC, acpi_parse_nmi_src, 0) < 0)
+	if (acpi_table_parse_madt(ACPI_MADT_TYPE_NMI_SOURCE, acpi_parse_nmi_src, 0) < 0)
@@ -712 +705 @@
-	if (acpi_table_parse(ACPI_FADT, acpi_parse_fadt) < 1)
+	if (acpi_table_parse(ACPI_SIG_FADT, acpi_parse_fadt))
@@ -845 +838 @@
-	struct acpi_table_lsapic *lsapic;
+	struct acpi_madt_local_sapic *lsapic;
@@ -857,2 +850,2 @@
-	if (obj->type != ACPI_TYPE_BUFFER ||
-	    obj->buffer.length < sizeof(*lsapic)) {
+	if (obj->type != ACPI_TYPE_BUFFER)
+	{
@@ -863 +856 @@
-	lsapic = (struct acpi_table_lsapic *)obj->buffer.pointer;
+	lsapic = (struct acpi_madt_local_sapic *)obj->buffer.pointer;
@@ -865,2 +858,2 @@
-	if ((lsapic->header.type != ACPI_MADT_LSAPIC) ||
-	    (!lsapic->flags.enabled)) {
+	if ((lsapic->header.type != ACPI_MADT_TYPE_LOCAL_SAPIC) ||
+	    (!lsapic->lapic_flags & ACPI_MADT_ENABLED)) {
@@ -886 +878,0 @@
-	ia64_acpiid_to_sapicid[lsapic->acpi_id] = ia64_cpu_to_sapicid[cpu];
@@ -896,8 +887,0 @@
-	int i;
-
-	for (i = 0; i < MAX_SAPICS; i++) {
-		if (ia64_acpiid_to_sapicid[i] == ia64_cpu_to_sapicid[cpu]) {
-			ia64_acpiid_to_sapicid[i] = -1;
-			break;
-		}
-	}
@@ -923 +907 @@
-	struct acpi_table_iosapic *iosapic;
+	struct acpi_madt_io_sapic *iosapic;
@@ -941 +925 @@
-	iosapic = (struct acpi_table_iosapic *)obj->buffer.pointer;
+	iosapic = (struct acpi_madt_io_sapic *)obj->buffer.pointer;
@@ -943 +927 @@
-	if (iosapic->header.type != ACPI_MADT_IOSAPIC) {
+	if (iosapic->header.type != ACPI_MADT_TYPE_IO_SAPIC) {
--- ./projects/linux/linux-2.6.21/arch/ia64/kernel/acpi.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/arch/ia64/kernel/acpi.c	2007-07-09 01:32:17.000000000 +0200
@@ -70 +70,2 @@
-const char *acpi_get_sysname(void)
+const char __init *
+acpi_get_sysname(void)
@@ -794 +795 @@
- * cpu_possible_map should be static, it cannot change as cpu's
+ * cpu_possible_map should be static, it cannot change as CPUs
--- ./projects/linux/linux-2.6.22/arch/ia64/kernel/acpi.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/arch/ia64/kernel/acpi.c	2007-10-09 22:31:38.000000000 +0200
@@ -69,0 +70,2 @@
+unsigned long acpi_wakeup_address = 0;
+
@@ -742 +744 @@
-	int vector;
+	int tmp;
@@ -747,2 +749,2 @@
-		vector = gsi_to_vector(gsi);
-		if (vector == -1)
+		tmp = gsi_to_irq(gsi);
+		if (tmp == -1)
@@ -750,2 +752 @@
-
-		*irq = vector;
+		*irq = tmp;
@@ -988,0 +990,17 @@
+/*
+ * acpi_save_state_mem() - save kernel state
+ *
+ * TBD when when IA64 starts to support suspend...
+ */
+int acpi_save_state_mem(void) { return 0; } 
+
+/*
+ * acpi_restore_state()
+ */
+void acpi_restore_state_mem(void) {}
+
+/*
+ * do_suspend_lowlevel()
+ */
+void do_suspend_lowlevel(void) {}
+
--- ./projects/linux/linux-2.6.23/arch/ia64/kernel/acpi.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/arch/ia64/kernel/acpi.c	2008-01-24 23:58:37.000000000 +0100
@@ -681,3 +681,5 @@
-	    (ACPI_MADT_TYPE_IO_SAPIC, acpi_parse_iosapic, NR_IOSAPICS) < 1)
-		printk(KERN_ERR PREFIX
-		       "Error parsing MADT - no IOSAPIC entries\n");
+	    (ACPI_MADT_TYPE_IO_SAPIC, acpi_parse_iosapic, NR_IOSAPICS) < 1) {
+		if (!ia64_platform_is("sn2"))
+			printk(KERN_ERR PREFIX
+			       "Error parsing MADT - no IOSAPIC entries\n");
+	}
@@ -861 +863 @@
-	    (!lsapic->lapic_flags & ACPI_MADT_ENABLED)) {
+	    (!(lsapic->lapic_flags & ACPI_MADT_ENABLED))) {
--- ./projects/linux/linux-2.6.24/arch/ia64/kernel/acpi.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/ia64/kernel/acpi.c	2008-04-17 04:49:44.000000000 +0200
@@ -71,0 +72,14 @@
+#ifdef CONFIG_IA64_GENERIC
+static unsigned long __init acpi_find_rsdp(void)
+{
+	unsigned long rsdp_phys = 0;
+
+	if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
+		rsdp_phys = efi.acpi20;
+	else if (efi.acpi != EFI_INVALID_TABLE_ADDR)
+		printk(KERN_WARNING PREFIX
+		       "v1.0/r0.71 tables no longer supported\n");
+	return rsdp_phys;
+}
+#endif
+
@@ -155 +169 @@
-char *__acpi_map_table(unsigned long phys_addr, unsigned long size)
+char *__init __acpi_map_table(unsigned long phys_addr, unsigned long size)
@@ -604,2 +617,0 @@
-EXPORT_SYMBOL(acpi_register_gsi);
-
@@ -614,2 +625,0 @@
-EXPORT_SYMBOL(acpi_unregister_gsi);
-
@@ -634,12 +643,0 @@
-unsigned long __init acpi_find_rsdp(void)
-{
-	unsigned long rsdp_phys = 0;
-
-	if (efi.acpi20 != EFI_INVALID_TABLE_ADDR)
-		rsdp_phys = efi.acpi20;
-	else if (efi.acpi != EFI_INVALID_TABLE_ADDR)
-		printk(KERN_WARNING PREFIX
-		       "v1.0/r0.71 tables no longer supported\n");
-	return rsdp_phys;
-}
-
--- ./projects/linux/linux-2.6.25/arch/ia64/kernel/acpi.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/arch/ia64/kernel/acpi.c	2008-07-13 23:51:29.000000000 +0200
@@ -120 +120,4 @@
-		return "sn2";
+		if (!strcmp(hdr->oem_table_id + 4, "UV"))
+			return "uv";
+		else
+			return "sn2";
@@ -132,0 +136,2 @@
+# elif defined (CONFIG_IA64_SGI_UV)
+	return "uv";
@@ -425,0 +431 @@
+cpumask_t early_cpu_possible_map = CPU_MASK_NONE;
@@ -462 +467,0 @@
-		memset(numa_slit, 10, sizeof(numa_slit));
@@ -484,0 +490 @@
+	cpu_set(srat_num_cpus, early_cpu_possible_map);
@@ -562 +568 @@
-	for (i = 0; i < srat_num_cpus; i++)
+	for_each_possible_early_cpu(i)
@@ -570 +576,5 @@
-	if (!slit_table)
+	if (!slit_table) {
+		for (i = 0; i < MAX_NUMNODES; i++)
+			for (j = 0; j < MAX_NUMNODES; j++)
+				node_distance(i, j) = i == j ? LOCAL_DISTANCE :
+							REMOTE_DISTANCE;
@@ -571,0 +582,2 @@
+	}
+
@@ -622,0 +635,3 @@
+	if (has_8259 && gsi < 16)
+		return;
+
@@ -967 +982 @@
-int acpi_register_ioapic(acpi_handle handle, u64 phys_addr, u32 gsi_base)
+int __ref acpi_register_ioapic(acpi_handle handle, u64 phys_addr, u32 gsi_base)
--- ./projects/linux/linux-2.6.26/arch/ia64/kernel/acpi.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/arch/ia64/kernel/acpi.c	2008-10-10 00:13:53.000000000 +0200
@@ -777 +777 @@
-int acpi_map_cpu2node(acpi_handle handle, int cpu, long physid)
+int acpi_map_cpu2node(acpi_handle handle, int cpu, int physid)
@@ -857,2 +857 @@
-	long physid;
-	int cpu;
+	int cpu, physid;
--- ./projects/linux/linux-2.6.27/arch/ia64/kernel/acpi.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/arch/ia64/kernel/acpi.c	2008-12-25 00:26:37.000000000 +0100
@@ -54,0 +55 @@
+#include <asm/xen/hypervisor.h>
@@ -93,0 +95,3 @@
+#ifdef CONFIG_DMAR
+	u64 i, nentries;
+#endif
@@ -123,0 +128,13 @@
+	} else if (xen_pv_domain() && !strcmp(hdr->oem_id, "XEN")) {
+		return "xen";
+	}
+
+#ifdef CONFIG_DMAR
+	/* Look for Intel IOMMU */
+	nentries = (hdr->length - sizeof(*hdr)) /
+			 sizeof(xsdt->table_offset_entry[0]);
+	for (i = 0; i < nentries; i++) {
+		hdr = __va(xsdt->table_offset_entry[i]);
+		if (strncmp(hdr->signature, ACPI_SIG_DMAR,
+			sizeof(ACPI_SIG_DMAR) - 1) == 0)
+			return "dig_vtd";
@@ -124,0 +142 @@
+#endif
@@ -139,0 +158,4 @@
+# elif defined (CONFIG_IA64_XEN_GUEST)
+	return "xen";
+# elif defined(CONFIG_IA64_DIG_VTD)
+	return "dig_vtd";
@@ -658,0 +681,24 @@
+int __init early_acpi_boot_init(void)
+{
+	int ret;
+
+	/*
+	 * do a partial walk of MADT to determine how many CPUs
+	 * we have including offline CPUs
+	 */
+	if (acpi_table_parse(ACPI_SIG_MADT, acpi_parse_madt)) {
+		printk(KERN_ERR PREFIX "Can't find MADT\n");
+		return 0;
+	}
+
+	ret = acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_SAPIC,
+		acpi_parse_lsapic, NR_CPUS);
+	if (ret < 1)
+		printk(KERN_ERR PREFIX
+		       "Error parsing MADT - no LAPIC entries\n");
+
+	return 0;
+}
+
+
+
@@ -682,5 +727,0 @@
-	if (acpi_table_parse_madt(ACPI_MADT_TYPE_LOCAL_SAPIC, acpi_parse_lsapic, NR_CPUS)
-	    < 1)
-		printk(KERN_ERR PREFIX
-		       "Error parsing MADT - no LAPIC entries\n");
-
--- ./projects/linux/linux-2.6.28/arch/ia64/kernel/acpi.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/arch/ia64/kernel/acpi.c	2009-03-24 00:12:14.000000000 +0100
@@ -67,0 +68 @@
+u32 acpi_rsdt_forced;
@@ -205 +205,0 @@
-static int total_cpus __initdata;
@@ -1004 +1004 @@
-	    cpus_empty(node_to_cpumask(node)))
+	    cpumask_empty(cpumask_of_node(node)))
--- ./projects/linux/linux-2.6.29/arch/ia64/kernel/acpi.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/arch/ia64/kernel/acpi.c	2009-06-27 11:32:31.000000000 +0200
@@ -201,0 +202,4 @@
+void __init __acpi_unmap_table(char *map, unsigned long size)
+{
+}
+
@@ -889 +893 @@
-		cpu_set(i, cpu_possible_map);
+		set_cpu_possible(i, true);
@@ -927,3 +931,3 @@
-	cpus_complement(tmp_map, cpu_present_map);
-	cpu = first_cpu(tmp_map);
-	if (cpu >= NR_CPUS)
+	cpumask_complement(&tmp_map, cpu_present_mask);
+	cpu = cpumask_first(&tmp_map);
+	if (cpu >= nr_cpu_ids)
--- ./projects/linux/linux-2.6.15/arch/sh/drivers/dma/dma-sh.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/arch/sh/drivers/dma/dma-sh.c	2006-03-20 06:53:29.000000000 +0100
@@ -7,0 +8 @@
+ * Copyright (C) 2005 Andriy Skulysh
@@ -18,0 +20 @@
+#include <asm/dreamcast/dma.h>
@@ -25,25 +26,0 @@
-/*
- * The SuperH DMAC supports a number of transmit sizes, we list them here,
- * with their respective values as they appear in the CHCR registers.
- *
- * Defaults to a 64-bit transfer size.
- */
-enum {
-	XMIT_SZ_64BIT,
-	XMIT_SZ_8BIT,
-	XMIT_SZ_16BIT,
-	XMIT_SZ_32BIT,
-	XMIT_SZ_256BIT,
-};
-
-/*
- * The DMA count is defined as the number of bytes to transfer.
- */
-static unsigned int ts_shift[] = {
-	[XMIT_SZ_64BIT]		= 3,
-	[XMIT_SZ_8BIT]		= 0,
-	[XMIT_SZ_16BIT]		= 1,
-	[XMIT_SZ_32BIT]		= 2,
-	[XMIT_SZ_256BIT]	= 5,
-};
-
@@ -52 +29 @@
-	unsigned int irq;
+	unsigned int irq = 0;
@@ -59 +35,0 @@
-
@@ -62,0 +39 @@
+#ifdef DMTE4_IRQ
@@ -63,0 +41 @@
+#endif
@@ -81,3 +59 @@
-	chcr >>= 4;
-
-	return ts_shift[chcr & 0x0007];
+	return ts_shift[(chcr & CHCR_TS_MASK)>>CHCR_TS_SHIFT];
@@ -111,0 +88,5 @@
+	char name[32];
+
+	snprintf(name, sizeof(name), "DMAC Transfer End (Channel %d)",
+		 chan->chan);
+
@@ -113 +94 @@
-			   SA_INTERRUPT, "DMAC Transfer End", chan);
+			   SA_INTERRUPT, name, chan);
@@ -121 +102,2 @@
-static void sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
+static void
+sh_dmac_configure_channel(struct dma_channel *chan, unsigned long chcr)
@@ -124 +106,8 @@
-		chcr = RS_DUAL;
+		chcr = RS_DUAL | CHCR_IE;
+
+	if (chcr & CHCR_IE) {
+		chcr &= ~CHCR_IE;
+		chan->flags |= DMA_TEI_CAPABLE;
+	} else {
+		chan->flags &= ~DMA_TEI_CAPABLE;
+	}
@@ -133 +122 @@
-	int irq = get_dmte_irq(chan->chan);
+	int irq;
@@ -137 +126,5 @@
-	chcr |= CHCR_DE | CHCR_IE;
+	chcr |= CHCR_DE;
+
+	if (chan->flags & DMA_TEI_CAPABLE)
+		chcr |= CHCR_IE;
+
@@ -140 +133,4 @@
-	enable_irq(irq);
+	if (chan->flags & DMA_TEI_CAPABLE) {
+		irq = get_dmte_irq(chan->chan);
+		enable_irq(irq);
+	}
@@ -145 +141 @@
-	int irq = get_dmte_irq(chan->chan);
+	int irq;
@@ -148 +144,4 @@
-	disable_irq(irq);
+	if (chan->flags & DMA_TEI_CAPABLE) {
+		irq = get_dmte_irq(chan->chan);
+		disable_irq(irq);
+	}
@@ -161 +160 @@
-	if (!(chan->flags & DMA_CONFIGURED))
+	if (unlikely(!(chan->flags & DMA_CONFIGURED)))
@@ -181 +180,2 @@
-	if (chan->sar || (mach_is_dreamcast() && chan->chan == 2))
+	if (chan->sar || (mach_is_dreamcast() &&
+			  chan->chan == PVR2_CASCADE_CHAN))
@@ -183 +183,2 @@
-	if (chan->dar || (mach_is_dreamcast() && chan->chan == 2))
+	if (chan->dar || (mach_is_dreamcast() &&
+			  chan->chan == PVR2_CASCADE_CHAN))
@@ -201,2 +202,9 @@
-#if defined(CONFIG_CPU_SH4)
-static irqreturn_t dma_err(int irq, void *dev_id, struct pt_regs *regs)
+#ifdef CONFIG_CPU_SUBTYPE_SH7780
+#define dmaor_read_reg()	ctrl_inw(DMAOR)
+#define dmaor_write_reg(data)	ctrl_outw(data, DMAOR)
+#else
+#define dmaor_read_reg()	ctrl_inl(DMAOR)
+#define dmaor_write_reg(data)	ctrl_outl(data, DMAOR)
+#endif
+
+static inline int dmaor_reset(void)
@@ -204 +212,5 @@
-	unsigned long dmaor = ctrl_inl(DMAOR);
+	unsigned long dmaor = dmaor_read_reg();
+
+	/* Try to clear the error flags first, incase they are set */
+	dmaor &= ~(DMAOR_NMIF | DMAOR_AE);
+	dmaor_write_reg(dmaor);
@@ -206 +218,2 @@
-	printk("DMAE: DMAOR=%lx\n", dmaor);
+	dmaor |= DMAOR_INIT;
+	dmaor_write_reg(dmaor);
@@ -208,3 +221,5 @@
-	ctrl_outl(ctrl_inl(DMAOR)&~DMAOR_NMIF, DMAOR);
-	ctrl_outl(ctrl_inl(DMAOR)&~DMAOR_AE, DMAOR);
-	ctrl_outl(ctrl_inl(DMAOR)|DMAOR_DME, DMAOR);
+	/* See if we got an error again */
+	if ((dmaor_read_reg() & (DMAOR_AE | DMAOR_NMIF))) {
+		printk(KERN_ERR "dma-sh: Can't initialize DMAOR.\n");
+		return -EINVAL;
+	}
@@ -211,0 +227,7 @@
+	return 0;
+}
+
+#if defined(CONFIG_CPU_SH4)
+static irqreturn_t dma_err(int irq, void *dev_id, struct pt_regs *regs)
+{
+	dmaor_reset();
@@ -227,2 +249,2 @@
-	.name		= "SuperH DMAC",
-	.nr_channels	= 4,
+	.name		= "sh_dmac",
+	.nr_channels	= CONFIG_NR_ONCHIP_DMA_CHANNELS,
@@ -251 +273,7 @@
-	ctrl_outl(0x8000 | DMAOR_DME, DMAOR);
+	/*
+	 * Initialize DMAOR, and clean up any error flags that may have
+	 * been set.
+	 */
+	i = dmaor_reset();
+	if (i < 0)
+		return i;
@@ -260,0 +289 @@
+	unregister_dmac(&sh_dmac_info);
@@ -265,0 +295,2 @@
+MODULE_AUTHOR("Takashi YOSHII, Paul Mundt, Andriy Skulysh");
+MODULE_DESCRIPTION("SuperH On-Chip DMAC Support");
@@ -267 +297,0 @@
-
--- ./projects/linux/linux-2.6.17/arch/sh/drivers/dma/dma-sh.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/arch/sh/drivers/dma/dma-sh.c	2006-09-20 05:42:06.000000000 +0200
@@ -15 +14,0 @@
-#include <linux/config.h>
@@ -94 +93 @@
-			   SA_INTERRUPT, name, chan);
+			   IRQF_DISABLED, name, chan);
@@ -262 +261 @@
-	i = request_irq(DMAE_IRQ, dma_err, SA_INTERRUPT, "DMAC Address Error", 0);
+	i = request_irq(DMAE_IRQ, dma_err, IRQF_DISABLED, "DMAC Address Error", 0);
--- ./projects/linux/linux-2.6.18/arch/sh/drivers/dma/dma-sh.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/arch/sh/drivers/dma/dma-sh.c	2006-11-29 22:57:37.000000000 +0100
@@ -14 +13,0 @@
-
@@ -16 +14,0 @@
-#include <linux/irq.h>
@@ -20,2 +17,0 @@
-#include <asm/signal.h>
-#include <asm/irq.h>
@@ -26,3 +21,0 @@
-static inline unsigned int get_dmte_irq(unsigned int chan)
-{
-	unsigned int irq = 0;
@@ -29,0 +23,7 @@
+
+#ifdef CONFIG_CPU_SH4
+static struct ipr_data dmae_ipr_map[] = {
+	{ DMAE_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+};
+#endif
+static struct ipr_data dmte_ipr_map[] = {
@@ -35,7 +35,9 @@
-	if (chan < 4) {
-		irq = DMTE0_IRQ + chan;
-	} else {
-#ifdef DMTE4_IRQ
-		irq = DMTE4_IRQ + chan - 4;
-#endif
-	}
+	{ DMTE0_IRQ + 0, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE0_IRQ + 1, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE0_IRQ + 2, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE0_IRQ + 3, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE4_IRQ + 0, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE4_IRQ + 1, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE4_IRQ + 2, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+	{ DMTE4_IRQ + 3, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
+};
@@ -42,0 +45,5 @@
+static inline unsigned int get_dmte_irq(unsigned int chan)
+{
+	unsigned int irq = 0;
+	if (chan < ARRAY_SIZE(dmte_ipr_map))
+		irq = dmte_ipr_map[chan].irq;
@@ -67 +74 @@
-static irqreturn_t dma_tei(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t dma_tei(int irq, void *dev_id)
@@ -69 +76 @@
-	struct dma_channel *chan = (struct dma_channel *)dev_id;
+	struct dma_channel *chan = dev_id;
@@ -87 +94,2 @@
-	char name[32];
+	if (unlikely(!chan->flags & DMA_TEI_CAPABLE))
+		return 0;
@@ -89 +97,4 @@
-	snprintf(name, sizeof(name), "DMAC Transfer End (Channel %d)",
+	chan->name = kzalloc(32, GFP_KERNEL);
+	if (unlikely(chan->name == NULL))
+		return -ENOMEM;
+	snprintf(chan->name, 32, "DMAC Transfer End (Channel %d)",
@@ -93 +104 @@
-			   IRQF_DISABLED, name, chan);
+			   IRQF_DISABLED, chan->name, chan);
@@ -98,0 +110 @@
+	kfree(chan->name);
@@ -230 +242 @@
-static irqreturn_t dma_err(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t dma_err(int irq, void *dummy)
@@ -260 +272 @@
-	make_ipr_irq(DMAE_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
+	make_ipr_irq(dmae_ipr_map, ARRAY_SIZE(dmae_ipr_map));
@@ -262 +274 @@
-	if (i < 0)
+	if (unlikely(i < 0))
@@ -266,5 +278,4 @@
-	for (i = 0; i < info->nr_channels; i++) {
-		int irq = get_dmte_irq(i);
-
-		make_ipr_irq(irq, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY);
-	}
+	i = info->nr_channels;
+	if (i > ARRAY_SIZE(dmte_ipr_map))
+		i = ARRAY_SIZE(dmte_ipr_map);
+	make_ipr_irq(dmte_ipr_map, i);
@@ -277 +288 @@
-	if (i < 0)
+	if (unlikely(i != 0))
--- ./projects/linux/linux-2.6.19/arch/sh/drivers/dma/dma-sh.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/arch/sh/drivers/dma/dma-sh.c	2007-02-04 19:44:54.000000000 +0100
@@ -97,6 +96,0 @@
-	chan->name = kzalloc(32, GFP_KERNEL);
-	if (unlikely(chan->name == NULL))
-		return -ENOMEM;
-	snprintf(chan->name, 32, "DMAC Transfer End (Channel %d)",
-		 chan->chan);
-
@@ -104 +98 @@
-			   IRQF_DISABLED, chan->name, chan);
+			   IRQF_DISABLED, chan->dev_id, chan);
@@ -110 +103,0 @@
-	kfree(chan->name);
--- ./projects/linux/linux-2.6.20/arch/sh/drivers/dma/dma-sh.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/arch/sh/drivers/dma/dma-sh.c	2007-04-26 05:08:32.000000000 +0200
@@ -22,6 +22,12 @@
-
-
-#ifdef CONFIG_CPU_SH4
-static struct ipr_data dmae_ipr_map[] = {
-	{ DMAE_IRQ, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-};
+static int dmte_irq_map[] = {
+	DMTE0_IRQ,
+	DMTE1_IRQ,
+	DMTE2_IRQ,
+	DMTE3_IRQ,
+#if defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
+    defined(CONFIG_CPU_SUBTYPE_SH7760)  ||	\
+    defined(CONFIG_CPU_SUBTYPE_SH7780)
+	DMTE4_IRQ,
+	DMTE5_IRQ,
+	DMTE6_IRQ,
+	DMTE7_IRQ,    
@@ -29,14 +34,0 @@
-static struct ipr_data dmte_ipr_map[] = {
-	/*
-	 * Normally we could just do DMTE0_IRQ + chan outright, though in the
-	 * case of the 7751R, the DMTE IRQs for channels > 4 start right above
-	 * the SCIF
-	 */
-	{ DMTE0_IRQ + 0, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE0_IRQ + 1, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE0_IRQ + 2, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE0_IRQ + 3, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE4_IRQ + 0, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE4_IRQ + 1, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE4_IRQ + 2, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
-	{ DMTE4_IRQ + 3, DMA_IPR_ADDR, DMA_IPR_POS, DMA_PRIORITY },
@@ -48,2 +40,2 @@
-	if (chan < ARRAY_SIZE(dmte_ipr_map))
-		irq = dmte_ipr_map[chan].irq;
+	if (chan < ARRAY_SIZE(dmte_irq_map))
+		irq = dmte_irq_map[chan];
@@ -106 +98 @@
-static void
+static int
@@ -121,0 +114 @@
+	return 0;
@@ -265 +257,0 @@
-	make_ipr_irq(dmae_ipr_map, ARRAY_SIZE(dmae_ipr_map));
@@ -271,5 +262,0 @@
-	i = info->nr_channels;
-	if (i > ARRAY_SIZE(dmte_ipr_map))
-		i = ARRAY_SIZE(dmte_ipr_map);
-	make_ipr_irq(dmte_ipr_map, i);
-
--- ./projects/linux/linux-2.6.23/arch/sh/drivers/dma/dma-sh.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/arch/sh/drivers/dma/dma-sh.c	2008-01-24 23:58:37.000000000 +0100
@@ -27 +27,2 @@
-#if defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
+#if defined(CONFIG_CPU_SUBTYPE_SH7720)  ||	\
+    defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
@@ -28,0 +30 @@
+    defined(CONFIG_CPU_SUBTYPE_SH7709)  ||	\
@@ -31,0 +34,4 @@
+#endif
+#if defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
+    defined(CONFIG_CPU_SUBTYPE_SH7760)  ||	\
+    defined(CONFIG_CPU_SUBTYPE_SH7780)
@@ -33 +39 @@
-	DMTE7_IRQ,    
+	DMTE7_IRQ,
@@ -199 +205,2 @@
-#ifdef CONFIG_CPU_SUBTYPE_SH7780
+#if defined(CONFIG_CPU_SUBTYPE_SH7720) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7780)
--- ./projects/linux/linux-2.6.24/arch/sh/drivers/dma/dma-sh.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/arch/sh/drivers/dma/dma-sh.c	2008-04-17 04:49:44.000000000 +0200
@@ -27,0 +28 @@
+    defined(CONFIG_CPU_SUBTYPE_SH7721)  ||	\
@@ -92 +93 @@
-	if (unlikely(!chan->flags & DMA_TEI_CAPABLE))
+	if (unlikely(!(chan->flags & DMA_TEI_CAPABLE)))
@@ -205,0 +207 @@
+    defined(CONFIG_CPU_SUBTYPE_SH7721) || \
--- ./projects/linux/linux-2.6.26/arch/sh/drivers/dma/dma-sh.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/arch/sh/drivers/dma/dma-sh.c	2008-10-10 00:13:53.000000000 +0200
@@ -17 +17 @@
-#include <asm/dreamcast/dma.h>
+#include <mach-dreamcast/mach/dma.h>
--- ./projects/linux/linux-2.6.28/arch/sh/drivers/dma/dma-sh.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/arch/sh/drivers/dma/dma-sh.c	2009-03-24 00:12:14.000000000 +0100
@@ -208 +208,2 @@
-    defined(CONFIG_CPU_SUBTYPE_SH7780)
+    defined(CONFIG_CPU_SUBTYPE_SH7780) || \
+    defined(CONFIG_CPU_SUBTYPE_SH7709)
--- ./projects/linux/linux-2.6.29/arch/sh/drivers/dma/dma-sh.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/arch/sh/drivers/dma/dma-sh.c	2009-06-27 11:32:30.000000000 +0200
@@ -20 +20 @@
-#include "dma-sh.h"
+#include <asm/dma-sh.h>
@@ -22,19 +22,4 @@
-static int dmte_irq_map[] = {
-	DMTE0_IRQ,
-	DMTE1_IRQ,
-	DMTE2_IRQ,
-	DMTE3_IRQ,
-#if defined(CONFIG_CPU_SUBTYPE_SH7720)  ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7721)  ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7760)  ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7709)  ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7780)
-	DMTE4_IRQ,
-	DMTE5_IRQ,
-#endif
-#if defined(CONFIG_CPU_SUBTYPE_SH7751R) ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7760)  ||	\
-    defined(CONFIG_CPU_SUBTYPE_SH7780)
-	DMTE6_IRQ,
-	DMTE7_IRQ,
+#if defined(DMAE1_IRQ)
+#define NR_DMAE		2
+#else
+#define NR_DMAE		1
@@ -41,0 +27,3 @@
+
+static const char *dmae_name[] = {
+	"DMAC Address Error0", "DMAC Address Error1"
@@ -48,0 +37,6 @@
+
+#if defined(CONFIG_SH_DMA_IRQ_MULTI)
+	if (irq > DMTE6_IRQ)
+		return DMTE6_IRQ;
+	return DMTE0_IRQ;
+#else
@@ -49,0 +44 @@
+#endif
@@ -62 +57 @@
-	u32 chcr = ctrl_inl(CHCR[chan->chan]);
+	u32 chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
@@ -78 +73 @@
-	chcr = ctrl_inl(CHCR[chan->chan]);
+	chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
@@ -84 +79 @@
-	ctrl_outl(chcr, CHCR[chan->chan]);
+	ctrl_outl(chcr, (dma_base_addr[chan->chan] + CHCR));
@@ -97 +92,6 @@
-			   IRQF_DISABLED, chan->dev_id, chan);
+#if defined(CONFIG_SH_DMA_IRQ_MULTI)
+				IRQF_SHARED,
+#else
+				IRQF_DISABLED,
+#endif
+				chan->dev_id, chan);
@@ -118 +118 @@
-	ctrl_outl(chcr, CHCR[chan->chan]);
+	ctrl_outl(chcr, (dma_base_addr[chan->chan] + CHCR));
@@ -129 +129 @@
-	chcr = ctrl_inl(CHCR[chan->chan]);
+	chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
@@ -135 +135 @@
-	ctrl_outl(chcr, CHCR[chan->chan]);
+	ctrl_outl(chcr, (dma_base_addr[chan->chan] + CHCR));
@@ -153 +153 @@
-	chcr = ctrl_inl(CHCR[chan->chan]);
+	chcr = ctrl_inl(dma_base_addr[chan->chan] + CHCR);
@@ -155 +155 @@
-	ctrl_outl(chcr, CHCR[chan->chan]);
+	ctrl_outl(chcr, (dma_base_addr[chan->chan] + CHCR));
@@ -186 +186 @@
-		ctrl_outl(chan->sar, SAR[chan->chan]);
+		ctrl_outl(chan->sar, (dma_base_addr[chan->chan]+SAR));
@@ -189 +189 @@
-		ctrl_outl(chan->dar, DAR[chan->chan]);
+		ctrl_outl(chan->dar, (dma_base_addr[chan->chan] + DAR));
@@ -191 +191,2 @@
-	ctrl_outl(chan->count >> calc_xmit_shift(chan), DMATCR[chan->chan]);
+	ctrl_outl(chan->count >> calc_xmit_shift(chan),
+		(dma_base_addr[chan->chan] + TCR));
@@ -200 +201 @@
-	if (!(ctrl_inl(CHCR[chan->chan]) & CHCR_DE))
+	if (!(ctrl_inl(dma_base_addr[chan->chan] + CHCR) & CHCR_DE))
@@ -203 +204,2 @@
-	return ctrl_inl(DMATCR[chan->chan]) << calc_xmit_shift(chan);
+	return ctrl_inl(dma_base_addr[chan->chan] + TCR)
+		 << calc_xmit_shift(chan);
@@ -206,12 +208 @@
-#if defined(CONFIG_CPU_SUBTYPE_SH7720) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7721) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7780) || \
-    defined(CONFIG_CPU_SUBTYPE_SH7709)
-#define dmaor_read_reg()	ctrl_inw(DMAOR)
-#define dmaor_write_reg(data)	ctrl_outw(data, DMAOR)
-#else
-#define dmaor_read_reg()	ctrl_inl(DMAOR)
-#define dmaor_write_reg(data)	ctrl_outl(data, DMAOR)
-#endif
-
-static inline int dmaor_reset(void)
+static inline int dmaor_reset(int no)
@@ -219 +210 @@
-	unsigned long dmaor = dmaor_read_reg();
+	unsigned long dmaor = dmaor_read_reg(no);
@@ -223 +214 @@
-	dmaor_write_reg(dmaor);
+	dmaor_write_reg(no, dmaor);
@@ -226 +217 @@
-	dmaor_write_reg(dmaor);
+	dmaor_write_reg(no, dmaor);
@@ -229 +220 @@
-	if ((dmaor_read_reg() & (DMAOR_AE | DMAOR_NMIF))) {
+	if ((dmaor_read_reg(no) & (DMAOR_AE | DMAOR_NMIF))) {
@@ -240 +231,23 @@
-	dmaor_reset();
+#if defined(CONFIG_SH_DMA_IRQ_MULTI)
+	int cnt = 0;
+	switch (irq) {
+#if defined(DMTE6_IRQ) && defined(DMAE1_IRQ)
+	case DMTE6_IRQ:
+		cnt++;
+#endif
+	case DMTE0_IRQ:
+		if (dmaor_read_reg(cnt) & (DMAOR_NMIF | DMAOR_AE)) {
+			disable_irq(irq);
+			/* DMA multi and error IRQ */
+			return IRQ_HANDLED;
+		}
+	default:
+		return IRQ_NONE;
+	}
+#else
+	dmaor_reset(0);
+#if defined(CONFIG_CPU_SUBTYPE_SH7723)	|| \
+		defined(CONFIG_CPU_SUBTYPE_SH7780)	|| \
+		defined(CONFIG_CPU_SUBTYPE_SH7785)
+	dmaor_reset(1);
+#endif
@@ -243,0 +257 @@
+#endif
@@ -261,0 +276,16 @@
+#ifdef CONFIG_CPU_SH4
+static unsigned int get_dma_error_irq(int n)
+{
+#if defined(CONFIG_SH_DMA_IRQ_MULTI)
+	return (n == 0) ? get_dmte_irq(0) : get_dmte_irq(6);
+#else
+	return (n == 0) ? DMAE0_IRQ :
+#if defined(DMAE1_IRQ)
+				DMAE1_IRQ;
+#else
+				-1;
+#endif
+#endif
+}
+#endif
+
@@ -268,3 +298,8 @@
-	i = request_irq(DMAE_IRQ, dma_err, IRQF_DISABLED, "DMAC Address Error", 0);
-	if (unlikely(i < 0))
-		return i;
+	int n;
+
+	for (n = 0; n < NR_DMAE; n++) {
+		i = request_irq(get_dma_error_irq(n), dma_err,
+#if defined(CONFIG_SH_DMA_IRQ_MULTI)
+				IRQF_SHARED,
+#else
+				IRQF_DISABLED,
@@ -271,0 +307,7 @@
+				dmae_name[n], (void *)dmae_name[n]);
+		if (unlikely(i < 0)) {
+			printk(KERN_ERR "%s request_irq fail\n", dmae_name[n]);
+			return i;
+		}
+	}
+#endif /* CONFIG_CPU_SH4 */
@@ -277 +319,7 @@
-	i = dmaor_reset();
+	i = dmaor_reset(0);
+	if (unlikely(i != 0))
+		return i;
+#if defined(CONFIG_CPU_SUBTYPE_SH7723)	|| \
+		defined(CONFIG_CPU_SUBTYPE_SH7780)	|| \
+		defined(CONFIG_CPU_SUBTYPE_SH7785)
+	i = dmaor_reset(1);
@@ -279,0 +328 @@
+#endif
@@ -287,2 +336,6 @@
-	free_irq(DMAE_IRQ, 0);
-#endif
+	int n;
+
+	for (n = 0; n < NR_DMAE; n++) {
+		free_irq(get_dma_error_irq(n), (void *)dmae_name[n]);
+	}
+#endif /* CONFIG_CPU_SH4 */
--- ./projects/linux/linux-2.6.13/drivers/acpi/asus_acpi.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/acpi/asus_acpi.c	2005-10-28 02:02:08.000000000 +0200
@@ -64 +64 @@
-#define BR_UP       0x10      		
+#define BR_UP       0x10
@@ -78 +77,0 @@
-
@@ -86 +84,0 @@
-
@@ -90,16 +88,16 @@
-	char *name;              //name of the laptop________________A
-	char *mt_mled;           //method to handle mled_____________R
-	char *mled_status;       //node to handle mled reading_______A
-	char *mt_wled;           //method to handle wled_____________R
-	char *wled_status;       //node to handle wled reading_______A
- 	char *mt_tled;           //method to handle tled_____________R
- 	char *tled_status;       //node to handle tled reading_______A
-	char *mt_lcd_switch;     //method to turn LCD ON/OFF_________A
-	char *lcd_status;        //node to read LCD panel state______A
-	char *brightness_up;     //method to set brightness up_______A
-	char *brightness_down;   //guess what ?______________________A
-	char *brightness_set;    //method to set absolute brightness_R
-	char *brightness_get;    //method to get absolute brightness_R
-	char *brightness_status; //node to get brightness____________A
-	char *display_set;       //method to set video output________R
-	char *display_get;       //method to get video output________R
+	char *name;		//name of the laptop________________A
+	char *mt_mled;		//method to handle mled_____________R
+	char *mled_status;	//node to handle mled reading_______A
+	char *mt_wled;		//method to handle wled_____________R
+	char *wled_status;	//node to handle wled reading_______A
+	char *mt_tled;		//method to handle tled_____________R
+	char *tled_status;	//node to handle tled reading_______A
+	char *mt_lcd_switch;	//method to turn LCD ON/OFF_________A
+	char *lcd_status;	//node to read LCD panel state______A
+	char *brightness_up;	//method to set brightness up_______A
+	char *brightness_down;	//guess what ?______________________A
+	char *brightness_set;	//method to set absolute brightness_R
+	char *brightness_get;	//method to get absolute brightness_R
+	char *brightness_status;	//node to get brightness____________A
+	char *display_set;	//method to set video output________R
+	char *display_get;	//method to get video output________R
@@ -113,5 +111,5 @@
-	struct acpi_device *device; //the device we are in
-	acpi_handle handle;         //the handle of the hotk device
-	char status;                //status of the hotk, for LEDs, ...
-	struct model_data *methods; //methods available on the laptop
-	u8 brightness;              //brightness level
+	struct acpi_device *device;	//the device we are in
+	acpi_handle handle;	//the handle of the hotk device
+	char status;		//status of the hotk, for LEDs, ...
+	struct model_data *methods;	//methods available on the laptop
+	u8 brightness;		//brightness level
@@ -119,19 +117,19 @@
-		A1x = 0,  //A1340D, A1300F
-		A2x,      //A2500H
-		D1x,      //D1
-		L2D,      //L2000D
-		L3C,      //L3800C
-		L3D,      //L3400D
-		L3H,      //L3H, but also L2000E
-		L4R,      //L4500R
-		L5x,      //L5800C 
-		L8L,      //L8400L
-		M1A,      //M1300A
-		M2E,      //M2400E, L4400L
-		M6N,      //M6800N
-		M6R,      //M6700R
-		P30,	  //Samsung P30
-		S1x,      //S1300A, but also L1400B and M2400A (L84F)
-		S2x,      //S200 (J1 reported), Victor MP-XP7210
-		xxN,      //M2400N, M3700N, M5200N, S1300N, S5200N, W1OOON
-			  //(Centrino)
+		A1x = 0,	//A1340D, A1300F
+		A2x,		//A2500H
+		D1x,		//D1
+		L2D,		//L2000D
+		L3C,		//L3800C
+		L3D,		//L3400D
+		L3H,		//L3H, but also L2000E
+		L4R,		//L4500R
+		L5x,		//L5800C 
+		L8L,		//L8400L
+		M1A,		//M1300A
+		M2E,		//M2400E, L4400L
+		M6N,		//M6800N
+		M6R,		//M6700R
+		P30,		//Samsung P30
+		S1x,		//S1300A, but also L1400B and M2400A (L84F)
+		S2x,		//S200 (J1 reported), Victor MP-XP7210
+		xxN,		//M2400N, M3700N, M5200N, S1300N, S5200N, W1OOON
+		//(Centrino)
@@ -139,2 +137,2 @@
-	} model;              //Models currently supported
-	u16 event_count[128]; //count for each event TODO make this better
+	} model;		//Models currently supported
+	u16 event_count[128];	//count for each event TODO make this better
@@ -153 +151 @@
-        /*
+	/*
@@ -168,8 +166,7 @@
-		.name              = "A1x",
-		.mt_mled           = "MLED",
-		.mled_status       = "\\MAIL",
-		.mt_lcd_switch     = A1x_PREFIX "_Q10",
-		.lcd_status        = "\\BKLI",
-		.brightness_up     = A1x_PREFIX "_Q0E",
-		.brightness_down   = A1x_PREFIX "_Q0F"
-	},
+	 .name = "A1x",
+	 .mt_mled = "MLED",
+	 .mled_status = "\\MAIL",
+	 .mt_lcd_switch = A1x_PREFIX "_Q10",
+	 .lcd_status = "\\BKLI",
+	 .brightness_up = A1x_PREFIX "_Q0E",
+	 .brightness_down = A1x_PREFIX "_Q0F"},
@@ -178,11 +175,10 @@
-		.name              = "A2x",
-		.mt_mled           = "MLED",
-		.mt_wled           = "WLED",
-		.wled_status       = "\\SG66",
-		.mt_lcd_switch     = "\\Q10",
-		.lcd_status        = "\\BAOF",
-		.brightness_set    = "SPLV",
-		.brightness_get    = "GPLV",
-		.display_set       = "SDSP",
-		.display_get       = "\\INFB"
-	},
+	 .name = "A2x",
+	 .mt_mled = "MLED",
+	 .mt_wled = "WLED",
+	 .wled_status = "\\SG66",
+	 .mt_lcd_switch = "\\Q10",
+	 .lcd_status = "\\BAOF",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\INFB"},
@@ -191,10 +187,9 @@
-		.name              = "D1x",
-		.mt_mled           = "MLED",
-		.mt_lcd_switch     = "\\Q0D",
-		.lcd_status        = "\\GP11",
-		.brightness_up     = "\\Q0C",
-		.brightness_down   = "\\Q0B",
-		.brightness_status = "\\BLVL",
-		.display_set       = "SDSP",
-		.display_get       = "\\INFB"
-	},
+	 .name = "D1x",
+	 .mt_mled = "MLED",
+	 .mt_lcd_switch = "\\Q0D",
+	 .lcd_status = "\\GP11",
+	 .brightness_up = "\\Q0C",
+	 .brightness_down = "\\Q0B",
+	 .brightness_status = "\\BLVL",
+	 .display_set = "SDSP",
+	 .display_get = "\\INFB"},
@@ -203,12 +198,11 @@
-		.name              = "L2D",
-		.mt_mled           = "MLED",
-		.mled_status       = "\\SGP6",
-		.mt_wled           = "WLED",
-		.wled_status       = "\\RCP3",
-		.mt_lcd_switch     = "\\Q10",
-		.lcd_status        = "\\SGP0",
-		.brightness_up     = "\\Q0E",
-		.brightness_down   = "\\Q0F",
-		.display_set       = "SDSP",
-		.display_get       = "\\INFB"
-	},
+	 .name = "L2D",
+	 .mt_mled = "MLED",
+	 .mled_status = "\\SGP6",
+	 .mt_wled = "WLED",
+	 .wled_status = "\\RCP3",
+	 .mt_lcd_switch = "\\Q10",
+	 .lcd_status = "\\SGP0",
+	 .brightness_up = "\\Q0E",
+	 .brightness_down = "\\Q0F",
+	 .display_set = "SDSP",
+	 .display_get = "\\INFB"},
@@ -217,10 +211,9 @@
-		.name              = "L3C",
-		.mt_mled           = "MLED",
-		.mt_wled           = "WLED",
-		.mt_lcd_switch     = L3C_PREFIX "_Q10",
-		.lcd_status        = "\\GL32",
-		.brightness_set    = "SPLV",
-		.brightness_get    = "GPLV",
-		.display_set       = "SDSP",
-		.display_get       = "\\_SB.PCI0.PCI1.VGAC.NMAP"
-	},
+	 .name = "L3C",
+	 .mt_mled = "MLED",
+	 .mt_wled = "WLED",
+	 .mt_lcd_switch = L3C_PREFIX "_Q10",
+	 .lcd_status = "\\GL32",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\_SB.PCI0.PCI1.VGAC.NMAP"},
@@ -229,11 +222,10 @@
-		.name              = "L3D",
-		.mt_mled           = "MLED",
-		.mled_status       = "\\MALD",
-		.mt_wled           = "WLED",
-		.mt_lcd_switch     = "\\Q10",
-		.lcd_status        = "\\BKLG",
-		.brightness_set    = "SPLV",
-		.brightness_get    = "GPLV",
-		.display_set       = "SDSP",
-		.display_get       = "\\INFB"
-	},
+	 .name = "L3D",
+	 .mt_mled = "MLED",
+	 .mled_status = "\\MALD",
+	 .mt_wled = "WLED",
+	 .mt_lcd_switch = "\\Q10",
+	 .lcd_status = "\\BKLG",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\INFB"},
@@ -242,10 +234,9 @@
-		.name              = "L3H",
-		.mt_mled           = "MLED",
-		.mt_wled           = "WLED",
-		.mt_lcd_switch     = "EHK",
-		.lcd_status        = "\\_SB.PCI0.PM.PBC",
-		.brightness_set    = "SPLV",
-		.brightness_get    = "GPLV",
-		.display_set       = "SDSP",
-		.display_get       = "\\INFB"
-	},
+	 .name = "L3H",
+	 .mt_mled = "MLED",
+	 .mt_wled = "WLED",
+	 .mt_lcd_switch = "EHK",
+	 .lcd_status = "\\_SB.PCI0.PM.PBC",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\INFB"},
@@ -254,11 +245,10 @@
-		.name              = "L4R",
-		.mt_mled           = "MLED",
-		.mt_wled           = "WLED",
-		.wled_status       = "\\_SB.PCI0.SBRG.SG13",
-		.mt_lcd_switch     = xxN_PREFIX "_Q10",
-		.lcd_status        = "\\_SB.PCI0.SBSM.SEO4",
-		.brightness_set    = "SPLV",
-		.brightness_get    = "GPLV", 
-		.display_set       = "SDSP",
-		.display_get       = "\\_SB.PCI0.P0P1.VGA.GETD"
-	},
+	 .name = "L4R",
+	 .mt_mled = "MLED",
+	 .mt_wled = "WLED",
+	 .wled_status = "\\_SB.PCI0.SBRG.SG13",
+	 .mt_lcd_switch = xxN_PREFIX "_Q10",
+	 .lcd_status = "\\_SB.PCI0.SBSM.SEO4",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\_SB.PCI0.P0P1.VGA.GETD"},
@@ -267,2 +257,2 @@
-		.name              = "L5x",
-		.mt_mled           = "MLED",
+	 .name = "L5x",
+	 .mt_mled = "MLED",
@@ -270,8 +260,7 @@
-		.mt_tled           = "TLED",
-		.mt_lcd_switch     = "\\Q0D",
-		.lcd_status        = "\\BAOF",
-		.brightness_set    = "SPLV",
-		.brightness_get    = "GPLV",
-		.display_set       = "SDSP",
-		.display_get       = "\\INFB"
-	},
+	 .mt_tled = "TLED",
+	 .mt_lcd_switch = "\\Q0D",
+	 .lcd_status = "\\BAOF",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\INFB"},
@@ -280 +269 @@
-		.name              = "L8L"
+	 .name = "L8L"
@@ -282 +271 @@
-	},
+	 },
@@ -285,10 +274,9 @@
-		.name              = "M1A",
-		.mt_mled           = "MLED",
-		.mt_lcd_switch     = M1A_PREFIX "Q10",
-		.lcd_status        = "\\PNOF",
-		.brightness_up     = M1A_PREFIX "Q0E",
-		.brightness_down   = M1A_PREFIX "Q0F",
-		.brightness_status = "\\BRIT",
-		.display_set       = "SDSP",
-		.display_get       = "\\INFB"
-	},
+	 .name = "M1A",
+	 .mt_mled = "MLED",
+	 .mt_lcd_switch = M1A_PREFIX "Q10",
+	 .lcd_status = "\\PNOF",
+	 .brightness_up = M1A_PREFIX "Q0E",
+	 .brightness_down = M1A_PREFIX "Q0F",
+	 .brightness_status = "\\BRIT",
+	 .display_set = "SDSP",
+	 .display_get = "\\INFB"},
@@ -297,10 +285,9 @@
-		.name              = "M2E",
-		.mt_mled           = "MLED",
-		.mt_wled           = "WLED",
-		.mt_lcd_switch     = "\\Q10",
-		.lcd_status        = "\\GP06",
-		.brightness_set    = "SPLV",
-		.brightness_get    = "GPLV",
-		.display_set       = "SDSP",
-		.display_get       = "\\INFB"
-	},
+	 .name = "M2E",
+	 .mt_mled = "MLED",
+	 .mt_wled = "WLED",
+	 .mt_lcd_switch = "\\Q10",
+	 .lcd_status = "\\GP06",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\INFB"},
@@ -309,11 +296,10 @@
-		.name              = "M6N",
-		.mt_mled           = "MLED",
-		.mt_wled           = "WLED",
-		.wled_status       = "\\_SB.PCI0.SBRG.SG13",
-		.mt_lcd_switch     = xxN_PREFIX "_Q10",
-		.lcd_status        = "\\_SB.BKLT",
-		.brightness_set    = "SPLV",
-		.brightness_get    = "GPLV",
-		.display_set       = "SDSP",
-		.display_get       = "\\SSTE"
-	},
+	 .name = "M6N",
+	 .mt_mled = "MLED",
+	 .mt_wled = "WLED",
+	 .wled_status = "\\_SB.PCI0.SBRG.SG13",
+	 .mt_lcd_switch = xxN_PREFIX "_Q10",
+	 .lcd_status = "\\_SB.BKLT",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\SSTE"},
@@ -321,11 +307,9 @@
-		.name              = "M6R",
-		.mt_mled           = "MLED",
-		.mt_wled           = "WLED",
-		.mt_lcd_switch     = xxN_PREFIX "_Q10",
-		.lcd_status        = "\\_SB.PCI0.SBSM.SEO4",
-		.brightness_set    = "SPLV",
-		.brightness_get    = "GPLV",
-		.display_set       = "SDSP",
-		.display_get       = "\\SSTE"
-	},
-
+	 .name = "M6R",
+	 .mt_mled = "MLED",
+	 .mt_wled = "WLED",
+	 .mt_lcd_switch = xxN_PREFIX "_Q10",
+	 .lcd_status = "\\_SB.PCI0.SBSM.SEO4",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\SSTE"},
@@ -334,10 +318,9 @@
-		.name              = "P30",
-		.mt_wled           = "WLED",
-		.mt_lcd_switch     = P30_PREFIX "_Q0E",
-		.lcd_status        = "\\BKLT",
-		.brightness_up     = P30_PREFIX "_Q68",
-		.brightness_down   = P30_PREFIX "_Q69",
-		.brightness_get    = "GPLV",
-		.display_set       = "SDSP",
-		.display_get       = "\\DNXT"
-	},
+	 .name = "P30",
+	 .mt_wled = "WLED",
+	 .mt_lcd_switch = P30_PREFIX "_Q0E",
+	 .lcd_status = "\\BKLT",
+	 .brightness_up = P30_PREFIX "_Q68",
+	 .brightness_down = P30_PREFIX "_Q69",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\DNXT"},
@@ -346,9 +329,8 @@
-		.name              = "S1x",
-		.mt_mled           = "MLED",
-		.mled_status       = "\\EMLE",
-		.mt_wled           = "WLED",
-		.mt_lcd_switch     = S1x_PREFIX "Q10" ,
-		.lcd_status        = "\\PNOF",
-		.brightness_set    = "SPLV",
-		.brightness_get    = "GPLV"
-	},
+	 .name = "S1x",
+	 .mt_mled = "MLED",
+	 .mled_status = "\\EMLE",
+	 .mt_wled = "WLED",
+	 .mt_lcd_switch = S1x_PREFIX "Q10",
+	 .lcd_status = "\\PNOF",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV"},
@@ -357,8 +339,7 @@
-		.name              = "S2x",
-		.mt_mled           = "MLED",
-		.mled_status       = "\\MAIL",
-		.mt_lcd_switch     = S2x_PREFIX "_Q10",
-		.lcd_status        = "\\BKLI",
-		.brightness_up     = S2x_PREFIX "_Q0B",
-		.brightness_down   = S2x_PREFIX "_Q0A"
-	},
+	 .name = "S2x",
+	 .mt_mled = "MLED",
+	 .mled_status = "\\MAIL",
+	 .mt_lcd_switch = S2x_PREFIX "_Q10",
+	 .lcd_status = "\\BKLI",
+	 .brightness_up = S2x_PREFIX "_Q0B",
+	 .brightness_down = S2x_PREFIX "_Q0A"},
@@ -367,2 +348,2 @@
-		.name              = "xxN",
-		.mt_mled           = "MLED",
+	 .name = "xxN",
+	 .mt_mled = "MLED",
@@ -370,7 +351,6 @@
-		.mt_lcd_switch     = xxN_PREFIX "_Q10",
-		.lcd_status        = "\\BKLT",
-		.brightness_set    = "SPLV",
-		.brightness_get    = "GPLV",
-		.display_set       = "SDSP",
-		.display_get       = "\\ADVG"
-	}
+	 .mt_lcd_switch = xxN_PREFIX "_Q10",
+	 .lcd_status = "\\BKLT",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\ADVG"}
@@ -398,7 +378,7 @@
-	.name = 	ACPI_HOTK_NAME,
-	.class = 	ACPI_HOTK_CLASS,
-	.ids = 		ACPI_HOTK_HID,
-	.ops = 		{
-				.add = 		asus_hotk_add,
-				.remove = 	asus_hotk_remove,
-			},
+	.name = ACPI_HOTK_NAME,
+	.class = ACPI_HOTK_CLASS,
+	.ids = ACPI_HOTK_HID,
+	.ops = {
+		.add = asus_hotk_add,
+		.remove = asus_hotk_remove,
+		},
@@ -426 +406 @@
-	status = acpi_evaluate_object(handle, (char *) method, &params, output);
+	status = acpi_evaluate_object(handle, (char *)method, &params, output);
@@ -430 +409,0 @@
-
@@ -440 +419 @@
-	status = acpi_evaluate_object(handle, (char *) method, NULL, &output);
+	status = acpi_evaluate_object(handle, (char *)method, NULL, &output);
@@ -452 +431 @@
-		void *data)
+	       void *data)
@@ -463 +442 @@
-	len += sprintf(page + len, "Model reference    : %s\n", 
+	len += sprintf(page + len, "Model reference    : %s\n",
@@ -472 +451,2 @@
-		len += sprintf(page + len, "SFUN value         : 0x%04x\n", temp);
+		len +=
+		    sprintf(page + len, "SFUN value         : 0x%04x\n", temp);
@@ -481 +461,2 @@
-		len += sprintf(page + len, "ASYM value         : 0x%04x\n", temp);
+		len +=
+		    sprintf(page + len, "ASYM value         : 0x%04x\n", temp);
@@ -504 +484,0 @@
-
@@ -513,2 +493 @@
-static int
-read_led(const char *ledname, int ledmask)
+static int read_led(const char *ledname, int ledmask)
@@ -528 +507 @@
-static int parse_arg(const char __user *buf, unsigned long count, int *val)
+static int parse_arg(const char __user * buf, unsigned long count, int *val)
@@ -545,2 +524,2 @@
-write_led(const char __user *buffer, unsigned long count,
-          char *ledname, int ledmask, int invert)
+write_led(const char __user * buffer, unsigned long count,
+	  char *ledname, int ledmask, int invert)
@@ -558 +537 @@
-	if (invert) /* invert target value */
+	if (invert)		/* invert target value */
@@ -562 +541,2 @@
-		printk(KERN_WARNING "Asus ACPI: LED (%s) write failed\n", ledname);
+		printk(KERN_WARNING "Asus ACPI: LED (%s) write failed\n",
+		       ledname);
@@ -567 +546,0 @@
-
@@ -575 +554,2 @@
-	return sprintf(page, "%d\n", read_led(hotk->methods->mled_status, MLED_ON));
+	return sprintf(page, "%d\n",
+		       read_led(hotk->methods->mled_status, MLED_ON));
@@ -578 +557,0 @@
-
@@ -580 +559 @@
-proc_write_mled(struct file *file, const char __user *buffer,
+proc_write_mled(struct file *file, const char __user * buffer,
@@ -593 +572,2 @@
-	return sprintf(page, "%d\n", read_led(hotk->methods->wled_status, WLED_ON));
+	return sprintf(page, "%d\n",
+		       read_led(hotk->methods->wled_status, WLED_ON));
@@ -597 +577 @@
-proc_write_wled(struct file *file, const char __user *buffer,
+proc_write_wled(struct file *file, const char __user * buffer,
@@ -610 +590,2 @@
-	return sprintf(page, "%d\n", read_led(hotk->methods->tled_status, TLED_ON));
+	return sprintf(page, "%d\n",
+		       read_led(hotk->methods->tled_status, TLED_ON));
@@ -614 +595 @@
-proc_write_tled(struct file *file, const char __user *buffer,
+proc_write_tled(struct file *file, const char __user * buffer,
@@ -620 +600,0 @@
-
@@ -626 +606 @@
-	/* We don't have to check anything if we are here */
+		/* We don't have to check anything if we are here */
@@ -628,2 +608,3 @@
-			printk(KERN_WARNING "Asus ACPI: Error reading LCD status\n");
-	
+			printk(KERN_WARNING
+			       "Asus ACPI: Error reading LCD status\n");
+
@@ -632 +613 @@
-	} else { /* L3H and the like have to be handled differently */
+	} else {		/* L3H and the like have to be handled differently */
@@ -638 +619 @@
-		
+
@@ -650,2 +631,4 @@
-		
-		status = acpi_evaluate_object(NULL, hotk->methods->lcd_status, &input, &output);
+
+		status =
+		    acpi_evaluate_object(NULL, hotk->methods->lcd_status,
+					 &input, &output);
@@ -658 +641 @@
-	
+
@@ -672 +655,2 @@
-			    acpi_evaluate_object(NULL, hotk->methods->mt_lcd_switch,
+			    acpi_evaluate_object(NULL,
+						 hotk->methods->mt_lcd_switch,
@@ -674,2 +658,4 @@
-		} else { /* L3H and the like have to be handled differently */
-			if (!write_acpi_int(hotk->handle, hotk->methods->mt_lcd_switch, 0x07, NULL))
+		} else {	/* L3H and the like have to be handled differently */
+			if (!write_acpi_int
+			    (hotk->handle, hotk->methods->mt_lcd_switch, 0x07,
+			     NULL))
@@ -694 +679,0 @@
-
@@ -696 +681 @@
-proc_write_lcd(struct file *file, const char __user *buffer,
+proc_write_lcd(struct file *file, const char __user * buffer,
@@ -700 +685 @@
-	
+
@@ -707 +691,0 @@
-
@@ -711,3 +695,3 @@
-	
-	if(hotk->methods->brightness_get) { /* SPLV/GPLV laptop */
-		if (!read_acpi_int(hotk->handle, hotk->methods->brightness_get, 
+
+	if (hotk->methods->brightness_get) {	/* SPLV/GPLV laptop */
+		if (!read_acpi_int(hotk->handle, hotk->methods->brightness_get,
@@ -715,3 +699,4 @@
-			printk(KERN_WARNING "Asus ACPI: Error reading brightness\n");
-	} else if (hotk->methods->brightness_status) { /* For D1 for example */
-		if (!read_acpi_int(NULL, hotk->methods->brightness_status, 
+			printk(KERN_WARNING
+			       "Asus ACPI: Error reading brightness\n");
+	} else if (hotk->methods->brightness_status) {	/* For D1 for example */
+		if (!read_acpi_int(NULL, hotk->methods->brightness_status,
@@ -719,2 +704,3 @@
-			printk(KERN_WARNING "Asus ACPI: Error reading brightness\n");
-	} else /* No GPLV method */
+			printk(KERN_WARNING
+			       "Asus ACPI: Error reading brightness\n");
+	} else			/* No GPLV method */
@@ -733,2 +719,2 @@
-	if(hotk->methods->brightness_set) {
-		if (!write_acpi_int(hotk->handle, hotk->methods->brightness_set, 
+	if (hotk->methods->brightness_set) {
+		if (!write_acpi_int(hotk->handle, hotk->methods->brightness_set,
@@ -736 +722,2 @@
-			printk(KERN_WARNING "Asus ACPI: Error changing brightness\n");
+			printk(KERN_WARNING
+			       "Asus ACPI: Error changing brightness\n");
@@ -743,2 +730,2 @@
-		status = acpi_evaluate_object(NULL, (value > 0) ? 
-					      hotk->methods->brightness_up : 
+		status = acpi_evaluate_object(NULL, (value > 0) ?
+					      hotk->methods->brightness_up :
@@ -749 +736,2 @@
-			printk(KERN_WARNING "Asus ACPI: Error changing brightness\n");
+			printk(KERN_WARNING
+			       "Asus ACPI: Error changing brightness\n");
@@ -762 +750 @@
-proc_write_brn(struct file *file, const char __user *buffer,
+proc_write_brn(struct file *file, const char __user * buffer,
@@ -770 +758 @@
-			/* 0 <= value <= 15 */
+		/* 0 <= value <= 15 */
@@ -782 +770 @@
-	if (!write_acpi_int(hotk->handle, hotk->methods->display_set, 
+	if (!write_acpi_int(hotk->handle, hotk->methods->display_set,
@@ -794 +782 @@
-	      void *data)
+	       void *data)
@@ -797 +785 @@
-	
+
@@ -799,2 +787,3 @@
-		printk(KERN_WARNING "Asus ACPI: Error reading display status\n");
-	value &= 0x07; /* needed for some models, shouldn't hurt others */
+		printk(KERN_WARNING
+		       "Asus ACPI: Error reading display status\n");
+	value &= 0x07;		/* needed for some models, shouldn't hurt others */
@@ -811,2 +800,2 @@
-proc_write_disp(struct file *file, const char __user *buffer,
-	       unsigned long count, void *data)
+proc_write_disp(struct file *file, const char __user * buffer,
+		unsigned long count, void *data)
@@ -825,5 +814,4 @@
-
-typedef int (proc_readfunc)(char *page, char **start, off_t off, int count,
-	                     int *eof, void *data);
-typedef int (proc_writefunc)(struct file *file, const char __user *buffer,
-	                      unsigned long count, void *data);
+typedef int (proc_readfunc) (char *page, char **start, off_t off, int count,
+			     int *eof, void *data);
+typedef int (proc_writefunc) (struct file * file, const char __user * buffer,
+			      unsigned long count, void *data);
@@ -832,6 +820,7 @@
-__init asus_proc_add(char *name, proc_writefunc *writefunc,
-	             proc_readfunc *readfunc, mode_t mode,
-	             struct acpi_device *device)
-{
-	struct proc_dir_entry *proc = create_proc_entry(name, mode, acpi_device_dir(device));
-	if(!proc) {
+__init asus_proc_add(char *name, proc_writefunc * writefunc,
+		     proc_readfunc * readfunc, mode_t mode,
+		     struct acpi_device *device)
+{
+	struct proc_dir_entry *proc =
+	    create_proc_entry(name, mode, acpi_device_dir(device));
+	if (!proc) {
@@ -854 +843 @@
-	
+
@@ -861 +850 @@
-	if ((asus_uid == 0) && (asus_gid == 0)){
+	if ((asus_uid == 0) && (asus_gid == 0)) {
@@ -884 +873,2 @@
-		asus_proc_add(PROC_WLED, &proc_write_wled, &proc_read_wled, mode, device);
+		asus_proc_add(PROC_WLED, &proc_write_wled, &proc_read_wled,
+			      mode, device);
@@ -888 +878,2 @@
-		asus_proc_add(PROC_MLED, &proc_write_mled, &proc_read_mled, mode, device);
+		asus_proc_add(PROC_MLED, &proc_write_mled, &proc_read_mled,
+			      mode, device);
@@ -892 +883,2 @@
-		asus_proc_add(PROC_TLED, &proc_write_tled, &proc_read_tled, mode, device);
+		asus_proc_add(PROC_TLED, &proc_write_tled, &proc_read_tled,
+			      mode, device);
@@ -900 +892,2 @@
-		asus_proc_add(PROC_LCD, &proc_write_lcd, &proc_read_lcd, mode, device);
+		asus_proc_add(PROC_LCD, &proc_write_lcd, &proc_read_lcd, mode,
+			      device);
@@ -902 +895 @@
-	
+
@@ -905 +898,2 @@
-		asus_proc_add(PROC_BRN, &proc_write_brn, &proc_read_brn, mode, device);
+		asus_proc_add(PROC_BRN, &proc_write_brn, &proc_read_brn, mode,
+			      device);
@@ -909 +903,2 @@
-		asus_proc_add(PROC_DISP, &proc_write_disp, &proc_read_disp, mode, device);
+		asus_proc_add(PROC_DISP, &proc_write_disp, &proc_read_disp,
+			      mode, device);
@@ -915 +910 @@
-static int asus_hotk_remove_fs(struct acpi_device* device)
+static int asus_hotk_remove_fs(struct acpi_device *device)
@@ -917,2 +912,2 @@
-	if(acpi_device_dir(device)) {
-		remove_proc_entry(PROC_INFO,acpi_device_dir(device));
+	if (acpi_device_dir(device)) {
+		remove_proc_entry(PROC_INFO, acpi_device_dir(device));
@@ -920 +915 @@
-			remove_proc_entry(PROC_WLED,acpi_device_dir(device));
+			remove_proc_entry(PROC_WLED, acpi_device_dir(device));
@@ -922 +917 @@
-			remove_proc_entry(PROC_MLED,acpi_device_dir(device));
+			remove_proc_entry(PROC_MLED, acpi_device_dir(device));
@@ -924 +919 @@
-			remove_proc_entry(PROC_TLED,acpi_device_dir(device));
+			remove_proc_entry(PROC_TLED, acpi_device_dir(device));
@@ -927,2 +922,4 @@
-		if ((hotk->methods->brightness_up && hotk->methods->brightness_down) ||
-		    (hotk->methods->brightness_get && hotk->methods->brightness_set))
+		if ((hotk->methods->brightness_up
+		     && hotk->methods->brightness_down)
+		    || (hotk->methods->brightness_get
+			&& hotk->methods->brightness_set))
@@ -936 +932,0 @@
-
@@ -939 +935 @@
-	/* TODO Find a better way to handle events count.*/
+	/* TODO Find a better way to handle events count. */
@@ -945 +941 @@
-	} else if ((event & ~((u32) BR_DOWN)) < 16 ) {
+	} else if ((event & ~((u32) BR_DOWN)) < 16) {
@@ -979 +975 @@
-		asus_info = (struct acpi_table_header *) dsdt.pointer;
+		asus_info = (struct acpi_table_header *)dsdt.pointer;
@@ -991 +987,2 @@
-		printk(KERN_NOTICE "  BSTS called, 0x%02x returned\n", bsts_result);
+		printk(KERN_NOTICE "  BSTS called, 0x%02x returned\n",
+		       bsts_result);
@@ -996 +993 @@
-		if (asus_info && /* Samsung P30 */
+		if (asus_info &&	/* Samsung P30 */
@@ -999 +996,2 @@
-			printk(KERN_NOTICE "  Samsung P30 detected, supported\n");
+			printk(KERN_NOTICE
+			       "  Samsung P30 detected, supported\n");
@@ -1009,2 +1007,2 @@
-	
-	model = (union acpi_object *) buffer.pointer;
+
+	model = (union acpi_object *)buffer.pointer;
@@ -1012 +1010,2 @@
-		printk(KERN_NOTICE "  %s model detected, ", model->string.pointer);
+		printk(KERN_NOTICE "  %s model detected, ",
+		       model->string.pointer);
@@ -1038 +1037 @@
-                 strncmp(model->string.pointer, "W1N", 3) == 0)
+		 strncmp(model->string.pointer, "W1N", 3) == 0)
@@ -1072 +1071 @@
-		hotk->methods->lcd_status = NULL; 
+		hotk->methods->lcd_status = NULL;
@@ -1077 +1076 @@
-		hotk->methods->mt_mled = NULL; 
+		hotk->methods->mt_mled = NULL;
@@ -1081 +1080 @@
-		hotk->methods->mt_wled = "WLED"; 
+		hotk->methods->mt_wled = "WLED";
@@ -1086 +1085 @@
-	/* S1300A reports L84F, but L1400B too, account for that */
+		/* S1300A reports L84F, but L1400B too, account for that */
@@ -1094 +1092,0 @@
-
@@ -1113 +1110,0 @@
-
@@ -1126 +1123 @@
-	    (struct asus_hotk *) kmalloc(sizeof(struct asus_hotk), GFP_KERNEL);
+	    (struct asus_hotk *)kmalloc(sizeof(struct asus_hotk), GFP_KERNEL);
@@ -1137 +1133,0 @@
-
@@ -1156,4 +1152,7 @@
-	if ((!hotk->methods->brightness_get) && (!hotk->methods->brightness_status) &&
-	    (hotk->methods->brightness_up && hotk->methods->brightness_down)) {
-		status = acpi_evaluate_object(NULL, hotk->methods->brightness_down,
-					      NULL, NULL);
+	if ((!hotk->methods->brightness_get)
+	    && (!hotk->methods->brightness_status)
+	    && (hotk->methods->brightness_up
+		&& hotk->methods->brightness_down)) {
+		status =
+		    acpi_evaluate_object(NULL, hotk->methods->brightness_down,
+					 NULL, NULL);
@@ -1163,2 +1162,4 @@
-			status = acpi_evaluate_object(NULL, hotk->methods->brightness_up,
-						      NULL, NULL);
+			status =
+			    acpi_evaluate_object(NULL,
+						 hotk->methods->brightness_up,
+						 NULL, NULL);
@@ -1166 +1167 @@
-				printk(KERN_WARNING "  Strange, error changing" 
+				printk(KERN_WARNING "  Strange, error changing"
@@ -1179 +1179,0 @@
-
@@ -1199 +1198,0 @@
-
@@ -1207 +1206 @@
-	if (!acpi_specific_hotkey_enabled){
+	if (!acpi_specific_hotkey_enabled) {
@@ -1209 +1208 @@
-		return -ENODEV;	
+		return -ENODEV;
@@ -1228 +1226,0 @@
-
--- ./projects/linux/linux-2.6.15/drivers/acpi/asus_acpi.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/acpi/asus_acpi.c	2006-03-20 06:53:29.000000000 +0100
@@ -81 +81 @@
-MODULE_PARM_DESC(uid, "UID for entries in /proc/acpi/asus.\n");
+MODULE_PARM_DESC(asus_uid, "UID for entries in /proc/acpi/asus.\n");
@@ -83 +83 @@
-MODULE_PARM_DESC(gid, "GID for entries in /proc/acpi/asus.\n");
+MODULE_PARM_DESC(asus_gid, "GID for entries in /proc/acpi/asus.\n");
@@ -305 +305 @@
-	 .display_get = "\\SSTE"},
+	 .display_get = "\\_SB.PCI0.P0P1.VGA.GETD"},
@@ -853,0 +854,2 @@
+		printk(KERN_WARNING "  asus_uid and asus_gid parameters are "
+		       "deprecated, use chown and chmod instead!\n");
@@ -990,3 +992,15 @@
-	/* Samsung P30 has a device with a valid _HID whose INIT does not 
-	 * return anything. Catch this one and any similar here */
-	if (buffer.pointer == NULL) {
+	/* This is unlikely with implicit return */
+	if (buffer.pointer == NULL)
+		return -EINVAL;
+
+	model = (union acpi_object *) buffer.pointer;
+	/*
+	 * Samsung P30 has a device with a valid _HID whose INIT does not 
+	 * return anything. It used to be possible to catch this exception,
+	 * but the implicit return code will now happily confuse the 
+	 * driver. We assume that every ACPI_TYPE_STRING is a valid model
+	 * identifier but it's still possible to get completely bogus data.
+	 */
+	if (model->type == ACPI_TYPE_STRING) {
+		printk(KERN_NOTICE "  %s model detected, ", model->string.pointer);
+	} else {
@@ -1005,2 +1019,2 @@
-		return AE_OK;
-	}
+		
+		acpi_os_free(model);
@@ -1008,4 +1022 @@
-	model = (union acpi_object *)buffer.pointer;
-	if (model->type == ACPI_TYPE_STRING) {
-		printk(KERN_NOTICE "  %s model detected, ",
-		       model->string.pointer);
+		return AE_OK;
--- ./projects/linux/linux-2.6.17/drivers/acpi/asus_acpi.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/acpi/asus_acpi.c	2006-09-20 05:42:06.000000000 +0200
@@ -5 +5 @@
- *  Copyright (C) 2002, 2003, 2004 Julien Lerouge, Karol Kozimor
+ *  Copyright (C) 2002-2005 Julien Lerouge, 2003-2006 Karol Kozimor
@@ -28,0 +29 @@
+ *  ric Burghard  - LED display support for W1N
@@ -30,4 +30,0 @@
- *  TODO:
- *  add Fn key status
- *  Add mode selection on module loading (parameter) -> still necessary?
- *  Complete display switching -- may require dirty hacks or calling _DOS?
@@ -45 +42 @@
-#define ASUS_ACPI_VERSION "0.29"
+#define ASUS_ACPI_VERSION "0.30"
@@ -50,0 +48,2 @@
+#define PROC_BT         "bluetooth"
+#define PROC_LEDD       "ledd"
@@ -70,3 +69,4 @@
-#define MLED_ON     0x01	//is MLED ON ?
-#define WLED_ON     0x02
-#define TLED_ON     0x04
+#define MLED_ON     0x01	//mail LED
+#define WLED_ON     0x02	//wireless LED
+#define TLED_ON     0x04	//touchpad LED
+#define BT_ON       0x08	//internal Bluetooth
@@ -95 +95,4 @@
-	char *mt_lcd_switch;	//method to turn LCD ON/OFF_________A
+	char *mt_ledd;		//method to handle LED display______R
+	char *mt_bt_switch;	//method to switch Bluetooth on/off_R
+	char *bt_status;	//no model currently supports this__?
+	char *mt_lcd_switch;	//method to turn LCD on/off_________A
@@ -113,0 +117 @@
+	u32 ledd_status;	//status of the LED display
@@ -118,0 +123 @@
+		A4G,		//A4700G
@@ -123 +128 @@
-		L3H,		//L3H, but also L2000E
+		L3H,		//L3H, L2000E, L5D
@@ -129,2 +134,2 @@
-		M6N,		//M6800N
-		M6R,		//M6700R
+		M6N,		//M6800N, W3400N
+		M6R,		//M6700R, A3000G
@@ -134 +139,3 @@
-		xxN,		//M2400N, M3700N, M5200N, S1300N, S5200N, W1OOON
+		W1N,		//W1000N
+		W5A,		//W5A
+		xxN,		//M2400N, M3700N, M5200N, M6800N, S1300N, S5200N
@@ -152,8 +158,0 @@
-	 * Those pathnames are relative to the HOTK / ATKD device :
-	 *       - mt_mled
-	 *       - mt_wled
-	 *       - brightness_set
-	 *       - brightness_get
-	 *       - display_set
-	 *       - display_get
-	 *
@@ -162 +160,0 @@
-	 *
@@ -186,0 +185,10 @@
+	 .name = "A4G",
+	 .mt_mled = "MLED",
+/* WLED present, but not controlled by ACPI */
+	 .mt_lcd_switch = xxN_PREFIX "_Q10",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\ADVG"},
+
+	{
@@ -305 +313,2 @@
-	 .display_get = "\\_SB.PCI0.P0P1.VGA.GETD"},
+	 .display_get = "\\SSTE"},
+
@@ -315 +324 @@
-	 .display_get = "\\SSTE"},
+	 .display_get = "\\_SB.PCI0.P0P1.VGA.GETD"},
@@ -347,0 +357,22 @@
+	 .name = "W1N",
+	 .mt_mled = "MLED",
+	 .mt_wled = "WLED",
+	 .mt_ledd = "SLCM",
+	 .mt_lcd_switch = xxN_PREFIX "_Q10",
+	 .lcd_status = "\\BKLT",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\ADVG"},
+
+	{
+	 .name = "W5A",
+	 .mt_bt_switch = "BLED",
+	 .mt_wled = "WLED",
+	 .mt_lcd_switch = xxN_PREFIX "_Q10",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\ADVG"},
+
+	{
@@ -565,0 +597,30 @@
+ * Proc handlers for LED display
+ */
+static int
+proc_read_ledd(char *page, char **start, off_t off, int count, int *eof,
+	       void *data)
+{
+	return sprintf(page, "0x%08x\n", hotk->ledd_status);
+}
+
+static int
+proc_write_ledd(struct file *file, const char __user * buffer,
+		unsigned long count, void *data)
+{
+	int value;
+
+	count = parse_arg(buffer, count, &value);
+	if (count > 0) {
+		if (!write_acpi_int
+		    (hotk->handle, hotk->methods->mt_ledd, value, NULL))
+			printk(KERN_WARNING
+			       "Asus ACPI: LED display write failed\n");
+		else
+			hotk->ledd_status = (u32) value;
+	} else if (count < 0)
+		printk(KERN_WARNING "Asus ACPI: Error reading user input\n");
+
+	return count;
+}
+
+/*
@@ -583,0 +645,19 @@
+ * Proc handlers for Bluetooth
+ */
+static int
+proc_read_bluetooth(char *page, char **start, off_t off, int count, int *eof,
+		    void *data)
+{
+	return sprintf(page, "%d\n", read_led(hotk->methods->bt_status, BT_ON));
+}
+
+static int
+proc_write_bluetooth(struct file *file, const char __user * buffer,
+		     unsigned long count, void *data)
+{
+	/* Note: mt_bt_switch controls both internal Bluetooth adapter's 
+	   presence and its LED */
+	return write_led(buffer, count, hotk->methods->mt_bt_switch, BT_ON, 0);
+}
+
+/*
@@ -820 +900 @@
-__init asus_proc_add(char *name, proc_writefunc * writefunc,
+asus_proc_add(char *name, proc_writefunc * writefunc,
@@ -839 +919 @@
-static int __init asus_hotk_add_fs(struct acpi_device *device)
+static int asus_hotk_add_fs(struct acpi_device *device)
@@ -878,0 +959,5 @@
+	if (hotk->methods->mt_ledd) {
+		asus_proc_add(PROC_LEDD, &proc_write_ledd, &proc_read_ledd,
+			      mode, device);
+	}
+
@@ -888,0 +974,5 @@
+	if (hotk->methods->mt_bt_switch) {
+		asus_proc_add(PROC_BT, &proc_write_bluetooth,
+			      &proc_read_bluetooth, mode, device);
+	}
+
@@ -921,0 +1012,4 @@
+		if (hotk->methods->mt_ledd)
+			remove_proc_entry(PROC_LEDD, acpi_device_dir(device));
+		if (hotk->methods->mt_bt_switch)
+			remove_proc_entry(PROC_BT, acpi_device_dir(device));
@@ -953,0 +1048,59 @@
+ * Match the model string to the list of supported models. Return END_MODEL if
+ * no match or model is NULL.
+ */
+static int asus_model_match(char *model)
+{
+	if (model == NULL)
+		return END_MODEL;
+
+	if (strncmp(model, "L3D", 3) == 0)
+		return L3D;
+	else if (strncmp(model, "L2E", 3) == 0 ||
+		 strncmp(model, "L3H", 3) == 0 || strncmp(model, "L5D", 3) == 0)
+		return L3H;
+	else if (strncmp(model, "L3", 2) == 0 || strncmp(model, "L2B", 3) == 0)
+		return L3C;
+	else if (strncmp(model, "L8L", 3) == 0)
+		return L8L;
+	else if (strncmp(model, "L4R", 3) == 0)
+		return L4R;
+	else if (strncmp(model, "M6N", 3) == 0 || strncmp(model, "W3N", 3) == 0)
+		return M6N;
+	else if (strncmp(model, "M6R", 3) == 0 || strncmp(model, "A3G", 3) == 0)
+		return M6R;
+	else if (strncmp(model, "M2N", 3) == 0 ||
+		 strncmp(model, "M3N", 3) == 0 ||
+		 strncmp(model, "M5N", 3) == 0 ||
+		 strncmp(model, "M6N", 3) == 0 ||
+		 strncmp(model, "S1N", 3) == 0 ||
+		 strncmp(model, "S5N", 3) == 0 || strncmp(model, "W1N", 3) == 0)
+		return xxN;
+	else if (strncmp(model, "M1", 2) == 0)
+		return M1A;
+	else if (strncmp(model, "M2", 2) == 0 || strncmp(model, "L4E", 3) == 0)
+		return M2E;
+	else if (strncmp(model, "L2", 2) == 0)
+		return L2D;
+	else if (strncmp(model, "L8", 2) == 0)
+		return S1x;
+	else if (strncmp(model, "D1", 2) == 0)
+		return D1x;
+	else if (strncmp(model, "A1", 2) == 0)
+		return A1x;
+	else if (strncmp(model, "A2", 2) == 0)
+		return A2x;
+	else if (strncmp(model, "J1", 2) == 0)
+		return S2x;
+	else if (strncmp(model, "L5", 2) == 0)
+		return L5x;
+	else if (strncmp(model, "A4G", 3) == 0)
+		return A4G;
+	else if (strncmp(model, "W1N", 3) == 0)
+		return W1N;
+	else if (strncmp(model, "W5A", 3) == 0)
+		return W5A;
+	else
+		return END_MODEL;
+}
+
+/*
@@ -957 +1110 @@
-static int __init asus_hotk_get_info(void)
+static int asus_hotk_get_info(void)
@@ -962,0 +1116 @@
+	char *string = NULL;
@@ -973 +1127 @@
-	status = acpi_get_table(ACPI_TABLE_DSDT, 1, &dsdt);
+	status = acpi_get_table(ACPI_TABLE_ID_DSDT, 1, &dsdt);
@@ -992,5 +1145,0 @@
-	/* This is unlikely with implicit return */
-	if (buffer.pointer == NULL)
-		return -EINVAL;
-
-	model = (union acpi_object *) buffer.pointer;
@@ -998,5 +1147,4 @@
-	 * Samsung P30 has a device with a valid _HID whose INIT does not 
-	 * return anything. It used to be possible to catch this exception,
-	 * but the implicit return code will now happily confuse the 
-	 * driver. We assume that every ACPI_TYPE_STRING is a valid model
-	 * identifier but it's still possible to get completely bogus data.
+	 * Try to match the object returned by INIT to the specific model.
+	 * Handle every possible object (or the lack of thereof) the DSDT 
+	 * writers might throw at us. When in trouble, we pass NULL to 
+	 * asus_model_match() and try something completely different.
@@ -1004,4 +1152,17 @@
-	if (model->type == ACPI_TYPE_STRING) {
-		printk(KERN_NOTICE "  %s model detected, ", model->string.pointer);
-	} else {
-		if (asus_info &&	/* Samsung P30 */
+	if (buffer.pointer) {
+		model = (union acpi_object *)buffer.pointer;
+		switch (model->type) {
+		case ACPI_TYPE_STRING:
+			string = model->string.pointer;
+			break;
+		case ACPI_TYPE_BUFFER:
+			string = model->buffer.pointer;
+			break;
+		default:
+			kfree(model);
+			break;
+		}
+	}
+	hotk->model = asus_model_match(string);
+	if (hotk->model == END_MODEL) {	/* match failed */
+		if (asus_info &&
@@ -1014,3 +1175,4 @@
-			printk(KERN_WARNING "  no string returned by INIT\n");
-			printk(KERN_WARNING "  trying default values, supply "
-			       "the developers with your DSDT\n");
+			printk(KERN_NOTICE "  unsupported model %s, trying "
+			       "default values\n", string);
+			printk(KERN_NOTICE
+			       "  send /proc/acpi/dsdt to the developers\n");
@@ -1019,3 +1180,0 @@
-		
-		acpi_os_free(model);
-
@@ -1024,54 +1182,0 @@
-
-	hotk->model = END_MODEL;
-	if (strncmp(model->string.pointer, "L3D", 3) == 0)
-		hotk->model = L3D;
-	else if (strncmp(model->string.pointer, "L3H", 3) == 0 ||
-		 strncmp(model->string.pointer, "L2E", 3) == 0)
-		hotk->model = L3H;
-	else if (strncmp(model->string.pointer, "L3", 2) == 0 ||
-		 strncmp(model->string.pointer, "L2B", 3) == 0)
-		hotk->model = L3C;
-	else if (strncmp(model->string.pointer, "L8L", 3) == 0)
-		hotk->model = L8L;
-	else if (strncmp(model->string.pointer, "L4R", 3) == 0)
-		hotk->model = L4R;
-	else if (strncmp(model->string.pointer, "M6N", 3) == 0)
-		hotk->model = M6N;
-	else if (strncmp(model->string.pointer, "M6R", 3) == 0)
-		hotk->model = M6R;
-	else if (strncmp(model->string.pointer, "M2N", 3) == 0 ||
-		 strncmp(model->string.pointer, "M3N", 3) == 0 ||
-		 strncmp(model->string.pointer, "M5N", 3) == 0 ||
-		 strncmp(model->string.pointer, "M6N", 3) == 0 ||
-		 strncmp(model->string.pointer, "S1N", 3) == 0 ||
-		 strncmp(model->string.pointer, "S5N", 3) == 0 ||
-		 strncmp(model->string.pointer, "W1N", 3) == 0)
-		hotk->model = xxN;
-	else if (strncmp(model->string.pointer, "M1", 2) == 0)
-		hotk->model = M1A;
-	else if (strncmp(model->string.pointer, "M2", 2) == 0 ||
-		 strncmp(model->string.pointer, "L4E", 3) == 0)
-		hotk->model = M2E;
-	else if (strncmp(model->string.pointer, "L2", 2) == 0)
-		hotk->model = L2D;
-	else if (strncmp(model->string.pointer, "L8", 2) == 0)
-		hotk->model = S1x;
-	else if (strncmp(model->string.pointer, "D1", 2) == 0)
-		hotk->model = D1x;
-	else if (strncmp(model->string.pointer, "A1", 2) == 0)
-		hotk->model = A1x;
-	else if (strncmp(model->string.pointer, "A2", 2) == 0)
-		hotk->model = A2x;
-	else if (strncmp(model->string.pointer, "J1", 2) == 0)
-		hotk->model = S2x;
-	else if (strncmp(model->string.pointer, "L5", 2) == 0)
-		hotk->model = L5x;
-
-	if (hotk->model == END_MODEL) {
-		printk("unsupported, trying default values, supply the "
-		       "developers with your DSDT\n");
-		hotk->model = M2E;
-	} else {
-		printk("supported\n");
-	}
-
@@ -1078,0 +1184 @@
+	printk(KERN_NOTICE "  %s model detected, supported\n", string);
@@ -1081 +1187 @@
-	if (strncmp(model->string.pointer, "L2B", 3) == 0)
+	if (strncmp(string, "L2B", 3) == 0)
@@ -1085,2 +1191,6 @@
-	else if (strncmp(model->string.pointer, "S5N", 3) == 0 ||
-		 strncmp(model->string.pointer, "M5N", 3) == 0)
+	else if (strncmp(string, "A3G", 3) == 0)
+		hotk->methods->lcd_status = "\\BLFG";
+	/* A3G is like M6R */
+	else if (strncmp(string, "S5N", 3) == 0 ||
+		 strncmp(string, "M5N", 3) == 0 ||
+		 strncmp(string, "W3N", 3) == 0)
@@ -1088,3 +1198,6 @@
-	/* S5N and M5N have no MLED */
-	else if (strncmp(model->string.pointer, "M2N", 3) == 0 ||
-		 strncmp(model->string.pointer, "W1N", 3) == 0)
+	/* S5N, M5N and W3N have no MLED */
+	else if (strncmp(string, "L5D", 3) == 0)
+		hotk->methods->mt_wled = NULL;
+	/* L5D's WLED is not controlled by ACPI */
+	else if (strncmp(string, "M2N", 3) == 0 ||
+		 strncmp(string, "S1N", 3) == 0)
@@ -1092 +1205 @@
-	/* M2N and W1N have a usable WLED */
+	/* M2N and S1N have a usable WLED */
@@ -1099 +1212 @@
-	acpi_os_free(model);
+	kfree(model);
@@ -1104 +1217 @@
-static int __init asus_hotk_check(void)
+static int asus_hotk_check(void)
@@ -1122 +1235,3 @@
-static int __init asus_hotk_add(struct acpi_device *device)
+static int asus_hotk_found;
+
+static int asus_hotk_add(struct acpi_device *device)
@@ -1165,2 +1280 @@
-	    && (hotk->methods->brightness_up
-		&& hotk->methods->brightness_down)) {
+	    && (hotk->methods->brightness_up && hotk->methods->brightness_down)) {
@@ -1182,0 +1297,5 @@
+	asus_hotk_found = 1;
+
+	/* LED display is off by default */
+	hotk->ledd_status = 0xFFF;
+
@@ -1229 +1348,13 @@
-	if (result < 1) {
+	if (result < 0) {
+		remove_proc_entry(PROC_ASUS, acpi_root_dir);
+		return result;
+	}
+
+	/*
+	 * This is a bit of a kludge.  We only want this module loaded
+	 * for ASUS systems, but there's currently no way to probe the
+	 * ACPI namespace for ASUS HIDs.  So we just return failure if
+	 * we didn't find one, which will cause the module to be
+	 * unloaded.
+	 */
+	if (!asus_hotk_found) {
@@ -1232 +1363 @@
-		return -ENODEV;
+		return result;
@@ -1243 +1374 @@
-	acpi_os_free(asus_info);
+	kfree(asus_info);
--- ./projects/linux/linux-2.6.18/drivers/acpi/asus_acpi.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/acpi/asus_acpi.c	2006-11-29 22:57:37.000000000 +0100
@@ -140,0 +141 @@
+		W3V,            //W3030V
@@ -378,0 +380,11 @@
+	 .name = "W3V",
+	 .mt_mled = "MLED",
+	 .mt_wled = "WLED",
+	 .mt_lcd_switch = xxN_PREFIX "_Q10",
+	 .lcd_status = "\\BKLT",
+	 .brightness_set = "SPLV",
+	 .brightness_get = "GPLV",
+	 .display_set = "SDSP",
+	 .display_get = "\\INFB"},
+
+       {
@@ -558 +570 @@
-	int value;
+	int rv, value;
@@ -561,2 +573,2 @@
-	count = parse_arg(buffer, count, &value);
-	if (count > 0)
+	rv = parse_arg(buffer, count, &value);
+	if (rv > 0)
@@ -575 +587 @@
-	return count;
+	return rv;
@@ -610 +622 @@
-	int value;
+	int rv, value;
@@ -612,2 +624,2 @@
-	count = parse_arg(buffer, count, &value);
-	if (count > 0) {
+	rv = parse_arg(buffer, count, &value);
+	if (rv > 0) {
@@ -620,4 +632,2 @@
-	} else if (count < 0)
-		printk(KERN_WARNING "Asus ACPI: Error reading user input\n");
-
-	return count;
+	}
+	return rv;
@@ -764 +774 @@
-	int value;
+	int rv, value;
@@ -766,2 +776,2 @@
-	count = parse_arg(buffer, count, &value);
-	if (count > 0)
+	rv = parse_arg(buffer, count, &value);
+	if (rv > 0)
@@ -769 +779 @@
-	return count;
+	return rv;
@@ -833 +843 @@
-	int value;
+	int rv, value;
@@ -835,2 +845,2 @@
-	count = parse_arg(buffer, count, &value);
-	if (count > 0) {
+	rv = parse_arg(buffer, count, &value);
+	if (rv > 0) {
@@ -840,2 +849,0 @@
-	} else if (count < 0) {
-		printk(KERN_WARNING "Asus ACPI: Error reading user input\n");
@@ -843,2 +851 @@
-
-	return count;
+	return rv;
@@ -883 +890 @@
-	int value;
+	int rv, value;
@@ -885,2 +892,2 @@
-	count = parse_arg(buffer, count, &value);
-	if (count > 0)
+	rv = parse_arg(buffer, count, &value);
+	if (rv > 0)
@@ -888,4 +895 @@
-	else if (count < 0)
-		printk(KERN_WARNING "Asus ACPI: Error reading user input\n");
-
-	return count;
+	return rv;
@@ -1099,0 +1104,2 @@
+	else if (strncmp(model, "W3V", 3) == 0)
+		return W3V;
@@ -1202,0 +1209 @@
+		 strncmp(string, "W3V", 3) == 0 ||
@@ -1205 +1212 @@
-	/* M2N and S1N have a usable WLED */
+	/* M2N, S1N and W3V have a usable WLED */
--- ./projects/linux/linux-2.6.19/drivers/acpi/asus_acpi.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/acpi/asus_acpi.c	2007-02-04 19:44:54.000000000 +0100
@@ -37,0 +38 @@
+#include <linux/backlight.h>
@@ -404,0 +406,2 @@
+static struct backlight_device *asus_backlight_device;
+
@@ -782 +785 @@
-static int read_brightness(void)
+static int read_brightness(struct backlight_device *bd)
@@ -804 +807 @@
-static void set_brightness(int value)
+static int set_brightness(int value)
@@ -806,0 +810 @@
+	int ret = 0;
@@ -814 +818,2 @@
-		return;
+			ret = -EIO;
+		goto out;
@@ -818 +823 @@
-	value -= read_brightness();
+	value -= read_brightness(NULL);
@@ -827,0 +833 @@
+			ret = -EIO;
@@ -829 +835,7 @@
-	return;
+out:
+	return ret;
+}
+
+static int set_brightness_status(struct backlight_device *bd)
+{
+	return set_brightness(bd->props->brightness);
@@ -836 +848 @@
-	return sprintf(page, "%d\n", read_brightness());
+	return sprintf(page, "%d\n", read_brightness(NULL));
@@ -1137 +1149 @@
-		asus_info = (struct acpi_table_header *)dsdt.pointer;
+		asus_info = dsdt.pointer;
@@ -1159 +1171 @@
-		model = (union acpi_object *)buffer.pointer;
+		model = buffer.pointer;
@@ -1255,2 +1267 @@
-	hotk =
-	    (struct asus_hotk *)kmalloc(sizeof(struct asus_hotk), GFP_KERNEL);
+	hotk = kzalloc(sizeof(struct asus_hotk), GFP_KERNEL);
@@ -1259 +1269,0 @@
-	memset(hotk, 0, sizeof(struct asus_hotk));
@@ -1335,0 +1346,20 @@
+static struct backlight_properties asus_backlight_data = {
+        .owner          = THIS_MODULE,
+        .get_brightness = read_brightness,
+        .update_status  = set_brightness_status,
+        .max_brightness = 15,
+};
+
+static void __exit asus_acpi_exit(void)
+{
+	if (asus_backlight_device)
+		backlight_device_unregister(asus_backlight_device);
+
+	acpi_bus_unregister_driver(&asus_hotk_driver);
+	remove_proc_entry(PROC_ASUS, acpi_root_dir);
+
+	kfree(asus_info);
+
+	return;
+}
+
@@ -1373,9 +1403,7 @@
-	return 0;
-}
-
-static void __exit asus_acpi_exit(void)
-{
-	acpi_bus_unregister_driver(&asus_hotk_driver);
-	remove_proc_entry(PROC_ASUS, acpi_root_dir);
-
-	kfree(asus_info);
+	asus_backlight_device = backlight_device_register("asus",NULL,NULL,
+							  &asus_backlight_data);
+        if (IS_ERR(asus_backlight_device)) {
+		printk(KERN_ERR "Could not register asus backlight device\n");
+		asus_backlight_device = NULL;
+		asus_acpi_exit();
+	}
@@ -1383 +1411 @@
-	return;
+	return 0;
--- ./projects/linux/linux-2.6.20/drivers/acpi/asus_acpi.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/acpi/asus_acpi.c	2007-04-26 05:08:32.000000000 +0200
@@ -29 +29 @@
- *  ric Burghard  - LED display support for W1N
+ *  ic Burghard  - LED display support for W1N
@@ -143,0 +144 @@
+		A4S,            //Z81sp
@@ -400 +401,10 @@
-	 .display_get = "\\ADVG"}
+	.display_get = "\\ADVG"},
+
+	{
+		.name              = "A4S",
+		.brightness_set    = "SPLV",
+		.brightness_get    = "GPLV",
+		.mt_bt_switch      = "BLED",
+		.mt_wled           = "WLED"
+	}
+
@@ -424 +434 @@
-	.name = ACPI_HOTK_NAME,
+	.name = "asus_acpi",
@@ -841 +851 @@
-	return set_brightness(bd->props->brightness);
+	return set_brightness(bd->props.brightness);
@@ -1119,0 +1130,2 @@
+	else if (strncmp(model, "A4S", 3) == 0)
+		return A4S;
@@ -1131 +1142,0 @@
-	struct acpi_buffer dsdt = { ACPI_ALLOCATE_BUFFER, NULL };
@@ -1145 +1156 @@
-	status = acpi_get_table(ACPI_TABLE_ID_DSDT, 1, &dsdt);
+	status = acpi_get_table(ACPI_SIG_DSDT, 1, &asus_info);
@@ -1148,2 +1158,0 @@
-	else
-		asus_info = dsdt.pointer;
@@ -1346,2 +1355 @@
-static struct backlight_properties asus_backlight_data = {
-        .owner          = THIS_MODULE,
+static struct backlight_ops asus_backlight_data = {
@@ -1350 +1357,0 @@
-        .max_brightness = 15,
@@ -1361,2 +1367,0 @@
-	kfree(asus_info);
-
@@ -1373,4 +1377,0 @@
-	if (!acpi_specific_hotkey_enabled) {
-		printk(KERN_ERR "Using generic hotkey driver\n");
-		return -ENODEV;
-	}
@@ -1409,0 +1411 @@
+        asus_backlight_device->props.max_brightness = 15;
--- ./projects/linux/linux-2.6.21/drivers/acpi/asus_acpi.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/acpi/asus_acpi.c	2007-07-09 01:32:17.000000000 +0200
@@ -1360 +1360 @@
-static void __exit asus_acpi_exit(void)
+static void asus_acpi_exit(void)
@@ -1401 +1401 @@
-		return result;
+		return -ENODEV;
@@ -1409,0 +1410 @@
+		return -ENODEV;
--- ./projects/linux/linux-2.6.22/drivers/acpi/asus_acpi.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/acpi/asus_acpi.c	2007-10-09 22:31:38.000000000 +0200
@@ -59 +58,0 @@
-#define ACPI_HOTK_HID           "ATK0100"
@@ -429 +428 @@
- * The hotkey driver declaration
+ * The hotkey driver and autoloading declaration
@@ -432,0 +432,6 @@
+static const struct acpi_device_id asus_device_ids[] = {
+	{"ATK0100", 0},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, asus_device_ids);
+
@@ -436 +441 @@
-	.ids = ACPI_HOTK_HID,
+	.ids = asus_device_ids,
@@ -1067 +1072 @@
-	acpi_bus_generate_event(hotk->device, event,
+	acpi_bus_generate_proc_event(hotk->device, event,
@@ -1189,0 +1195 @@
+			model = NULL;
--- ./projects/linux/linux-2.6.24/drivers/acpi/asus_acpi.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/acpi/asus_acpi.c	2008-04-17 04:49:44.000000000 +0200
@@ -144,0 +145 @@
+		F3Sa,
@@ -408 +409,14 @@
-	}
+	},
+
+	{
+		.name		= "F3Sa",
+		.mt_bt_switch	= "BLED",
+		.mt_wled	= "WLED",
+		.mt_mled	= "MLED",
+		.brightness_get	= "GPLV",
+		.brightness_set	= "SPLV",
+		.mt_lcd_switch	= "\\_SB.PCI0.SBRG.EC0._Q10",
+		.lcd_status	= "\\_SB.PCI0.SBRG.EC0.RPIN",
+		.display_get	= "\\ADVG",
+		.display_set	= "SDSP",
+	},
@@ -599 +613 @@
-		led_out = !led_out & 0x1;
+		led_out = !led_out;
@@ -713,9 +727,2 @@
-	if (hotk->model != L3H) {
-		/* We don't have to check anything if we are here */
-		if (!read_acpi_int(NULL, hotk->methods->lcd_status, &lcd))
-			printk(KERN_WARNING
-			       "Asus ACPI: Error reading LCD status\n");
-
-		if (hotk->model == L2D)
-			lcd = ~lcd;
-	} else {		/* L3H and the like have to be handled differently */
+	if (hotk->model == L3H) {
+		/* L3H and the like have to be handled differently */
@@ -747,0 +755,26 @@
+	} else if (hotk->model == F3Sa) {
+		unsigned long tmp;
+		union acpi_object param;
+		struct acpi_object_list input;
+		acpi_status status;
+
+		/* Read pin 11 */
+		param.type = ACPI_TYPE_INTEGER;
+		param.integer.value = 0x11;
+		input.count = 1;
+		input.pointer = &param;
+
+		status = acpi_evaluate_integer(NULL, hotk->methods->lcd_status,
+						&input, &tmp);
+		if (status != AE_OK)
+			return -1;
+
+		lcd = tmp;
+	} else {
+		/* We don't have to check anything if we are here */
+		if (!read_acpi_int(NULL, hotk->methods->lcd_status, &lcd))
+			printk(KERN_WARNING
+			       "Asus ACPI: Error reading LCD status\n");
+
+		if (hotk->model == L2D)
+			lcd = ~lcd;
@@ -1136,0 +1170,2 @@
+	else if (strncmp(model, "F3Sa", 4) == 0)
+		return F3Sa;
--- ./projects/linux/linux-2.6.26/drivers/acpi/asus_acpi.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/acpi/asus_acpi.c	2008-10-10 00:13:53.000000000 +0200
@@ -81 +81 @@
-MODULE_PARM_DESC(asus_uid, "UID for entries in /proc/acpi/asus.\n");
+MODULE_PARM_DESC(asus_uid, "UID for entries in /proc/acpi/asus");
@@ -83 +83 @@
-MODULE_PARM_DESC(asus_gid, "GID for entries in /proc/acpi/asus.\n");
+MODULE_PARM_DESC(asus_gid, "GID for entries in /proc/acpi/asus");
--- ./projects/linux/linux-2.6.27/drivers/acpi/asus_acpi.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/acpi/asus_acpi.c	2008-12-25 00:26:37.000000000 +0100
@@ -45 +45 @@
-#define PROC_ASUS       "asus"	//the directory
+#define PROC_ASUS       "asus"	/* The directory */
@@ -69,4 +69,4 @@
-#define MLED_ON     0x01	//mail LED
-#define WLED_ON     0x02	//wireless LED
-#define TLED_ON     0x04	//touchpad LED
-#define BT_ON       0x08	//internal Bluetooth
+#define MLED_ON     0x01	/* Mail LED */
+#define WLED_ON     0x02	/* Wireless LED */
+#define TLED_ON     0x04	/* Touchpad LED */
+#define BT_ON       0x08	/* Internal Bluetooth */
@@ -85 +85 @@
-/* For each model, all features implemented, 
+/* For each model, all features implemented,
@@ -88,19 +88,19 @@
-	char *name;		//name of the laptop________________A
-	char *mt_mled;		//method to handle mled_____________R
-	char *mled_status;	//node to handle mled reading_______A
-	char *mt_wled;		//method to handle wled_____________R
-	char *wled_status;	//node to handle wled reading_______A
-	char *mt_tled;		//method to handle tled_____________R
-	char *tled_status;	//node to handle tled reading_______A
-	char *mt_ledd;		//method to handle LED display______R
-	char *mt_bt_switch;	//method to switch Bluetooth on/off_R
-	char *bt_status;	//no model currently supports this__?
-	char *mt_lcd_switch;	//method to turn LCD on/off_________A
-	char *lcd_status;	//node to read LCD panel state______A
-	char *brightness_up;	//method to set brightness up_______A
-	char *brightness_down;	//guess what ?______________________A
-	char *brightness_set;	//method to set absolute brightness_R
-	char *brightness_get;	//method to get absolute brightness_R
-	char *brightness_status;	//node to get brightness____________A
-	char *display_set;	//method to set video output________R
-	char *display_get;	//method to get video output________R
+	char *name;		/* name of the laptop________________A */
+	char *mt_mled;		/* method to handle mled_____________R */
+	char *mled_status;	/* node to handle mled reading_______A */
+	char *mt_wled;		/* method to handle wled_____________R */
+	char *wled_status;	/* node to handle wled reading_______A */
+	char *mt_tled;		/* method to handle tled_____________R */
+	char *tled_status;	/* node to handle tled reading_______A */
+	char *mt_ledd;		/* method to handle LED display______R */
+	char *mt_bt_switch;	/* method to switch Bluetooth on/off_R */
+	char *bt_status;	/* no model currently supports this__? */
+	char *mt_lcd_switch;	/* method to turn LCD on/off_________A */
+	char *lcd_status;	/* node to read LCD panel state______A */
+	char *brightness_up;	/* method to set brightness up_______A */
+	char *brightness_down;	/* method to set brightness down ____A */
+	char *brightness_set;	/* method to set absolute brightness_R */
+	char *brightness_get;	/* method to get absolute brightness_R */
+	char *brightness_status;/* node to get brightness____________A */
+	char *display_set;	/* method to set video output________R */
+	char *display_get;	/* method to get video output________R */
@@ -114,6 +114,6 @@
-	struct acpi_device *device;	//the device we are in
-	acpi_handle handle;	//the handle of the hotk device
-	char status;		//status of the hotk, for LEDs, ...
-	u32 ledd_status;	//status of the LED display
-	struct model_data *methods;	//methods available on the laptop
-	u8 brightness;		//brightness level
+	struct acpi_device *device;	/* the device we are in */
+	acpi_handle handle;		/* the handle of the hotk device */
+	char status;			/* status of the hotk, for LEDs */
+	u32 ledd_status;		/* status of the LED display */
+	struct model_data *methods;	/* methods available on the laptop */
+	u8 brightness;			/* brightness level */
@@ -121,25 +121,25 @@
-		A1x = 0,	//A1340D, A1300F
-		A2x,		//A2500H
-		A4G,		//A4700G
-		D1x,		//D1
-		L2D,		//L2000D
-		L3C,		//L3800C
-		L3D,		//L3400D
-		L3H,		//L3H, L2000E, L5D
-		L4R,		//L4500R
-		L5x,		//L5800C 
-		L8L,		//L8400L
-		M1A,		//M1300A
-		M2E,		//M2400E, L4400L
-		M6N,		//M6800N, W3400N
-		M6R,		//M6700R, A3000G
-		P30,		//Samsung P30
-		S1x,		//S1300A, but also L1400B and M2400A (L84F)
-		S2x,		//S200 (J1 reported), Victor MP-XP7210
-		W1N,		//W1000N
-		W5A,		//W5A
-		W3V,            //W3030V
-		xxN,		//M2400N, M3700N, M5200N, M6800N, S1300N, S5200N
-		A4S,            //Z81sp
-		//(Centrino)
-		F3Sa,
+		A1x = 0,	/* A1340D, A1300F */
+		A2x,		/* A2500H */
+		A4G,		/* A4700G */
+		D1x,		/* D1 */
+		L2D,		/* L2000D */
+		L3C,		/* L3800C */
+		L3D,		/* L3400D */
+		L3H,		/* L3H, L2000E, L5D */
+		L4R,		/* L4500R */
+		L5x,		/* L5800C */
+		L8L,		/* L8400L */
+		M1A,		/* M1300A */
+		M2E,		/* M2400E, L4400L */
+		M6N,		/* M6800N, W3400N */
+		M6R,		/* M6700R, A3000G */
+		P30,		/* Samsung P30 */
+		S1x,		/* S1300A, but also L1400B and M2400A (L84F) */
+		S2x,		/* S200 (J1 reported), Victor MP-XP7210 */
+		W1N,		/* W1000N */
+		W5A,		/* W5A */
+		W3V,            /* W3030V */
+		xxN,		/* M2400N, M3700N, M5200N, M6800N,
+							 S1300N, S5200N*/
+		A4S,            /* Z81sp */
+		F3Sa,		/* (Centrino) */
@@ -147,2 +147,2 @@
-	} model;		//Models currently supported
-	u16 event_count[128];	//count for each event TODO make this better
+	} model;		/* Models currently supported */
+	u16 event_count[128];	/* Count for each event TODO make this better */
@@ -462 +462 @@
-/* 
+/*
@@ -467 +467 @@
- * returns 1 if write is successful, 0 else. 
+ * returns 1 if write is successful, 0 else.
@@ -472,2 +472,2 @@
-	struct acpi_object_list params;	//list of input parameters (an int here)
-	union acpi_object in_obj;	//the only param we use
+	struct acpi_object_list params;	/* list of input parameters (int) */
+	union acpi_object in_obj;	/* the only param we use */
@@ -510 +510 @@
-	char buf[16];		//enough for all info
+	char buf[16];		/* enough for all info */
@@ -512,2 +512,2 @@
-	 * We use the easy way, we don't care of off and count, so we don't set eof
-	 * to 1
+	 * We use the easy way, we don't care of off and count,
+	 * so we don't set eof to 1
@@ -519,3 +519,3 @@
-	/* 
-	 * The SFUN method probably allows the original driver to get the list 
-	 * of features supported by a given model. For now, 0x0100 or 0x0800 
+	/*
+	 * The SFUN method probably allows the original driver to get the list
+	 * of features supported by a given model. For now, 0x0100 or 0x0800
@@ -531 +531 @@
-	 * more accurate than those provided by _BST. 
+	 * more accurate than those provided by _BST.
@@ -582 +582 @@
-static int parse_arg(const char __user * buf, unsigned long count, int *val)
+static int parse_arg(const char __user *buf, unsigned long count, int *val)
@@ -599 +599 @@
-write_led(const char __user * buffer, unsigned long count,
+write_led(const char __user *buffer, unsigned long count,
@@ -634 +634 @@
-proc_write_mled(struct file *file, const char __user * buffer,
+proc_write_mled(struct file *file, const char __user *buffer,
@@ -651 +651 @@
-proc_write_ledd(struct file *file, const char __user * buffer,
+proc_write_ledd(struct file *file, const char __user *buffer,
@@ -680 +680 @@
-proc_write_wled(struct file *file, const char __user * buffer,
+proc_write_wled(struct file *file, const char __user *buffer,
@@ -697 +697 @@
-proc_write_bluetooth(struct file *file, const char __user * buffer,
+proc_write_bluetooth(struct file *file, const char __user *buffer,
@@ -700 +700 @@
-	/* Note: mt_bt_switch controls both internal Bluetooth adapter's 
+	/* Note: mt_bt_switch controls both internal Bluetooth adapter's
@@ -717 +717 @@
-proc_write_tled(struct file *file, const char __user * buffer,
+proc_write_tled(struct file *file, const char __user *buffer,
@@ -737 +737 @@
-		/* Note: the following values are partly guessed up, but 
+		/* Note: the following values are partly guessed up, but
@@ -756 +756 @@
-		unsigned long tmp;
+		unsigned long long tmp;
@@ -799 +799,2 @@
-		} else {	/* L3H and the like have to be handled differently */
+		} else {
+			/* L3H and the like must be handled differently */
@@ -804 +805 @@
-			/* L3H's AML executes EHK (0x07) upon Fn+F7 keypress, 
+			/* L3H's AML executes EHK (0x07) upon Fn+F7 keypress,
@@ -822 +823 @@
-proc_write_lcd(struct file *file, const char __user * buffer,
+proc_write_lcd(struct file *file, const char __user *buffer,
@@ -900 +901 @@
-proc_write_brn(struct file *file, const char __user * buffer,
+proc_write_brn(struct file *file, const char __user *buffer,
@@ -924 +925 @@
- * Now, *this* one could be more user-friendly, but so far, no-one has 
+ * Now, *this* one could be more user-friendly, but so far, no-one has
@@ -936 +937 @@
-	value &= 0x07;		/* needed for some models, shouldn't hurt others */
+	value &= 0x07;	/* needed for some models, shouldn't hurt others */
@@ -941,4 +942,4 @@
- * Experimental support for display switching. As of now: 1 should activate 
- * the LCD output, 2 should do for CRT, and 4 for TV-Out. Any combination 
- * (bitwise) of these will suffice. I never actually tested 3 displays hooked up 
- * simultaneously, so be warned. See the acpi4asus README for more info.
+ * Experimental support for display switching. As of now: 1 should activate
+ * the LCD output, 2 should do for CRT, and 4 for TV-Out. Any combination
+ * (bitwise) of these will suffice. I never actually tested 3 displays hooked
+ * up simultaneously, so be warned. See the acpi4asus README for more info.
@@ -947 +948 @@
-proc_write_disp(struct file *file, const char __user * buffer,
+proc_write_disp(struct file *file, const char __user *buffer,
@@ -960 +961 @@
-typedef int (proc_writefunc) (struct file * file, const char __user * buffer,
+typedef int (proc_writefunc) (struct file *file, const char __user *buffer,
@@ -964,2 +965,2 @@
-asus_proc_add(char *name, proc_writefunc * writefunc,
-		     proc_readfunc * readfunc, mode_t mode,
+asus_proc_add(char *name, proc_writefunc *writefunc,
+		     proc_readfunc *readfunc, mode_t mode,
@@ -1043,3 +1044,3 @@
-	/* 
-	 * We need both read node and write method as LCD switch is also accessible
-	 * from keyboard 
+	/*
+	 * We need both read node and write method as LCD switch is also
+	 * accessible from the keyboard
@@ -1099 +1100 @@
-	if ((event & ~((u32) BR_UP)) < 16) {
+	if ((event & ~((u32) BR_UP)) < 16)
@@ -1101 +1102 @@
-	} else if ((event & ~((u32) BR_DOWN)) < 16) {
+	else if ((event & ~((u32) BR_DOWN)) < 16)
@@ -1103 +1103,0 @@
-	}
@@ -1189,2 +1189,2 @@
-	 * Get DSDT headers early enough to allow for differentiating between 
-	 * models, but late enough to allow acpi_bus_register_driver() to fail 
+	 * Get DSDT headers early enough to allow for differentiating between
+	 * models, but late enough to allow acpi_bus_register_driver() to fail
@@ -1215,2 +1215,2 @@
-	 * Handle every possible object (or the lack of thereof) the DSDT 
-	 * writers might throw at us. When in trouble, we pass NULL to 
+	 * Handle every possible object (or the lack of thereof) the DSDT
+	 * writers might throw at us. When in trouble, we pass NULL to
@@ -1246,0 +1247,2 @@
+			kfree(model);
+			return -ENODEV;
@@ -1257 +1259 @@
-	/* L2B is similar enough to L3C to use its settings, with this only 
+	/* L2B is similar enough to L3C to use its settings, with this only
@@ -1324 +1326 @@
-	acpi_driver_data(device) = hotk;
+	device->driver_data = hotk;
@@ -1369,2 +1371,2 @@
-      end:
-	if (result) {
+end:
+	if (result)
@@ -1372 +1373,0 @@
-	}
@@ -1397,2 +1398,2 @@
-        .get_brightness = read_brightness,
-        .update_status  = set_brightness_status,
+	.get_brightness = read_brightness,
+	.update_status  = set_brightness_status,
@@ -1445 +1446 @@
-	asus_backlight_device = backlight_device_register("asus",NULL,NULL,
+	asus_backlight_device = backlight_device_register("asus", NULL, NULL,
@@ -1447 +1448 @@
-        if (IS_ERR(asus_backlight_device)) {
+	if (IS_ERR(asus_backlight_device)) {
@@ -1453 +1454 @@
-        asus_backlight_device->props.max_brightness = 15;
+	asus_backlight_device->props.max_brightness = 15;
--- ./projects/linux/linux-2.6.13/drivers/block/paride/pt.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/block/paride/pt.c	2005-10-28 02:02:08.000000000 +0200
@@ -386,2 +386 @@
-	current->state = TASK_INTERRUPTIBLE;
-	schedule_timeout(cs);
+	schedule_timeout_interruptible(cs);
--- ./projects/linux/linux-2.6.14/drivers/block/paride/pt.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/block/paride/pt.c	2006-01-03 04:21:10.000000000 +0100
@@ -148,0 +149 @@
+#include <linux/sched.h>	/* current, TASK_*, schedule_timeout() */
@@ -974 +975 @@
-			class_device_create(pt_class, MKDEV(major, unit),
+			class_device_create(pt_class, NULL, MKDEV(major, unit),
@@ -983 +984 @@
-			class_device_create(pt_class, MKDEV(major, unit + 128),
+			class_device_create(pt_class, NULL, MKDEV(major, unit + 128),
--- ./projects/linux/linux-2.6.16/drivers/block/paride/pt.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/block/paride/pt.c	2006-06-18 03:49:35.000000000 +0200
@@ -946 +946,2 @@
-	int unit, err = 0;
+	int unit;
+	int err;
@@ -958 +959,2 @@
-	if (register_chrdev(major, name, &pt_fops)) {
+	err = register_chrdev(major, name, &pt_fops);
+	if (err < 0) {
@@ -963 +964,0 @@
-		err = -1;
@@ -965,0 +967 @@
+	major = err;
--- ./projects/linux/linux-2.6.17/drivers/block/paride/pt.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/block/paride/pt.c	2006-09-20 05:42:06.000000000 +0200
@@ -144 +143,0 @@
-#include <linux/devfs_fs_kernel.h>
@@ -974 +972,0 @@
-	devfs_mk_dir("pt");
@@ -979,7 +976,0 @@
-			err = devfs_mk_cdev(MKDEV(major, unit),
-				      S_IFCHR | S_IRUSR | S_IWUSR,
-				      "pt/%d", unit);
-			if (err) {
-				class_device_destroy(pt_class, MKDEV(major, unit));
-				goto out_class;
-			}
@@ -988,7 +978,0 @@
-			err = devfs_mk_cdev(MKDEV(major, unit + 128),
-				      S_IFCHR | S_IRUSR | S_IWUSR,
-				      "pt/%dn", unit);
-			if (err) {
-				class_device_destroy(pt_class, MKDEV(major, unit + 128));
-				goto out_class;
-			}
@@ -998,2 +981,0 @@
-out_class:
-	class_destroy(pt_class);
@@ -1012 +993,0 @@
-			devfs_remove("pt/%d", unit);
@@ -1014 +994,0 @@
-			devfs_remove("pt/%dn", unit);
@@ -1017 +996,0 @@
-	devfs_remove("pt");
--- ./projects/linux/linux-2.6.19/drivers/block/paride/pt.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/block/paride/pt.c	2007-02-04 19:44:54.000000000 +0100
@@ -949 +949 @@
-		err = -1;
+		err = -EINVAL;
@@ -954 +954 @@
-		err = -1;
+		err = -ENODEV;
--- ./projects/linux/linux-2.6.20/drivers/block/paride/pt.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/block/paride/pt.c	2007-04-26 05:08:32.000000000 +0200
@@ -235 +235 @@
-static struct file_operations pt_fops = {
+static const struct file_operations pt_fops = {
--- ./projects/linux/linux-2.6.23/drivers/block/paride/pt.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/block/paride/pt.c	2008-01-24 23:58:37.000000000 +0100
@@ -667 +667 @@
-	if ((!tape->flags & PT_WRITE_OK) && (file->f_mode & 2))
+	if ((!(tape->flags & PT_WRITE_OK)) && (file->f_mode & 2))
--- ./projects/linux/linux-2.6.24/drivers/block/paride/pt.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/block/paride/pt.c	2008-04-17 04:49:44.000000000 +0200
@@ -663 +663 @@
-	if (!tape->flags & PT_MEDIA)
+	if (!(tape->flags & PT_MEDIA))
@@ -975,4 +975,4 @@
-			class_device_create(pt_class, NULL, MKDEV(major, unit),
-					NULL, "pt%d", unit);
-			class_device_create(pt_class, NULL, MKDEV(major, unit + 128),
-					NULL, "pt%dn", unit);
+			device_create(pt_class, NULL, MKDEV(major, unit),
+				      "pt%d", unit);
+			device_create(pt_class, NULL, MKDEV(major, unit + 128),
+				      "pt%dn", unit);
@@ -993,2 +993,2 @@
-			class_device_destroy(pt_class, MKDEV(major, unit));
-			class_device_destroy(pt_class, MKDEV(major, unit + 128));
+			device_destroy(pt_class, MKDEV(major, unit));
+			device_destroy(pt_class, MKDEV(major, unit + 128));
--- ./projects/linux/linux-2.6.26/drivers/block/paride/pt.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/block/paride/pt.c	2008-10-10 00:13:53.000000000 +0200
@@ -148,0 +149 @@
+#include <linux/smp_lock.h>
@@ -192,2 +193 @@
-static int pt_ioctl(struct inode *inode, struct file *file,
-		    unsigned int cmd, unsigned long arg);
+static long pt_ioctl(struct file *file, unsigned int cmd, unsigned long arg);
@@ -239 +239 @@
-	.ioctl = pt_ioctl,
+	.unlocked_ioctl = pt_ioctl,
@@ -653 +653,3 @@
-	if (unit >= PT_UNITS || (!tape->present))
+	lock_kernel();
+	if (unit >= PT_UNITS || (!tape->present)) {
+		unlock_kernel();
@@ -654,0 +657 @@
+	}
@@ -680,0 +684 @@
+	unlock_kernel();
@@ -684,0 +689 @@
+	unlock_kernel();
@@ -688,2 +693 @@
-static int pt_ioctl(struct inode *inode, struct file *file,
-	 unsigned int cmd, unsigned long arg)
+static long pt_ioctl(struct file *file, unsigned int cmd, unsigned long arg)
@@ -702,0 +707 @@
+			lock_kernel();
@@ -703,0 +709 @@
+			unlock_kernel();
@@ -706,0 +713 @@
+			lock_kernel();
@@ -707,0 +715 @@
+			unlock_kernel();
@@ -711 +719,2 @@
-			printk("%s: Unimplemented mt_op %d\n", tape->name,
+			/* FIXME: rate limit ?? */
+			printk(KERN_DEBUG "%s: Unimplemented mt_op %d\n", tape->name,
@@ -717,3 +726 @@
-		printk("%s: Unimplemented ioctl 0x%x\n", tape->name, cmd);
-		return -EINVAL;
-
+		return -ENOTTY;
@@ -975,4 +982,6 @@
-			device_create(pt_class, NULL, MKDEV(major, unit),
-				      "pt%d", unit);
-			device_create(pt_class, NULL, MKDEV(major, unit + 128),
-				      "pt%dn", unit);
+			device_create_drvdata(pt_class, NULL,
+					      MKDEV(major, unit), NULL,
+					      "pt%d", unit);
+			device_create_drvdata(pt_class, NULL,
+					      MKDEV(major, unit + 128), NULL,
+					      "pt%dn", unit);
--- ./projects/linux/linux-2.6.27/drivers/block/paride/pt.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/block/paride/pt.c	2008-12-25 00:26:37.000000000 +0100
@@ -670 +670 @@
-	if ((!(tape->flags & PT_WRITE_OK)) && (file->f_mode & 2))
+	if ((!(tape->flags & PT_WRITE_OK)) && (file->f_mode & FMODE_WRITE))
@@ -982,6 +982,4 @@
-			device_create_drvdata(pt_class, NULL,
-					      MKDEV(major, unit), NULL,
-					      "pt%d", unit);
-			device_create_drvdata(pt_class, NULL,
-					      MKDEV(major, unit + 128), NULL,
-					      "pt%dn", unit);
+			device_create(pt_class, NULL, MKDEV(major, unit), NULL,
+				      "pt%d", unit);
+			device_create(pt_class, NULL, MKDEV(major, unit + 128),
+				      NULL, "pt%dn", unit);
--- ./projects/linux/linux-2.6.13/drivers/block/pktcdvd.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/block/pktcdvd.c	2005-10-28 02:02:08.000000000 +0200
@@ -8,2 +8,2 @@
- * Packet writing layer for ATAPI and SCSI CD-R, CD-RW, DVD-R, and
- * DVD-RW devices (aka an exercise in block layer masturbation)
+ * Packet writing layer for ATAPI and SCSI CD-RW, DVD+RW, DVD-RW and
+ * DVD-RAM devices.
@@ -10,0 +11 @@
+ * Theory of operation:
@@ -12,6 +13,8 @@
- * TODO: (circa order of when I will fix it)
- * - Only able to write on CD-RW media right now.
- * - check host application code on media and set it in write page
- * - interface for UDF <-> packet to negotiate a new location when a write
- *   fails.
- * - handle OPC, especially for -RW media
+ * At the lowest level, there is the standard driver for the CD/DVD device,
+ * typically ide-cd.c or sr.c. This driver can handle read and write requests,
+ * but it doesn't know anything about the special restrictions that apply to
+ * packet writing. One restriction is that write requests must be aligned to
+ * packet boundaries on the physical media, and the size of a write request
+ * must be equal to the packet size. Another restriction is that a
+ * GPCMD_FLUSH_CACHE command has to be issued to the drive before a read
+ * command, if the previous command was a write.
@@ -19 +22,10 @@
- * Theory of operation:
+ * The purpose of the packet writing driver is to hide these restrictions from
+ * higher layers, such as file systems, and present a block device that can be
+ * randomly read and written using 2kB-sized blocks.
+ *
+ * The lowest layer in the packet writing driver is the packet I/O scheduler.
+ * Its data is defined by the struct packet_iosched and includes two bio
+ * queues with pending read and write requests. These queues are processed
+ * by the pkt_iosched_process_queue() function. The write requests in this
+ * queue are already properly aligned and sized. This layer is responsible for
+ * issuing the flush cache commands and scheduling the I/O in a good order.
@@ -21,6 +33,4 @@
- * We use a custom make_request_fn function that forwards reads directly to
- * the underlying CD device. Write requests are either attached directly to
- * a live packet_data object, or simply stored sequentially in a list for
- * later processing by the kcdrwd kernel thread. This driver doesn't use
- * any elevator functionally as defined by the elevator_s struct, but the
- * underlying CD device uses a standard elevator.
+ * The next layer transforms unaligned write requests to aligned writes. This
+ * transformation requires reading missing pieces of data from the underlying
+ * block device, assembling the pieces to full packets and queuing them to the
+ * packet I/O scheduler.
@@ -28,3 +38,5 @@
- * This strategy makes it possible to do very late merging of IO requests.
- * A new bio sent to pkt_make_request can be merged with a live packet_data
- * object even if the object is in the data gathering state.
+ * At the top layer there is a custom make_request_fn function that forwards
+ * read requests directly to the iosched queue and puts write requests in the
+ * unaligned write queue. A kernel thread performs the necessary read
+ * gathering to convert the unaligned writes to aligned writes and then feeds
+ * them to the packet I/O scheduler.
@@ -103 +115 @@
-	bvl = kmalloc(nr_iovecs * sizeof(struct bio_vec), GFP_KERNEL);
+	bvl = kcalloc(nr_iovecs, sizeof(struct bio_vec), GFP_KERNEL);
@@ -106 +117,0 @@
-	memset(bvl, 0, nr_iovecs * sizeof(struct bio_vec));
@@ -128 +139 @@
-	pkt = kmalloc(sizeof(struct packet_data), GFP_KERNEL);
+	pkt = kzalloc(sizeof(struct packet_data), GFP_KERNEL);
@@ -131 +141,0 @@
-	memset(pkt, 0, sizeof(struct packet_data));
@@ -222 +232 @@
-static void *pkt_rb_alloc(unsigned int __nocast gfp_mask, void *data)
+static void *pkt_rb_alloc(gfp_t gfp_mask, void *data)
@@ -662 +671,0 @@
-			BUG_ON(offs > PAGE_SIZE);
@@ -727,6 +735,0 @@
-	if (pkt->cache_valid) {
-		VPRINTK("pkt_gather_data: zone %llx cached\n",
-			(unsigned long long)pkt->sector);
-		goto out_account;
-	}
-
@@ -740,0 +744 @@
+		pd->stats.secs_w += num_frames * (CD_FRAMESIZE >> 9);
@@ -747,0 +752,6 @@
+	if (pkt->cache_valid) {
+		VPRINTK("pkt_gather_data: zone %llx cached\n",
+			(unsigned long long)pkt->sector);
+		goto out_account;
+	}
+
@@ -781 +790,0 @@
-	pd->stats.secs_w += pd->settings.size;
@@ -797 +806 @@
-			break;
+			return pkt;
@@ -800 +809,2 @@
-	return pkt;
+	BUG();
+	return NULL;
@@ -944 +953,0 @@
-	BUG_ON(!pkt);
@@ -949 +957,0 @@
-	BUG_ON(pkt->frames > PACKET_MAX_SIZE);
@@ -1638,0 +1647,4 @@
+	if (pd->settings.size > PACKET_MAX_SECTORS) {
+		printk("pktcdvd: packet size is too big\n");
+		return -ENXIO;
+	}
@@ -2073 +2085 @@
-static void *psd_pool_alloc(unsigned int __nocast gfp_mask, void *data)
+static void *psd_pool_alloc(gfp_t gfp_mask, void *data)
@@ -2201 +2212,0 @@
-	BUG_ON(!node);
@@ -2409 +2419,0 @@
-	BUG_ON(!pd);
@@ -2480 +2490 @@
-	pd = kmalloc(sizeof(struct pktcdvd_device), GFP_KERNEL);
+	pd = kzalloc(sizeof(struct pktcdvd_device), GFP_KERNEL);
@@ -2483 +2492,0 @@
-	memset(pd, 0, sizeof(struct pktcdvd_device));
--- ./projects/linux/linux-2.6.14/drivers/block/pktcdvd.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/block/pktcdvd.c	2006-01-03 04:21:10.000000000 +0100
@@ -514 +513,0 @@
-	request_queue_t *q;
@@ -520,2 +518,0 @@
-	q = bdev_get_queue(pd->bdev);
-
@@ -1194 +1191 @@
-	for (i = 0; i <= PACKET_NUM_STATES; i++)
+	for (i = 0; i < PACKET_NUM_STATES; i++)
--- ./projects/linux/linux-2.6.15/drivers/block/pktcdvd.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/block/pktcdvd.c	2006-03-20 06:53:29.000000000 +0100
@@ -46,2 +45,0 @@
-#define VERSION_CODE	"v0.2.0a 2004-07-14 Jens Axboe (axboe@suse.de) and petero2@telia.com"
-
@@ -62,0 +61 @@
+#include <scsi/scsi.h>
@@ -134 +133 @@
-static struct packet_data *pkt_alloc_packet_data(void)
+static struct packet_data *pkt_alloc_packet_data(int frames)
@@ -143 +142,2 @@
-	pkt->w_bio = pkt_bio_alloc(PACKET_MAX_SIZE);
+	pkt->frames = frames;
+	pkt->w_bio = pkt_bio_alloc(frames);
@@ -147 +147 @@
-	for (i = 0; i < PAGES_PER_PACKET; i++) {
+	for (i = 0; i < frames / FRAMES_PER_PAGE; i++) {
@@ -155 +155 @@
-	for (i = 0; i < PACKET_MAX_SIZE; i++) {
+	for (i = 0; i < frames; i++) {
@@ -165 +165 @@
-	for (i = 0; i < PACKET_MAX_SIZE; i++) {
+	for (i = 0; i < frames; i++) {
@@ -172 +172 @@
-	for (i = 0; i < PAGES_PER_PACKET; i++)
+	for (i = 0; i < frames / FRAMES_PER_PAGE; i++)
@@ -189 +189 @@
-	for (i = 0; i < PACKET_MAX_SIZE; i++) {
+	for (i = 0; i < pkt->frames; i++) {
@@ -194 +194 @@
-	for (i = 0; i < PAGES_PER_PACKET; i++)
+	for (i = 0; i < pkt->frames / FRAMES_PER_PAGE; i++)
@@ -208,0 +209 @@
+	INIT_LIST_HEAD(&pd->cdrw.pkt_free_list);
@@ -215,3 +216,2 @@
-	INIT_LIST_HEAD(&pd->cdrw.pkt_free_list);
-	INIT_LIST_HEAD(&pd->cdrw.pkt_active_list);
-	spin_lock_init(&pd->cdrw.active_list_lock);
+	BUG_ON(!list_empty(&pd->cdrw.pkt_free_list));
+
@@ -219 +219 @@
-		pkt = pkt_alloc_packet_data();
+		pkt = pkt_alloc_packet_data(pd->settings.size >> 2);
@@ -250 +250 @@
-static inline void pkt_rbtree_erase(struct pktcdvd_device *pd, struct pkt_rb_node *node)
+static void pkt_rbtree_erase(struct pktcdvd_device *pd, struct pkt_rb_node *node)
@@ -318 +318 @@
-static inline void pkt_add_list_last(struct bio *bio, struct bio **list_head, struct bio **list_tail)
+static void pkt_add_list_last(struct bio *bio, struct bio **list_head, struct bio **list_tail)
@@ -383,0 +384 @@
+	rq->cmd_len = COMMAND_SIZE(rq->cmd[0]);
@@ -649 +650 @@
-static void pkt_make_local_copy(struct packet_data *pkt, struct page **pages, int *offsets)
+static void pkt_make_local_copy(struct packet_data *pkt, struct bio_vec *bvec)
@@ -657,2 +658,2 @@
-		if (pages[f] != pkt->pages[p]) {
-			void *vfrom = kmap_atomic(pages[f], KM_USER0) + offsets[f];
+		if (bvec[f].bv_page != pkt->pages[p]) {
+			void *vfrom = kmap_atomic(bvec[f].bv_page, KM_USER0) + bvec[f].bv_offset;
@@ -662,2 +663,2 @@
-			pages[f] = pkt->pages[p];
-			offsets[f] = offs;
+			bvec[f].bv_page = pkt->pages[p];
+			bvec[f].bv_offset = offs;
@@ -665 +666 @@
-			BUG_ON(offsets[f] != offs);
+			BUG_ON(bvec[f].bv_offset != offs);
@@ -954 +955 @@
-	pkt->frames = pd->settings.size >> 2;
+	BUG_ON(pkt->frames != pd->settings.size >> 2);
@@ -995,2 +995,0 @@
-	struct page *pages[PACKET_MAX_SIZE];
-	int offsets[PACKET_MAX_SIZE];
@@ -998,0 +998 @@
+	struct bio_vec *bvec = pkt->w_bio->bi_io_vec;
@@ -1001,2 +1001,2 @@
-		pages[f] = pkt->pages[(f * CD_FRAMESIZE) / PAGE_SIZE];
-		offsets[f] = (f * CD_FRAMESIZE) % PAGE_SIZE;
+		bvec[f].bv_page = pkt->pages[(f * CD_FRAMESIZE) / PAGE_SIZE];
+		bvec[f].bv_offset = (f * CD_FRAMESIZE) % PAGE_SIZE;
@@ -1006 +1006 @@
-	 * Fill-in pages[] and offsets[] with data from orig_bios.
+	 * Fill-in bvec with data from orig_bios.
@@ -1028,2 +1028,2 @@
-				pages[f] = src_bvl->bv_page;
-				offsets[f] = src_bvl->bv_offset + src_offs;
+				bvec[f].bv_page = src_bvl->bv_page;
+				bvec[f].bv_offset = src_bvl->bv_offset + src_offs;
@@ -1032 +1032 @@
-						  pages[f], offsets[f]);
+						  bvec[f].bv_page, bvec[f].bv_offset);
@@ -1046 +1046 @@
-		pkt_make_local_copy(pkt, pages, offsets);
+		pkt_make_local_copy(pkt, bvec);
@@ -1059,11 +1059,3 @@
-	for (f = 0; f < pkt->frames; f++) {
-		if ((f + 1 < pkt->frames) && (pages[f + 1] == pages[f]) &&
-		    (offsets[f + 1] = offsets[f] + CD_FRAMESIZE)) {
-			if (!bio_add_page(pkt->w_bio, pages[f], CD_FRAMESIZE * 2, offsets[f]))
-				BUG();
-			f++;
-		} else {
-			if (!bio_add_page(pkt->w_bio, pages[f], CD_FRAMESIZE, offsets[f]))
-				BUG();
-		}
-	}
+	for (f = 0; f < pkt->frames; f++)
+		if (!bio_add_page(pkt->w_bio, bvec[f].bv_page, CD_FRAMESIZE, bvec[f].bv_offset))
+			BUG();
@@ -1508 +1500 @@
- * 0 -- we can write to this track, 1 -- we can't
+ * 1 -- we can write to this track, 0 -- we can't
@@ -1510 +1502 @@
-static int pkt_good_track(track_information *ti)
+static int pkt_writable_track(struct pktcdvd_device *pd, track_information *ti)
@@ -1512,3 +1504,8 @@
-	/*
-	 * only good for CD-RW at the moment, not DVD-RW
-	 */
+	switch (pd->mmc3_profile) {
+		case 0x1a: /* DVD+RW */
+		case 0x12: /* DVD-RAM */
+			/* The track is always writable on DVD+RW/DVD-RAM */
+			return 1;
+		default:
+			break;
+	}
@@ -1516,4 +1513 @@
-	/*
-	 * FIXME: only for FP
-	 */
-	if (ti->fp == 0)
+	if (!ti->packet || !ti->fp)
@@ -1525,2 +1519,2 @@
-	if (ti->rt == 0 && ti->blank == 0 && ti->packet == 1)
-		return 0;
+	if (ti->rt == 0 && ti->blank == 0)
+		return 1;
@@ -1528,2 +1522,2 @@
-	if (ti->rt == 0 && ti->blank == 1 && ti->packet == 1)
-		return 0;
+	if (ti->rt == 0 && ti->blank == 1)
+		return 1;
@@ -1531,2 +1525,2 @@
-	if (ti->rt == 1 && ti->blank == 0 && ti->packet == 1)
-		return 0;
+	if (ti->rt == 1 && ti->blank == 0)
+		return 1;
@@ -1535 +1529 @@
-	return 1;
+	return 0;
@@ -1539 +1533 @@
- * 0 -- we can write to this disc, 1 -- we can't
+ * 1 -- we can write to this disc, 0 -- we can't
@@ -1541 +1535 @@
-static int pkt_good_disc(struct pktcdvd_device *pd, disc_information *di)
+static int pkt_writable_disc(struct pktcdvd_device *pd, disc_information *di)
@@ -1550,3 +1543,0 @@
-			return 0;
-		default:
-			printk("pktcdvd: Wrong disc profile (%x)\n", pd->mmc3_profile);
@@ -1553,0 +1545,3 @@
+		default:
+			VPRINTK("pktcdvd: Wrong disc profile (%x)\n", pd->mmc3_profile);
+			return 0;
@@ -1562 +1556 @@
-		return 1;
+		return 0;
@@ -1567 +1561 @@
-		return 1;
+		return 0;
@@ -1572 +1566 @@
-		return 1;
+		return 0;
@@ -1577 +1571 @@
-		return 1;
+		return 0;
@@ -1580 +1574 @@
-	return 0;
+	return 1;
@@ -1605,2 +1599,2 @@
-	if (pkt_good_disc(pd, &di))
-		return -ENXIO;
+	if (!pkt_writable_disc(pd, &di))
+		return -EROFS;
@@ -1608,14 +1601,0 @@
-	switch (pd->mmc3_profile) {
-		case 0x1a: /* DVD+RW */
-			printk("pktcdvd: inserted media is DVD+RW\n");
-			break;
-		case 0x13: /* DVD-RW */
-			printk("pktcdvd: inserted media is DVD-RW\n");
-			break;
-		case 0x12: /* DVD-RAM */
-			printk("pktcdvd: inserted media is DVD-RAM\n");
-			break;
-		default:
-			printk("pktcdvd: inserted media is CD-R%s\n", di.erasable ? "W" : "");
-			break;
-	}
@@ -1630 +1610 @@
-	if (pkt_good_track(&ti)) {
+	if (!pkt_writable_track(pd, &ti)) {
@@ -1632 +1612 @@
-		return -ENXIO;
+		return -EROFS;
@@ -1642 +1622 @@
-		pd->settings.size = 128;
+		return -ENXIO;
@@ -1646 +1626 @@
-		return -ENXIO;
+		return -EROFS;
@@ -1688 +1668 @@
-			return 1;
+			return -EROFS;
@@ -1898,2 +1878,2 @@
-		DPRINTK("pktcdvd: %s failed probe\n", pd->name);
-		return -EIO;
+		VPRINTK("pktcdvd: %s failed probe\n", pd->name);
+		return ret;
@@ -1957,0 +1938,3 @@
+	if ((ret = bd_claim(pd->bdev, pd)))
+		goto out_putdev;
+
@@ -1960 +1943 @@
-		goto out_putdev;
+		goto out_unclaim;
@@ -1970 +1953 @@
-			goto out_putdev;
+			goto out_unclaim;
@@ -1985 +1968 @@
-		goto out_putdev;
+		goto out_unclaim;
@@ -1987 +1970,6 @@
-	if (write)
+	if (write) {
+		if (!pkt_grow_pktlist(pd, CONFIG_CDROM_PKTCDVD_BUFFERS)) {
+			printk("pktcdvd: not enough memory for buffers\n");
+			ret = -ENOMEM;
+			goto out_unclaim;
+		}
@@ -1988,0 +1977 @@
+	}
@@ -1991,0 +1981,2 @@
+out_unclaim:
+	bd_release(pd->bdev);
@@ -2009,0 +2001 @@
+	bd_release(pd->bdev);
@@ -2010,0 +2003,2 @@
+
+	pkt_shrink_pktlist(pd);
@@ -2043,2 +2037,2 @@
-		if (pkt_open_dev(pd, file->f_mode & FMODE_WRITE)) {
-			ret = -EIO;
+		ret = pkt_open_dev(pd, file->f_mode & FMODE_WRITE);
+		if (ret)
@@ -2046 +2039,0 @@
-		}
@@ -2376,6 +2368,0 @@
-	if (!pkt_grow_pktlist(pd, CONFIG_CDROM_PKTCDVD_BUFFERS)) {
-		printk("pktcdvd: not enough memory for buffers\n");
-		ret = -ENOMEM;
-		goto out_mem;
-	}
-
@@ -2392 +2379 @@
-		goto out_thread;
+		goto out_mem;
@@ -2403,2 +2389,0 @@
-out_thread:
-	pkt_shrink_pktlist(pd);
@@ -2434 +2419,2 @@
-		pkt_lock_door(pd, 0);
+		if (pd->refcnt == 1)
+			pkt_lock_door(pd, 0);
@@ -2438 +2424 @@
-		printk("pktcdvd: Unknown ioctl for %s (%x)\n", pd->name, cmd);
+		VPRINTK("pktcdvd: Unknown ioctl for %s (%x)\n", pd->name, cmd);
@@ -2499,0 +2486,4 @@
+	INIT_LIST_HEAD(&pd->cdrw.pkt_free_list);
+	INIT_LIST_HEAD(&pd->cdrw.pkt_active_list);
+	spin_lock_init(&pd->cdrw.active_list_lock);
+
@@ -2564,2 +2553,0 @@
-	pkt_shrink_pktlist(pd);
-
@@ -2675 +2662,0 @@
-	DPRINTK("pktcdvd: %s\n", VERSION_CODE);
--- ./projects/linux/linux-2.6.16/drivers/block/pktcdvd.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/block/pktcdvd.c	2006-06-18 03:49:35.000000000 +0200
@@ -58,0 +59 @@
+#include <linux/mutex.h>
@@ -84 +85 @@
-static struct semaphore ctl_mutex;	/* Serialize open/close/setup/teardown */
+static struct mutex ctl_mutex;	/* Serialize open/close/setup/teardown */
@@ -232,10 +232,0 @@
-static void *pkt_rb_alloc(gfp_t gfp_mask, void *data)
-{
-	return kmalloc(sizeof(struct pkt_rb_node), gfp_mask);
-}
-
-static void pkt_rb_free(void *ptr, void *data)
-{
-	kfree(ptr);
-}
-
@@ -2021 +2012 @@
-	down(&ctl_mutex);
+	mutex_lock(&ctl_mutex);
@@ -2047 +2038 @@
-	up(&ctl_mutex);
+	mutex_unlock(&ctl_mutex);
@@ -2054 +2045 @@
-	up(&ctl_mutex);
+	mutex_unlock(&ctl_mutex);
@@ -2063 +2054 @@
-	down(&ctl_mutex);
+	mutex_lock(&ctl_mutex);
@@ -2070 +2061 @@
-	up(&ctl_mutex);
+	mutex_unlock(&ctl_mutex);
@@ -2075,10 +2065,0 @@
-static void *psd_pool_alloc(gfp_t gfp_mask, void *data)
-{
-	return kmalloc(sizeof(struct packet_stacked_data), gfp_mask);
-}
-
-static void psd_pool_free(void *ptr, void *data)
-{
-	kfree(ptr);
-}
-
@@ -2477 +2458,2 @@
-	pd->rb_pool = mempool_create(PKT_RB_POOL_SIZE, pkt_rb_alloc, pkt_rb_free, NULL);
+	pd->rb_pool = mempool_create_kmalloc_pool(PKT_RB_POOL_SIZE,
+						  sizeof(struct pkt_rb_node));
@@ -2517 +2499 @@
-	blk_put_queue(disk->queue);
+	blk_cleanup_queue(disk->queue);
@@ -2558 +2540 @@
-	blk_put_queue(pd->disk->queue);
+	blk_cleanup_queue(pd->disk->queue);
@@ -2599 +2581 @@
-		down(&ctl_mutex);
+		mutex_lock(&ctl_mutex);
@@ -2601 +2583 @@
-		up(&ctl_mutex);
+		mutex_unlock(&ctl_mutex);
@@ -2606 +2588 @@
-		down(&ctl_mutex);
+		mutex_lock(&ctl_mutex);
@@ -2608 +2590 @@
-		up(&ctl_mutex);
+		mutex_unlock(&ctl_mutex);
@@ -2611 +2593 @@
-		down(&ctl_mutex);
+		mutex_lock(&ctl_mutex);
@@ -2613 +2595 @@
-		up(&ctl_mutex);
+		mutex_unlock(&ctl_mutex);
@@ -2641 +2623,2 @@
-	psd_pool = mempool_create(PSD_POOL_SIZE, psd_pool_alloc, psd_pool_free, NULL);
+	psd_pool = mempool_create_kmalloc_pool(PSD_POOL_SIZE,
+					sizeof(struct packet_stacked_data));
@@ -2659 +2642 @@
-	init_MUTEX(&ctl_mutex);
+	mutex_init(&ctl_mutex);
--- ./projects/linux/linux-2.6.17/drivers/block/pktcdvd.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/block/pktcdvd.c	2006-09-20 05:42:06.000000000 +0200
@@ -47 +46,0 @@
-#include <linux/config.h>
@@ -2581 +2580 @@
-		mutex_lock(&ctl_mutex);
+		mutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);
@@ -2588 +2587 @@
-		mutex_lock(&ctl_mutex);
+		mutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);
@@ -2593 +2592 @@
-		mutex_lock(&ctl_mutex);
+		mutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);
@@ -2615 +2613,0 @@
-	.devfs_name 	= "pktcdvd/control",
--- ./projects/linux/linux-2.6.18/drivers/block/pktcdvd.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/block/pktcdvd.c	2006-11-29 22:57:37.000000000 +0100
@@ -64,0 +65,2 @@
+#define DRIVER_NAME	"pktcdvd"
+
@@ -83 +85 @@
-static int pkt_major;
+static int pktdev_major;
@@ -92 +94 @@
-		VPRINTK("pktcdvd: queue empty\n");
+		VPRINTK(DRIVER_NAME": queue empty\n");
@@ -351 +353 @@
-	DECLARE_COMPLETION(wait);
+	DECLARE_COMPLETION_ONSTACK(wait);
@@ -368 +370,2 @@
-	rq->flags |= REQ_BLOCK_PC | REQ_HARDBARRIER;
+	rq->cmd_type = REQ_TYPE_BLOCK_PC;
+	rq->cmd_flags |= REQ_HARDBARRIER;
@@ -370 +373 @@
-		rq->flags |= REQ_QUIET;
+		rq->cmd_flags |= REQ_QUIET;
@@ -377,2 +380 @@
-	rq->flags |= REQ_NOMERGE;
-	rq->waiting = &wait;
+	rq->end_io_data = &wait;
@@ -403 +405 @@
-	printk("pktcdvd:");
+	printk(DRIVER_NAME":");
@@ -531 +533 @@
-					VPRINTK("pktcdvd: write, waiting\n");
+					VPRINTK(DRIVER_NAME": write, waiting\n");
@@ -540 +542 @@
-					VPRINTK("pktcdvd: read, waiting\n");
+					VPRINTK(DRIVER_NAME": read, waiting\n");
@@ -603 +605 @@
-		printk("pktcdvd: cdrom max_phys_segments too small\n");
+		printk(DRIVER_NAME": cdrom max_phys_segments too small\n");
@@ -1052 +1054 @@
-	VPRINTK("pktcdvd: vcnt=%d\n", pkt->w_bio->bi_vcnt);
+	VPRINTK(DRIVER_NAME": vcnt=%d\n", pkt->w_bio->bi_vcnt);
@@ -1289 +1291 @@
-	printk("pktcdvd: %s packets, ", pd->settings.fp ? "Fixed" : "Variable");
+	printk(DRIVER_NAME": %s packets, ", pd->settings.fp ? "Fixed" : "Variable");
@@ -1474 +1476 @@
-		printk("pktcdvd: write mode wrong %d\n", wp->data_block_type);
+		printk(DRIVER_NAME": write mode wrong %d\n", wp->data_block_type);
@@ -1518 +1520 @@
-	printk("pktcdvd: bad state %d-%d-%d\n", ti->rt, ti->blank, ti->packet);
+	printk(DRIVER_NAME": bad state %d-%d-%d\n", ti->rt, ti->blank, ti->packet);
@@ -1536 +1538 @@
-			VPRINTK("pktcdvd: Wrong disc profile (%x)\n", pd->mmc3_profile);
+			VPRINTK(DRIVER_NAME": Wrong disc profile (%x)\n", pd->mmc3_profile);
@@ -1545 +1547 @@
-		printk("pktcdvd: Unknown disc. No track?\n");
+		printk(DRIVER_NAME": Unknown disc. No track?\n");
@@ -1550 +1552 @@
-		printk("pktcdvd: Wrong disc type (%x)\n", di->disc_type);
+		printk(DRIVER_NAME": Wrong disc type (%x)\n", di->disc_type);
@@ -1555 +1557 @@
-		printk("pktcdvd: Disc not erasable\n");
+		printk(DRIVER_NAME": Disc not erasable\n");
@@ -1560 +1562 @@
-		printk("pktcdvd: Can't write to last track (reserved)\n");
+		printk(DRIVER_NAME": Can't write to last track (reserved)\n");
@@ -1596 +1598 @@
-		printk("pktcdvd: failed get_track\n");
+		printk(DRIVER_NAME": failed get_track\n");
@@ -1601 +1603 @@
-		printk("pktcdvd: can't write to this track\n");
+		printk(DRIVER_NAME": can't write to this track\n");
@@ -1611 +1613 @@
-		printk("pktcdvd: detected zero packet size!\n");
+		printk(DRIVER_NAME": detected zero packet size!\n");
@@ -1615 +1617 @@
-		printk("pktcdvd: packet size is too big\n");
+		printk(DRIVER_NAME": packet size is too big\n");
@@ -1657 +1659 @@
-			printk("pktcdvd: unknown data mode\n");
+			printk(DRIVER_NAME": unknown data mode\n");
@@ -1691 +1693 @@
-		printk("pktcdvd: write caching control failed\n");
+		printk(DRIVER_NAME": write caching control failed\n");
@@ -1694 +1696 @@
-		printk("pktcdvd: enabled write caching on %s\n", pd->name);
+		printk(DRIVER_NAME": enabled write caching on %s\n", pd->name);
@@ -1808 +1810 @@
-		printk("pktcdvd: Disc type is not CD-RW\n");
+		printk(DRIVER_NAME": Disc type is not CD-RW\n");
@@ -1812 +1814 @@
-		printk("pktcdvd: A1 values on media are not valid, maybe not CDRW?\n");
+		printk(DRIVER_NAME": A1 values on media are not valid, maybe not CDRW?\n");
@@ -1832 +1834 @@
-			printk("pktcdvd: Unknown disc sub-type %d\n",st);
+			printk(DRIVER_NAME": Unknown disc sub-type %d\n",st);
@@ -1836 +1838 @@
-		printk("pktcdvd: Max. media speed: %d\n",*speed);
+		printk(DRIVER_NAME": Max. media speed: %d\n",*speed);
@@ -1839 +1841 @@
-		printk("pktcdvd: Unknown speed %d for sub-type %d\n",sp,st);
+		printk(DRIVER_NAME": Unknown speed %d for sub-type %d\n",sp,st);
@@ -1850 +1852 @@
-	VPRINTK("pktcdvd: Performing OPC\n");
+	VPRINTK(DRIVER_NAME": Performing OPC\n");
@@ -1868 +1870 @@
-		VPRINTK("pktcdvd: %s failed probe\n", pd->name);
+		VPRINTK(DRIVER_NAME": %s failed probe\n", pd->name);
@@ -1873 +1875 @@
-		DPRINTK("pktcdvd: %s failed saving write settings\n", pd->name);
+		DPRINTK(DRIVER_NAME": %s failed saving write settings\n", pd->name);
@@ -1885 +1887 @@
-			DPRINTK("pktcdvd: write speed %ukB/s\n", write_speed);
+			DPRINTK(DRIVER_NAME": write speed %ukB/s\n", write_speed);
@@ -1891 +1893 @@
-			DPRINTK("pktcdvd: write speed %ux\n", write_speed / 176);
+			DPRINTK(DRIVER_NAME": write speed %ux\n", write_speed / 176);
@@ -1897 +1899 @@
-		DPRINTK("pktcdvd: %s couldn't set write speed\n", pd->name);
+		DPRINTK(DRIVER_NAME": %s couldn't set write speed\n", pd->name);
@@ -1904 +1906 @@
-		DPRINTK("pktcdvd: %s Optimum Power Calibration failed\n", pd->name);
+		DPRINTK(DRIVER_NAME": %s Optimum Power Calibration failed\n", pd->name);
@@ -1932 +1934 @@
-		printk("pktcdvd: pkt_get_last_written failed\n");
+		printk(DRIVER_NAME": pkt_get_last_written failed\n");
@@ -1962 +1964 @@
-			printk("pktcdvd: not enough memory for buffers\n");
+			printk(DRIVER_NAME": not enough memory for buffers\n");
@@ -1966 +1968 @@
-		printk("pktcdvd: %lukB available on disc\n", lba << 1);
+		printk(DRIVER_NAME": %lukB available on disc\n", lba << 1);
@@ -1986 +1988 @@
-		DPRINTK("pktcdvd: %s not flushing cache\n", pd->name);
+		DPRINTK(DRIVER_NAME": %s not flushing cache\n", pd->name);
@@ -2009 +2011 @@
-	VPRINTK("pktcdvd: entering open\n");
+	VPRINTK(DRIVER_NAME": entering open\n");
@@ -2043 +2045 @@
-	VPRINTK("pktcdvd: failed open (%d)\n", ret);
+	VPRINTK(DRIVER_NAME": failed open (%d)\n", ret);
@@ -2091 +2093 @@
-		printk("pktcdvd: %s incorrect request queue\n", bdevname(bio->bi_bdev, b));
+		printk(DRIVER_NAME": %s incorrect request queue\n", bdevname(bio->bi_bdev, b));
@@ -2113 +2115 @@
-		printk("pktcdvd: WRITE for ro device %s (%llu)\n",
+		printk(DRIVER_NAME": WRITE for ro device %s (%llu)\n",
@@ -2119 +2121 @@
-		printk("pktcdvd: wrong bio size\n");
+		printk(DRIVER_NAME": wrong bio size\n");
@@ -2322 +2324 @@
-		printk("pktcdvd: Recursive setup not allowed\n");
+		printk(DRIVER_NAME": Recursive setup not allowed\n");
@@ -2330 +2332 @@
-			printk("pktcdvd: %s already setup\n", bdevname(pd2->bdev, b));
+			printk(DRIVER_NAME": %s already setup\n", bdevname(pd2->bdev, b));
@@ -2334 +2336 @@
-			printk("pktcdvd: Can't chain pktcdvd devices\n");
+			printk(DRIVER_NAME": Can't chain pktcdvd devices\n");
@@ -2357 +2359 @@
-		printk("pktcdvd: can't start kernel thread\n");
+		printk(DRIVER_NAME": can't start kernel thread\n");
@@ -2367 +2369 @@
-	DPRINTK("pktcdvd: writer %s mapped to %s\n", pd->name, bdevname(bdev, b));
+	DPRINTK(DRIVER_NAME": writer %s mapped to %s\n", pd->name, bdevname(bdev, b));
@@ -2404 +2406 @@
-		VPRINTK("pktcdvd: Unknown ioctl for %s (%x)\n", pd->name, cmd);
+		VPRINTK(DRIVER_NAME": Unknown ioctl for %s (%x)\n", pd->name, cmd);
@@ -2449 +2451 @@
-		printk("pktcdvd: max %d writers supported\n", MAX_WRITERS);
+		printk(DRIVER_NAME": max %d writers supported\n", MAX_WRITERS);
@@ -2473 +2475 @@
-	sprintf(pd->name, "pktcdvd%d", idx);
+	sprintf(pd->name, DRIVER_NAME"%d", idx);
@@ -2477 +2479 @@
-	disk->major = pkt_major;
+	disk->major = pktdev_major;
@@ -2481 +2483 @@
-	sprintf(disk->disk_name, "pktcdvd%d", idx);
+	sprintf(disk->disk_name, DRIVER_NAME"%d", idx);
@@ -2523 +2525 @@
-		DPRINTK("pktcdvd: dev not setup\n");
+		DPRINTK(DRIVER_NAME": dev not setup\n");
@@ -2536 +2538 @@
-	DPRINTK("pktcdvd: writer %s unmapped\n", pd->name);
+	DPRINTK(DRIVER_NAME": writer %s unmapped\n", pd->name);
@@ -2613 +2615 @@
-	.name  		= "pktcdvd",
+	.name  		= DRIVER_NAME,
@@ -2626 +2628 @@
-	ret = register_blkdev(pkt_major, "pktcdvd");
+	ret = register_blkdev(pktdev_major, DRIVER_NAME);
@@ -2628 +2630 @@
-		printk("pktcdvd: Unable to register block device\n");
+		printk(DRIVER_NAME": Unable to register block device\n");
@@ -2631,2 +2633,2 @@
-	if (!pkt_major)
-		pkt_major = ret;
+	if (!pktdev_major)
+		pktdev_major = ret;
@@ -2636 +2638 @@
-		printk("pktcdvd: Unable to register misc device\n");
+		printk(DRIVER_NAME": Unable to register misc device\n");
@@ -2642 +2644 @@
-	pkt_proc = proc_mkdir("pktcdvd", proc_root_driver);
+	pkt_proc = proc_mkdir(DRIVER_NAME, proc_root_driver);
@@ -2647 +2649 @@
-	unregister_blkdev(pkt_major, "pktcdvd");
+	unregister_blkdev(pktdev_major, DRIVER_NAME);
@@ -2655 +2657 @@
-	remove_proc_entry("pktcdvd", proc_root_driver);
+	remove_proc_entry(DRIVER_NAME, proc_root_driver);
@@ -2657 +2659 @@
-	unregister_blkdev(pkt_major, "pktcdvd");
+	unregister_blkdev(pktdev_major, DRIVER_NAME);
--- ./projects/linux/linux-2.6.19/drivers/block/pktcdvd.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/block/pktcdvd.c	2007-02-04 19:44:54.000000000 +0100
@@ -3,0 +4 @@
+ * Copyright (C) 2006 Thomas Maier <balagi@justmail.de>
@@ -57 +58 @@
-#include <linux/suspend.h>
+#include <linux/freezer.h>
@@ -61,0 +63,2 @@
+#include <linux/debugfs.h>
+#include <linux/device.h>
@@ -85,0 +89,2 @@
+static int write_congestion_on  = PKT_WRITE_CONGESTION_ON;
+static int write_congestion_off = PKT_WRITE_CONGESTION_OFF;
@@ -88,0 +94,413 @@
+static struct class	*class_pktcdvd = NULL;    /* /sys/class/pktcdvd */
+static struct dentry	*pkt_debugfs_root = NULL; /* /debug/pktcdvd */
+
+/* forward declaration */
+static int pkt_setup_dev(dev_t dev, dev_t* pkt_dev);
+static int pkt_remove_dev(dev_t pkt_dev);
+static int pkt_seq_show(struct seq_file *m, void *p);
+
+
+
+/*
+ * create and register a pktcdvd kernel object.
+ */
+static struct pktcdvd_kobj* pkt_kobj_create(struct pktcdvd_device *pd,
+					const char* name,
+					struct kobject* parent,
+					struct kobj_type* ktype)
+{
+	struct pktcdvd_kobj *p;
+	p = kzalloc(sizeof(*p), GFP_KERNEL);
+	if (!p)
+		return NULL;
+	kobject_set_name(&p->kobj, "%s", name);
+	p->kobj.parent = parent;
+	p->kobj.ktype = ktype;
+	p->pd = pd;
+	if (kobject_register(&p->kobj) != 0)
+		return NULL;
+	return p;
+}
+/*
+ * remove a pktcdvd kernel object.
+ */
+static void pkt_kobj_remove(struct pktcdvd_kobj *p)
+{
+	if (p)
+		kobject_unregister(&p->kobj);
+}
+/*
+ * default release function for pktcdvd kernel objects.
+ */
+static void pkt_kobj_release(struct kobject *kobj)
+{
+	kfree(to_pktcdvdkobj(kobj));
+}
+
+
+/**********************************************************
+ *
+ * sysfs interface for pktcdvd
+ * by (C) 2006  Thomas Maier <balagi@justmail.de>
+ *
+ **********************************************************/
+
+#define DEF_ATTR(_obj,_name,_mode) \
+	static struct attribute _obj = { \
+		.name = _name, .owner = THIS_MODULE, .mode = _mode }
+
+/**********************************************************
+  /sys/class/pktcdvd/pktcdvd[0-7]/
+                     stat/reset
+                     stat/packets_started
+                     stat/packets_finished
+                     stat/kb_written
+                     stat/kb_read
+                     stat/kb_read_gather
+                     write_queue/size
+                     write_queue/congestion_off
+                     write_queue/congestion_on
+ **********************************************************/
+
+DEF_ATTR(kobj_pkt_attr_st1, "reset", 0200);
+DEF_ATTR(kobj_pkt_attr_st2, "packets_started", 0444);
+DEF_ATTR(kobj_pkt_attr_st3, "packets_finished", 0444);
+DEF_ATTR(kobj_pkt_attr_st4, "kb_written", 0444);
+DEF_ATTR(kobj_pkt_attr_st5, "kb_read", 0444);
+DEF_ATTR(kobj_pkt_attr_st6, "kb_read_gather", 0444);
+
+static struct attribute *kobj_pkt_attrs_stat[] = {
+	&kobj_pkt_attr_st1,
+	&kobj_pkt_attr_st2,
+	&kobj_pkt_attr_st3,
+	&kobj_pkt_attr_st4,
+	&kobj_pkt_attr_st5,
+	&kobj_pkt_attr_st6,
+	NULL
+};
+
+DEF_ATTR(kobj_pkt_attr_wq1, "size", 0444);
+DEF_ATTR(kobj_pkt_attr_wq2, "congestion_off", 0644);
+DEF_ATTR(kobj_pkt_attr_wq3, "congestion_on",  0644);
+
+static struct attribute *kobj_pkt_attrs_wqueue[] = {
+	&kobj_pkt_attr_wq1,
+	&kobj_pkt_attr_wq2,
+	&kobj_pkt_attr_wq3,
+	NULL
+};
+
+/* declares a char buffer[64] _dbuf, copies data from
+ * _b with length _l into it and ensures that _dbuf ends
+ * with a \0 character.
+ */
+#define DECLARE_BUF_AS_STRING(_dbuf, _b, _l) \
+	char _dbuf[64]; int dlen = (_l) < 0 ? 0 : (_l); \
+	if (dlen >= sizeof(_dbuf)) dlen = sizeof(_dbuf)-1; \
+	memcpy(_dbuf, _b, dlen); _dbuf[dlen] = 0
+
+static ssize_t kobj_pkt_show(struct kobject *kobj,
+			struct attribute *attr, char *data)
+{
+	struct pktcdvd_device *pd = to_pktcdvdkobj(kobj)->pd;
+	int n = 0;
+	int v;
+	if (strcmp(attr->name, "packets_started") == 0) {
+		n = sprintf(data, "%lu\n", pd->stats.pkt_started);
+
+	} else if (strcmp(attr->name, "packets_finished") == 0) {
+		n = sprintf(data, "%lu\n", pd->stats.pkt_ended);
+
+	} else if (strcmp(attr->name, "kb_written") == 0) {
+		n = sprintf(data, "%lu\n", pd->stats.secs_w >> 1);
+
+	} else if (strcmp(attr->name, "kb_read") == 0) {
+		n = sprintf(data, "%lu\n", pd->stats.secs_r >> 1);
+
+	} else if (strcmp(attr->name, "kb_read_gather") == 0) {
+		n = sprintf(data, "%lu\n", pd->stats.secs_rg >> 1);
+
+	} else if (strcmp(attr->name, "size") == 0) {
+		spin_lock(&pd->lock);
+		v = pd->bio_queue_size;
+		spin_unlock(&pd->lock);
+		n = sprintf(data, "%d\n", v);
+
+	} else if (strcmp(attr->name, "congestion_off") == 0) {
+		spin_lock(&pd->lock);
+		v = pd->write_congestion_off;
+		spin_unlock(&pd->lock);
+		n = sprintf(data, "%d\n", v);
+
+	} else if (strcmp(attr->name, "congestion_on") == 0) {
+		spin_lock(&pd->lock);
+		v = pd->write_congestion_on;
+		spin_unlock(&pd->lock);
+		n = sprintf(data, "%d\n", v);
+	}
+	return n;
+}
+
+static void init_write_congestion_marks(int* lo, int* hi)
+{
+	if (*hi > 0) {
+		*hi = max(*hi, 500);
+		*hi = min(*hi, 1000000);
+		if (*lo <= 0)
+			*lo = *hi - 100;
+		else {
+			*lo = min(*lo, *hi - 100);
+			*lo = max(*lo, 100);
+		}
+	} else {
+		*hi = -1;
+		*lo = -1;
+	}
+}
+
+static ssize_t kobj_pkt_store(struct kobject *kobj,
+			struct attribute *attr,
+			const char *data, size_t len)
+{
+	struct pktcdvd_device *pd = to_pktcdvdkobj(kobj)->pd;
+	int val;
+	DECLARE_BUF_AS_STRING(dbuf, data, len); /* ensure sscanf scans a string */
+
+	if (strcmp(attr->name, "reset") == 0 && dlen > 0) {
+		pd->stats.pkt_started = 0;
+		pd->stats.pkt_ended = 0;
+		pd->stats.secs_w = 0;
+		pd->stats.secs_rg = 0;
+		pd->stats.secs_r = 0;
+
+	} else if (strcmp(attr->name, "congestion_off") == 0
+		   && sscanf(dbuf, "%d", &val) == 1) {
+		spin_lock(&pd->lock);
+		pd->write_congestion_off = val;
+		init_write_congestion_marks(&pd->write_congestion_off,
+					&pd->write_congestion_on);
+		spin_unlock(&pd->lock);
+
+	} else if (strcmp(attr->name, "congestion_on") == 0
+		   && sscanf(dbuf, "%d", &val) == 1) {
+		spin_lock(&pd->lock);
+		pd->write_congestion_on = val;
+		init_write_congestion_marks(&pd->write_congestion_off,
+					&pd->write_congestion_on);
+		spin_unlock(&pd->lock);
+	}
+	return len;
+}
+
+static struct sysfs_ops kobj_pkt_ops = {
+	.show = kobj_pkt_show,
+	.store = kobj_pkt_store
+};
+static struct kobj_type kobj_pkt_type_stat = {
+	.release = pkt_kobj_release,
+	.sysfs_ops = &kobj_pkt_ops,
+	.default_attrs = kobj_pkt_attrs_stat
+};
+static struct kobj_type kobj_pkt_type_wqueue = {
+	.release = pkt_kobj_release,
+	.sysfs_ops = &kobj_pkt_ops,
+	.default_attrs = kobj_pkt_attrs_wqueue
+};
+
+static void pkt_sysfs_dev_new(struct pktcdvd_device *pd)
+{
+	if (class_pktcdvd) {
+		pd->clsdev = class_device_create(class_pktcdvd,
+					NULL, pd->pkt_dev,
+					NULL, "%s", pd->name);
+		if (IS_ERR(pd->clsdev))
+			pd->clsdev = NULL;
+	}
+	if (pd->clsdev) {
+		pd->kobj_stat = pkt_kobj_create(pd, "stat",
+					&pd->clsdev->kobj,
+					&kobj_pkt_type_stat);
+		pd->kobj_wqueue = pkt_kobj_create(pd, "write_queue",
+					&pd->clsdev->kobj,
+					&kobj_pkt_type_wqueue);
+	}
+}
+
+static void pkt_sysfs_dev_remove(struct pktcdvd_device *pd)
+{
+	pkt_kobj_remove(pd->kobj_stat);
+	pkt_kobj_remove(pd->kobj_wqueue);
+	if (class_pktcdvd)
+		class_device_destroy(class_pktcdvd, pd->pkt_dev);
+}
+
+
+/********************************************************************
+  /sys/class/pktcdvd/
+                     add            map block device
+                     remove         unmap packet dev
+                     device_map     show mappings
+ *******************************************************************/
+
+static void class_pktcdvd_release(struct class *cls)
+{
+	kfree(cls);
+}
+static ssize_t class_pktcdvd_show_map(struct class *c, char *data)
+{
+	int n = 0;
+	int idx;
+	mutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);
+	for (idx = 0; idx < MAX_WRITERS; idx++) {
+		struct pktcdvd_device *pd = pkt_devs[idx];
+		if (!pd)
+			continue;
+		n += sprintf(data+n, "%s %u:%u %u:%u\n",
+			pd->name,
+			MAJOR(pd->pkt_dev), MINOR(pd->pkt_dev),
+			MAJOR(pd->bdev->bd_dev),
+			MINOR(pd->bdev->bd_dev));
+	}
+	mutex_unlock(&ctl_mutex);
+	return n;
+}
+
+static ssize_t class_pktcdvd_store_add(struct class *c, const char *buf,
+					size_t count)
+{
+	unsigned int major, minor;
+	DECLARE_BUF_AS_STRING(dbuf, buf, count);
+	if (sscanf(dbuf, "%u:%u", &major, &minor) == 2) {
+		pkt_setup_dev(MKDEV(major, minor), NULL);
+		return count;
+	}
+	return -EINVAL;
+}
+
+static ssize_t class_pktcdvd_store_remove(struct class *c, const char *buf,
+					size_t count)
+{
+	unsigned int major, minor;
+	DECLARE_BUF_AS_STRING(dbuf, buf, count);
+	if (sscanf(dbuf, "%u:%u", &major, &minor) == 2) {
+		pkt_remove_dev(MKDEV(major, minor));
+		return count;
+	}
+	return -EINVAL;
+}
+
+static struct class_attribute class_pktcdvd_attrs[] = {
+ __ATTR(add,            0200, NULL, class_pktcdvd_store_add),
+ __ATTR(remove,         0200, NULL, class_pktcdvd_store_remove),
+ __ATTR(device_map,     0444, class_pktcdvd_show_map, NULL),
+ __ATTR_NULL
+};
+
+
+static int pkt_sysfs_init(void)
+{
+	int ret = 0;
+
+	/*
+	 * create control files in sysfs
+	 * /sys/class/pktcdvd/...
+	 */
+	class_pktcdvd = kzalloc(sizeof(*class_pktcdvd), GFP_KERNEL);
+	if (!class_pktcdvd)
+		return -ENOMEM;
+	class_pktcdvd->name = DRIVER_NAME;
+	class_pktcdvd->owner = THIS_MODULE;
+	class_pktcdvd->class_release = class_pktcdvd_release;
+	class_pktcdvd->class_attrs = class_pktcdvd_attrs;
+	ret = class_register(class_pktcdvd);
+	if (ret) {
+		kfree(class_pktcdvd);
+		class_pktcdvd = NULL;
+		printk(DRIVER_NAME": failed to create class pktcdvd\n");
+		return ret;
+	}
+	return 0;
+}
+
+static void pkt_sysfs_cleanup(void)
+{
+	if (class_pktcdvd)
+		class_destroy(class_pktcdvd);
+	class_pktcdvd = NULL;
+}
+
+/********************************************************************
+  entries in debugfs
+
+  /debugfs/pktcdvd[0-7]/
+			info
+
+ *******************************************************************/
+
+static int pkt_debugfs_seq_show(struct seq_file *m, void *p)
+{
+	return pkt_seq_show(m, p);
+}
+
+static int pkt_debugfs_fops_open(struct inode *inode, struct file *file)
+{
+	return single_open(file, pkt_debugfs_seq_show, inode->i_private);
+}
+
+static struct file_operations debug_fops = {
+	.open		= pkt_debugfs_fops_open,
+	.read		= seq_read,
+	.llseek		= seq_lseek,
+	.release	= single_release,
+	.owner		= THIS_MODULE,
+};
+
+static void pkt_debugfs_dev_new(struct pktcdvd_device *pd)
+{
+	if (!pkt_debugfs_root)
+		return;
+	pd->dfs_f_info = NULL;
+	pd->dfs_d_root = debugfs_create_dir(pd->name, pkt_debugfs_root);
+	if (IS_ERR(pd->dfs_d_root)) {
+		pd->dfs_d_root = NULL;
+		return;
+	}
+	pd->dfs_f_info = debugfs_create_file("info", S_IRUGO,
+				pd->dfs_d_root, pd, &debug_fops);
+	if (IS_ERR(pd->dfs_f_info)) {
+		pd->dfs_f_info = NULL;
+		return;
+	}
+}
+
+static void pkt_debugfs_dev_remove(struct pktcdvd_device *pd)
+{
+	if (!pkt_debugfs_root)
+		return;
+	if (pd->dfs_f_info)
+		debugfs_remove(pd->dfs_f_info);
+	pd->dfs_f_info = NULL;
+	if (pd->dfs_d_root)
+		debugfs_remove(pd->dfs_d_root);
+	pd->dfs_d_root = NULL;
+}
+
+static void pkt_debugfs_init(void)
+{
+	pkt_debugfs_root = debugfs_create_dir(DRIVER_NAME, NULL);
+	if (IS_ERR(pkt_debugfs_root)) {
+		pkt_debugfs_root = NULL;
+		return;
+	}
+}
+
+static void pkt_debugfs_cleanup(void)
+{
+	if (!pkt_debugfs_root)
+		return;
+	debugfs_remove(pkt_debugfs_root);
+	pkt_debugfs_root = NULL;
+}
+
+/* ----------------------------------------------------------*/
+
@@ -350,2 +768 @@
-	char sense[SCSI_SENSE_BUFFERSIZE];
-	request_queue_t *q;
+	request_queue_t *q = bdev_get_queue(pd->bdev);
@@ -353,2 +770 @@
-	DECLARE_COMPLETION_ONSTACK(wait);
-	int err = 0;
+	int ret = 0;
@@ -356 +772,12 @@
-	q = bdev_get_queue(pd->bdev);
+	rq = blk_get_request(q, (cgc->data_direction == CGC_DATA_WRITE) ?
+			     WRITE : READ, __GFP_WAIT);
+
+	if (cgc->buflen) {
+		if (blk_rq_map_kern(q, rq, cgc->buffer, cgc->buflen, __GFP_WAIT))
+			goto out;
+	}
+
+	rq->cmd_len = COMMAND_SIZE(rq->cmd[0]);
+	memcpy(rq->cmd, cgc->cmd, CDROM_PACKET_SIZE);
+	if (sizeof(rq->cmd) > CDROM_PACKET_SIZE)
+		memset(rq->cmd + CDROM_PACKET_SIZE, 0, sizeof(rq->cmd) - CDROM_PACKET_SIZE);
@@ -358,6 +784,0 @@
-	rq = blk_get_request(q, (cgc->data_direction == CGC_DATA_WRITE) ? WRITE : READ,
-			     __GFP_WAIT);
-	rq->errors = 0;
-	rq->rq_disk = pd->bdev->bd_disk;
-	rq->bio = NULL;
-	rq->buffer = NULL;
@@ -365,5 +785,0 @@
-	rq->data = cgc->buffer;
-	rq->data_len = cgc->buflen;
-	rq->sense = sense;
-	memset(sense, 0, sizeof(sense));
-	rq->sense_len = 0;
@@ -374,14 +789,0 @@
-	memcpy(rq->cmd, cgc->cmd, CDROM_PACKET_SIZE);
-	if (sizeof(rq->cmd) > CDROM_PACKET_SIZE)
-		memset(rq->cmd + CDROM_PACKET_SIZE, 0, sizeof(rq->cmd) - CDROM_PACKET_SIZE);
-	rq->cmd_len = COMMAND_SIZE(rq->cmd[0]);
-
-	rq->ref_count++;
-	rq->end_io_data = &wait;
-	rq->end_io = blk_end_sync_rq;
-	elv_add_request(q, rq, ELEVATOR_INSERT_BACK, 1);
-	generic_unplug_device(q);
-	wait_for_completion(&wait);
-
-	if (rq->errors)
-		err = -EIO;
@@ -388,0 +791,3 @@
+	blk_execute_rq(rq->q, pd->bdev->bd_disk, rq, 0);
+	ret = rq->errors;
+out:
@@ -390 +795 @@
-	return err;
+	return ret;
@@ -895,0 +1301 @@
+	int wakeup;
@@ -967,0 +1374,4 @@
+	/* check write congestion marks, and if bio_queue_size is
+	   below, wake up any waiters */
+	wakeup = (pd->write_congestion_on > 0
+	 		&& pd->bio_queue_size <= pd->write_congestion_off);
@@ -968,0 +1379,2 @@
+	if (wakeup)
+		blk_clear_queue_congested(pd->disk->queue, WRITE);
@@ -2180,0 +2593,17 @@
+ 	/*
+	 * Test if there is enough room left in the bio work queue
+	 * (queue size >= congestion on mark).
+	 * If not, wait till the work queue size is below the congestion off mark.
+	 */
+	spin_lock(&pd->lock);
+	if (pd->write_congestion_on > 0
+	    && pd->bio_queue_size >= pd->write_congestion_on) {
+		blk_set_queue_congested(q, WRITE);
+		do {
+			spin_unlock(&pd->lock);
+			congestion_wait(WRITE, HZ);
+			spin_lock(&pd->lock);
+		} while(pd->bio_queue_size > pd->write_congestion_off);
+	}
+	spin_unlock(&pd->lock);
+
@@ -2299,0 +2729,3 @@
+	seq_printf(m, "\twrite congestion marks:\toff=%d on=%d\n",
+			pd->write_congestion_off,
+			pd->write_congestion_on);
@@ -2439 +2871 @@
-static int pkt_setup_dev(struct pkt_ctrl_command *ctrl_cmd)
+static int pkt_setup_dev(dev_t dev, dev_t* pkt_dev)
@@ -2445 +2877,2 @@
-	dev_t dev = new_decode_dev(ctrl_cmd->dev);
+
+	mutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);
@@ -2452 +2885,2 @@
-		return -EBUSY;
+		ret = -EBUSY;
+		goto out_mutex;
@@ -2457 +2891 @@
-		return ret;
+		goto out_mutex;
@@ -2464,5 +2897,0 @@
-	disk = alloc_disk(1);
-	if (!disk)
-		goto out_mem;
-	pd->disk = disk;
-
@@ -2478,0 +2908,7 @@
+	pd->write_congestion_on  = write_congestion_on;
+	pd->write_congestion_off = write_congestion_off;
+
+	disk = alloc_disk(1);
+	if (!disk)
+		goto out_mem;
+	pd->disk = disk;
@@ -2483 +2919 @@
-	sprintf(disk->disk_name, DRIVER_NAME"%d", idx);
+	strcpy(disk->disk_name, pd->name);
@@ -2494,0 +2931,4 @@
+
+	pkt_sysfs_dev_new(pd);
+	pkt_debugfs_dev_new(pd);
+
@@ -2496 +2936,4 @@
-	ctrl_cmd->pkt_dev = new_encode_dev(pd->pkt_dev);
+	if (pkt_dev)
+		*pkt_dev = pd->pkt_dev;
+
+	mutex_unlock(&ctl_mutex);
@@ -2506,0 +2950,3 @@
+out_mutex:
+	mutex_unlock(&ctl_mutex);
+	printk(DRIVER_NAME": setup of pktcdvd device failed\n");
@@ -2513 +2959 @@
-static int pkt_remove_dev(struct pkt_ctrl_command *ctrl_cmd)
+static int pkt_remove_dev(dev_t pkt_dev)
@@ -2517 +2963,3 @@
-	dev_t pkt_dev = new_decode_dev(ctrl_cmd->pkt_dev);
+	int ret = 0;
+
+	mutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);
@@ -2526 +2974,2 @@
-		return -ENXIO;
+		ret = -ENXIO;
+		goto out;
@@ -2529,3 +2978,4 @@
-	if (pd->refcnt > 0)
-		return -EBUSY;
-
+	if (pd->refcnt > 0) {
+		ret = -EBUSY;
+		goto out;
+	}
@@ -2534,0 +2985,5 @@
+	pkt_devs[idx] = NULL;
+
+	pkt_debugfs_dev_remove(pd);
+	pkt_sysfs_dev_remove(pd);
+
@@ -2544 +2998,0 @@
-	pkt_devs[idx] = NULL;
@@ -2550 +3004,4 @@
-	return 0;
+
+out:
+	mutex_unlock(&ctl_mutex);
+	return ret;
@@ -2555 +3012,5 @@
-	struct pktcdvd_device *pd = pkt_find_dev_from_minor(ctrl_cmd->dev_index);
+	struct pktcdvd_device *pd;
+
+	mutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);
+
+	pd = pkt_find_dev_from_minor(ctrl_cmd->dev_index);
@@ -2563,0 +3025,2 @@
+
+	mutex_unlock(&ctl_mutex);
@@ -2570,0 +3034 @@
+	dev_t pkt_dev = 0;
@@ -2582,3 +3046,2 @@
-		mutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);
-		ret = pkt_setup_dev(&ctrl_cmd);
-		mutex_unlock(&ctl_mutex);
+		ret = pkt_setup_dev(new_decode_dev(ctrl_cmd.dev), &pkt_dev);
+		ctrl_cmd.pkt_dev = new_encode_dev(pkt_dev);
@@ -2589,3 +3052 @@
-		mutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);
-		ret = pkt_remove_dev(&ctrl_cmd);
-		mutex_unlock(&ctl_mutex);
+		ret = pkt_remove_dev(new_decode_dev(ctrl_cmd.pkt_dev));
@@ -2594 +3054,0 @@
-		mutex_lock_nested(&ctl_mutex, SINGLE_DEPTH_NESTING);
@@ -2596 +3055,0 @@
-		mutex_unlock(&ctl_mutex);
@@ -2622,0 +3082,2 @@
+	mutex_init(&ctl_mutex);
+
@@ -2635,0 +3097,6 @@
+	ret = pkt_sysfs_init();
+	if (ret)
+		goto out;
+
+	pkt_debugfs_init();
+
@@ -2639 +3106 @@
-		goto out;
+		goto out_misc;
@@ -2642,2 +3108,0 @@
-	mutex_init(&ctl_mutex);
-
@@ -2647,0 +3113,3 @@
+out_misc:
+	pkt_debugfs_cleanup();
+	pkt_sysfs_cleanup();
@@ -2658,0 +3127,4 @@
+
+	pkt_debugfs_cleanup();
+	pkt_sysfs_cleanup();
+
--- ./projects/linux/linux-2.6.20/drivers/block/pktcdvd.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/block/pktcdvd.c	2007-04-26 05:08:32.000000000 +0200
@@ -193,9 +192,0 @@
-/* declares a char buffer[64] _dbuf, copies data from
- * _b with length _l into it and ensures that _dbuf ends
- * with a \0 character.
- */
-#define DECLARE_BUF_AS_STRING(_dbuf, _b, _l) \
-	char _dbuf[64]; int dlen = (_l) < 0 ? 0 : (_l); \
-	if (dlen >= sizeof(_dbuf)) dlen = sizeof(_dbuf)-1; \
-	memcpy(_dbuf, _b, dlen); _dbuf[dlen] = 0
-
@@ -267 +257,0 @@
-	DECLARE_BUF_AS_STRING(dbuf, data, len); /* ensure sscanf scans a string */
@@ -269 +259 @@
-	if (strcmp(attr->name, "reset") == 0 && dlen > 0) {
+	if (strcmp(attr->name, "reset") == 0 && len > 0) {
@@ -277 +267 @@
-		   && sscanf(dbuf, "%d", &val) == 1) {
+		   && sscanf(data, "%d", &val) == 1) {
@@ -285 +275 @@
-		   && sscanf(dbuf, "%d", &val) == 1) {
+		   && sscanf(data, "%d", &val) == 1) {
@@ -372,2 +362 @@
-	DECLARE_BUF_AS_STRING(dbuf, buf, count);
-	if (sscanf(dbuf, "%u:%u", &major, &minor) == 2) {
+	if (sscanf(buf, "%u:%u", &major, &minor) == 2) {
@@ -384,2 +373 @@
-	DECLARE_BUF_AS_STRING(dbuf, buf, count);
-	if (sscanf(dbuf, "%u:%u", &major, &minor) == 2) {
+	if (sscanf(buf, "%u:%u", &major, &minor) == 2) {
@@ -450 +438 @@
-static struct file_operations debug_fops = {
+static const struct file_operations debug_fops = {
@@ -780 +768 @@
-	rq->cmd_len = COMMAND_SIZE(rq->cmd[0]);
+	rq->cmd_len = COMMAND_SIZE(cgc->cmd[0]);
@@ -792 +780,2 @@
-	ret = rq->errors;
+	if (rq->errors)
+		ret = -EIO;
@@ -1380 +1369 @@
-		blk_clear_queue_congested(pd->disk->queue, WRITE);
+		clear_bdi_congested(&pd->disk->queue->backing_dev_info, WRITE);
@@ -2601 +2590 @@
-		blk_set_queue_congested(q, WRITE);
+		set_bdi_congested(&q->backing_dev_info, WRITE);
@@ -2740 +2729 @@
-static struct file_operations pkt_proc_fops = {
+static const struct file_operations pkt_proc_fops = {
@@ -3067 +3056 @@
-static struct file_operations pkt_ctl_fops = {
+static const struct file_operations pkt_ctl_fops = {
--- ./projects/linux/linux-2.6.22/drivers/block/pktcdvd.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/block/pktcdvd.c	2007-10-09 22:31:38.000000000 +0200
@@ -149,2 +149 @@
-	static struct attribute _obj = { \
-		.name = _name, .owner = THIS_MODULE, .mode = _mode }
+	static struct attribute _obj = { .name = _name, .mode = _mode }
@@ -756 +755 @@
-	request_queue_t *q = bdev_get_queue(pd->bdev);
+	struct request_queue *q = bdev_get_queue(pd->bdev);
@@ -983 +982 @@
-static int pkt_set_segment_merging(struct pktcdvd_device *pd, request_queue_t *q)
+static int pkt_set_segment_merging(struct pktcdvd_device *pd, struct request_queue *q)
@@ -1596,0 +1596 @@
+	set_freezable();
@@ -1656,3 +1655,0 @@
-			if (signal_pending(current)) {
-				flush_signals(current);
-			}
@@ -2320 +2317 @@
-	request_queue_t *q;
+	struct request_queue *q;
@@ -2483 +2480 @@
-static int pkt_make_request(request_queue_t *q, struct bio *bio)
+static int pkt_make_request(struct request_queue *q, struct bio *bio)
@@ -2632 +2629 @@
-static int pkt_merge_bvec(request_queue_t *q, struct bio *bio, struct bio_vec *bvec)
+static int pkt_merge_bvec(struct request_queue *q, struct bio *bio, struct bio_vec *bvec)
@@ -2653 +2650 @@
-	request_queue_t *q = pd->disk->queue;
+	struct request_queue *q = pd->disk->queue;
--- ./projects/linux/linux-2.6.23/drivers/block/pktcdvd.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/block/pktcdvd.c	2008-01-24 23:58:37.000000000 +0100
@@ -120 +120,2 @@
-	if (kobject_register(&p->kobj) != 0)
+	if (kobject_register(&p->kobj) != 0) {
+		kobject_put(&p->kobj);
@@ -121,0 +123 @@
+	}
@@ -360,0 +363 @@
+
@@ -361,0 +365,4 @@
+		/* pkt_setup_dev() expects caller to hold reference to self */
+		if (!try_module_get(THIS_MODULE))
+			return -ENODEV;
+
@@ -362,0 +370,3 @@
+
+		module_put(THIS_MODULE);
+
@@ -364,0 +375 @@
+
@@ -1061 +1072 @@
-static int pkt_end_io_read(struct bio *bio, unsigned int bytes_done, int err)
+static void pkt_end_io_read(struct bio *bio, int err)
@@ -1067,3 +1077,0 @@
-	if (bio->bi_size)
-		return 1;
-
@@ -1080,2 +1087,0 @@
-
-	return 0;
@@ -1084 +1090 @@
-static int pkt_end_io_packet_write(struct bio *bio, unsigned int bytes_done, int err)
+static void pkt_end_io_packet_write(struct bio *bio, int err)
@@ -1090,3 +1095,0 @@
-	if (bio->bi_size)
-		return 1;
-
@@ -1101 +1103,0 @@
-	return 0;
@@ -1144,0 +1147,2 @@
+		struct bio_vec *vec;
+
@@ -1148,0 +1153 @@
+		vec = bio->bi_io_vec;
@@ -1154,0 +1160,2 @@
+		bio->bi_io_vec = vec;
+		bio->bi_destructor = pkt_bio_destructor;
@@ -1450,0 +1458,2 @@
+	pkt->w_bio->bi_io_vec = bvec;
+	pkt->w_bio->bi_destructor = pkt_bio_destructor;
@@ -1473 +1482 @@
-		bio_endio(bio, bio->bi_size, uptodate ? 0 : -EIO);
+		bio_endio(bio, uptodate ? 0 : -EIO);
@@ -2465 +2474 @@
-static int pkt_end_io_read_cloned(struct bio *bio, unsigned int bytes_done, int err)
+static void pkt_end_io_read_cloned(struct bio *bio, int err)
@@ -2470,3 +2478,0 @@
-	if (bio->bi_size)
-		return 1;
-
@@ -2474 +2480 @@
-	bio_endio(psd->bio, psd->bio->bi_size, err);
+	bio_endio(psd->bio, err);
@@ -2477 +2482,0 @@
-	return 0;
@@ -2623 +2628 @@
-	bio_io_error(bio, bio->bi_size);
+	bio_io_error(bio);
--- ./projects/linux/linux-2.6.24/drivers/block/pktcdvd.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/block/pktcdvd.c	2008-04-17 04:49:44.000000000 +0200
@@ -112,0 +113,2 @@
+	int error;
+
@@ -116,3 +117,0 @@
-	kobject_set_name(&p->kobj, "%s", name);
-	p->kobj.parent = parent;
-	p->kobj.ktype = ktype;
@@ -120 +119,2 @@
-	if (kobject_register(&p->kobj) != 0) {
+	error = kobject_init_and_add(&p->kobj, ktype, parent, "%s", name);
+	if (error) {
@@ -123,0 +124 @@
+	kobject_uevent(&p->kobj, KOBJ_ADD);
@@ -132 +133 @@
-		kobject_unregister(&p->kobj);
+		kobject_put(&p->kobj);
@@ -304,5 +305,3 @@
-		pd->clsdev = class_device_create(class_pktcdvd,
-					NULL, pd->pkt_dev,
-					NULL, "%s", pd->name);
-		if (IS_ERR(pd->clsdev))
-			pd->clsdev = NULL;
+		pd->dev = device_create(class_pktcdvd, NULL, pd->pkt_dev, "%s", pd->name);
+		if (IS_ERR(pd->dev))
+			pd->dev = NULL;
@@ -310 +309 @@
-	if (pd->clsdev) {
+	if (pd->dev) {
@@ -312 +311 @@
-					&pd->clsdev->kobj,
+					&pd->dev->kobj,
@@ -315 +314 @@
-					&pd->clsdev->kobj,
+					&pd->dev->kobj,
@@ -325 +324 @@
-		class_device_destroy(class_pktcdvd, pd->pkt_dev);
+		device_destroy(class_pktcdvd, pd->pkt_dev);
@@ -853 +852,2 @@
-static int pkt_set_speed(struct pktcdvd_device *pd, unsigned write_speed, unsigned read_speed)
+static noinline_for_stack int pkt_set_speed(struct pktcdvd_device *pd,
+				unsigned write_speed, unsigned read_speed)
@@ -1780 +1780,2 @@
-static int pkt_get_last_written(struct pktcdvd_device *pd, long *last_written)
+static noinline_for_stack int pkt_get_last_written(struct pktcdvd_device *pd,
+						long *last_written)
@@ -1817 +1818 @@
-static int pkt_set_write_settings(struct pktcdvd_device *pd)
+static noinline_for_stack int pkt_set_write_settings(struct pktcdvd_device *pd)
@@ -1976 +1977 @@
-static int pkt_probe_settings(struct pktcdvd_device *pd)
+static noinline_for_stack int pkt_probe_settings(struct pktcdvd_device *pd)
@@ -2075 +2076,2 @@
-static int pkt_write_caching(struct pktcdvd_device *pd, int set)
+static noinline_for_stack int pkt_write_caching(struct pktcdvd_device *pd,
+						int set)
@@ -2120 +2122,2 @@
-static int pkt_get_max_speed(struct pktcdvd_device *pd, unsigned *write_speed)
+static noinline_for_stack int pkt_get_max_speed(struct pktcdvd_device *pd,
+						unsigned *write_speed)
@@ -2181 +2184,2 @@
-static int pkt_media_speed(struct pktcdvd_device *pd, unsigned *speed)
+static noinline_for_stack int pkt_media_speed(struct pktcdvd_device *pd,
+						unsigned *speed)
@@ -2216 +2220 @@
-	if (!buf[6] & 0x40) {
+	if (!(buf[6] & 0x40)) {
@@ -2220 +2224 @@
-	if (!buf[6] & 0x4) {
+	if (!(buf[6] & 0x4)) {
@@ -2253 +2257 @@
-static int pkt_perform_opc(struct pktcdvd_device *pd)
+static noinline_for_stack int pkt_perform_opc(struct pktcdvd_device *pd)
--- ./projects/linux/linux-2.6.25/drivers/block/pktcdvd.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/block/pktcdvd.c	2008-07-13 23:51:29.000000000 +0200
@@ -779,2 +778,0 @@
-	if (sizeof(rq->cmd) > CDROM_PACKET_SIZE)
-		memset(rq->cmd + CDROM_PACKET_SIZE, 0, sizeof(rq->cmd) - CDROM_PACKET_SIZE);
@@ -2747 +2744,0 @@
-	struct proc_dir_entry *proc;
@@ -2791,5 +2788 @@
-	proc = create_proc_entry(pd->name, 0, pkt_proc);
-	if (proc) {
-		proc->data = pd;
-		proc->proc_fops = &pkt_proc_fops;
-	}
+	proc_create_data(pd->name, 0, pkt_proc, &pkt_proc_fops, pd);
@@ -3104 +3097 @@
-	pkt_proc = proc_mkdir(DRIVER_NAME, proc_root_driver);
+	pkt_proc = proc_mkdir("driver/"DRIVER_NAME, NULL);
@@ -3120 +3113 @@
-	remove_proc_entry(DRIVER_NAME, proc_root_driver);
+	remove_proc_entry("driver/"DRIVER_NAME, NULL);
--- ./projects/linux/linux-2.6.26/drivers/block/pktcdvd.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/block/pktcdvd.c	2008-10-10 00:13:53.000000000 +0200
@@ -305 +305,3 @@
-		pd->dev = device_create(class_pktcdvd, NULL, pd->pkt_dev, "%s", pd->name);
+		pd->dev = device_create_drvdata(class_pktcdvd, NULL,
+						pd->pkt_dev, NULL,
+						"%s", pd->name);
@@ -2082 +2083,0 @@
-	memset(buf, 0, sizeof(buf));
@@ -2129 +2129,0 @@
-	memset(buf, 0, sizeof(buf));
@@ -2636 +2636,2 @@
-static int pkt_merge_bvec(struct request_queue *q, struct bio *bio, struct bio_vec *bvec)
+static int pkt_merge_bvec(struct request_queue *q, struct bvec_merge_data *bmd,
+			  struct bio_vec *bvec)
@@ -2639,2 +2640,2 @@
-	sector_t zone = ZONE(bio->bi_sector, pd);
-	int used = ((bio->bi_sector - zone) << 9) + bio->bi_size;
+	sector_t zone = ZONE(bmd->bi_sector, pd);
+	int used = ((bmd->bi_sector - zone) << 9) + bmd->bi_size;
@@ -2648 +2649 @@
-	remaining2 = PAGE_SIZE - bio->bi_size;
+	remaining2 = PAGE_SIZE - bmd->bi_size;
--- ./projects/linux/linux-2.6.27/drivers/block/pktcdvd.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/block/pktcdvd.c	2008-12-25 00:26:37.000000000 +0100
@@ -305,3 +305,2 @@
-		pd->dev = device_create_drvdata(class_pktcdvd, NULL,
-						pd->pkt_dev, NULL,
-						"%s", pd->name);
+		pd->dev = device_create(class_pktcdvd, NULL, MKDEV(0, 0), NULL,
+					"%s", pd->name);
@@ -2324 +2323 @@
-static int pkt_open_dev(struct pktcdvd_device *pd, int write)
+static int pkt_open_dev(struct pktcdvd_device *pd, fmode_t write)
@@ -2336 +2335 @@
-	if ((ret = blkdev_get(pd->bdev, FMODE_READ, O_RDONLY)))
+	if ((ret = blkdev_get(pd->bdev, FMODE_READ)))
@@ -2385 +2384 @@
-	blkdev_put(pd->bdev);
+	blkdev_put(pd->bdev, FMODE_READ);
@@ -2403 +2402 @@
-	blkdev_put(pd->bdev);
+	blkdev_put(pd->bdev, FMODE_READ);
@@ -2415 +2414 @@
-static int pkt_open(struct inode *inode, struct file *file)
+static int pkt_open(struct block_device *bdev, fmode_t mode)
@@ -2423 +2422 @@
-	pd = pkt_find_dev_from_minor(iminor(inode));
+	pd = pkt_find_dev_from_minor(MINOR(bdev->bd_dev));
@@ -2432 +2431 @@
-		if ((file->f_mode & FMODE_WRITE) &&
+		if ((mode & FMODE_WRITE) &&
@@ -2438 +2437 @@
-		ret = pkt_open_dev(pd, file->f_mode & FMODE_WRITE);
+		ret = pkt_open_dev(pd, mode & FMODE_WRITE);
@@ -2445 +2444 @@
-		set_blocksize(inode->i_bdev, CD_FRAMESIZE);
+		set_blocksize(bdev, CD_FRAMESIZE);
@@ -2459 +2458 @@
-static int pkt_close(struct inode *inode, struct file *file)
+static int pkt_close(struct gendisk *disk, fmode_t mode)
@@ -2461 +2460 @@
-	struct pktcdvd_device *pd = inode->i_bdev->bd_disk->private_data;
+	struct pktcdvd_device *pd = disk->private_data;
@@ -2547 +2546 @@
-			bp = bio_split(bio, bio_split_pool, first_sectors);
+			bp = bio_split(bio, first_sectors);
@@ -2769 +2768 @@
-	ret = blkdev_get(bdev, FMODE_READ, O_RDONLY | O_NONBLOCK);
+	ret = blkdev_get(bdev, FMODE_READ | FMODE_NDELAY);
@@ -2794 +2793 @@
-	blkdev_put(bdev);
+	blkdev_put(bdev, FMODE_READ | FMODE_NDELAY);
@@ -2800 +2799 @@
-static int pkt_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+static int pkt_ioctl(struct block_device *bdev, fmode_t mode, unsigned int cmd, unsigned long arg)
@@ -2802 +2801 @@
-	struct pktcdvd_device *pd = inode->i_bdev->bd_disk->private_data;
+	struct pktcdvd_device *pd = bdev->bd_disk->private_data;
@@ -2804 +2803,2 @@
-	VPRINTK("pkt_ioctl: cmd %x, dev %d:%d\n", cmd, imajor(inode), iminor(inode));
+	VPRINTK("pkt_ioctl: cmd %x, dev %d:%d\n", cmd,
+		MAJOR(bdev->bd_dev), MINOR(bdev->bd_dev));
@@ -2806,0 +2807,8 @@
+	case CDROMEJECT:
+		/*
+		 * The door gets locked when the device is opened, so we
+		 * have to unlock it or else the eject command fails.
+		 */
+		if (pd->refcnt == 1)
+			pkt_lock_door(pd, 0);
+		/* fallthru */
@@ -2815,10 +2823 @@
-		return blkdev_ioctl(pd->bdev->bd_inode, file, cmd, arg);
-
-	case CDROMEJECT:
-		/*
-		 * The door gets locked when the device is opened, so we
-		 * have to unlock it or else the eject command fails.
-		 */
-		if (pd->refcnt == 1)
-			pkt_lock_door(pd, 0);
-		return blkdev_ioctl(pd->bdev->bd_inode, file, cmd, arg);
+		return __blkdev_driver_ioctl(pd->bdev, mode, cmd, arg);
@@ -2853 +2852 @@
-	.ioctl =		pkt_ioctl,
+	.locked_ioctl =		pkt_ioctl,
@@ -2914 +2913 @@
-	pd->pkt_dev = MKDEV(disk->major, disk->first_minor);
+	pd->pkt_dev = MKDEV(pktdev_major, idx);
@@ -2979 +2978 @@
-	blkdev_put(pd->bdev);
+	blkdev_put(pd->bdev, FMODE_READ | FMODE_NDELAY);
--- ./projects/linux/linux-2.6.15/drivers/char/isicom.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/char/isicom.c	2006-03-20 06:53:29.000000000 +0100
@@ -23 +23 @@
- *					This is to prevent the firmware 
+ *					This is to prevent the firmware
@@ -34 +34 @@
- *					when the last port on the card is 
+ *					when the last port on the card is
@@ -38 +38 @@
- *					to  isicom_setup_port and 
+ *					to  isicom_setup_port and
@@ -42,2 +42,2 @@
- *					
- *	
+ *
+ *
@@ -45,2 +45,2 @@
- *	
- *	
+ *
+ *
@@ -53 +53 @@
- *      11/04/01  Kevin			Fixed firmware load problem with
+ *	11/04/01  Kevin			Fixed firmware load problem with
@@ -55 +55 @@
- *	
+ *
@@ -65 +65 @@
- *					info during insmod as well as module 
+ *					info during insmod as well as module
@@ -67 +67 @@
- *	
+ *
@@ -76 +76 @@
- *  	
+ *
@@ -82,7 +82,7 @@
- *  	11/02/03  ranjeeth		Added support for 230 Kbps and 460 Kbps
- *  					Baud index extended to 21
- *  	
- *  	20/03/03  ranjeeth		Made to work for Linux Advanced server.
- *  					Taken care of license warning.	
- *      
- *	10/12/03  Ravindra		Made to work for Fedora Core 1 of 
+ *	11/02/03  ranjeeth		Added support for 230 Kbps and 460 Kbps
+ *					Baud index extended to 21
+ *
+ *	20/03/03  ranjeeth		Made to work for Linux Advanced server.
+ *					Taken care of license warning.
+ *
+ *	10/12/03  Ravindra		Made to work for Fedora Core 1 of
@@ -96 +96 @@
- *	To use this driver you also need the support package. You 
+ *	To use this driver you also need the support package. You
@@ -99 +99 @@
- * 	
+ *
@@ -110 +109,0 @@
- *		Hotplug
@@ -115,0 +115 @@
+#include <linux/firmware.h>
@@ -117,0 +118 @@
+#include <linux/tty_flip.h>
@@ -123 +123,0 @@
-#include <linux/miscdevice.h>
@@ -136,0 +137,14 @@
+#define InterruptTheCard(base) outw(0, (base) + 0xc)
+#define ClearInterrupt(base) inw((base) + 0x0a)
+
+#ifdef DEBUG
+#define pr_dbg(str...) printk(KERN_DEBUG "ISICOM: " str)
+#define isicom_paranoia_check(a, b, c) __isicom_paranoia_check((a), (b), (c))
+#else
+#define pr_dbg(str...) do { } while (0)
+#define isicom_paranoia_check(a, b, c) 0
+#endif
+
+static int isicom_probe(struct pci_dev *, const struct pci_device_id *);
+static void __devexit isicom_remove(struct pci_dev *);
+
@@ -138,9 +152,9 @@
-	{ VENDOR_ID, 0x2028, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2051, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2052, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2053, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2054, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2055, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2056, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2057, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
-	{ VENDOR_ID, 0x2058, PCI_ANY_ID, PCI_ANY_ID, 0, 0, 0 },
+	{ PCI_DEVICE(VENDOR_ID, 0x2028) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2051) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2052) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2053) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2054) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2055) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2056) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2057) },
+	{ PCI_DEVICE(VENDOR_ID, 0x2058) },
@@ -150,0 +165,7 @@
+static struct pci_driver isicom_driver = {
+	.name		= "isicom",
+	.id_table	= isicom_pci_tbl,
+	.probe		= isicom_probe,
+	.remove		= __devexit_p(isicom_remove)
+};
+
@@ -156,5 +176,0 @@
-#ifdef ISICOM_DEBUG
-static unsigned long tx_count = 0;
-#endif
-
-static int ISILoad_ioctl(struct inode *inode, struct file *filp, unsigned  int cmd, unsigned long arg);
@@ -163,4 +179 @@
-static void isicom_start(struct tty_struct * tty);
-
-static unsigned char * tmp_buf;
-static DECLARE_MUTEX(tmp_buf_sem);
+static void isicom_start(struct tty_struct *tty);
@@ -171,2 +184 @@
-	-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 16, 17,     
-	18, 19
+	-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 16, 17, 18, 19
@@ -176 +188 @@
-	unsigned short		base;
+	unsigned long		base;
@@ -180 +192 @@
-	unsigned short		port_status; /* each bit represents a single port */
+	unsigned short		port_status; /* each bit for each port */
@@ -195,3 +207,3 @@
-	unsigned short		channel;
-	unsigned short		status;
-	unsigned short		closing_wait;
+	u16			channel;
+	u16			status;
+	u16			closing_wait;
@@ -218 +230 @@
- 
+
@@ -222 +234 @@
-	unsigned short base = card->base;
+	unsigned long base = card->base;
@@ -227 +239 @@
-			return 1; 
+			return 1;
@@ -233 +245,3 @@
-	printk(KERN_WARNING "ISICOM: Failed to lock Card (0x%x)\n", card->base);
+	printk(KERN_WARNING "ISICOM: Failed to lock Card (0x%lx)\n",
+		card->base);
+
@@ -240 +254 @@
-	unsigned short 		base = card->base;
+	unsigned long base = card->base;
@@ -246 +260 @@
-			return 1; 
+			return 1;
@@ -262,2 +276,2 @@
- 
-static void raise_dtr(struct isi_port * port)
+
+static void raise_dtr(struct isi_port *port)
@@ -265,3 +279,3 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -272 +286 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -279,5 +293,5 @@
-static inline void drop_dtr(struct isi_port * port)
-{	
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+static inline void drop_dtr(struct isi_port *port)
+{
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -288 +302 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -290 +304 @@
-	InterruptTheCard(base);	
+	InterruptTheCard(base);
@@ -295 +309 @@
-static inline void raise_rts(struct isi_port * port)
+static inline void raise_rts(struct isi_port *port)
@@ -297,3 +311,3 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -304 +318 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -306 +320 @@
-	InterruptTheCard(base);	
+	InterruptTheCard(base);
@@ -310 +324 @@
-static inline void drop_rts(struct isi_port * port)
+static inline void drop_rts(struct isi_port *port)
@@ -312,3 +326,3 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -319 +333 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -321 +335 @@
-	InterruptTheCard(base);	
+	InterruptTheCard(base);
@@ -326 +340 @@
-static inline void raise_dtr_rts(struct isi_port * port)
+static inline void raise_dtr_rts(struct isi_port *port)
@@ -328,3 +342,3 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -335 +349 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -342 +356 @@
-static void drop_dtr_rts(struct isi_port * port)
+static void drop_dtr_rts(struct isi_port *port)
@@ -344,3 +358,3 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -351 +365 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -353 +367 @@
-	InterruptTheCard(base);	
+	InterruptTheCard(base);
@@ -358 +372 @@
-static inline void kill_queue(struct isi_port * port, short queue)
+static inline void kill_queue(struct isi_port *port, short queue)
@@ -360,3 +374,3 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;
-	unsigned char channel = port->channel;
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+	u16 channel = port->channel;
@@ -367 +381 @@
-	outw(0x8000 | (channel << card->shift_count) | 0x02 , base);
+	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
@@ -369 +383 @@
-	InterruptTheCard(base);	
+	InterruptTheCard(base);
@@ -373,229 +386,0 @@
-
-/* 
- *  Firmware loader driver specific routines. This needs to mostly die
- *  and be replaced with request_firmware.
- */
-
-static struct file_operations ISILoad_fops = {
-	.owner		= THIS_MODULE,
-	.ioctl		= ISILoad_ioctl,
-};
-
-static struct miscdevice isiloader_device = {
-	ISILOAD_MISC_MINOR, "isictl", &ISILoad_fops
-};
-
- 
-static inline int WaitTillCardIsFree(unsigned short base)
-{
-	unsigned long count=0;
-	while( (!(inw(base+0xe) & 0x1)) && (count++ < 6000000));
-	if (inw(base+0xe)&0x1)  
-		return 0;
-	else
-		return 1;
-}
-
-static int ISILoad_ioctl(struct inode *inode, struct file *filp,
-		         unsigned int cmd, unsigned long arg)
-{
-	unsigned int card, i, j, signature, status, portcount = 0;
-	unsigned long t;
-	unsigned short word_count, base;
-	bin_frame frame;
-	void __user *argp = (void __user *)arg;
-	/* exec_record exec_rec; */
-	
-	if(get_user(card, (int __user *)argp))
-		return -EFAULT;
-		
-	if(card < 0 || card >= BOARD_COUNT)
-		return -ENXIO;
-		
-	base=isi_card[card].base;
-	
-	if(base==0)
-		return -ENXIO;	/* disabled or not used */
-	
-	switch(cmd) {
-		case MIOCTL_RESET_CARD:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EPERM;
-			printk(KERN_DEBUG "ISILoad:Resetting Card%d at 0x%x ",card+1,base);
-								
-			inw(base+0x8);
-			
-			for(t=jiffies+HZ/100;time_before(jiffies, t););
-				
-			outw(0,base+0x8); /* Reset */
-			
-			for(j=1;j<=3;j++) {
-				for(t=jiffies+HZ;time_before(jiffies, t););
-				printk(".");
-			}	
-			signature=(inw(base+0x4)) & 0xff;	
-			if (isi_card[card].isa) {
-					
-				if (!(inw(base+0xe) & 0x1) || (inw(base+0x2))) {
-#ifdef ISICOM_DEBUG				
-					printk("\nbase+0x2=0x%x , base+0xe=0x%x",inw(base+0x2),inw(base+0xe));
-#endif				
-					printk("\nISILoad:ISA Card%d reset failure (Possible bad I/O Port Address 0x%x).\n",card+1,base);
-					return -EIO;					
-				}
-			}	
-			else {
-				portcount = inw(base+0x2);
-				if (!(inw(base+0xe) & 0x1) || ((portcount!=0) && (portcount!=4) && (portcount!=8))) {	
-#ifdef ISICOM_DEBUG
-					printk("\nbase+0x2=0x%x , base+0xe=0x%x",inw(base+0x2),inw(base+0xe));
-#endif
-					printk("\nISILoad:PCI Card%d reset failure (Possible bad I/O Port Address 0x%x).\n",card+1,base);
-					return -EIO;
-				}
-			}	
-			switch(signature) {
-			case	0xa5:
-			case	0xbb:
-			case	0xdd:	
-					if (isi_card[card].isa) 
-						isi_card[card].port_count = 8;
-					else {
-						if (portcount == 4)
-							isi_card[card].port_count = 4;
-						else
-							isi_card[card].port_count = 8;
-					}	
-				     	isi_card[card].shift_count = 12;
-				     	break;
-				        
-			case	0xcc:	isi_card[card].port_count = 16;
-					isi_card[card].shift_count = 11;
-					break;  			
-					
-			default: printk("ISILoad:Card%d reset failure (Possible bad I/O Port Address 0x%x).\n",card+1,base);
-#ifdef ISICOM_DEBUG			
-				 printk("Sig=0x%x\n",signature);
-#endif				 
-				 return -EIO;
-			}
-			printk("-Done\n");
-			return put_user(signature,(unsigned __user *)argp);
-						
-	case	MIOCTL_LOAD_FIRMWARE:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EPERM;
-				
-			if(copy_from_user(&frame, argp, sizeof(bin_frame)))
-				return -EFAULT;
-			
-			if (WaitTillCardIsFree(base))
-				return -EIO;
-			
-			outw(0xf0,base);	/* start upload sequence */ 
-			outw(0x00,base);
-			outw((frame.addr), base);/*      lsb of adderess    */
-			
-			word_count=(frame.count >> 1) + frame.count % 2;
-			outw(word_count, base);
-			InterruptTheCard(base);
-			
-			for(i=0;i<=0x2f;i++);	/* a wee bit of delay */
-			
-			if (WaitTillCardIsFree(base)) 
-				return -EIO;
-				
-			if ((status=inw(base+0x4))!=0) {
-				printk(KERN_WARNING "ISILoad:Card%d rejected load header:\nAddress:0x%x \nCount:0x%x \nStatus:0x%x \n", 
-				card+1, frame.addr, frame.count, status);
-				return -EIO;
-			}
-			outsw(base, (void *) frame.bin_data, word_count);
-			
-			InterruptTheCard(base);
-			
-			for(i=0;i<=0x0f;i++);	/* another wee bit of delay */ 
-			
-			if (WaitTillCardIsFree(base)) 
-				return -EIO;
-				
-			if ((status=inw(base+0x4))!=0) {
-				printk(KERN_ERR "ISILoad:Card%d got out of sync.Card Status:0x%x\n",card+1, status);
-				return -EIO;
-			}	
-			return 0;
-						
-	case	MIOCTL_READ_FIRMWARE:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EPERM;
-				
-			if(copy_from_user(&frame, argp, sizeof(bin_header)))
-				return -EFAULT;
-			
-			if (WaitTillCardIsFree(base))
-				return -EIO;
-			
-			outw(0xf1,base);	/* start download sequence */ 
-			outw(0x00,base);
-			outw((frame.addr), base);/*      lsb of adderess    */
-			
-			word_count=(frame.count >> 1) + frame.count % 2;
-			outw(word_count+1, base);
-			InterruptTheCard(base);
-			
-			for(i=0;i<=0xf;i++);	/* a wee bit of delay */
-			
-			if (WaitTillCardIsFree(base)) 
-				return -EIO;
-				
-			if ((status=inw(base+0x4))!=0) {
-				printk(KERN_WARNING "ISILoad:Card%d rejected verify header:\nAddress:0x%x \nCount:0x%x \nStatus:0x%x \n", 
-				card+1, frame.addr, frame.count, status);
-				return -EIO;
-			}
-			
-			inw(base);
-			insw(base, frame.bin_data, word_count);
-			InterruptTheCard(base);
-			
-			for(i=0;i<=0x0f;i++);	/* another wee bit of delay */ 
-			
-			if (WaitTillCardIsFree(base)) 
-				return -EIO;
-				
-			if ((status=inw(base+0x4))!=0) {
-				printk(KERN_ERR "ISILoad:Card%d verify got out of sync.Card Status:0x%x\n",card+1, status);
-				return -EIO;
-			}	
-			
-			if(copy_to_user(argp, &frame, sizeof(bin_frame)))
-				return -EFAULT;
-			return 0;
-	
-	case	MIOCTL_XFER_CTRL:
-			if (!capable(CAP_SYS_ADMIN))
-				return -EPERM;
-			if (WaitTillCardIsFree(base)) 
-				return -EIO;
-					
-			outw(0xf2, base);
-			outw(0x800, base);
-			outw(0x0, base);
-			outw(0x0, base);
-			InterruptTheCard(base);
-			outw(0x0, base+0x4);    /* for ISI4608 cards */
-							
-			isi_card[card].status |= FIRMWARE_LOADED;
-			return 0;	
-			
-	default:
-#ifdef ISICOM_DEBUG	
-		printk(KERN_DEBUG "ISILoad: Received Ioctl cmd 0x%x.\n", cmd); 
-#endif
-		return -ENOIOCTLCMD;
-	
-	}
-	
-}
-		        	
-
@@ -606,9 +391,4 @@
- 
-static inline int isicom_paranoia_check(struct isi_port const * port, char *name, 
-					const char * routine)
-{
-#ifdef ISICOM_DEBUG 
-	static const char * badmagic = 
-			KERN_WARNING "ISICOM: Warning: bad isicom magic for dev %s in %s.\n";
-	static const char * badport = 
-			KERN_WARNING "ISICOM: Warning: NULL isicom port for dev %s in %s.\n";		
+
+static inline int __isicom_paranoia_check(struct isi_port const *port,
+	char *name, const char *routine)
+{
@@ -616 +396,2 @@
-		printk(badport, name, routine);
+		printk(KERN_WARNING "ISICOM: Warning: bad isicom magic for "
+			"dev %s in %s.\n", name, routine);
@@ -620 +401,2 @@
-		printk(badmagic, name, routine);
+		printk(KERN_WARNING "ISICOM: Warning: NULL isicom port for "
+			"dev %s in %s.\n", name, routine);
@@ -622,2 +404,2 @@
-	}	
-#endif	
+	}
+
@@ -626 +408 @@
-			
+
@@ -628 +410 @@
- *	Transmitter. 
+ *	Transmitter.
@@ -638,7 +420,3 @@
-	struct isi_port * port;
-	struct tty_struct * tty;
-	
-#ifdef ISICOM_DEBUG
-	++tx_count;
-#endif	
-	
+	struct isi_port *port;
+	struct tty_struct *tty;
+
@@ -648 +426 @@
-		if (isi_card[card].status & BOARD_ACTIVE) 
+		if (isi_card[card].status & BOARD_ACTIVE)
@@ -650 +428 @@
-		card = (card + 1) & 0x0003;	
+		card = (card + 1) & 0x0003;
@@ -654 +432 @@
-		
+
@@ -656 +434 @@
-	
+
@@ -665 +443 @@
-		 	!(port->status & ISI_TXOK))
+				!(port->status & ISI_TXOK))
@@ -668 +446 @@
-		
+
@@ -670,3 +448,3 @@
-		
-		
-		if(tty == NULL) {
+
+
+		if (tty == NULL) {
@@ -676 +454 @@
-		
+
@@ -684 +462 @@
-			continue;		
+			continue;
@@ -686,6 +464,4 @@
-#ifdef ISICOM_DEBUG
-		printk(KERN_DEBUG "ISICOM: txing %d bytes, port%d.\n", 
-				txcount, port->channel+1); 
-#endif	
-		outw((port->channel << isi_card[card].shift_count) | txcount
-					, base);
+		pr_dbg("txing %d bytes, port%d.\n", txcount,
+			port->channel + 1);
+		outw((port->channel << isi_card[card].shift_count) | txcount,
+			base);
@@ -693 +469 @@
-		wrd = 0;			
+		wrd = 0;
@@ -695 +471,2 @@
-			cnt = min_t(int, txcount, (SERIAL_XMIT_SIZE - port->xmit_tail));
+			cnt = min_t(int, txcount, (SERIAL_XMIT_SIZE
+					- port->xmit_tail));
@@ -699,2 +476,4 @@
-					wrd |= (port->xmit_buf[port->xmit_tail] << 8);
-					port->xmit_tail = (port->xmit_tail + 1) & (SERIAL_XMIT_SIZE - 1);
+					wrd |= (port->xmit_buf[port->xmit_tail]
+									<< 8);
+					port->xmit_tail = (port->xmit_tail + 1)
+						& (SERIAL_XMIT_SIZE - 1);
@@ -704,3 +483,2 @@
-					outw(wrd, base);			
-				}
-				else {
+					outw(wrd, base);
+				} else {
@@ -710 +488 @@
-			}		
+			}
@@ -713,3 +491,3 @@
-			outsw(base, port->xmit_buf+port->xmit_tail, word_count);
-			port->xmit_tail = (port->xmit_tail + (word_count << 1)) &
-						(SERIAL_XMIT_SIZE - 1);
+			outsw(base, port->xmit_buf+port->xmit_tail,word_count);
+			port->xmit_tail = (port->xmit_tail
+				+ (word_count << 1)) & (SERIAL_XMIT_SIZE - 1);
@@ -721 +499,2 @@
-				port->xmit_tail = (port->xmit_tail + 1) & (SERIAL_XMIT_SIZE - 1);
+				port->xmit_tail = (port->xmit_tail + 1)
+					& (SERIAL_XMIT_SIZE - 1);
@@ -733 +512,8 @@
-	}	
+	}
+
+	/*	schedule another tx for hopefully in about 10ms	*/
+sched_again:
+	if (!re_schedule) {
+		re_schedule = 2;
+ 		return;
+	}
@@ -735,4 +520,0 @@
-	/*	schedule another tx for hopefully in about 10ms	*/	
-sched_again:	
-	if (!re_schedule)	
-		return;
@@ -744,4 +526,4 @@
-	
-	return;	
-}		
- 
+
+	return;
+}
+
@@ -750,2 +532,2 @@
- 
-static void isicom_bottomhalf(void * data)
+
+static void isicom_bottomhalf(void *data)
@@ -753,3 +535,3 @@
-	struct isi_port * port = (struct isi_port *) data;
-	struct tty_struct * tty = port->tty;
-	
+	struct isi_port *port = (struct isi_port *) data;
+	struct tty_struct *tty = port->tty;
+
@@ -759 +541 @@
-	tty_wakeup(tty);	
+	tty_wakeup(tty);
@@ -761,2 +543,2 @@
-} 		
- 		
+}
+
@@ -764 +546 @@
- *	Main interrupt handler routine 
+ *	Main interrupt handler routine
@@ -766,9 +548,8 @@
- 
-static irqreturn_t isicom_interrupt(int irq, void *dev_id,
-					struct pt_regs *regs)
-{
-	struct isi_board * card;
-	struct isi_port * port;
-	struct tty_struct * tty;
-	unsigned short base, header, word_count, count;
-	unsigned char channel;
+
+static irqreturn_t isicom_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+{
+	struct isi_board *card = dev_id;
+	struct isi_port *port;
+	struct tty_struct *tty;
+	unsigned long base;
+	u16 header, word_count, count, channel;
@@ -776,2 +557 @@
-	
-	card = (struct isi_board *) dev_id;
+	unsigned char *rp;
@@ -781 +561 @@
-	
+
@@ -784 +564 @@
-	
+
@@ -787,2 +567,2 @@
-		 *      disable any interrupts from the PCI card and lower the
-		 *      interrupt line
+		 * disable any interrupts from the PCI card and lower the
+		 * interrupt line
@@ -793 +573 @@
-	
+
@@ -800,2 +580,2 @@
-		printk(KERN_WARNING "ISICOM: isicom_interrupt(0x%x): %d(channel) > port_count.\n",
-				base, channel+1);
+		printk(KERN_WARNING "ISICOM: isicom_interrupt(0x%lx): "
+			"%d(channel) > port_count.\n", base, channel+1);
@@ -805 +585 @@
-			outw(0x0000, base+0x04); /* enable interrupts */		
+			outw(0x0000, base+0x04); /* enable interrupts */
@@ -807 +587 @@
-		return IRQ_HANDLED;			
+		return IRQ_HANDLED;
@@ -816,2 +596,2 @@
-	}	
-		
+	}
+
@@ -834 +614 @@
-	
+
@@ -838,28 +618,7 @@
-			case 0:	/* Change in EIA signals */
-				
-				if (port->flags & ASYNC_CHECK_CD) {
-					if (port->status & ISI_DCD) {
-						if (!(header & ISI_DCD)) {
-						/* Carrier has been lost  */
-#ifdef ISICOM_DEBUG						
-							printk(KERN_DEBUG "ISICOM: interrupt: DCD->low.\n");
-#endif							
-							port->status &= ~ISI_DCD;
-							schedule_work(&port->hangup_tq);
-						}
-					}
-					else {
-						if (header & ISI_DCD) {
-						/* Carrier has been detected */
-#ifdef ISICOM_DEBUG
-							printk(KERN_DEBUG "ISICOM: interrupt: DCD->high.\n");
-#endif							
-							port->status |= ISI_DCD;
-							wake_up_interruptible(&port->open_wait);
-						}
-					}
-				}
-				else {
-					if (header & ISI_DCD) 
-						port->status |= ISI_DCD;
-					else
+		case 0:	/* Change in EIA signals */
+			if (port->flags & ASYNC_CHECK_CD) {
+				if (port->status & ISI_DCD) {
+					if (!(header & ISI_DCD)) {
+					/* Carrier has been lost  */
+						pr_dbg("interrupt: DCD->low.\n"
+							);
@@ -867,17 +626 @@
-				}	
-				
-				if (port->flags & ASYNC_CTS_FLOW) {
-					if (port->tty->hw_stopped) {
-						if (header & ISI_CTS) {
-							port->tty->hw_stopped = 0;
-							/* start tx ing */
-							port->status |= (ISI_TXOK | ISI_CTS);
-							schedule_work(&port->bh_tqueue);
-						}
-					}
-					else {
-						if (!(header & ISI_CTS)) {
-							port->tty->hw_stopped = 1;
-							/* stop tx ing */
-							port->status &= ~(ISI_TXOK | ISI_CTS);
-						}
+						schedule_work(&port->hangup_tq);
@@ -884,0 +628,5 @@
+				} else if (header & ISI_DCD) {
+				/* Carrier has been detected */
+					pr_dbg("interrupt: DCD->high.\n");
+					port->status |= ISI_DCD;
+					wake_up_interruptible(&port->open_wait);
@@ -886,9 +634,3 @@
-				else {
-					if (header & ISI_CTS) 
-						port->status |= ISI_CTS;
-					else
-						port->status &= ~ISI_CTS;
-				}
-				
-				if (header & ISI_DSR) 
-					port->status |= ISI_DSR;
+			} else {
+				if (header & ISI_DCD)
+					port->status |= ISI_DCD;
@@ -896,4 +638,20 @@
-					port->status &= ~ISI_DSR;
-				
-				if (header & ISI_RI) 
-					port->status |= ISI_RI;
+					port->status &= ~ISI_DCD;
+			}
+
+			if (port->flags & ASYNC_CTS_FLOW) {
+				if (port->tty->hw_stopped) {
+					if (header & ISI_CTS) {
+						port->tty->hw_stopped = 0;
+						/* start tx ing */
+						port->status |= (ISI_TXOK
+							| ISI_CTS);
+						schedule_work(&port->bh_tqueue);
+					}
+				} else if (!(header & ISI_CTS)) {
+					port->tty->hw_stopped = 1;
+					/* stop tx ing */
+					port->status &= ~(ISI_TXOK | ISI_CTS);
+				}
+			} else {
+				if (header & ISI_CTS)
+					port->status |= ISI_CTS;
@@ -901,30 +659,34 @@
-					port->status &= ~ISI_RI;						
-				
-				break;
-				
-			case 1:	/* Received Break !!!	 */
-				if (tty->flip.count >= TTY_FLIPBUF_SIZE)
-					break;
-				*tty->flip.flag_buf_ptr++ = TTY_BREAK;
-				*tty->flip.char_buf_ptr++ = 0;
-				tty->flip.count++;
-				if (port->flags & ASYNC_SAK)
-					do_SAK(tty);
-				schedule_delayed_work(&tty->flip.work, 1);
-				break;
-				
-			case 2:	/* Statistics		 */
-				printk(KERN_DEBUG "ISICOM: isicom_interrupt: stats!!!.\n");			
-				break;
-				
-			default:
-				printk(KERN_WARNING "ISICOM: Intr: Unknown code in status packet.\n");
-				break;
-		}	 
-	}
-	else {				/* Data   Packet */
-		count = min_t(unsigned short, byte_count, (TTY_FLIPBUF_SIZE - tty->flip.count));
-#ifdef ISICOM_DEBUG
-		printk(KERN_DEBUG "ISICOM: Intr: Can rx %d of %d bytes.\n", 
-					count, byte_count);
-#endif			
+					port->status &= ~ISI_CTS;
+			}
+
+			if (header & ISI_DSR)
+				port->status |= ISI_DSR;
+			else
+				port->status &= ~ISI_DSR;
+
+			if (header & ISI_RI)
+				port->status |= ISI_RI;
+			else
+				port->status &= ~ISI_RI;
+
+			break;
+
+		case 1:	/* Received Break !!! */
+			tty_insert_flip_char(tty, 0, TTY_BREAK);
+			if (port->flags & ASYNC_SAK)
+				do_SAK(tty);
+			tty_flip_buffer_push(tty);
+			break;
+
+		case 2:	/* Statistics		 */
+			pr_dbg("isicom_interrupt: stats!!!.\n");
+			break;
+
+		default:
+			pr_dbg("Intr: Unknown code in status packet.\n");
+			break;
+		}
+	} else {				/* Data   Packet */
+
+		count = tty_prepare_flip_string(tty, &rp, byte_count & ~1);
+		pr_dbg("Intr: Can rx %d of %d bytes.\n", count, byte_count);
@@ -932,2 +694 @@
-		insw(base, tty->flip.char_buf_ptr, word_count);
-		tty->flip.char_buf_ptr += (word_count << 1);		
+		insw(base, rp, word_count);
@@ -936 +697,2 @@
-			*tty->flip.char_buf_ptr++ = (char)(inw(base) & 0xff);
+			tty_insert_flip_char(tty,  inw(base) & 0xff,
+				TTY_NORMAL);
@@ -938,5 +700 @@
-		}	
-		memset(tty->flip.flag_buf_ptr, 0, count);
-		tty->flip.flag_buf_ptr += count;
-		tty->flip.count += count;
-		
+		}
@@ -944,2 +702,2 @@
-			printk(KERN_DEBUG "ISICOM: Intr(0x%x:%d): Flip buffer overflow! dropping bytes...\n",
-					base, channel+1);
+			pr_dbg("Intr(0x%lx:%d): Flip buffer overflow! dropping "
+				"bytes...\n", base, channel + 1);
@@ -951 +709 @@
-		schedule_delayed_work(&tty->flip.work, 1);
+		tty_flip_buffer_push(tty);
@@ -956 +714,2 @@
-		outw(0x0000, base+0x04); /* enable interrupts */	
+		outw(0x0000, base+0x04); /* enable interrupts */
+
@@ -958 +717 @@
-} 
+}
@@ -960 +719 @@
-static void isicom_config_port(struct isi_port * port)
+static void isicom_config_port(struct isi_port *port)
@@ -962,2 +721,2 @@
-	struct isi_board * card = port->card;
-	struct tty_struct * tty;
+	struct isi_board *card = port->card;
+	struct tty_struct *tty;
@@ -965,2 +724,3 @@
-	unsigned short channel_setup, base = card->base;
-	unsigned short channel = port->channel, shift_count = card->shift_count;
+	unsigned long base = card->base;
+	u16 channel_setup, channel = port->channel,
+		shift_count = card->shift_count;
@@ -968 +728 @@
-	
+
@@ -974 +734 @@
-		
+
@@ -978,2 +738,2 @@
-		 */   
-		 
+		 */
+
@@ -984 +744 @@
-	}	
+	}
@@ -986,2 +746,2 @@
-	
-		/*  the ASYNC_SPD_HI and ASYNC_SPD_VHI options are set 
+
+		/*  the ASYNC_SPD_HI and ASYNC_SPD_VHI options are set
@@ -990,2 +750,2 @@
-		 */  
-			
+		 */
+
@@ -993 +753 @@
-			baud++;     /*  57.6 Kbps */
+			baud++; /*  57.6 Kbps */
@@ -995 +755 @@
-			baud +=2;   /*  115  Kbps */	 
+			baud +=2; /*  115  Kbps */
@@ -999,4 +759,4 @@
-	 	drop_dtr(port);
-	 	return;
-	}	
-	else  
+		drop_dtr(port);
+		return;
+	}
+	else
@@ -1004 +764 @@
-		
+
@@ -1010,12 +770,12 @@
-			case CS5:
-				channel_setup |= ISICOM_CS5;
-				break;
-			case CS6:
-				channel_setup |= ISICOM_CS6;
-				break;
-			case CS7:
-				channel_setup |= ISICOM_CS7;
-				break;
-			case CS8:
-				channel_setup |= ISICOM_CS8;
-				break;
+		case CS5:
+			channel_setup |= ISICOM_CS5;
+			break;
+		case CS6:
+			channel_setup |= ISICOM_CS6;
+			break;
+		case CS7:
+			channel_setup |= ISICOM_CS7;
+			break;
+		case CS8:
+			channel_setup |= ISICOM_CS8;
+			break;
@@ -1023 +783 @@
-			
+
@@ -1029 +789 @@
-				channel_setup |= ISICOM_ODPAR;	
+				channel_setup |= ISICOM_ODPAR;
@@ -1031 +791 @@
-		outw(channel_setup, base);	
+		outw(channel_setup, base);
@@ -1033,2 +793,2 @@
-		unlock_card(card);	
-	}	
+		unlock_card(card);
+	}
@@ -1038,2 +798,2 @@
-		port->flags |= ASYNC_CHECK_CD;	
-	
+		port->flags |= ASYNC_CHECK_CD;
+
@@ -1046,2 +806,2 @@
-	}	
-	if (I_IXON(tty))	
+	}
+	if (I_IXON(tty))
@@ -1050,2 +810,2 @@
-		flow_ctrl |= ISICOM_INITIATE_XONXOFF;	
-		
+		flow_ctrl |= ISICOM_INITIATE_XONXOFF;
+
@@ -1059 +819 @@
-	
+
@@ -1066,2 +825,0 @@
- 
-/* open et all */ 
@@ -1069 +827,3 @@
-static inline void isicom_setup_board(struct isi_board * bp)
+/* open et all */
+
+static inline void isicom_setup_board(struct isi_board *bp)
@@ -1072 +832 @@
-	struct isi_port * port;
+	struct isi_port *port;
@@ -1074 +834 @@
-	
+
@@ -1083 +843 @@
-	for(channel = 0; channel < bp->port_count; channel++, port++)
+	for (channel = 0; channel < bp->port_count; channel++, port++)
@@ -1087,2 +847,2 @@
- 
-static int isicom_setup_port(struct isi_port * port)
+
+static int isicom_setup_port(struct isi_port *port)
@@ -1090 +850 @@
-	struct isi_board * card = port->card;
+	struct isi_board *card = port->card;
@@ -1092 +852 @@
-	
+
@@ -1098 +858 @@
-		
+
@@ -1101 +861 @@
-		
+
@@ -1106,2 +866,2 @@
-		port->xmit_buf = (unsigned char *) page;	
-	}	
+		port->xmit_buf = (unsigned char *) page;
+	}
@@ -1114 +874 @@
-		
+
@@ -1116 +876 @@
-	
+
@@ -1119 +879 @@
-	
+
@@ -1123,5 +883,6 @@
-	
-	return 0;		
-} 
- 
-static int block_til_ready(struct tty_struct * tty, struct file * filp, struct isi_port * port) 
+
+	return 0;
+}
+
+static int block_til_ready(struct tty_struct *tty, struct file *filp,
+	struct isi_port *port)
@@ -1129 +890 @@
-	struct isi_board * card = port->card;
+	struct isi_board *card = port->card;
@@ -1137,3 +898 @@
-#ifdef ISICOM_DEBUG	
-		printk(KERN_DEBUG "ISICOM: block_til_ready: close in progress.\n");
-#endif		
+		pr_dbg("block_til_ready: close in progress.\n");
@@ -1146 +905 @@
-	
+
@@ -1148,5 +907,4 @@
-	
-	if ((filp->f_flags & O_NONBLOCK) || (tty->flags & (1 << TTY_IO_ERROR))) {
-#ifdef ISICOM_DEBUG	
-		printk(KERN_DEBUG "ISICOM: block_til_ready: non-block mode.\n");
-#endif		
+
+	if ((filp->f_flags & O_NONBLOCK) ||
+			(tty->flags & (1 << TTY_IO_ERROR))) {
+		pr_dbg("block_til_ready: non-block mode.\n");
@@ -1154,3 +912,3 @@
-		return 0;	
-	}	
-	
+		return 0;
+	}
+
@@ -1159,2 +917,2 @@
-	
-	/* block waiting for DCD to be asserted, and while 
+
+	/* block waiting for DCD to be asserted, and while
@@ -1170 +928 @@
-	
+
@@ -1175 +933 @@
-		if (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)) { 	
+		if (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)) {
@@ -1181 +939 @@
-		}	
+		}
@@ -1183 +941 @@
-		    (do_clocal || (port->status & ISI_DCD))) {
+				(do_clocal || (port->status & ISI_DCD))) {
@@ -1185 +943 @@
-		}	
+		}
@@ -1190 +948 @@
-		schedule();		
+		schedule();
@@ -1204,2 +962,2 @@
- 
-static int isicom_open(struct tty_struct * tty, struct file * filp)
+
+static int isicom_open(struct tty_struct *tty, struct file *filp)
@@ -1207,2 +965,2 @@
-	struct isi_port * port;
-	struct isi_board * card;
+	struct isi_port *port;
+	struct isi_board *card;
@@ -1217 +975 @@
-	
+
@@ -1220 +978 @@
-	
+
@@ -1225 +983 @@
-	port = &isi_ports[line];	
+	port = &isi_ports[line];
@@ -1228,3 +986,3 @@
-		
-	isicom_setup_board(card);		
-	
+
+	isicom_setup_board(card);
+
@@ -1239 +997 @@
-	return 0;      		
+	return 0;
@@ -1241 +999 @@
- 
+
@@ -1244 +1002 @@
-static inline void isicom_shutdown_board(struct isi_board * bp)
+static inline void isicom_shutdown_board(struct isi_board *bp)
@@ -1255 +1013 @@
-static void isicom_shutdown_port(struct isi_port * port)
+static void isicom_shutdown_port(struct isi_port *port)
@@ -1257,2 +1015,2 @@
-	struct isi_board * card = port->card;
-	struct tty_struct * tty;	
+	struct isi_board *card = port->card;
+	struct tty_struct *tty;
@@ -1260 +1018 @@
-	
+
@@ -1263 +1021 @@
-	spin_lock_irqsave(&card->card_lock, flags);	
+	spin_lock_irqsave(&card->card_lock, flags);
@@ -1271 +1029 @@
-	}	
+	}
@@ -1276 +1034 @@
-	
+
@@ -1280 +1038 @@
-	appears on the remote end. Now we drop the dtr only if the 
+	appears on the remote end. Now we drop the dtr only if the
@@ -1282,2 +1040,2 @@
-	
-	if (C_HUPCL(tty)) 
+
+	if (C_HUPCL(tty))
@@ -1286,2 +1044,2 @@
-		
-	/* any other port uninits  */ 
+
+	/* any other port uninits  */
@@ -1290 +1048 @@
-	
+
@@ -1292 +1050 @@
-		printk(KERN_DEBUG "ISICOM: isicom_shutdown_port: bad board(0x%x) count %d.\n",
+		pr_dbg("isicom_shutdown_port: bad board(0x%lx) count %d.\n",
@@ -1294 +1052 @@
-		card->count = 0;	
+		card->count = 0;
@@ -1296,3 +1054,3 @@
-	
-	/* last port was closed , shutdown that boad too */
-	if(C_HUPCL(tty)) {
+
+	/* last port was closed, shutdown that boad too */
+	if (C_HUPCL(tty)) {
@@ -1304 +1062 @@
-static void isicom_close(struct tty_struct * tty, struct file * filp)
+static void isicom_close(struct tty_struct *tty, struct file *filp)
@@ -1306,2 +1064,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	struct isi_board * card = port->card;
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
@@ -1309 +1067 @@
-	
+
@@ -1314,5 +1072,3 @@
-	
-#ifdef ISICOM_DEBUG		
-	printk(KERN_DEBUG "ISICOM: Close start!!!.\n");
-#endif	
-	
+
+	pr_dbg("Close start!!!.\n");
+
@@ -1324 +1080 @@
-	
+
@@ -1326,2 +1082,2 @@
-		printk(KERN_WARNING "ISICOM:(0x%x) isicom_close: bad port count"
-			"tty->count = 1	port count = %d.\n",
+		printk(KERN_WARNING "ISICOM:(0x%lx) isicom_close: bad port "
+			"count tty->count = 1 port count = %d.\n",
@@ -1332,2 +1088,2 @@
-		printk(KERN_WARNING "ISICOM:(0x%x) isicom_close: bad port count for"
-			"channel%d = %d", card->base, port->channel, 
+		printk(KERN_WARNING "ISICOM:(0x%lx) isicom_close: bad port "
+			"count for channel%d = %d", card->base, port->channel,
@@ -1335 +1091 @@
-		port->count = 0;	
+		port->count = 0;
@@ -1337 +1093 @@
-	
+
@@ -1341 +1097 @@
-	} 	
+	}
@@ -1345 +1101 @@
-	
+
@@ -1348 +1104 @@
-	/* indicate to the card that no more data can be received 
+	/* indicate to the card that no more data can be received
@@ -1351 +1107 @@
-	if (port->flags & ASYNC_INITIALIZED) {   
+	if (port->flags & ASYNC_INITIALIZED) {
@@ -1354 +1110 @@
-	}	
+	}
@@ -1357 +1113 @@
-	
+
@@ -1368,4 +1124,3 @@
-#ifdef ISICOM_DEBUG			
-			printk(KERN_DEBUG "ISICOM: scheduling until time out.\n");
-#endif			
-			msleep_interruptible(jiffies_to_msecs(port->close_delay));
+			pr_dbg("scheduling until time out.\n");
+			msleep_interruptible(
+				jiffies_to_msecs(port->close_delay));
@@ -1375 +1130 @@
-	}	
+	}
@@ -1382,2 +1137,2 @@
-static int isicom_write(struct tty_struct * tty,
-			const unsigned char * buf, int count)
+static int isicom_write(struct tty_struct *tty,	const unsigned char *buf,
+	int count)
@@ -1385,2 +1140,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	struct isi_board * card = port->card;
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
@@ -1392,2 +1147,2 @@
-	
-	if (!tty || !port->xmit_buf || !tmp_buf)
+
+	if (!tty || !port->xmit_buf)
@@ -1395 +1150 @@
-		
+
@@ -1397,5 +1152,5 @@
-	
-	while(1) {	
-		cnt = min_t(int, count, min(SERIAL_XMIT_SIZE - port->xmit_cnt - 1,
-					    SERIAL_XMIT_SIZE - port->xmit_head));
-		if (cnt <= 0) 
+
+	while(1) {
+		cnt = min_t(int, count, min(SERIAL_XMIT_SIZE - port->xmit_cnt
+				- 1, SERIAL_XMIT_SIZE - port->xmit_head));
+		if (cnt <= 0)
@@ -1403 +1158 @@
-		
+
@@ -1405 +1160,2 @@
-		port->xmit_head = (port->xmit_head + cnt) & (SERIAL_XMIT_SIZE - 1);
+		port->xmit_head = (port->xmit_head + cnt) & (SERIAL_XMIT_SIZE
+			- 1);
@@ -1410 +1166 @@
-	}		
+	}
@@ -1414 +1170 @@
-	return total;	
+	return total;
@@ -1418 +1174 @@
-static void isicom_put_char(struct tty_struct * tty, unsigned char ch)
+static void isicom_put_char(struct tty_struct *tty, unsigned char ch)
@@ -1420,2 +1176,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	struct isi_board * card = port->card;
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
@@ -1423 +1179 @@
-	
+
@@ -1426 +1182 @@
-	
+
@@ -1435 +1191 @@
-	
+
@@ -1443 +1199 @@
-static void isicom_flush_chars(struct tty_struct * tty)
+static void isicom_flush_chars(struct tty_struct *tty)
@@ -1445,2 +1201,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	
+	struct isi_port *port = tty->driver_data;
+
@@ -1449,2 +1205,3 @@
-	
-	if (port->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped || !port->xmit_buf)
+
+	if (port->xmit_cnt <= 0 || tty->stopped || tty->hw_stopped ||
+			!port->xmit_buf)
@@ -1452 +1209 @@
-		
+
@@ -1455 +1212 @@
-	port->status |= ISI_TXOK;	
+	port->status |= ISI_TXOK;
@@ -1459 +1216 @@
-static int isicom_write_room(struct tty_struct * tty)
+static int isicom_write_room(struct tty_struct *tty)
@@ -1461 +1218 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
+	struct isi_port *port = tty->driver_data;
@@ -1466 +1223 @@
-	
+
@@ -1474 +1231 @@
-static int isicom_chars_in_buffer(struct tty_struct * tty)
+static int isicom_chars_in_buffer(struct tty_struct *tty)
@@ -1476 +1233 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
+	struct isi_port *port = tty->driver_data;
@@ -1483 +1240,2 @@
-static inline void isicom_send_break(struct isi_port * port, unsigned long length)
+static inline void isicom_send_break(struct isi_port *port,
+	unsigned long length)
@@ -1485,4 +1243,4 @@
-	struct isi_board * card = port->card;
-	unsigned short base = card->base;	
-	
-	if(!lock_card(card))
+	struct isi_board *card = port->card;
+	unsigned long base = card->base;
+
+	if (!lock_card(card))
@@ -1490 +1248 @@
-		
+
@@ -1501 +1259 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
+	struct isi_port *port = tty->driver_data;
@@ -1503 +1261 @@
-	unsigned short status = port->status;
+	u16 status = port->status;
@@ -1507 +1265 @@
-	
+
@@ -1517 +1275 @@
-			   unsigned int set, unsigned int clear)
+	unsigned int set, unsigned int clear)
@@ -1519,2 +1277,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	
+	struct isi_port *port = tty->driver_data;
+
@@ -1523 +1281 @@
-	
+
@@ -1535 +1293 @@
-}			
+}
@@ -1537,2 +1295,2 @@
-static int isicom_set_serial_info(struct isi_port * port,
-					struct serial_struct __user *info)
+static int isicom_set_serial_info(struct isi_port *port,
+	struct serial_struct __user *info)
@@ -1543 +1301 @@
-	if(copy_from_user(&newinfo, info, sizeof(newinfo)))
+	if (copy_from_user(&newinfo, info, sizeof(newinfo)))
@@ -1545,4 +1303,4 @@
-		
-	reconfig_port = ((port->flags & ASYNC_SPD_MASK) != 
-			 (newinfo.flags & ASYNC_SPD_MASK));
-	
+
+	reconfig_port = ((port->flags & ASYNC_SPD_MASK) !=
+		(newinfo.flags & ASYNC_SPD_MASK));
+
@@ -1551,3 +1309,3 @@
-		    (newinfo.closing_wait != port->closing_wait) ||
-		    ((newinfo.flags & ~ASYNC_USR_MASK) != 
-		     (port->flags & ~ASYNC_USR_MASK)))
+				(newinfo.closing_wait != port->closing_wait) ||
+				((newinfo.flags & ~ASYNC_USR_MASK) !=
+				(port->flags & ~ASYNC_USR_MASK)))
@@ -1557 +1315 @@
-	}	
+	}
@@ -1560,2 +1318,2 @@
-		port->closing_wait = newinfo.closing_wait; 
-		port->flags = ((port->flags & ~ASYNC_FLAGS) | 
+		port->closing_wait = newinfo.closing_wait;
+		port->flags = ((port->flags & ~ASYNC_FLAGS) |
@@ -1567,2 +1325,2 @@
-	return 0;		 
-}		
+	return 0;
+}
@@ -1570,2 +1328,2 @@
-static int isicom_get_serial_info(struct isi_port * port, 
-					struct serial_struct __user *info)
+static int isicom_get_serial_info(struct isi_port *port,
+	struct serial_struct __user *info)
@@ -1574 +1332 @@
-	
+
@@ -1584 +1342 @@
-	if(copy_to_user(info, &out_info, sizeof(out_info)))
+	if (copy_to_user(info, &out_info, sizeof(out_info)))
@@ -1587 +1345 @@
-}					
+}
@@ -1589,2 +1347,2 @@
-static int isicom_ioctl(struct tty_struct * tty, struct file * filp,
-			unsigned int cmd, unsigned long arg) 
+static int isicom_ioctl(struct tty_struct *tty, struct file *filp,
+	unsigned int cmd, unsigned long arg)
@@ -1592 +1350 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
+	struct isi_port *port = tty->driver_data;
@@ -1600,36 +1358,37 @@
-		case TCSBRK:
-			retval = tty_check_change(tty);
-			if (retval)
-				return retval;
-			tty_wait_until_sent(tty, 0);
-			if (!arg)
-				isicom_send_break(port, HZ/4);
-			return 0;
-			
-		case TCSBRKP:	
-			retval = tty_check_change(tty);
-			if (retval)
-				return retval;
-			tty_wait_until_sent(tty, 0);
-			isicom_send_break(port, arg ? arg * (HZ/10) : HZ/4);
-			return 0;
-			
-		case TIOCGSOFTCAR:
-			return put_user(C_CLOCAL(tty) ? 1 : 0, (unsigned long __user *)argp);
-			
-		case TIOCSSOFTCAR:
-			if(get_user(arg, (unsigned long __user *) argp))
-				return -EFAULT;
-			tty->termios->c_cflag =
-				((tty->termios->c_cflag & ~CLOCAL) |
-				(arg ? CLOCAL : 0));
-			return 0;	
-			
-		case TIOCGSERIAL:
-			return isicom_get_serial_info(port, argp);
-		
-		case TIOCSSERIAL:
-			return isicom_set_serial_info(port, argp);
-					
-		default:
-			return -ENOIOCTLCMD;						
+	case TCSBRK:
+		retval = tty_check_change(tty);
+		if (retval)
+			return retval;
+		tty_wait_until_sent(tty, 0);
+		if (!arg)
+			isicom_send_break(port, HZ/4);
+		return 0;
+
+	case TCSBRKP:
+		retval = tty_check_change(tty);
+		if (retval)
+			return retval;
+		tty_wait_until_sent(tty, 0);
+		isicom_send_break(port, arg ? arg * (HZ/10) : HZ/4);
+		return 0;
+
+	case TIOCGSOFTCAR:
+		return put_user(C_CLOCAL(tty) ? 1 : 0,
+				(unsigned long __user *)argp);
+
+	case TIOCSSOFTCAR:
+		if (get_user(arg, (unsigned long __user *) argp))
+			return -EFAULT;
+		tty->termios->c_cflag =
+			((tty->termios->c_cflag & ~CLOCAL) |
+			(arg ? CLOCAL : 0));
+		return 0;
+
+	case TIOCGSERIAL:
+		return isicom_get_serial_info(port, argp);
+
+	case TIOCSSERIAL:
+		return isicom_set_serial_info(port, argp);
+
+	default:
+		return -ENOIOCTLCMD;
@@ -1641 +1400,2 @@
-static void isicom_set_termios(struct tty_struct * tty, struct termios * old_termios)
+static void isicom_set_termios(struct tty_struct *tty,
+	struct termios *old_termios)
@@ -1643,2 +1403,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	
+	struct isi_port *port = tty->driver_data;
+
@@ -1647 +1407 @@
-	
+
@@ -1649 +1409 @@
-	    tty->termios->c_iflag == old_termios->c_iflag)
+			tty->termios->c_iflag == old_termios->c_iflag)
@@ -1651 +1411 @@
-		
+
@@ -1653 +1413 @@
-	
+
@@ -1655 +1415 @@
-	    !(tty->termios->c_cflag & CRTSCTS)) {	
+			!(tty->termios->c_cflag & CRTSCTS)) {
@@ -1657,2 +1417,2 @@
-		isicom_start(tty);   
-	}    
+		isicom_start(tty);
+	}
@@ -1662 +1422 @@
-static void isicom_throttle(struct tty_struct * tty)
+static void isicom_throttle(struct tty_struct *tty)
@@ -1664,3 +1424,3 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	struct isi_board * card = port->card;
-	
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
+
@@ -1669 +1429 @@
-	
+
@@ -1676 +1436 @@
-static void isicom_unthrottle(struct tty_struct * tty)
+static void isicom_unthrottle(struct tty_struct *tty)
@@ -1678,3 +1438,3 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	struct isi_board * card = port->card;
-	
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
+
@@ -1683 +1443 @@
-	
+
@@ -1690 +1450 @@
-static void isicom_stop(struct tty_struct * tty)
+static void isicom_stop(struct tty_struct *tty)
@@ -1692 +1452 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
+	struct isi_port *port = tty->driver_data;
@@ -1696 +1456 @@
-	
+
@@ -1703 +1463 @@
-static void isicom_start(struct tty_struct * tty)
+static void isicom_start(struct tty_struct *tty)
@@ -1705,2 +1465,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	
+	struct isi_port *port = tty->driver_data;
+
@@ -1709 +1469 @@
-	
+
@@ -1716 +1476 @@
-static void do_isicom_hangup(void * data)
+static void do_isicom_hangup(void *data)
@@ -1718,3 +1478,3 @@
-	struct isi_port * port = (struct isi_port *) data;
-	struct tty_struct * tty;
-	
+	struct isi_port *port = data;
+	struct tty_struct *tty;
+
@@ -1726 +1486 @@
-static void isicom_hangup(struct tty_struct * tty)
+static void isicom_hangup(struct tty_struct *tty)
@@ -1728,2 +1488,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	
+	struct isi_port *port = tty->driver_data;
+
@@ -1732 +1492 @@
-	
+
@@ -1741 +1501 @@
-static void isicom_flush_buffer(struct tty_struct * tty)
+static void isicom_flush_buffer(struct tty_struct *tty)
@@ -1743,2 +1503,2 @@
-	struct isi_port * port = (struct isi_port *) tty->driver_data;
-	struct isi_board * card = port->card;
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
@@ -1746 +1506 @@
-	
+
@@ -1749 +1509 @@
-	
+
@@ -1753 +1513 @@
-	
+
@@ -1757,0 +1518,3 @@
+/*
+ * Driver init and deinit functions
+ */
@@ -1759 +1522,2 @@
-static int __devinit register_ioregion(void)
+static int __devinit isicom_register_ioregion(struct pci_dev *pdev,
+	const unsigned int index)
@@ -1761,11 +1525,13 @@
-	int count, done=0;
-	for (count=0; count < BOARD_COUNT; count++ ) {
-		if (isi_card[count].base)
-			if (!request_region(isi_card[count].base,16,ISICOM_NAME)) {
-				printk(KERN_DEBUG "ISICOM: I/O Region 0x%x-0x%x is busy. Card%d will be disabled.\n",
-					isi_card[count].base,isi_card[count].base+15,count+1);
-				isi_card[count].base=0;
-				done++;
-			}
-	}
-	return done;
+	struct isi_board *board = pci_get_drvdata(pdev);
+
+	if (!board->base)
+		return -EINVAL;
+
+	if (!request_region(board->base, 16, ISICOM_NAME)) {
+		dev_dbg(&pdev->dev, "I/O Region 0x%lx-0x%lx is busy. Card%d "
+			"will be disabled.\n", board->base, board->base + 15,
+			index + 1);
+		return -EBUSY;
+ 	}
+
+	return 0;
@@ -1774 +1540 @@
-static void unregister_ioregion(void)
+static void isicom_unregister_ioregion(struct pci_dev *pdev)
@@ -1776,8 +1542,9 @@
-	int count;
-	for (count=0; count < BOARD_COUNT; count++ ) 
-		if (isi_card[count].base) {
-			release_region(isi_card[count].base,16);
-#ifdef ISICOM_DEBUG			
-			printk(KERN_DEBUG "ISICOM: I/O Region 0x%x-0x%x released for Card%d.\n",isi_card[count].base,isi_card[count].base+15,count+1);
-#endif			
-		}
+	struct isi_board *board = pci_get_drvdata(pdev);
+
+	if (!board->base)
+		return;
+
+	release_region(board->base, 16);
+	dev_dbg(&pdev->dev, "I/O Region 0x%lx-0x%lx released.\n",
+		board->base, board->base + 15);
+	board->base = 0;
@@ -1787,6 +1554,6 @@
-	.open	= isicom_open,
-	.close	= isicom_close,
-	.write	= isicom_write,
-	.put_char	= isicom_put_char,
-	.flush_chars	= isicom_flush_chars,
-	.write_room	= isicom_write_room,
+	.open			= isicom_open,
+	.close			= isicom_close,
+	.write			= isicom_write,
+	.put_char		= isicom_put_char,
+	.flush_chars		= isicom_flush_chars,
+	.write_room		= isicom_write_room,
@@ -1794,10 +1561,10 @@
-	.ioctl	= isicom_ioctl,
-	.set_termios	= isicom_set_termios,
-	.throttle	= isicom_throttle,
-	.unthrottle	= isicom_unthrottle,
-	.stop	= isicom_stop,
-	.start	= isicom_start,
-	.hangup	= isicom_hangup,
-	.flush_buffer	= isicom_flush_buffer,
-	.tiocmget	= isicom_tiocmget,
-	.tiocmset	= isicom_tiocmset,
+	.ioctl			= isicom_ioctl,
+	.set_termios		= isicom_set_termios,
+	.throttle		= isicom_throttle,
+	.unthrottle		= isicom_unthrottle,
+	.stop			= isicom_stop,
+	.start			= isicom_start,
+	.hangup			= isicom_hangup,
+	.flush_buffer		= isicom_flush_buffer,
+	.tiocmget		= isicom_tiocmget,
+	.tiocmset		= isicom_tiocmset,
@@ -1806 +1573 @@
-static int __devinit register_drivers(void)
+static int __devinit isicom_register_tty_driver(void)
@@ -1808 +1575 @@
-	int error;
+	int error = -ENOMEM;
@@ -1813 +1580 @@
-		return -ENOMEM;
+		goto end;
@@ -1815,11 +1582,11 @@
-	isicom_normal->owner	= THIS_MODULE;
-	isicom_normal->name 	= "ttyM";
-	isicom_normal->devfs_name = "isicom/";
-	isicom_normal->major	= ISICOM_NMAJOR;
-	isicom_normal->minor_start	= 0;
-	isicom_normal->type	= TTY_DRIVER_TYPE_SERIAL;
-	isicom_normal->subtype	= SERIAL_TYPE_NORMAL;
-	isicom_normal->init_termios	= tty_std_termios;
-	isicom_normal->init_termios.c_cflag	= 
-				B9600 | CS8 | CREAD | HUPCL |CLOCAL;
-	isicom_normal->flags	= TTY_DRIVER_REAL_RAW;
+	isicom_normal->owner			= THIS_MODULE;
+	isicom_normal->name 			= "ttyM";
+	isicom_normal->devfs_name	 	= "isicom/";
+	isicom_normal->major			= ISICOM_NMAJOR;
+	isicom_normal->minor_start		= 0;
+	isicom_normal->type			= TTY_DRIVER_TYPE_SERIAL;
+	isicom_normal->subtype			= SERIAL_TYPE_NORMAL;
+	isicom_normal->init_termios		= tty_std_termios;
+	isicom_normal->init_termios.c_cflag	= B9600 | CS8 | CREAD | HUPCL |
+		CLOCAL;
+	isicom_normal->flags			= TTY_DRIVER_REAL_RAW;
@@ -1827,3 +1594,3 @@
-	
-	if ((error=tty_register_driver(isicom_normal))!=0) {
-		printk(KERN_DEBUG "ISICOM: Couldn't register the dialin driver, error=%d\n",
+
+	if ((error = tty_register_driver(isicom_normal))) {
+		pr_dbg("Couldn't register the dialin driver, error=%d\n",
@@ -1832 +1598,0 @@
-		return error;
@@ -1834 +1600,2 @@
-	return 0;
+end:
+	return error;
@@ -1837 +1604 @@
-static void unregister_drivers(void)
+static void isicom_unregister_tty_driver(void)
@@ -1839,3 +1606,5 @@
-	int error = tty_unregister_driver(isicom_normal);
-	if (error)
-		printk(KERN_DEBUG "ISICOM: couldn't unregister normal driver error=%d.\n",error);
+	int error;
+
+	if ((error = tty_unregister_driver(isicom_normal)))
+		pr_dbg("couldn't unregister normal driver, error=%d.\n", error);
+
@@ -1845 +1614,2 @@
-static int __devinit register_isr(void)
+static int __devinit isicom_register_isr(struct pci_dev *pdev,
+	const unsigned int index)
@@ -1847,2 +1617,3 @@
-	int count, done=0;
-	unsigned long irqflags;
+	struct isi_board *board = pci_get_drvdata(pdev);
+	unsigned long irqflags = SA_INTERRUPT;
+	int retval = -EINVAL;
@@ -1850,15 +1621,2 @@
-	for (count=0; count < BOARD_COUNT; count++ ) {
-		if (isi_card[count].base) {
-			irqflags = (isi_card[count].isa == YES) ? 
-					SA_INTERRUPT : 
-					(SA_INTERRUPT | SA_SHIRQ);
-
-			if (request_irq(isi_card[count].irq, 
-					isicom_interrupt, 
-					irqflags, 
-					ISICOM_NAME, &isi_card[count])) {
-
-				printk(KERN_WARNING "ISICOM: Could not"
-					" install handler at Irq %d."
-					" Card%d will be disabled.\n",
-					isi_card[count].irq, count+1);
+	if (!board->base)
+		goto end;
@@ -1866,8 +1624,12 @@
-				release_region(isi_card[count].base,16);
-				isi_card[count].base=0;
-			}
-			else
-				done++;
-		}	
-	}
-	return done;
+	if (board->isa == NO)
+		irqflags |= SA_SHIRQ;
+
+	retval = request_irq(board->irq, isicom_interrupt, irqflags,
+		ISICOM_NAME, board);
+	if (retval < 0)
+		dev_warn(&pdev->dev, "Could not install handler at Irq %d. "
+			"Card%d will be disabled.\n", board->irq, index + 1);
+ 	else
+		retval = 0;
+end:
+	return retval;
@@ -1876 +1638,2 @@
-static void __exit unregister_isr(void)
+static int __devinit reset_card(struct pci_dev *pdev,
+	const unsigned int card, unsigned int *signature)
@@ -1878 +1641,4 @@
-	int count;
+	struct isi_board *board = pci_get_drvdata(pdev);
+	unsigned long base = board->base;
+	unsigned int portcount = 0;
+	int retval = 0;
@@ -1880,5 +1646,2 @@
-	for (count=0; count < BOARD_COUNT; count++ ) {
-		if (isi_card[count].base)
-			free_irq(isi_card[count].irq, &isi_card[count]);
-	}
-}
+	dev_dbg(&pdev->dev, "ISILoad:Resetting Card%d at 0x%lx\n", card + 1,
+		base);
@@ -1886,30 +1649,32 @@
-static int __devinit isicom_init(void)
-{
-	int card, channel, base;
-	struct isi_port * port;
-	unsigned long page;
-	
-	if (!tmp_buf) { 
-		page = get_zeroed_page(GFP_KERNEL);
-	      	if (!page) {
-#ifdef ISICOM_DEBUG	      	
-	      		printk(KERN_DEBUG "ISICOM: Couldn't allocate page for tmp_buf.\n");
-#else
-			printk(KERN_ERR "ISICOM: Not enough memory...\n");
-#endif	      
-	      		return 0;
-	      	}	
-	      	tmp_buf = (unsigned char *) page;
-	}
-	
-	if (!register_ioregion()) 
-	{
-		printk(KERN_ERR "ISICOM: All required I/O space found busy.\n");
-		free_page((unsigned long)tmp_buf);
-		return 0;
-	}
-	if (register_drivers()) 
-	{
-		unregister_ioregion();
-		free_page((unsigned long)tmp_buf);
-		return 0;
+	inw(base + 0x8);
+
+	mdelay(10);
+
+	outw(0, base + 0x8); /* Reset */
+
+	msleep(3000);
+
+	*signature = inw(base + 0x4) & 0xff;
+
+	if (board->isa == YES) {
+		if (!(inw(base + 0xe) & 0x1) || (inw(base + 0x2))) {
+			dev_dbg(&pdev->dev, "base+0x2=0x%lx, base+0xe=0x%lx\n",
+				inw(base + 0x2), inw(base + 0xe));
+			dev_err(&pdev->dev, "ISILoad:ISA Card%d reset failure "
+				"(Possible bad I/O Port Address 0x%lx).\n",
+				card + 1, base);
+			retval = -EIO;
+			goto end;
+		}
+	} else {
+		portcount = inw(base + 0x2);
+		if (!(inw(base + 0xe) & 0x1) || ((portcount != 0) &&
+				(portcount != 4) && (portcount != 8))) {
+			dev_dbg(&pdev->dev, "base+0x2=0x%lx, base+0xe=0x%lx\n",
+				inw(base + 0x2), inw(base + 0xe));
+			dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure "
+				"(Possible bad I/O Port Address 0x%lx).\n",
+				card + 1, base);
+			retval = -EIO;
+			goto end;
+		}
@@ -1917,6 +1682,183 @@
-	if (!register_isr()) 
-	{
-		unregister_drivers();
-		/*  ioports already uregistered in register_isr */
-		free_page((unsigned long)tmp_buf);
-		return 0;		
+
+	switch (*signature) {
+	case 0xa5:
+	case 0xbb:
+	case 0xdd:
+		board->port_count = (board->isa == NO && portcount == 4) ? 4 :
+			8;
+		board->shift_count = 12;
+		break;
+	case 0xcc:
+		board->port_count = 16;
+		board->shift_count = 11;
+		break;
+	default:
+		dev_warn(&pdev->dev, "ISILoad:Card%d reset failure (Possible "
+			"bad I/O Port Address 0x%lx).\n", card + 1, base);
+		dev_dbg(&pdev->dev, "Sig=0x%lx\n", signature);
+		retval = -EIO;
+	}
+	dev_info(&pdev->dev, "-Done\n");
+
+end:
+	return retval;
+}
+
+static inline int WaitTillCardIsFree(u16 base)
+{
+	unsigned long count = 0;
+
+	while (!(inw(base + 0xe) & 0x1) && count++ < 100)
+		msleep(5);
+
+	return !(inw(base + 0xe) & 0x1);
+}
+
+static int __devinit load_firmware(struct pci_dev *pdev,
+	const unsigned int index, const unsigned int signature)
+{
+	struct isi_board *board = pci_get_drvdata(pdev);
+	const struct firmware *fw;
+	unsigned long base = board->base;
+	unsigned int a;
+	u16 word_count, status;
+	int retval = -EIO;
+	char *name;
+	u8 *data;
+
+	struct stframe {
+		u16	addr;
+		u16	count;
+		u8	data[0];
+	} *frame;
+
+	switch (signature) {
+	case 0xa5:
+		name = "isi608.bin";
+		break;
+	case 0xbb:
+		name = "isi608em.bin";
+		break;
+	case 0xcc:
+		name = "isi616em.bin";
+		break;
+	case 0xdd:
+		name = "isi4608.bin";
+		break;
+	case 0xee:
+		name = "isi4616.bin";
+		break;
+	default:
+		dev_err(&pdev->dev, "Unknown signature.\n");
+		goto end;
+ 	}
+
+	retval = request_firmware(&fw, name, &pdev->dev);
+	if (retval)
+		goto end;
+
+	for (frame = (struct stframe *)fw->data;
+			frame < (struct stframe *)(fw->data + fw->size);
+			frame++) {
+		if (WaitTillCardIsFree(base))
+			goto errrelfw;
+
+		outw(0xf0, base);	/* start upload sequence */
+		outw(0x00, base);
+		outw(frame->addr, base); /* lsb of address */
+
+		word_count = frame->count / 2 + frame->count % 2;
+		outw(word_count, base);
+		InterruptTheCard(base);
+
+		udelay(100); /* 0x2f */
+
+		if (WaitTillCardIsFree(base))
+			goto errrelfw;
+
+		if ((status = inw(base + 0x4)) != 0) {
+			dev_warn(&pdev->dev, "Card%d rejected load header:\n"
+				"Address:0x%x\nCount:0x%x\nStatus:0x%x\n",
+				index + 1, frame->addr, frame->count, status);
+			goto errrelfw;
+		}
+		outsw(base, frame->data, word_count);
+
+		InterruptTheCard(base);
+
+		udelay(50); /* 0x0f */
+
+		if (WaitTillCardIsFree(base))
+			goto errrelfw;
+
+		if ((status = inw(base + 0x4)) != 0) {
+			dev_err(&pdev->dev, "Card%d got out of sync.Card "
+				"Status:0x%x\n", index + 1, status);
+			goto errrelfw;
+		}
+ 	}
+
+	retval = -EIO;
+
+	if (WaitTillCardIsFree(base))
+		goto errrelfw;
+
+	outw(0xf2, base);
+	outw(0x800, base);
+	outw(0x0, base);
+	outw(0x0, base);
+	InterruptTheCard(base);
+	outw(0x0, base + 0x4); /* for ISI4608 cards */
+
+/* XXX: should we test it by reading it back and comparing with original like
+ * in load firmware package? */
+	for (frame = (struct stframe*)fw->data;
+			frame < (struct stframe*)(fw->data + fw->size);
+			frame++) {
+		if (WaitTillCardIsFree(base))
+			goto errrelfw;
+
+		outw(0xf1, base); /* start download sequence */
+		outw(0x00, base);
+		outw(frame->addr, base); /* lsb of address */
+
+		word_count = (frame->count >> 1) + frame->count % 2;
+		outw(word_count + 1, base);
+		InterruptTheCard(base);
+
+		udelay(50); /* 0xf */
+
+		if (WaitTillCardIsFree(base))
+			goto errrelfw;
+
+		if ((status = inw(base + 0x4)) != 0) {
+			dev_warn(&pdev->dev, "Card%d rejected verify header:\n"
+				"Address:0x%x\nCount:0x%x\nStatus: 0x%x\n",
+				index + 1, frame->addr, frame->count, status);
+			goto errrelfw;
+		}
+
+		data = kmalloc(word_count * 2, GFP_KERNEL);
+		inw(base);
+		insw(base, data, word_count);
+		InterruptTheCard(base);
+
+		for (a = 0; a < frame->count; a++)
+			if (data[a] != frame->data[a]) {
+				kfree(data);
+				dev_err(&pdev->dev, "Card%d, firmware upload "
+					"failed\n", index + 1);
+				goto errrelfw;
+			}
+		kfree(data);
+
+		udelay(50); /* 0xf */
+
+		if (WaitTillCardIsFree(base))
+			goto errrelfw;
+
+		if ((status = inw(base + 0x4)) != 0) {
+			dev_err(&pdev->dev, "Card%d verify got out of sync. "
+				"Card Status:0x%x\n", index + 1, status);
+			goto errrelfw;
+		}
@@ -1924,23 +1866,8 @@
-	
-	memset(isi_ports, 0, sizeof(isi_ports));
-	for (card = 0; card < BOARD_COUNT; card++) {
-		port = &isi_ports[card * 16];
-		isi_card[card].ports = port;
-		spin_lock_init(&isi_card[card].card_lock);
-		base = isi_card[card].base;
-		for (channel = 0; channel < 16; channel++, port++) {
-			port->magic = ISICOM_MAGIC;
-			port->card = &isi_card[card];
-			port->channel = channel;
-		 	port->close_delay = 50 * HZ/100;
-		 	port->closing_wait = 3000 * HZ/100;
-		 	INIT_WORK(&port->hangup_tq, do_isicom_hangup, port);
-		 	INIT_WORK(&port->bh_tqueue, isicom_bottomhalf, port);
-		 	port->status = 0;
-			init_waitqueue_head(&port->open_wait);	 				
-			init_waitqueue_head(&port->close_wait);
-			/*  . . .  */
- 		}
-	} 
-	
-	return 1;	
+
+	board->status |= FIRMWARE_LOADED;
+	retval = 0;
+
+errrelfw:
+	release_firmware(fw);
+end:
+	return retval;
@@ -1952 +1878,0 @@
- 
@@ -1954,0 +1881 @@
+static int card;
@@ -1956,7 +1883,64 @@
-MODULE_AUTHOR("MultiTech");
-MODULE_DESCRIPTION("Driver for the ISI series of cards by MultiTech");
-MODULE_LICENSE("GPL");
-module_param_array(io, int, NULL, 0);
-MODULE_PARM_DESC(io, "I/O ports for the cards");
-module_param_array(irq, int, NULL, 0);
-MODULE_PARM_DESC(irq, "Interrupts for the cards");
+static int __devinit isicom_probe(struct pci_dev *pdev,
+	const struct pci_device_id *ent)
+{
+	unsigned int ioaddr, signature, index;
+	int retval = -EPERM;
+	u8 pciirq;
+	struct isi_board *board = NULL;
+
+	if (card >= BOARD_COUNT)
+		goto err;
+
+	ioaddr = pci_resource_start(pdev, 3);
+	/* i.e at offset 0x1c in the PCI configuration register space. */
+	pciirq = pdev->irq;
+	dev_info(&pdev->dev, "ISI PCI Card(Device ID 0x%x)\n", ent->device);
+
+	/* allot the first empty slot in the array */
+	for (index = 0; index < BOARD_COUNT; index++)
+		if (isi_card[index].base == 0) {
+			board = &isi_card[index];
+			break;
+		}
+
+	board->base = ioaddr;
+	board->irq = pciirq;
+	board->isa = NO;
+	card++;
+
+	pci_set_drvdata(pdev, board);
+
+	retval = isicom_register_ioregion(pdev, index);
+	if (retval < 0)
+		goto err;
+
+	retval = isicom_register_isr(pdev, index);
+	if (retval < 0)
+		goto errunrr;
+
+	retval = reset_card(pdev, index, &signature);
+	if (retval < 0)
+		goto errunri;
+
+	retval = load_firmware(pdev, index, signature);
+	if (retval < 0)
+		goto errunri;
+
+	return 0;
+
+errunri:
+	free_irq(board->irq, board);
+errunrr:
+	isicom_unregister_ioregion(pdev);
+err:
+	board->base = 0;
+	return retval;
+}
+
+static void __devexit isicom_remove(struct pci_dev *pdev)
+{
+	struct isi_board *board = pci_get_drvdata(pdev);
+
+	free_irq(board->irq, board);
+	isicom_unregister_ioregion(pdev);
+}
@@ -1966,5 +1950,3 @@
-	struct pci_dev *dev = NULL;
-	int retval, card, idx, count;
-	unsigned char pciirq;
-	unsigned int ioaddr;
-	                
+	int retval, idx, channel;
+	struct isi_port *port;
+
@@ -1972,40 +1954 @@
-	for(idx=0; idx < BOARD_COUNT; idx++) {	
-		if (io[idx]) {
-			isi_card[idx].base=io[idx];
-			isi_card[idx].irq=irq[idx];
-			isi_card[idx].isa=YES;
-			card++;
-		}
-		else {
-			isi_card[idx].base = 0;
-			isi_card[idx].irq = 0;
-		}
-	}
-	
-	for (idx=0 ;idx < card; idx++) {
-		if (!((isi_card[idx].irq==2)||(isi_card[idx].irq==3)||
-		    (isi_card[idx].irq==4)||(isi_card[idx].irq==5)||
-		    (isi_card[idx].irq==7)||(isi_card[idx].irq==10)||
-		    (isi_card[idx].irq==11)||(isi_card[idx].irq==12)||
-		    (isi_card[idx].irq==15))) {
-			
-			if (isi_card[idx].base) {
-				printk(KERN_ERR "ISICOM: Irq %d unsupported. Disabling Card%d...\n",
-					isi_card[idx].irq, idx+1);
-				isi_card[idx].base=0;
-				card--;
-			}	
-		}
-	}	
-	
-	if (card < BOARD_COUNT) {
-		for (idx=0; idx < DEVID_COUNT; idx++) {
-			dev = NULL;
-			for (;;){
-				if (!(dev = pci_find_device(VENDOR_ID, isicom_pci_tbl[idx].device, dev)))
-					break;
-				if (card >= BOARD_COUNT)
-					break;
-					
-				if (pci_enable_device(dev))
-					break;
+	memset(isi_ports, 0, sizeof(isi_ports));
@@ -2013,28 +1956,19 @@
-				/* found a PCI ISI card! */
-				ioaddr = pci_resource_start (dev, 3); /* i.e at offset 0x1c in the
-								       * PCI configuration register
-								       * space.
-								       */
-				pciirq = dev->irq;
-				printk(KERN_INFO "ISI PCI Card(Device ID 0x%x)\n", isicom_pci_tbl[idx].device);
-				/*
-				 * allot the first empty slot in the array
-				 */				
-				for (count=0; count < BOARD_COUNT; count++) {				
-					if (isi_card[count].base == 0) {
-						isi_card[count].base = ioaddr;
-						isi_card[count].irq = pciirq;
-						isi_card[count].isa = NO;
-						card++;
-						break;
-					}
-				}
-			}				
-			if (card >= BOARD_COUNT) break;
-		}
-	}
-	
-	if (!(isi_card[0].base || isi_card[1].base || isi_card[2].base || isi_card[3].base)) {
-		printk(KERN_ERR "ISICOM: No valid card configuration. Driver cannot be initialized...\n"); 
-		return -EIO;
-	}	
+	for(idx = 0; idx < BOARD_COUNT; idx++) {
+		port = &isi_ports[idx * 16];
+		isi_card[idx].ports = port;
+		spin_lock_init(&isi_card[idx].card_lock);
+		for (channel = 0; channel < 16; channel++, port++) {
+			port->magic = ISICOM_MAGIC;
+			port->card = &isi_card[idx];
+			port->channel = channel;
+			port->close_delay = 50 * HZ/100;
+			port->closing_wait = 3000 * HZ/100;
+			INIT_WORK(&port->hangup_tq, do_isicom_hangup, port);
+			INIT_WORK(&port->bh_tqueue, isicom_bottomhalf, port);
+			port->status = 0;
+			init_waitqueue_head(&port->open_wait);
+			init_waitqueue_head(&port->close_wait);
+			/*  . . .  */
+ 		}
+		isi_card[idx].base = 0;
+		isi_card[idx].irq = 0;
@@ -2042 +1976,20 @@
-	retval = misc_register(&isiloader_device);
+		if (!io[idx])
+			continue;
+
+		if (irq[idx] == 2 || irq[idx] == 3 || irq[idx] == 4	||
+				irq[idx] == 5	|| irq[idx] == 7	||
+				irq[idx] == 10	|| irq[idx] == 11	||
+				irq[idx] == 12	|| irq[idx] == 15) {
+			printk(KERN_ERR "ISICOM: ISA not supported yet.\n");
+			retval = -EINVAL;
+			goto error;
+		} else
+			printk(KERN_ERR "ISICOM: Irq %d unsupported. "
+				"Disabling Card%d...\n", irq[idx], idx + 1);
+	}
+
+	retval = isicom_register_tty_driver();
+	if (retval < 0)
+		goto error;
+
+	retval = pci_register_driver(&isicom_driver);
@@ -2044,8 +1997,2 @@
-		printk(KERN_ERR "ISICOM: Unable to register firmware loader driver.\n");
-		return retval;
-	}
-	
-	if (!isicom_init()) {
-		if (misc_deregister(&isiloader_device)) 
-			printk(KERN_ERR "ISICOM: Unable to unregister Firmware Loader driver\n");
-		return -EIO;
+		printk(KERN_ERR "ISICOM: Unable to register pci driver.\n");
+		goto errtty;
@@ -2053 +2000 @@
-	
+
@@ -2060 +2007 @@
-	
+
@@ -2061,0 +2009,4 @@
+errtty:
+	isicom_unregister_tty_driver();
+error:
+	return retval;
@@ -2065,0 +2017,2 @@
+	unsigned int index = 0;
+
@@ -2067,9 +2020,6 @@
-	/* FIXME */
-	msleep(1000);
-	unregister_isr();
-	unregister_drivers();
-	unregister_ioregion();	
-	if(tmp_buf)
-		free_page((unsigned long)tmp_buf);
-	if (misc_deregister(&isiloader_device))
-		printk(KERN_ERR "ISICOM: Unable to unregister Firmware Loader driver\n");
+
+	while (re_schedule != 2 && index++ < 100)
+		msleep(10);
+
+	pci_unregister_driver(&isicom_driver);
+	isicom_unregister_tty_driver();
@@ -2079,0 +2030,8 @@
+
+MODULE_AUTHOR("MultiTech");
+MODULE_DESCRIPTION("Driver for the ISI series of cards by MultiTech");
+MODULE_LICENSE("GPL");
+module_param_array(io, int, NULL, 0);
+MODULE_PARM_DESC(io, "I/O ports for the cards");
+module_param_array(irq, int, NULL, 0);
+MODULE_PARM_DESC(irq, "Interrupts for the cards");
--- ./projects/linux/linux-2.6.17/drivers/char/isicom.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/char/isicom.c	2006-09-20 05:42:06.000000000 +0200
@@ -248 +248 @@
-	return 0;	/* Failed to aquire the card! */
+	return 0;	/* Failed to acquire the card! */
@@ -265 +265 @@
-	return 0;	/* Failed to aquire the card! */
+	return 0;	/* Failed to acquire the card! */
@@ -1148 +1148 @@
-	if (!tty || !port->xmit_buf)
+	if (!port->xmit_buf)
@@ -1183 +1183 @@
-	if (!tty || !port->xmit_buf)
+	if (!port->xmit_buf)
@@ -1584 +1583,0 @@
-	isicom_normal->devfs_name	 	= "isicom/";
@@ -1618 +1617 @@
-	unsigned long irqflags = SA_INTERRUPT;
+	unsigned long irqflags = IRQF_DISABLED;
@@ -1625 +1624 @@
-		irqflags |= SA_SHIRQ;
+		irqflags |= IRQF_SHARED;
--- ./projects/linux/linux-2.6.18/drivers/char/isicom.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/char/isicom.c	2006-11-29 22:57:37.000000000 +0100
@@ -549 +549 @@
-static irqreturn_t isicom_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t isicom_interrupt(int irq, void *dev_id)
@@ -1065 +1065 @@
-	struct isi_board *card = port->card;
+	struct isi_board *card;
@@ -1069,0 +1070 @@
+	card = port->card;
@@ -1553 +1554 @@
-static struct tty_operations isicom_ops = {
+static const struct tty_operations isicom_ops = {
@@ -1758,0 +1760,2 @@
+	retval = -EIO;
+
@@ -1761 +1764,2 @@
-			frame++) {
+			frame = (struct stframe *)((u8 *)(frame + 1) +
+				frame->count)) {
@@ -1800,12 +1803,0 @@
-	retval = -EIO;
-
-	if (WaitTillCardIsFree(base))
-		goto errrelfw;
-
-	outw(0xf2, base);
-	outw(0x800, base);
-	outw(0x0, base);
-	outw(0x0, base);
-	InterruptTheCard(base);
-	outw(0x0, base + 0x4); /* for ISI4608 cards */
-
@@ -1814,3 +1806,4 @@
-	for (frame = (struct stframe*)fw->data;
-			frame < (struct stframe*)(fw->data + fw->size);
-			frame++) {
+	for (frame = (struct stframe *)fw->data;
+			frame < (struct stframe *)(fw->data + fw->size);
+			frame = (struct stframe *)((u8 *)(frame + 1) +
+				frame->count)) {
@@ -1865,0 +1859,11 @@
+	/* xfer ctrl */
+	if (WaitTillCardIsFree(base))
+		goto errrelfw;
+
+	outw(0xf2, base);
+	outw(0x800, base);
+	outw(0x0, base);
+	outw(0x0, base);
+	InterruptTheCard(base);
+	outw(0x0, base + 0x4); /* for ISI4608 cards */
+
--- ./projects/linux/linux-2.6.19/drivers/char/isicom.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/char/isicom.c	2007-02-04 19:44:54.000000000 +0100
@@ -175 +175 @@
-static struct timer_list tx;
+static DECLARE_COMPLETION(isi_timerdone);
@@ -180,0 +181,2 @@
+static DEFINE_TIMER(tx, isicom_tx, 0, 0);
+
@@ -196 +197,0 @@
-	unsigned char		isa;
@@ -198,0 +200 @@
+	unsigned int		index;
@@ -230,0 +233,14 @@
+static inline int WaitTillCardIsFree(u16 base)
+{
+	unsigned int count = 0;
+	unsigned int a = in_atomic(); /* do we run under spinlock? */
+
+	while (!(inw(base + 0xe) & 0x1) && count++ < 100)
+		if (a)
+			mdelay(1);
+		else
+			msleep(1);
+
+	return !(inw(base + 0xe) & 0x1);
+}
+
@@ -276,0 +293 @@
+/* card->lock HAS to be held */
@@ -283 +300 @@
-	if (!lock_card(card))
+	if (WaitTillCardIsFree(base))
@@ -290 +306,0 @@
-	unlock_card(card);
@@ -292,0 +309 @@
+/* card->lock HAS to be held */
@@ -299 +316 @@
-	if (!lock_card(card))
+	if (WaitTillCardIsFree(base))
@@ -306 +322,0 @@
-	unlock_card(card);
@@ -308,0 +325 @@
+/* card->lock HAS to be held */
@@ -315 +332 @@
-	if (!lock_card(card))
+	if (WaitTillCardIsFree(base))
@@ -322 +338,0 @@
-	unlock_card(card);
@@ -323,0 +340,2 @@
+
+/* card->lock HAS to be held */
@@ -330 +348 @@
-	if (!lock_card(card))
+	if (WaitTillCardIsFree(base))
@@ -337 +354,0 @@
-	unlock_card(card);
@@ -339,0 +357 @@
+/* card->lock MUST NOT be held */
@@ -355,0 +374 @@
+/* card->lock HAS to be held */
@@ -362 +381 @@
-	if (!lock_card(card))
+	if (WaitTillCardIsFree(base))
@@ -369,16 +387,0 @@
-	unlock_card(card);
-}
-
-static inline void kill_queue(struct isi_port *port, short queue)
-{
-	struct isi_board *card = port->card;
-	unsigned long base = card->base;
-	u16 channel = port->channel;
-
-	if (!lock_card(card))
-		return;
-
-	outw(0x8000 | (channel << card->shift_count) | 0x02, base);
-	outw((queue << 8) | 0x06, base);
-	InterruptTheCard(base);
-	unlock_card(card);
@@ -517 +520 @@
-		re_schedule = 2;
+		complete(&isi_timerdone);
@@ -521,7 +524 @@
-	init_timer(&tx);
-	tx.expires = jiffies + HZ/100;
-	tx.data = 0;
-	tx.function = isicom_tx;
-	add_timer(&tx);
-
-	return;
+	mod_timer(&tx, jiffies + msecs_to_jiffies(10));
@@ -533 +530 @@
-static void isicom_bottomhalf(void *data)
+static void isicom_bottomhalf(struct work_struct *work)
@@ -535 +532 @@
-	struct isi_port *port = (struct isi_port *) data;
+	struct isi_port *port = container_of(work, struct isi_port, bh_tqueue);
@@ -565,8 +562,6 @@
-	if (card->isa == NO) {
-		/*
-		 * disable any interrupts from the PCI card and lower the
-		 * interrupt line
-		 */
-		outw(0x8000, base+0x04);
-		ClearInterrupt(base);
-	}
+	/*
+	 * disable any interrupts from the PCI card and lower the
+	 * interrupt line
+	 */
+	outw(0x8000, base+0x04);
+	ClearInterrupt(base);
@@ -582,4 +577 @@
-		if (card->isa)
-			ClearInterrupt(base);
-		else
-			outw(0x0000, base+0x04); /* enable interrupts */
+		outw(0x0000, base+0x04); /* enable interrupts */
@@ -591,4 +583 @@
-		if (card->isa)
-			ClearInterrupt(base);
-		else
-			outw(0x0000, base+0x04); /* enable interrupts */
+		outw(0x0000, base+0x04); /* enable interrupts */
@@ -607,4 +596 @@
-		if (card->isa == YES)
-			ClearInterrupt(base);
-		else
-			outw(0x0000, base+0x04); /* enable interrupts */
+		outw(0x0000, base+0x04); /* enable interrupts */
@@ -711,4 +697 @@
-	if (card->isa == YES)
-		ClearInterrupt(base);
-	else
-		outw(0x0000, base+0x04); /* enable interrupts */
+	outw(0x0000, base+0x04); /* enable interrupts */
@@ -765 +748 @@
-	if (lock_card(card)) {
+	if (WaitTillCardIsFree(base) == 0) {
@@ -793 +775,0 @@
-		unlock_card(card);
@@ -812 +794 @@
-	if (lock_card(card)) {
+	if (WaitTillCardIsFree(base) == 0) {
@@ -817 +798,0 @@
-		unlock_card(card);
@@ -842 +822,0 @@
-	spin_unlock_irqrestore(&bp->card_lock, flags);
@@ -845 +825 @@
-	return;
+	spin_unlock_irqrestore(&bp->card_lock, flags);
@@ -878 +858,6 @@
-	kill_queue(port, ISICOM_KILLTX | ISICOM_KILLRX);
+	if (WaitTillCardIsFree(card->base) == 0) {
+		outw(0x8000 | (port->channel << card->shift_count) | 0x02,
+				card->base);
+		outw(((ISICOM_KILLTX | ISICOM_KILLRX) << 8) | 0x06, card->base);
+		InterruptTheCard(card->base);
+	}
@@ -967,2 +952,2 @@
-	unsigned int line, board;
-	int error;
+	unsigned int board;
+	int error, line;
@@ -1004,3 +988,0 @@
-	unsigned long flags;
-
-	spin_lock_irqsave(&bp->card_lock, flags);
@@ -1010 +991,0 @@
-	spin_unlock_irqrestore(&bp->card_lock, flags);
@@ -1012,0 +994 @@
+/* card->lock HAS to be held */
@@ -1017 +998,0 @@
-	unsigned long flags;
@@ -1021,3 +1002 @@
-	spin_lock_irqsave(&card->card_lock, flags);
-	if (!(port->flags & ASYNC_INITIALIZED)) {
-		spin_unlock_irqrestore(&card->card_lock, flags);
+	if (!(port->flags & ASYNC_INITIALIZED))
@@ -1025 +1004 @@
-	}
+
@@ -1033 +1011,0 @@
-	spin_unlock_irqrestore(&card->card_lock, flags);
@@ -1278,0 +1257 @@
+	unsigned long flags;
@@ -1282,0 +1262 @@
+	spin_lock_irqsave(&port->card->card_lock, flags);
@@ -1291,0 +1272 @@
+	spin_unlock_irqrestore(&port->card->card_lock, flags);
@@ -1323,0 +1305,2 @@
+		unsigned long flags;
+		spin_lock_irqsave(&port->card->card_lock, flags);
@@ -1324,0 +1308 @@
+		spin_unlock_irqrestore(&port->card->card_lock, flags);
@@ -1402 +1386 @@
-	struct termios *old_termios)
+	struct ktermios *old_termios)
@@ -1404,0 +1389 @@
+	unsigned long flags;
@@ -1412,0 +1398 @@
+	spin_lock_irqsave(&port->card->card_lock, flags);
@@ -1413,0 +1400 @@
+	spin_unlock_irqrestore(&port->card->card_lock, flags);
@@ -1477 +1464 @@
-static void do_isicom_hangup(void *data)
+static void do_isicom_hangup(struct work_struct *work)
@@ -1479 +1466 @@
-	struct isi_port *port = data;
+	struct isi_port *port = container_of(work, struct isi_port, hangup_tq);
@@ -1489,0 +1477 @@
+	unsigned long flags;
@@ -1493,0 +1482 @@
+	spin_lock_irqsave(&port->card->card_lock, flags);
@@ -1494,0 +1484,2 @@
+	spin_unlock_irqrestore(&port->card->card_lock, flags);
+
@@ -1523,31 +1513,0 @@
-static int __devinit isicom_register_ioregion(struct pci_dev *pdev,
-	const unsigned int index)
-{
-	struct isi_board *board = pci_get_drvdata(pdev);
-
-	if (!board->base)
-		return -EINVAL;
-
-	if (!request_region(board->base, 16, ISICOM_NAME)) {
-		dev_dbg(&pdev->dev, "I/O Region 0x%lx-0x%lx is busy. Card%d "
-			"will be disabled.\n", board->base, board->base + 15,
-			index + 1);
-		return -EBUSY;
- 	}
-
-	return 0;
-}
-
-static void isicom_unregister_ioregion(struct pci_dev *pdev)
-{
-	struct isi_board *board = pci_get_drvdata(pdev);
-
-	if (!board->base)
-		return;
-
-	release_region(board->base, 16);
-	dev_dbg(&pdev->dev, "I/O Region 0x%lx-0x%lx released.\n",
-		board->base, board->base + 15);
-	board->base = 0;
-}
-
@@ -1574,64 +1533,0 @@
-static int __devinit isicom_register_tty_driver(void)
-{
-	int error = -ENOMEM;
-
-	/* tty driver structure initialization */
-	isicom_normal = alloc_tty_driver(PORT_COUNT);
-	if (!isicom_normal)
-		goto end;
-
-	isicom_normal->owner			= THIS_MODULE;
-	isicom_normal->name 			= "ttyM";
-	isicom_normal->major			= ISICOM_NMAJOR;
-	isicom_normal->minor_start		= 0;
-	isicom_normal->type			= TTY_DRIVER_TYPE_SERIAL;
-	isicom_normal->subtype			= SERIAL_TYPE_NORMAL;
-	isicom_normal->init_termios		= tty_std_termios;
-	isicom_normal->init_termios.c_cflag	= B9600 | CS8 | CREAD | HUPCL |
-		CLOCAL;
-	isicom_normal->flags			= TTY_DRIVER_REAL_RAW;
-	tty_set_operations(isicom_normal, &isicom_ops);
-
-	if ((error = tty_register_driver(isicom_normal))) {
-		pr_dbg("Couldn't register the dialin driver, error=%d\n",
-			error);
-		put_tty_driver(isicom_normal);
-	}
-end:
-	return error;
-}
-
-static void isicom_unregister_tty_driver(void)
-{
-	int error;
-
-	if ((error = tty_unregister_driver(isicom_normal)))
-		pr_dbg("couldn't unregister normal driver, error=%d.\n", error);
-
-	put_tty_driver(isicom_normal);
-}
-
-static int __devinit isicom_register_isr(struct pci_dev *pdev,
-	const unsigned int index)
-{
-	struct isi_board *board = pci_get_drvdata(pdev);
-	unsigned long irqflags = IRQF_DISABLED;
-	int retval = -EINVAL;
-
-	if (!board->base)
-		goto end;
-
-	if (board->isa == NO)
-		irqflags |= IRQF_SHARED;
-
-	retval = request_irq(board->irq, isicom_interrupt, irqflags,
-		ISICOM_NAME, board);
-	if (retval < 0)
-		dev_warn(&pdev->dev, "Could not install handler at Irq %d. "
-			"Card%d will be disabled.\n", board->irq, index + 1);
- 	else
-		retval = 0;
-end:
-	return retval;
-}
-
@@ -1659,22 +1555,10 @@
-	if (board->isa == YES) {
-		if (!(inw(base + 0xe) & 0x1) || (inw(base + 0x2))) {
-			dev_dbg(&pdev->dev, "base+0x2=0x%lx, base+0xe=0x%lx\n",
-				inw(base + 0x2), inw(base + 0xe));
-			dev_err(&pdev->dev, "ISILoad:ISA Card%d reset failure "
-				"(Possible bad I/O Port Address 0x%lx).\n",
-				card + 1, base);
-			retval = -EIO;
-			goto end;
-		}
-	} else {
-		portcount = inw(base + 0x2);
-		if (!(inw(base + 0xe) & 0x1) || ((portcount != 0) &&
-				(portcount != 4) && (portcount != 8))) {
-			dev_dbg(&pdev->dev, "base+0x2=0x%lx, base+0xe=0x%lx\n",
-				inw(base + 0x2), inw(base + 0xe));
-			dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure "
-				"(Possible bad I/O Port Address 0x%lx).\n",
-				card + 1, base);
-			retval = -EIO;
-			goto end;
-		}
+	portcount = inw(base + 0x2);
+	if (!(inw(base + 0xe) & 0x1) || ((portcount != 0) &&
+			(portcount != 4) && (portcount != 8))) {
+		dev_dbg(&pdev->dev, "base+0x2=0x%lx, base+0xe=0x%lx\n",
+			inw(base + 0x2), inw(base + 0xe));
+		dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure "
+			"(Possible bad I/O Port Address 0x%lx).\n",
+			card + 1, base);
+		retval = -EIO;
+		goto end;
@@ -1687,2 +1571 @@
-		board->port_count = (board->isa == NO && portcount == 4) ? 4 :
-			8;
+		board->port_count = (portcount == 4) ? 4 : 8;
@@ -1707,10 +1589,0 @@
-static inline int WaitTillCardIsFree(u16 base)
-{
-	unsigned long count = 0;
-
-	while (!(inw(base + 0xe) & 0x1) && count++ < 100)
-		msleep(5);
-
-	return !(inw(base + 0xe) & 0x1);
-}
-
@@ -1833,0 +1707,5 @@
+		if (data == NULL) {
+			dev_err(&pdev->dev, "Card%d, firmware upload "
+				"failed, not enough memory\n", index + 1);
+			goto errrelfw;
+		}
@@ -1882,2 +1759,0 @@
-static int io[4];
-static int irq[4];
@@ -1908,0 +1785 @@
+	board->index = index;
@@ -1911 +1787,0 @@
-	board->isa = NO;
@@ -1916,2 +1792,6 @@
-	retval = isicom_register_ioregion(pdev, index);
-	if (retval < 0)
+	retval = pci_request_region(pdev, 3, ISICOM_NAME);
+	if (retval) {
+		dev_err(&pdev->dev, "I/O Region 0x%lx-0x%lx is busy. Card%d "
+			"will be disabled.\n", board->base, board->base + 15,
+			index + 1);
+		retval = -EBUSY;
@@ -1918,0 +1799 @@
+ 	}
@@ -1920,2 +1801,5 @@
-	retval = isicom_register_isr(pdev, index);
-	if (retval < 0)
+	retval = request_irq(board->irq, isicom_interrupt,
+			IRQF_SHARED | IRQF_DISABLED, ISICOM_NAME, board);
+	if (retval < 0) {
+		dev_err(&pdev->dev, "Could not install handler at Irq %d. "
+			"Card%d will be disabled.\n", board->irq, index + 1);
@@ -1922,0 +1807 @@
+	}
@@ -1931,0 +1817,4 @@
+	for (index = 0; index < board->port_count; index++)
+		tty_register_device(isicom_normal, board->index * 16 + index,
+				&pdev->dev);
+
@@ -1937 +1826 @@
-	isicom_unregister_ioregion(pdev);
+	pci_release_region(pdev, 3);
@@ -1945,0 +1835,4 @@
+	unsigned int i;
+
+	for (i = 0; i < board->port_count; i++)
+		tty_unregister_device(isicom_normal, board->index * 16 + i);
@@ -1948 +1841 @@
-	isicom_unregister_ioregion(pdev);
+	pci_release_region(pdev, 3);
@@ -1951 +1844 @@
-static int __devinit isicom_setup(void)
+static int __init isicom_init(void)
@@ -1957 +1849,0 @@
-	memset(isi_ports, 0, sizeof(isi_ports));
@@ -1969,2 +1861,2 @@
-			INIT_WORK(&port->hangup_tq, do_isicom_hangup, port);
-			INIT_WORK(&port->bh_tqueue, isicom_bottomhalf, port);
+			INIT_WORK(&port->hangup_tq, do_isicom_hangup);
+			INIT_WORK(&port->bh_tqueue, isicom_bottomhalf);
@@ -1978,14 +1869,0 @@
-
-		if (!io[idx])
-			continue;
-
-		if (irq[idx] == 2 || irq[idx] == 3 || irq[idx] == 4	||
-				irq[idx] == 5	|| irq[idx] == 7	||
-				irq[idx] == 10	|| irq[idx] == 11	||
-				irq[idx] == 12	|| irq[idx] == 15) {
-			printk(KERN_ERR "ISICOM: ISA not supported yet.\n");
-			retval = -EINVAL;
-			goto error;
-		} else
-			printk(KERN_ERR "ISICOM: Irq %d unsupported. "
-				"Disabling Card%d...\n", irq[idx], idx + 1);
@@ -1994,2 +1872,4 @@
-	retval = isicom_register_tty_driver();
-	if (retval < 0)
+	/* tty driver structure initialization */
+	isicom_normal = alloc_tty_driver(PORT_COUNT);
+	if (!isicom_normal) {
+		retval = -ENOMEM;
@@ -1996,0 +1877,20 @@
+	}
+
+	isicom_normal->owner			= THIS_MODULE;
+	isicom_normal->name 			= "ttyM";
+	isicom_normal->major			= ISICOM_NMAJOR;
+	isicom_normal->minor_start		= 0;
+	isicom_normal->type			= TTY_DRIVER_TYPE_SERIAL;
+	isicom_normal->subtype			= SERIAL_TYPE_NORMAL;
+	isicom_normal->init_termios		= tty_std_termios;
+	isicom_normal->init_termios.c_cflag	= B9600 | CS8 | CREAD | HUPCL |
+		CLOCAL;
+	isicom_normal->flags			= TTY_DRIVER_REAL_RAW |
+		TTY_DRIVER_DYNAMIC_DEV;
+	tty_set_operations(isicom_normal, &isicom_ops);
+
+	retval = tty_register_driver(isicom_normal);
+	if (retval) {
+		pr_dbg("Couldn't register the dialin driver\n");
+		goto err_puttty;
+	}
@@ -2001 +1901 @@
-		goto errtty;
+		goto err_unrtty;
@@ -2004,6 +1904 @@
-	init_timer(&tx);
-	tx.expires = jiffies + 1;
-	tx.data = 0;
-	tx.function = isicom_tx;
-	re_schedule = 1;
-	add_timer(&tx);
+	mod_timer(&tx, jiffies + 1);
@@ -2012,2 +1907,4 @@
-errtty:
-	isicom_unregister_tty_driver();
+err_unrtty:
+	tty_unregister_driver(isicom_normal);
+err_puttty:
+	put_tty_driver(isicom_normal);
@@ -2020,2 +1916,0 @@
-	unsigned int index = 0;
-
@@ -2024,2 +1919 @@
-	while (re_schedule != 2 && index++ < 100)
-		msleep(10);
+	wait_for_completion_timeout(&isi_timerdone, HZ);
@@ -2028 +1922,2 @@
-	isicom_unregister_tty_driver();
+	tty_unregister_driver(isicom_normal);
+	put_tty_driver(isicom_normal);
@@ -2031 +1926 @@
-module_init(isicom_setup);
+module_init(isicom_init);
@@ -2037,4 +1931,0 @@
-module_param_array(io, int, NULL, 0);
-MODULE_PARM_DESC(io, "I/O ports for the cards");
-module_param_array(irq, int, NULL, 0);
-MODULE_PARM_DESC(irq, "Interrupts for the cards");
--- ./projects/linux/linux-2.6.20/drivers/char/isicom.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/char/isicom.c	2007-04-26 05:08:32.000000000 +0200
@@ -186 +186 @@
-	-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 16, 17, 18, 19
+	-1, 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 11, 13, 15, 16, 17, 18, 19, 20, 21
@@ -216,2 +215,0 @@
-	struct work_struct	hangup_tq;
-	struct work_struct	bh_tqueue;
@@ -513 +511 @@
-			schedule_work(&port->bh_tqueue);
+			tty_wakeup(tty);
@@ -527,15 +524,0 @@
-/* 	Interrupt handlers 	*/
-
-
-static void isicom_bottomhalf(struct work_struct *work)
-{
-	struct isi_port *port = container_of(work, struct isi_port, bh_tqueue);
-	struct tty_struct *tty = port->tty;
-
-	if (!tty)
-		return;
-
-	tty_wakeup(tty);
-	wake_up_interruptible(&tty->write_wait);
-}
-
@@ -559,0 +543,5 @@
+
+	/* did the card interrupt us? */
+	if (!(inw(base + 0x0e) & 0x02))
+		return IRQ_NONE;
+
@@ -583,0 +572 @@
+		spin_unlock(&card->card_lock);
@@ -612 +601 @@
-						schedule_work(&port->hangup_tq);
+						tty_hangup(tty);
@@ -634 +623 @@
-						schedule_work(&port->bh_tqueue);
+						tty_wakeup(tty);
@@ -697,0 +687 @@
+	spin_unlock(&card->card_lock);
@@ -723 +713,2 @@
-		if (baud < 1 || baud > 2)
+		/* 1,2,3,4 => 57.6, 115.2, 230, 460 kbps resp. */
+		if (baud < 1 || baud > 4)
@@ -738,0 +730,4 @@
+		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+			baud += 3; /* 230 kbps*/
+		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+			baud += 4; /* 460 kbps*/
@@ -1463,11 +1457,0 @@
-/* hangup et all */
-static void do_isicom_hangup(struct work_struct *work)
-{
-	struct isi_port *port = container_of(work, struct isi_port, hangup_tq);
-	struct tty_struct *tty;
-
-	tty = port->tty;
-	if (tty)
-		tty_hangup(tty);
-}
-
@@ -1506 +1489,0 @@
-	wake_up_interruptible(&tty->write_wait);
@@ -1539 +1522 @@
-	unsigned int portcount = 0;
+	unsigned int sig, portcount = 0;
@@ -1547 +1530 @@
-	mdelay(10);
+	msleep(10);
@@ -1551 +1534 @@
-	msleep(3000);
+	msleep(1000);
@@ -1553 +1536,12 @@
-	*signature = inw(base + 0x4) & 0xff;
+	sig = inw(base + 0x4) & 0xff;
+
+	if (sig != 0xa5 && sig != 0xbb && sig != 0xcc && sig != 0xdd &&
+			sig != 0xee) {
+		dev_warn(&pdev->dev, "ISILoad:Card%u reset failure (Possible "
+			"bad I/O Port Address 0x%lx).\n", card + 1, base);
+		dev_dbg(&pdev->dev, "Sig=0x%x\n", sig);
+		retval = -EIO;
+		goto end;
+	}
+
+	msleep(10);
@@ -1556,7 +1550,4 @@
-	if (!(inw(base + 0xe) & 0x1) || ((portcount != 0) &&
-			(portcount != 4) && (portcount != 8))) {
-		dev_dbg(&pdev->dev, "base+0x2=0x%lx, base+0xe=0x%lx\n",
-			inw(base + 0x2), inw(base + 0xe));
-		dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure "
-			"(Possible bad I/O Port Address 0x%lx).\n",
-			card + 1, base);
+	if (!inw(base + 0xe) & 0x1 || (portcount != 0 && portcount != 4 &&
+				portcount != 8 && portcount != 16)) {
+		dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure.",
+			card + 1);
@@ -1567 +1558 @@
-	switch (*signature) {
+	switch (sig) {
@@ -1574,0 +1566 @@
+	case 0xee:
@@ -1578,5 +1569,0 @@
-	default:
-		dev_warn(&pdev->dev, "ISILoad:Card%d reset failure (Possible "
-			"bad I/O Port Address 0x%lx).\n", card + 1, base);
-		dev_dbg(&pdev->dev, "Sig=0x%lx\n", signature);
-		retval = -EIO;
@@ -1584,0 +1572 @@
+	*signature = sig;
@@ -1760 +1748 @@
-static int card;
+static unsigned int card_count;
@@ -1770 +1758 @@
-	if (card >= BOARD_COUNT)
+	if (card_count >= BOARD_COUNT)
@@ -1788 +1776 @@
-	card++;
+	card_count++;
@@ -1798 +1786 @@
-		goto err;
+		goto errdec;
@@ -1827 +1815 @@
-err:
+errdec:
@@ -1828,0 +1817,2 @@
+	card_count--;
+err:
@@ -1841,0 +1832,2 @@
+	board->base = 0;
+	card_count--;
@@ -1849,2 +1840,0 @@
-	card = 0;
-
@@ -1861,2 +1850,0 @@
-			INIT_WORK(&port->hangup_tq, do_isicom_hangup);
-			INIT_WORK(&port->bh_tqueue, isicom_bottomhalf);
--- ./projects/linux/linux-2.6.21/drivers/char/isicom.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/char/isicom.c	2007-07-09 01:32:17.000000000 +0200
@@ -139,0 +140 @@
+#define pr_dbg(str...) pr_debug("ISICOM: " str)
@@ -141 +141,0 @@
-#define pr_dbg(str...) printk(KERN_DEBUG "ISICOM: " str)
@@ -144 +143,0 @@
-#define pr_dbg(str...) do { } while (0)
--- ./projects/linux/linux-2.6.22/drivers/char/isicom.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/char/isicom.c	2007-10-09 22:31:38.000000000 +0200
@@ -174,3 +173,0 @@
-static DECLARE_COMPLETION(isi_timerdone);
-static char re_schedule = 1;
-
@@ -190 +187 @@
-	unsigned char		irq;
+	int			irq;
@@ -230 +227 @@
-static inline int WaitTillCardIsFree(u16 base)
+static inline int WaitTillCardIsFree(unsigned long base)
@@ -246 +242,0 @@
-	char		retries;
@@ -247,0 +244 @@
+	unsigned int retries, a;
@@ -249 +246 @@
-	for (retries = 0; retries < 100; retries++) {
+	for (retries = 0; retries < 10; retries++) {
@@ -251,5 +248,4 @@
-		if (inw(base + 0xe) & 0x1) {
-			return 1;
-		} else {
-			spin_unlock_irqrestore(&card->card_lock, card->flags);
-			udelay(1000);   /* 1ms */
+		for (a = 0; a < 10; a++) {
+			if (inw(base + 0xe) & 0x1)
+				return 1;
+			udelay(10);
@@ -256,0 +253,2 @@
+		spin_unlock_irqrestore(&card->card_lock, card->flags);
+		msleep(10);
@@ -264,17 +261,0 @@
-static int lock_card_at_interrupt(struct isi_board *card)
-{
-	unsigned char		retries;
-	unsigned long base = card->base;
-
-	for (retries = 0; retries < 200; retries++) {
-		spin_lock_irqsave(&card->card_lock, card->flags);
-
-		if (inw(base + 0xe) & 0x1)
-			return 1;
-		else
-			spin_unlock_irqrestore(&card->card_lock, card->flags);
-	}
-	/* Failing in interrupt is an acceptable event */
-	return 0;	/* Failed to acquire the card! */
-}
-
@@ -418 +399,3 @@
-	short count = (BOARD_COUNT-1), card, base;
+	unsigned long flags, base;
+	unsigned int retries;
+	short count = (BOARD_COUNT-1), card;
@@ -437,0 +421,10 @@
+
+	spin_lock_irqsave(&isi_card[card].card_lock, flags);
+	for (retries = 0; retries < 100; retries++) {
+		if (inw(base + 0xe) & 0x1)
+			break;
+		udelay(2);
+	}
+	if (retries >= 100)
+		goto unlock;
+
@@ -439,2 +431,0 @@
-		if (!lock_card_at_interrupt(&isi_card[card]))
-			continue;
@@ -444 +434,0 @@
-			unlock_card(&isi_card[card]);
@@ -449,3 +439 @@
-
-		if (tty == NULL) {
-			unlock_card(&isi_card[card]);
+		if (tty == NULL)
@@ -453 +440,0 @@
-		}
@@ -456,2 +443 @@
-		if (txcount <= 0 || tty->stopped || tty->hw_stopped) {
-			unlock_card(&isi_card[card]);
+		if (txcount <= 0 || tty->stopped || tty->hw_stopped)
@@ -459,3 +445,2 @@
-		}
-		if (!(inw(base + 0x02) & (1 << port->channel))) {
-			unlock_card(&isi_card[card]);
+
+		if (!(inw(base + 0x02) & (1 << port->channel)))
@@ -463 +448 @@
-		}
+
@@ -511 +495,0 @@
-		unlock_card(&isi_card[card]);
@@ -513,0 +498,2 @@
+unlock:
+	spin_unlock_irqrestore(&isi_card[card].card_lock, flags);
@@ -516,5 +501,0 @@
-	if (!re_schedule) {
-		complete(&isi_timerdone);
- 		return;
-	}
-
@@ -1752 +1733 @@
-	unsigned int ioaddr, signature, index;
+	unsigned int signature, index;
@@ -1754 +1734,0 @@
-	u8 pciirq;
@@ -1760,3 +1739,0 @@
-	ioaddr = pci_resource_start(pdev, 3);
-	/* i.e at offset 0x1c in the PCI configuration register space. */
-	pciirq = pdev->irq;
@@ -1773,2 +1750,2 @@
-	board->base = ioaddr;
-	board->irq = pciirq;
+	board->base = pci_resource_start(pdev, 3);
+	board->irq = pdev->irq;
@@ -1904,3 +1881 @@
-	re_schedule = 0;
-
-	wait_for_completion_timeout(&isi_timerdone, HZ);
+	del_timer_sync(&tx);
--- ./projects/linux/linux-2.6.23/drivers/char/isicom.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/char/isicom.c	2008-01-24 23:58:37.000000000 +0100
@@ -1532 +1532 @@
-		dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure.",
+		dev_err(&pdev->dev, "ISILoad:PCI Card%d reset failure.\n",
@@ -1625 +1625,3 @@
-				"Address:0x%x\nCount:0x%x\nStatus:0x%x\n",
+				KERN_WARNING "Address:0x%x\n"
+				KERN_WARNING "Count:0x%x\n"
+				KERN_WARNING "Status:0x%x\n",
@@ -1669 +1671,3 @@
-				"Address:0x%x\nCount:0x%x\nStatus: 0x%x\n",
+				KERN_WARNING "Address:0x%x\n"
+				KERN_WARNING "Count:0x%x\n"
+				KERN_WARNING "Status: 0x%x\n",
--- ./projects/linux/linux-2.6.24/drivers/char/isicom.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/char/isicom.c	2008-04-17 04:49:44.000000000 +0200
@@ -1530 +1530 @@
-	if (!inw(base + 0xe) & 0x1 || (portcount != 0 && portcount != 4 &&
+	if (!(inw(base + 0xe) & 0x1) || (portcount != 0 && portcount != 4 &&
--- ./projects/linux/linux-2.6.25/drivers/char/isicom.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/char/isicom.c	2008-07-13 23:51:29.000000000 +0200
@@ -129,2 +129,2 @@
-#include <asm/uaccess.h>
-#include <asm/io.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
@@ -192 +192 @@
-	struct isi_port		* ports;
+	struct isi_port		*ports;
@@ -208,2 +208,2 @@
-	struct isi_board	* card;
-	struct tty_struct 	* tty;
+	struct isi_board	*card;
+	struct tty_struct 	*tty;
@@ -212 +212 @@
-	unsigned char		* xmit_buf;
+	unsigned char		*xmit_buf;
@@ -408 +408 @@
-	while(count-- > 0) {
+	while (count-- > 0) {
@@ -431 +431 @@
-	for (;count > 0;count--, port++) {
+	for (; count > 0; count--, port++) {
@@ -474 +474,2 @@
-			if (cnt <= 0) break;
+			if (cnt <= 0)
+				break;
@@ -476 +477 @@
-			outsw(base, port->xmit_buf+port->xmit_tail,word_count);
+			outsw(base, port->xmit_buf+port->xmit_tail, word_count);
@@ -559 +560 @@
-		while(byte_count > 1) {
+		while (byte_count > 1) {
@@ -572 +573 @@
-		switch(header & 0xff) {
+		switch (header & 0xff) {
@@ -659 +660,2 @@
-			while(byte_count > 0) { /* drain out unread xtra data */
+		/* drain out unread xtra data */
+		while (byte_count > 0) {
@@ -682 +684,3 @@
-	if (!(tty = port->tty) || !tty->termios)
+	tty = port->tty;
+
+	if (tty == NULL)
@@ -683,0 +688 @@
+	/* FIXME: Switch to new tty baud API */
@@ -709 +714 @@
-			baud +=2; /*  115  Kbps */
+			baud += 2; /*  115  Kbps */
@@ -719,2 +724 @@
-	}
-	else
+	} else
@@ -724 +728 @@
-		outw(0x8000 | (channel << shift_count) |0x03, base);
+		outw(0x8000 | (channel << shift_count) | 0x03, base);
@@ -727 +731 @@
-		switch(C_CSIZE(tty)) {
+		switch (C_CSIZE(tty)) {
@@ -770 +774 @@
-		outw(0x8000 | (channel << shift_count) |0x04, base);
+		outw(0x8000 | (channel << shift_count) | 0x04, base);
@@ -808 +812 @@
-	if (port->flags & ASYNC_INITIALIZED) {
+	if (port->flags & ASYNC_INITIALIZED)
@@ -810 +813,0 @@
-	}
@@ -812,3 +815,3 @@
-		unsigned long page;
-
-		if (!(page = get_zeroed_page(GFP_KERNEL)))
+		/* Relies on BKL */
+		unsigned long page  = get_zeroed_page(GFP_KERNEL);
+		if (page == 0)
@@ -816,2 +819 @@
-
-		if (port->xmit_buf) {
+		if (port->xmit_buf)
@@ -819,3 +821,2 @@
-			return -ERESTARTSYS;
-		}
-		port->xmit_buf = (unsigned char *) page;
+		else
+			port->xmit_buf = (unsigned char *) page;
@@ -952,6 +953,4 @@
-	if ((error = isicom_setup_port(port))!=0)
-		return error;
-	if ((error = block_til_ready(tty, filp, port))!=0)
-		return error;
-
-	return 0;
+	error = isicom_setup_port(port);
+	if (error == 0)
+		error = block_til_ready(tty, filp, port);
+	return error;
@@ -964 +963 @@
-	if (bp->status & BOARD_ACTIVE) {
+	if (bp->status & BOARD_ACTIVE)
@@ -966 +964,0 @@
-	}
@@ -1014,0 +1013,16 @@
+static void isicom_flush_buffer(struct tty_struct *tty)
+{
+	struct isi_port *port = tty->driver_data;
+	struct isi_board *card = port->card;
+	unsigned long flags;
+
+	if (isicom_paranoia_check(port, tty->name, "isicom_flush_buffer"))
+		return;
+
+	spin_lock_irqsave(&card->card_lock, flags);
+	port->xmit_cnt = port->xmit_head = port->xmit_tail = 0;
+	spin_unlock_irqrestore(&card->card_lock, flags);
+
+	tty_wakeup(tty);
+}
+
@@ -1068,2 +1082 @@
-	if (tty->driver->flush_buffer)
-		tty->driver->flush_buffer(tty);
+	isicom_flush_buffer(tty);
@@ -1107 +1120 @@
-	while(1) {
+	while (1) {
@@ -1128 +1141 @@
-static void isicom_put_char(struct tty_struct *tty, unsigned char ch)
+static int isicom_put_char(struct tty_struct *tty, unsigned char ch)
@@ -1135 +1148 @@
-		return;
+		return 0;
@@ -1138 +1151 @@
-		return;
+		return 0;
@@ -1143 +1156 @@
-		return;
+		return 0;
@@ -1149,0 +1163 @@
+	return 1;
@@ -1260,0 +1275,2 @@
+	lock_kernel();
+
@@ -1268 +1284,2 @@
-				(port->flags & ~ASYNC_USR_MASK)))
+				(port->flags & ~ASYNC_USR_MASK))) {
+			unlock_kernel();
@@ -1270 +1287,2 @@
-		port->flags = ((port->flags & ~ ASYNC_USR_MASK) |
+		}
+		port->flags = ((port->flags & ~ASYNC_USR_MASK) |
@@ -1272,2 +1290 @@
-	}
-	else {
+	} else {
@@ -1284,0 +1302 @@
+	unlock_kernel();
@@ -1292,0 +1311 @@
+	lock_kernel();
@@ -1301,0 +1321 @@
+	unlock_kernel();
@@ -1317 +1337 @@
-	switch(cmd) {
+	switch (cmd) {
@@ -1334,13 +1353,0 @@
-
-	case TIOCGSOFTCAR:
-		return put_user(C_CLOCAL(tty) ? 1 : 0,
-				(unsigned long __user *)argp);
-
-	case TIOCSSOFTCAR:
-		if (get_user(arg, (unsigned long __user *) argp))
-			return -EFAULT;
-		tty->termios->c_cflag =
-			((tty->termios->c_cflag & ~CLOCAL) |
-			(arg ? CLOCAL : 0));
-		return 0;
-
@@ -1456,16 +1462,0 @@
-/* flush_buffer et all */
-static void isicom_flush_buffer(struct tty_struct *tty)
-{
-	struct isi_port *port = tty->driver_data;
-	struct isi_board *card = port->card;
-	unsigned long flags;
-
-	if (isicom_paranoia_check(port, tty->name, "isicom_flush_buffer"))
-		return;
-
-	spin_lock_irqsave(&card->card_lock, flags);
-	port->xmit_cnt = port->xmit_head = port->xmit_tail = 0;
-	spin_unlock_irqrestore(&card->card_lock, flags);
-
-	tty_wakeup(tty);
-}
@@ -1595 +1586 @@
- 	}
+	}
@@ -1623 +1614,2 @@
-		if ((status = inw(base + 0x4)) != 0) {
+		status = inw(base + 0x4);
+		if (status != 0) {
@@ -1640 +1632,2 @@
-		if ((status = inw(base + 0x4)) != 0) {
+		status = inw(base + 0x4);
+		if (status != 0) {
@@ -1645 +1638 @@
- 	}
+	}
@@ -1669 +1662,2 @@
-		if ((status = inw(base + 0x4)) != 0) {
+		status = inw(base + 0x4);
+		if (status != 0) {
@@ -1702 +1696,2 @@
-		if ((status = inw(base + 0x4)) != 0) {
+		status = inw(base + 0x4);
+		if (status != 0) {
@@ -1767 +1762 @@
- 	}
+	}
@@ -1821 +1816 @@
-	for(idx = 0; idx < BOARD_COUNT; idx++) {
+	for (idx = 0; idx < BOARD_COUNT; idx++) {
@@ -1835 +1830 @@
- 		}
+		}
--- ./projects/linux/linux-2.6.26/drivers/char/isicom.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/char/isicom.c	2008-10-10 00:13:53.000000000 +0200
@@ -201,4 +201 @@
-	unsigned int		flags;
-	int			count;
-	int			blocked_open;
-	int			close_delay;
+	struct tty_port		port;
@@ -207 +203,0 @@
-	u16			closing_wait;
@@ -209,3 +204,0 @@
-	struct tty_struct 	*tty;
-	wait_queue_head_t	close_wait;
-	wait_queue_head_t	open_wait;
@@ -433 +426 @@
-		if (!(port->flags & ASYNC_INITIALIZED) ||
+		if (!(port->port.flags & ASYNC_INITIALIZED) ||
@@ -437 +430 @@
-		tty = port->tty;
+		tty = port->port.tty;
@@ -461 +454 @@
-					wrd |= (port->xmit_buf[port->xmit_tail]
+					wrd |= (port->port.xmit_buf[port->xmit_tail]
@@ -477 +470 @@
-			outsw(base, port->xmit_buf+port->xmit_tail, word_count);
+			outsw(base, port->port.xmit_buf+port->xmit_tail, word_count);
@@ -484 +477 @@
-				wrd = port->xmit_buf[port->xmit_tail];
+				wrd = port->port.xmit_buf[port->xmit_tail];
@@ -551 +544 @@
-	if (!(port->flags & ASYNC_INITIALIZED)) {
+	if (!(port->port.flags & ASYNC_INITIALIZED)) {
@@ -557 +550 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -575 +568 @@
-			if (port->flags & ASYNC_CHECK_CD) {
+			if (port->port.flags & ASYNC_CHECK_CD) {
@@ -588 +581 @@
-					wake_up_interruptible(&port->open_wait);
+					wake_up_interruptible(&port->port.open_wait);
@@ -597,2 +590,2 @@
-			if (port->flags & ASYNC_CTS_FLOW) {
-				if (port->tty->hw_stopped) {
+			if (port->port.flags & ASYNC_CTS_FLOW) {
+				if (port->port.tty->hw_stopped) {
@@ -600 +593 @@
-						port->tty->hw_stopped = 0;
+						port->port.tty->hw_stopped = 0;
@@ -607 +600 @@
-					port->tty->hw_stopped = 1;
+					port->port.tty->hw_stopped = 1;
@@ -632 +625 @@
-			if (port->flags & ASYNC_SAK)
+			if (port->port.flags & ASYNC_SAK)
@@ -684 +677 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -700 +693 @@
-			port->tty->termios->c_cflag &= ~CBAUDEX;
+			port->port.tty->termios->c_cflag &= ~CBAUDEX;
@@ -711 +704 @@
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
+		if ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_HI)
@@ -713 +706 @@
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
+		if ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_VHI)
@@ -715 +708 @@
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
+		if ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_SHI)
@@ -717 +710 @@
-		if ((port->flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
+		if ((port->port.flags & ASYNC_SPD_MASK) == ASYNC_SPD_WARP)
@@ -757 +750 @@
-		port->flags &= ~ASYNC_CHECK_CD;
+		port->port.flags &= ~ASYNC_CHECK_CD;
@@ -759 +752 @@
-		port->flags |= ASYNC_CHECK_CD;
+		port->port.flags |= ASYNC_CHECK_CD;
@@ -763 +756 @@
-	port->flags &= ~ASYNC_CTS_FLOW;
+	port->port.flags &= ~ASYNC_CTS_FLOW;
@@ -765 +758 @@
-		port->flags |= ASYNC_CTS_FLOW;
+		port->port.flags |= ASYNC_CTS_FLOW;
@@ -812 +805 @@
-	if (port->flags & ASYNC_INITIALIZED)
+	if (port->port.flags & ASYNC_INITIALIZED)
@@ -814,10 +807,2 @@
-	if (!port->xmit_buf) {
-		/* Relies on BKL */
-		unsigned long page  = get_zeroed_page(GFP_KERNEL);
-		if (page == 0)
-			return -ENOMEM;
-		if (port->xmit_buf)
-			free_page(page);
-		else
-			port->xmit_buf = (unsigned char *) page;
-	}
+	if (tty_port_alloc_xmit_buf(&port->port) < 0)
+		return -ENOMEM;
@@ -826,3 +811,3 @@
-	if (port->tty)
-		clear_bit(TTY_IO_ERROR, &port->tty->flags);
-	if (port->count == 1)
+	if (port->port.tty)
+		clear_bit(TTY_IO_ERROR, &port->port.tty->flags);
+	if (port->port.count == 1)
@@ -842 +827 @@
-	port->flags |= ASYNC_INITIALIZED;
+	port->port.flags |= ASYNC_INITIALIZED;
@@ -858 +843 @@
-	if (tty_hung_up_p(filp) || port->flags & ASYNC_CLOSING) {
+	if (tty_hung_up_p(filp) || port->port.flags & ASYNC_CLOSING) {
@@ -860,2 +845,2 @@
-		interruptible_sleep_on(&port->close_wait);
-		if (port->flags & ASYNC_HUP_NOTIFY)
+		interruptible_sleep_on(&port->port.close_wait);
+		if (port->port.flags & ASYNC_HUP_NOTIFY)
@@ -872 +857 @@
-		port->flags |= ASYNC_NORMAL_ACTIVE;
+		port->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -882 +867 @@
-	add_wait_queue(&port->open_wait, &wait);
+	add_wait_queue(&port->port.open_wait, &wait);
@@ -886,2 +871,2 @@
-		port->count--;
-	port->blocked_open++;
+		port->port.count--;
+	port->port.blocked_open++;
@@ -894,2 +879,2 @@
-		if (tty_hung_up_p(filp) || !(port->flags & ASYNC_INITIALIZED)) {
-			if (port->flags & ASYNC_HUP_NOTIFY)
+		if (tty_hung_up_p(filp) || !(port->port.flags & ASYNC_INITIALIZED)) {
+			if (port->port.flags & ASYNC_HUP_NOTIFY)
@@ -901 +886 @@
-		if (!(port->flags & ASYNC_CLOSING) &&
+		if (!(port->port.flags & ASYNC_CLOSING) &&
@@ -912 +897 @@
-	remove_wait_queue(&port->open_wait, &wait);
+	remove_wait_queue(&port->port.open_wait, &wait);
@@ -915,2 +900,2 @@
-		port->count++;
-	port->blocked_open--;
+		port->port.count++;
+	port->port.blocked_open--;
@@ -920 +905 @@
-	port->flags |= ASYNC_NORMAL_ACTIVE;
+	port->port.flags |= ASYNC_NORMAL_ACTIVE;
@@ -950 +935 @@
-	port->count++;
+	port->port.count++;
@@ -952 +937 @@
-	port->tty = tty;
+	port->port.tty = tty;
@@ -973 +958 @@
-	tty = port->tty;
+	tty = port->port.tty;
@@ -975 +960 @@
-	if (!(port->flags & ASYNC_INITIALIZED))
+	if (!(port->port.flags & ASYNC_INITIALIZED))
@@ -978,5 +963,2 @@
-	if (port->xmit_buf) {
-		free_page((unsigned long) port->xmit_buf);
-		port->xmit_buf = NULL;
-	}
-	port->flags &= ~ASYNC_INITIALIZED;
+	tty_port_free_xmit_buf(&port->port);
+	port->port.flags &= ~ASYNC_INITIALIZED;
@@ -984 +966 @@
-	port->tty = NULL;
+	port->port.tty = NULL;
@@ -1049 +1031 @@
-	if (tty->count == 1 && port->count != 1) {
+	if (tty->count == 1 && port->port.count != 1) {
@@ -1052,2 +1034,2 @@
-			card->base, port->count);
-		port->count = 1;
+			card->base, port->port.count);
+		port->port.count = 1;
@@ -1055 +1037 @@
-	if (--port->count < 0) {
+	if (--port->port.count < 0) {
@@ -1058,2 +1040,2 @@
-			port->count);
-		port->count = 0;
+			port->port.count);
+		port->port.count = 0;
@@ -1062 +1044 @@
-	if (port->count) {
+	if (port->port.count) {
@@ -1066 +1048 @@
-	port->flags |= ASYNC_CLOSING;
+	port->port.flags |= ASYNC_CLOSING;
@@ -1070,2 +1052,2 @@
-	if (port->closing_wait != ASYNC_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, port->closing_wait);
+	if (port->port.closing_wait != ASYNC_CLOSING_WAIT_NONE)
+		tty_wait_until_sent(tty, port->port.closing_wait);
@@ -1075 +1057 @@
-	if (port->flags & ASYNC_INITIALIZED) {
+	if (port->port.flags & ASYNC_INITIALIZED) {
@@ -1088 +1070 @@
-	if (port->blocked_open) {
+	if (port->port.blocked_open) {
@@ -1090 +1072 @@
-		if (port->close_delay) {
+		if (port->port.close_delay) {
@@ -1093 +1075 @@
-				jiffies_to_msecs(port->close_delay));
+				jiffies_to_msecs(port->port.close_delay));
@@ -1096 +1078 @@
-		wake_up_interruptible(&port->open_wait);
+		wake_up_interruptible(&port->port.open_wait);
@@ -1098,2 +1080,2 @@
-	port->flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
-	wake_up_interruptible(&port->close_wait);
+	port->port.flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
+	wake_up_interruptible(&port->port.close_wait);
@@ -1115,3 +1096,0 @@
-	if (!port->xmit_buf)
-		return 0;
-
@@ -1126 +1105 @@
-		memcpy(port->xmit_buf + port->xmit_head, buf, cnt);
+		memcpy(port->port.xmit_buf + port->xmit_head, buf, cnt);
@@ -1150,3 +1128,0 @@
-	if (!port->xmit_buf)
-		return 0;
-
@@ -1159 +1135 @@
-	port->xmit_buf[port->xmit_head++] = ch;
+	port->port.xmit_buf[port->xmit_head++] = ch;
@@ -1175 +1151 @@
-			!port->xmit_buf)
+			!port->port.xmit_buf)
@@ -1208,2 +1184 @@
-static inline void isicom_send_break(struct isi_port *port,
-	unsigned long length)
+static int isicom_send_break(struct tty_struct *tty, int length)
@@ -1210,0 +1186 @@
+	struct isi_port *port = tty->driver_data;
@@ -1213,0 +1190,3 @@
+	if (length == -1)
+		return -EOPNOTSUPP;
+
@@ -1215 +1194 @@
-		return;
+		return -EINVAL;
@@ -1222,0 +1202 @@
+	return 0;
@@ -1277 +1257 @@
-	reconfig_port = ((port->flags & ASYNC_SPD_MASK) !=
+	reconfig_port = ((port->port.flags & ASYNC_SPD_MASK) !=
@@ -1281,2 +1261,2 @@
-		if ((newinfo.close_delay != port->close_delay) ||
-				(newinfo.closing_wait != port->closing_wait) ||
+		if ((newinfo.close_delay != port->port.close_delay) ||
+				(newinfo.closing_wait != port->port.closing_wait) ||
@@ -1284 +1264 @@
-				(port->flags & ~ASYNC_USR_MASK))) {
+				(port->port.flags & ~ASYNC_USR_MASK))) {
@@ -1288 +1268 @@
-		port->flags = ((port->flags & ~ASYNC_USR_MASK) |
+		port->port.flags = ((port->port.flags & ~ASYNC_USR_MASK) |
@@ -1291,3 +1271,3 @@
-		port->close_delay = newinfo.close_delay;
-		port->closing_wait = newinfo.closing_wait;
-		port->flags = ((port->flags & ~ASYNC_FLAGS) |
+		port->port.close_delay = newinfo.close_delay;
+		port->port.closing_wait = newinfo.closing_wait;
+		port->port.flags = ((port->port.flags & ~ASYNC_FLAGS) |
@@ -1317 +1297 @@
-	out_info.flags = port->flags;
+	out_info.flags = port->port.flags;
@@ -1319,2 +1299,2 @@
-	out_info.close_delay = port->close_delay;
-	out_info.closing_wait = port->closing_wait;
+	out_info.close_delay = port->port.close_delay;
+	out_info.closing_wait = port->port.closing_wait;
@@ -1332 +1311,0 @@
-	int retval;
@@ -1338,16 +1316,0 @@
-	case TCSBRK:
-		retval = tty_check_change(tty);
-		if (retval)
-			return retval;
-		tty_wait_until_sent(tty, 0);
-		if (!arg)
-			isicom_send_break(port, HZ/4);
-		return 0;
-
-	case TCSBRKP:
-		retval = tty_check_change(tty);
-		if (retval)
-			return retval;
-		tty_wait_until_sent(tty, 0);
-		isicom_send_break(port, arg ? arg * (HZ/10) : HZ/4);
-		return 0;
@@ -1457,4 +1420,4 @@
-	port->count = 0;
-	port->flags &= ~ASYNC_NORMAL_ACTIVE;
-	port->tty = NULL;
-	wake_up_interruptible(&port->open_wait);
+	port->port.count = 0;
+	port->port.flags &= ~ASYNC_NORMAL_ACTIVE;
+	port->port.tty = NULL;
+	wake_up_interruptible(&port->port.open_wait);
@@ -1485,0 +1449 @@
+	.break_ctl		= isicom_send_break,
@@ -1738,0 +1703,6 @@
+	retval = pci_enable_device(pdev);
+	if (retval) {
+		dev_err(&pdev->dev, "failed to enable\n");
+		goto err;
+	}
+
@@ -1792,0 +1763 @@
+	pci_disable_device(pdev);
@@ -1808,0 +1780 @@
+	pci_disable_device(pdev);
@@ -1820,0 +1793 @@
+			tty_port_init(&port->port);
@@ -1824,2 +1797,2 @@
-			port->close_delay = 50 * HZ/100;
-			port->closing_wait = 3000 * HZ/100;
+			port->port.close_delay = 50 * HZ/100;
+			port->port.closing_wait = 3000 * HZ/100;
@@ -1827,2 +1799,0 @@
-			init_waitqueue_head(&port->open_wait);
-			init_waitqueue_head(&port->close_wait);
@@ -1852 +1823 @@
-		TTY_DRIVER_DYNAMIC_DEV;
+		TTY_DRIVER_DYNAMIC_DEV | TTY_DRIVER_HARDWARE_BREAK;
--- ./projects/linux/linux-2.6.27/drivers/char/isicom.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/char/isicom.c	2008-12-25 00:26:37.000000000 +0100
@@ -10 +10,2 @@
- *	1/9/98	alan@redhat.com		Merge to 2.0.x kernel tree
+ *	1/9/98	alan@lxorguk.ukuu.org.uk
+ *					Merge to 2.0.x kernel tree
@@ -15 +16,2 @@
- *	9/12/98	alan@redhat.com		Rough port to 2.1.x
+ *	9/12/98	alan@lxorguk.ukuu.org.uk
+ *					Rough port to 2.1.x
@@ -423,0 +426,4 @@
+	tty = tty_port_tty_get(&port->port);
+	if (tty == NULL)
+		goto put_unlock;
+
@@ -430,5 +435,0 @@
-		tty = port->port.tty;
-
-		if (tty == NULL)
-			continue;
-
@@ -491,0 +493,2 @@
+put_unlock:
+	tty_kref_put(tty);
@@ -550 +553 @@
-	tty = port->port.tty;
+	tty = tty_port_tty_get(&port->port);
@@ -591 +594 @@
-				if (port->port.tty->hw_stopped) {
+				if (tty->hw_stopped) {
@@ -600 +603 @@
-					port->port.tty->hw_stopped = 1;
+					tty->hw_stopped = 1;
@@ -662,0 +666 @@
+	tty_kref_put(tty);
@@ -667 +671 @@
-static void isicom_config_port(struct isi_port *port)
+static void isicom_config_port(struct tty_struct *tty)
@@ -668,0 +673 @@
+	struct isi_port *port = tty->driver_data;
@@ -670 +674,0 @@
-	struct tty_struct *tty;
@@ -677,4 +680,0 @@
-	tty = port->port.tty;
-
-	if (tty == NULL)
-		return;
@@ -693 +693 @@
-			port->port.tty->termios->c_cflag &= ~CBAUDEX;
+			tty->termios->c_cflag &= ~CBAUDEX;
@@ -800 +800 @@
-static int isicom_setup_port(struct isi_port *port)
+static int isicom_setup_port(struct tty_struct *tty)
@@ -801,0 +802 @@
+	struct isi_port *port = tty->driver_data;
@@ -811,2 +812 @@
-	if (port->port.tty)
-		clear_bit(TTY_IO_ERROR, &port->port.tty->flags);
+	clear_bit(TTY_IO_ERROR, &tty->flags);
@@ -826 +826 @@
-	isicom_config_port(port);
+	isicom_config_port(tty);
@@ -937,2 +937,2 @@
-	port->port.tty = tty;
-	error = isicom_setup_port(port);
+	tty_port_tty_set(&port->port, tty);
+	error = isicom_setup_port(tty);
@@ -958 +958 @@
-	tty = port->port.tty;
+	tty = tty_port_tty_get(&port->port);
@@ -960 +960,2 @@
-	if (!(port->port.flags & ASYNC_INITIALIZED))
+	if (!(port->port.flags & ASYNC_INITIALIZED)) {
+		tty_kref_put(tty);
@@ -961,0 +963 @@
+	}
@@ -966 +968 @@
-	port->port.tty = NULL;
+	tty_port_tty_set(&port->port, NULL);
@@ -1246,2 +1248,2 @@
-static int isicom_set_serial_info(struct isi_port *port,
-	struct serial_struct __user *info)
+static int isicom_set_serial_info(struct tty_struct *tty,
+					struct serial_struct __user *info)
@@ -1248,0 +1251 @@
+	struct isi_port *port = tty->driver_data;
@@ -1279 +1282 @@
-		isicom_config_port(port);
+		isicom_config_port(tty);
@@ -1321 +1324 @@
-		return isicom_set_serial_info(port, argp);
+		return isicom_set_serial_info(tty, argp);
@@ -1344 +1347 @@
-	isicom_config_port(port);
+	isicom_config_port(tty);
@@ -1422 +1425 @@
-	port->port.tty = NULL;
+	tty_port_tty_set(&port->port, NULL);
--- ./projects/linux/linux-2.6.28/drivers/char/isicom.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/char/isicom.c	2009-03-24 00:12:14.000000000 +0100
@@ -331 +331,2 @@
-static inline void raise_dtr_rts(struct isi_port *port)
+
+static void isicom_raise_dtr_rts(struct tty_port *port)
@@ -333 +334,2 @@
-	struct isi_board *card = port->card;
+	struct isi_port *ip = container_of(port, struct isi_port, port);
+	struct isi_board *card = ip->card;
@@ -335 +337 @@
-	u16 channel = port->channel;
+	u16 channel = ip->channel;
@@ -343 +345 @@
-	port->status |= (ISI_DTR | ISI_RTS);
+	ip->status |= (ISI_DTR | ISI_RTS);
@@ -833,2 +835 @@
-static int block_til_ready(struct tty_struct *tty, struct file *filp,
-	struct isi_port *port)
+static int isicom_carrier_raised(struct tty_port *port)
@@ -836,71 +837,2 @@
-	struct isi_board *card = port->card;
-	int do_clocal = 0, retval;
-	unsigned long flags;
-	DECLARE_WAITQUEUE(wait, current);
-
-	/* block if port is in the process of being closed */
-
-	if (tty_hung_up_p(filp) || port->port.flags & ASYNC_CLOSING) {
-		pr_dbg("block_til_ready: close in progress.\n");
-		interruptible_sleep_on(&port->port.close_wait);
-		if (port->port.flags & ASYNC_HUP_NOTIFY)
-			return -EAGAIN;
-		else
-			return -ERESTARTSYS;
-	}
-
-	/* if non-blocking mode is set ... */
-
-	if ((filp->f_flags & O_NONBLOCK) ||
-			(tty->flags & (1 << TTY_IO_ERROR))) {
-		pr_dbg("block_til_ready: non-block mode.\n");
-		port->port.flags |= ASYNC_NORMAL_ACTIVE;
-		return 0;
-	}
-
-	if (C_CLOCAL(tty))
-		do_clocal = 1;
-
-	/* block waiting for DCD to be asserted, and while
-						callout dev is busy */
-	retval = 0;
-	add_wait_queue(&port->port.open_wait, &wait);
-
-	spin_lock_irqsave(&card->card_lock, flags);
-	if (!tty_hung_up_p(filp))
-		port->port.count--;
-	port->port.blocked_open++;
-	spin_unlock_irqrestore(&card->card_lock, flags);
-
-	while (1) {
-		raise_dtr_rts(port);
-
-		set_current_state(TASK_INTERRUPTIBLE);
-		if (tty_hung_up_p(filp) || !(port->port.flags & ASYNC_INITIALIZED)) {
-			if (port->port.flags & ASYNC_HUP_NOTIFY)
-				retval = -EAGAIN;
-			else
-				retval = -ERESTARTSYS;
-			break;
-		}
-		if (!(port->port.flags & ASYNC_CLOSING) &&
-				(do_clocal || (port->status & ISI_DCD))) {
-			break;
-		}
-		if (signal_pending(current)) {
-			retval = -ERESTARTSYS;
-			break;
-		}
-		schedule();
-	}
-	set_current_state(TASK_RUNNING);
-	remove_wait_queue(&port->port.open_wait, &wait);
-	spin_lock_irqsave(&card->card_lock, flags);
-	if (!tty_hung_up_p(filp))
-		port->port.count++;
-	port->port.blocked_open--;
-	spin_unlock_irqrestore(&card->card_lock, flags);
-	if (retval)
-		return retval;
-	port->port.flags |= ASYNC_NORMAL_ACTIVE;
-	return 0;
+	struct isi_port *ip = container_of(port, struct isi_port, port);
+	return (ip->status & ISI_DCD)?1 : 0;
@@ -934,0 +867 @@
+	/* FIXME: locking on port.count etc */
@@ -940 +873 @@
-		error = block_til_ready(tty, filp, port);
+		error = tty_port_block_til_ready(&port->port, tty, filp);
@@ -1015 +948,2 @@
-	struct isi_port *port = tty->driver_data;
+	struct isi_port *ip = tty->driver_data;
+	struct tty_port *port = &ip->port;
@@ -1019,26 +953 @@
-	if (!port)
-		return;
-	card = port->card;
-	if (isicom_paranoia_check(port, tty->name, "isicom_close"))
-		return;
-
-	pr_dbg("Close start!!!.\n");
-
-	spin_lock_irqsave(&card->card_lock, flags);
-	if (tty_hung_up_p(filp)) {
-		spin_unlock_irqrestore(&card->card_lock, flags);
-		return;
-	}
-
-	if (tty->count == 1 && port->port.count != 1) {
-		printk(KERN_WARNING "ISICOM:(0x%lx) isicom_close: bad port "
-			"count tty->count = 1 port count = %d.\n",
-			card->base, port->port.count);
-		port->port.count = 1;
-	}
-	if (--port->port.count < 0) {
-		printk(KERN_WARNING "ISICOM:(0x%lx) isicom_close: bad port "
-			"count for channel%d = %d", card->base, port->channel,
-			port->port.count);
-		port->port.count = 0;
-	}
+	BUG_ON(!ip);
@@ -1046,2 +955,2 @@
-	if (port->port.count) {
-		spin_unlock_irqrestore(&card->card_lock, flags);
+	card = ip->card;
+	if (isicom_paranoia_check(ip, tty->name, "isicom_close"))
@@ -1049,4 +957,0 @@
-	}
-	port->port.flags |= ASYNC_CLOSING;
-	tty->closing = 1;
-	spin_unlock_irqrestore(&card->card_lock, flags);
@@ -1054,2 +958,0 @@
-	if (port->port.closing_wait != ASYNC_CLOSING_WAIT_NONE)
-		tty_wait_until_sent(tty, port->port.closing_wait);
@@ -1059,2 +962,2 @@
-	if (port->port.flags & ASYNC_INITIALIZED) {
-		card->port_status &= ~(1 << port->channel);
+	if (port->flags & ASYNC_INITIALIZED) {
+		card->port_status &= ~(1 << ip->channel);
@@ -1063 +966 @@
-	isicom_shutdown_port(port);
+	isicom_shutdown_port(ip);
@@ -1067,18 +970,2 @@
-	tty_ldisc_flush(tty);
-
-	spin_lock_irqsave(&card->card_lock, flags);
-	tty->closing = 0;
-
-	if (port->port.blocked_open) {
-		spin_unlock_irqrestore(&card->card_lock, flags);
-		if (port->port.close_delay) {
-			pr_dbg("scheduling until time out.\n");
-			msleep_interruptible(
-				jiffies_to_msecs(port->port.close_delay));
-		}
-		spin_lock_irqsave(&card->card_lock, flags);
-		wake_up_interruptible(&port->port.open_wait);
-	}
-	port->port.flags &= ~(ASYNC_NORMAL_ACTIVE | ASYNC_CLOSING);
-	wake_up_interruptible(&port->port.close_wait);
-	spin_unlock_irqrestore(&card->card_lock, flags);
+	
+	tty_port_close_end(port, tty);
@@ -1423,4 +1310 @@
-	port->port.count = 0;
-	port->port.flags &= ~ASYNC_NORMAL_ACTIVE;
-	tty_port_tty_set(&port->port, NULL);
-	wake_up_interruptible(&port->port.open_wait);
+	tty_port_hangup(&port->port);
@@ -1454,0 +1339,5 @@
+static const struct tty_port_operations isicom_port_ops = {
+	.carrier_raised		= isicom_carrier_raised,
+	.raise_dtr_rts		= isicom_raise_dtr_rts,
+};
+
@@ -1796,0 +1686 @@
+			port->port.ops = &isicom_port_ops;
--- ./projects/linux/linux-2.6.29/drivers/char/isicom.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/char/isicom.c	2009-06-27 11:32:32.000000000 +0200
@@ -927,0 +928 @@
+	tty_kref_put(tty);
--- ./projects/linux/linux-2.6.13/drivers/i2c/busses/i2c-s3c2410.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/i2c/busses/i2c-s3c2410.c	2005-10-28 02:02:08.000000000 +0200
@@ -571 +570,0 @@
-	.name			= "S3C2410-I2C-Algorithm",
--- ./projects/linux/linux-2.6.14/drivers/i2c/busses/i2c-s3c2410.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/i2c/busses/i2c-s3c2410.c	2006-01-03 04:21:10.000000000 +0100
@@ -36 +36 @@
-#include <linux/device.h>
+#include <linux/platform_device.h>
@@ -763 +763 @@
-static int s3c24xx_i2c_probe(struct device *dev)
+static int s3c24xx_i2c_probe(struct platform_device *pdev)
@@ -765 +764,0 @@
-	struct platform_device *pdev = to_platform_device(dev);
@@ -772,2 +771,2 @@
-	i2c->dev = dev;
-	i2c->clk = clk_get(dev, "i2c");
+	i2c->dev = &pdev->dev;
+	i2c->clk = clk_get(&pdev->dev, "i2c");
@@ -775 +774 @@
-		dev_err(dev, "cannot get clock\n");
+		dev_err(&pdev->dev, "cannot get clock\n");
@@ -780 +779 @@
-	dev_dbg(dev, "clock source %p\n", i2c->clk);
+	dev_dbg(&pdev->dev, "clock source %p\n", i2c->clk);
@@ -789 +788 @@
-		dev_err(dev, "cannot find IO resource\n");
+		dev_err(&pdev->dev, "cannot find IO resource\n");
@@ -798 +797 @@
-		dev_err(dev, "cannot request IO\n");
+		dev_err(&pdev->dev, "cannot request IO\n");
@@ -806 +805 @@
-		dev_err(dev, "cannot map IO\n");
+		dev_err(&pdev->dev, "cannot map IO\n");
@@ -811 +810 @@
-	dev_dbg(dev, "registers %p (%p, %p)\n", i2c->regs, i2c->ioarea, res);
+	dev_dbg(&pdev->dev, "registers %p (%p, %p)\n", i2c->regs, i2c->ioarea, res);
@@ -816 +815 @@
-	i2c->adap.dev.parent = dev;
+	i2c->adap.dev.parent = &pdev->dev;
@@ -830 +829 @@
-		dev_err(dev, "cannot find IRQ\n");
+		dev_err(&pdev->dev, "cannot find IRQ\n");
@@ -839 +838 @@
-		dev_err(dev, "cannot claim IRQ\n");
+		dev_err(&pdev->dev, "cannot claim IRQ\n");
@@ -845 +844 @@
-	dev_dbg(dev, "irq resource %p (%ld)\n", res, res->start);
+	dev_dbg(&pdev->dev, "irq resource %p (%ld)\n", res, res->start);
@@ -849 +848 @@
-		dev_err(dev, "failed to add bus to i2c core\n");
+		dev_err(&pdev->dev, "failed to add bus to i2c core\n");
@@ -853 +852 @@
-	dev_set_drvdata(dev, i2c);
+	platform_set_drvdata(pdev, i2c);
@@ -855 +854 @@
-	dev_info(dev, "%s: S3C I2C adapter\n", i2c->adap.dev.bus_id);
+	dev_info(&pdev->dev, "%s: S3C I2C adapter\n", i2c->adap.dev.bus_id);
@@ -869 +868 @@
-static int s3c24xx_i2c_remove(struct device *dev)
+static int s3c24xx_i2c_remove(struct platform_device *pdev)
@@ -871 +870 @@
-	struct s3c24xx_i2c *i2c = dev_get_drvdata(dev);
+	struct s3c24xx_i2c *i2c = platform_get_drvdata(pdev);
@@ -875 +874 @@
-		dev_set_drvdata(dev, NULL);
+		platform_set_drvdata(pdev, NULL);
@@ -882 +881 @@
-static int s3c24xx_i2c_resume(struct device *dev, u32 level)
+static int s3c24xx_i2c_resume(struct platform_device *dev)
@@ -884,4 +883,3 @@
-	struct s3c24xx_i2c *i2c = dev_get_drvdata(dev);
-	
-	if (i2c != NULL && level == RESUME_ENABLE) {
-		dev_dbg(dev, "resume: level %d\n", level);
+	struct s3c24xx_i2c *i2c = platform_get_drvdata(dev);
+
+	if (i2c != NULL)
@@ -889 +886,0 @@
-	}
@@ -900,3 +897 @@
-static struct device_driver s3c2410_i2c_driver = {
-	.name		= "s3c2410-i2c",
-	.bus		= &platform_bus_type,
+static struct platform_driver s3c2410_i2c_driver = {
@@ -905,0 +901,4 @@
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c2410-i2c",
+	},
@@ -908,3 +907 @@
-static struct device_driver s3c2440_i2c_driver = {
-	.name		= "s3c2440-i2c",
-	.bus		= &platform_bus_type,
+static struct platform_driver s3c2440_i2c_driver = {
@@ -913,0 +911,4 @@
+	.driver		= {
+		.owner	= THIS_MODULE,
+		.name	= "s3c2440-i2c",
+	},
@@ -920,3 +921,6 @@
-	ret = driver_register(&s3c2410_i2c_driver);
-	if (ret == 0)
-		ret = driver_register(&s3c2440_i2c_driver); 
+	ret = platform_driver_register(&s3c2410_i2c_driver);
+	if (ret == 0) {
+		ret = platform_driver_register(&s3c2440_i2c_driver);
+		if (ret)
+			platform_driver_unregister(&s3c2410_i2c_driver);
+	}
@@ -929,2 +933,2 @@
-	driver_unregister(&s3c2410_i2c_driver);
-	driver_unregister(&s3c2440_i2c_driver);
+	platform_driver_unregister(&s3c2410_i2c_driver);
+	platform_driver_unregister(&s3c2440_i2c_driver);
--- ./projects/linux/linux-2.6.15/drivers/i2c/busses/i2c-s3c2410.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/i2c/busses/i2c-s3c2410.c	2006-03-20 06:53:29.000000000 +0100
@@ -36,0 +37 @@
+#include <linux/clk.h>
@@ -42 +42,0 @@
-#include <asm/hardware/clock.h>
@@ -741 +740,0 @@
-		clk_unuse(i2c->clk);
@@ -781 +779,0 @@
-	clk_use(i2c->clk);
--- ./projects/linux/linux-2.6.17/drivers/i2c/busses/i2c-s3c2410.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/i2c/busses/i2c-s3c2410.c	2006-09-20 05:42:06.000000000 +0200
@@ -23 +22,0 @@
-#include <linux/config.h>
@@ -832 +831 @@
-	ret = request_irq(res->start, s3c24xx_i2c_irq, SA_INTERRUPT,
+	ret = request_irq(res->start, s3c24xx_i2c_irq, IRQF_DISABLED,
--- ./projects/linux/linux-2.6.18/drivers/i2c/busses/i2c-s3c2410.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/i2c/busses/i2c-s3c2410.c	2006-11-29 22:57:37.000000000 +0100
@@ -426,2 +426 @@
-static irqreturn_t s3c24xx_i2c_irq(int irqno, void *dev_id,
-				   struct pt_regs *regs)
+static irqreturn_t s3c24xx_i2c_irq(int irqno, void *dev_id)
@@ -569 +568 @@
-static struct i2c_algorithm s3c24xx_i2c_algorithm = {
+static const struct i2c_algorithm s3c24xx_i2c_algorithm = {
--- ./projects/linux/linux-2.6.20/drivers/i2c/busses/i2c-s3c2410.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/i2c/busses/i2c-s3c2410.c	2007-04-26 05:08:32.000000000 +0200
@@ -31 +30,0 @@
-#include <linux/sched.h>
--- ./projects/linux/linux-2.6.21/drivers/i2c/busses/i2c-s3c2410.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/i2c/busses/i2c-s3c2410.c	2007-07-09 01:32:17.000000000 +0200
@@ -63,0 +64,2 @@
+	unsigned int		tx_setup;
+
@@ -202,2 +204,5 @@
-	// delay a bit and reset iiccon before setting start (per samsung)
-	udelay(1);
+	/* delay here to ensure the data byte has gotten onto the bus
+	 * before the transaction is started */
+
+	ndelay(i2c->tx_setup);
+
@@ -325 +330,9 @@
-			
+
+			/* delay after writing the byte to allow the
+			 * data setup time on the bus, as writing the
+			 * data to the register causes the first bit
+			 * to appear on SDA, and SCL will change as
+			 * soon as the interrupt is acknowledged */
+
+			ndelay(i2c->tx_setup);
+
@@ -573,3 +586,4 @@
-	.lock	= SPIN_LOCK_UNLOCKED,
-	.wait	= __WAIT_QUEUE_HEAD_INITIALIZER(s3c24xx_i2c.wait),
-	.adap	= {
+	.lock		= __SPIN_LOCK_UNLOCKED(s3c24xx_i2c.lock),
+	.wait		= __WAIT_QUEUE_HEAD_INITIALIZER(s3c24xx_i2c.wait),
+	.tx_setup	= 50,
+	.adap		= {
@@ -734,20 +747,0 @@
-static void s3c24xx_i2c_free(struct s3c24xx_i2c *i2c)
-{
-	if (i2c->clk != NULL && !IS_ERR(i2c->clk)) {
-		clk_disable(i2c->clk);
-		clk_put(i2c->clk);
-		i2c->clk = NULL;
-	}
-
-	if (i2c->regs != NULL) {
-		iounmap(i2c->regs);
-		i2c->regs = NULL;
-	}
-
-	if (i2c->ioarea != NULL) {
-		release_resource(i2c->ioarea);
-		kfree(i2c->ioarea);
-		i2c->ioarea = NULL;
-	}
-}
-
@@ -772 +766 @@
-		goto out;
+		goto err_noclk;
@@ -785 +779 @@
-		goto out;
+		goto err_clk;
@@ -794 +788 @@
-		goto out;
+		goto err_clk;
@@ -802 +796 @@
-		goto out;
+		goto err_ioarea;
@@ -816 +810 @@
-		goto out;
+		goto err_iomap;
@@ -826 +820 @@
-		goto out;
+		goto err_iomap;
@@ -834 +828 @@
-		goto out;
+		goto err_iomap;
@@ -839 +833,2 @@
-	dev_dbg(&pdev->dev, "irq resource %p (%ld)\n", res, res->start);
+	dev_dbg(&pdev->dev, "irq resource %p (%lu)\n", res,
+		(unsigned long)res->start);
@@ -844 +839 @@
-		goto out;
+		goto err_irq;
@@ -849,0 +845 @@
+	return 0;
@@ -851,3 +847,5 @@
- out:
-	if (ret < 0)
-		s3c24xx_i2c_free(i2c);
+ err_irq:
+	free_irq(i2c->irq->start, i2c);
+
+ err_iomap:
+	iounmap(i2c->regs);
@@ -854,0 +853,9 @@
+ err_ioarea:
+	release_resource(i2c->ioarea);
+	kfree(i2c->ioarea);
+
+ err_clk:
+	clk_disable(i2c->clk);
+	clk_put(i2c->clk);
+
+ err_noclk:
@@ -866,5 +873,11 @@
-	
-	if (i2c != NULL) {
-		s3c24xx_i2c_free(i2c);
-		platform_set_drvdata(pdev, NULL);
-	}
+
+	i2c_del_adapter(&i2c->adap);
+	free_irq(i2c->irq->start, i2c);
+
+	clk_disable(i2c->clk);
+	clk_put(i2c->clk);
+
+	iounmap(i2c->regs);
+
+	release_resource(i2c->ioarea);
+	kfree(i2c->ioarea);
--- ./projects/linux/linux-2.6.22/drivers/i2c/busses/i2c-s3c2410.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/i2c/busses/i2c-s3c2410.c	2007-10-09 22:31:38.000000000 +0200
@@ -42,2 +42,2 @@
-#include <asm/arch/regs-iic.h>
-#include <asm/arch/iic.h>
+#include <asm/plat-s3c/regs-iic.h>
+#include <asm/plat-s3c/iic.h>
--- ./projects/linux/linux-2.6.25/drivers/i2c/busses/i2c-s3c2410.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/i2c/busses/i2c-s3c2410.c	2008-07-13 23:51:29.000000000 +0200
@@ -279 +279 @@
-		dev_err(i2c->dev, "%s: called in STATE_IDLE\n", __FUNCTION__);
+		dev_err(i2c->dev, "%s: called in STATE_IDLE\n", __func__);
@@ -284 +284 @@
-		dev_err(i2c->dev, "%s: called in STATE_STOP\n", __FUNCTION__);
+		dev_err(i2c->dev, "%s: called in STATE_STOP\n", __func__);
@@ -293 +293 @@
-		if (iicstat  & S3C2410_IICSTAT_LASTBIT &&
+		if (iicstat & S3C2410_IICSTAT_LASTBIT &&
@@ -298 +298 @@
-			s3c24xx_i2c_stop(i2c, -EREMOTEIO);
+			s3c24xx_i2c_stop(i2c, -ENXIO);
@@ -308 +308 @@
-		 * (used by the i2c probe to find devices */
+		 * as this is used by the i2c probe to find devices. */
@@ -325,0 +326,9 @@
+		if (!(i2c->msg->flags & I2C_M_IGNORE_NAK)) {
+			if (iicstat & S3C2410_IICSTAT_LASTBIT) {
+				dev_dbg(i2c->dev, "WRITE: No Ack\n");
+
+				s3c24xx_i2c_stop(i2c, -ECONNREFUSED);
+				goto out_ack;
+			}
+		}
+
@@ -326,0 +336 @@
+
@@ -380,11 +389,0 @@
-		if (!(i2c->msg->flags & I2C_M_IGNORE_NAK) &&
-		    !(is_msglast(i2c) && is_lastmsg(i2c))) {
-
-			if (iicstat & S3C2410_IICSTAT_LASTBIT) {
-				dev_dbg(i2c->dev, "READ: No Ack\n");
-
-				s3c24xx_i2c_stop(i2c, -ECONNREFUSED);
-				goto out_ack;
-			}
-		}
-
@@ -950,0 +950,2 @@
+MODULE_ALIAS("platform:s3c2410-i2c");
+MODULE_ALIAS("platform:s3c2440-i2c");
--- ./projects/linux/linux-2.6.26/drivers/i2c/busses/i2c-s3c2410.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/i2c/busses/i2c-s3c2410.c	2008-10-10 00:13:53.000000000 +0200
@@ -35,0 +36 @@
+#include <linux/cpufreq.h>
@@ -37 +38 @@
-#include <asm/hardware.h>
+#include <mach/hardware.h>
@@ -41 +42 @@
-#include <asm/arch/regs-gpio.h>
+#include <mach/regs-gpio.h>
@@ -66,0 +68 @@
+	unsigned long		clkrate;
@@ -73,0 +76,4 @@
+
+#ifdef CONFIG_CPU_FREQ
+	struct notifier_block	freq_transition;
+#endif
@@ -503,0 +510,3 @@
+	if (!readl(i2c->regs + S3C2410_IICCON) & S3C2410_IICCON_IRQEN)
+		return -EIO;
+
@@ -593 +602 @@
-		.class			= I2C_CLASS_HWMON,
+		.class			= I2C_CLASS_HWMON | I2C_CLASS_SPD,
@@ -639 +648 @@
-/* s3c24xx_i2c_getdivisor
+/* s3c24xx_i2c_clockrate
@@ -646,4 +655 @@
-static int s3c24xx_i2c_getdivisor(struct s3c24xx_i2c *i2c,
-				  struct s3c2410_platform_i2c *pdata,
-				  unsigned long *iicon,
-				  unsigned int *got)
+static int s3c24xx_i2c_clockrate(struct s3c24xx_i2c *i2c, unsigned int *got)
@@ -650,0 +657 @@
+	struct s3c2410_platform_i2c *pdata;
@@ -652 +658,0 @@
-	
@@ -653,0 +660 @@
+	u32 iiccon;
@@ -656,0 +664,3 @@
+	i2c->clkrate = clkin;
+
+	pdata = s3c24xx_i2c_get_platformdata(i2c->adap.dev.parent);
@@ -659 +669 @@
-	dev_dbg(i2c->dev,  "pdata %p, freq %lu %lu..%lu\n",
+	dev_dbg(i2c->dev, "pdata %p, freq %lu %lu..%lu\n",
@@ -691,2 +701,65 @@
-	*iicon |= (divs-1);
-	*iicon |= (div1 == 512) ? S3C2410_IICCON_TXDIV_512 : 0;
+
+	iiccon = readl(i2c->regs + S3C2410_IICCON);
+	iiccon &= ~(S3C2410_IICCON_SCALEMASK | S3C2410_IICCON_TXDIV_512);
+	iiccon |= (divs-1);
+
+	if (div1 == 512)
+		iiccon |= S3C2410_IICCON_TXDIV_512;
+
+	writel(iiccon, i2c->regs + S3C2410_IICCON);
+
+	return 0;
+}
+
+#ifdef CONFIG_CPU_FREQ
+
+#define freq_to_i2c(_n) container_of(_n, struct s3c24xx_i2c, freq_transition)
+
+static int s3c24xx_i2c_cpufreq_transition(struct notifier_block *nb,
+					  unsigned long val, void *data)
+{
+	struct s3c24xx_i2c *i2c = freq_to_i2c(nb);
+	unsigned long flags;
+	unsigned int got;
+	int delta_f;
+	int ret;
+
+	delta_f = clk_get_rate(i2c->clk) - i2c->clkrate;
+
+	/* if we're post-change and the input clock has slowed down
+	 * or at pre-change and the clock is about to speed up, then
+	 * adjust our clock rate. <0 is slow, >0 speedup.
+	 */
+
+	if ((val == CPUFREQ_POSTCHANGE && delta_f < 0) ||
+	    (val == CPUFREQ_PRECHANGE && delta_f > 0)) {
+		spin_lock_irqsave(&i2c->lock, flags);
+		ret = s3c24xx_i2c_clockrate(i2c, &got);
+		spin_unlock_irqrestore(&i2c->lock, flags);
+
+		if (ret < 0)
+			dev_err(i2c->dev, "cannot find frequency\n");
+		else
+			dev_info(i2c->dev, "setting freq %d\n", got);
+	}
+
+	return 0;
+}
+
+static inline int s3c24xx_i2c_register_cpufreq(struct s3c24xx_i2c *i2c)
+{
+	i2c->freq_transition.notifier_call = s3c24xx_i2c_cpufreq_transition;
+
+	return cpufreq_register_notifier(&i2c->freq_transition,
+					 CPUFREQ_TRANSITION_NOTIFIER);
+}
+
+static inline void s3c24xx_i2c_deregister_cpufreq(struct s3c24xx_i2c *i2c)
+{
+	cpufreq_unregister_notifier(&i2c->freq_transition,
+				    CPUFREQ_TRANSITION_NOTIFIER);
+}
+
+#else
+static inline int s3c24xx_i2c_register_cpufreq(struct s3c24xx_i2c *i2c)
+{
@@ -695,0 +769,5 @@
+static inline void s3c24xx_i2c_deregister_cpufreq(struct s3c24xx_i2c *i2c)
+{
+}
+#endif
+
@@ -721,0 +800,2 @@
+	writel(iicon, i2c->regs + S3C2410_IICCON);
+
@@ -724 +804,2 @@
-	if (s3c24xx_i2c_getdivisor(i2c, pdata, &iicon, &freq) != 0) {
+	if (s3c24xx_i2c_clockrate(i2c, &freq) != 0) {
+		writel(0, i2c->regs + S3C2410_IICCON);
@@ -733,2 +813,0 @@
-	
-	writel(iicon, i2c->regs + S3C2410_IICCON);
@@ -754,0 +834 @@
+	struct s3c2410_platform_i2c *pdata;
@@ -757,0 +838,2 @@
+	pdata = s3c24xx_i2c_get_platformdata(&pdev->dev);
+
@@ -835 +917 @@
-	ret = i2c_add_adapter(&i2c->adap);
+	ret = s3c24xx_i2c_register_cpufreq(i2c);
@@ -837 +919 @@
-		dev_err(&pdev->dev, "failed to add bus to i2c core\n");
+		dev_err(&pdev->dev, "failed to register cpufreq notifier\n");
@@ -840,0 +923,14 @@
+	/* Note, previous versions of the driver used i2c_add_adapter()
+	 * to add the bus at any number. We now pass the bus number via
+	 * the platform data, so if unset it will now default to always
+	 * being bus 0.
+	 */
+
+	i2c->adap.nr = pdata->bus_num;
+
+	ret = i2c_add_numbered_adapter(&i2c->adap);
+	if (ret < 0) {
+		dev_err(&pdev->dev, "failed to add bus to i2c core\n");
+		goto err_cpufreq;
+	}
+
@@ -845,0 +942,3 @@
+ err_cpufreq:
+	s3c24xx_i2c_deregister_cpufreq(i2c);
+
@@ -872,0 +972,2 @@
+	s3c24xx_i2c_deregister_cpufreq(i2c);
+
--- ./projects/linux/linux-2.6.27/drivers/i2c/busses/i2c-s3c2410.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/i2c/busses/i2c-s3c2410.c	2008-12-25 00:26:37.000000000 +0100
@@ -58,0 +59 @@
+	unsigned int		suspended:1;
@@ -510 +511 @@
-	if (!readl(i2c->regs + S3C2410_IICCON) & S3C2410_IICCON_IRQEN)
+	if (i2c->suspended)
@@ -988,0 +990,8 @@
+static int s3c24xx_i2c_suspend_late(struct platform_device *dev,
+				    pm_message_t msg)
+{
+	struct s3c24xx_i2c *i2c = platform_get_drvdata(dev);
+	i2c->suspended = 1;
+	return 0;
+}
+
@@ -993,2 +1002,2 @@
-	if (i2c != NULL)
-		s3c24xx_i2c_init(i2c);
+	i2c->suspended = 0;
+	s3c24xx_i2c_init(i2c);
@@ -999,0 +1009 @@
+#define s3c24xx_i2c_suspend_late NULL
@@ -1007,0 +1018 @@
+	.suspend_late	= s3c24xx_i2c_suspend_late,
@@ -1017,0 +1029 @@
+	.suspend_late	= s3c24xx_i2c_suspend_late,
--- ./projects/linux/linux-2.6.28/drivers/i2c/busses/i2c-s3c2410.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/i2c/busses/i2c-s3c2410.c	2009-03-24 00:12:14.000000000 +0100
@@ -38 +37,0 @@
-#include <mach/hardware.h>
@@ -42,3 +41,2 @@
-#include <mach/regs-gpio.h>
-#include <asm/plat-s3c/regs-iic.h>
-#include <asm/plat-s3c/iic.h>
+#include <plat/regs-iic.h>
+#include <plat/iic.h>
@@ -66,0 +65 @@
+	unsigned int		irq;
@@ -74 +72,0 @@
-	struct resource		*irq;
@@ -83,10 +81 @@
-/* default platform data to use if not supplied in the platform_device
-*/
-
-static struct s3c2410_platform_i2c s3c24xx_i2c_default_platform = {
-	.flags		= 0,
-	.slave_addr	= 0x10,
-	.bus_freq	= 100*1000,
-	.max_freq	= 400*1000,
-	.sda_delay	= S3C2410_IICLC_SDA_DELAY5 | S3C2410_IICLC_FILTER_ON,
-};
+/* default platform data removed, dev should always carry data. */
@@ -106,15 +94,0 @@
-
-/* s3c24xx_i2c_get_platformdata
- *
- * get the platform data associated with the given device, or return
- * the default if there is none
-*/
-
-static inline struct s3c2410_platform_i2c *s3c24xx_i2c_get_platformdata(struct device *dev)
-{
-	if (dev->platform_data != NULL)
-		return (struct s3c2410_platform_i2c *)dev->platform_data;
-
-	return &s3c24xx_i2c_default_platform;
-}
-
@@ -133 +107 @@
-	i2c->msg_idx ++;
+	i2c->msg_idx++;
@@ -144 +118 @@
-	
+
@@ -147 +120,0 @@
-
@@ -153 +126 @@
-	
+
@@ -156 +128,0 @@
-
@@ -164 +136 @@
-	
+
@@ -172 +144 @@
-	
+
@@ -180 +152 @@
- * put the start of a message onto the bus 
+ * put the start of a message onto the bus
@@ -183 +155 @@
-static void s3c24xx_i2c_message_start(struct s3c24xx_i2c *i2c, 
+static void s3c24xx_i2c_message_start(struct s3c24xx_i2c *i2c,
@@ -202 +174 @@
-	// todo - check for wether ack wanted or not
+	/* todo - check for wether ack wanted or not */
@@ -207 +179 @@
-	
+
@@ -210 +182 @@
-	
+
@@ -218,2 +190,2 @@
-	
-	stat |=  S3C2410_IICSTAT_START;
+
+	stat |= S3C2410_IICSTAT_START;
@@ -230 +202 @@
-	iicstat &= ~ S3C2410_IICSTAT_START;
+	iicstat &= ~S3C2410_IICSTAT_START;
@@ -232 +204 @@
-	
+
@@ -234 +206 @@
-	
+
@@ -244 +216 @@
- * returns TRUE if the current message is the last in the set 
+ * returns TRUE if the current message is the last in the set
@@ -292 +264 @@
-		s3c24xx_i2c_disable_irq(i2c);		
+		s3c24xx_i2c_disable_irq(i2c);
@@ -299 +271 @@
-		
+
@@ -325 +297 @@
-		/* fall through to the write state, as we will need to 
+		/* fall through to the write state, as we will need to
@@ -342 +314 @@
-	retry_write:
+ retry_write:
@@ -362 +334 @@
-			i2c->msg_idx ++;
+			i2c->msg_idx++;
@@ -364 +336 @@
-			
+
@@ -378 +349,0 @@
-			
@@ -392 +363 @@
-		/* we have a byte of data in the data register, do 
+		/* we have a byte of data in the data register, do
@@ -400 +371 @@
-	prepare_read:
+ prepare_read:
@@ -406 +377 @@
-			
+
@@ -432 +403 @@
-	tmp = readl(i2c->regs + S3C2410_IICCON);	
+	tmp = readl(i2c->regs + S3C2410_IICCON);
@@ -453 +424 @@
-		// deal with arbitration loss
+		/* deal with arbitration loss */
@@ -460 +431 @@
-		tmp = readl(i2c->regs + S3C2410_IICCON);	
+		tmp = readl(i2c->regs + S3C2410_IICCON);
@@ -465 +436 @@
-	
+
@@ -488 +459 @@
-		
+
@@ -495,3 +465,0 @@
-	dev_dbg(i2c->dev, "timeout: GPEDAT is %08x\n",
-		__raw_readl(S3C2410_GPEDAT));
-
@@ -506 +474,2 @@
-static int s3c24xx_i2c_doxfer(struct s3c24xx_i2c *i2c, struct i2c_msg *msgs, int num)
+static int s3c24xx_i2c_doxfer(struct s3c24xx_i2c *i2c,
+			      struct i2c_msg *msgs, int num)
@@ -532 +501 @@
-	
+
@@ -537 +506 @@
-	/* having these next two as dev_err() makes life very 
+	/* having these next two as dev_err() makes life very
@@ -594,13 +562,0 @@
-static struct s3c24xx_i2c s3c24xx_i2c = {
-	.lock		= __SPIN_LOCK_UNLOCKED(s3c24xx_i2c.lock),
-	.wait		= __WAIT_QUEUE_HEAD_INITIALIZER(s3c24xx_i2c.wait),
-	.tx_setup	= 50,
-	.adap		= {
-		.name			= "s3c2410-i2c",
-		.owner			= THIS_MODULE,
-		.algo			= &s3c24xx_i2c_algorithm,
-		.retries		= 2,
-		.class			= I2C_CLASS_HWMON | I2C_CLASS_SPD,
-	},
-};
-
@@ -646 +602 @@
-	return (diff >= -2 && diff <= 2);
+	return diff >= -2 && diff <= 2;
@@ -658 +614 @@
-	struct s3c2410_platform_i2c *pdata;
+	struct s3c2410_platform_i2c *pdata = i2c->dev->platform_data;
@@ -666,2 +621,0 @@
-
-	pdata = s3c24xx_i2c_get_platformdata(i2c->adap.dev.parent);
@@ -669 +623 @@
-     
+
@@ -777 +731 @@
- * initialise the controller, set the IO lines and frequency 
+ * initialise the controller, set the IO lines and frequency
@@ -788 +742 @@
-	pdata = s3c24xx_i2c_get_platformdata(i2c->adap.dev.parent);
+	pdata = i2c->dev->platform_data;
@@ -792,2 +746,2 @@
-	s3c2410_gpio_cfgpin(S3C2410_GPE15, S3C2410_GPE15_IICSDA);
-	s3c2410_gpio_cfgpin(S3C2410_GPE14, S3C2410_GPE14_IICSCL);
+	if (pdata->cfg_gpio)
+		pdata->cfg_gpio(to_platform_device(i2c->dev));
@@ -796 +750 @@
-	
+
@@ -834 +788 @@
-	struct s3c24xx_i2c *i2c = &s3c24xx_i2c;
+	struct s3c24xx_i2c *i2c;
@@ -839 +793,21 @@
-	pdata = s3c24xx_i2c_get_platformdata(&pdev->dev);
+	pdata = pdev->dev.platform_data;
+	if (!pdata) {
+		dev_err(&pdev->dev, "no platform data\n");
+		return -EINVAL;
+	}
+
+	i2c = kzalloc(sizeof(struct s3c24xx_i2c), GFP_KERNEL);
+	if (!i2c) {
+		dev_err(&pdev->dev, "no memory for state\n");
+		return -ENOMEM;
+	}
+
+	strlcpy(i2c->adap.name, "s3c2410-i2c", sizeof(i2c->adap.name));
+	i2c->adap.owner   = THIS_MODULE;
+	i2c->adap.algo    = &s3c24xx_i2c_algorithm;
+	i2c->adap.retries = 2;
+	i2c->adap.class   = I2C_CLASS_HWMON | I2C_CLASS_SPD;
+	i2c->tx_setup     = 50;
+
+	spin_lock_init(&i2c->lock);
+	init_waitqueue_head(&i2c->wait);
@@ -881 +855,2 @@
-	dev_dbg(&pdev->dev, "registers %p (%p, %p)\n", i2c->regs, i2c->ioarea, res);
+	dev_dbg(&pdev->dev, "registers %p (%p, %p)\n",
+		i2c->regs, i2c->ioarea, res);
@@ -895 +870 @@
-	 * ensure no current IRQs pending 
+	 * ensure no current IRQs pending
@@ -898,2 +873,2 @@
-	res = platform_get_resource(pdev, IORESOURCE_IRQ, 0);
-	if (res == NULL) {
+	i2c->irq = ret = platform_get_irq(pdev, 0);
+	if (ret <= 0) {
@@ -901 +875,0 @@
-		ret = -ENOENT;
@@ -905,2 +879,2 @@
-	ret = request_irq(res->start, s3c24xx_i2c_irq, IRQF_DISABLED,
-			  pdev->name, i2c);
+	ret = request_irq(i2c->irq, s3c24xx_i2c_irq, IRQF_DISABLED,
+			  dev_name(&pdev->dev), i2c);
@@ -909 +883 @@
-		dev_err(&pdev->dev, "cannot claim IRQ\n");
+		dev_err(&pdev->dev, "cannot claim IRQ %d\n", i2c->irq);
@@ -913,5 +886,0 @@
-	i2c->irq = res;
-		
-	dev_dbg(&pdev->dev, "irq resource %p (%lu)\n", res,
-		(unsigned long)res->start);
-
@@ -940 +909 @@
-	dev_info(&pdev->dev, "%s: S3C I2C adapter\n", i2c->adap.dev.bus_id);
+	dev_info(&pdev->dev, "%s: S3C I2C adapter\n", dev_name(&i2c->adap.dev));
@@ -947 +916 @@
-	free_irq(i2c->irq->start, i2c);
+	free_irq(i2c->irq, i2c);
@@ -960,0 +930 @@
+	kfree(i2c);
@@ -976 +946 @@
-	free_irq(i2c->irq->start, i2c);
+	free_irq(i2c->irq, i2c);
@@ -984,0 +955 @@
+	kfree(i2c);
--- ./projects/linux/linux-2.6.29/drivers/i2c/busses/i2c-s3c2410.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/i2c/busses/i2c-s3c2410.c	2009-06-27 11:32:32.000000000 +0200
@@ -3 +3 @@
- * Copyright (C) 2004,2005 Simtec Electronics
+ * Copyright (C) 2004,2005,2009 Simtec Electronics
@@ -593,12 +592,0 @@
-/* freq_acceptable
- *
- * test wether a frequency is within the acceptable range of error
-*/
-
-static inline int freq_acceptable(unsigned int freq, unsigned int wanted)
-{
-	int diff = freq - wanted;
-
-	return diff >= -2 && diff <= 2;
-}
-
@@ -616,0 +605 @@
+	unsigned long target_frequency;
@@ -619 +607,0 @@
-	int start, end;
@@ -624,9 +612 @@
-	dev_dbg(i2c->dev, "pdata %p, freq %lu %lu..%lu\n",
-		 pdata, pdata->bus_freq, pdata->min_freq, pdata->max_freq);
-
-	if (pdata->bus_freq != 0) {
-		freq = s3c24xx_i2c_calcdivisor(clkin, pdata->bus_freq/1000,
-					       &div1, &divs);
-		if (freq_acceptable(freq, pdata->bus_freq/1000))
-			goto found;
-	}
+	dev_dbg(i2c->dev, "pdata desired frequency %lu\n", pdata->frequency);
@@ -634 +614 @@
-	/* ok, we may have to search for something suitable... */
+	target_frequency = pdata->frequency ? pdata->frequency : 100000;
@@ -636,2 +616 @@
-	start = (pdata->max_freq == 0) ? pdata->bus_freq : pdata->max_freq;
-	end = pdata->min_freq;
+	target_frequency /= 1000; /* Target frequency now in KHz */
@@ -639,2 +618 @@
-	start /= 1000;
-	end /= 1000;
+	freq = s3c24xx_i2c_calcdivisor(clkin, target_frequency, &div1, &divs);
@@ -642,6 +620,5 @@
-	/* search loop... */
-
-	for (; start > end; start--) {
-		freq = s3c24xx_i2c_calcdivisor(clkin, start, &div1, &divs);
-		if (freq_acceptable(freq, start))
-			goto found;
+	if (freq > target_frequency) {
+		dev_err(i2c->dev,
+			"Unable to achieve desired frequency %luKHz."	\
+			" Lowest achievable %dKHz\n", target_frequency, freq);
+		return -EINVAL;
@@ -650,5 +626,0 @@
-	/* cannot find frequency spec */
-
-	return -EINVAL;
-
- found:
@@ -665,0 +638,17 @@
+	if (s3c24xx_i2c_is2440(i2c)) {
+		unsigned long sda_delay;
+
+		if (pdata->sda_delay) {
+			sda_delay = (freq / 1000) * pdata->sda_delay;
+			sda_delay /= 1000000;
+			sda_delay = DIV_ROUND_UP(sda_delay, 5);
+			if (sda_delay > 3)
+				sda_delay = 3;
+			sda_delay |= S3C2410_IICLC_FILTER_ON;
+		} else
+			sda_delay = 0;
+
+		dev_dbg(i2c->dev, "IICLC=%08lx\n", sda_delay);
+		writel(sda_delay, i2c->regs + S3C2440_IICLC);
+	}
+
@@ -772,5 +761,2 @@
-	if (s3c24xx_i2c_is2440(i2c)) {
-		dev_dbg(i2c->dev, "S3C2440_IICLC=%08x\n", pdata->sda_delay);
-
-		writel(pdata->sda_delay, i2c->regs + S3C2440_IICLC);
-	}
+	if (s3c24xx_i2c_is2440(i2c))
+		writel(0x0, i2c->regs + S3C2440_IICLC);
@@ -1020,0 +1007 @@
+subsys_initcall(i2c_adap_s3c_init);
@@ -1027,2 +1013,0 @@
-
-module_init(i2c_adap_s3c_init);
--- ./projects/linux/linux-2.6.19/drivers/isdn/act2000/module.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/isdn/act2000/module.c	2007-02-04 19:44:54.000000000 +0100
@@ -195 +195 @@
-act2000_transmit(struct act2000_card *card)
+act2000_transmit(struct work_struct *work)
@@ -196,0 +197,3 @@
+	struct act2000_card *card =
+		container_of(work, struct act2000_card, snd_tq);
+
@@ -210 +213 @@
-act2000_receive(struct act2000_card *card)
+act2000_receive(struct work_struct *work)
@@ -211,0 +215,3 @@
+	struct act2000_card *card =
+		container_of(work, struct act2000_card, poll_tq);
+
@@ -230 +236 @@
-	act2000_receive(card);
+	act2000_receive(&card->poll_tq);
@@ -570 +576 @@
-        if (!(card = (act2000_card *) kmalloc(sizeof(act2000_card), GFP_KERNEL))) {
+        if (!(card = kzalloc(sizeof(act2000_card), GFP_KERNEL))) {
@@ -575 +580,0 @@
-        memset((char *) card, 0, sizeof(act2000_card));
@@ -581,3 +586,3 @@
-	INIT_WORK(&card->snd_tq, (void *) (void *) act2000_transmit, card);
-	INIT_WORK(&card->rcv_tq, (void *) (void *) actcapi_dispatch, card);
-	INIT_WORK(&card->poll_tq, (void *) (void *) act2000_receive, card);
+	INIT_WORK(&card->snd_tq, act2000_transmit);
+	INIT_WORK(&card->rcv_tq, actcapi_dispatch);
+	INIT_WORK(&card->poll_tq, act2000_receive);
--- ./projects/linux/linux-2.6.21/drivers/isdn/act2000/module.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/isdn/act2000/module.c	2007-07-09 01:32:17.000000000 +0200
@@ -445 +445 @@
-		memcpy(skb_put(xmit_skb, len), skb->data, len);
+		skb_copy_from_linear_data(skb, skb_put(xmit_skb, len), len);
--- ./projects/linux/linux-2.6.24/drivers/isdn/act2000/module.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/isdn/act2000/module.c	2008-04-17 04:49:44.000000000 +0200
@@ -313 +313 @@
-			if (!card->flags & ACT2000_FLAGS_RUNNING)
+			if (!(card->flags & ACT2000_FLAGS_RUNNING))
@@ -342 +342 @@
-			if (!card->flags & ACT2000_FLAGS_RUNNING)
+			if (!(card->flags & ACT2000_FLAGS_RUNNING))
@@ -350 +350 @@
-			if (!card->flags & ACT2000_FLAGS_RUNNING)
+			if (!(card->flags & ACT2000_FLAGS_RUNNING))
@@ -354 +354 @@
-			if (!card->flags & ACT2000_FLAGS_RUNNING)
+			if (!(card->flags & ACT2000_FLAGS_RUNNING))
@@ -369 +369 @@
-			if (!card->flags & ACT2000_FLAGS_RUNNING)
+			if (!(card->flags & ACT2000_FLAGS_RUNNING))
@@ -389 +389 @@
-			if (!card->flags & ACT2000_FLAGS_RUNNING)
+			if (!(card->flags & ACT2000_FLAGS_RUNNING))
@@ -397 +397 @@
-			if (!card->flags & ACT2000_FLAGS_RUNNING)
+			if (!(card->flags & ACT2000_FLAGS_RUNNING))
@@ -404 +404 @@
-			if (!card->flags & ACT2000_FLAGS_RUNNING)
+			if (!(card->flags & ACT2000_FLAGS_RUNNING))
@@ -527 +527 @@
-                if (!card->flags & ACT2000_FLAGS_RUNNING)
+                if (!(card->flags & ACT2000_FLAGS_RUNNING))
@@ -542 +542 @@
-                if (!card->flags & ACT2000_FLAGS_RUNNING)
+                if (!(card->flags & ACT2000_FLAGS_RUNNING))
@@ -557 +557 @@
-                if (!card->flags & ACT2000_FLAGS_RUNNING)
+                if (!(card->flags & ACT2000_FLAGS_RUNNING))
--- ./projects/linux/linux-2.6.20/drivers/isdn/hardware/eicon/message.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/isdn/hardware/eicon/message.c	2007-04-26 05:08:32.000000000 +0200
@@ -256 +256 @@
-static byte remove_started = FALSE;
+static byte remove_started = false;
@@ -459 +459 @@
-      c = FALSE;
+      c = false;
@@ -464 +464 @@
-          c = TRUE;
+          c = true;
@@ -509 +509 @@
-          c = TRUE;
+          c = true;
@@ -515 +515 @@
-          c = TRUE;
+          c = true;
@@ -629 +629 @@
-    if(p>length) return TRUE;
+    if(p>length) return true;
@@ -632 +632 @@
-  return FALSE;
+  return false;
@@ -690 +690 @@
-    remove_started = TRUE;
+    remove_started = true;
@@ -1083 +1083 @@
-  ncci_remove (plci, 0, FALSE);
+  ncci_remove (plci, 0, false);
@@ -1229 +1229 @@
-      return FALSE;
+      return false;
@@ -1333 +1333 @@
-      if(ch==1 && LinkLayer!=3 && LinkLayer!=12) noCh = TRUE;
+      if(ch==1 && LinkLayer!=3 && LinkLayer!=12) noCh = true;
@@ -1384 +1384 @@
-            return FALSE;
+            return false;
@@ -1398 +1398 @@
-            return FALSE;
+            return false;
@@ -1402 +1402 @@
-        return FALSE;
+        return false;
@@ -1574 +1574 @@
-  return FALSE;
+  return false;
@@ -1627 +1627 @@
-  if(!appl)  return FALSE;
+  if(!appl)  return false;
@@ -1629 +1629 @@
-  return FALSE;
+  return false;
@@ -1705 +1705 @@
-  return FALSE;
+  return false;
@@ -1742 +1742 @@
-      return FALSE;
+      return false;
@@ -1772 +1772 @@
-      appl->NullCREnable  = TRUE;
+      appl->NullCREnable  = true;
@@ -1791 +1791 @@
-      return FALSE;
+      return false;
@@ -1814 +1814 @@
-  return FALSE;
+  return false;
@@ -1820 +1820 @@
-  return FALSE;
+  return false;
@@ -1831 +1831 @@
-  ret = FALSE;
+  ret = false;
@@ -1925 +1925 @@
-            return FALSE;
+            return false;
@@ -1975 +1975 @@
-              return FALSE;
+              return false;
@@ -2000 +2000 @@
-                return FALSE;
+                return false;
@@ -2006 +2006 @@
-                return FALSE;
+                return false;
@@ -2126 +2126 @@
-              return FALSE;
+              return false;
@@ -2268 +2268 @@
-              return FALSE;
+              return false;
@@ -2294 +2294 @@
-            appl->CDEnable = TRUE;
+            appl->CDEnable = true;
@@ -2301 +2301 @@
-            return FALSE;
+            return false;
@@ -2340 +2340 @@
-            return FALSE;
+            return false;
@@ -2459 +2459 @@
-            return FALSE;
+            return false;
@@ -2475 +2475 @@
-                rplci->cr_enquiry=TRUE;
+                rplci->cr_enquiry=true;
@@ -2490 +2490 @@
-              rplci->cr_enquiry=FALSE;
+              rplci->cr_enquiry=false;
@@ -2512 +2512 @@
-            return FALSE;
+            return false;
@@ -2527 +2527 @@
-                rplci->cr_enquiry=TRUE;
+                rplci->cr_enquiry=true;
@@ -2542 +2542 @@
-              rplci->cr_enquiry=FALSE;
+              rplci->cr_enquiry=false;
@@ -2559 +2559 @@
-            return FALSE;
+            return false;
@@ -2600 +2600 @@
-  return FALSE;
+  return false;
@@ -2606 +2606 @@
-  return FALSE;
+  return false;
@@ -2652 +2652 @@
-        return FALSE;
+        return false;
@@ -2687 +2687 @@
-            fax_info_change = FALSE;
+            fax_info_change = false;
@@ -2696 +2696 @@
-                fax_info_change = TRUE;
+                fax_info_change = true;
@@ -2712 +2712 @@
-                  fax_info_change = TRUE;
+                  fax_info_change = true;
@@ -2784 +2784 @@
-                fax_info_change = TRUE;
+                fax_info_change = true;
@@ -2790 +2790 @@
-                fax_info_change = TRUE;
+                fax_info_change = true;
@@ -2801 +2801 @@
-                  return FALSE;
+                  return false;
@@ -2806 +2806 @@
-                  return FALSE;
+                  return false;
@@ -2823 +2823 @@
-        return FALSE;
+        return false;
@@ -2840 +2840 @@
-  return FALSE;
+  return false;
@@ -2912 +2912 @@
-     return FALSE;
+     return false;
@@ -2935 +2935 @@
-        return FALSE;
+        return false;
@@ -2948 +2948 @@
-          plci->adjust_b_restore = FALSE;
+          plci->adjust_b_restore = false;
@@ -2955 +2955 @@
-  return FALSE;
+  return false;
@@ -2975 +2975 @@
-  return FALSE;
+  return false;
@@ -3007 +3007 @@
-        return FALSE;
+        return false;
@@ -3031 +3031 @@
-  return FALSE;
+  return false;
@@ -3087 +3087 @@
-  return FALSE;
+  return false;
@@ -3143 +3143 @@
-      return FALSE;
+      return false;
@@ -3164 +3164 @@
-  return FALSE;
+  return false;
@@ -3197 +3197 @@
-  return FALSE;
+  return false;
@@ -3238 +3238 @@
-  return FALSE;
+  return false;
@@ -3257 +3257 @@
-        return TRUE;
+        return true;
@@ -3262 +3262 @@
-  return FALSE;
+  return false;
@@ -3295 +3295 @@
-  return FALSE;
+  return false;
@@ -3381 +3381 @@
-              return FALSE;
+              return false;
@@ -3410 +3410 @@
-        return FALSE;
+        return false;
@@ -3415 +3415 @@
-  return FALSE;
+  return false;
@@ -3492 +3492 @@
-          plci->manufacturer = TRUE;
+          plci->manufacturer = true;
@@ -3523 +3523 @@
-                return FALSE;
+                return false;
@@ -3576 +3576 @@
-        plci->cr_enquiry = TRUE;
+        plci->cr_enquiry = true;
@@ -3742 +3742 @@
-  return FALSE;
+  return false;
@@ -3763 +3763 @@
-    return FALSE;
+    return false;
@@ -3814 +3814 @@
-  return FALSE;
+  return false;
@@ -3911 +3911 @@
-        control_rc (plci, 0, rc, ch, 0, TRUE);
+        control_rc (plci, 0, rc, ch, 0, true);
@@ -3918 +3918 @@
-            control_rc (plci, req, rc, ch, 0, TRUE);
+            control_rc (plci, req, rc, ch, 0, true);
@@ -3934 +3934 @@
-            control_rc (plci, 0, rc, ch, global_req, TRUE);
+            control_rc (plci, 0, rc, ch, global_req, true);
@@ -3939 +3939 @@
-            plci->data_sent = FALSE;
+            plci->data_sent = false;
@@ -3943 +3943 @@
-              control_rc (plci, req, rc, ch, 0, TRUE);
+              control_rc (plci, req, rc, ch, 0, true);
@@ -3948 +3948 @@
-            control_rc (plci, req, rc, ch, 0, TRUE);
+            control_rc (plci, req, rc, ch, 0, true);
@@ -3977 +3977 @@
-        control_rc (plci, 0, rc, ch, global_req, FALSE);
+        control_rc (plci, 0, rc, ch, global_req, false);
@@ -3982 +3982 @@
-        control_rc (plci, req, rc, ch, 0, FALSE);
+        control_rc (plci, req, rc, ch, 0, false);
@@ -4068,2 +4068,2 @@
-      plci->li_notify_update = FALSE;
-      mixer_notify_update (plci, FALSE);
+      plci->li_notify_update = false;
+      mixer_notify_update (plci, false);
@@ -4431 +4431 @@
-            appl->NullCREnable = FALSE;
+            appl->NullCREnable = false;
@@ -4444 +4444 @@
-            appl->NullCREnable = FALSE;
+            appl->NullCREnable = false;
@@ -4865 +4865 @@
-  byte force_mt_info = FALSE;
+  byte force_mt_info = false;
@@ -4936 +4936 @@
-      plci->cr_enquiry = FALSE;
+      plci->cr_enquiry = false;
@@ -5161 +5161 @@
-          application[i].CDEnable = FALSE;
+          application[i].CDEnable = false;
@@ -5378 +5378 @@
-          application[i].CDEnable = FALSE;
+          application[i].CDEnable = false;
@@ -5733 +5733 @@
-                        SendMultiIE(plci,Id,multi_pi_parms, PI, 0x210, TRUE));
+                        SendMultiIE(plci,Id,multi_pi_parms, PI, 0x210, true));
@@ -6120 +6120 @@
-        Info_Sent_Flag = TRUE;
+        Info_Sent_Flag = true;
@@ -6126 +6126 @@
-        Info_Sent_Flag = TRUE;
+        Info_Sent_Flag = true;
@@ -6132 +6132 @@
-        Info_Sent_Flag = TRUE;
+        Info_Sent_Flag = true;
@@ -6139 +6139 @@
-        Info_Sent_Flag = TRUE;
+        Info_Sent_Flag = true;
@@ -6145 +6145 @@
-        Info_Sent_Flag = TRUE;
+        Info_Sent_Flag = true;
@@ -6151 +6151 @@
-        Info_Sent_Flag = TRUE;
+        Info_Sent_Flag = true;
@@ -6315 +6315 @@
-          iesent=TRUE;
+          iesent=true;
@@ -6333 +6333 @@
-            iesent=TRUE;
+            iesent=true;
@@ -6343 +6343 @@
-      iesent=TRUE;
+      iesent=true;
@@ -6394 +6394 @@
-          iesent = TRUE;
+          iesent = true;
@@ -6406 +6406 @@
-          iesent = TRUE;
+          iesent = true;
@@ -6415 +6415 @@
-      iesent = TRUE;
+      iesent = true;
@@ -6815 +6815 @@
-          if (((T30_INFO   *)plci->NL.RBuffer->P)->code < sizeof(fax_info) / sizeof(fax_info[0]))
+	  if (((T30_INFO   *)plci->NL.RBuffer->P)->code < ARRAY_SIZE(fax_info))
@@ -6890 +6890 @@
-   fax_send_edata_ack = FALSE;
+   fax_send_edata_ack = false;
@@ -6931 +6931 @@
-     fax_send_edata_ack = FALSE;
+     fax_send_edata_ack = false;
@@ -7028 +7028 @@
-      plci->adjust_b_restore = FALSE;
+      plci->adjust_b_restore = false;
@@ -7044 +7044 @@
-    ncci_remove (plci, ncci, FALSE);
+    ncci_remove (plci, ncci, false);
@@ -7291 +7291 @@
-  plci->data_sent = FALSE;
+  plci->data_sent = false;
@@ -7298 +7298 @@
-  plci->manufacturer = FALSE;
+  plci->manufacturer = false;
@@ -7302 +7302 @@
-  plci->cr_enquiry = FALSE;
+  plci->cr_enquiry = false;
@@ -7975 +7975 @@
-    plci->adv_nl = TRUE;
+    plci->adv_nl = true;
@@ -8025 +8025 @@
-    plci->adv_nl = TRUE;
+    plci->adv_nl = true;
@@ -8843 +8843 @@
-            plci->data_sent = TRUE;
+            plci->data_sent = true;
@@ -8998,4 +8998,4 @@
-  if(!ie1 || ! ie2) return FALSE;
-  if(!ie1[0]) return FALSE;
-  for(i=0;i<(word)(ie1[0]+1);i++) if(ie1[i]!=ie2[i]) return FALSE;
-  return TRUE;
+  if(!ie1 || ! ie2) return false;
+  if(!ie1[0]) return false;
+  for(i=0;i<(word)(ie1[0]+1);i++) if(ie1[i]!=ie2[i]) return false;
+  return true;
@@ -9154 +9154 @@
-      a->AdvCodecFLAG = TRUE;
+      a->AdvCodecFLAG = true;
@@ -9186 +9186 @@
-        a->scom_appl_disable = TRUE;
+        a->scom_appl_disable = true;
@@ -9414 +9414 @@
-        this->NullCREnable = FALSE;
+        this->NullCREnable = false;
@@ -9436 +9436 @@
-  if(!plci) return TRUE;
+  if(!plci) return true;
@@ -9449 +9449 @@
-        ncci_remove (plci, 0, FALSE);
+        ncci_remove (plci, 0, false);
@@ -9459 +9459 @@
-      return TRUE;
+      return true;
@@ -9462 +9462 @@
-  return FALSE;
+  return false;
@@ -9567 +9567 @@
-#define DTMF_DIGIT_MAP_ENTRIES (sizeof(dtmf_digit_map) / sizeof(dtmf_digit_map[0]))
+#define DTMF_DIGIT_MAP_ENTRIES ARRAY_SIZE(dtmf_digit_map)
@@ -9818 +9818 @@
-        dtmf_enable_receiver (plci, FALSE);
+        dtmf_enable_receiver (plci, false);
@@ -10023 +10023 @@
-        return (FALSE);
+        return (false);
@@ -10072,2 +10072 @@
-        if (plci->dtmf_send_requests >=
-          sizeof(plci->dtmf_msg_number_queue) / sizeof(plci->dtmf_msg_number_queue[0]))
+        if (plci->dtmf_send_requests >= ARRAY_SIZE(plci->dtmf_msg_number_queue))
@@ -10082 +10081 @@
-        return (FALSE);
+        return (false);
@@ -10093 +10092 @@
-  return (FALSE);
+  return (false);
@@ -10845,4 +10844,4 @@
-  { LI_COEF_CH_CH, FALSE, FALSE },
-  { LI_COEF_CH_PC, FALSE, TRUE },
-  { LI_COEF_PC_CH, TRUE, FALSE },
-  { LI_COEF_PC_PC, TRUE, TRUE }
+  { LI_COEF_CH_CH, false, false },
+  { LI_COEF_CH_PC, false, true },
+  { LI_COEF_PC_CH, true, false },
+  { LI_COEF_PC_PC, true, true }
@@ -10919 +10918 @@
-    return (TRUE);
+    return (true);
@@ -10930 +10929 @@
-      return (FALSE);
+      return (false);
@@ -10972 +10971 @@
-        return (TRUE);
+        return (true);
@@ -11021 +11020 @@
-        } while ((n < sizeof(xconnect_write_prog) / sizeof(xconnect_write_prog[0]))
+        } while ((n < ARRAY_SIZE(xconnect_write_prog))
@@ -11023 +11022 @@
-        if (n == sizeof(xconnect_write_prog) / sizeof(xconnect_write_prog[0]))
+        if (n == ARRAY_SIZE(xconnect_write_prog))
@@ -11053 +11052 @@
-        return (TRUE);
+        return (true);
@@ -11093 +11092 @@
-        for (n = 0; n < sizeof(mixer_write_prog_bri) / sizeof(mixer_write_prog_bri[0]); n++)
+        for (n = 0; n < ARRAY_SIZE(mixer_write_prog_bri); n++)
@@ -11130 +11129 @@
-        return (TRUE);
+        return (true);
@@ -11143 +11142 @@
-        for (n = 0; n < sizeof(mixer_write_prog_pri) / sizeof(mixer_write_prog_pri[0]); n++)
+        for (n = 0; n < ARRAY_SIZE(mixer_write_prog_pri); n++)
@@ -11199 +11198 @@
-        for (n = 0; n < sizeof(mixer_write_prog_bri) / sizeof(mixer_write_prog_bri[0]); n++)
+        for (n = 0; n < ARRAY_SIZE(mixer_write_prog_bri); n++)
@@ -11235 +11234 @@
-  return (TRUE);
+  return (true);
@@ -11254 +11253 @@
-      plci->li_notify_update = TRUE;
+      plci->li_notify_update = true;
@@ -11280 +11279 @@
-        notify_plci->li_notify_update = TRUE;
+        notify_plci->li_notify_update = true;
@@ -11302 +11301 @@
-          notify_plci->li_notify_update = FALSE;
+          notify_plci->li_notify_update = false;
@@ -11307 +11306 @@
-      plci->li_notify_update = FALSE;
+      plci->li_notify_update = false;
@@ -11321 +11320 @@
-  plci->li_notify_update = FALSE;
+  plci->li_notify_update = false;
@@ -12162 +12161 @@
-        li_update_connect (Id, a, plci, plci_b_id, TRUE, li_flags);
+        li_update_connect (Id, a, plci, plci_b_id, true, li_flags);
@@ -12191 +12190 @@
-        li2_update_connect (Id, a, plci, UnMapId (Id), TRUE, li_flags);
+        li2_update_connect (Id, a, plci, UnMapId (Id), true, li_flags);
@@ -12227 +12226 @@
-            li2_update_connect (Id, a, plci, plci_b_id, TRUE, li_flags);
+            li2_update_connect (Id, a, plci, plci_b_id, true, li_flags);
@@ -12252 +12251 @@
-      mixer_notify_update (plci, TRUE);
+      mixer_notify_update (plci, true);
@@ -12258 +12257 @@
-      return (FALSE);
+      return (false);
@@ -12286 +12285 @@
-        li_update_connect (Id, a, plci, plci_b_id, FALSE, 0);
+        li_update_connect (Id, a, plci, plci_b_id, false, 0);
@@ -12348 +12347 @@
-            li2_update_connect (Id, a, plci, plci_b_id, FALSE, 0);
+            li2_update_connect (Id, a, plci, plci_b_id, false, 0);
@@ -12371 +12370 @@
-      mixer_notify_update (plci, TRUE);
+      mixer_notify_update (plci, true);
@@ -12377 +12376 @@
-      return (FALSE);
+      return (false);
@@ -12387 +12386 @@
-        return (FALSE);
+        return (false);
@@ -12395 +12394 @@
-        return (FALSE);
+        return (false);
@@ -12411 +12410 @@
-      return (FALSE);
+      return (false);
@@ -12421 +12420 @@
-  return (FALSE);
+  return (false);
@@ -12526 +12525 @@
-  mixer_notify_update (plci, TRUE);
+  mixer_notify_update (plci, true);
@@ -12550 +12549 @@
-    return (FALSE);
+    return (false);
@@ -12555 +12554 @@
-  return (TRUE);
+  return (true);
@@ -12599 +12598 @@
-        mixer_notify_update (plci, TRUE);
+        mixer_notify_update (plci, true);
@@ -12886 +12885 @@
-            return (FALSE);
+            return (false);
@@ -12893 +12892 @@
-            return (FALSE);
+            return (false);
@@ -12898 +12897 @@
-            return (FALSE);
+            return (false);
@@ -12903 +12902 @@
-            return (FALSE);
+            return (false);
@@ -12908 +12907 @@
-            return (FALSE);
+            return (false);
@@ -12981 +12980 @@
-            return (FALSE);
+            return (false);
@@ -12988 +12987 @@
-            return (FALSE);
+            return (false);
@@ -13002 +13001 @@
-  return (FALSE);
+  return (false);
@@ -13181 +13180 @@
-      for (n = 0; n < sizeof(mixer_write_prog_bri) / sizeof(mixer_write_prog_bri[0]); n++)
+      for (n = 0; n < ARRAY_SIZE(mixer_write_prog_bri); n++)
@@ -13566 +13565 @@
-  plci->adjust_b_restore = FALSE;
+  plci->adjust_b_restore = false;
@@ -13835 +13834 @@
-      plci->adjust_b_restore = TRUE;
+      plci->adjust_b_restore = true;
@@ -14606 +14605 @@
-  int max_ch = sizeof(a->ch_flow_control)/sizeof(a->ch_flow_control[0]);
+  int max_ch = ARRAY_SIZE(a->ch_flow_control);
@@ -14631 +14630 @@
-  int max_ch = sizeof(a->ch_flow_control)/sizeof(a->ch_flow_control[0]);
+  int max_ch = ARRAY_SIZE(a->ch_flow_control);
@@ -14771 +14770 @@
-      for(k=0,busy=FALSE; k<a->max_plci; k++)
+      for(k=0,busy=false; k<a->max_plci; k++)
@@ -14778 +14777 @@
-            busy = TRUE;
+            busy = true;
@@ -14783 +14782 @@
-            busy = TRUE;
+            busy = true;
@@ -14794 +14793 @@
-          group_found=TRUE;
+          group_found=true;
@@ -14800 +14799 @@
-          group_found=TRUE;
+          group_found=true;
@@ -14808 +14807 @@
-          group_found=TRUE;
+          group_found=true;
@@ -14863 +14862 @@
-  if(appls_found) return TRUE;
+  if(appls_found) return true;
@@ -14892 +14891 @@
-  return FALSE;
+  return false;
--- ./projects/linux/linux-2.6.21/drivers/isdn/hardware/eicon/message.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/isdn/hardware/eicon/message.c	2007-07-09 01:32:17.000000000 +0200
@@ -1 +0,0 @@
-
@@ -536 +535 @@
-          m->info.data_b3_req.Data = (dword)(TransmitBufferSet (appl, m->info.data_b3_req.Data));
+          m->info.data_b3_req.Data = (dword)(long)(TransmitBufferSet (appl, m->info.data_b3_req.Data));
@@ -1035 +1034 @@
-          (byte   *)(((CAPI_MSG   *)(&((byte   *)(plci->msg_in_queue))[i]))->info.data_b3_req.Data));
+          (byte *)(long)(((CAPI_MSG *)(&((byte *)(plci->msg_in_queue))[i]))->info.data_b3_req.Data));
@@ -3121 +3120 @@
-        data->P = (byte   *)(*((dword   *)(parms[0].info)));
+        data->P = (byte *)(long)(*((dword *)(parms[0].info)));
@@ -3154 +3153 @@
-        TransmitBufferFree (appl, (byte   *)(*((dword   *)(parms[0].info))));
+        TransmitBufferFree (appl, (byte *)(long)(*((dword *)(parms[0].info))));
@@ -4060 +4059 @@
-        TransmitBufferFree (appl, (byte   *)(m->info.data_b3_req.Data));
+        TransmitBufferFree (appl, (byte *)(long)(m->info.data_b3_req.Data));
@@ -7137 +7136 @@
-      plci->RData[0].P = plci->internal_ind_buffer + (-((int)(plci->internal_ind_buffer)) & 3);
+      plci->RData[0].P = plci->internal_ind_buffer + (-((int)(long)(plci->internal_ind_buffer)) & 3);
--- ./projects/linux/linux-2.6.24/drivers/isdn/hardware/eicon/message.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/isdn/hardware/eicon/message.c	2008-04-17 04:49:44.000000000 +0200
@@ -4944 +4944 @@
-      /* S = IE2 lenght + cont. */
+      /* S = IE2 length + cont. */
@@ -9030 +9030 @@
-  if(esc_chi[0] && !(esc_chi[esc_chi[0]])&0x7f )
+	if (esc_chi[0] && !(esc_chi[esc_chi[0]] & 0x7f))
--- ./projects/linux/linux-2.6.25/drivers/isdn/hardware/eicon/message.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/isdn/hardware/eicon/message.c	2008-07-13 23:51:29.000000000 +0200
@@ -745 +745 @@
-    while (plci->internal_command_queue[i] != 0)
+    while (plci->internal_command_queue[i] != NULL)
@@ -761 +761 @@
-  while (plci->internal_command_queue[1] != 0)
+  while (plci->internal_command_queue[1] != NULL)
@@ -9122 +9122 @@
-      if(plci!=0)
+      if(plci!=NULL)
@@ -9147 +9147 @@
-      if(plci!=0)
+      if(plci!=NULL)
@@ -9173 +9173 @@
-    if(plci!=0) plci->tel = CODEC;
+    if(plci!=NULL) plci->tel = CODEC;
@@ -14607 +14607 @@
-  if ((!plci) || (!plci->Id) || ((a = plci->adapter) == 0)) {
+  if ((!plci) || (!plci->Id) || ((a = plci->adapter) == NULL)) {
--- ./projects/linux/linux-2.6.28/drivers/isdn/hardware/eicon/message.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/isdn/hardware/eicon/message.c	2009-03-24 00:12:14.000000000 +0100
@@ -595 +595 @@
-word api_parse(byte   * msg, word length, byte * format, API_PARSE * parms)
+static word api_parse(byte *msg, word length, byte *format, API_PARSE *parms)
@@ -634 +634 @@
-void api_save_msg(API_PARSE   *in, byte *format, API_SAVE   *out)
+static void api_save_msg(API_PARSE *in, byte *format, API_SAVE *out)
@@ -666 +666 @@
-void api_load_msg(API_SAVE   *in, API_PARSE   *out)
+static void api_load_msg(API_SAVE *in, API_PARSE *out)
@@ -3417 +3417,2 @@
-byte manufacturer_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte manufacturer_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			     PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -3745 +3746,2 @@
-byte manufacturer_res(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * msg)
+static byte manufacturer_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			     PLCI *plci, APPL *appl, API_PARSE *msg)
@@ -4077 +4079,2 @@
-void control_rc(PLCI   * plci, byte req, byte rc, byte ch, byte global_req, byte nl_rc)
+static void control_rc(PLCI *plci, byte req, byte rc, byte ch, byte global_req,
+		       byte nl_rc)
@@ -4743 +4746 @@
-void data_rc(PLCI   * plci, byte ch)
+static void data_rc(PLCI *plci, byte ch)
@@ -4779 +4782 @@
-void data_ack(PLCI   * plci, byte ch)
+static void data_ack(PLCI *plci, byte ch)
@@ -4805 +4808 @@
-void sig_ind(PLCI   * plci)
+static void sig_ind(PLCI *plci)
@@ -6173 +6176 @@
-void SendInfo(PLCI   * plci, dword Id, byte   * * parms, byte iesent)
+static void SendInfo(PLCI *plci, dword Id, byte **parms, byte iesent)
@@ -6349 +6352,2 @@
-byte SendMultiIE(PLCI   * plci, dword Id, byte   * * parms, byte ie_type, dword info_mask, byte setupParse)
+static byte SendMultiIE(PLCI *plci, dword Id, byte **parms, byte ie_type,
+			dword info_mask, byte setupParse)
@@ -6468 +6472 @@
-void nl_ind(PLCI   * plci)
+static void nl_ind(PLCI *plci)
@@ -7250 +7254 @@
-word get_plci(DIVA_CAPI_ADAPTER   * a)
+static word get_plci(DIVA_CAPI_ADAPTER *a)
@@ -7409 +7413 @@
-void add_d(PLCI   * plci, word length, byte   * p)
+static void add_d(PLCI *plci, word length, byte *p)
@@ -7427 +7431 @@
-void add_ai(PLCI   * plci, API_PARSE * ai)
+static void add_ai(PLCI *plci, API_PARSE *ai)
@@ -7448 +7452,2 @@
-word add_b1(PLCI   * plci, API_PARSE * bp, word b_channel_info, word b1_facilities)
+static word add_b1(PLCI *plci, API_PARSE *bp, word b_channel_info,
+		   word b1_facilities)
@@ -7912 +7917 @@
-word add_b23(PLCI   * plci, API_PARSE * bp)
+static word add_b23(PLCI *plci, API_PARSE *bp)
@@ -8709 +8714 @@
-void nl_req_ncci(PLCI   * plci, byte req, byte ncci)
+static void nl_req_ncci(PLCI *plci, byte req, byte ncci)
@@ -8731 +8736 @@
-void send_req(PLCI   * plci)
+static void send_req(PLCI *plci)
@@ -8866 +8871 @@
-void listen_check(DIVA_CAPI_ADAPTER   * a)
+static void listen_check(DIVA_CAPI_ADAPTER *a)
@@ -8909 +8914 @@
-void IndParse(PLCI   * plci, word * parms_id, byte   ** parms, byte multiIEsize)
+static void IndParse(PLCI *plci, word *parms_id, byte **parms, byte multiIEsize)
@@ -8994 +8999 @@
-byte ie_compare(byte   * ie1, byte * ie2)
+static byte ie_compare(byte *ie1, byte *ie2)
@@ -9003 +9008 @@
-word find_cip(DIVA_CAPI_ADAPTER   * a, byte   * bc, byte   * hlc)
+static word find_cip(DIVA_CAPI_ADAPTER *a, byte *bc, byte *hlc)
@@ -9071 +9076 @@
-void SetVoiceChannel(PLCI   *plci, byte   *chi, DIVA_CAPI_ADAPTER   * a)
+static void SetVoiceChannel(PLCI *plci, byte *chi, DIVA_CAPI_ADAPTER *a)
@@ -9089 +9094 @@
-void VoiceChannelOff(PLCI   *plci)
+static void VoiceChannelOff(PLCI *plci)
@@ -9102 +9107,2 @@
-word AdvCodecSupport(DIVA_CAPI_ADAPTER   *a, PLCI   *plci, APPL   *appl, byte hook_listen)
+static word AdvCodecSupport(DIVA_CAPI_ADAPTER *a, PLCI *plci, APPL *appl,
+			    byte hook_listen)
@@ -9198 +9204 @@
-void CodecIdCheck(DIVA_CAPI_ADAPTER   *a, PLCI   *plci)
+static void CodecIdCheck(DIVA_CAPI_ADAPTER *a, PLCI *plci)
--- ./projects/linux/linux-2.6.29/drivers/isdn/hardware/eicon/message.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/isdn/hardware/eicon/message.c	2009-06-27 11:32:32.000000000 +0200
@@ -1197 +1197,2 @@
-byte connect_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte connect_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -1414 +1415,2 @@
-byte connect_res(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte connect_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -1570 +1572,2 @@
-byte connect_a_res(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * msg)
+static byte connect_a_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			  PLCI *plci, APPL *appl, API_PARSE *msg)
@@ -1576 +1579,2 @@
-byte disconnect_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * msg)
+static byte disconnect_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			   PLCI *plci, APPL *appl, API_PARSE *msg)
@@ -1631 +1635,2 @@
-byte disconnect_res(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * msg)
+static byte disconnect_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			   PLCI *plci, APPL *appl, API_PARSE *msg)
@@ -1658 +1663,2 @@
-byte listen_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte listen_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+		       PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -1707 +1713,2 @@
-byte info_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * msg)
+static byte info_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+		     PLCI *plci, APPL *appl, API_PARSE *msg)
@@ -1816 +1823,2 @@
-byte info_res(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * msg)
+static byte info_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+		     PLCI *plci, APPL *appl, API_PARSE *msg)
@@ -1822 +1830,2 @@
-byte alert_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * msg)
+static byte alert_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+		      PLCI *plci, APPL *appl, API_PARSE *msg)
@@ -1852 +1861,2 @@
-byte facility_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * msg)
+static byte facility_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			 PLCI *plci, APPL *appl, API_PARSE *msg)
@@ -2602 +2612,2 @@
-byte facility_res(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * msg)
+static byte facility_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			 PLCI *plci, APPL *appl, API_PARSE *msg)
@@ -2608 +2619,2 @@
-byte connect_b3_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte connect_b3_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			   PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -2842 +2854,2 @@
-byte connect_b3_res(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte connect_b3_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			   PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -2957 +2970,2 @@
-byte connect_b3_a_res(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte connect_b3_a_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			     PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -2977 +2991,2 @@
-byte disconnect_b3_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte disconnect_b3_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			      PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -3033 +3048,2 @@
-byte disconnect_b3_res(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte disconnect_b3_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			      PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -3089 +3105,2 @@
-byte data_b3_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte data_b3_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -3166 +3183,2 @@
-byte data_b3_res(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte data_b3_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -3199 +3217,2 @@
-byte reset_b3_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte reset_b3_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			 PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -3240 +3259,2 @@
-byte reset_b3_res(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte reset_b3_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			 PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -3264 +3284,2 @@
-byte connect_b3_t90_a_res(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * parms)
+static byte connect_b3_t90_a_res(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+				 PLCI *plci, APPL *appl, API_PARSE *parms)
@@ -3298 +3319,2 @@
-byte select_b_req(dword Id, word Number, DIVA_CAPI_ADAPTER   * a, PLCI   * plci, APPL   * appl, API_PARSE * msg)
+static byte select_b_req(dword Id, word Number, DIVA_CAPI_ADAPTER *a,
+			 PLCI *plci, APPL *appl, API_PARSE *msg)
@@ -8692 +8714 @@
-void sig_req(PLCI   * plci, byte req, byte Id)
+static void sig_req(PLCI *plci, byte req, byte Id)
@@ -8792 +8814 @@
-void send_data(PLCI   * plci)
+static void send_data(PLCI *plci)
--- ./projects/linux/linux-2.6.24/drivers/isdn/i4l/isdn_ttyfax.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/isdn/i4l/isdn_ttyfax.c	2008-04-17 04:49:44.000000000 +0200
@@ -837 +837 @@
-		if (!info->faxonline & 1)	/* not outgoing connection */
+		if (!(info->faxonline & 1))	/* not outgoing connection */
@@ -909 +909,2 @@
-			if ((f->phase != ISDN_FAX_PHASE_D) || (!info->faxonline & 1))
+			if ((f->phase != ISDN_FAX_PHASE_D) ||
+			    (!(info->faxonline & 1)))
--- ./projects/linux/linux-2.6.14/drivers/isdn/icn/icn.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/isdn/icn/icn.c	2006-01-03 04:21:10.000000000 +0100
@@ -950,2 +950 @@
-			set_current_state(TASK_INTERRUPTIBLE);
-			schedule_timeout(10);
+			schedule_timeout_interruptible(10);
--- ./projects/linux/linux-2.6.18/drivers/isdn/icn/icn.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/isdn/icn/icn.c	2006-11-29 22:57:37.000000000 +0100
@@ -1013 +1013,2 @@
-		put_user(*card->msg_buf_read++, p);
+		if (put_user(*card->msg_buf_read++, p))
+			return -EFAULT;
--- ./projects/linux/linux-2.6.19/drivers/isdn/icn/icn.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/isdn/icn/icn.c	2007-02-04 19:44:54.000000000 +0100
@@ -1522 +1522 @@
-	if (!(card = (icn_card *) kmalloc(sizeof(icn_card), GFP_KERNEL))) {
+	if (!(card = kzalloc(sizeof(icn_card), GFP_KERNEL))) {
@@ -1527 +1526,0 @@
-	memset((char *) card, 0, sizeof(icn_card));
--- ./projects/linux/linux-2.6.21/drivers/isdn/icn/icn.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/isdn/icn/icn.c	2007-07-09 01:32:17.000000000 +0200
@@ -14,0 +15 @@
+#include <linux/sched.h>
--- ./projects/linux/linux-2.6.24/drivers/isdn/icn/icn.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/isdn/icn/icn.c	2008-04-17 04:49:44.000000000 +0200
@@ -1305 +1305 @@
-			if (!card->flags & ICN_FLAGS_RUNNING)
+			if (!(card->flags & ICN_FLAGS_RUNNING))
@@ -1331 +1331 @@
-			if (!card->flags & ICN_FLAGS_RUNNING)
+			if (!(card->flags & ICN_FLAGS_RUNNING))
@@ -1351 +1351 @@
-			if (!card->flags & ICN_FLAGS_RUNNING)
+			if (!(card->flags & ICN_FLAGS_RUNNING))
@@ -1369 +1369 @@
-			if (!card->flags & ICN_FLAGS_RUNNING)
+			if (!(card->flags & ICN_FLAGS_RUNNING))
@@ -1378 +1378 @@
-			if (!card->flags & ICN_FLAGS_RUNNING)
+			if (!(card->flags & ICN_FLAGS_RUNNING))
@@ -1394 +1394 @@
-			if (!card->flags & ICN_FLAGS_RUNNING)
+			if (!(card->flags & ICN_FLAGS_RUNNING))
@@ -1408 +1408 @@
-			if (!card->flags & ICN_FLAGS_RUNNING)
+			if (!(card->flags & ICN_FLAGS_RUNNING))
@@ -1427 +1427 @@
-			if (!card->flags & ICN_FLAGS_RUNNING)
+			if (!(card->flags & ICN_FLAGS_RUNNING))
@@ -1474 +1474 @@
-		if (!card->flags & ICN_FLAGS_RUNNING)
+		if (!(card->flags & ICN_FLAGS_RUNNING))
@@ -1489 +1489 @@
-		if (!card->flags & ICN_FLAGS_RUNNING)
+		if (!(card->flags & ICN_FLAGS_RUNNING))
@@ -1504 +1504 @@
-		if (!card->flags & ICN_FLAGS_RUNNING)
+		if (!(card->flags & ICN_FLAGS_RUNNING))
--- ./projects/linux/linux-2.6.14/drivers/isdn/isdnloop/isdnloop.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/isdn/isdnloop/isdnloop.c	2006-01-03 04:21:10.000000000 +0100
@@ -1164,6 +1164,3 @@
-							while (card->ptype == ISDN_PTYPE_UNKNOWN) {
-								set_current_state(TASK_INTERRUPTIBLE);
-								schedule_timeout(10);
-							}
-							set_current_state(TASK_INTERRUPTIBLE);
-							schedule_timeout(10);
+							while (card->ptype == ISDN_PTYPE_UNKNOWN)
+								schedule_timeout_interruptible(10);
+							schedule_timeout_interruptible(10);
--- ./projects/linux/linux-2.6.16/drivers/isdn/isdnloop/isdnloop.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/isdn/isdnloop/isdnloop.c	2006-06-18 03:49:35.000000000 +0200
@@ -25 +25 @@
-MODULE_PARM(isdnloop_id, "s");
+module_param(isdnloop_id, charp, 0);
--- ./projects/linux/linux-2.6.17/drivers/isdn/isdnloop/isdnloop.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/isdn/isdnloop/isdnloop.c	2006-09-20 05:42:06.000000000 +0200
@@ -12 +11,0 @@
-#include <linux/config.h>
--- ./projects/linux/linux-2.6.18/drivers/isdn/isdnloop/isdnloop.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/isdn/isdnloop/isdnloop.c	2006-11-29 22:57:37.000000000 +0100
@@ -103,2 +103 @@
-		save_flags(flags);
-		cli();
+		spin_lock_irqsave(&card->isdnloop_lock, flags);
@@ -108 +107 @@
-		restore_flags(flags);
+		spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -284,2 +283 @@
-	save_flags(flags);
-	cli();
+	spin_lock_irqsave(&card->isdnloop_lock, flags);
@@ -293 +291 @@
-	restore_flags(flags);
+	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -375,2 +373 @@
-			save_flags(flags);
-			cli();
+			spin_lock_irqsave(&card->isdnloop_lock, flags);
@@ -382 +379 @@
-			restore_flags(flags);
+			spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -385,2 +382 @@
-	save_flags(flags);
-	cli();
+	spin_lock_irqsave(&card->isdnloop_lock, flags);
@@ -389 +385 @@
-	restore_flags(flags);
+	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -419,2 +415 @@
-		save_flags(flags);
-		cli();
+		spin_lock_irqsave(&card->isdnloop_lock, flags);
@@ -429 +424 @@
-		restore_flags(flags);
+		spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -454 +449,2 @@
-		put_user(*card->msg_buf_read++, p);
+		if (put_user(*card->msg_buf_read++, p))
+			return -EFAULT;
@@ -579,2 +575 @@
-	save_flags(flags);
-	cli();
+	spin_lock_irqsave(&card->isdnloop_lock, flags);
@@ -590 +585 @@
-	restore_flags(flags);
+	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -625,2 +620 @@
-	save_flags(flags);
-	cli();
+	spin_lock_irqsave(&card->isdnloop_lock, flags);
@@ -635 +629 @@
-	restore_flags(flags);
+	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -650,2 +644 @@
-	save_flags(flags);
-	cli();
+	spin_lock_irqsave(&card->isdnloop_lock, flags);
@@ -653 +646 @@
-	restore_flags(flags);
+	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -709,2 +702 @@
-				save_flags(flags);
-				cli();
+				spin_lock_irqsave(&card->isdnloop_lock, flags);
@@ -715 +707 @@
-						restore_flags(flags);
+						spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -723 +715 @@
-					restore_flags(flags);
+					spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -726 +718 @@
-					restore_flags(flags);
+					spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -1030,2 +1022 @@
-	save_flags(flags);
-	cli();
+	spin_lock_irqsave(&card->isdnloop_lock, flags);
@@ -1042 +1033 @@
-	restore_flags(flags);
+	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -1081,2 +1072 @@
-	save_flags(flags);
-	cli();
+	spin_lock_irqsave(&card->isdnloop_lock, flags);
@@ -1087 +1077 @@
-				restore_flags(flags);
+				spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -1092 +1082 @@
-				restore_flags(flags);
+				spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -1101 +1091 @@
-				restore_flags(flags);
+				spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -1106 +1096 @@
-				restore_flags(flags);
+				spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -1114 +1104 @@
-			restore_flags(flags);
+			spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -1125 +1115 @@
-	restore_flags(flags);
+	spin_unlock_irqrestore(&card->isdnloop_lock, flags);
@@ -1474,0 +1465 @@
+	card->isdnloop_lock = SPIN_LOCK_UNLOCKED;
--- ./projects/linux/linux-2.6.19/drivers/isdn/isdnloop/isdnloop.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/isdn/isdnloop/isdnloop.c	2007-02-04 19:44:54.000000000 +0100
@@ -1433 +1433 @@
-	if (!(card = (isdnloop_card *) kmalloc(sizeof(isdnloop_card), GFP_KERNEL))) {
+	if (!(card = kzalloc(sizeof(isdnloop_card), GFP_KERNEL))) {
@@ -1438 +1437,0 @@
-	memset((char *) card, 0, sizeof(isdnloop_card));
--- ./projects/linux/linux-2.6.21/drivers/isdn/isdnloop/isdnloop.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/isdn/isdnloop/isdnloop.c	2007-07-09 01:32:17.000000000 +0200
@@ -418 +418,2 @@
-			memcpy(skb_put(nskb, len), skb->data, len);
+			skb_copy_from_linear_data(skb,
+						  skb_put(nskb, len), len);
@@ -1464 +1465 @@
-	card->isdnloop_lock = SPIN_LOCK_UNLOCKED;
+	spin_lock_init(&card->isdnloop_lock);
--- ./projects/linux/linux-2.6.24/drivers/isdn/isdnloop/isdnloop.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/isdn/isdnloop/isdnloop.c	2008-04-17 04:49:44.000000000 +0200
@@ -1187 +1187 @@
-			if (!card->flags & ISDNLOOP_FLAGS_RUNNING)
+			if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
@@ -1213 +1213 @@
-			if (!card->flags & ISDNLOOP_FLAGS_RUNNING)
+			if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
@@ -1241 +1241 @@
-			if (!card->flags & ISDNLOOP_FLAGS_RUNNING)
+			if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
@@ -1267 +1267 @@
-				if (!card->flags & ISDNLOOP_FLAGS_RUNNING)
+				if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
@@ -1276 +1276 @@
-				if (!card->flags & ISDNLOOP_FLAGS_RUNNING)
+				if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
@@ -1292 +1292 @@
-				if (!card->flags & ISDNLOOP_FLAGS_RUNNING)
+				if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
@@ -1306 +1306 @@
-				if (!card->flags & ISDNLOOP_FLAGS_RUNNING)
+				if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
@@ -1336 +1336 @@
-				if (!card->flags & ISDNLOOP_FLAGS_RUNNING)
+				if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
@@ -1383 +1383 @@
-		if (!card->flags & ISDNLOOP_FLAGS_RUNNING)
+		if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
@@ -1398 +1398 @@
-		if (!card->flags & ISDNLOOP_FLAGS_RUNNING)
+		if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
@@ -1413 +1413 @@
-		if (!card->flags & ISDNLOOP_FLAGS_RUNNING)
+		if (!(card->flags & ISDNLOOP_FLAGS_RUNNING))
--- ./projects/linux/linux-2.6.20/drivers/kvm/mmu.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/kvm/mmu.c	2007-04-26 05:08:32.000000000 +0200
@@ -134 +134 @@
-#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & PAGE_MASK)
+#define PT64_BASE_ADDR_MASK (((1ULL << 52) - 1) & ~(u64)(PAGE_SIZE-1))
@@ -301 +301 @@
-	if (!page->private) {
+	if (!page_private(page)) {
@@ -303,2 +303,2 @@
-		page->private = (unsigned long)spte;
-	} else if (!(page->private & 1)) {
+		set_page_private(page,(unsigned long)spte);
+	} else if (!(page_private(page) & 1)) {
@@ -307 +307 @@
-		desc->shadow_ptes[0] = (u64 *)page->private;
+		desc->shadow_ptes[0] = (u64 *)page_private(page);
@@ -309 +309 @@
-		page->private = (unsigned long)desc | 1;
+		set_page_private(page,(unsigned long)desc | 1);
@@ -312 +312 @@
-		desc = (struct kvm_rmap_desc *)(page->private & ~1ul);
+		desc = (struct kvm_rmap_desc *)(page_private(page) & ~1ul);
@@ -336 +336 @@
-	desc->shadow_ptes[j] = 0;
+	desc->shadow_ptes[j] = NULL;
@@ -340 +340 @@
-		page->private = (unsigned long)desc->shadow_ptes[0];
+		set_page_private(page,(unsigned long)desc->shadow_ptes[0]);
@@ -345 +345 @@
-			page->private = (unsigned long)desc->more | 1;
+			set_page_private(page,(unsigned long)desc->more | 1);
@@ -359 +359 @@
-	if (!page->private) {
+	if (!page_private(page)) {
@@ -362 +362 @@
-	} else if (!(page->private & 1)) {
+	} else if (!(page_private(page) & 1)) {
@@ -364 +364 @@
-		if ((u64 *)page->private != spte) {
+		if ((u64 *)page_private(page) != spte) {
@@ -369 +369 @@
-		page->private = 0;
+		set_page_private(page,0);
@@ -372 +372 @@
-		desc = (struct kvm_rmap_desc *)(page->private & ~1ul);
+		desc = (struct kvm_rmap_desc *)(page_private(page) & ~1ul);
@@ -401,3 +401,3 @@
-	while (page->private) {
-		if (!(page->private & 1))
-			spte = (u64 *)page->private;
+	while (page_private(page)) {
+		if (!(page_private(page) & 1))
+			spte = (u64 *)page_private(page);
@@ -405 +405 @@
-			desc = (struct kvm_rmap_desc *)(page->private & ~1ul);
+			desc = (struct kvm_rmap_desc *)(page_private(page) & ~1ul);
@@ -409,2 +409,2 @@
-		BUG_ON((*spte & PT64_BASE_ADDR_MASK) !=
-		       page_to_pfn(page) << PAGE_SHIFT);
+		BUG_ON((*spte & PT64_BASE_ADDR_MASK) >> PAGE_SHIFT
+		       != page_to_pfn(page));
@@ -1095,0 +1096,19 @@
+static void mmu_pre_write_zap_pte(struct kvm_vcpu *vcpu,
+				  struct kvm_mmu_page *page,
+				  u64 *spte)
+{
+	u64 pte;
+	struct kvm_mmu_page *child;
+
+	pte = *spte;
+	if (is_present_pte(pte)) {
+		if (page->role.level == PT_PAGE_TABLE_LEVEL)
+			rmap_remove(vcpu, spte);
+		else {
+			child = page_header(pte & PT64_BASE_ADDR_MASK);
+			mmu_page_remove_parent_pte(vcpu, child, spte);
+		}
+	}
+	*spte = 0;
+}
+
@@ -1100 +1118,0 @@
-	struct kvm_mmu_page *child;
@@ -1105 +1122,0 @@
-	u64 pte;
@@ -1111,0 +1129 @@
+	int npte;
@@ -1146,0 +1165 @@
+		npte = 1;
@@ -1148 +1167,11 @@
-			page_offset <<= 1;          /* 32->64 */
+			page_offset <<= 1;	/* 32->64 */
+			/*
+			 * A 32-bit pde maps 4MB while the shadow pdes map
+			 * only 2MB.  So we need to double the offset again
+			 * and zap two pdes instead of one.
+			 */
+			if (level == PT32_ROOT_LEVEL) {
+				page_offset &= ~7; /* kill rounding error */
+				page_offset <<= 1;
+				npte = 2;
+			}
@@ -1153,8 +1182,3 @@
-		pte = *spte;
-		if (is_present_pte(pte)) {
-			if (level == PT_PAGE_TABLE_LEVEL)
-				rmap_remove(vcpu, spte);
-			else {
-				child = page_header(pte & PT64_BASE_ADDR_MASK);
-				mmu_page_remove_parent_pte(vcpu, child, spte);
-			}
+		while (npte--) {
+			mmu_pre_write_zap_pte(vcpu, page, spte);
+			++spte;
@@ -1162 +1185,0 @@
-		*spte = 0;
@@ -1221 +1244 @@
-		page->private = (unsigned long)page_header;
+		set_page_private(page, (unsigned long)page_header);
--- ./projects/linux/linux-2.6.21/drivers/kvm/mmu.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/kvm/mmu.c	2007-07-09 01:32:17.000000000 +0200
@@ -54,0 +55,3 @@
+#ifndef MMU_DEBUG
+#define ASSERT(x) do { } while (0)
+#else
@@ -59,0 +63 @@
+#endif
@@ -161,0 +166,3 @@
+static struct kmem_cache *pte_chain_cache;
+static struct kmem_cache *rmap_desc_cache;
+
@@ -199 +206,2 @@
-				  size_t objsize, int min)
+				  struct kmem_cache *base_cache, int min,
+				  gfp_t gfp_flags)
@@ -206 +214 @@
-		obj = kzalloc(objsize, GFP_NOWAIT);
+		obj = kmem_cache_zalloc(base_cache, gfp_flags);
@@ -220 +228 @@
-static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)
+static int __mmu_topup_memory_caches(struct kvm_vcpu *vcpu, gfp_t gfp_flags)
@@ -225 +233 @@
-				   sizeof(struct kvm_pte_chain), 4);
+				   pte_chain_cache, 4, gfp_flags);
@@ -229 +237 @@
-				   sizeof(struct kvm_rmap_desc), 1);
+				   rmap_desc_cache, 1, gfp_flags);
@@ -233,0 +242,15 @@
+static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)
+{
+	int r;
+
+	r = __mmu_topup_memory_caches(vcpu, GFP_NOWAIT);
+	if (r < 0) {
+		spin_unlock(&vcpu->kvm->lock);
+		kvm_arch_ops->vcpu_put(vcpu);
+		r = __mmu_topup_memory_caches(vcpu, GFP_KERNEL);
+		kvm_arch_ops->vcpu_load(vcpu);
+		spin_lock(&vcpu->kvm->lock);
+	}
+	return r;
+}
+
@@ -393 +415,0 @@
-	struct kvm_memory_slot *slot;
@@ -397,3 +419,2 @@
-	slot = gfn_to_memslot(kvm, gfn);
-	BUG_ON(!slot);
-	page = gfn_to_page(slot, gfn);
+	page = gfn_to_page(kvm, gfn);
+	BUG_ON(!page);
@@ -419,0 +441 @@
+#ifdef MMU_DEBUG
@@ -433,0 +456 @@
+#endif
@@ -440 +462,0 @@
-	list_del(&page_head->link);
@@ -442 +464 @@
-	list_add(&page_head->link, &vcpu->free_pages);
+	list_move(&page_head->link, &vcpu->free_pages);
@@ -460,2 +482 @@
-	list_del(&page->link);
-	list_add(&page->link, &vcpu->kvm->active_mmu_pages);
+	list_move(&page->link, &vcpu->kvm->active_mmu_pages);
@@ -464 +484,0 @@
-	page->global = 1;
@@ -571,0 +592 @@
+					     unsigned hugepage_access,
@@ -584,0 +606 @@
+	role.hugepage_access = hugepage_access;
@@ -672,4 +694,2 @@
-	} else {
-		list_del(&page->link);
-		list_add(&page->link, &vcpu->kvm->active_mmu_pages);
-	}
+	} else
+		list_move(&page->link, &vcpu->kvm->active_mmu_pages);
@@ -717 +736,0 @@
-	struct kvm_memory_slot *slot;
@@ -721,2 +740,2 @@
-	slot = gfn_to_memslot(vcpu->kvm, gpa >> PAGE_SHIFT);
-	if (!slot)
+	page = gfn_to_page(vcpu->kvm, gpa >> PAGE_SHIFT);
+	if (!page)
@@ -724 +742,0 @@
-	page = gfn_to_page(slot, gpa >> PAGE_SHIFT);
@@ -737,0 +756,9 @@
+struct page *gva_to_page(struct kvm_vcpu *vcpu, gva_t gva)
+{
+	gpa_t gpa = vcpu->mmu.gva_to_gpa(vcpu, gva);
+
+	if (gpa == UNMAPPED_GVA)
+		return NULL;
+	return pfn_to_page(gpa_to_hpa(vcpu, gpa) >> PAGE_SHIFT);
+}
+
@@ -775 +802 @@
-						     1, &table[index]);
+						     1, 0, &table[index]);
@@ -807,4 +834,6 @@
-		ASSERT(VALID_PAGE(root));
-		root &= PT64_BASE_ADDR_MASK;
-		page = page_header(root);
-		--page->root_count;
+		if (root) {
+			ASSERT(VALID_PAGE(root));
+			root &= PT64_BASE_ADDR_MASK;
+			page = page_header(root);
+			--page->root_count;
+		}
@@ -830 +859 @@
-					PT64_ROOT_LEVEL, 0, NULL);
+					PT64_ROOT_LEVEL, 0, 0, NULL);
@@ -841 +870,5 @@
-		if (vcpu->mmu.root_level == PT32E_ROOT_LEVEL)
+		if (vcpu->mmu.root_level == PT32E_ROOT_LEVEL) {
+			if (!is_present_pte(vcpu->pdptrs[i])) {
+				vcpu->mmu.pae_root[i] = 0;
+				continue;
+			}
@@ -843 +876 @@
-		else if (vcpu->mmu.root_level == 0)
+		} else if (vcpu->mmu.root_level == 0)
@@ -847 +880 @@
-					NULL);
+					0, NULL);
@@ -906 +939 @@
-	++kvm_stat.tlb_flush;
+	++vcpu->stat.tlb_flush;
@@ -921,5 +953,0 @@
-static void mark_pagetable_nonglobal(void *shadow_pte)
-{
-	page_header(__pa(shadow_pte))->global = 0;
-}
-
@@ -943,3 +970,0 @@
-	if (!(*shadow_pte & PT_GLOBAL_MASK))
-		mark_pagetable_nonglobal(shadow_pte);
-
@@ -1318,0 +1344,45 @@
+void kvm_mmu_zap_all(struct kvm_vcpu *vcpu)
+{
+	destroy_kvm_mmu(vcpu);
+
+	while (!list_empty(&vcpu->kvm->active_mmu_pages)) {
+		struct kvm_mmu_page *page;
+
+		page = container_of(vcpu->kvm->active_mmu_pages.next,
+				    struct kvm_mmu_page, link);
+		kvm_mmu_zap_page(vcpu, page);
+	}
+
+	mmu_free_memory_caches(vcpu);
+	kvm_arch_ops->tlb_flush(vcpu);
+	init_kvm_mmu(vcpu);
+}
+
+void kvm_mmu_module_exit(void)
+{
+	if (pte_chain_cache)
+		kmem_cache_destroy(pte_chain_cache);
+	if (rmap_desc_cache)
+		kmem_cache_destroy(rmap_desc_cache);
+}
+
+int kvm_mmu_module_init(void)
+{
+	pte_chain_cache = kmem_cache_create("kvm_pte_chain",
+					    sizeof(struct kvm_pte_chain),
+					    0, 0, NULL, NULL);
+	if (!pte_chain_cache)
+		goto nomem;
+	rmap_desc_cache = kmem_cache_create("kvm_rmap_desc",
+					    sizeof(struct kvm_rmap_desc),
+					    0, 0, NULL, NULL);
+	if (!rmap_desc_cache)
+		goto nomem;
+
+	return 0;
+
+nomem:
+	kvm_mmu_module_exit();
+	return -ENOMEM;
+}
+
@@ -1341 +1411 @@
-		if (!ent & PT_PRESENT_MASK)
+		if (!(ent & PT_PRESENT_MASK))
@@ -1363 +1433 @@
-	int i;
+	unsigned i;
--- ./projects/linux/linux-2.6.22/drivers/kvm/mmu.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/kvm/mmu.c	2007-10-09 22:31:38.000000000 +0200
@@ -18,0 +19,4 @@
+
+#include "vmx.h"
+#include "kvm.h"
+
@@ -21 +24,0 @@
-#include <asm/page.h>
@@ -26,2 +29,2 @@
-#include "vmx.h"
-#include "kvm.h"
+#include <asm/page.h>
+#include <asm/cmpxchg.h>
@@ -93,5 +95,0 @@
-#define PT32_PTE_COPY_MASK \
-	(PT_PRESENT_MASK | PT_ACCESSED_MASK | PT_DIRTY_MASK | PT_GLOBAL_MASK)
-
-#define PT64_PTE_COPY_MASK (PT64_NX_MASK | PT32_PTE_COPY_MASK)
-
@@ -101 +98,0 @@
-#define PT_SHADOW_PS_MARK (1ULL << PT_FIRST_AVAIL_BITS_SHIFT)
@@ -104,8 +100,0 @@
-#define PT_SHADOW_WRITABLE_SHIFT (PT_FIRST_AVAIL_BITS_SHIFT + 1)
-#define PT_SHADOW_WRITABLE_MASK (1ULL << PT_SHADOW_WRITABLE_SHIFT)
-
-#define PT_SHADOW_USER_SHIFT (PT_SHADOW_WRITABLE_SHIFT + 1)
-#define PT_SHADOW_USER_MASK (1ULL << (PT_SHADOW_USER_SHIFT))
-
-#define PT_SHADOW_BITS_OFFSET (PT_SHADOW_WRITABLE_SHIFT - PT_WRITABLE_SHIFT)
-
@@ -167,0 +157 @@
+static struct kmem_cache *mmu_page_header_cache;
@@ -204,0 +195,9 @@
+static void set_shadow_pte(u64 *sptep, u64 spte)
+{
+#ifdef CONFIG_X86_64
+	set_64bit((unsigned long *)sptep, spte);
+#else
+	set_64bit((unsigned long long *)sptep, spte);
+#endif
+}
+
@@ -227,0 +227,23 @@
+static int mmu_topup_memory_cache_page(struct kvm_mmu_memory_cache *cache,
+				       int min, gfp_t gfp_flags)
+{
+	struct page *page;
+
+	if (cache->nobjs >= min)
+		return 0;
+	while (cache->nobjs < ARRAY_SIZE(cache->objects)) {
+		page = alloc_page(gfp_flags);
+		if (!page)
+			return -ENOMEM;
+		set_page_private(page, 0);
+		cache->objects[cache->nobjs++] = page_address(page);
+	}
+	return 0;
+}
+
+static void mmu_free_memory_cache_page(struct kvm_mmu_memory_cache *mc)
+{
+	while (mc->nobjs)
+		free_page((unsigned long)mc->objects[--mc->nobjs]);
+}
+
@@ -237,0 +260,7 @@
+	if (r)
+		goto out;
+	r = mmu_topup_memory_cache_page(&vcpu->mmu_page_cache, 4, gfp_flags);
+	if (r)
+		goto out;
+	r = mmu_topup_memory_cache(&vcpu->mmu_page_header_cache,
+				   mmu_page_header_cache, 4, gfp_flags);
@@ -246,0 +276 @@
+	kvm_mmu_free_some_pages(vcpu);
@@ -252,0 +283 @@
+		kvm_mmu_free_some_pages(vcpu);
@@ -260,0 +292,2 @@
+	mmu_free_memory_cache_page(&vcpu->mmu_page_cache);
+	mmu_free_memory_cache(&vcpu->mmu_page_header_cache);
@@ -274,8 +306,0 @@
-static void mmu_memory_cache_free(struct kvm_mmu_memory_cache *mc, void *obj)
-{
-	if (mc->nobjs < KVM_NR_MEM_OBJS)
-		mc->objects[mc->nobjs++] = obj;
-	else
-		kfree(obj);
-}
-
@@ -288,2 +313 @@
-static void mmu_free_pte_chain(struct kvm_vcpu *vcpu,
-			       struct kvm_pte_chain *pc)
+static void mmu_free_pte_chain(struct kvm_pte_chain *pc)
@@ -291 +315 @@
-	mmu_memory_cache_free(&vcpu->mmu_pte_chain_cache, pc);
+	kfree(pc);
@@ -300,2 +324 @@
-static void mmu_free_rmap_desc(struct kvm_vcpu *vcpu,
-			       struct kvm_rmap_desc *rd)
+static void mmu_free_rmap_desc(struct kvm_rmap_desc *rd)
@@ -303 +326 @@
-	mmu_memory_cache_free(&vcpu->mmu_rmap_desc_cache, rd);
+	kfree(rd);
@@ -348,2 +371 @@
-static void rmap_desc_remove_entry(struct kvm_vcpu *vcpu,
-				   struct page *page,
+static void rmap_desc_remove_entry(struct page *page,
@@ -369 +391 @@
-	mmu_free_rmap_desc(vcpu, desc);
+	mmu_free_rmap_desc(desc);
@@ -372 +394 @@
-static void rmap_remove(struct kvm_vcpu *vcpu, u64 *spte)
+static void rmap_remove(u64 *spte)
@@ -400 +422 @@
-					rmap_desc_remove_entry(vcpu, page,
+					rmap_desc_remove_entry(page,
@@ -435,3 +457,3 @@
-		rmap_remove(vcpu, spte);
-		kvm_arch_ops->tlb_flush(vcpu);
-		*spte &= ~(u64)PT_WRITABLE_MASK;
+		rmap_remove(spte);
+		set_shadow_pte(spte, *spte & ~PT_WRITABLE_MASK);
+		kvm_flush_remote_tlbs(vcpu->kvm);
@@ -442 +464 @@
-static int is_empty_shadow_page(hpa_t page_hpa)
+static int is_empty_shadow_page(u64 *spt)
@@ -447,2 +469 @@
-	for (pos = __va(page_hpa), end = pos + PAGE_SIZE / sizeof(u64);
-		      pos != end; pos++)
+	for (pos = spt, end = pos + PAGE_SIZE / sizeof(u64); pos != end; pos++)
@@ -458 +479,2 @@
-static void kvm_mmu_free_page(struct kvm_vcpu *vcpu, hpa_t page_hpa)
+static void kvm_mmu_free_page(struct kvm *kvm,
+			      struct kvm_mmu_page *page_head)
@@ -460,6 +482,5 @@
-	struct kvm_mmu_page *page_head = page_header(page_hpa);
-
-	ASSERT(is_empty_shadow_page(page_hpa));
-	page_head->page_hpa = page_hpa;
-	list_move(&page_head->link, &vcpu->free_pages);
-	++vcpu->kvm->n_free_mmu_pages;
+	ASSERT(is_empty_shadow_page(page_head->spt));
+	list_del(&page_head->link);
+	__free_page(virt_to_page(page_head->spt));
+	kfree(page_head);
+	++kvm->n_free_mmu_pages;
@@ -478 +499 @@
-	if (list_empty(&vcpu->free_pages))
+	if (!vcpu->kvm->n_free_mmu_pages)
@@ -481,3 +502,6 @@
-	page = list_entry(vcpu->free_pages.next, struct kvm_mmu_page, link);
-	list_move(&page->link, &vcpu->kvm->active_mmu_pages);
-	ASSERT(is_empty_shadow_page(page->page_hpa));
+	page = mmu_memory_cache_alloc(&vcpu->mmu_page_header_cache,
+				      sizeof *page);
+	page->spt = mmu_memory_cache_alloc(&vcpu->mmu_page_cache, PAGE_SIZE);
+	set_page_private(virt_to_page(page->spt), (unsigned long)page);
+	list_add(&page->link, &vcpu->kvm->active_mmu_pages);
+	ASSERT(is_empty_shadow_page(page->spt));
@@ -528,2 +552 @@
-static void mmu_page_remove_parent_pte(struct kvm_vcpu *vcpu,
-				       struct kvm_mmu_page *page,
+static void mmu_page_remove_parent_pte(struct kvm_mmu_page *page,
@@ -556 +579 @@
-				mmu_free_pte_chain(vcpu, pte_chain);
+				mmu_free_pte_chain(pte_chain);
@@ -634 +657 @@
-static void kvm_mmu_page_unlink_children(struct kvm_vcpu *vcpu,
+static void kvm_mmu_page_unlink_children(struct kvm *kvm,
@@ -641 +664 @@
-	pt = __va(page->page_hpa);
+	pt = page->spt;
@@ -646 +669 @@
-				rmap_remove(vcpu, &pt[i]);
+				rmap_remove(&pt[i]);
@@ -649 +672 @@
-		kvm_arch_ops->tlb_flush(vcpu);
+		kvm_flush_remote_tlbs(kvm);
@@ -660 +683 @@
-		mmu_page_remove_parent_pte(vcpu, page_header(ent), &pt[i]);
+		mmu_page_remove_parent_pte(page_header(ent), &pt[i]);
@@ -661,0 +685 @@
+	kvm_flush_remote_tlbs(kvm);
@@ -664,2 +688 @@
-static void kvm_mmu_put_page(struct kvm_vcpu *vcpu,
-			     struct kvm_mmu_page *page,
+static void kvm_mmu_put_page(struct kvm_mmu_page *page,
@@ -668 +691 @@
-	mmu_page_remove_parent_pte(vcpu, page, parent_pte);
+	mmu_page_remove_parent_pte(page, parent_pte);
@@ -671 +694 @@
-static void kvm_mmu_zap_page(struct kvm_vcpu *vcpu,
+static void kvm_mmu_zap_page(struct kvm *kvm,
@@ -687,2 +710,2 @@
-		kvm_mmu_put_page(vcpu, page, parent_pte);
-		*parent_pte = 0;
+		kvm_mmu_put_page(page, parent_pte);
+		set_shadow_pte(parent_pte, 0);
@@ -690 +713 @@
-	kvm_mmu_page_unlink_children(vcpu, page);
+	kvm_mmu_page_unlink_children(kvm, page);
@@ -693 +716 @@
-		kvm_mmu_free_page(vcpu, page->page_hpa);
+		kvm_mmu_free_page(kvm, page);
@@ -695 +718 @@
-		list_move(&page->link, &vcpu->kvm->active_mmu_pages);
+		list_move(&page->link, &kvm->active_mmu_pages);
@@ -714 +737 @@
-			kvm_mmu_zap_page(vcpu, page);
+			kvm_mmu_zap_page(vcpu->kvm, page);
@@ -719,0 +743,11 @@
+static void mmu_unshadow(struct kvm_vcpu *vcpu, gfn_t gfn)
+{
+	struct kvm_mmu_page *page;
+
+	while ((page = kvm_mmu_lookup_page(vcpu, gfn)) != NULL) {
+		pgprintk("%s: zap %lx %x\n",
+			 __FUNCTION__, gfn, page->role.word);
+		kvm_mmu_zap_page(vcpu->kvm, page);
+	}
+}
+
@@ -808 +842 @@
-			table[index] = new_table->page_hpa | PT_PRESENT_MASK
+			table[index] = __pa(new_table->spt) | PT_PRESENT_MASK
@@ -819,0 +854,2 @@
+	if (!VALID_PAGE(vcpu->mmu.root_hpa))
+		return;
@@ -824 +859,0 @@
-		ASSERT(VALID_PAGE(root));
@@ -835 +869,0 @@
-			ASSERT(VALID_PAGE(root));
@@ -860 +894 @@
-		root = page->page_hpa;
+		root = __pa(page->spt);
@@ -881 +915 @@
-		root = page->page_hpa;
+		root = __pa(page->spt);
@@ -931,3 +965 @@
-	mmu_alloc_roots(vcpu);
-	ASSERT(VALID_PAGE(context->root_hpa));
-	kvm_arch_ops->set_cr3(vcpu, context->root_hpa);
+	context->root_hpa = INVALID_PAGE;
@@ -947,53 +978,0 @@
-	if (unlikely(vcpu->kvm->n_free_mmu_pages < KVM_MIN_FREE_MMU_PAGES))
-		kvm_mmu_free_some_pages(vcpu);
-	mmu_alloc_roots(vcpu);
-	kvm_mmu_flush_tlb(vcpu);
-	kvm_arch_ops->set_cr3(vcpu, vcpu->mmu.root_hpa);
-}
-
-static inline void set_pte_common(struct kvm_vcpu *vcpu,
-			     u64 *shadow_pte,
-			     gpa_t gaddr,
-			     int dirty,
-			     u64 access_bits,
-			     gfn_t gfn)
-{
-	hpa_t paddr;
-
-	*shadow_pte |= access_bits << PT_SHADOW_BITS_OFFSET;
-	if (!dirty)
-		access_bits &= ~PT_WRITABLE_MASK;
-
-	paddr = gpa_to_hpa(vcpu, gaddr & PT64_BASE_ADDR_MASK);
-
-	*shadow_pte |= access_bits;
-
-	if (is_error_hpa(paddr)) {
-		*shadow_pte |= gaddr;
-		*shadow_pte |= PT_SHADOW_IO_MARK;
-		*shadow_pte &= ~PT_PRESENT_MASK;
-		return;
-	}
-
-	*shadow_pte |= paddr;
-
-	if (access_bits & PT_WRITABLE_MASK) {
-		struct kvm_mmu_page *shadow;
-
-		shadow = kvm_mmu_lookup_page(vcpu, gfn);
-		if (shadow) {
-			pgprintk("%s: found shadow page for %lx, marking ro\n",
-				 __FUNCTION__, gfn);
-			access_bits &= ~PT_WRITABLE_MASK;
-			if (is_writeble_pte(*shadow_pte)) {
-				    *shadow_pte &= ~PT_WRITABLE_MASK;
-				    kvm_arch_ops->tlb_flush(vcpu);
-			}
-		}
-	}
-
-	if (access_bits & PT_WRITABLE_MASK)
-		mark_page_dirty(vcpu->kvm, gaddr >> PAGE_SHIFT);
-
-	page_header_update_slot(vcpu->kvm, shadow_pte, gaddr);
-	rmap_add(vcpu, shadow_pte);
@@ -1009,17 +987,0 @@
-static inline int fix_read_pf(u64 *shadow_ent)
-{
-	if ((*shadow_ent & PT_SHADOW_USER_MASK) &&
-	    !(*shadow_ent & PT_USER_MASK)) {
-		/*
-		 * If supervisor write protect is disabled, we shadow kernel
-		 * pages as user pages so we can trap the write access.
-		 */
-		*shadow_ent |= PT_USER_MASK;
-		*shadow_ent &= ~PT_WRITABLE_MASK;
-
-		return 1;
-
-	}
-	return 0;
-}
-
@@ -1050,4 +1012 @@
-	mmu_alloc_roots(vcpu);
-	ASSERT(VALID_PAGE(context->root_hpa));
-	kvm_arch_ops->set_cr3(vcpu, context->root_hpa |
-		    (vcpu->cr3 & (CR3_PCD_MASK | CR3_WPT_MASK)));
+	context->root_hpa = INVALID_PAGE;
@@ -1072,4 +1031 @@
-	mmu_alloc_roots(vcpu);
-	ASSERT(VALID_PAGE(context->root_hpa));
-	kvm_arch_ops->set_cr3(vcpu, context->root_hpa |
-		    (vcpu->cr3 & (CR3_PCD_MASK | CR3_WPT_MASK)));
+	context->root_hpa = INVALID_PAGE;
@@ -1109,0 +1066,6 @@
+	destroy_kvm_mmu(vcpu);
+	return init_kvm_mmu(vcpu);
+}
+
+int kvm_mmu_load(struct kvm_vcpu *vcpu)
+{
@@ -1112,4 +1074 @@
-	destroy_kvm_mmu(vcpu);
-	r = init_kvm_mmu(vcpu);
-	if (r < 0)
-		goto out;
+	spin_lock(&vcpu->kvm->lock);
@@ -1116,0 +1076,5 @@
+	if (r)
+		goto out;
+	mmu_alloc_roots(vcpu);
+	kvm_arch_ops->set_cr3(vcpu, vcpu->mmu.root_hpa);
+	kvm_mmu_flush_tlb(vcpu);
@@ -1117,0 +1082 @@
+	spin_unlock(&vcpu->kvm->lock);
@@ -1119,0 +1085 @@
+EXPORT_SYMBOL_GPL(kvm_mmu_load);
@@ -1121 +1087,6 @@
-static void mmu_pre_write_zap_pte(struct kvm_vcpu *vcpu,
+void kvm_mmu_unload(struct kvm_vcpu *vcpu)
+{
+	mmu_free_roots(vcpu);
+}
+
+static void mmu_pte_write_zap_pte(struct kvm_vcpu *vcpu,
@@ -1131 +1102 @@
-			rmap_remove(vcpu, spte);
+			rmap_remove(spte);
@@ -1134 +1105 @@
-			mmu_page_remove_parent_pte(vcpu, child, spte);
+			mmu_page_remove_parent_pte(child, spte);
@@ -1137,0 +1109,15 @@
+	kvm_flush_remote_tlbs(vcpu->kvm);
+}
+
+static void mmu_pte_write_new_pte(struct kvm_vcpu *vcpu,
+				  struct kvm_mmu_page *page,
+				  u64 *spte,
+				  const void *new, int bytes)
+{
+	if (page->role.level != PT_PAGE_TABLE_LEVEL)
+		return;
+
+	if (page->role.glevels == PT32_ROOT_LEVEL)
+		paging32_update_pte(vcpu, page, spte, new, bytes);
+	else
+		paging64_update_pte(vcpu, page, spte, new, bytes);
@@ -1140 +1126,2 @@
-void kvm_mmu_pre_write(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes)
+void kvm_mmu_pte_write(struct kvm_vcpu *vcpu, gpa_t gpa,
+		       const u8 *old, const u8 *new, int bytes)
@@ -1151,0 +1139 @@
+	unsigned quadrant;
@@ -1171,0 +1160 @@
+		misaligned |= bytes < 4;
@@ -1185 +1174 @@
-			kvm_mmu_zap_page(vcpu, page);
+			kvm_mmu_zap_page(vcpu->kvm, page);
@@ -1202,0 +1192 @@
+			quadrant = page_offset >> PAGE_SHIFT;
@@ -1203,0 +1194,2 @@
+			if (quadrant != page->role.quadrant)
+				continue;
@@ -1205,2 +1197 @@
-		spte = __va(page->page_hpa);
-		spte += page_offset / sizeof(*spte);
+		spte = &page->spt[page_offset / sizeof(*spte)];
@@ -1208 +1199,2 @@
-			mmu_pre_write_zap_pte(vcpu, page, spte);
+			mmu_pte_write_zap_pte(vcpu, page, spte);
+			mmu_pte_write_new_pte(vcpu, page, spte, new, bytes);
@@ -1214,4 +1205,0 @@
-void kvm_mmu_post_write(struct kvm_vcpu *vcpu, gpa_t gpa, int bytes)
-{
-}
-
@@ -1225 +1213 @@
-void kvm_mmu_free_some_pages(struct kvm_vcpu *vcpu)
+void __kvm_mmu_free_some_pages(struct kvm_vcpu *vcpu)
@@ -1232 +1220 @@
-		kvm_mmu_zap_page(vcpu, page);
+		kvm_mmu_zap_page(vcpu->kvm, page);
@@ -1235 +1222,0 @@
-EXPORT_SYMBOL_GPL(kvm_mmu_free_some_pages);
@@ -1244,8 +1231 @@
-		kvm_mmu_zap_page(vcpu, page);
-	}
-	while (!list_empty(&vcpu->free_pages)) {
-		page = list_entry(vcpu->free_pages.next,
-				  struct kvm_mmu_page, link);
-		list_del(&page->link);
-		__free_page(pfn_to_page(page->page_hpa >> PAGE_SHIFT));
-		page->page_hpa = INVALID_PAGE;
+		kvm_mmu_zap_page(vcpu->kvm, page);
@@ -1263,12 +1243 @@
-	for (i = 0; i < KVM_NUM_MMU_PAGES; i++) {
-		struct kvm_mmu_page *page_header = &vcpu->page_header_buf[i];
-
-		INIT_LIST_HEAD(&page_header->link);
-		if ((page = alloc_page(GFP_KERNEL)) == NULL)
-			goto error_1;
-		set_page_private(page, (unsigned long)page_header);
-		page_header->page_hpa = (hpa_t)page_to_pfn(page) << PAGE_SHIFT;
-		memset(__va(page_header->page_hpa), 0, PAGE_SIZE);
-		list_add(&page_header->link, &vcpu->free_pages);
-		++vcpu->kvm->n_free_mmu_pages;
-	}
+	vcpu->kvm->n_free_mmu_pages = KVM_NUM_MMU_PAGES;
@@ -1299 +1267,0 @@
-	ASSERT(list_empty(&vcpu->free_pages));
@@ -1308 +1275,0 @@
-	ASSERT(!list_empty(&vcpu->free_pages));
@@ -1322 +1289 @@
-void kvm_mmu_slot_remove_write_access(struct kvm_vcpu *vcpu, int slot)
+void kvm_mmu_slot_remove_write_access(struct kvm *kvm, int slot)
@@ -1324 +1290,0 @@
-	struct kvm *kvm = vcpu->kvm;
@@ -1334 +1300 @@
-		pt = __va(page->page_hpa);
+		pt = page->spt;
@@ -1338 +1304 @@
-				rmap_remove(vcpu, &pt[i]);
+				rmap_remove(&pt[i]);
@@ -1344 +1310 @@
-void kvm_mmu_zap_all(struct kvm_vcpu *vcpu)
+void kvm_mmu_zap_all(struct kvm *kvm)
@@ -1346 +1312 @@
-	destroy_kvm_mmu(vcpu);
+	struct kvm_mmu_page *page, *node;
@@ -1348,2 +1314,2 @@
-	while (!list_empty(&vcpu->kvm->active_mmu_pages)) {
-		struct kvm_mmu_page *page;
+	list_for_each_entry_safe(page, node, &kvm->active_mmu_pages, link)
+		kvm_mmu_zap_page(kvm, page);
@@ -1351,8 +1317 @@
-		page = container_of(vcpu->kvm->active_mmu_pages.next,
-				    struct kvm_mmu_page, link);
-		kvm_mmu_zap_page(vcpu, page);
-	}
-
-	mmu_free_memory_caches(vcpu);
-	kvm_arch_ops->tlb_flush(vcpu);
-	init_kvm_mmu(vcpu);
+	kvm_flush_remote_tlbs(kvm);
@@ -1366,0 +1326,2 @@
+	if (mmu_page_header_cache)
+		kmem_cache_destroy(mmu_page_header_cache);
@@ -1373 +1334 @@
-					    0, 0, NULL, NULL);
+					    0, 0, NULL);
@@ -1378 +1339 @@
-					    0, 0, NULL, NULL);
+					    0, 0, NULL);
@@ -1381,0 +1343,6 @@
+	mmu_page_header_cache = kmem_cache_create("kvm_mmu_page_header",
+						  sizeof(struct kvm_mmu_page),
+						  0, 0, NULL);
+	if (!mmu_page_header_cache)
+		goto nomem;
+
@@ -1485 +1452 @@
-		u64 *pt = __va(page->page_hpa);
+		u64 *pt = page->spt;
--- ./projects/linux/linux-2.6.23/drivers/kvm/mmu.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/kvm/mmu.c	2008-01-24 23:58:37.000000000 +0100
@@ -161 +161 @@
-	return vcpu->cr0 & CR0_WP_MASK;
+	return vcpu->cr0 & X86_CR0_WP;
@@ -205,2 +205 @@
-				  struct kmem_cache *base_cache, int min,
-				  gfp_t gfp_flags)
+				  struct kmem_cache *base_cache, int min)
@@ -213 +212 @@
-		obj = kmem_cache_zalloc(base_cache, gfp_flags);
+		obj = kmem_cache_zalloc(base_cache, GFP_KERNEL);
@@ -228 +227 @@
-				       int min, gfp_t gfp_flags)
+				       int min)
@@ -235 +234 @@
-		page = alloc_page(gfp_flags);
+		page = alloc_page(GFP_KERNEL);
@@ -250 +249 @@
-static int __mmu_topup_memory_caches(struct kvm_vcpu *vcpu, gfp_t gfp_flags)
+static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)
@@ -253,0 +253 @@
+	kvm_mmu_free_some_pages(vcpu);
@@ -255 +255 @@
-				   pte_chain_cache, 4, gfp_flags);
+				   pte_chain_cache, 4);
@@ -259 +259 @@
-				   rmap_desc_cache, 1, gfp_flags);
+				   rmap_desc_cache, 1);
@@ -262 +262 @@
-	r = mmu_topup_memory_cache_page(&vcpu->mmu_page_cache, 4, gfp_flags);
+	r = mmu_topup_memory_cache_page(&vcpu->mmu_page_cache, 4);
@@ -266 +266 @@
-				   mmu_page_header_cache, 4, gfp_flags);
+				   mmu_page_header_cache, 4);
@@ -271,17 +270,0 @@
-static int mmu_topup_memory_caches(struct kvm_vcpu *vcpu)
-{
-	int r;
-
-	r = __mmu_topup_memory_caches(vcpu, GFP_NOWAIT);
-	kvm_mmu_free_some_pages(vcpu);
-	if (r < 0) {
-		spin_unlock(&vcpu->kvm->lock);
-		kvm_arch_ops->vcpu_put(vcpu);
-		r = __mmu_topup_memory_caches(vcpu, GFP_KERNEL);
-		kvm_arch_ops->vcpu_load(vcpu);
-		spin_lock(&vcpu->kvm->lock);
-		kvm_mmu_free_some_pages(vcpu);
-	}
-	return r;
-}
-
@@ -972 +955 @@
-	kvm_arch_ops->tlb_flush(vcpu);
+	kvm_x86_ops->tlb_flush(vcpu);
@@ -985 +968 @@
-	kvm_arch_ops->inject_page_fault(vcpu, addr, err_code);
+	kvm_x86_ops->inject_page_fault(vcpu, addr, err_code);
@@ -1068,0 +1052 @@
+EXPORT_SYMBOL_GPL(kvm_mmu_reset_context);
@@ -1074 +1058 @@
-	spin_lock(&vcpu->kvm->lock);
+	mutex_lock(&vcpu->kvm->lock);
@@ -1079 +1063 @@
-	kvm_arch_ops->set_cr3(vcpu, vcpu->mmu.root_hpa);
+	kvm_x86_ops->set_cr3(vcpu, vcpu->mmu.root_hpa);
@@ -1082 +1066 @@
-	spin_unlock(&vcpu->kvm->lock);
+	mutex_unlock(&vcpu->kvm->lock);
@@ -1108 +1092 @@
-	*spte = 0;
+	set_shadow_pte(spte, 0);
@@ -1127 +1111 @@
-		       const u8 *old, const u8 *new, int bytes)
+		       const u8 *new, int bytes)
--- ./projects/linux/linux-2.6.13/drivers/media/video/cx88/cx88-video.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/media/video/cx88/cx88-video.c	2005-10-28 02:02:08.000000000 +0200
@@ -2 +1,0 @@
- * $Id: cx88-video.c,v 1.82 2005/07/22 05:13:34 mkrufky Exp $
@@ -69 +68 @@
-	printk(KERN_DEBUG "%s/0: " fmt, dev->core->name , ## arg)
+	printk(KERN_DEBUG "%s/0: " fmt, core->name , ## arg)
@@ -328,0 +328 @@
+	struct cx88_core *core = dev->core;
@@ -334 +334 @@
-	down(&dev->lock);
+	down(&core->lock);
@@ -337 +337 @@
-		up(&dev->lock);
+		up(&core->lock);
@@ -344 +344 @@
-	up(&dev->lock);
+	up(&core->lock);
@@ -362,0 +363 @@
+	struct cx88_core *core = dev->core;
@@ -366 +367 @@
-	down(&dev->lock);
+	down(&core->lock);
@@ -370 +371 @@
-	up(&dev->lock);
+	up(&core->lock);
@@ -375 +376,2 @@
-static int video_mux(struct cx8800_dev *dev, unsigned int input)
+/* static int video_mux(struct cx8800_dev *dev, unsigned int input) */
+static int video_mux(struct cx88_core *core, unsigned int input)
@@ -377 +379 @@
-	struct cx88_core *core = dev->core;
+	/* struct cx88_core *core = dev->core; */
@@ -383 +385 @@
-	dev->core->input = input;
+	core->input = input;
@@ -416 +418 @@
-	cx88_sram_channel_setup(dev->core, &cx88_sram_channels[SRAM_CH21],
+	cx88_sram_channel_setup(core, &cx88_sram_channels[SRAM_CH21],
@@ -418 +420 @@
-	cx88_set_scale(dev->core, buf->vb.width, buf->vb.height, buf->vb.field);
+	cx88_set_scale(core, buf->vb.width, buf->vb.height, buf->vb.field);
@@ -426,0 +429,8 @@
+
+	/* Enables corresponding bits at PCI_INT_STAT:
+		bits 0 to 4: video, audio, transport stream, VIP, Host
+		bit 7: timer
+		bits 8 and 9: DMA complete for: SRC, DST
+		bits 10 and 11: BERR signal asserted for RISC: RD, WR
+		bits 12 to 15: BERR signal asserted for: BRDG, SRC, DST, IPB
+	 */
@@ -434 +444 @@
-	cx_set(MO_VID_DMACNTRL, 0x11);
+	cx_set(MO_VID_DMACNTRL, 0x11); /* Planar Y and packed FIFO and RISC enable */
@@ -457,0 +468 @@
+	struct cx88_core *core = dev->core;
@@ -526,0 +538 @@
+	struct cx88_core *core = dev->core;
@@ -531,2 +543,2 @@
-	if (fh->width  < 48 || fh->width  > norm_maxw(dev->core->tvnorm) ||
-	    fh->height < 32 || fh->height > norm_maxh(dev->core->tvnorm))
+	if (fh->width  < 48 || fh->width  > norm_maxw(core->tvnorm) ||
+	    fh->height < 32 || fh->height > norm_maxh(core->tvnorm))
@@ -611,0 +624 @@
+	struct cx88_core      *core = dev->core;
@@ -703,0 +717 @@
+	struct cx88_core *core;
@@ -727,0 +742,2 @@
+	core = dev->core;
+
@@ -758 +773,0 @@
-		struct cx88_core *core = dev->core;
@@ -765 +780 @@
-		dev->core->tvaudio = WW_FM;
+		core->tvaudio = WW_FM;
@@ -768 +783 @@
-		cx88_call_i2c_clients(dev->core,AUDC_SET_RADIO,NULL);
+		cx88_call_i2c_clients(core,AUDC_SET_RADIO,NULL);
@@ -859,0 +875,3 @@
+
+	cx88_call_i2c_clients (dev->core, TUNER_SET_STANDBY, NULL);
+
@@ -873 +891,2 @@
-static int get_control(struct cx8800_dev *dev, struct v4l2_control *ctl)
+/* static int get_control(struct cx8800_dev *dev, struct v4l2_control *ctl) */
+static int get_control(struct cx88_core *core, struct v4l2_control *ctl)
@@ -875 +894 @@
-	struct cx88_core *core = dev->core;
+	/* struct cx88_core *core = dev->core; */
@@ -901 +920,2 @@
-static int set_control(struct cx8800_dev *dev, struct v4l2_control *ctl)
+/* static int set_control(struct cx8800_dev *dev, struct v4l2_control *ctl) */
+static int set_control(struct cx88_core *core, struct v4l2_control *ctl)
@@ -903 +923 @@
-	struct cx88_core *core = dev->core;
+	/* struct cx88_core *core = dev->core; */
@@ -916 +936 @@
-		return -ERANGE;
+		ctl->value = c->v.minimum;
@@ -918 +938 @@
-		return -ERANGE;
+		ctl->value = c->v.maximum;
@@ -949 +969,2 @@
-static void init_controls(struct cx8800_dev *dev)
+/* static void init_controls(struct cx8800_dev *dev) */
+static void init_controls(struct cx88_core *core)
@@ -972,5 +993,5 @@
-	set_control(dev,&mute);
-	set_control(dev,&volume);
-	set_control(dev,&hue);
-	set_control(dev,&contrast);
-	set_control(dev,&brightness);
+	set_control(core,&mute);
+	set_control(core,&volume);
+	set_control(core,&hue);
+	set_control(core,&contrast);
+	set_control(core,&brightness);
@@ -1006,0 +1028,2 @@
+	struct cx88_core *core = dev->core;
+
@@ -1019,2 +1042,2 @@
-		maxw  = norm_maxw(dev->core->tvnorm);
-		maxh  = norm_maxh(dev->core->tvnorm);
+		maxw  = norm_maxw(core->tvnorm);
+		maxh  = norm_maxh(core->tvnorm);
@@ -1103,0 +1127,2 @@
+
+	/* --- capabilities ------------------------------------------ */
@@ -1109 +1134 @@
-                strcpy(cap->driver, "cx8800");
+		strcpy(cap->driver, "cx8800");
@@ -1118,0 +1144 @@
+			V4L2_CAP_VIDEO_OVERLAY |
@@ -1124,0 +1151,115 @@
+	/* --- capture ioctls ---------------------------------------- */
+	case VIDIOC_ENUM_FMT:
+	{
+		struct v4l2_fmtdesc *f = arg;
+		enum v4l2_buf_type type;
+		unsigned int index;
+
+		index = f->index;
+		type  = f->type;
+		switch (type) {
+		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
+			if (index >= ARRAY_SIZE(formats))
+				return -EINVAL;
+			memset(f,0,sizeof(*f));
+			f->index = index;
+			f->type  = type;
+			strlcpy(f->description,formats[index].name,sizeof(f->description));
+			f->pixelformat = formats[index].fourcc;
+			break;
+		default:
+			return -EINVAL;
+		}
+		return 0;
+	}
+	case VIDIOC_G_FMT:
+	{
+		struct v4l2_format *f = arg;
+		return cx8800_g_fmt(dev,fh,f);
+	}
+	case VIDIOC_S_FMT:
+	{
+		struct v4l2_format *f = arg;
+		return cx8800_s_fmt(dev,fh,f);
+	}
+	case VIDIOC_TRY_FMT:
+	{
+		struct v4l2_format *f = arg;
+		return cx8800_try_fmt(dev,fh,f);
+	}
+
+	/* --- streaming capture ------------------------------------- */
+	case VIDIOCGMBUF:
+	{
+		struct video_mbuf *mbuf = arg;
+		struct videobuf_queue *q;
+		struct v4l2_requestbuffers req;
+		unsigned int i;
+
+		q = get_queue(fh);
+		memset(&req,0,sizeof(req));
+		req.type   = q->type;
+		req.count  = 8;
+		req.memory = V4L2_MEMORY_MMAP;
+		err = videobuf_reqbufs(q,&req);
+		if (err < 0)
+			return err;
+		memset(mbuf,0,sizeof(*mbuf));
+		mbuf->frames = req.count;
+		mbuf->size   = 0;
+		for (i = 0; i < mbuf->frames; i++) {
+			mbuf->offsets[i]  = q->bufs[i]->boff;
+			mbuf->size       += q->bufs[i]->bsize;
+		}
+		return 0;
+	}
+	case VIDIOC_REQBUFS:
+		return videobuf_reqbufs(get_queue(fh), arg);
+
+	case VIDIOC_QUERYBUF:
+		return videobuf_querybuf(get_queue(fh), arg);
+
+	case VIDIOC_QBUF:
+		return videobuf_qbuf(get_queue(fh), arg);
+
+	case VIDIOC_DQBUF:
+		return videobuf_dqbuf(get_queue(fh), arg,
+					file->f_flags & O_NONBLOCK);
+
+	case VIDIOC_STREAMON:
+	{
+		int res = get_ressource(fh);
+
+		if (!res_get(dev,fh,res))
+			return -EBUSY;
+		return videobuf_streamon(get_queue(fh));
+	}
+	case VIDIOC_STREAMOFF:
+	{
+		int res = get_ressource(fh);
+
+		err = videobuf_streamoff(get_queue(fh));
+		if (err < 0)
+			return err;
+		res_free(dev,fh,res);
+		return 0;
+	}
+
+	default:
+		return cx88_do_ioctl( inode, file, fh->radio, core, cmd, arg, video_do_ioctl );
+	}
+	return 0;
+}
+
+int cx88_do_ioctl(struct inode *inode, struct file *file, int radio,
+                  struct cx88_core *core, unsigned int cmd, void *arg, v4l2_kioctl driver_ioctl)
+{
+	int err;
+
+	if (video_debug > 1)
+		cx88_print_ioctl(core->name,cmd);
+	printk( KERN_INFO "CORE IOCTL: 0x%x\n", cmd );
+	cx88_print_ioctl(core->name,cmd);
+	dprintk( 1, "CORE IOCTL: 0x%x\n", cmd );
+
+	switch (cmd) {
@@ -1159,3 +1300,3 @@
-		down(&dev->lock);
-		cx88_set_tvnorm(dev->core,&tvnorms[i]);
-		up(&dev->lock);
+		down(&core->lock);
+		cx88_set_tvnorm(core,&tvnorms[i]);
+		up(&core->lock);
@@ -1202 +1343 @@
-		*i = dev->core->input;
+		*i = core->input;
@@ -1211 +1352 @@
-		down(&dev->lock);
+		down(&core->lock);
@@ -1213,2 +1354,2 @@
-		video_mux(dev,*i);
-		up(&dev->lock);
+		video_mux(core,*i);
+		up(&core->lock);
@@ -1220,40 +1360,0 @@
-	/* --- capture ioctls ---------------------------------------- */
-	case VIDIOC_ENUM_FMT:
-	{
-		struct v4l2_fmtdesc *f = arg;
-		enum v4l2_buf_type type;
-		unsigned int index;
-
-		index = f->index;
-		type  = f->type;
-		switch (type) {
-		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-			if (index >= ARRAY_SIZE(formats))
-				return -EINVAL;
-			memset(f,0,sizeof(*f));
-			f->index = index;
-			f->type  = type;
-			strlcpy(f->description,formats[index].name,sizeof(f->description));
-			f->pixelformat = formats[index].fourcc;
-			break;
-		default:
-			return -EINVAL;
-		}
-		return 0;
-	}
-	case VIDIOC_G_FMT:
-	{
-		struct v4l2_format *f = arg;
-		return cx8800_g_fmt(dev,fh,f);
-	}
-	case VIDIOC_S_FMT:
-	{
-		struct v4l2_format *f = arg;
-		return cx8800_s_fmt(dev,fh,f);
-	}
-	case VIDIOC_TRY_FMT:
-	{
-		struct v4l2_format *f = arg;
-		return cx8800_try_fmt(dev,fh,f);
-	}
-
@@ -1280 +1381 @@
-		return get_control(dev,arg);
+		return get_control(core,arg);
@@ -1282 +1383 @@
-		return set_control(dev,arg);
+		return set_control(core,arg);
@@ -1326,2 +1427,3 @@
-		f->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;
-		f->frequency = dev->freq;
+		/* f->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV; */
+		f->type = radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;
+		f->frequency = core->freq;
@@ -1329 +1431 @@
-		cx88_call_i2c_clients(dev->core,VIDIOC_G_FREQUENCY,f);
+		cx88_call_i2c_clients(core,VIDIOC_G_FREQUENCY,f);
@@ -1341 +1443 @@
-		if (0 == fh->radio && f->type != V4L2_TUNER_ANALOG_TV)
+		if (0 == radio && f->type != V4L2_TUNER_ANALOG_TV)
@@ -1343 +1445 @@
-		if (1 == fh->radio && f->type != V4L2_TUNER_RADIO)
+		if (1 == radio && f->type != V4L2_TUNER_RADIO)
@@ -1345,2 +1447,2 @@
-		down(&dev->lock);
-		dev->freq = f->frequency;
+		down(&core->lock);
+		core->freq = f->frequency;
@@ -1348 +1450 @@
-		cx88_call_i2c_clients(dev->core,VIDIOC_S_FREQUENCY,f);
+		cx88_call_i2c_clients(core,VIDIOC_S_FREQUENCY,f);
@@ -1354,58 +1456 @@
-		up(&dev->lock);
-		return 0;
-	}
-
-	/* --- streaming capture ------------------------------------- */
-	case VIDIOCGMBUF:
-	{
-		struct video_mbuf *mbuf = arg;
-		struct videobuf_queue *q;
-		struct v4l2_requestbuffers req;
-		unsigned int i;
-
-		q = get_queue(fh);
-		memset(&req,0,sizeof(req));
-		req.type   = q->type;
-		req.count  = 8;
-		req.memory = V4L2_MEMORY_MMAP;
-		err = videobuf_reqbufs(q,&req);
-		if (err < 0)
-			return err;
-		memset(mbuf,0,sizeof(*mbuf));
-		mbuf->frames = req.count;
-		mbuf->size   = 0;
-		for (i = 0; i < mbuf->frames; i++) {
-			mbuf->offsets[i]  = q->bufs[i]->boff;
-			mbuf->size       += q->bufs[i]->bsize;
-		}
-		return 0;
-	}
-	case VIDIOC_REQBUFS:
-		return videobuf_reqbufs(get_queue(fh), arg);
-
-	case VIDIOC_QUERYBUF:
-		return videobuf_querybuf(get_queue(fh), arg);
-
-	case VIDIOC_QBUF:
-		return videobuf_qbuf(get_queue(fh), arg);
-
-	case VIDIOC_DQBUF:
-		return videobuf_dqbuf(get_queue(fh), arg,
-				      file->f_flags & O_NONBLOCK);
-
-	case VIDIOC_STREAMON:
-	{
-		int res = get_ressource(fh);
-
-                if (!res_get(dev,fh,res))
-			return -EBUSY;
-		return videobuf_streamon(get_queue(fh));
-	}
-	case VIDIOC_STREAMOFF:
-	{
-		int res = get_ressource(fh);
-
-		err = videobuf_streamoff(get_queue(fh));
-		if (err < 0)
-			return err;
-		res_free(dev,fh,res);
+		up(&core->lock);
@@ -1417 +1462 @@
-						  video_do_ioctl);
+						  driver_ioctl);
@@ -1464 +1509 @@
-		cx88_call_i2c_clients(dev->core,VIDIOC_G_TUNER,t);
+		cx88_call_i2c_clients(core,VIDIOC_G_TUNER,t);
@@ -1504,2 +1549,2 @@
-		cx88_call_i2c_clients(dev->core,VIDIOCSTUNER,v);
-                return 0;
+		cx88_call_i2c_clients(core,VIDIOCSTUNER,v);
+		return 0;
@@ -1514 +1559 @@
-		cx88_call_i2c_clients(dev->core,VIDIOC_S_TUNER,t);
+		cx88_call_i2c_clients(core,VIDIOC_S_TUNER,t);
@@ -1572 +1617 @@
-	cx88_sram_channel_dump(dev->core, &cx88_sram_channels[SRAM_CH21]);
+	cx88_sram_channel_dump(core, &cx88_sram_channels[SRAM_CH21]);
@@ -1617 +1662 @@
-		cx88_sram_channel_dump(dev->core, &cx88_sram_channels[SRAM_CH21]);
+		cx88_sram_channel_dump(core, &cx88_sram_channels[SRAM_CH21]);
@@ -1624 +1669 @@
-		cx88_wakeup(dev->core, &dev->vidq, count);
+		cx88_wakeup(core, &dev->vidq, count);
@@ -1632 +1677 @@
-		cx88_wakeup(dev->core, &dev->vbiq, count);
+		cx88_wakeup(core, &dev->vbiq, count);
@@ -1801 +1845,0 @@
-        init_MUTEX(&dev->lock);
@@ -1837,0 +1882 @@
+
@@ -1881,5 +1926,5 @@
-	down(&dev->lock);
-	init_controls(dev);
-	cx88_set_tvnorm(dev->core,tvnorms);
-	video_mux(dev,0);
-	up(&dev->lock);
+	down(&core->lock);
+	init_controls(core);
+	cx88_set_tvnorm(core,tvnorms);
+	video_mux(core,0);
+	up(&core->lock);
@@ -1904,0 +1950 @@
+	struct cx88_core *core = dev->core;
@@ -1907,3 +1953,3 @@
-	if (dev->core->kthread) {
-		kthread_stop(dev->core->kthread);
-		dev->core->kthread = NULL;
+	if (core->kthread) {
+		kthread_stop(core->kthread);
+		core->kthread = NULL;
@@ -1912 +1958 @@
-	cx88_shutdown(dev->core); /* FIXME */
+	cx88_shutdown(core); /* FIXME */
@@ -1924 +1970 @@
-	cx88_core_put(dev->core,dev->pci);
+	cx88_core_put(core,dev->pci);
@@ -1948 +1994 @@
-	cx88_shutdown(dev->core);
+	cx88_shutdown(core);
@@ -1961,0 +2008 @@
+	int err;
@@ -1964 +2011,7 @@
-		pci_enable_device(pci_dev);
+		err=pci_enable_device(pci_dev);
+		if (err) {
+			printk(KERN_ERR "%s: can't enable device\n",
+						       core->name);
+			return err;
+		}
+
@@ -1967 +2020,10 @@
-	pci_set_power_state(pci_dev, PCI_D0);
+	err= pci_set_power_state(pci_dev, PCI_D0);
+	if (err) {
+		printk(KERN_ERR "%s: can't enable device\n",
+				       core->name);
+
+		pci_disable_device(pci_dev);
+		dev->state.disabled = 1;
+
+		return err;
+	}
@@ -1971 +2033 @@
-	cx88_reset(dev->core);
+	cx88_reset(core);
@@ -2032,0 +2095,2 @@
+EXPORT_SYMBOL(cx88_do_ioctl);
+
--- ./projects/linux/linux-2.6.14/drivers/media/video/cx88/cx88-video.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/media/video/cx88/cx88-video.c	2006-01-03 04:21:10.000000000 +0100
@@ -36,0 +37,3 @@
+/* Include V4L1 specific functions. Should be removed soon */
+#include <linux/videodev.h>
+
@@ -103 +106 @@
-        },{
+	},{
@@ -473 +476 @@
-	        buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
+		buf = list_entry(q->active.next, struct cx88_buffer, vb.queue);
@@ -489 +492 @@
-	        buf = list_entry(q->queued.next, struct cx88_buffer, vb.queue);
+		buf = list_entry(q->queued.next, struct cx88_buffer, vb.queue);
@@ -786 +789 @@
-        return 0;
+	return 0;
@@ -790 +793 @@
-video_read(struct file *file, char *data, size_t count, loff_t *ppos)
+video_read(struct file *file, char __user *data, size_t count, loff_t *ppos)
@@ -925 +928 @@
-        u32 v_sat_value;
+	u32 v_sat_value;
@@ -1190 +1193 @@
-
+#ifdef HAVE_V4L1
@@ -1215,0 +1219 @@
+#endif
@@ -1247 +1250,0 @@
-
@@ -1255 +1258 @@
-                  struct cx88_core *core, unsigned int cmd, void *arg, v4l2_kioctl driver_ioctl)
+		  struct cx88_core *core, unsigned int cmd, void *arg, v4l2_kioctl driver_ioctl)
@@ -1258,0 +1262 @@
+	dprintk( 1, "CORE IOCTL: 0x%x\n", cmd );
@@ -1261,3 +1264,0 @@
-	printk( KERN_INFO "CORE IOCTL: 0x%x\n", cmd );
-	cx88_print_ioctl(core->name,cmd);
-	dprintk( 1, "CORE IOCTL: 0x%x\n", cmd );
@@ -1404 +1405 @@
-                t->signal = (reg & (1<<5)) ? 0xffff : 0x0000;
+		t->signal = (reg & (1<<5)) ? 0xffff : 0x0000;
@@ -1491 +1492 @@
-                strcpy(cap->driver, "cx8800");
+		strcpy(cap->driver, "cx8800");
@@ -1507,0 +1509 @@
+		t->type = V4L2_TUNER_RADIO;
@@ -1541,0 +1544 @@
+#ifdef HAVE_V4L1
@@ -1551,0 +1555 @@
+#endif
@@ -1832,2 +1836,2 @@
-        pci_read_config_byte(pci_dev, PCI_LATENCY_TIMER,  &dev->pci_lat);
-        printk(KERN_INFO "%s/0: found at %s, rev: %d, irq: %d, "
+	pci_read_config_byte(pci_dev, PCI_LATENCY_TIMER,  &dev->pci_lat);
+	printk(KERN_INFO "%s/0: found at %s, rev: %d, irq: %d, "
@@ -1949 +1953 @@
-        struct cx8800_dev *dev = pci_get_drvdata(pci_dev);
+	struct cx8800_dev *dev = pci_get_drvdata(pci_dev);
--- ./projects/linux/linux-2.6.15/drivers/media/video/cx88/cx88-video.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/media/video/cx88/cx88-video.c	2006-03-20 06:53:29.000000000 +0100
@@ -35,0 +36 @@
+#include <media/v4l2-common.h>
@@ -243 +244 @@
-			.default_value = 0,
+			.default_value = 0x3f,
@@ -274 +275 @@
-			.default_value = 0,
+			.default_value = 0x7f,
@@ -287,0 +289 @@
+			.default_value = 1,
@@ -301 +303 @@
-			.default_value = 0,
+			.default_value = 0x1f,
@@ -751 +753 @@
-	fh = kmalloc(sizeof(*fh),GFP_KERNEL);
+	fh = kzalloc(sizeof(*fh),GFP_KERNEL);
@@ -754 +755,0 @@
-	memset(fh,0,sizeof(*fh));
@@ -919,0 +921,3 @@
+	printk("get_control id=0x%X reg=0x%02x val=0x%02x (mask 0x%02x)%s\n",
+					ctl->id, c->reg, ctl->value,
+					c->mask, c->sreg ? " [shadowed]" : "");
@@ -928,2 +932 @@
-	u32 v_sat_value;
-	u32 value;
+	u32 value,mask;
@@ -931,3 +934,2 @@
-
-	for (i = 0; i < CX8800_CTLS; i++)
-		if (cx8800_ctls[i].v.id == ctl->id)
+	for (i = 0; i < CX8800_CTLS; i++) {
+		if (cx8800_ctls[i].v.id == ctl->id) {
@@ -934,0 +937,2 @@
+		}
+	}
@@ -941,0 +946 @@
+	mask=c->mask;
@@ -951,7 +956,12 @@
-		v_sat_value = ctl->value - (0x7f - 0x5a);
-		if (v_sat_value > 0xff)
-			v_sat_value = 0xff;
-		if (v_sat_value < 0x00)
-			v_sat_value = 0x00;
-		cx_andor(MO_UV_SATURATION, 0xff00, v_sat_value << 8);
-		/* fall through to default route for u_sat */
+
+		value = ((ctl->value - c->off) << c->shift) & c->mask;
+
+		if (core->tvnorm->id & V4L2_STD_SECAM) {
+			/* For SECAM, both U and V sat should be equal */
+			value=value<<8|value;
+		} else {
+			/* Keeps U Saturation proportional to V Sat */
+			value=(value*0x5a)/0x7f<<8|value;
+		}
+		mask=0xffff;
+		break;
@@ -962,2 +972,3 @@
-	dprintk(1,"set_control id=0x%X reg=0x%x val=0x%x%s\n",
-		ctl->id, c->reg, value, c->sreg ? " [shadowed]" : "");
+	printk("set_control id=0x%X reg=0x%02x val=0x%02x (mask 0x%02x)%s\n",
+					ctl->id, c->reg, value,
+					mask, c->sreg ? " [shadowed]" : "");
@@ -965 +976 @@
-		cx_sandor(c->sreg, c->reg, c->mask, value);
+		cx_sandor(c->sreg, c->reg, mask, value);
@@ -967 +978 @@
-		cx_andor(c->reg, c->mask, value);
+		cx_andor(c->reg, mask, value);
@@ -972 +982,0 @@
-/* static void init_controls(struct cx8800_dev *dev) */
@@ -975,20 +985,2 @@
-	static struct v4l2_control mute = {
-		.id    = V4L2_CID_AUDIO_MUTE,
-		.value = 1,
-	};
-	static struct v4l2_control volume = {
-		.id    = V4L2_CID_AUDIO_VOLUME,
-		.value = 0x3f,
-	};
-	static struct v4l2_control hue = {
-		.id    = V4L2_CID_HUE,
-		.value = 0x80,
-	};
-	static struct v4l2_control contrast = {
-		.id    = V4L2_CID_CONTRAST,
-		.value = 0x80,
-	};
-	static struct v4l2_control brightness = {
-		.id    = V4L2_CID_BRIGHTNESS,
-		.value = 0x80,
-	};
+	struct v4l2_control ctrl;
+	int i;
@@ -996,5 +988,6 @@
-	set_control(core,&mute);
-	set_control(core,&volume);
-	set_control(core,&hue);
-	set_control(core,&contrast);
-	set_control(core,&brightness);
+	for (i = 0; i < CX8800_CTLS; i++) {
+		ctrl.id=cx8800_ctls[i].v.id;
+		ctrl.value=cx8800_ctls[i].v.default_value
+				+cx8800_ctls[i].off;
+		set_control(core, &ctrl);
+	}
@@ -1128 +1121 @@
-		cx88_print_ioctl(core->name,cmd);
+		v4l_print_ioctl(core->name,cmd);
@@ -1264 +1257 @@
-		cx88_print_ioctl(core->name,cmd);
+		v4l_print_ioctl(core->name,cmd);
@@ -1484 +1477 @@
-		cx88_print_ioctl(core->name,cmd);
+		v4l_print_ioctl(core->name,cmd);
@@ -1742,0 +1736 @@
+	.compat_ioctl  = v4l_compat_ioctl32,
@@ -1769,0 +1764 @@
+	.compat_ioctl  = v4l_compat_ioctl32,
@@ -1816 +1811 @@
-	dev = kmalloc(sizeof(*dev),GFP_KERNEL);
+	dev = kzalloc(sizeof(*dev),GFP_KERNEL);
@@ -1819 +1813,0 @@
-	memset(dev,0,sizeof(*dev));
@@ -1931 +1924,0 @@
-	init_controls(core);
@@ -1932,0 +1926 @@
+	init_controls(core);
--- ./projects/linux/linux-2.6.16/drivers/media/video/cx88/cx88-video.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/media/video/cx88/cx88-video.c	2006-06-18 03:49:35.000000000 +0200
@@ -37,0 +38 @@
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
@@ -39,0 +41 @@
+#endif
@@ -230 +232 @@
-			.default_value = 0,
+			.default_value = 0x7f,
@@ -258 +260 @@
-			.default_value = 0,
+			.default_value = 0x7f,
@@ -303 +305 @@
-			.default_value = 0x1f,
+			.default_value = 0x3f,
@@ -339 +341 @@
-	down(&core->lock);
+	mutex_lock(&core->lock);
@@ -342 +344 @@
-		up(&core->lock);
+		mutex_unlock(&core->lock);
@@ -349 +351 @@
-	up(&core->lock);
+	mutex_unlock(&core->lock);
@@ -369,2 +371 @@
-	if ((fh->resources & bits) != bits)
-		BUG();
+	BUG_ON((fh->resources & bits) != bits);
@@ -372 +373 @@
-	down(&core->lock);
+	mutex_lock(&core->lock);
@@ -376 +377 @@
-	up(&core->lock);
+	mutex_unlock(&core->lock);
@@ -568 +569 @@
-		if (0 != (rc = videobuf_iolock(dev->pci,&buf->vb,NULL)))
+		if (0 != (rc = videobuf_iolock(q,&buf->vb,NULL)))
@@ -618 +619 @@
-	cx88_free_buffer(dev->pci,buf);
+	cx88_free_buffer(q,buf);
@@ -675 +675,0 @@
-	struct cx8800_fh   *fh  = q->priv_data;
@@ -677 +677 @@
-	cx88_free_buffer(fh->dev->pci,buf);
+	cx88_free_buffer(q,buf);
@@ -912 +912,2 @@
-		ctl->value = (value & 0x40) ? (value & 0x3f) : (0x40 - (value & 0x3f));
+		ctl->value = ((value & 0x7f) < 0x40) ? ((value & 0x7f) + 0x40)
+					: (0x7f - (value & 0x7f));
@@ -921,3 +922,3 @@
-	printk("get_control id=0x%X reg=0x%02x val=0x%02x (mask 0x%02x)%s\n",
-					ctl->id, c->reg, ctl->value,
-					c->mask, c->sreg ? " [shadowed]" : "");
+	dprintk(1,"get_control id=0x%X(%s) ctrl=0x%02x, reg=0x%02x val=0x%02x (mask 0x%02x)%s\n",
+				ctl->id, c->v.name, ctl->value, c->reg,
+				value,c->mask, c->sreg ? " [shadowed]" : "");
@@ -949 +950 @@
-		value = (ctl->value < 0x40) ? (0x40 - ctl->value) : ctl->value;
+		value = (ctl->value < 0x40) ? (0x7f - ctl->value) : (ctl->value - 0x40);
@@ -972,3 +973,3 @@
-	printk("set_control id=0x%X reg=0x%02x val=0x%02x (mask 0x%02x)%s\n",
-					ctl->id, c->reg, value,
-					mask, c->sreg ? " [shadowed]" : "");
+	dprintk(1,"set_control id=0x%X(%s) ctrl=0x%02x, reg=0x%02x val=0x%02x (mask 0x%02x)%s\n",
+				ctl->id, c->v.name, ctl->value, c->reg, value,
+				mask, c->sreg ? " [shadowed]" : "");
@@ -990,2 +991 @@
-		ctrl.value=cx8800_ctls[i].v.default_value
-				+cx8800_ctls[i].off;
+		ctrl.value=cx8800_ctls[i].v.default_value;
@@ -1255,3 +1255,11 @@
-	dprintk( 1, "CORE IOCTL: 0x%x\n", cmd );
-	if (video_debug > 1)
-		v4l_print_ioctl(core->name,cmd);
+       if (video_debug) {
+	       if (video_debug > 1) {
+		       if (_IOC_DIR(cmd) & _IOC_WRITE)
+			       v4l_printk_ioctl_arg("cx88(w)",cmd, arg);
+		       else if (!_IOC_DIR(cmd) & _IOC_READ) {
+			       v4l_print_ioctl("cx88", cmd);
+		       }
+	       } else
+		       v4l_print_ioctl(core->name,cmd);
+
+       }
@@ -1294 +1302 @@
-		down(&core->lock);
+		mutex_lock(&core->lock);
@@ -1296 +1304 @@
-		up(&core->lock);
+		mutex_unlock(&core->lock);
@@ -1346 +1354 @@
-		down(&core->lock);
+		mutex_lock(&core->lock);
@@ -1349 +1357 @@
-		up(&core->lock);
+		mutex_unlock(&core->lock);
@@ -1441 +1449 @@
-		down(&core->lock);
+		mutex_lock(&core->lock);
@@ -1450 +1458 @@
-		up(&core->lock);
+		mutex_unlock(&core->lock);
@@ -1464 +1472,13 @@
-	return video_usercopy(inode, file, cmd, arg, video_do_ioctl);
+       int retval;
+
+       retval=video_usercopy(inode, file, cmd, arg, video_do_ioctl);
+
+       if (video_debug > 1) {
+	       if (retval < 0) {
+		       v4l_print_ioctl("cx88(err)", cmd);
+		       printk(KERN_DEBUG "cx88(err): errcode=%d\n",retval);
+	       } else if (_IOC_DIR(cmd) & _IOC_READ)
+		       v4l_printk_ioctl_arg("cx88(r)",cmd, (void *)arg);
+       }
+
+       return retval;
@@ -1924 +1944 @@
-	down(&core->lock);
+	mutex_lock(&core->lock);
@@ -1928 +1948 @@
-	up(&core->lock);
+	mutex_unlock(&core->lock);
--- ./projects/linux/linux-2.6.17/drivers/media/video/cx88/cx88-video.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/media/video/cx88/cx88-video.c	2006-09-20 05:42:06.000000000 +0200
@@ -329,0 +330,45 @@
+const u32 cx88_user_ctrls[] = {
+	V4L2_CID_USER_CLASS,
+	V4L2_CID_BRIGHTNESS,
+	V4L2_CID_CONTRAST,
+	V4L2_CID_SATURATION,
+	V4L2_CID_HUE,
+	V4L2_CID_AUDIO_VOLUME,
+	V4L2_CID_AUDIO_BALANCE,
+	V4L2_CID_AUDIO_MUTE,
+	0
+};
+EXPORT_SYMBOL(cx88_user_ctrls);
+
+static const u32 *ctrl_classes[] = {
+	cx88_user_ctrls,
+	NULL
+};
+
+int cx8800_ctrl_query(struct v4l2_queryctrl *qctrl)
+{
+	int i;
+
+	if (qctrl->id < V4L2_CID_BASE ||
+	    qctrl->id >= V4L2_CID_LASTP1)
+		return -EINVAL;
+	for (i = 0; i < CX8800_CTLS; i++)
+		if (cx8800_ctls[i].v.id == qctrl->id)
+			break;
+	if (i == CX8800_CTLS) {
+		*qctrl = no_ctl;
+		return 0;
+	}
+	*qctrl = cx8800_ctls[i].v;
+	return 0;
+}
+EXPORT_SYMBOL(cx8800_ctrl_query);
+
+static int cx88_queryctrl(struct v4l2_queryctrl *qctrl)
+{
+	qctrl->id = v4l2_ctrl_next(ctrl_classes, qctrl->id);
+	if (qctrl->id == 0)
+		return -EINVAL;
+	return cx8800_ctrl_query(qctrl);
+}
+
@@ -497,2 +542 @@
-			list_del(&buf->vb.queue);
-			list_add_tail(&buf->vb.queue,&q->active);
+			list_move_tail(&buf->vb.queue, &q->active);
@@ -509,2 +553 @@
-			list_del(&buf->vb.queue);
-			list_add_tail(&buf->vb.queue,&q->active);
+			list_move_tail(&buf->vb.queue, &q->active);
@@ -1140 +1182,0 @@
-			V4L2_CAP_VIDEO_OVERLAY |
@@ -1186 +1228 @@
-#ifdef HAVE_V4L1
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
@@ -1367 +1408,0 @@
-		int i;
@@ -1369,12 +1410 @@
-		if (c->id <  V4L2_CID_BASE ||
-		    c->id >= V4L2_CID_LASTP1)
-			return -EINVAL;
-		for (i = 0; i < CX8800_CTLS; i++)
-			if (cx8800_ctls[i].v.id == c->id)
-				break;
-		if (i == CX8800_CTLS) {
-			*c = no_ctl;
-			return 0;
-		}
-		*c = cx8800_ctls[i].v;
-		return 0;
+		return cx88_queryctrl(c);
@@ -1557 +1587 @@
-#ifdef HAVE_V4L1
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
@@ -1852 +1882 @@
-	       "latency: %d, mmio: 0x%lx\n", core->name,
+	       "latency: %d, mmio: 0x%llx\n", core->name,
@@ -1854 +1884 @@
-	       dev->pci_lat,pci_resource_start(pci_dev,0));
+	       dev->pci_lat,(unsigned long long)pci_resource_start(pci_dev,0));
@@ -1887 +1917 @@
-			  SA_SHIRQ | SA_INTERRUPT, core->name, dev);
+			  IRQF_SHARED | IRQF_DISABLED, core->name, dev);
@@ -1898,2 +1927,0 @@
-	if (core->tda9887_conf)
-		request_module("tda9887");
--- ./projects/linux/linux-2.6.18/drivers/media/video/cx88/cx88-video.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/media/video/cx88/cx88-video.c	2006-11-29 22:57:37.000000000 +0100
@@ -499,0 +500 @@
+#ifdef CONFIG_PM
@@ -514,0 +516 @@
+#endif
@@ -1745 +1747 @@
-static irqreturn_t cx8800_irq(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t cx8800_irq(int irq, void *dev_id)
@@ -1928,0 +1931,3 @@
+	if (cx88_boards[ core->board ].audio_chip == AUDIO_CHIP_WM8775)
+		request_module("wm8775");
+
@@ -2019,0 +2025 @@
+#ifdef CONFIG_PM
@@ -2094,0 +2101 @@
+#endif
@@ -2115 +2122 @@
-
+#ifdef CONFIG_PM
@@ -2117,0 +2125 @@
+#endif
--- ./projects/linux/linux-2.6.19/drivers/media/video/cx88/cx88-video.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/media/video/cx88/cx88-video.c	2007-02-04 19:44:54.000000000 +0100
@@ -456,0 +457,8 @@
+
+	if (cx88_boards[core->board].mpeg & CX88_MPEG_BLACKBIRD) {
+		/* sets sound input from external adc */
+		if (INPUT(input)->extadc)
+			cx_set(AUD_CTL, EN_I2SIN_ENABLE);
+		else
+			cx_clear(AUD_CTL, EN_I2SIN_ENABLE);
+	}
@@ -1492,0 +1501,24 @@
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	/* ioctls to allow direct acces to the cx2388x registers */
+	case VIDIOC_INT_G_REGISTER:
+	{
+		struct v4l2_register *reg = arg;
+
+		if (reg->i2c_id != 0)
+			return -EINVAL;
+		/* cx2388x has a 24-bit register space */
+		reg->val = cx_read(reg->reg&0xffffff);
+		return 0;
+	}
+	case VIDIOC_INT_S_REGISTER:
+	{
+		struct v4l2_register *reg = arg;
+
+		if (reg->i2c_id != 0)
+			return -EINVAL;
+		if (!capable(CAP_SYS_ADMIN))
+			return -EPERM;
+		cx_write(reg->reg&0xffffff, reg->val);
+		return 0;
+	}
+#endif
--- ./projects/linux/linux-2.6.20/drivers/media/video/cx88/cx88-video.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/media/video/cx88/cx88-video.c	2007-04-26 05:08:32.000000000 +0200
@@ -0,0 +1 @@
+
@@ -7,0 +9,5 @@
+ * (c) 2005-2006 Mauro Carvalho Chehab <mchehab@infradead.org>
+ *	- Multituner support
+ *	- video_ioctl2 conversion
+ *	- PAL/M fixes
+ *
@@ -83,59 +88,0 @@
-static struct cx88_tvnorm tvnorms[] = {
-	{
-		.name      = "NTSC-M",
-		.id        = V4L2_STD_NTSC_M,
-		.cxiformat = VideoFormatNTSC,
-		.cxoformat = 0x181f0008,
-	},{
-		.name      = "NTSC-JP",
-		.id        = V4L2_STD_NTSC_M_JP,
-		.cxiformat = VideoFormatNTSCJapan,
-		.cxoformat = 0x181f0008,
-	},{
-		.name      = "PAL-BG",
-		.id        = V4L2_STD_PAL_BG,
-		.cxiformat = VideoFormatPAL,
-		.cxoformat = 0x181f0008,
-	},{
-		.name      = "PAL-DK",
-		.id        = V4L2_STD_PAL_DK,
-		.cxiformat = VideoFormatPAL,
-		.cxoformat = 0x181f0008,
-	},{
-		.name      = "PAL-I",
-		.id        = V4L2_STD_PAL_I,
-		.cxiformat = VideoFormatPAL,
-		.cxoformat = 0x181f0008,
-	},{
-		.name      = "PAL-M",
-		.id        = V4L2_STD_PAL_M,
-		.cxiformat = VideoFormatPALM,
-		.cxoformat = 0x1c1f0008,
-	},{
-		.name      = "PAL-N",
-		.id        = V4L2_STD_PAL_N,
-		.cxiformat = VideoFormatPALN,
-		.cxoformat = 0x1c1f0008,
-	},{
-		.name      = "PAL-Nc",
-		.id        = V4L2_STD_PAL_Nc,
-		.cxiformat = VideoFormatPALNC,
-		.cxoformat = 0x1c1f0008,
-	},{
-		.name      = "PAL-60",
-		.id        = V4L2_STD_PAL_60,
-		.cxiformat = VideoFormatPAL60,
-		.cxoformat = 0x181f0008,
-	},{
-		.name      = "SECAM-L",
-		.id        = V4L2_STD_SECAM_L,
-		.cxiformat = VideoFormatSECAM,
-		.cxoformat = 0x181f0008,
-	},{
-		.name      = "SECAM-DK",
-		.id        = V4L2_STD_SECAM_DK,
-		.cxiformat = VideoFormatSECAM,
-		.cxoformat = 0x181f0008,
-	}
-};
-
@@ -367,8 +313,0 @@
-static int cx88_queryctrl(struct v4l2_queryctrl *qctrl)
-{
-	qctrl->id = v4l2_ctrl_next(ctrl_classes, qctrl->id);
-	if (qctrl->id == 0)
-		return -EINVAL;
-	return cx8800_ctrl_query(qctrl);
-}
-
@@ -427,2 +366 @@
-/* static int video_mux(struct cx8800_dev *dev, unsigned int input) */
-static int video_mux(struct cx88_core *core, unsigned int input)
+int cx88_video_mux(struct cx88_core *core, unsigned int input)
@@ -466,0 +405 @@
+EXPORT_SYMBOL(cx88_video_mux);
@@ -946,0 +886 @@
+/* VIDEO CTRL IOCTLS                                                  */
@@ -948,2 +888 @@
-/* static int get_control(struct cx8800_dev *dev, struct v4l2_control *ctl) */
-static int get_control(struct cx88_core *core, struct v4l2_control *ctl)
+int cx88_get_control (struct cx88_core  *core, struct v4l2_control *ctl)
@@ -951,2 +890 @@
-	/* struct cx88_core *core = dev->core; */
-	struct cx88_ctrl *c = NULL;
+	struct cx88_ctrl  *c    = NULL;
@@ -959 +897 @@
-	if (NULL == c)
+	if (unlikely(NULL == c))
@@ -979,0 +918 @@
+EXPORT_SYMBOL(cx88_get_control);
@@ -981,2 +920 @@
-/* static int set_control(struct cx8800_dev *dev, struct v4l2_control *ctl) */
-static int set_control(struct cx88_core *core, struct v4l2_control *ctl)
+int cx88_set_control(struct cx88_core *core, struct v4l2_control *ctl)
@@ -984 +921,0 @@
-	/* struct cx88_core *core = dev->core; */
@@ -987,0 +925 @@
+
@@ -993 +931 @@
-	if (NULL == c)
+	if (unlikely(NULL == c))
@@ -1013 +951 @@
-		if (core->tvnorm->id & V4L2_STD_SECAM) {
+		if (core->tvnorm & V4L2_STD_SECAM) {
@@ -1035,0 +974 @@
+EXPORT_SYMBOL(cx88_set_control);
@@ -1045 +984,2 @@
-		set_control(core, &ctrl);
+
+		cx88_set_control(core, &ctrl);
@@ -1049,0 +990,17 @@
+/* VIDEO IOCTLS                                                       */
+
+static int vidioc_g_fmt_cap (struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct cx8800_fh  *fh   = priv;
+
+	f->fmt.pix.width        = fh->width;
+	f->fmt.pix.height       = fh->height;
+	f->fmt.pix.field        = fh->vidq.field;
+	f->fmt.pix.pixelformat  = fh->fmt->fourcc;
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * fh->fmt->depth) >> 3;
+	f->fmt.pix.sizeimage =
+		f->fmt.pix.height * f->fmt.pix.bytesperline;
+	return 0;
+}
@@ -1051 +1008 @@
-static int cx8800_g_fmt(struct cx8800_dev *dev, struct cx8800_fh *fh,
+static int vidioc_try_fmt_cap (struct file *file, void *priv,
@@ -1054,15 +1011,26 @@
-	switch (f->type) {
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		memset(&f->fmt.pix,0,sizeof(f->fmt.pix));
-		f->fmt.pix.width        = fh->width;
-		f->fmt.pix.height       = fh->height;
-		f->fmt.pix.field        = fh->vidq.field;
-		f->fmt.pix.pixelformat  = fh->fmt->fourcc;
-		f->fmt.pix.bytesperline =
-			(f->fmt.pix.width * fh->fmt->depth) >> 3;
-		f->fmt.pix.sizeimage =
-			f->fmt.pix.height * f->fmt.pix.bytesperline;
-		return 0;
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-		cx8800_vbi_fmt(dev, f);
-		return 0;
+	struct cx88_core  *core = ((struct cx8800_fh *)priv)->dev->core;
+	struct cx8800_fmt *fmt;
+	enum v4l2_field   field;
+	unsigned int      maxw, maxh;
+
+	fmt = format_by_fourcc(f->fmt.pix.pixelformat);
+	if (NULL == fmt)
+		return -EINVAL;
+
+	field = f->fmt.pix.field;
+	maxw  = norm_maxw(core->tvnorm);
+	maxh  = norm_maxh(core->tvnorm);
+
+	if (V4L2_FIELD_ANY == field) {
+		field = (f->fmt.pix.height > maxh/2)
+			? V4L2_FIELD_INTERLACED
+			: V4L2_FIELD_BOTTOM;
+	}
+
+	switch (field) {
+	case V4L2_FIELD_TOP:
+	case V4L2_FIELD_BOTTOM:
+		maxh = maxh / 2;
+		break;
+	case V4L2_FIELD_INTERLACED:
+		break;
@@ -1071,0 +1040,17 @@
+
+	f->fmt.pix.field = field;
+	if (f->fmt.pix.height < 32)
+		f->fmt.pix.height = 32;
+	if (f->fmt.pix.height > maxh)
+		f->fmt.pix.height = maxh;
+	if (f->fmt.pix.width < 48)
+		f->fmt.pix.width = 48;
+	if (f->fmt.pix.width > maxw)
+		f->fmt.pix.width = maxw;
+	f->fmt.pix.width &= ~0x03;
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * fmt->depth) >> 3;
+	f->fmt.pix.sizeimage =
+		f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+	return 0;
@@ -1074,2 +1059,2 @@
-static int cx8800_try_fmt(struct cx8800_dev *dev, struct cx8800_fh *fh,
-			  struct v4l2_format *f)
+static int vidioc_s_fmt_cap (struct file *file, void *priv,
+					struct v4l2_format *f)
@@ -1077 +1062,2 @@
-	struct cx88_core *core = dev->core;
+	struct cx8800_fh  *fh   = priv;
+	int err = vidioc_try_fmt_cap (file,priv,f);
@@ -1079,20 +1065,8 @@
-	switch (f->type) {
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-	{
-		struct cx8800_fmt *fmt;
-		enum v4l2_field field;
-		unsigned int maxw, maxh;
-
-		fmt = format_by_fourcc(f->fmt.pix.pixelformat);
-		if (NULL == fmt)
-			return -EINVAL;
-
-		field = f->fmt.pix.field;
-		maxw  = norm_maxw(core->tvnorm);
-		maxh  = norm_maxh(core->tvnorm);
-
-		if (V4L2_FIELD_ANY == field) {
-			field = (f->fmt.pix.height > maxh/2)
-				? V4L2_FIELD_INTERLACED
-				: V4L2_FIELD_BOTTOM;
-		}
+	if (0 != err)
+		return err;
+	fh->fmt        = format_by_fourcc(f->fmt.pix.pixelformat);
+	fh->width      = f->fmt.pix.width;
+	fh->height     = f->fmt.pix.height;
+	fh->vidq.field = f->fmt.pix.field;
+	return 0;
+}
@@ -1100,10 +1074,5 @@
-		switch (field) {
-		case V4L2_FIELD_TOP:
-		case V4L2_FIELD_BOTTOM:
-			maxh = maxh / 2;
-			break;
-		case V4L2_FIELD_INTERLACED:
-			break;
-		default:
-			return -EINVAL;
-		}
+static int vidioc_querycap (struct file *file, void  *priv,
+					struct v4l2_capability *cap)
+{
+	struct cx8800_dev *dev  = ((struct cx8800_fh *)priv)->dev;
+	struct cx88_core  *core = dev->core;
@@ -1111,14 +1080,14 @@
-		f->fmt.pix.field = field;
-		if (f->fmt.pix.height < 32)
-			f->fmt.pix.height = 32;
-		if (f->fmt.pix.height > maxh)
-			f->fmt.pix.height = maxh;
-		if (f->fmt.pix.width < 48)
-			f->fmt.pix.width = 48;
-		if (f->fmt.pix.width > maxw)
-			f->fmt.pix.width = maxw;
-		f->fmt.pix.width &= ~0x03;
-		f->fmt.pix.bytesperline =
-			(f->fmt.pix.width * fmt->depth) >> 3;
-		f->fmt.pix.sizeimage =
-			f->fmt.pix.height * f->fmt.pix.bytesperline;
+	strcpy(cap->driver, "cx8800");
+	strlcpy(cap->card, cx88_boards[core->board].name,
+		sizeof(cap->card));
+	sprintf(cap->bus_info,"PCI:%s",pci_name(dev->pci));
+	cap->version = CX88_VERSION_CODE;
+	cap->capabilities =
+		V4L2_CAP_VIDEO_CAPTURE |
+		V4L2_CAP_READWRITE     |
+		V4L2_CAP_STREAMING     |
+		V4L2_CAP_VBI_CAPTURE;
+	if (UNSET != core->tuner_type)
+		cap->capabilities |= V4L2_CAP_TUNER;
+	return 0;
+}
@@ -1126,6 +1095,4 @@
-		return 0;
-	}
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-		cx8800_vbi_fmt(dev, f);
-		return 0;
-	default:
+static int vidioc_enum_fmt_cap (struct file *file, void  *priv,
+					struct v4l2_fmtdesc *f)
+{
+	if (unlikely(f->index >= ARRAY_SIZE(formats)))
@@ -1133 +1100,5 @@
-	}
+
+	strlcpy(f->description,formats[f->index].name,sizeof(f->description));
+	f->pixelformat = formats[f->index].fourcc;
+
+	return 0;
@@ -1136,2 +1107,2 @@
-static int cx8800_s_fmt(struct cx8800_dev *dev, struct cx8800_fh *fh,
-			struct v4l2_format *f)
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+static int vidiocgmbuf (struct file *file, void *priv, struct video_mbuf *mbuf)
@@ -1138,0 +1110,4 @@
+	struct cx8800_fh           *fh   = priv;
+	struct videobuf_queue      *q;
+	struct v4l2_requestbuffers req;
+	unsigned int i;
@@ -1141,5 +1116,8 @@
-	switch (f->type) {
-	case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-		err = cx8800_try_fmt(dev,fh,f);
-		if (0 != err)
-			return err;
+	q = get_queue(fh);
+	memset(&req,0,sizeof(req));
+	req.type   = q->type;
+	req.count  = 8;
+	req.memory = V4L2_MEMORY_MMAP;
+	err = videobuf_reqbufs(q,&req);
+	if (err < 0)
+		return err;
@@ -1147,10 +1125,5 @@
-		fh->fmt        = format_by_fourcc(f->fmt.pix.pixelformat);
-		fh->width      = f->fmt.pix.width;
-		fh->height     = f->fmt.pix.height;
-		fh->vidq.field = f->fmt.pix.field;
-		return 0;
-	case V4L2_BUF_TYPE_VBI_CAPTURE:
-		cx8800_vbi_fmt(dev, f);
-		return 0;
-	default:
-		return -EINVAL;
+	mbuf->frames = req.count;
+	mbuf->size   = 0;
+	for (i = 0; i < mbuf->frames; i++) {
+		mbuf->offsets[i]  = q->bufs[i]->boff;
+		mbuf->size       += q->bufs[i]->bsize;
@@ -1157,0 +1131 @@
+	return 0;
@@ -1158,0 +1133 @@
+#endif
@@ -1160,7 +1135 @@
-/*
- * This function is _not_ called directly, but from
- * video_generic_ioctl (and maybe others).  userspace
- * copying is done already, arg is a kernel pointer.
- */
-static int video_do_ioctl(struct inode *inode, struct file *file,
-			  unsigned int cmd, void *arg)
+static int vidioc_reqbufs (struct file *file, void *priv, struct v4l2_requestbuffers *p)
@@ -1168,8 +1137,3 @@
-	struct cx8800_fh  *fh   = file->private_data;
-	struct cx8800_dev *dev  = fh->dev;
-	struct cx88_core  *core = dev->core;
-	int err;
-
-	if (video_debug > 1)
-		v4l_print_ioctl(core->name,cmd);
-	switch (cmd) {
+	struct cx8800_fh  *fh   = priv;
+	return (videobuf_reqbufs(get_queue(fh), p));
+}
@@ -1177,4 +1141,5 @@
-	/* --- capabilities ------------------------------------------ */
-	case VIDIOC_QUERYCAP:
-	{
-		struct v4l2_capability *cap = arg;
+static int vidioc_querybuf (struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct cx8800_fh  *fh   = priv;
+	return (videobuf_querybuf(get_queue(fh), p));
+}
@@ -1182,16 +1147,5 @@
-		memset(cap,0,sizeof(*cap));
-		strcpy(cap->driver, "cx8800");
-		strlcpy(cap->card, cx88_boards[core->board].name,
-			sizeof(cap->card));
-		sprintf(cap->bus_info,"PCI:%s",pci_name(dev->pci));
-		cap->version = CX88_VERSION_CODE;
-		cap->capabilities =
-			V4L2_CAP_VIDEO_CAPTURE |
-			V4L2_CAP_READWRITE     |
-			V4L2_CAP_STREAMING     |
-			V4L2_CAP_VBI_CAPTURE   |
-			0;
-		if (UNSET != core->tuner_type)
-			cap->capabilities |= V4L2_CAP_TUNER;
-		return 0;
-	}
+static int vidioc_qbuf (struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct cx8800_fh  *fh   = priv;
+	return (videobuf_qbuf(get_queue(fh), p));
+}
@@ -1199,68 +1153,6 @@
-	/* --- capture ioctls ---------------------------------------- */
-	case VIDIOC_ENUM_FMT:
-	{
-		struct v4l2_fmtdesc *f = arg;
-		enum v4l2_buf_type type;
-		unsigned int index;
-
-		index = f->index;
-		type  = f->type;
-		switch (type) {
-		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-			if (index >= ARRAY_SIZE(formats))
-				return -EINVAL;
-			memset(f,0,sizeof(*f));
-			f->index = index;
-			f->type  = type;
-			strlcpy(f->description,formats[index].name,sizeof(f->description));
-			f->pixelformat = formats[index].fourcc;
-			break;
-		default:
-			return -EINVAL;
-		}
-		return 0;
-	}
-	case VIDIOC_G_FMT:
-	{
-		struct v4l2_format *f = arg;
-		return cx8800_g_fmt(dev,fh,f);
-	}
-	case VIDIOC_S_FMT:
-	{
-		struct v4l2_format *f = arg;
-		return cx8800_s_fmt(dev,fh,f);
-	}
-	case VIDIOC_TRY_FMT:
-	{
-		struct v4l2_format *f = arg;
-		return cx8800_try_fmt(dev,fh,f);
-	}
-#ifdef CONFIG_VIDEO_V4L1_COMPAT
-	/* --- streaming capture ------------------------------------- */
-	case VIDIOCGMBUF:
-	{
-		struct video_mbuf *mbuf = arg;
-		struct videobuf_queue *q;
-		struct v4l2_requestbuffers req;
-		unsigned int i;
-
-		q = get_queue(fh);
-		memset(&req,0,sizeof(req));
-		req.type   = q->type;
-		req.count  = 8;
-		req.memory = V4L2_MEMORY_MMAP;
-		err = videobuf_reqbufs(q,&req);
-		if (err < 0)
-			return err;
-		memset(mbuf,0,sizeof(*mbuf));
-		mbuf->frames = req.count;
-		mbuf->size   = 0;
-		for (i = 0; i < mbuf->frames; i++) {
-			mbuf->offsets[i]  = q->bufs[i]->boff;
-			mbuf->size       += q->bufs[i]->bsize;
-		}
-		return 0;
-	}
-#endif
-	case VIDIOC_REQBUFS:
-		return videobuf_reqbufs(get_queue(fh), arg);
+static int vidioc_dqbuf (struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct cx8800_fh  *fh   = priv;
+	return (videobuf_dqbuf(get_queue(fh), p,
+				file->f_flags & O_NONBLOCK));
+}
@@ -1268,2 +1160,4 @@
-	case VIDIOC_QUERYBUF:
-		return videobuf_querybuf(get_queue(fh), arg);
+static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct cx8800_fh  *fh   = priv;
+	struct cx8800_dev *dev  = fh->dev;
@@ -1271,2 +1165,4 @@
-	case VIDIOC_QBUF:
-		return videobuf_qbuf(get_queue(fh), arg);
+	if (unlikely(fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE))
+		return -EINVAL;
+	if (unlikely(i != fh->type))
+		return -EINVAL;
@@ -1274,3 +1170,4 @@
-	case VIDIOC_DQBUF:
-		return videobuf_dqbuf(get_queue(fh), arg,
-					file->f_flags & O_NONBLOCK);
+	if (unlikely(!res_get(dev,fh,get_ressource(fh))))
+		return -EBUSY;
+	return videobuf_streamon(get_queue(fh));
+}
@@ -1278,3 +1175,5 @@
-	case VIDIOC_STREAMON:
-	{
-		int res = get_ressource(fh);
+static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct cx8800_fh  *fh   = priv;
+	struct cx8800_dev *dev  = fh->dev;
+	int               err, res;
@@ -1282,7 +1181,4 @@
-		if (!res_get(dev,fh,res))
-			return -EBUSY;
-		return videobuf_streamon(get_queue(fh));
-	}
-	case VIDIOC_STREAMOFF:
-	{
-		int res = get_ressource(fh);
+	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (i != fh->type)
+		return -EINVAL;
@@ -1290,9 +1186,5 @@
-		err = videobuf_streamoff(get_queue(fh));
-		if (err < 0)
-			return err;
-		res_free(dev,fh,res);
-		return 0;
-	}
-	default:
-		return cx88_do_ioctl( inode, file, fh->radio, core, cmd, arg, video_do_ioctl );
-	}
+	res = get_ressource(fh);
+	err = videobuf_streamoff(get_queue(fh));
+	if (err < 0)
+		return err;
+	res_free(dev,fh,res);
@@ -1302,2 +1194 @@
-int cx88_do_ioctl(struct inode *inode, struct file *file, int radio,
-		  struct cx88_core *core, unsigned int cmd, void *arg, v4l2_kioctl driver_ioctl)
+static int vidioc_s_std (struct file *file, void *priv, v4l2_std_id *tvnorms)
@@ -1305 +1196 @@
-	int err;
+	struct cx88_core  *core = ((struct cx8800_fh *)priv)->dev->core;
@@ -1307,18 +1198,3 @@
-       if (video_debug) {
-	       if (video_debug > 1) {
-		       if (_IOC_DIR(cmd) & _IOC_WRITE)
-			       v4l_printk_ioctl_arg("cx88(w)",cmd, arg);
-		       else if (!_IOC_DIR(cmd) & _IOC_READ) {
-			       v4l_print_ioctl("cx88", cmd);
-		       }
-	       } else
-		       v4l_print_ioctl(core->name,cmd);
-
-       }
-
-	switch (cmd) {
-	/* ---------- tv norms ---------- */
-	case VIDIOC_ENUMSTD:
-	{
-		struct v4l2_standard *e = arg;
-		unsigned int i;
+	mutex_lock(&core->lock);
+	cx88_set_tvnorm(core,*tvnorms);
+	mutex_unlock(&core->lock);
@@ -1326,13 +1202,2 @@
-		i = e->index;
-		if (i >= ARRAY_SIZE(tvnorms))
-			return -EINVAL;
-		err = v4l2_video_std_construct(e, tvnorms[e->index].id,
-					       tvnorms[e->index].name);
-		e->index = i;
-		if (err < 0)
-			return err;
-		return 0;
-	}
-	case VIDIOC_G_STD:
-	{
-		v4l2_std_id *id = arg;
+	return 0;
+}
@@ -1340,7 +1205,15 @@
-		*id = core->tvnorm->id;
-		return 0;
-	}
-	case VIDIOC_S_STD:
-	{
-		v4l2_std_id *id = arg;
-		unsigned int i;
+/* only one input in this sample driver */
+int cx88_enum_input (struct cx88_core  *core,struct v4l2_input *i)
+{
+	static const char *iname[] = {
+		[ CX88_VMUX_COMPOSITE1 ] = "Composite1",
+		[ CX88_VMUX_COMPOSITE2 ] = "Composite2",
+		[ CX88_VMUX_COMPOSITE3 ] = "Composite3",
+		[ CX88_VMUX_COMPOSITE4 ] = "Composite4",
+		[ CX88_VMUX_SVIDEO     ] = "S-Video",
+		[ CX88_VMUX_TELEVISION ] = "Television",
+		[ CX88_VMUX_CABLE      ] = "Cable TV",
+		[ CX88_VMUX_DVB        ] = "DVB",
+		[ CX88_VMUX_DEBUG      ] = "for debug only",
+	};
+	unsigned int n;
@@ -1348,5 +1221,16 @@
-		for(i = 0; i < ARRAY_SIZE(tvnorms); i++)
-			if (*id & tvnorms[i].id)
-				break;
-		if (i == ARRAY_SIZE(tvnorms))
-			return -EINVAL;
+	n = i->index;
+	if (n >= 4)
+		return -EINVAL;
+	if (0 == INPUT(n)->type)
+		return -EINVAL;
+	memset(i,0,sizeof(*i));
+	i->index = n;
+	i->type  = V4L2_INPUT_TYPE_CAMERA;
+	strcpy(i->name,iname[INPUT(n)->type]);
+	if ((CX88_VMUX_TELEVISION == INPUT(n)->type) ||
+		(CX88_VMUX_CABLE      == INPUT(n)->type))
+		i->type = V4L2_INPUT_TYPE_TUNER;
+		i->std = CX88_NORMS;
+	return 0;
+}
+EXPORT_SYMBOL(cx88_enum_input);
@@ -1354,5 +1238,6 @@
-		mutex_lock(&core->lock);
-		cx88_set_tvnorm(core,&tvnorms[i]);
-		mutex_unlock(&core->lock);
-		return 0;
-	}
+static int vidioc_enum_input (struct file *file, void *priv,
+				struct v4l2_input *i)
+{
+	struct cx88_core  *core = ((struct cx8800_fh *)priv)->dev->core;
+	return cx88_enum_input (core,i);
+}
@@ -1360,36 +1245,3 @@
-	/* ------ input switching ---------- */
-	case VIDIOC_ENUMINPUT:
-	{
-		static const char *iname[] = {
-			[ CX88_VMUX_COMPOSITE1 ] = "Composite1",
-			[ CX88_VMUX_COMPOSITE2 ] = "Composite2",
-			[ CX88_VMUX_COMPOSITE3 ] = "Composite3",
-			[ CX88_VMUX_COMPOSITE4 ] = "Composite4",
-			[ CX88_VMUX_SVIDEO     ] = "S-Video",
-			[ CX88_VMUX_TELEVISION ] = "Television",
-			[ CX88_VMUX_CABLE      ] = "Cable TV",
-			[ CX88_VMUX_DVB        ] = "DVB",
-			[ CX88_VMUX_DEBUG      ] = "for debug only",
-		};
-		struct v4l2_input *i = arg;
-		unsigned int n;
-
-		n = i->index;
-		if (n >= 4)
-			return -EINVAL;
-		if (0 == INPUT(n)->type)
-			return -EINVAL;
-		memset(i,0,sizeof(*i));
-		i->index = n;
-		i->type  = V4L2_INPUT_TYPE_CAMERA;
-		strcpy(i->name,iname[INPUT(n)->type]);
-		if ((CX88_VMUX_TELEVISION == INPUT(n)->type) ||
-		    (CX88_VMUX_CABLE      == INPUT(n)->type))
-			i->type = V4L2_INPUT_TYPE_TUNER;
-		for (n = 0; n < ARRAY_SIZE(tvnorms); n++)
-			i->std |= tvnorms[n].id;
-		return 0;
-	}
-	case VIDIOC_G_INPUT:
-	{
-		unsigned int *i = arg;
+static int vidioc_g_input (struct file *file, void *priv, unsigned int *i)
+{
+	struct cx88_core  *core = ((struct cx8800_fh *)priv)->dev->core;
@@ -1397,6 +1249,3 @@
-		*i = core->input;
-		return 0;
-	}
-	case VIDIOC_S_INPUT:
-	{
-		unsigned int *i = arg;
+	*i = core->input;
+	return 0;
+}
@@ -1404,8 +1253,3 @@
-		if (*i >= 4)
-			return -EINVAL;
-		mutex_lock(&core->lock);
-		cx88_newstation(core);
-		video_mux(core,*i);
-		mutex_unlock(&core->lock);
-		return 0;
-	}
+static int vidioc_s_input (struct file *file, void *priv, unsigned int i)
+{
+	struct cx88_core  *core = ((struct cx8800_fh *)priv)->dev->core;
@@ -1412,0 +1257,2 @@
+	if (i >= 4)
+		return -EINVAL;
@@ -1413,0 +1260,6 @@
+	mutex_lock(&core->lock);
+	cx88_newstation(core);
+	cx88_video_mux(core,i);
+	mutex_unlock(&core->lock);
+	return 0;
+}
@@ -1415,4 +1266,0 @@
-	/* --- controls ---------------------------------------------- */
-	case VIDIOC_QUERYCTRL:
-	{
-		struct v4l2_queryctrl *c = arg;
@@ -1420,6 +1267,0 @@
-		return cx88_queryctrl(c);
-	}
-	case VIDIOC_G_CTRL:
-		return get_control(core,arg);
-	case VIDIOC_S_CTRL:
-		return set_control(core,arg);
@@ -1427,5 +1269,8 @@
-	/* --- tuner ioctls ------------------------------------------ */
-	case VIDIOC_G_TUNER:
-	{
-		struct v4l2_tuner *t = arg;
-		u32 reg;
+static int vidioc_queryctrl (struct file *file, void *priv,
+				struct v4l2_queryctrl *qctrl)
+{
+	qctrl->id = v4l2_ctrl_next(ctrl_classes, qctrl->id);
+	if (unlikely(qctrl->id == 0))
+		return -EINVAL;
+	return cx8800_ctrl_query(qctrl);
+}
@@ -1433,19 +1278,7 @@
-		if (UNSET == core->tuner_type)
-			return -EINVAL;
-		if (0 != t->index)
-			return -EINVAL;
-
-		memset(t,0,sizeof(*t));
-		strcpy(t->name, "Television");
-		t->type       = V4L2_TUNER_ANALOG_TV;
-		t->capability = V4L2_TUNER_CAP_NORM;
-		t->rangehigh  = 0xffffffffUL;
-
-		cx88_get_stereo(core ,t);
-		reg = cx_read(MO_DEVICE_STATUS);
-		t->signal = (reg & (1<<5)) ? 0xffff : 0x0000;
-		return 0;
-	}
-	case VIDIOC_S_TUNER:
-	{
-		struct v4l2_tuner *t = arg;
+static int vidioc_g_ctrl (struct file *file, void *priv,
+				struct v4l2_control *ctl)
+{
+	struct cx88_core  *core = ((struct cx8800_fh *)priv)->dev->core;
+	return
+		cx88_get_control(core,ctl);
+}
@@ -1453,10 +1286,7 @@
-		if (UNSET == core->tuner_type)
-			return -EINVAL;
-		if (0 != t->index)
-			return -EINVAL;
-		cx88_set_stereo(core, t->audmode, 1);
-		return 0;
-	}
-	case VIDIOC_G_FREQUENCY:
-	{
-		struct v4l2_frequency *f = arg;
+static int vidioc_s_ctrl (struct file *file, void *priv,
+				struct v4l2_control *ctl)
+{
+	struct cx88_core  *core = ((struct cx8800_fh *)priv)->dev->core;
+	return
+		cx88_set_control(core,ctl);
+}
@@ -1464 +1294,5 @@
-		memset(f,0,sizeof(*f));
+static int vidioc_g_tuner (struct file *file, void *priv,
+				struct v4l2_tuner *t)
+{
+	struct cx88_core  *core = ((struct cx8800_fh *)priv)->dev->core;
+	u32 reg;
@@ -1466,2 +1300,4 @@
-		if (UNSET == core->tuner_type)
-			return -EINVAL;
+	if (unlikely(UNSET == core->tuner_type))
+		return -EINVAL;
+	if (0 != t->index)
+		return -EINVAL;
@@ -1469,3 +1305,10 @@
-		/* f->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV; */
-		f->type = radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;
-		f->frequency = core->freq;
+	strcpy(t->name, "Television");
+	t->type       = V4L2_TUNER_ANALOG_TV;
+	t->capability = V4L2_TUNER_CAP_NORM;
+	t->rangehigh  = 0xffffffffUL;
+
+	cx88_get_stereo(core ,t);
+	reg = cx_read(MO_DEVICE_STATUS);
+	t->signal = (reg & (1<<5)) ? 0xffff : 0x0000;
+	return 0;
+}
@@ -1473 +1316,4 @@
-		cx88_call_i2c_clients(core,VIDIOC_G_FREQUENCY,f);
+static int vidioc_s_tuner (struct file *file, void *priv,
+				struct v4l2_tuner *t)
+{
+	struct cx88_core  *core = ((struct cx8800_fh *)priv)->dev->core;
@@ -1475,5 +1321,4 @@
-		return 0;
-	}
-	case VIDIOC_S_FREQUENCY:
-	{
-		struct v4l2_frequency *f = arg;
+	if (UNSET == core->tuner_type)
+		return -EINVAL;
+	if (0 != t->index)
+		return -EINVAL;
@@ -1481,12 +1326,3 @@
-		if (UNSET == core->tuner_type)
-			return -EINVAL;
-		if (f->tuner != 0)
-			return -EINVAL;
-		if (0 == radio && f->type != V4L2_TUNER_ANALOG_TV)
-			return -EINVAL;
-		if (1 == radio && f->type != V4L2_TUNER_RADIO)
-			return -EINVAL;
-		mutex_lock(&core->lock);
-		core->freq = f->frequency;
-		cx88_newstation(core);
-		cx88_call_i2c_clients(core,VIDIOC_S_FREQUENCY,f);
+	cx88_set_stereo(core, t->audmode, 1);
+	return 0;
+}
@@ -1494,3 +1330,5 @@
-		/* When changing channels it is required to reset TVAUDIO */
-		msleep (10);
-		cx88_set_tvaudio(core);
+static int vidioc_g_frequency (struct file *file, void *priv,
+				struct v4l2_frequency *f)
+{
+	struct cx8800_fh  *fh   = priv;
+	struct cx88_core  *core = fh->dev->core;
@@ -1498,8 +1336,2 @@
-		mutex_unlock(&core->lock);
-		return 0;
-	}
-#ifdef CONFIG_VIDEO_ADV_DEBUG
-	/* ioctls to allow direct acces to the cx2388x registers */
-	case VIDIOC_INT_G_REGISTER:
-	{
-		struct v4l2_register *reg = arg;
+	if (unlikely(UNSET == core->tuner_type))
+		return -EINVAL;
@@ -1507,9 +1339,3 @@
-		if (reg->i2c_id != 0)
-			return -EINVAL;
-		/* cx2388x has a 24-bit register space */
-		reg->val = cx_read(reg->reg&0xffffff);
-		return 0;
-	}
-	case VIDIOC_INT_S_REGISTER:
-	{
-		struct v4l2_register *reg = arg;
+	/* f->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV; */
+	f->type = fh->radio ? V4L2_TUNER_RADIO : V4L2_TUNER_ANALOG_TV;
+	f->frequency = core->freq;
@@ -1517,8 +1343 @@
-		if (reg->i2c_id != 0)
-			return -EINVAL;
-		if (!capable(CAP_SYS_ADMIN))
-			return -EPERM;
-		cx_write(reg->reg&0xffffff, reg->val);
-		return 0;
-	}
-#endif
+	cx88_call_i2c_clients(core,VIDIOC_G_FREQUENCY,f);
@@ -1526,4 +1344,0 @@
-	default:
-		return v4l_compat_translate_ioctl(inode,file,cmd,arg,
-						  driver_ioctl);
-	}
@@ -1533,2 +1348,2 @@
-static int video_ioctl(struct inode *inode, struct file *file,
-		       unsigned int cmd, unsigned long arg)
+int cx88_set_freq (struct cx88_core  *core,
+				struct v4l2_frequency *f)
@@ -1536 +1351,4 @@
-       int retval;
+	if (unlikely(UNSET == core->tuner_type))
+		return -EINVAL;
+	if (unlikely(f->tuner != 0))
+		return -EINVAL;
@@ -1538 +1356,8 @@
-       retval=video_usercopy(inode, file, cmd, arg, video_do_ioctl);
+	mutex_lock(&core->lock);
+	core->freq = f->frequency;
+	cx88_newstation(core);
+	cx88_call_i2c_clients(core,VIDIOC_S_FREQUENCY,f);
+
+	/* When changing channels it is required to reset TVAUDIO */
+	msleep (10);
+	cx88_set_tvaudio(core);
@@ -1540,7 +1365 @@
-       if (video_debug > 1) {
-	       if (retval < 0) {
-		       v4l_print_ioctl("cx88(err)", cmd);
-		       printk(KERN_DEBUG "cx88(err): errcode=%d\n",retval);
-	       } else if (_IOC_DIR(cmd) & _IOC_READ)
-		       v4l_printk_ioctl_arg("cx88(r)",cmd, (void *)arg);
-       }
+	mutex_unlock(&core->lock);
@@ -1548 +1367 @@
-       return retval;
+	return 0;
@@ -1549,0 +1369 @@
+EXPORT_SYMBOL(cx88_set_freq);
@@ -1551 +1371,5 @@
-/* ----------------------------------------------------------- */
+static int vidioc_s_frequency (struct file *file, void *priv,
+				struct v4l2_frequency *f)
+{
+	struct cx8800_fh  *fh   = priv;
+	struct cx88_core  *core = fh->dev->core;
@@ -1553,2 +1377,12 @@
-static int radio_do_ioctl(struct inode *inode, struct file *file,
-			unsigned int cmd, void *arg)
+	if (unlikely(0 == fh->radio && f->type != V4L2_TUNER_ANALOG_TV))
+		return -EINVAL;
+	if (unlikely(1 == fh->radio && f->type != V4L2_TUNER_RADIO))
+		return -EINVAL;
+
+	return
+		cx88_set_freq (core,f);
+}
+
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+static int vidioc_g_register (struct file *file, void *fh,
+				struct v4l2_register *reg)
@@ -1556,3 +1390 @@
-	struct cx8800_fh *fh    = file->private_data;
-	struct cx8800_dev *dev  = fh->dev;
-	struct cx88_core  *core = dev->core;
+	struct cx88_core *core = ((struct cx8800_fh*)fh)->dev->core;
@@ -1560,2 +1392,6 @@
-	if (video_debug > 1)
-		v4l_print_ioctl(core->name,cmd);
+	if (!v4l2_chip_match_host(reg->match_type, reg->match_chip))
+		return -EINVAL;
+	/* cx2388x has a 24-bit register space */
+	reg->val = cx_read(reg->reg&0xffffff);
+	return 0;
+}
@@ -1563,4 +1399,4 @@
-	switch (cmd) {
-	case VIDIOC_QUERYCAP:
-	{
-		struct v4l2_capability *cap = arg;
+static int vidioc_s_register (struct file *file, void *fh,
+				struct v4l2_register *reg)
+{
+	struct cx88_core *core = ((struct cx8800_fh*)fh)->dev->core;
@@ -1568,12 +1404,6 @@
-		memset(cap,0,sizeof(*cap));
-		strcpy(cap->driver, "cx8800");
-		strlcpy(cap->card, cx88_boards[core->board].name,
-			sizeof(cap->card));
-		sprintf(cap->bus_info,"PCI:%s", pci_name(dev->pci));
-		cap->version = CX88_VERSION_CODE;
-		cap->capabilities = V4L2_CAP_TUNER;
-		return 0;
-	}
-	case VIDIOC_G_TUNER:
-	{
-		struct v4l2_tuner *t = arg;
+	if (!v4l2_chip_match_host(reg->match_type, reg->match_chip))
+		return -EINVAL;
+	cx_write(reg->reg&0xffffff, reg->val);
+	return 0;
+}
+#endif
@@ -1581,2 +1411,3 @@
-		if (t->index > 0)
-			return -EINVAL;
+/* ----------------------------------------------------------- */
+/* RADIO ESPECIFIC IOCTLS                                      */
+/* ----------------------------------------------------------- */
@@ -1584,3 +1415,5 @@
-		memset(t,0,sizeof(*t));
-		strcpy(t->name, "Radio");
-		t->type = V4L2_TUNER_RADIO;
+static int radio_querycap (struct file *file, void  *priv,
+					struct v4l2_capability *cap)
+{
+	struct cx8800_dev *dev  = ((struct cx8800_fh *)priv)->dev;
+	struct cx88_core  *core = dev->core;
@@ -1588,6 +1421,8 @@
-		cx88_call_i2c_clients(core,VIDIOC_G_TUNER,t);
-		return 0;
-	}
-	case VIDIOC_ENUMINPUT:
-	{
-		struct v4l2_input *i = arg;
+	strcpy(cap->driver, "cx8800");
+	strlcpy(cap->card, cx88_boards[core->board].name,
+		sizeof(cap->card));
+	sprintf(cap->bus_info,"PCI:%s", pci_name(dev->pci));
+	cap->version = CX88_VERSION_CODE;
+	cap->capabilities = V4L2_CAP_TUNER;
+	return 0;
+}
@@ -1595,15 +1430,4 @@
-		if (i->index != 0)
-			return -EINVAL;
-		strcpy(i->name,"Radio");
-		i->type = V4L2_INPUT_TYPE_TUNER;
-		return 0;
-	}
-	case VIDIOC_G_INPUT:
-	{
-		int *i = arg;
-		*i = 0;
-		return 0;
-	}
-	case VIDIOC_G_AUDIO:
-	{
-		struct v4l2_audio *a = arg;
+static int radio_g_tuner (struct file *file, void *priv,
+				struct v4l2_tuner *t)
+{
+	struct cx88_core  *core = ((struct cx8800_fh *)priv)->dev->core;
@@ -1611,14 +1435,2 @@
-		memset(a,0,sizeof(*a));
-		strcpy(a->name,"Radio");
-		return 0;
-	}
-	case VIDIOC_G_STD:
-	{
-		v4l2_std_id *id = arg;
-		*id = 0;
-		return 0;
-	}
-#ifdef CONFIG_VIDEO_V4L1_COMPAT
-	case VIDIOCSTUNER:
-	{
-		struct video_tuner *v = arg;
+	if (unlikely(t->index > 0))
+		return -EINVAL;
@@ -1626,2 +1438,2 @@
-		if (v->tuner) /* Only tuner 0 */
-			return -EINVAL;
+	strcpy(t->name, "Radio");
+	t->type = V4L2_TUNER_RADIO;
@@ -1629,7 +1441,11 @@
-		cx88_call_i2c_clients(core,VIDIOCSTUNER,v);
-		return 0;
-	}
-#endif
-	case VIDIOC_S_TUNER:
-	{
-		struct v4l2_tuner *t = arg;
+	cx88_call_i2c_clients(core,VIDIOC_G_TUNER,t);
+	return 0;
+}
+
+static int radio_enum_input (struct file *file, void *priv,
+				struct v4l2_input *i)
+{
+	if (i->index != 0)
+		return -EINVAL;
+	strcpy(i->name,"Radio");
+	i->type = V4L2_INPUT_TYPE_TUNER;
@@ -1637,2 +1453,2 @@
-		if (0 != t->index)
-			return -EINVAL;
+	return 0;
+}
@@ -1640 +1456,4 @@
-		cx88_call_i2c_clients(core,VIDIOC_S_TUNER,t);
+static int radio_g_audio (struct file *file, void *priv, struct v4l2_audio *a)
+{
+	if (unlikely(a->index))
+		return -EINVAL;
@@ -1642,2 +1461,4 @@
-		return 0;
-	}
+	memset(a,0,sizeof(*a));
+	strcpy(a->name,"Radio");
+	return 0;
+}
@@ -1645,4 +1466 @@
-	case VIDIOC_S_AUDIO:
-	case VIDIOC_S_INPUT:
-	case VIDIOC_S_STD:
-		return 0;
+/* FIXME: Should add a standard for radio */
@@ -1650,4 +1468,4 @@
-	case VIDIOC_QUERYCTRL:
-	{
-		struct v4l2_queryctrl *c = arg;
-		int i;
+static int radio_s_tuner (struct file *file, void *priv,
+				struct v4l2_tuner *t)
+{
+	struct cx88_core  *core = ((struct cx8800_fh *)priv)->dev->core;
@@ -1655,12 +1473,2 @@
-		if (c->id <  V4L2_CID_BASE ||
-		    c->id >= V4L2_CID_LASTP1)
-			return -EINVAL;
-		if (c->id == V4L2_CID_AUDIO_MUTE) {
-			for (i = 0; i < CX8800_CTLS; i++)
-				if (cx8800_ctls[i].v.id == c->id)
-					break;
-			*c = cx8800_ctls[i].v;
-		} else
-			*c = no_ctl;
-		return 0;
-	}
+	if (0 != t->index)
+		return -EINVAL;
@@ -1667,0 +1476 @@
+	cx88_call_i2c_clients(core,VIDIOC_S_TUNER,t);
@@ -1669,5 +1478,2 @@
-	case VIDIOC_G_CTRL:
-	case VIDIOC_S_CTRL:
-	case VIDIOC_G_FREQUENCY:
-	case VIDIOC_S_FREQUENCY:
-		return video_do_ioctl(inode,file,cmd,arg);
+	return 0;
+}
@@ -1675,4 +1481,3 @@
-	default:
-		return v4l_compat_translate_ioctl(inode,file,cmd,arg,
-						  radio_do_ioctl);
-	}
+static int radio_s_audio (struct file *file, void *fh,
+			  struct v4l2_audio *a)
+{
@@ -1680 +1485 @@
-};
+}
@@ -1682,2 +1487 @@
-static int radio_ioctl(struct inode *inode, struct file *file,
-			unsigned int cmd, unsigned long arg)
+static int radio_s_input (struct file *file, void *fh, unsigned int i)
@@ -1685,2 +1489,20 @@
-	return video_usercopy(inode, file, cmd, arg, radio_do_ioctl);
-};
+	return 0;
+}
+
+static int radio_queryctrl (struct file *file, void *priv,
+			    struct v4l2_queryctrl *c)
+{
+	int i;
+
+	if (c->id <  V4L2_CID_BASE ||
+		c->id >= V4L2_CID_LASTP1)
+		return -EINVAL;
+	if (c->id == V4L2_CID_AUDIO_MUTE) {
+		for (i = 0; i < CX8800_CTLS; i++)
+			if (cx8800_ctls[i].v.id == c->id)
+				break;
+		*c = cx8800_ctls[i].v;
+	} else
+		*c = no_ctl;
+	return 0;
+}
@@ -1811 +1633 @@
-static struct file_operations video_fops =
+static const struct file_operations video_fops =
@@ -1819 +1641 @@
-	.ioctl	       = video_ioctl,
+	.ioctl	       = video_ioctl2,
@@ -1823,0 +1646 @@
+static struct video_device cx8800_vbi_template;
@@ -1826,14 +1649,38 @@
-	.name          = "cx8800-video",
-	.type          = VID_TYPE_CAPTURE|VID_TYPE_TUNER|VID_TYPE_SCALES,
-	.hardware      = 0,
-	.fops          = &video_fops,
-	.minor         = -1,
-};
-
-static struct video_device cx8800_vbi_template =
-{
-	.name          = "cx8800-vbi",
-	.type          = VID_TYPE_TELETEXT|VID_TYPE_TUNER,
-	.hardware      = 0,
-	.fops          = &video_fops,
-	.minor         = -1,
+	.name                 = "cx8800-video",
+	.type                 = VID_TYPE_CAPTURE|VID_TYPE_TUNER|VID_TYPE_SCALES,
+	.fops                 = &video_fops,
+	.minor                = -1,
+	.vidioc_querycap      = vidioc_querycap,
+	.vidioc_enum_fmt_cap  = vidioc_enum_fmt_cap,
+	.vidioc_g_fmt_cap     = vidioc_g_fmt_cap,
+	.vidioc_try_fmt_cap   = vidioc_try_fmt_cap,
+	.vidioc_s_fmt_cap     = vidioc_s_fmt_cap,
+	.vidioc_g_fmt_vbi     = cx8800_vbi_fmt,
+	.vidioc_try_fmt_vbi   = cx8800_vbi_fmt,
+	.vidioc_s_fmt_vbi     = cx8800_vbi_fmt,
+	.vidioc_reqbufs       = vidioc_reqbufs,
+	.vidioc_querybuf      = vidioc_querybuf,
+	.vidioc_qbuf          = vidioc_qbuf,
+	.vidioc_dqbuf         = vidioc_dqbuf,
+	.vidioc_s_std         = vidioc_s_std,
+	.vidioc_enum_input    = vidioc_enum_input,
+	.vidioc_g_input       = vidioc_g_input,
+	.vidioc_s_input       = vidioc_s_input,
+	.vidioc_queryctrl     = vidioc_queryctrl,
+	.vidioc_g_ctrl        = vidioc_g_ctrl,
+	.vidioc_s_ctrl        = vidioc_s_ctrl,
+	.vidioc_streamon      = vidioc_streamon,
+	.vidioc_streamoff     = vidioc_streamoff,
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+	.vidiocgmbuf          = vidiocgmbuf,
+#endif
+	.vidioc_g_tuner       = vidioc_g_tuner,
+	.vidioc_s_tuner       = vidioc_s_tuner,
+	.vidioc_g_frequency   = vidioc_g_frequency,
+	.vidioc_s_frequency   = vidioc_s_frequency,
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.vidioc_g_register    = vidioc_g_register,
+	.vidioc_s_register    = vidioc_s_register,
+#endif
+	.tvnorms              = CX88_NORMS,
+	.current_norm         = V4L2_STD_NTSC_M,
@@ -1842 +1689 @@
-static struct file_operations radio_fops =
+static const struct file_operations radio_fops =
@@ -1847 +1694 @@
-	.ioctl         = radio_ioctl,
+	.ioctl         = video_ioctl2,
@@ -1854,5 +1701,17 @@
-	.name          = "cx8800-radio",
-	.type          = VID_TYPE_TUNER,
-	.hardware      = 0,
-	.fops          = &radio_fops,
-	.minor         = -1,
+	.name                 = "cx8800-radio",
+	.type                 = VID_TYPE_TUNER,
+	.hardware             = 0,
+	.fops                 = &radio_fops,
+	.minor                = -1,
+	.vidioc_querycap      = radio_querycap,
+	.vidioc_g_tuner       = radio_g_tuner,
+	.vidioc_enum_input    = radio_enum_input,
+	.vidioc_g_audio       = radio_g_audio,
+	.vidioc_s_tuner       = radio_s_tuner,
+	.vidioc_s_audio       = radio_s_audio,
+	.vidioc_s_input       = radio_s_input,
+	.vidioc_queryctrl     = radio_queryctrl,
+	.vidioc_g_ctrl        = vidioc_g_ctrl,
+	.vidioc_s_ctrl        = vidioc_s_ctrl,
+	.vidioc_g_frequency   = vidioc_g_frequency,
+	.vidioc_s_frequency   = vidioc_s_frequency,
@@ -1892,0 +1752 @@
+
@@ -1926,0 +1787,6 @@
+	/* Initialize VBI template */
+	memcpy( &cx8800_vbi_template, &cx8800_video_template,
+		sizeof(cx8800_vbi_template) );
+	strcpy(cx8800_vbi_template.name,"cx8800-vbi");
+	cx8800_vbi_template.type = VID_TYPE_TELETEXT|VID_TYPE_TUNER;
+
@@ -1929 +1795 @@
-	core->tvnorm = tvnorms;
+	core->tvnorm = cx8800_video_template.current_norm;
@@ -2010 +1876 @@
-	cx88_set_tvnorm(core,tvnorms);
+	cx88_set_tvnorm(core,core->tvnorm);
@@ -2012 +1878 @@
-	video_mux(core,0);
+	cx88_video_mux(core,0);
@@ -2181,2 +2046,0 @@
-EXPORT_SYMBOL(cx88_do_ioctl);
-
--- ./projects/linux/linux-2.6.21/drivers/media/video/cx88/cx88-video.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/media/video/cx88/cx88-video.c	2007-07-09 01:32:17.000000000 +0200
@@ -1 +0,0 @@
-
@@ -36,0 +36 @@
+#include <linux/dma-mapping.h>
@@ -38,0 +39 @@
+#include <linux/dma-mapping.h>
@@ -1558 +1559,2 @@
-				   cx88_vid_irqs, status, mask);
+				   cx88_vid_irqs, ARRAY_SIZE(cx88_vid_irqs),
+				   status, mask);
@@ -1781 +1783 @@
-	if (!pci_dma_supported(pci_dev,0xffffffff)) {
+	if (!pci_dma_supported(pci_dev,DMA_32BIT_MASK)) {
--- ./projects/linux/linux-2.6.22/drivers/media/video/cx88/cx88-video.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/media/video/cx88/cx88-video.c	2007-10-09 22:31:38.000000000 +0200
@@ -1884 +1884 @@
-	if (core->tuner_type != TUNER_ABSENT)
+	if (core->tuner_type != TUNER_ABSENT) {
@@ -1885,0 +1886,6 @@
+		if (IS_ERR(core->kthread)) {
+			err = PTR_ERR(core->kthread);
+			printk(KERN_ERR "Failed to create cx88 audio thread, err=%d\n",
+			       err);
+		}
+	}
--- ./projects/linux/linux-2.6.23/drivers/media/video/cx88/cx88-video.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/media/video/cx88/cx88-video.c	2008-01-24 23:58:37.000000000 +0100
@@ -31 +30,0 @@
-#include <linux/moduleparam.h>
@@ -39 +37,0 @@
-#include <linux/dma-mapping.h>
@@ -372,3 +370,3 @@
-		input, INPUT(input)->vmux,
-		INPUT(input)->gpio0,INPUT(input)->gpio1,
-		INPUT(input)->gpio2,INPUT(input)->gpio3);
+		input, INPUT(input).vmux,
+		INPUT(input).gpio0,INPUT(input).gpio1,
+		INPUT(input).gpio2,INPUT(input).gpio3);
@@ -376,5 +374,5 @@
-	cx_andor(MO_INPUT_FORMAT, 0x03 << 14, INPUT(input)->vmux << 14);
-	cx_write(MO_GP3_IO, INPUT(input)->gpio3);
-	cx_write(MO_GP0_IO, INPUT(input)->gpio0);
-	cx_write(MO_GP1_IO, INPUT(input)->gpio1);
-	cx_write(MO_GP2_IO, INPUT(input)->gpio2);
+	cx_andor(MO_INPUT_FORMAT, 0x03 << 14, INPUT(input).vmux << 14);
+	cx_write(MO_GP3_IO, INPUT(input).gpio3);
+	cx_write(MO_GP0_IO, INPUT(input).gpio0);
+	cx_write(MO_GP1_IO, INPUT(input).gpio1);
+	cx_write(MO_GP2_IO, INPUT(input).gpio2);
@@ -382 +380 @@
-	switch (INPUT(input)->type) {
+	switch (INPUT(input).type) {
@@ -397 +395 @@
-	if (cx88_boards[core->board].mpeg & CX88_MPEG_BLACKBIRD) {
+	if (core->board.mpeg & CX88_MPEG_BLACKBIRD) {
@@ -399 +397 @@
-		if (INPUT(input)->extadc)
+		if (INPUT(input).extadc)
@@ -427 +425 @@
-	cx_set(MO_PCI_INTMSK, core->pci_irqmask | 0x01);
+	cx_set(MO_PCI_INTMSK, core->pci_irqmask | PCI_INT_VIDINT);
@@ -460 +458 @@
-	cx_clear(MO_PCI_INTMSK, 0x000001);
+	cx_clear(MO_PCI_INTMSK, PCI_INT_VIDINT);
@@ -471 +468,0 @@
-	struct list_head *item;
@@ -478,4 +475,2 @@
-		list_for_each(item,&q->active) {
-			buf = list_entry(item, struct cx88_buffer, vb.queue);
-			buf->count    = q->count++;
-		}
+		list_for_each_entry(buf, &q->active, vb.queue)
+			buf->count = q->count++;
@@ -538,0 +534 @@
+	struct videobuf_dmabuf *dma=videobuf_to_dma(&buf->vb);
@@ -571 +567 @@
-					 buf->vb.dma.sglist, 0, UNSET,
+					 dma->sglist, 0, UNSET,
@@ -576 +572 @@
-					 buf->vb.dma.sglist, UNSET, 0,
+					 dma->sglist, UNSET, 0,
@@ -581 +577 @@
-					 buf->vb.dma.sglist, 0, buf->bpl,
+					 dma->sglist, 0, buf->bpl,
@@ -587 +583 @@
-					 buf->vb.dma.sglist,
+					 dma->sglist,
@@ -594 +590 @@
-					 buf->vb.dma.sglist,
+					 dma->sglist,
@@ -717 +712,0 @@
-	struct list_head *list;
@@ -721,2 +716 @@
-	list_for_each(list,&cx8800_devlist) {
-		h = list_entry(list, struct cx8800_dev, devlist);
+	list_for_each_entry(h, &cx8800_devlist, devlist) {
@@ -757 +751 @@
-	videobuf_queue_init(&fh->vidq, &cx8800_video_qops,
+	videobuf_queue_pci_init(&fh->vidq, &cx8800_video_qops,
@@ -763 +757 @@
-	videobuf_queue_init(&fh->vbiq, &cx8800_vbi_qops,
+	videobuf_queue_pci_init(&fh->vbiq, &cx8800_vbi_qops,
@@ -771 +764,0 @@
-		int board = core->board;
@@ -773,4 +766,4 @@
-		cx_write(MO_GP3_IO, cx88_boards[board].radio.gpio3);
-		cx_write(MO_GP0_IO, cx88_boards[board].radio.gpio0);
-		cx_write(MO_GP1_IO, cx88_boards[board].radio.gpio1);
-		cx_write(MO_GP2_IO, cx88_boards[board].radio.gpio2);
+		cx_write(MO_GP3_IO, core->board.radio.gpio3);
+		cx_write(MO_GP0_IO, core->board.radio.gpio0);
+		cx_write(MO_GP1_IO, core->board.radio.gpio1);
+		cx_write(MO_GP2_IO, core->board.radio.gpio2);
@@ -861,4 +854 @@
-		if (fh->vbiq.streaming)
-			videobuf_streamoff(&fh->vbiq);
-		if (fh->vbiq.reading)
-			videobuf_read_stop(&fh->vbiq);
+		videobuf_stop(&fh->vbiq);
@@ -1082,2 +1072 @@
-	strlcpy(cap->card, cx88_boards[core->board].name,
-		sizeof(cap->card));
+	strlcpy(cap->card, core->board.name, sizeof(cap->card));
@@ -1091 +1080 @@
-	if (UNSET != core->tuner_type)
+	if (UNSET != core->board.tuner_type)
@@ -1111,5 +1100 @@
-	struct cx8800_fh           *fh   = priv;
-	struct videobuf_queue      *q;
-	struct v4l2_requestbuffers req;
-	unsigned int i;
-	int err;
+	struct cx8800_fh           *fh  = priv;
@@ -1117,16 +1102 @@
-	q = get_queue(fh);
-	memset(&req,0,sizeof(req));
-	req.type   = q->type;
-	req.count  = 8;
-	req.memory = V4L2_MEMORY_MMAP;
-	err = videobuf_reqbufs(q,&req);
-	if (err < 0)
-		return err;
-
-	mbuf->frames = req.count;
-	mbuf->size   = 0;
-	for (i = 0; i < mbuf->frames; i++) {
-		mbuf->offsets[i]  = q->bufs[i]->boff;
-		mbuf->size       += q->bufs[i]->bsize;
-	}
-	return 0;
+	return videobuf_cgmbuf (get_queue(fh), mbuf, 8);
@@ -1225 +1195 @@
-	if (0 == INPUT(n)->type)
+	if (0 == INPUT(n).type)
@@ -1230,3 +1200,3 @@
-	strcpy(i->name,iname[INPUT(n)->type]);
-	if ((CX88_VMUX_TELEVISION == INPUT(n)->type) ||
-		(CX88_VMUX_CABLE      == INPUT(n)->type))
+	strcpy(i->name,iname[INPUT(n).type]);
+	if ((CX88_VMUX_TELEVISION == INPUT(n).type) ||
+	    (CX88_VMUX_CABLE      == INPUT(n).type))
@@ -1301 +1271 @@
-	if (unlikely(UNSET == core->tuner_type))
+	if (unlikely(UNSET == core->board.tuner_type))
@@ -1322 +1292 @@
-	if (UNSET == core->tuner_type)
+	if (UNSET == core->board.tuner_type)
@@ -1337 +1307 @@
-	if (unlikely(UNSET == core->tuner_type))
+	if (unlikely(UNSET == core->board.tuner_type))
@@ -1352 +1322 @@
-	if (unlikely(UNSET == core->tuner_type))
+	if (unlikely(UNSET == core->board.tuner_type))
@@ -1423,2 +1393 @@
-	strlcpy(cap->card, cx88_boards[core->board].name,
-		sizeof(cap->card));
+	strlcpy(cap->card, core->board.name, sizeof(cap->card));
@@ -1611 +1580,2 @@
-		status = cx_read(MO_PCI_INTSTAT) & (core->pci_irqmask | 0x01);
+		status = cx_read(MO_PCI_INTSTAT) &
+			(core->pci_irqmask | PCI_INT_VIDINT);
@@ -1619 +1589 @@
-		if (status & 0x01)
+		if (status & PCI_INT_VIDINT)
@@ -1705 +1674,0 @@
-	.hardware             = 0,
@@ -1719,0 +1689,4 @@
+#ifdef CONFIG_VIDEO_ADV_DEBUG
+	.vidioc_g_register    = vidioc_g_register,
+	.vidioc_s_register    = vidioc_s_register,
+#endif
@@ -1821 +1794 @@
-		printk(KERN_ERR "%s: can't get IRQ %d\n",
+		printk(KERN_ERR "%s/0: can't get IRQ %d\n",
@@ -1828 +1801 @@
-	if (TUNER_ABSENT != core->tuner_type)
+	if (TUNER_ABSENT != core->board.tuner_type)
@@ -1831 +1804 @@
-	if (cx88_boards[ core->board ].audio_chip == AUDIO_CHIP_WM8775)
+	if (core->board.audio_chip == AUDIO_CHIP_WM8775)
@@ -1833,0 +1807,6 @@
+	switch (core->boardnr) {
+	case CX88_BOARD_DVICO_FUSIONHDTV_5_GOLD:
+		request_module("ir-kbd-i2c");
+		request_module("rtc-isl1208");
+	}
+
@@ -1840 +1819 @@
-		printk(KERN_INFO "%s: can't register video device\n",
+		printk(KERN_ERR "%s/0: can't register video device\n",
@@ -1851 +1830 @@
-		printk(KERN_INFO "%s/0: can't register vbi device\n",
+		printk(KERN_ERR "%s/0: can't register vbi device\n",
@@ -1858 +1837 @@
-	if (core->has_radio) {
+	if (core->board.radio.type == CX88_RADIO) {
@@ -1864 +1843 @@
-			printk(KERN_INFO "%s/0: can't register radio device\n",
+			printk(KERN_ERR "%s/0: can't register radio device\n",
@@ -1884 +1863 @@
-	if (core->tuner_type != TUNER_ABSENT) {
+	if (core->board.tuner_type != TUNER_ABSENT) {
@@ -1888,2 +1867,2 @@
-			printk(KERN_ERR "Failed to create cx88 audio thread, err=%d\n",
-			       err);
+			printk(KERN_ERR "%s/0: failed to create cx88 audio thread, err=%d\n",
+			       core->name, err);
@@ -1940 +1919 @@
-		printk("%s: suspend video\n", core->name);
+		printk("%s/0: suspend video\n", core->name);
@@ -1945 +1924 @@
-		printk("%s: suspend vbi\n", core->name);
+		printk("%s/0: suspend vbi\n", core->name);
@@ -1950,0 +1930,2 @@
+	if (core->ir)
+		cx88_ir_stop(core, core->ir);
@@ -1971,2 +1952,2 @@
-			printk(KERN_ERR "%s: can't enable device\n",
-						       core->name);
+			printk(KERN_ERR "%s/0: can't enable device\n",
+			       core->name);
@@ -1980,3 +1961 @@
-		printk(KERN_ERR "%s: can't enable device\n",
-				       core->name);
-
+		printk(KERN_ERR "%s/0: can't set power state\n", core->name);
@@ -1991,0 +1971,4 @@
+	if (core->ir)
+		cx88_ir_start(core, core->ir);
+
+	cx_set(MO_PCI_INTMSK, core->pci_irqmask);
@@ -1996 +1979 @@
-		printk("%s: resume video\n", core->name);
+		printk("%s/0: resume video\n", core->name);
@@ -2000 +1983 @@
-		printk("%s: resume vbi\n", core->name);
+		printk("%s/0: resume vbi\n", core->name);
@@ -2036 +2019 @@
-	printk(KERN_INFO "cx2388x v4l2 driver version %d.%d.%d loaded\n",
+	printk(KERN_INFO "cx88/0: cx2388x v4l2 driver version %d.%d.%d loaded\n",
--- ./projects/linux/linux-2.6.24/drivers/media/video/cx88/cx88-video.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/media/video/cx88/cx88-video.c	2008-04-17 04:49:44.000000000 +0200
@@ -395,3 +395,13 @@
-	if (core->board.mpeg & CX88_MPEG_BLACKBIRD) {
-		/* sets sound input from external adc */
-		if (INPUT(input).extadc)
+	/* if there are audioroutes defined, we have an external
+	   ADC to deal with audio */
+
+	if (INPUT(input).audioroute) {
+
+		/* cx2388's C-ADC is connected to the tuner only.
+		   When used with S-Video, that ADC is busy dealing with
+		   chroma, so an external must be used for baseband audio */
+
+		if (INPUT(input).type != CX88_VMUX_TELEVISION &&
+			INPUT(input).type != CX88_RADIO) {
+			/* "ADC mode" */
+			cx_write(AUD_I2SCNTL, 0x1);
@@ -399 +409,3 @@
-		else
+		} else {
+			/* Normal mode */
+			cx_write(AUD_I2SCNTL, 0x0);
@@ -400,0 +413,15 @@
+		}
+
+		/* The wm8775 module has the "2" route hardwired into
+		   the initialization. Some boards may use different
+		   routes for different inputs. HVR-1300 surely does */
+		if (core->board.audio_chip &&
+		    core->board.audio_chip == AUDIO_CHIP_WM8775) {
+			struct v4l2_routing route;
+
+			route.input = INPUT(input).audioroute;
+			cx88_call_i2c_clients(core,
+				VIDIOC_INT_S_AUDIO_ROUTING, &route);
+
+		}
+
@@ -401,0 +429 @@
+
@@ -489 +517 @@
-			buf->vb.state = STATE_ACTIVE;
+			buf->vb.state = VIDEOBUF_ACTIVE;
@@ -499 +527 @@
-			buf->vb.state = STATE_ACTIVE;
+			buf->vb.state = VIDEOBUF_ACTIVE;
@@ -556 +584 @@
-	if (STATE_NEEDS_INIT == buf->vb.state) {
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
@@ -604 +632 @@
-	buf->vb.state = STATE_PREPARED;
+	buf->vb.state = VIDEOBUF_PREPARED;
@@ -628 +656 @@
-		buf->vb.state = STATE_QUEUED;
+		buf->vb.state = VIDEOBUF_QUEUED;
@@ -635 +663 @@
-		buf->vb.state = STATE_ACTIVE;
+		buf->vb.state = VIDEOBUF_ACTIVE;
@@ -647 +675 @@
-			buf->vb.state = STATE_ACTIVE;
+			buf->vb.state = VIDEOBUF_ACTIVE;
@@ -655 +683 @@
-			buf->vb.state = STATE_QUEUED;
+			buf->vb.state = VIDEOBUF_QUEUED;
@@ -825,2 +853,2 @@
-	if (buf->vb.state == STATE_DONE ||
-	    buf->vb.state == STATE_ERROR)
+	if (buf->vb.state == VIDEOBUF_DONE ||
+	    buf->vb.state == VIDEOBUF_ERROR)
@@ -1499 +1527 @@
-		buf->vb.state = STATE_ERROR;
+		buf->vb.state = VIDEOBUF_ERROR;
@@ -1801,2 +1828,0 @@
-	if (TUNER_ABSENT != core->board.tuner_type)
-		request_module("tuner");
--- ./projects/linux/linux-2.6.25/drivers/media/video/cx88/cx88-video.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/media/video/cx88/cx88-video.c	2008-07-13 23:51:29.000000000 +0200
@@ -66 +66 @@
-static unsigned int video_debug = 0;
+static unsigned int video_debug;
@@ -70 +70 @@
-static unsigned int irq_debug = 0;
+static unsigned int irq_debug;
@@ -230,0 +231,24 @@
+		.v = {
+			.id            = V4L2_CID_CHROMA_AGC,
+			.name          = "Chroma AGC",
+			.minimum       = 0,
+			.maximum       = 1,
+			.default_value = 0x1,
+			.type          = V4L2_CTRL_TYPE_BOOLEAN,
+		},
+		.reg                   = MO_INPUT_FORMAT,
+		.mask                  = 1 << 10,
+		.shift                 = 10,
+	}, {
+		.v = {
+			.id            = V4L2_CID_COLOR_KILLER,
+			.name          = "Color killer",
+			.minimum       = 0,
+			.maximum       = 1,
+			.default_value = 0x1,
+			.type          = V4L2_CTRL_TYPE_BOOLEAN,
+		},
+		.reg                   = MO_INPUT_FORMAT,
+		.mask                  = 1 << 9,
+		.shift                 = 9,
+	}, {
@@ -284,0 +309,2 @@
+	V4L2_CID_CHROMA_AGC,
+	V4L2_CID_COLOR_KILLER,
@@ -294 +320 @@
-int cx8800_ctrl_query(struct v4l2_queryctrl *qctrl)
+int cx8800_ctrl_query(struct cx88_core *core, struct v4l2_queryctrl *qctrl)
@@ -308,0 +335,5 @@
+	/* Report chroma AGC as inactive when SECAM is selected */
+	if (cx8800_ctls[i].v.id == V4L2_CID_CHROMA_AGC &&
+	    core->tvnorm & V4L2_STD_SECAM)
+		qctrl->flags |= V4L2_CTRL_FLAG_INACTIVE;
+
@@ -779,2 +810,2 @@
-	videobuf_queue_pci_init(&fh->vidq, &cx8800_video_qops,
-			    dev->pci, &dev->slock,
+	videobuf_queue_sg_init(&fh->vidq, &cx8800_video_qops,
+			    &dev->pci->dev, &dev->slock,
@@ -785,2 +816,2 @@
-	videobuf_queue_pci_init(&fh->vbiq, &cx8800_vbi_qops,
-			    dev->pci, &dev->slock,
+	videobuf_queue_sg_init(&fh->vbiq, &cx8800_vbi_qops,
+			    &dev->pci->dev, &dev->slock,
@@ -978,0 +1010,6 @@
+	case V4L2_CID_CHROMA_AGC:
+		/* Do not allow chroma AGC to be enabled for SECAM */
+		value = ((ctl->value - c->off) << c->shift) & c->mask;
+		if (core->tvnorm & V4L2_STD_SECAM && value)
+			return -EINVAL;
+		break;
@@ -1270,0 +1308,2 @@
+	struct cx88_core *core = ((struct cx8800_fh *)priv)->dev->core;
+
@@ -1274 +1313 @@
-	return cx8800_ctrl_query(qctrl);
+	return cx8800_ctrl_query(core, qctrl);
@@ -1835 +1874 @@
-		request_module("ir-kbd-i2c");
+	case CX88_BOARD_DVICO_FUSIONHDTV_7_GOLD:
@@ -1836,0 +1876,3 @@
+		/* break intentionally omitted */
+	case CX88_BOARD_DVICO_FUSIONHDTV_5_PCI_NANO:
+		request_module("ir-kbd-i2c");
@@ -1919,0 +1962,3 @@
+	if (core->ir)
+		cx88_ir_stop(core, core->ir);
+
--- ./projects/linux/linux-2.6.26/drivers/media/video/cx88/cx88-video.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/media/video/cx88/cx88-video.c	2008-10-10 00:13:53.000000000 +0200
@@ -41,0 +42 @@
+#include <media/v4l2-ioctl.h>
@@ -450 +451 @@
-		    core->board.audio_chip == AUDIO_CHIP_WM8775) {
+		    core->board.audio_chip == V4L2_IDENT_WM8775) {
@@ -1048 +1049 @@
-static int vidioc_g_fmt_cap (struct file *file, void *priv,
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
@@ -1064 +1065 @@
-static int vidioc_try_fmt_cap (struct file *file, void *priv,
+static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
@@ -1115 +1116 @@
-static int vidioc_s_fmt_cap (struct file *file, void *priv,
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
@@ -1119 +1120 @@
-	int err = vidioc_try_fmt_cap (file,priv,f);
+	int err = vidioc_try_fmt_vid_cap (file,priv,f);
@@ -1150 +1151 @@
-static int vidioc_enum_fmt_cap (struct file *file, void  *priv,
+static int vidioc_enum_fmt_vid_cap (struct file *file, void  *priv,
@@ -1685,7 +1686 @@
-static struct video_device cx8800_vbi_template;
-static struct video_device cx8800_video_template =
-{
-	.name                 = "cx8800-video",
-	.type                 = VID_TYPE_CAPTURE|VID_TYPE_TUNER|VID_TYPE_SCALES,
-	.fops                 = &video_fops,
-	.minor                = -1,
+static const struct v4l2_ioctl_ops video_ioctl_ops = {
@@ -1693,7 +1688,7 @@
-	.vidioc_enum_fmt_cap  = vidioc_enum_fmt_cap,
-	.vidioc_g_fmt_cap     = vidioc_g_fmt_cap,
-	.vidioc_try_fmt_cap   = vidioc_try_fmt_cap,
-	.vidioc_s_fmt_cap     = vidioc_s_fmt_cap,
-	.vidioc_g_fmt_vbi     = cx8800_vbi_fmt,
-	.vidioc_try_fmt_vbi   = cx8800_vbi_fmt,
-	.vidioc_s_fmt_vbi     = cx8800_vbi_fmt,
+	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
+	.vidioc_g_fmt_vbi_cap     = cx8800_vbi_fmt,
+	.vidioc_try_fmt_vbi_cap   = cx8800_vbi_fmt,
+	.vidioc_s_fmt_vbi_cap     = cx8800_vbi_fmt,
@@ -1723,0 +1719,9 @@
+};
+
+static struct video_device cx8800_vbi_template;
+
+static struct video_device cx8800_video_template = {
+	.name                 = "cx8800-video",
+	.fops                 = &video_fops,
+	.minor                = -1,
+	.ioctl_ops 	      = &video_ioctl_ops,
@@ -1738,6 +1742 @@
-static struct video_device cx8800_radio_template =
-{
-	.name                 = "cx8800-radio",
-	.type                 = VID_TYPE_TUNER,
-	.fops                 = &radio_fops,
-	.minor                = -1,
+static const struct v4l2_ioctl_ops radio_ioctl_ops = {
@@ -1761,0 +1761,7 @@
+static struct video_device cx8800_radio_template = {
+	.name                 = "cx8800-radio",
+	.fops                 = &radio_fops,
+	.minor                = -1,
+	.ioctl_ops 	      = &radio_ioctl_ops,
+};
+
@@ -1833 +1838,0 @@
-	cx8800_vbi_template.type = VID_TYPE_TELETEXT|VID_TYPE_TUNER;
@@ -1869 +1874 @@
-	if (core->board.audio_chip == AUDIO_CHIP_WM8775)
+	if (core->board.audio_chip == V4L2_IDENT_WM8775)
--- ./projects/linux/linux-2.6.27/drivers/media/video/cx88/cx88-video.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/media/video/cx88/cx88-video.c	2008-12-25 00:26:37.000000000 +0100
@@ -429 +428,0 @@
-
@@ -431,16 +429,0 @@
-
-		/* cx2388's C-ADC is connected to the tuner only.
-		   When used with S-Video, that ADC is busy dealing with
-		   chroma, so an external must be used for baseband audio */
-
-		if (INPUT(input).type != CX88_VMUX_TELEVISION &&
-			INPUT(input).type != CX88_RADIO) {
-			/* "ADC mode" */
-			cx_write(AUD_I2SCNTL, 0x1);
-			cx_set(AUD_CTL, EN_I2SIN_ENABLE);
-		} else {
-			/* Normal mode */
-			cx_write(AUD_I2SCNTL, 0x0);
-			cx_clear(AUD_CTL, EN_I2SIN_ENABLE);
-		}
-
@@ -457 +439,0 @@
-
@@ -459 +441,12 @@
-
+		/* cx2388's C-ADC is connected to the tuner only.
+		   When used with S-Video, that ADC is busy dealing with
+		   chroma, so an external must be used for baseband audio */
+		if (INPUT(input).type != CX88_VMUX_TELEVISION ) {
+			/* "I2S ADC mode" */
+			core->tvaudio = WW_I2SADC;
+			cx88_set_tvaudio(core);
+		} else {
+			/* Normal mode */
+			cx_write(AUD_I2SCNTL, 0x0);
+			cx_clear(AUD_CTL, EN_I2SIN_ENABLE);
+		}
@@ -775,0 +769 @@
+	lock_kernel();
@@ -791 +785,2 @@
-	if (NULL == dev)
+	if (NULL == dev) {
+		unlock_kernel();
@@ -792,0 +788 @@
+	}
@@ -801 +797,2 @@
-	if (NULL == fh)
+	if (NULL == fh) {
+		unlock_kernel();
@@ -802,0 +800 @@
+	}
@@ -830,3 +828,18 @@
-		core->tvaudio = WW_FM;
-		cx88_set_tvaudio(core);
-		cx88_set_stereo(core,V4L2_TUNER_MODE_STEREO,1);
+		if (core->board.radio.audioroute) {
+			if(core->board.audio_chip &&
+				core->board.audio_chip == V4L2_IDENT_WM8775) {
+				struct v4l2_routing route;
+
+				route.input = core->board.radio.audioroute;
+				cx88_call_i2c_clients(core,
+					VIDIOC_INT_S_AUDIO_ROUTING, &route);
+			}
+			/* "I2S ADC mode" */
+			core->tvaudio = WW_I2SADC;
+			cx88_set_tvaudio(core);
+		} else {
+			/* FM Mode */
+			core->tvaudio = WW_FM;
+			cx88_set_tvaudio(core);
+			cx88_set_stereo(core,V4L2_TUNER_MODE_STEREO,1);
+		}
@@ -834,0 +848,3 @@
+	unlock_kernel();
+
+	atomic_inc(&core->users);
@@ -923 +939,2 @@
-	cx88_call_i2c_clients (dev->core, TUNER_SET_STANDBY, NULL);
+	if(atomic_dec_and_test(&dev->core->users))
+		cx88_call_i2c_clients (dev->core, TUNER_SET_STANDBY, NULL);
@@ -1202 +1219,4 @@
-	if (unlikely(fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE))
+	/* We should remember that this driver also supports teletext,  */
+	/* so we have to test if the v4l2_buf_type is VBI capture data. */
+	if (unlikely((fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&
+		     (fh->type != V4L2_BUF_TYPE_VBI_CAPTURE)))
@@ -1203,0 +1224 @@
+
@@ -1218 +1239,2 @@
-	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+	if ((fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) &&
+	    (fh->type != V4L2_BUF_TYPE_VBI_CAPTURE))
@@ -1219,0 +1242 @@
+
@@ -1897 +1920 @@
-	       core->name,dev->video_dev->minor & 0x1f);
+	       core->name, dev->video_dev->num);
@@ -1908 +1931 @@
-	       core->name,dev->vbi_dev->minor & 0x1f);
+	       core->name, dev->vbi_dev->num);
@@ -1921 +1944 @@
-		       core->name,dev->radio_dev->minor & 0x1f);
+		       core->name, dev->radio_dev->num);
--- ./projects/linux/linux-2.6.28/drivers/media/video/cx88/cx88-video.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/media/video/cx88/cx88-video.c	2009-03-24 00:12:14.000000000 +0100
@@ -760 +760 @@
-static int video_open(struct inode *inode, struct file *file)
+static int video_open(struct file *file)
@@ -762 +762 @@
-	int minor = iminor(inode);
+	int minor = video_devdata(file)->minor;
@@ -907 +907 @@
-static int video_release(struct inode *inode, struct file *file)
+static int video_release(struct file *file)
@@ -1450 +1450 @@
-				struct v4l2_register *reg)
+				struct v4l2_dbg_register *reg)
@@ -1454 +1454 @@
-	if (!v4l2_chip_match_host(reg->match_type, reg->match_chip))
+	if (!v4l2_chip_match_host(&reg->match))
@@ -1457 +1457,2 @@
-	reg->val = cx_read(reg->reg&0xffffff);
+	reg->val = cx_read(reg->reg & 0xffffff);
+	reg->size = 4;
@@ -1462 +1463 @@
-				struct v4l2_register *reg)
+				struct v4l2_dbg_register *reg)
@@ -1466 +1467 @@
-	if (!v4l2_chip_match_host(reg->match_type, reg->match_chip))
+	if (!v4l2_chip_match_host(&reg->match))
@@ -1468 +1469 @@
-	cx_write(reg->reg&0xffffff, reg->val);
+	cx_write(reg->reg & 0xffffff, reg->val);
@@ -1696 +1697 @@
-static const struct file_operations video_fops =
+static const struct v4l2_file_operations video_fops =
@@ -1705,2 +1705,0 @@
-	.compat_ioctl  = v4l_compat_ioctl32,
-	.llseek        = no_llseek,
@@ -1755 +1754 @@
-static const struct file_operations radio_fops =
+static const struct v4l2_file_operations radio_fops =
@@ -1761,2 +1759,0 @@
-	.compat_ioctl  = v4l_compat_ioctl32,
-	.llseek        = no_llseek,
--- ./projects/linux/linux-2.6.29/drivers/media/video/cx88/cx88-video.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/media/video/cx88/cx88-video.c	2009-06-27 11:32:32.000000000 +0200
@@ -44,5 +43,0 @@
-#ifdef CONFIG_VIDEO_V4L1_COMPAT
-/* Include V4L1 specific functions. Should be removed soon */
-#include <linux/videodev.h>
-#endif
-
@@ -300,0 +296 @@
+/* Must be sorted from low to high control ID! */
@@ -435,5 +431,2 @@
-			struct v4l2_routing route;
-
-			route.input = INPUT(input).audioroute;
-			cx88_call_i2c_clients(core,
-				VIDIOC_INT_S_AUDIO_ROUTING, &route);
+			call_all(core, audio, s_routing,
+					INPUT(input).audioroute, 0, 0);
@@ -831,5 +824,2 @@
-				struct v4l2_routing route;
-
-				route.input = core->board.radio.audioroute;
-				cx88_call_i2c_clients(core,
-					VIDIOC_INT_S_AUDIO_ROUTING, &route);
+				call_all(core, audio, s_routing,
+					core->board.radio.audioroute, 0, 0);
@@ -846 +836 @@
-		cx88_call_i2c_clients(core,AUDC_SET_RADIO,NULL);
+		call_all(core, tuner, s_radio);
@@ -940 +930 @@
-		cx88_call_i2c_clients (dev->core, TUNER_SET_STANDBY, NULL);
+		call_all(dev->core, tuner, s_standby);
@@ -1279 +1269 @@
-	unsigned int n;
+	unsigned int n = i->index;
@@ -1281 +1270,0 @@
-	n = i->index;
@@ -1286,2 +1274,0 @@
-	memset(i,0,sizeof(*i));
-	i->index = n;
@@ -1405 +1392 @@
-	cx88_call_i2c_clients(core,VIDIOC_G_FREQUENCY,f);
+	call_all(core, tuner, g_frequency, f);
@@ -1421 +1408 @@
-	cx88_call_i2c_clients(core,VIDIOC_S_FREQUENCY,f);
+	call_all(core, tuner, s_frequency, f);
@@ -1503 +1490 @@
-	cx88_call_i2c_clients(core,VIDIOC_G_TUNER,t);
+	call_all(core, tuner, g_tuner, t);
@@ -1523 +1509,0 @@
-	memset(a,0,sizeof(*a));
@@ -1538 +1524 @@
-	cx88_call_i2c_clients(core,VIDIOC_S_TUNER,t);
+	call_all(core, tuner, s_tuner, t);
@@ -1849 +1835 @@
-	if (!pci_dma_supported(pci_dev,DMA_32BIT_MASK)) {
+	if (!pci_dma_supported(pci_dev,DMA_BIT_MASK(32))) {
@@ -1895 +1881,10 @@
-		request_module("wm8775");
+		v4l2_i2c_new_subdev(&core->v4l2_dev, &core->i2c_adap,
+				"wm8775", "wm8775", 0x36 >> 1);
+
+	if (core->board.audio_chip == V4L2_IDENT_TVAUDIO) {
+		/* This probes for a tda9874 as is used on some
+		   Pixelview Ultra boards. */
+		v4l2_i2c_new_probed_subdev_addr(&core->v4l2_dev,
+				&core->i2c_adap,
+				"tvaudio", "tvaudio", 0xb0 >> 1);
+	}
@@ -1899 +1894,5 @@
-	case CX88_BOARD_DVICO_FUSIONHDTV_7_GOLD:
+	case CX88_BOARD_DVICO_FUSIONHDTV_7_GOLD: {
+		static struct i2c_board_info rtc_info = {
+			I2C_BOARD_INFO("isl1208", 0x6f)
+		};
+
@@ -1900,0 +1900,2 @@
+		core->i2c_rtc = i2c_new_device(&core->i2c_adap, &rtc_info);
+	}
--- ./projects/linux/linux-2.6.17/drivers/media/video/vivi.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/media/video/vivi.c	2006-09-20 05:42:06.000000000 +0200
@@ -51,14 +50,0 @@
-#ifndef kzalloc
-#define kzalloc(size, flags)                            \
-({                                                      \
-	void *__ret = kmalloc(size, flags);             \
-	if (__ret)                                      \
-		memset(__ret, 0, size);                 \
-	__ret;                                          \
-})
-#endif
-
-MODULE_DESCRIPTION("Video Technology Magazine Virtual Video Capture Board");
-MODULE_AUTHOR("Mauro Carvalho Chehab, Ted Walther and John Sokol");
-MODULE_LICENSE("Dual BSD/GPL");
-
@@ -70,9 +56,4 @@
-static int video_nr = -1;        /* /dev/videoN, -1 for autodetect */
-module_param(video_nr, int, 0);
-
-static int debug = 0;
-module_param(debug, int, 0);
-
-static unsigned int vid_limit = 16;
-module_param(vid_limit,int,0644);
-MODULE_PARM_DESC(vid_limit,"capture memory limit in megabytes");
+/* Declare static vars that will be used as parameters */
+static unsigned int vid_limit = 16;	/* Video memory limit, in Mb */
+static struct video_device vivi;	/* Video device */
+static int video_nr = -1;		/* /dev/videoN, -1 for autodetect */
@@ -132,4 +113,4 @@
-#define dprintk(level,fmt, arg...)			     \
-	do { 						     \
-		if (debug >= (level))			     \
-			printk(KERN_DEBUG "vivi: " fmt , ## arg);    \
+#define dprintk(level,fmt, arg...)					\
+	do {								\
+		if (vivi.debug >= (level))				\
+			printk(KERN_DEBUG "vivi: " fmt , ## arg);	\
@@ -193 +174 @@
-	struct video_device        video_dev;
+	struct video_device        vfd;
@@ -251 +232,2 @@
-void prep_to_addr(struct sg_to_addr to_addr[],struct videobuf_buffer *vb)
+static void prep_to_addr(struct sg_to_addr to_addr[],
+			 struct videobuf_buffer *vb)
@@ -262 +244 @@
-inline int get_addr_pos(int pos, int pages, struct sg_to_addr to_addr[])
+static int get_addr_pos(int pos, int pages, struct sg_to_addr to_addr[])
@@ -283,2 +265,2 @@
-void gen_line(struct sg_to_addr to_addr[],int inipos,int pages,int wmax,
-					int hmax, int line, char *timestr)
+static void gen_line(struct sg_to_addr to_addr[],int inipos,int pages,int wmax,
+		     int hmax, int line, char *timestr)
@@ -494 +476 @@
-void vivi_sleep(struct vivi_dmaqueue  *dma_q)
+static void vivi_sleep(struct vivi_dmaqueue  *dma_q)
@@ -529 +511 @@
-int vivi_thread(void *data)
+static int vivi_thread(void *data)
@@ -545 +527 @@
-int vivi_start_thread(struct vivi_dmaqueue  *dma_q)
+static int vivi_start_thread(struct vivi_dmaqueue  *dma_q)
@@ -563 +545 @@
-void vivi_stop_thread(struct vivi_dmaqueue  *dma_q)
+static void vivi_stop_thread(struct vivi_dmaqueue  *dma_q)
@@ -669,2 +651 @@
-void
-free_buffer(struct videobuf_queue *vq, struct vivi_buffer *buf)
+static void free_buffer(struct videobuf_queue *vq, struct vivi_buffer *buf)
@@ -794,2 +775,2 @@
-int vivi_map_sg (void *dev, struct scatterlist *sg, int nents,
-	   int direction)
+static int vivi_map_sg(void *dev, struct scatterlist *sg, int nents,
+		       int direction)
@@ -811,2 +792,2 @@
-int vivi_unmap_sg(void *dev,struct scatterlist *sglist,int nr_pages,
-					int direction)
+static int vivi_unmap_sg(void *dev,struct scatterlist *sglist,int nr_pages,
+			 int direction)
@@ -818,2 +799,2 @@
-int vivi_dma_sync_sg(void *dev,struct scatterlist *sglist,int nr_pages,
-					int direction)
+static int vivi_dma_sync_sg(void *dev,struct scatterlist *sglist, int nr_pages,
+			    int direction)
@@ -843 +824,74 @@
-static int vivi_try_fmt(struct vivi_dev *dev, struct vivi_fh *fh,
+
+static int res_get(struct vivi_dev *dev, struct vivi_fh *fh)
+{
+	/* is it free? */
+	down(&dev->lock);
+	if (dev->resources) {
+		/* no, someone else uses it */
+		up(&dev->lock);
+		return 0;
+	}
+	/* it's free, grab it */
+	dev->resources =1;
+	dprintk(1,"res: get\n");
+	up(&dev->lock);
+	return 1;
+}
+
+static int res_locked(struct vivi_dev *dev)
+{
+	return (dev->resources);
+}
+
+static void res_free(struct vivi_dev *dev, struct vivi_fh *fh)
+{
+	down(&dev->lock);
+	dev->resources = 0;
+	dprintk(1,"res: put\n");
+	up(&dev->lock);
+}
+
+/* ------------------------------------------------------------------
+	IOCTL vidioc handling
+   ------------------------------------------------------------------*/
+static int vidioc_querycap (struct file *file, void  *priv,
+					struct v4l2_capability *cap)
+{
+	strcpy(cap->driver, "vivi");
+	strcpy(cap->card, "vivi");
+	cap->version = VIVI_VERSION;
+	cap->capabilities =	V4L2_CAP_VIDEO_CAPTURE |
+				V4L2_CAP_STREAMING     |
+				V4L2_CAP_READWRITE;
+	return 0;
+}
+
+static int vidioc_enum_fmt_cap (struct file *file, void  *priv,
+					struct v4l2_fmtdesc *f)
+{
+	if (f->index > 0)
+		return -EINVAL;
+
+	strlcpy(f->description,format.name,sizeof(f->description));
+	f->pixelformat = format.fourcc;
+	return 0;
+}
+
+static int vidioc_g_fmt_cap (struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct vivi_fh  *fh=priv;
+
+	f->fmt.pix.width        = fh->width;
+	f->fmt.pix.height       = fh->height;
+	f->fmt.pix.field        = fh->vb_vidq.field;
+	f->fmt.pix.pixelformat  = fh->fmt->fourcc;
+	f->fmt.pix.bytesperline =
+		(f->fmt.pix.width * fh->fmt->depth) >> 3;
+	f->fmt.pix.sizeimage =
+		f->fmt.pix.height * f->fmt.pix.bytesperline;
+
+	return (0);
+}
+
+static int vidioc_try_fmt_cap (struct file *file, void *priv,
@@ -851 +905,2 @@
-		dprintk(1,"Fourcc format invalid.\n");
+		dprintk(1,"Fourcc format (0x%08x) invalid. Driver accepts "
+			"only 0x%08x\n",f->fmt.pix.pixelformat,format.fourcc);
@@ -887 +942,3 @@
-static int res_get(struct vivi_dev *dev, struct vivi_fh *fh)
+/*FIXME: This seems to be generic enough to be at videodev2 */
+static int vidioc_s_fmt_cap (struct file *file, void *priv,
+					struct v4l2_format *f)
@@ -889,13 +946,4 @@
-	/* is it free? */
-	down(&dev->lock);
-	if (dev->resources) {
-		/* no, someone else uses it */
-		up(&dev->lock);
-		return 0;
-	}
-	/* it's free, grab it */
-	dev->resources =1;
-	dprintk(1,"res: get\n");
-	up(&dev->lock);
-	return 1;
-}
+	struct vivi_fh  *fh=priv;
+	int ret = vidioc_try_fmt_cap(file,fh,f);
+	if (ret < 0)
+		return (ret);
@@ -903,3 +951,7 @@
-static inline int res_locked(struct vivi_dev *dev)
-{
-	return (dev->resources);
+	fh->fmt           = &format;
+	fh->width         = f->fmt.pix.width;
+	fh->height        = f->fmt.pix.height;
+	fh->vb_vidq.field = f->fmt.pix.field;
+	fh->type          = f->type;
+
+	return (0);
@@ -908 +960 @@
-static void res_free(struct vivi_dev *dev, struct vivi_fh *fh)
+static int vidioc_reqbufs (struct file *file, void *priv, struct v4l2_requestbuffers *p)
@@ -910,4 +962,3 @@
-	down(&dev->lock);
-	dev->resources = 0;
-	dprintk(1,"res: put\n");
-	up(&dev->lock);
+	struct vivi_fh  *fh=priv;
+
+	return (videobuf_reqbufs(&fh->vb_vidq, p));
@@ -916 +967 @@
-static int vivi_do_ioctl(struct inode *inode, struct file *file, unsigned int cmd, void *arg)
+static int vidioc_querybuf (struct file *file, void *priv, struct v4l2_buffer *p)
@@ -918,3 +969 @@
-	struct vivi_fh  *fh     = file->private_data;
-	struct vivi_dev *dev    = fh->dev;
-	int ret=0;
+	struct vivi_fh  *fh=priv;
@@ -922,7 +971,2 @@
-	if (debug) {
-		if (_IOC_DIR(cmd) & _IOC_WRITE)
-			v4l_printk_ioctl_arg("vivi(w)",cmd, arg);
-		else if (!_IOC_DIR(cmd) & _IOC_READ) {
-			v4l_print_ioctl("vivi", cmd);
-		}
-	}
+	return (videobuf_querybuf(&fh->vb_vidq, p));
+}
@@ -930,5 +974,3 @@
-	switch(cmd) {
-	/* --- capabilities ------------------------------------------ */
-	case VIDIOC_QUERYCAP:
-	{
-		struct v4l2_capability *cap = (struct v4l2_capability*)arg;
+static int vidioc_qbuf (struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct vivi_fh  *fh=priv;
@@ -936 +978,2 @@
-		memset(cap, 0, sizeof(*cap));
+	return (videobuf_qbuf(&fh->vb_vidq, p));
+}
@@ -938,15 +981,3 @@
-		strcpy(cap->driver, "vivi");
-		strcpy(cap->card, "vivi");
-		cap->version = VIVI_VERSION;
-		cap->capabilities =
-					V4L2_CAP_VIDEO_CAPTURE |
-					V4L2_CAP_STREAMING     |
-					V4L2_CAP_READWRITE;
-		break;
-	}
-	/* --- capture ioctls ---------------------------------------- */
-	case VIDIOC_ENUM_FMT:
-	{
-		struct v4l2_fmtdesc *f = arg;
-		enum v4l2_buf_type type;
-		unsigned int index;
+static int vidioc_dqbuf (struct file *file, void *priv, struct v4l2_buffer *p)
+{
+	struct vivi_fh  *fh=priv;
@@ -954,2 +985,3 @@
-		index = f->index;
-		type  = f->type;
+	return (videobuf_dqbuf(&fh->vb_vidq, p,
+				file->f_flags & O_NONBLOCK));
+}
@@ -957,4 +989,7 @@
-		if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			ret=-EINVAL;
-			break;
-		}
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+static int vidiocgmbuf (struct file *file, void *priv, struct video_mbuf *mbuf)
+{
+	struct vivi_fh  *fh=priv;
+	struct videobuf_queue *q=&fh->vb_vidq;
+	struct v4l2_requestbuffers req;
+	unsigned int i, ret;
@@ -962,7 +997,6 @@
-		switch (type) {
-		case V4L2_BUF_TYPE_VIDEO_CAPTURE:
-			if (index > 0){
-				ret=-EINVAL;
-				break;
-			}
-			memset(f,0,sizeof(*f));
+	req.type   = q->type;
+	req.count  = 8;
+	req.memory = V4L2_MEMORY_MMAP;
+	ret = videobuf_reqbufs(q,&req);
+	if (ret < 0)
+		return (ret);
@@ -970,9 +1004,5 @@
-			f->index = index;
-			f->type  = type;
-			strlcpy(f->description,format.name,sizeof(f->description));
-			f->pixelformat = format.fourcc;
-			break;
-		default:
-			ret=-EINVAL;
-		}
-		break;
+	mbuf->frames = req.count;
+	mbuf->size   = 0;
+	for (i = 0; i < mbuf->frames; i++) {
+		mbuf->offsets[i]  = q->bufs[i]->boff;
+		mbuf->size       += q->bufs[i]->bsize;
@@ -980,3 +1010,3 @@
-	case VIDIOC_G_FMT:
-	{
-		struct v4l2_format *f = (struct v4l2_format *)arg;
+	return (0);
+}
+#endif
@@ -984,4 +1014,4 @@
-		if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			ret=-EINVAL;
-			break;
-		}
+static int vidioc_streamon(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct vivi_fh  *fh=priv;
+	struct vivi_dev *dev    = fh->dev;
@@ -989,14 +1019,4 @@
-		memset(&f->fmt.pix,0,sizeof(f->fmt.pix));
-		f->fmt.pix.width        = fh->width;
-		f->fmt.pix.height       = fh->height;
-		f->fmt.pix.field        = fh->vb_vidq.field;
-		f->fmt.pix.pixelformat  = fh->fmt->fourcc;
-		f->fmt.pix.bytesperline =
-			(f->fmt.pix.width * fh->fmt->depth) >> 3;
-		f->fmt.pix.sizeimage =
-			f->fmt.pix.height * f->fmt.pix.bytesperline;
-		break;
-	}
-	case VIDIOC_S_FMT:
-	{
-		struct v4l2_format *f = arg;
+	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (i != fh->type)
+		return -EINVAL;
@@ -1004,5 +1024,4 @@
-		if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			dprintk(1,"Only capture supported.\n");
-			ret=-EINVAL;
-			break;
-		}
+	if (!res_get(dev,fh))
+		return -EBUSY;
+	return (videobuf_streamon(&fh->vb_vidq));
+}
@@ -1010,3 +1029,4 @@
-		ret = vivi_try_fmt(dev,fh,f);
-		if (ret < 0)
-			break;
+static int vidioc_streamoff(struct file *file, void *priv, enum v4l2_buf_type i)
+{
+	struct vivi_fh  *fh=priv;
+	struct vivi_dev *dev    = fh->dev;
@@ -1014,5 +1034,4 @@
-		fh->fmt           = &format;
-		fh->width         = f->fmt.pix.width;
-		fh->height        = f->fmt.pix.height;
-		fh->vb_vidq.field = f->fmt.pix.field;
-		fh->type          = f->type;
+	if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
+		return -EINVAL;
+	if (i != fh->type)
+		return -EINVAL;
@@ -1020,9 +1039,2 @@
-		break;
-	}
-	case VIDIOC_TRY_FMT:
-	{
-		struct v4l2_format *f = arg;
-		if (f->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			ret=-EINVAL;
-			break;
-		}
+	videobuf_streamoff(&fh->vb_vidq);
+	res_free(dev,fh);
@@ -1030,68 +1042,4 @@
-		ret=vivi_try_fmt(dev,fh,f);
-		break;
-	}
-	case VIDIOC_REQBUFS:
-		if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			ret=-EINVAL;
-			break;
-		}
-		ret=videobuf_reqbufs(&fh->vb_vidq, arg);
-		break;
-	case VIDIOC_QUERYBUF:
-		if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			ret=-EINVAL;
-			break;
-		}
-		ret=videobuf_querybuf(&fh->vb_vidq, arg);
-		break;
-	case VIDIOC_QBUF:
-		if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			ret=-EINVAL;
-			break;
-		}
-		ret=videobuf_qbuf(&fh->vb_vidq, arg);
-		break;
-	case VIDIOC_DQBUF:
-		if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			ret=-EINVAL;
-			break;
-		}
-		ret=videobuf_dqbuf(&fh->vb_vidq, arg,
-					file->f_flags & O_NONBLOCK);
-		break;
-#ifdef HAVE_V4L1
-	/* --- streaming capture ------------------------------------- */
-	case VIDIOCGMBUF:
-	{
-		struct video_mbuf *mbuf = arg;
-		struct videobuf_queue *q=&fh->vb_vidq;
-		struct v4l2_requestbuffers req;
-		unsigned int i;
-
-		memset(&req,0,sizeof(req));
-		req.type   = q->type;
-		req.count  = 8;
-		req.memory = V4L2_MEMORY_MMAP;
-		ret = videobuf_reqbufs(q,&req);
-		if (ret < 0)
-			break;
-		memset(mbuf,0,sizeof(*mbuf));
-		mbuf->frames = req.count;
-		mbuf->size   = 0;
-		for (i = 0; i < mbuf->frames; i++) {
-			mbuf->offsets[i]  = q->bufs[i]->boff;
-			mbuf->size       += q->bufs[i]->bsize;
-		}
-		break;
-	}
-#endif
-	case VIDIOC_STREAMON:
-	{
-		if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE)
-			return -EINVAL;
-		if (!res_get(dev,fh))
-			return -EBUSY;
-		ret=videobuf_streamon(&fh->vb_vidq);
-		break;
-	}
-	case VIDIOC_STREAMOFF:
+	return (0);
+}
+
+static struct v4l2_tvnorm tvnorms[] = {
@@ -1099,9 +1047,2 @@
-		if (fh->type != V4L2_BUF_TYPE_VIDEO_CAPTURE) {
-			ret=-EINVAL;
-			break;
-		}
-		ret = videobuf_streamoff(&fh->vb_vidq);
-		if (ret < 0)
-			break;
-		res_free(dev,fh);
-		break;
+		.name      = "NTSC-M",
+		.id        = V4L2_STD_NTSC_M,
@@ -1109,4 +1050 @@
-	/* ---------- tv norms ---------- */
-	case VIDIOC_ENUMSTD:
-	{
-		struct v4l2_standard *e = arg;
+};
@@ -1114,5 +1052,2 @@
-		if (e->index>0) {
-			ret=-EINVAL;
-			break;
-		}
-		ret = v4l2_video_std_construct(e, V4L2_STD_NTSC_M, "NTSC-M");
+static int vidioc_s_std (struct file *file, void *priv, v4l2_std_id a)
+{
@@ -1120,3 +1055,2 @@
-		/* Allows vivi to use different fps from video std */
-		e->frameperiod.numerator = WAKE_NUMERATOR;
-		e->frameperiod.denominator = WAKE_DENOMINATOR;
+	return 0;
+}
@@ -1124,5 +1058,6 @@
-		break;
-	}
-	case VIDIOC_G_STD:
-	{
-		v4l2_std_id *id = arg;
+/* only one input in this sample driver */
+static int vidioc_enum_input (struct file *file, void *priv,
+				struct v4l2_input *inp)
+{
+	if (inp->index != 0)
+		return -EINVAL;
@@ -1130,11 +1065,3 @@
-		*id = V4L2_STD_NTSC_M;
-		break;
-	}
-	case VIDIOC_S_STD:
-	{
-		break;
-	}
-	/* ------ input switching ---------- */
-	case VIDIOC_ENUMINPUT:
-	{ /* only one input in this sample driver */
-		struct v4l2_input *inp = arg;
+	inp->type = V4L2_INPUT_TYPE_CAMERA;
+	inp->std = V4L2_STD_NTSC_M;
+	strcpy(inp->name,"Camera");
@@ -1142,5 +1069,2 @@
-		if (inp->index != 0) {
-			ret=-EINVAL;
-			break;
-		}
-		memset(inp, 0, sizeof(*inp));
+	return (0);
+}
@@ -1148,9 +1072,3 @@
-		inp->index = 0;
-		inp->type = V4L2_INPUT_TYPE_CAMERA;
-		inp->std = V4L2_STD_NTSC_M;
-		strcpy(inp->name,"Camera");
-		break;
-	}
-	case VIDIOC_G_INPUT:
-	{
-		unsigned int *i = arg;
+static int vidioc_g_input (struct file *file, void *priv, unsigned int *i)
+{
+	*i = 0;
@@ -1158,6 +1076,6 @@
-		*i = 0;
-		break;
-	}
-	case VIDIOC_S_INPUT:
-	{
-		unsigned int *i = arg;
+	return (0);
+}
+static int vidioc_s_input (struct file *file, void *priv, unsigned int i)
+{
+	if (i > 0)
+		return -EINVAL;
@@ -1165,4 +1083,2 @@
-		if (*i > 0)
-			ret=-EINVAL;
-		break;
-	}
+	return (0);
+}
@@ -1171,11 +1087,4 @@
-	case VIDIOC_QUERYCTRL:
-	{
-		struct v4l2_queryctrl *qc = arg;
-		int i;
-
-		for (i = 0; i < ARRAY_SIZE(vivi_qctrl); i++)
-			if (qc->id && qc->id == vivi_qctrl[i].id) {
-				memcpy(qc, &(vivi_qctrl[i]),
-					sizeof(*qc));
-				break;
-			}
+static int vidioc_queryctrl (struct file *file, void *priv,
+				struct v4l2_queryctrl *qc)
+{
+	int i;
@@ -1183,7 +1092,6 @@
-		ret=-EINVAL;
-		break;
-	}
-	case VIDIOC_G_CTRL:
-	{
-		struct v4l2_control *ctrl = arg;
-		int i;
+	for (i = 0; i < ARRAY_SIZE(vivi_qctrl); i++)
+		if (qc->id && qc->id == vivi_qctrl[i].id) {
+			memcpy(qc, &(vivi_qctrl[i]),
+				sizeof(*qc));
+			return (0);
+		}
@@ -1191,5 +1099,2 @@
-		for (i = 0; i < ARRAY_SIZE(vivi_qctrl); i++)
-			if (ctrl->id == vivi_qctrl[i].id) {
-				ctrl->value=qctl_regs[i];
-				break;
-			}
+	return -EINVAL;
+}
@@ -1197,25 +1102,4 @@
-		ret=-EINVAL;
-		break;
-	}
-	case VIDIOC_S_CTRL:
-	{
-		struct v4l2_control *ctrl = arg;
-		int i;
-		for (i = 0; i < ARRAY_SIZE(vivi_qctrl); i++)
-			if (ctrl->id == vivi_qctrl[i].id) {
-				if (ctrl->value <
-					vivi_qctrl[i].minimum
-					|| ctrl->value >
-					vivi_qctrl[i].maximum) {
-						ret=-ERANGE;
-						break;
-					}
-				qctl_regs[i]=ctrl->value;
-				break;
-			}
-		ret=-EINVAL;
-		break;
-	}
-	default:
-		ret=v4l_compat_translate_ioctl(inode,file,cmd,arg,vivi_do_ioctl);
-	}
+static int vidioc_g_ctrl (struct file *file, void *priv,
+				struct v4l2_control *ctrl)
+{
+	int i;
@@ -1223,7 +1107,5 @@
-	if (debug) {
-		if (ret<0) {
-			v4l_print_ioctl("vivi(err)", cmd);
-			dprintk(1,"errcode=%d\n",ret);
-		} else if (_IOC_DIR(cmd) & _IOC_READ)
-			v4l_printk_ioctl_arg("vivi(r)",cmd, arg);
-	}
+	for (i = 0; i < ARRAY_SIZE(vivi_qctrl); i++)
+		if (ctrl->id == vivi_qctrl[i].id) {
+			ctrl->value=qctl_regs[i];
+			return (0);
+		}
@@ -1231 +1113 @@
-	return ret;
+	return -EINVAL;
@@ -1233,2 +1115,2 @@
-
-static int vivi_ioctl(struct inode *inode, struct file *file, unsigned int cmd, unsigned long arg)
+static int vidioc_s_ctrl (struct file *file, void *priv,
+				struct v4l2_control *ctrl)
@@ -1236 +1118,14 @@
-	return video_usercopy(inode, file, cmd, arg, vivi_do_ioctl);
+	int i;
+
+	for (i = 0; i < ARRAY_SIZE(vivi_qctrl); i++)
+		if (ctrl->id == vivi_qctrl[i].id) {
+			if (ctrl->value <
+				vivi_qctrl[i].minimum
+				|| ctrl->value >
+				vivi_qctrl[i].maximum) {
+					return (-ERANGE);
+				}
+			qctl_regs[i]=ctrl->value;
+			return (0);
+		}
+	return -EINVAL;
@@ -1258 +1153 @@
-		if (h->video_dev.minor == minor) {
+		if (h->vfd.minor == minor) {
@@ -1266,0 +1162 @@
+
@@ -1281,0 +1178 @@
+
@@ -1317 +1214 @@
-	struct vivi_fh *fh = file->private_data;
+	struct vivi_fh        *fh = file->private_data;
@@ -1331,2 +1228,2 @@
-	struct vivi_fh *fh = file->private_data;
-	struct vivi_buffer *buf;
+	struct vivi_fh        *fh = file->private_data;
+	struct vivi_buffer    *buf;
@@ -1361,2 +1258,2 @@
-	struct vivi_fh  *fh     = file->private_data;
-	struct vivi_dev *dev    = fh->dev;
+	struct vivi_fh         *fh = file->private_data;
+	struct vivi_dev *dev       = fh->dev;
@@ -1382 +1279 @@
-	struct vivi_fh *fh = file->private_data;
+	struct vivi_fh        *fh = file->private_data;
@@ -1403 +1300 @@
-	.ioctl          = vivi_ioctl,
+	.ioctl          = video_ioctl2, /* V4L2 ioctl handler */
@@ -1409 +1306 @@
-	.name		= "VTM Virtual Video Capture Board",
+	.name		= "vivi",
@@ -1414,0 +1312,24 @@
+
+	.vidioc_querycap      = vidioc_querycap,
+	.vidioc_enum_fmt_cap  = vidioc_enum_fmt_cap,
+	.vidioc_g_fmt_cap     = vidioc_g_fmt_cap,
+	.vidioc_try_fmt_cap   = vidioc_try_fmt_cap,
+	.vidioc_s_fmt_cap     = vidioc_s_fmt_cap,
+	.vidioc_reqbufs       = vidioc_reqbufs,
+	.vidioc_querybuf      = vidioc_querybuf,
+	.vidioc_qbuf          = vidioc_qbuf,
+	.vidioc_dqbuf         = vidioc_dqbuf,
+	.vidioc_s_std         = vidioc_s_std,
+	.vidioc_enum_input    = vidioc_enum_input,
+	.vidioc_g_input       = vidioc_g_input,
+	.vidioc_s_input       = vidioc_s_input,
+	.vidioc_queryctrl     = vidioc_queryctrl,
+	.vidioc_g_ctrl        = vidioc_g_ctrl,
+	.vidioc_s_ctrl        = vidioc_s_ctrl,
+	.vidioc_streamon      = vidioc_streamon,
+	.vidioc_streamoff     = vidioc_streamoff,
+#ifdef CONFIG_VIDEO_V4L1_COMPAT
+	.vidiocgmbuf          = vidiocgmbuf,
+#endif
+	.tvnorms              = tvnorms,
+	.tvnormsize           = ARRAY_SIZE(tvnorms),
@@ -1416 +1337 @@
-/* ------------------------------------------------------------------
+/* -----------------------------------------------------------------
@@ -1459,0 +1381,13 @@
+
+MODULE_DESCRIPTION("Video Technology Magazine Virtual Video Capture Board");
+MODULE_AUTHOR("Mauro Carvalho Chehab, Ted Walther and John Sokol");
+MODULE_LICENSE("Dual BSD/GPL");
+
+module_param(video_nr, int, 0);
+
+module_param_named(debug,vivi.debug, int, 0644);
+MODULE_PARM_DESC(debug,"activates debug info");
+
+module_param(vid_limit,int,0644);
+MODULE_PARM_DESC(vid_limit,"capture memory limit in megabytes");
+
--- ./projects/linux/linux-2.6.18/drivers/media/video/vivi.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/media/video/vivi.c	2006-11-29 22:57:37.000000000 +0100
@@ -275 +275 @@
-	pg=pfn_to_page(to_addr[oldpg].sg->dma_address >> PAGE_SHIFT);
+	pg=pfn_to_page(sg_dma_address(to_addr[oldpg].sg) >> PAGE_SHIFT);
@@ -290 +290 @@
-				pg=pfn_to_page(to_addr[pgpos].sg->dma_address >> PAGE_SHIFT);
+				pg=pfn_to_page(sg_dma_address(to_addr[pgpos].sg) >> PAGE_SHIFT);
@@ -342,2 +342,2 @@
-						pg=pfn_to_page(to_addr[pgpos].
-								sg->dma_address
+						pg=pfn_to_page(sg_dma_address(
+								to_addr[pgpos].sg)
@@ -389 +389 @@
-	if (!vb->dma.sglist[0].dma_address)
+	if (!sg_dma_address(&vb->dma.sglist[0]))
@@ -786 +786 @@
-		sg[i].dma_address = page_to_phys(sg[i].page) + sg[i].offset;
+		sg_dma_address(&sg[i]) = page_to_phys(sg[i].page) + sg[i].offset;
@@ -995 +995,2 @@
-	unsigned int i, ret;
+	unsigned int i;
+	int ret;
@@ -1361,0 +1363,2 @@
+	vivi.current_norm         = tvnorms[0].id;
+
--- ./projects/linux/linux-2.6.19/drivers/media/video/vivi.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/media/video/vivi.c	2007-02-04 19:44:54.000000000 +0100
@@ -38,0 +39 @@
+#include <linux/freezer.h>
@@ -271,0 +273,4 @@
+	unsigned long flags;
+	spinlock_t spinlock;
+
+	spin_lock_init(&spinlock);
@@ -275,0 +281 @@
+	spin_lock_irqsave(&spinlock,flags);
@@ -377,0 +384,2 @@
+	spin_unlock_irqrestore(&spinlock,flags);
+
@@ -537 +545 @@
-	if (dma_q->kthread == NULL) {
+	if (IS_ERR(dma_q->kthread)) {
@@ -539 +547 @@
-		return -EINVAL;
+		return PTR_ERR(dma_q->kthread);
@@ -1046,8 +1054 @@
-static struct v4l2_tvnorm tvnorms[] = {
-	{
-		.name      = "NTSC-M",
-		.id        = V4L2_STD_NTSC_M,
-	}
-};
-
-static int vidioc_s_std (struct file *file, void *priv, v4l2_std_id a)
+static int vidioc_s_std (struct file *file, void *priv, v4l2_std_id *i)
@@ -1055 +1055,0 @@
-
@@ -1335,2 +1335,2 @@
-	.tvnorms              = tvnorms,
-	.tvnormsize           = ARRAY_SIZE(tvnorms),
+	.tvnorms              = V4L2_STD_NTSC_M,
+	.current_norm         = V4L2_STD_NTSC_M,
@@ -1363,2 +1362,0 @@
-	vivi.current_norm         = tvnorms[0].id;
-
@@ -1375 +1373,3 @@
-	list_for_each(list,&vivi_devlist) {
+	while (!list_empty(&vivi_devlist)) {
+		list = vivi_devlist.next;
+		list_del(list);
--- ./projects/linux/linux-2.6.20/drivers/media/video/vivi.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/media/video/vivi.c	2007-04-26 05:08:32.000000000 +0200
@@ -147,0 +148 @@
+#ifdef CONFIG_VIVI_SCATTER
@@ -148,0 +150 @@
+#endif
@@ -232,0 +235 @@
+#ifdef CONFIG_VIVI_SCATTER
@@ -264,0 +268 @@
+#endif
@@ -265,0 +270 @@
+#ifdef CONFIG_VIVI_SCATTER
@@ -267,0 +273,4 @@
+#else
+static void gen_line(char *basep,int inipos,int wmax,
+		     int hmax, int line, char *timestr)
+#endif
@@ -269,3 +278,2 @@
-	int  w,i,j,pos=inipos,pgpos,oldpg,y;
-	char *p,*s,*basep;
-	struct page *pg;
+	int  w,i,j,pos=inipos,y;
+	char *p,*s;
@@ -272,0 +281,5 @@
+#ifdef CONFIG_VIVI_SCATTER
+	int pgpos,oldpg;
+	char *basep;
+	struct page *pg;
+
@@ -282,0 +296 @@
+#endif
@@ -293,0 +308 @@
+#ifdef CONFIG_VIVI_SCATTER
@@ -301,0 +317,3 @@
+#else
+			p=basep+pos;
+#endif
@@ -345,0 +364 @@
+#ifdef CONFIG_VIVI_SCATTER
@@ -358,0 +378,3 @@
+#else
+					p=basep+pos;
+#endif
@@ -382,0 +405 @@
+#ifdef CONFIG_VIVI_SCATTER
@@ -385 +408,3 @@
-
+#else
+	return;
+#endif
@@ -392,2 +416,0 @@
-	struct videobuf_buffer *vb=&buf->vb;
-	struct sg_to_addr *to_addr=buf->to_addr;
@@ -394,0 +418,6 @@
+#ifdef CONFIG_VIVI_SCATTER
+	struct sg_to_addr *to_addr=buf->to_addr;
+	struct videobuf_buffer *vb=&buf->vb;
+#else
+	char *tmpbuf;
+#endif
@@ -395,0 +425 @@
+#ifdef CONFIG_VIVI_SCATTER
@@ -403,0 +434,8 @@
+#else
+	if (buf->vb.dma.varea) {
+		tmpbuf=kmalloc (wmax*2, GFP_KERNEL);
+	} else {
+		tmpbuf=buf->vb.dma.vmalloc;
+	}
+
+#endif
@@ -405,0 +444 @@
+#ifdef CONFIG_VIVI_SCATTER
@@ -406,0 +446,10 @@
+#else
+		if (buf->vb.dma.varea) {
+			gen_line(tmpbuf,0,wmax,hmax,h,dev->timestr);
+			/* FIXME: replacing to __copy_to_user */
+			if (copy_to_user(buf->vb.dma.varea+pos,tmpbuf,wmax*2)!=0)
+				dprintk(2,"vivifill copy_to_user failed.\n");
+		} else {
+			gen_line(tmpbuf,pos,wmax,hmax,h,dev->timestr);
+		}
+#endif
@@ -432 +481 @@
-			(unsigned long)buf->vb.dma.vmalloc,pos);
+			(unsigned long)buf->vb.dma.varea,pos);
@@ -474,5 +523,6 @@
-	}
-	if (list_empty(&dma_q->active)) {
-		del_timer(&dma_q->timeout);
-	} else {
-		mod_timer(&dma_q->timeout, jiffies+BUFFER_TIMEOUT);
+
+		if (list_empty(&dma_q->active)) {
+			del_timer(&dma_q->timeout);
+		} else {
+			mod_timer(&dma_q->timeout, jiffies+BUFFER_TIMEOUT);
+		}
@@ -524,0 +575,2 @@
+	mod_timer(&dma_q->timeout, jiffies+BUFFER_TIMEOUT);
+
@@ -541 +592,0 @@
-	init_waitqueue_head(&dma_q->wq);
@@ -548,0 +600,3 @@
+	/* Wakes thread */
+	wake_up_interruptible(&dma_q->wq);
+
@@ -665,0 +720 @@
+#ifdef CONFIG_VIVI_SCATTER
@@ -668,0 +724 @@
+#endif
@@ -713,0 +770 @@
+#ifdef CONFIG_VIVI_SCATTER
@@ -718 +775 @@
-
+#endif
@@ -782,0 +840 @@
+#ifdef CONFIG_VIVI_SCATTER
@@ -814,0 +873 @@
+#endif
@@ -823,3 +882,3 @@
-	.vb_map_sg      = vivi_map_sg,
-	.vb_dma_sync_sg = vivi_dma_sync_sg,
-	.vb_unmap_sg    = vivi_unmap_sg,
+//	.vb_map_sg      = vivi_map_sg,
+//	.vb_dma_sync_sg = vivi_dma_sync_sg,
+//	.vb_unmap_sg    = vivi_unmap_sg,
@@ -1202,0 +1262,7 @@
+#ifdef CONFIG_VIVI_SCATTER
+	videobuf_queue_init(&fh->vb_vidq,VIDEOBUF_DMA_SCATTER, &vivi_video_qops,
+			NULL, NULL,
+			fh->type,
+			V4L2_FIELD_INTERLACED,
+			sizeof(struct vivi_buffer),fh);
+#else
@@ -1207,0 +1274 @@
+#endif
@@ -1295 +1362 @@
-static struct file_operations vivi_fops = {
+static const struct file_operations vivi_fops = {
@@ -1354,0 +1422 @@
+	init_waitqueue_head(&dev->vidq.wq);
--- ./projects/linux/linux-2.6.22/drivers/media/video/vivi.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/media/video/vivi.c	2007-10-09 22:31:38.000000000 +0200
@@ -27,0 +28 @@
+#include <linux/mutex.h>
@@ -148,3 +148,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-	struct sg_to_addr      *to_addr;
-#endif
@@ -171 +169 @@
-	struct semaphore           lock;
+	struct mutex               lock;
@@ -235,19 +232,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-static void prep_to_addr(struct sg_to_addr to_addr[],
-			 struct videobuf_buffer *vb)
-{
-	int i, pos=0;
-
-	for (i=0;i<vb->dma.nr_pages;i++) {
-		to_addr[i].sg=&vb->dma.sglist[i];
-		to_addr[i].pos=pos;
-		pos += vb->dma.sglist[i].length;
-	}
-}
-
-static int get_addr_pos(int pos, int pages, struct sg_to_addr to_addr[])
-{
-	int p1=0,p2=pages-1,p3=pages/2;
-
-	/* Sanity test */
-	BUG_ON (pos>=to_addr[p2].pos+to_addr[p2].sg->length);
@@ -255,19 +233,0 @@
-	while (p1+1<p2) {
-		if (pos < to_addr[p3].pos) {
-			p2=p3;
-		} else {
-			p1=p3;
-		}
-		p3=(p1+p2)/2;
-	}
-	if (pos >= to_addr[p2].pos)
-		p1=p2;
-
-	return (p1);
-}
-#endif
-
-#ifdef CONFIG_VIVI_SCATTER
-static void gen_line(struct sg_to_addr to_addr[],int inipos,int pages,int wmax,
-		     int hmax, int line, char *timestr)
-#else
@@ -276 +235,0 @@
-#endif
@@ -281,16 +239,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-	int pgpos,oldpg;
-	char *basep;
-	struct page *pg;
-
-	unsigned long flags;
-	spinlock_t spinlock;
-
-	spin_lock_init(&spinlock);
-
-	/* Get first addr pointed to pixel position */
-	oldpg=get_addr_pos(pos,pages,to_addr);
-	pg=pfn_to_page(sg_dma_address(to_addr[oldpg].sg) >> PAGE_SHIFT);
-	spin_lock_irqsave(&spinlock,flags);
-	basep = kmap_atomic(pg, KM_BOUNCE_READ)+to_addr[oldpg].sg->offset;
-#endif
@@ -308,10 +250,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-			pgpos=get_addr_pos(pos,pages,to_addr);
-			if (pgpos!=oldpg) {
-				pg=pfn_to_page(sg_dma_address(to_addr[pgpos].sg) >> PAGE_SHIFT);
-				kunmap_atomic(basep, KM_BOUNCE_READ);
-				basep= kmap_atomic(pg, KM_BOUNCE_READ)+to_addr[pgpos].sg->offset;
-				oldpg=pgpos;
-			}
-			p=basep+pos-to_addr[pgpos].pos;
-#else
@@ -319 +251,0 @@
-#endif
@@ -364,15 +295,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-					pgpos=get_addr_pos(pos,pages,to_addr);
-					if (pgpos!=oldpg) {
-						pg=pfn_to_page(sg_dma_address(
-								to_addr[pgpos].sg)
-								>> PAGE_SHIFT);
-						kunmap_atomic(basep,
-								KM_BOUNCE_READ);
-						basep= kmap_atomic(pg,
-							KM_BOUNCE_READ)+
-							to_addr[pgpos].sg->offset;
-						oldpg=pgpos;
-					}
-					p=basep+pos-to_addr[pgpos].pos;
-#else
@@ -380 +296,0 @@
-#endif
@@ -405,4 +320,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-	kunmap_atomic(basep, KM_BOUNCE_READ);
-	spin_unlock_irqrestore(&spinlock,flags);
-#else
@@ -410 +321,0 @@
-#endif
@@ -418,4 +328,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-	struct sg_to_addr *to_addr=buf->to_addr;
-	struct videobuf_buffer *vb=&buf->vb;
-#else
@@ -423 +329,0 @@
-#endif
@@ -425,10 +330,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-	/* Test if DMA mapping is ready */
-	if (!sg_dma_address(&vb->dma.sglist[0]))
-		return;
-
-	prep_to_addr(to_addr,vb);
-
-	/* Check if there is enough memory */
-	BUG_ON(buf->vb.dma.nr_pages << PAGE_SHIFT < (buf->vb.width*buf->vb.height)*2);
-#else
@@ -441 +336,0 @@
-#endif
@@ -444,3 +338,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-		gen_line(to_addr,pos,vb->dma.nr_pages,wmax,hmax,h,dev->timestr);
-#else
@@ -455 +346,0 @@
-#endif
@@ -575,0 +467 @@
+	set_freezable();
@@ -720,5 +611,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-	/*FIXME: Maybe a spinlock is required here */
-	kfree(buf->to_addr);
-	buf->to_addr=NULL;
-#endif
@@ -770,6 +656,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-	if (NULL == (buf->to_addr = kmalloc(sizeof(*buf->to_addr) * vb->dma.nr_pages,GFP_KERNEL))) {
-		rc=-ENOMEM;
-		goto fail;
-	}
-#endif
@@ -840,34 +720,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-static int vivi_map_sg(void *dev, struct scatterlist *sg, int nents,
-		       int direction)
-{
-	int i;
-
-	dprintk(1,"%s, number of pages=%d\n",__FUNCTION__,nents);
-	BUG_ON(direction == DMA_NONE);
-
-	for (i = 0; i < nents; i++ ) {
-		BUG_ON(!sg[i].page);
-
-		sg_dma_address(&sg[i]) = page_to_phys(sg[i].page) + sg[i].offset;
-	}
-
-	return nents;
-}
-
-static int vivi_unmap_sg(void *dev,struct scatterlist *sglist,int nr_pages,
-			 int direction)
-{
-	dprintk(1,"%s\n",__FUNCTION__);
-	return 0;
-}
-
-static int vivi_dma_sync_sg(void *dev,struct scatterlist *sglist, int nr_pages,
-			    int direction)
-{
-//	dprintk(1,"%s\n",__FUNCTION__);
-
-//	flush_write_buffers();
-	return 0;
-}
-#endif
@@ -895 +742 @@
-	down(&dev->lock);
+	mutex_lock(&dev->lock);
@@ -898 +745 @@
-		up(&dev->lock);
+		mutex_unlock(&dev->lock);
@@ -904 +751 @@
-	up(&dev->lock);
+	mutex_unlock(&dev->lock);
@@ -915 +762 @@
-	down(&dev->lock);
+	mutex_lock(&dev->lock);
@@ -918 +765 @@
-	up(&dev->lock);
+	mutex_lock(&dev->lock);
@@ -1262,7 +1108,0 @@
-#ifdef CONFIG_VIVI_SCATTER
-	videobuf_queue_init(&fh->vb_vidq,VIDEOBUF_DMA_SCATTER, &vivi_video_qops,
-			NULL, NULL,
-			fh->type,
-			V4L2_FIELD_INTERLACED,
-			sizeof(struct vivi_buffer),fh);
-#else
@@ -1274 +1113,0 @@
-#endif
@@ -1425 +1264 @@
-	init_MUTEX(&dev->lock);
+	mutex_init(&dev->lock);
--- ./projects/linux/linux-2.6.23/drivers/media/video/vivi.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/media/video/vivi.c	2008-01-24 23:58:37.000000000 +0100
@@ -36 +36 @@
-#include <media/video-buf.h>
+#include <media/videobuf-vmalloc.h>
@@ -148 +147,0 @@
-
@@ -174 +172,0 @@
-	unsigned int               resources;
@@ -233 +230,0 @@
-
@@ -235 +232 @@
-		     int hmax, int line, char *timestr)
+		     int hmax, int line, int count, char *timestr)
@@ -246,3 +243,4 @@
-		r=bars[w*7/wmax][0];
-		g=bars[w*7/wmax][1];
-		b=bars[w*7/wmax][2];
+		int colorpos=((w+count)*8/(wmax+1)) % 8;
+		r=bars[colorpos][0];
+		g=bars[colorpos][1];
+		b=bars[colorpos][2];
@@ -329,7 +327,4 @@
-	char *tmpbuf;
-
-	if (buf->vb.dma.varea) {
-		tmpbuf=kmalloc (wmax*2, GFP_KERNEL);
-	} else {
-		tmpbuf=buf->vb.dma.vmalloc;
-	}
+	char *tmpbuf = kmalloc(wmax*2,GFP_KERNEL);
+	void *vbuf=videobuf_to_vmalloc (&buf->vb);
+	/* FIXME: move to dev struct */
+	static int mv_count=0;
@@ -336,0 +332,2 @@
+	if (!tmpbuf)
+		return;
@@ -339,8 +336,5 @@
-		if (buf->vb.dma.varea) {
-			gen_line(tmpbuf,0,wmax,hmax,h,dev->timestr);
-			/* FIXME: replacing to __copy_to_user */
-			if (copy_to_user(buf->vb.dma.varea+pos,tmpbuf,wmax*2)!=0)
-				dprintk(2,"vivifill copy_to_user failed.\n");
-		} else {
-			gen_line(tmpbuf,pos,wmax,hmax,h,dev->timestr);
-		}
+		gen_line(tmpbuf,0,wmax,hmax,h,mv_count,
+			 dev->timestr);
+		/* FIXME: replacing to __copy_to_user */
+		if (copy_to_user(vbuf+pos,tmpbuf,wmax*2)!=0)
+			dprintk(2,"vivifill copy_to_user failed.\n");
@@ -349,0 +344,4 @@
+	mv_count++;
+
+	kfree(tmpbuf);
+
@@ -372 +370 @@
-			(unsigned long)buf->vb.dma.varea,pos);
+			(unsigned long)tmpbuf,pos);
@@ -512 +509,0 @@
-	struct list_head *item;
@@ -526,3 +523 @@
-		list_for_each(item,&dma_q->active) {
-			buf = list_entry(item, struct vivi_buffer, vb.queue);
-
+		list_for_each_entry_safe(buf, prev, &dma_q->active, vb.queue) {
@@ -599,0 +595 @@
+
@@ -601,0 +598,3 @@
+
+	dprintk(1,"%s, count=%d, size=%d\n",__FUNCTION__,*count, *size);
+
@@ -612 +610,0 @@
-
@@ -614,2 +612 @@
-	videobuf_dma_unmap(vq, &buf->vb.dma);
-	videobuf_dma_free(&buf->vb.dma);
+	videobuf_vmalloc_free(&buf->vb);
@@ -629 +626 @@
-//	dprintk(1,"%s, field=%d\n",__FUNCTION__,field);
+	dprintk(1,"%s, field=%d\n",__FUNCTION__,field);
@@ -721 +717,0 @@
-
@@ -727,5 +722,0 @@
-
-	/* Non-pci handling routines */
-//	.vb_map_sg      = vivi_map_sg,
-//	.vb_dma_sync_sg = vivi_dma_sync_sg,
-//	.vb_unmap_sg    = vivi_unmap_sg,
@@ -735,34 +725,0 @@
-	IOCTL handling
-   ------------------------------------------------------------------*/
-
-
-static int res_get(struct vivi_dev *dev, struct vivi_fh *fh)
-{
-	/* is it free? */
-	mutex_lock(&dev->lock);
-	if (dev->resources) {
-		/* no, someone else uses it */
-		mutex_unlock(&dev->lock);
-		return 0;
-	}
-	/* it's free, grab it */
-	dev->resources =1;
-	dprintk(1,"res: get\n");
-	mutex_unlock(&dev->lock);
-	return 1;
-}
-
-static int res_locked(struct vivi_dev *dev)
-{
-	return (dev->resources);
-}
-
-static void res_free(struct vivi_dev *dev, struct vivi_fh *fh)
-{
-	mutex_lock(&dev->lock);
-	dev->resources = 0;
-	dprintk(1,"res: put\n");
-	mutex_lock(&dev->lock);
-}
-
-/* ------------------------------------------------------------------
@@ -828,2 +785 @@
-//		field=V4L2_FIELD_INTERLACED;
-		field=V4L2_FIELD_SEQ_TB;
+		field=V4L2_FIELD_INTERLACED;
@@ -907,11 +862,0 @@
-	struct videobuf_queue *q=&fh->vb_vidq;
-	struct v4l2_requestbuffers req;
-	unsigned int i;
-	int ret;
-
-	req.type   = q->type;
-	req.count  = 8;
-	req.memory = V4L2_MEMORY_MMAP;
-	ret = videobuf_reqbufs(q,&req);
-	if (ret < 0)
-		return (ret);
@@ -919,7 +864 @@
-	mbuf->frames = req.count;
-	mbuf->size   = 0;
-	for (i = 0; i < mbuf->frames; i++) {
-		mbuf->offsets[i]  = q->bufs[i]->boff;
-		mbuf->size       += q->bufs[i]->bsize;
-	}
-	return (0);
+	return videobuf_cgmbuf (&fh->vb_vidq, mbuf, 8);
@@ -932 +870,0 @@
-	struct vivi_dev *dev    = fh->dev;
@@ -939,3 +877 @@
-	if (!res_get(dev,fh))
-		return -EBUSY;
-	return (videobuf_streamon(&fh->vb_vidq));
+	return videobuf_streamon(&fh->vb_vidq);
@@ -947 +882,0 @@
-	struct vivi_dev *dev    = fh->dev;
@@ -954,4 +889 @@
-	videobuf_streamoff(&fh->vb_vidq);
-	res_free(dev,fh);
-
-	return (0);
+	return videobuf_streamoff(&fh->vb_vidq);
@@ -1050 +982 @@
-	struct vivi_dev *h,*dev = NULL;
+	struct vivi_dev *dev;
@@ -1052,2 +983,0 @@
-	struct list_head *list;
-	enum v4l2_buf_type type = 0;
@@ -1058,9 +988,5 @@
-	list_for_each(list,&vivi_devlist) {
-		h = list_entry(list, struct vivi_dev, vivi_devlist);
-		if (h->vfd.minor == minor) {
-			dev  = h;
-			type = V4L2_BUF_TYPE_VIDEO_CAPTURE;
-		}
-	}
-	if (NULL == dev)
-		return -ENODEV;
+	list_for_each_entry(dev, &vivi_devlist, vivi_devlist)
+		if (dev->vfd.minor == minor)
+			goto found;
+	return -ENODEV;
+found:
@@ -1073,2 +999,2 @@
-	dprintk(1,"open minor=%d type=%s users=%d\n",
-				minor,v4l2_type_names[type],dev->users);
+	dprintk(1, "open minor=%d type=%s users=%d\n", minor,
+		v4l2_type_names[V4L2_BUF_TYPE_VIDEO_CAPTURE], dev->users);
@@ -1109 +1035 @@
-	videobuf_queue_init(&fh->vb_vidq, &vivi_video_qops,
+	videobuf_queue_vmalloc_init(&fh->vb_vidq, &vivi_video_qops,
@@ -1124,3 +1050 @@
-		if (res_locked(fh->dev))
-			return -EBUSY;
-		return videobuf_read_one(&fh->vb_vidq, data, count, ppos,
+		return videobuf_read_stream(&fh->vb_vidq, data, count, ppos, 0,
@@ -1136 +1060 @@
-	struct vivi_buffer    *buf;
+	struct videobuf_queue *q = &fh->vb_vidq;
@@ -1143,18 +1067 @@
-	if (res_get(fh->dev,fh)) {
-		dprintk(1,"poll: mmap interface\n");
-		/* streaming capture */
-		if (list_empty(&fh->vb_vidq.stream))
-			return POLLERR;
-		buf = list_entry(fh->vb_vidq.stream.next,struct vivi_buffer,vb.stream);
-	} else {
-		dprintk(1,"poll: read() interface\n");
-		/* read() capture */
-		buf = (struct vivi_buffer*)fh->vb_vidq.read_buf;
-		if (NULL == buf)
-			return POLLERR;
-	}
-	poll_wait(file, &buf->vb.done, wait);
-	if (buf->vb.state == STATE_DONE ||
-	    buf->vb.state == STATE_ERROR)
-		return POLLIN|POLLRDNORM;
-	return 0;
+	return videobuf_poll_stream(file, q, wait);
@@ -1171,0 +1079 @@
+	videobuf_stop(&fh->vb_vidq);
@@ -1208 +1116 @@
-	.mmap		= vivi_mmap,
+	.mmap           = vivi_mmap,
@@ -1215 +1122,0 @@
-	.hardware	= 0,
--- ./projects/linux/linux-2.6.24/drivers/media/video/vivi.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/media/video/vivi.c	2008-04-17 04:49:44.000000000 +0200
@@ -47,4 +46,0 @@
-/* These timers are for 1 fps - used only for testing */
-//#define WAKE_DENOMINATOR 30 /* hack for testing purposes */
-//#define BUFFER_TIMEOUT     msecs_to_jiffies(5000)  /* 5 seconds */
-
@@ -56 +52,2 @@
-#define VIVI_VERSION KERNEL_VERSION(VIVI_MAJOR_VERSION, VIVI_MINOR_VERSION, VIVI_RELEASE)
+#define VIVI_VERSION \
+	KERNEL_VERSION(VIVI_MAJOR_VERSION, VIVI_MINOR_VERSION, VIVI_RELEASE)
@@ -60 +56,0 @@
-static struct video_device vivi;	/* Video device */
@@ -61,0 +58 @@
+static int n_devs = 1;			/* Number of virtual devices */
@@ -74 +71 @@
-	},{
+	}, {
@@ -115 +112 @@
-#define dprintk(level,fmt, arg...)					\
+#define dprintk(dev, level, fmt, arg...)				\
@@ -117 +114 @@
-		if (vivi.debug >= (level))				\
+		if (dev->vfd->debug >= (level))				\
@@ -168,0 +166 @@
+	spinlock_t                 slock;
@@ -173 +171 @@
-	struct video_device        vfd;
+	struct video_device        *vfd;
@@ -178 +176,2 @@
-	int                        h,m,s,us,jiffies;
+	int                        h, m, s, ms;
+	unsigned long              jiffies;
@@ -179,0 +179,2 @@
+
+	int			   mv_count;	/* Controls bars movement */
@@ -187 +188 @@
-	unsigned int               width,height;
+	unsigned int               width, height;
@@ -206 +207,2 @@
-	BLUE
+	BLUE,
+	BLACK,
@@ -211,8 +213,8 @@
-	{204,204,204},	/* white */
-	{208,208,  0},  /* ambar */
-	{  0,206,206},  /* cyan */
-	{  0,239,  0},  /* green */
-	{239,  0,239},  /* magenta */
-	{205,  0,  0},  /* red */
-	{  0,  0,255},  /* blue */
-	{  0,  0,  0}
+	{204, 204, 204},  /* white */
+	{208, 208,   0},  /* ambar */
+	{  0, 206, 206},  /* cyan */
+	{  0, 239,   0},  /* green */
+	{239,   0, 239},  /* magenta */
+	{205,   0,   0},  /* red */
+	{  0,   0, 255},  /* blue */
+	{  0,   0,   0},  /* black */
@@ -221 +223,2 @@
-#define TO_Y(r,g,b) (((16829*r +33039*g +6416*b  + 32768)>>16)+16)
+#define TO_Y(r, g, b) \
+	(((16829 * r + 33039 * g + 6416 * b  + 32768) >> 16) + 16)
@@ -223 +226,2 @@
-#define TO_V(r,g,b) (((28784*r -24103*g -4681*b  + 32768)>>16)+128)
+#define TO_V(r, g, b) \
+	(((28784 * r - 24103 * g - 4681 * b  + 32768) >> 16) + 128)
@@ -225 +229,2 @@
-#define TO_U(r,g,b) (((-9714*r -19070*g +28784*b + 32768)>>16)+128)
+#define TO_U(r, g, b) \
+	(((-9714 * r - 19070 * g + 28784 * b + 32768) >> 16) + 128)
@@ -231,2 +236,2 @@
-static void gen_line(char *basep,int inipos,int wmax,
-		     int hmax, int line, int count, char *timestr)
+static void gen_line(char *basep, int inipos, int wmax,
+		int hmax, int line, int count, char *timestr)
@@ -234,3 +239,4 @@
-	int  w,i,j,pos=inipos,y;
-	char *p,*s;
-	u8   chr,r,g,b,color;
+	int  w, i, j, y;
+	int pos = inipos;
+	char *p, *s;
+	u8   chr, r, g, b, color;
@@ -239 +245 @@
-	wmax/=2;
+	wmax /= 2;
@@ -242,5 +248,5 @@
-	for (w=0;w<wmax;w++) {
-		int colorpos=((w+count)*8/(wmax+1)) % 8;
-		r=bars[colorpos][0];
-		g=bars[colorpos][1];
-		b=bars[colorpos][2];
+	for (w = 0; w < wmax; w++) {
+		int colorpos = ((w + count) * 8/(wmax + 1)) % 8;
+		r = bars[colorpos][0];
+		g = bars[colorpos][1];
+		b = bars[colorpos][2];
@@ -248,2 +254,2 @@
-		for (color=0;color<4;color++) {
-			p=basep+pos;
+		for (color = 0; color < 4; color++) {
+			p = basep + pos;
@@ -252,10 +258,10 @@
-				case 0:
-				case 2:
-					*p=TO_Y(r,g,b);		/* Luminance */
-					break;
-				case 1:
-					*p=TO_U(r,g,b);		/* Cb */
-					break;
-				case 3:
-					*p=TO_V(r,g,b);		/* Cr */
-					break;
+			case 0:
+			case 2:
+				*p = TO_Y(r, g, b);	/* Luma */
+				break;
+			case 1:
+				*p = TO_U(r, g, b);	/* Cb */
+				break;
+			case 3:
+				*p = TO_V(r, g, b);	/* Cr */
+				break;
@@ -268 +274 @@
-	if (TSTAMP_MAX_Y>=hmax)
+	if (TSTAMP_MAX_Y >= hmax)
@@ -270 +276 @@
-	if (TSTAMP_MIN_X+strlen(timestr)>=wmax)
+	if (TSTAMP_MIN_X + strlen(timestr) >= wmax)
@@ -274,16 +280,15 @@
-	if (line>=TSTAMP_MIN_Y && line<=TSTAMP_MAX_Y) {
-		j=TSTAMP_MIN_X;
-		for (s=timestr;*s;s++) {
-			chr=rom8x16_bits[(*s-0x30)*16+line-TSTAMP_MIN_Y];
-			for (i=0;i<7;i++) {
-				if (chr&1<<(7-i)) { /* Font color*/
-					r=bars[BLUE][0];
-					g=bars[BLUE][1];
-					b=bars[BLUE][2];
-					r=g=b=0;
-					g=198;
-				} else { /* Background color */
-					r=bars[WHITE][0];
-					g=bars[WHITE][1];
-					b=bars[WHITE][2];
-					r=g=b=0;
+	if (line >= TSTAMP_MIN_Y && line <= TSTAMP_MAX_Y) {
+		j = TSTAMP_MIN_X;
+		for (s = timestr; *s; s++) {
+			chr = rom8x16_bits[(*s-0x30)*16+line-TSTAMP_MIN_Y];
+			for (i = 0; i < 7; i++) {
+				if (chr & 1 << (7 - i)) {
+					/* Font color*/
+					r = 0;
+					g = 198;
+					b = 0;
+				} else {
+					/* Background color */
+					r = bars[BLACK][0];
+					g = bars[BLACK][1];
+					b = bars[BLACK][2];
@@ -292,3 +297,3 @@
-				pos=inipos+j*2;
-				for (color=0;color<4;color++) {
-					p=basep+pos;
+				pos = inipos + j * 2;
+				for (color = 0; color < 4; color++) {
+					p = basep + pos;
@@ -296 +301 @@
-					y=TO_Y(r,g,b);
+					y = TO_Y(r, g, b);
@@ -299,10 +304,10 @@
-						case 0:
-						case 2:
-							*p=TO_Y(r,g,b);		/* Luminance */
-							break;
-						case 1:
-							*p=TO_U(r,g,b);		/* Cb */
-							break;
-						case 3:
-							*p=TO_V(r,g,b);		/* Cr */
-							break;
+					case 0:
+					case 2:
+						*p = TO_Y(r, g, b); /* Luma */
+						break;
+					case 1:
+						*p = TO_U(r, g, b); /* Cb */
+						break;
+					case 3:
+						*p = TO_V(r, g, b); /* Cr */
+						break;
@@ -317 +321,0 @@
-
@@ -321 +325 @@
-static void vivi_fillbuff(struct vivi_dev *dev,struct vivi_buffer *buf)
+static void vivi_fillbuff(struct vivi_dev *dev, struct vivi_buffer *buf)
@@ -323 +327 @@
-	int h,pos=0;
+	int h , pos = 0;
@@ -327,4 +331,2 @@
-	char *tmpbuf = kmalloc(wmax*2,GFP_KERNEL);
-	void *vbuf=videobuf_to_vmalloc (&buf->vb);
-	/* FIXME: move to dev struct */
-	static int mv_count=0;
+	char *tmpbuf = kmalloc(wmax * 2, GFP_KERNEL);
+	void *vbuf = videobuf_to_vmalloc(&buf->vb);
@@ -335,2 +337,2 @@
-	for (h=0;h<hmax;h++) {
-		gen_line(tmpbuf,0,wmax,hmax,h,mv_count,
+	for (h = 0; h < hmax; h++) {
+		gen_line(tmpbuf, 0, wmax, hmax, h, dev->mv_count,
@@ -339,2 +341,2 @@
-		if (copy_to_user(vbuf+pos,tmpbuf,wmax*2)!=0)
-			dprintk(2,"vivifill copy_to_user failed.\n");
+		if (copy_to_user(vbuf + pos, tmpbuf, wmax * 2) != 0)
+			dprintk(dev, 2, "vivifill copy_to_user failed.\n");
@@ -344 +346 @@
-	mv_count++;
+	dev->mv_count++;
@@ -350,4 +352,4 @@
-	dev->us+=jiffies_to_usecs(jiffies-dev->jiffies);
-	dev->jiffies=jiffies;
-	if (dev->us>=1000000) {
-		dev->us-=1000000;
+	dev->ms += jiffies_to_msecs(jiffies-dev->jiffies);
+	dev->jiffies = jiffies;
+	if (dev->ms >= 1000) {
+		dev->ms -= 1000;
@@ -355,2 +357,2 @@
-		if (dev->s>=60) {
-			dev->s-=60;
+		if (dev->s >= 60) {
+			dev->s -= 60;
@@ -358,2 +360,2 @@
-			if (dev->m>60) {
-				dev->m-=60;
+			if (dev->m > 60) {
+				dev->m -= 60;
@@ -361,2 +363,2 @@
-				if (dev->h>24)
-					dev->h-=24;
+				if (dev->h > 24)
+					dev->h -= 24;
@@ -366,2 +368,2 @@
-	sprintf(dev->timestr,"%02d:%02d:%02d:%03d",
-			dev->h,dev->m,dev->s,(dev->us+500)/1000);
+	sprintf(dev->timestr, "%02d:%02d:%02d:%03d",
+			dev->h, dev->m, dev->s, dev->ms);
@@ -369,2 +371,2 @@
-	dprintk(2,"vivifill at %s: Buffer 0x%08lx size= %d\n",dev->timestr,
-			(unsigned long)tmpbuf,pos);
+	dprintk(dev, 2, "vivifill at %s: Buffer 0x%08lx size= %d\n",
+			dev->timestr, (unsigned long)tmpbuf, pos);
@@ -373 +375 @@
-	buf->vb.state = STATE_DONE;
+	buf->vb.state = VIDEOBUF_DONE;
@@ -387 +389 @@
-	struct vivi_dev *dev= container_of(dma_q,struct vivi_dev,vidq);
+	struct vivi_dev *dev = container_of(dma_q, struct vivi_dev, vidq);
@@ -390,0 +393 @@
+	spin_lock(&dev->slock);
@@ -394 +397 @@
-			dprintk(1,"No active queue to serve\n");
+			dprintk(dev, 1, "No active queue to serve\n");
@@ -403,0 +407 @@
+			spin_unlock(&dev->slock);
@@ -408 +412 @@
-		dprintk(2,"[%p/%d] wakeup\n",buf,buf->vb.i);
+		dprintk(dev, 2, "[%p/%d] wakeup\n", buf, buf->vb. i);
@@ -411 +415 @@
-		vivi_fillbuff(dev,buf);
+		vivi_fillbuff(dev, buf);
@@ -416 +420 @@
-			mod_timer(&dma_q->timeout, jiffies+BUFFER_TIMEOUT);
+			mod_timer(&dma_q->timeout, jiffies + BUFFER_TIMEOUT);
@@ -420 +424,3 @@
-		dprintk(1,"%s: %d buffers handled (should be 1)\n",__FUNCTION__,bc);
+		dprintk(dev, 1, "%s: %d buffers handled (should be 1)\n",
+			__FUNCTION__, bc);
+	spin_unlock(&dev->slock);
@@ -422,0 +429,3 @@
+#define frames_to_ms(frames)					\
+	((frames * WAKE_NUMERATOR * 1000) / WAKE_DENOMINATOR)
+
@@ -425 +434,2 @@
-	int timeout;
+	struct vivi_dev *dev = container_of(dma_q, struct vivi_dev, vidq);
+	int timeout, running_time;
@@ -428 +438,2 @@
-	dprintk(1,"%s dma_q=0x%08lx\n",__FUNCTION__,(unsigned long)dma_q);
+	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __FUNCTION__,
+		(unsigned long)dma_q);
@@ -431,2 +442,2 @@
-	if (!kthread_should_stop()) {
-		dma_q->frame++;
+	if (kthread_should_stop())
+		goto stop_task;
@@ -434,2 +445,2 @@
-		/* Calculate time to wake up */
-		timeout=dma_q->ini_jiffies+msecs_to_jiffies((dma_q->frame*WAKE_NUMERATOR*1000)/WAKE_DENOMINATOR)-jiffies;
+	running_time = jiffies - dma_q->ini_jiffies;
+	dma_q->frame++;
@@ -437,3 +448,2 @@
-		if (timeout <= 0) {
-			int old=dma_q->frame;
-			dma_q->frame=(jiffies_to_msecs(jiffies-dma_q->ini_jiffies)*WAKE_DENOMINATOR)/(WAKE_NUMERATOR*1000)+1;
+	/* Calculate time to wake up */
+	timeout = msecs_to_jiffies(frames_to_ms(dma_q->frame)) - running_time;
@@ -441 +451,3 @@
-			timeout=dma_q->ini_jiffies+msecs_to_jiffies((dma_q->frame*WAKE_NUMERATOR*1000)/WAKE_DENOMINATOR)-jiffies;
+	if (timeout > msecs_to_jiffies(frames_to_ms(2)) || timeout <= 0) {
+		int old = dma_q->frame;
+		int nframes;
@@ -443,5 +455,2 @@
-			dprintk(1,"underrun, losed %d frames. "
-				  "Now, frame is %d. Waking on %d jiffies\n",
-					dma_q->frame-old,dma_q->frame,timeout);
-		} else
-			dprintk(1,"will sleep for %i jiffies\n",timeout);
+		dma_q->frame = (jiffies_to_msecs(running_time) /
+			       frames_to_ms(1)) + 1;
@@ -449 +458,2 @@
-		vivi_thread_tick(dma_q);
+		timeout = msecs_to_jiffies(frames_to_ms(dma_q->frame))
+			  - running_time;
@@ -451,2 +461,13 @@
-		schedule_timeout_interruptible (timeout);
-	}
+		if (unlikely (timeout <= 0))
+			timeout = 1;
+
+		nframes = (dma_q->frame > old)?
+				  dma_q->frame - old : old - dma_q->frame;
+
+		dprintk(dev, 1, "%ld: %s %d frames. "
+			"Current frame is %d. Will sleep for %d jiffies\n",
+			jiffies,
+			(dma_q->frame > old)? "Underrun, losed" : "Overrun of",
+			nframes, dma_q->frame, timeout);
+	} else
+		dprintk(dev, 1, "will sleep for %d jiffies\n", timeout);
@@ -453,0 +475,5 @@
+	vivi_thread_tick(dma_q);
+
+	schedule_timeout_interruptible(timeout);
+
+stop_task:
@@ -460 +486,2 @@
-	struct vivi_dmaqueue  *dma_q=data;
+	struct vivi_dmaqueue  *dma_q = data;
+	struct vivi_dev *dev = container_of(dma_q, struct vivi_dev, vidq);
@@ -462 +489 @@
-	dprintk(1,"thread started\n");
+	dprintk(dev, 1, "thread started\n");
@@ -473 +500 @@
-	dprintk(1, "thread: exit\n");
+	dprintk(dev, 1, "thread: exit\n");
@@ -479,2 +506 @@
-	dma_q->frame=0;
-	dma_q->ini_jiffies=jiffies;
+	struct vivi_dev *dev = container_of(dma_q, struct vivi_dev, vidq);
@@ -482 +508,4 @@
-	dprintk(1,"%s\n",__FUNCTION__);
+	dma_q->frame = 0;
+	dma_q->ini_jiffies = jiffies;
+
+	dprintk(dev, 1, "%s\n", __FUNCTION__);
@@ -493 +522 @@
-	dprintk(1,"returning from %s\n",__FUNCTION__);
+	dprintk(dev, 1, "returning from %s\n", __FUNCTION__);
@@ -499 +528,3 @@
-	dprintk(1,"%s\n",__FUNCTION__);
+	struct vivi_dev *dev = container_of(dma_q, struct vivi_dev, vidq);
+
+	dprintk(dev, 1, "%s\n", __FUNCTION__);
@@ -503 +534 @@
-		dma_q->kthread=NULL;
+		dma_q->kthread = NULL;
@@ -508,0 +540 @@
+	struct vivi_dev *dev = container_of(dma_q, struct vivi_dev, vidq);
@@ -511 +543,2 @@
-	dprintk(1,"%s dma_q=0x%08lx\n",__FUNCTION__,(unsigned long)dma_q);
+	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __FUNCTION__,
+		(unsigned long)dma_q);
@@ -514,2 +547,3 @@
-		buf = list_entry(dma_q->active.next, struct vivi_buffer, vb.queue);
-		dprintk(2,"restart_queue [%p/%d]: restart dma\n",
+		buf = list_entry(dma_q->active.next,
+				 struct vivi_buffer, vb.queue);
+		dprintk(dev, 2, "restart_queue [%p/%d]: restart dma\n",
@@ -518 +552 @@
-		dprintk(1,"Restarting video dma\n");
+		dprintk(dev, 1, "Restarting video dma\n");
@@ -520 +553,0 @@
-//		vivi_start_thread(dma_q);
@@ -525 +558 @@
-			buf->vb.state = STATE_ERROR;
+			buf->vb.state = VIDEOBUF_ERROR;
@@ -537 +570,2 @@
-		buf = list_entry(dma_q->queued.next, struct vivi_buffer, vb.queue);
+		buf = list_entry(dma_q->queued.next,
+				 struct vivi_buffer, vb.queue);
@@ -540 +574 @@
-			list_add_tail(&buf->vb.queue,&dma_q->active);
+			list_add_tail(&buf->vb.queue, &dma_q->active);
@@ -542 +576 @@
-			dprintk(1,"Restarting video dma\n");
+			dprintk(dev, 1, "Restarting video dma\n");
@@ -546 +580 @@
-			buf->vb.state = STATE_ACTIVE;
+			buf->vb.state = VIDEOBUF_ACTIVE;
@@ -548,2 +582,3 @@
-			dprintk(2,"[%p/%d] restart_queue - first active\n",
-				buf,buf->vb.i);
+			dprintk(dev, 2,
+				"[%p/%d] restart_queue - first active\n",
+				buf, buf->vb.i);
@@ -555,4 +590,5 @@
-			list_add_tail(&buf->vb.queue,&dma_q->active);
-			buf->vb.state = STATE_ACTIVE;
-			dprintk(2,"[%p/%d] restart_queue - move to active\n",
-				buf,buf->vb.i);
+			list_add_tail(&buf->vb.queue, &dma_q->active);
+			buf->vb.state = VIDEOBUF_ACTIVE;
+			dprintk(dev, 2,
+				"[%p/%d] restart_queue - move to active\n",
+				buf, buf->vb.i);
@@ -568 +604 @@
-	struct vivi_dev      *dev  = (struct vivi_dev*)data;
+	struct vivi_dev      *dev  = (struct vivi_dev *)data;
@@ -571,0 +608,2 @@
+	spin_lock(&dev->slock);
+
@@ -573 +611,2 @@
-		buf = list_entry(vidq->active.next, struct vivi_buffer, vb.queue);
+		buf = list_entry(vidq->active.next,
+				 struct vivi_buffer, vb.queue);
@@ -575 +614 @@
-		buf->vb.state = STATE_ERROR;
+		buf->vb.state = VIDEOBUF_ERROR;
@@ -577 +616 @@
-		printk("vivi/0: [%p/%d] timeout\n", buf, buf->vb.i);
+		printk(KERN_INFO "vivi/0: [%p/%d] timeout\n", buf, buf->vb.i);
@@ -579 +617,0 @@
-
@@ -580,0 +619,2 @@
+
+	spin_unlock(&dev->slock);
@@ -589 +629,2 @@
-	struct vivi_fh *fh = vq->priv_data;
+	struct vivi_fh  *fh = vq->priv_data;
+	struct vivi_dev *dev  = fh->dev;
@@ -599 +640,2 @@
-	dprintk(1,"%s, count=%d, size=%d\n",__FUNCTION__,*count, *size);
+	dprintk(dev, 1, "%s, count=%d, size=%d\n", __FUNCTION__,
+		*count, *size);
@@ -606 +648,4 @@
-	dprintk(1,"%s\n",__FUNCTION__);
+	struct vivi_fh  *fh = vq->priv_data;
+	struct vivi_dev *dev  = fh->dev;
+
+	dprintk(dev, 1, "%s\n", __FUNCTION__);
@@ -611 +656 @@
-	videobuf_waiton(&buf->vb,0,0);
+	videobuf_waiton(&buf->vb, 0, 0);
@@ -613 +658 @@
-	buf->vb.state = STATE_NEEDS_INIT;
+	buf->vb.state = VIDEOBUF_NEEDS_INIT;
@@ -623 +668,2 @@
-	struct vivi_buffer *buf = container_of(vb,struct vivi_buffer,vb);
+	struct vivi_dev    *dev = fh->dev;
+	struct vivi_buffer *buf = container_of(vb, struct vivi_buffer, vb);
@@ -626 +672 @@
-	dprintk(1,"%s, field=%d\n",__FUNCTION__,field);
+	dprintk(dev, 1, "%s, field=%d\n", __FUNCTION__, field);
@@ -647,2 +693,3 @@
-	if (STATE_NEEDS_INIT == buf->vb.state) {
-		if (0 != (rc = videobuf_iolock(vq,&buf->vb,NULL)))
+	if (VIDEOBUF_NEEDS_INIT == buf->vb.state) {
+		rc = videobuf_iolock(vq, &buf->vb, NULL);
+		if (rc < 0)
@@ -652 +699 @@
-	buf->vb.state = STATE_PREPARED;
+	buf->vb.state = VIDEOBUF_PREPARED;
@@ -657 +704 @@
-	free_buffer(vq,buf);
+	free_buffer(vq, buf);
@@ -664,4 +711,4 @@
-	struct vivi_buffer    *buf     = container_of(vb,struct vivi_buffer,vb);
-	struct vivi_fh        *fh      = vq->priv_data;
-	struct vivi_dev       *dev     = fh->dev;
-	struct vivi_dmaqueue  *vidq    = &dev->vidq;
+	struct vivi_buffer    *buf  = container_of(vb, struct vivi_buffer, vb);
+	struct vivi_fh        *fh   = vq->priv_data;
+	struct vivi_dev       *dev  = fh->dev;
+	struct vivi_dmaqueue  *vidq = &dev->vidq;
@@ -671,4 +718,5 @@
-		dprintk(1,"adding vb queue=0x%08lx\n",(unsigned long)&buf->vb.queue);
-		list_add_tail(&buf->vb.queue,&vidq->queued);
-		buf->vb.state = STATE_QUEUED;
-		dprintk(2,"[%p/%d] buffer_queue - append to queued\n",
+		dprintk(dev, 1, "adding vb queue=0x%08lx\n",
+			(unsigned long)&buf->vb.queue);
+		list_add_tail(&buf->vb.queue, &vidq->queued);
+		buf->vb.state = VIDEOBUF_QUEUED;
+		dprintk(dev, 2, "[%p/%d] buffer_queue - append to queued\n",
@@ -677 +725 @@
-		list_add_tail(&buf->vb.queue,&vidq->active);
+		list_add_tail(&buf->vb.queue, &vidq->active);
@@ -679 +727 @@
-		buf->vb.state = STATE_ACTIVE;
+		buf->vb.state = VIDEOBUF_ACTIVE;
@@ -681 +729 @@
-		dprintk(2,"[%p/%d] buffer_queue - first active\n",
+		dprintk(dev, 2, "[%p/%d] buffer_queue - first active\n",
@@ -686 +734,2 @@
-		prev = list_entry(vidq->active.prev, struct vivi_buffer, vb.queue);
+		prev = list_entry(vidq->active.prev,
+				  struct vivi_buffer, vb.queue);
@@ -690,3 +739,4 @@
-			list_add_tail(&buf->vb.queue,&vidq->active);
-			buf->vb.state = STATE_ACTIVE;
-			dprintk(2,"[%p/%d] buffer_queue - append to active\n",
+			list_add_tail(&buf->vb.queue, &vidq->active);
+			buf->vb.state = VIDEOBUF_ACTIVE;
+			dprintk(dev, 2,
+				"[%p/%d] buffer_queue - append to active\n",
@@ -696,3 +746,4 @@
-			list_add_tail(&buf->vb.queue,&vidq->queued);
-			buf->vb.state = STATE_QUEUED;
-			dprintk(2,"[%p/%d] buffer_queue - first queued\n",
+			list_add_tail(&buf->vb.queue, &vidq->queued);
+			buf->vb.state = VIDEOBUF_QUEUED;
+			dprintk(dev, 2,
+				"[%p/%d] buffer_queue - first queued\n",
@@ -704 +755,2 @@
-static void buffer_release(struct videobuf_queue *vq, struct videobuf_buffer *vb)
+static void buffer_release(struct videobuf_queue *vq,
+			   struct videobuf_buffer *vb)
@@ -706 +758 @@
-	struct vivi_buffer   *buf  = container_of(vb,struct vivi_buffer,vb);
+	struct vivi_buffer   *buf  = container_of(vb, struct vivi_buffer, vb);
@@ -708 +760 @@
-	struct vivi_dev      *dev  = (struct vivi_dev*)fh->dev;
+	struct vivi_dev      *dev  = (struct vivi_dev *)fh->dev;
@@ -711 +763 @@
-	dprintk(1,"%s\n",__FUNCTION__);
+	dprintk(dev, 1, "%s\n", __FUNCTION__);
@@ -715 +767 @@
-	free_buffer(vq,buf);
+	free_buffer(vq, buf);
@@ -728 +780 @@
-static int vidioc_querycap (struct file *file, void  *priv,
+static int vidioc_querycap(struct file *file, void  *priv,
@@ -740 +792 @@
-static int vidioc_enum_fmt_cap (struct file *file, void  *priv,
+static int vidioc_enum_fmt_cap(struct file *file, void  *priv,
@@ -746 +798 @@
-	strlcpy(f->description,format.name,sizeof(f->description));
+	strlcpy(f->description, format.name, sizeof(f->description));
@@ -751 +803 @@
-static int vidioc_g_fmt_cap (struct file *file, void *priv,
+static int vidioc_g_fmt_cap(struct file *file, void *priv,
@@ -754 +806 @@
-	struct vivi_fh  *fh=priv;
+	struct vivi_fh *fh = priv;
@@ -768 +820 @@
-static int vidioc_try_fmt_cap (struct file *file, void *priv,
+static int vidioc_try_fmt_cap(struct file *file, void *priv,
@@ -770,0 +823,2 @@
+	struct vivi_fh  *fh  = priv;
+	struct vivi_dev *dev = fh->dev;
@@ -776,2 +830,3 @@
-		dprintk(1,"Fourcc format (0x%08x) invalid. Driver accepts "
-			"only 0x%08x\n",f->fmt.pix.pixelformat,format.fourcc);
+		dprintk(dev, 1, "Fourcc format (0x%08x) invalid. "
+			"Driver accepts only 0x%08x\n",
+			f->fmt.pix.pixelformat, format.fourcc);
@@ -780 +835 @@
-	fmt=&format;
+	fmt = &format;
@@ -785 +840 @@
-		field=V4L2_FIELD_INTERLACED;
+		field = V4L2_FIELD_INTERLACED;
@@ -787 +842 @@
-		dprintk(1,"Field type invalid.\n");
+		dprintk(dev, 1, "Field type invalid.\n");
@@ -813 +868 @@
-static int vidioc_s_fmt_cap (struct file *file, void *priv,
+static int vidioc_s_fmt_cap(struct file *file, void *priv,
@@ -816,2 +871,2 @@
-	struct vivi_fh  *fh=priv;
-	int ret = vidioc_try_fmt_cap(file,fh,f);
+	struct vivi_fh  *fh = priv;
+	int ret = vidioc_try_fmt_cap(file, fh, f);
@@ -830 +885,2 @@
-static int vidioc_reqbufs (struct file *file, void *priv, struct v4l2_requestbuffers *p)
+static int vidioc_reqbufs(struct file *file, void *priv,
+			  struct v4l2_requestbuffers *p)
@@ -832 +888 @@
-	struct vivi_fh  *fh=priv;
+	struct vivi_fh  *fh = priv;
@@ -837 +893 @@
-static int vidioc_querybuf (struct file *file, void *priv, struct v4l2_buffer *p)
+static int vidioc_querybuf(struct file *file, void *priv, struct v4l2_buffer *p)
@@ -839 +895 @@
-	struct vivi_fh  *fh=priv;
+	struct vivi_fh  *fh = priv;
@@ -844 +900 @@
-static int vidioc_qbuf (struct file *file, void *priv, struct v4l2_buffer *p)
+static int vidioc_qbuf(struct file *file, void *priv, struct v4l2_buffer *p)
@@ -846 +902 @@
-	struct vivi_fh  *fh=priv;
+	struct vivi_fh *fh = priv;
@@ -851 +907 @@
-static int vidioc_dqbuf (struct file *file, void *priv, struct v4l2_buffer *p)
+static int vidioc_dqbuf(struct file *file, void *priv, struct v4l2_buffer *p)
@@ -853 +909 @@
-	struct vivi_fh  *fh=priv;
+	struct vivi_fh  *fh = priv;
@@ -860 +916 @@
-static int vidiocgmbuf (struct file *file, void *priv, struct video_mbuf *mbuf)
+static int vidiocgmbuf(struct file *file, void *priv, struct video_mbuf *mbuf)
@@ -862 +918 @@
-	struct vivi_fh  *fh=priv;
+	struct vivi_fh  *fh = priv;
@@ -864 +920 @@
-	return videobuf_cgmbuf (&fh->vb_vidq, mbuf, 8);
+	return videobuf_cgmbuf(&fh->vb_vidq, mbuf, 8);
@@ -870 +926 @@
-	struct vivi_fh  *fh=priv;
+	struct vivi_fh  *fh = priv;
@@ -882 +938 @@
-	struct vivi_fh  *fh=priv;
+	struct vivi_fh  *fh = priv;
@@ -892 +948 @@
-static int vidioc_s_std (struct file *file, void *priv, v4l2_std_id *i)
+static int vidioc_s_std(struct file *file, void *priv, v4l2_std_id *i)
@@ -898 +954 @@
-static int vidioc_enum_input (struct file *file, void *priv,
+static int vidioc_enum_input(struct file *file, void *priv,
@@ -905,2 +961,2 @@
-	inp->std = V4L2_STD_NTSC_M;
-	strcpy(inp->name,"Camera");
+	inp->std = V4L2_STD_525_60;
+	strcpy(inp->name, "Camera");
@@ -911 +967 @@
-static int vidioc_g_input (struct file *file, void *priv, unsigned int *i)
+static int vidioc_g_input(struct file *file, void *priv, unsigned int *i)
@@ -917 +973 @@
-static int vidioc_s_input (struct file *file, void *priv, unsigned int i)
+static int vidioc_s_input(struct file *file, void *priv, unsigned int i)
@@ -926,2 +982,2 @@
-static int vidioc_queryctrl (struct file *file, void *priv,
-				struct v4l2_queryctrl *qc)
+static int vidioc_queryctrl(struct file *file, void *priv,
+			    struct v4l2_queryctrl *qc)
@@ -941,2 +997,2 @@
-static int vidioc_g_ctrl (struct file *file, void *priv,
-				struct v4l2_control *ctrl)
+static int vidioc_g_ctrl(struct file *file, void *priv,
+			 struct v4l2_control *ctrl)
@@ -948 +1004 @@
-			ctrl->value=qctl_regs[i];
+			ctrl->value = qctl_regs[i];
@@ -954 +1010 @@
-static int vidioc_s_ctrl (struct file *file, void *priv,
+static int vidioc_s_ctrl(struct file *file, void *priv,
@@ -961,4 +1017,2 @@
-			if (ctrl->value <
-				vivi_qctrl[i].minimum
-				|| ctrl->value >
-				vivi_qctrl[i].maximum) {
+			if (ctrl->value < vivi_qctrl[i].minimum
+			    || ctrl->value > vivi_qctrl[i].maximum) {
@@ -967 +1021 @@
-			qctl_regs[i]=ctrl->value;
+			qctl_regs[i] = ctrl->value;
@@ -986 +1040 @@
-	printk(KERN_DEBUG "vivi: open called (minor=%d)\n",minor);
+	printk(KERN_DEBUG "vivi: open called (minor=%d)\n", minor);
@@ -989 +1043 @@
-		if (dev->vfd.minor == minor)
+		if (dev->vfd->minor == minor)
@@ -992,3 +1045,0 @@
-found:
-
-
@@ -995,0 +1047 @@
+found:
@@ -999 +1051 @@
-	dprintk(1, "open minor=%d type=%s users=%d\n", minor,
+	dprintk(dev, 1, "open minor=%d type=%s users=%d\n", minor,
@@ -1003 +1055 @@
-	fh = kzalloc(sizeof(*fh),GFP_KERNEL);
+	fh = kzalloc(sizeof(*fh), GFP_KERNEL);
@@ -1019,6 +1071 @@
-		qctl_regs[i] =vivi_qctrl[i].default_value;
-
-	dprintk(1,"Open: fh=0x%08lx, dev=0x%08lx, dev->vidq=0x%08lx\n",
-		(unsigned long)fh,(unsigned long)dev,(unsigned long)&dev->vidq);
-	dprintk(1,"Open: list_empty queued=%d\n",list_empty(&dev->vidq.queued));
-	dprintk(1,"Open: list_empty active=%d\n",list_empty(&dev->vidq.active));
+		qctl_regs[i] = vivi_qctrl[i].default_value;
@@ -1027,7 +1074,8 @@
-	dev->h=0;
-	dev->m=0;
-	dev->s=0;
-	dev->us=0;
-	dev->jiffies=jiffies;
-	sprintf(dev->timestr,"%02d:%02d:%02d:%03d",
-			dev->h,dev->m,dev->s,(dev->us+500)/1000);
+	dev->h = 0;
+	dev->m = 0;
+	dev->s = 0;
+	dev->ms = 0;
+	dev->mv_count = 0;
+	dev->jiffies = jiffies;
+	sprintf(dev->timestr, "%02d:%02d:%02d:%03d",
+			dev->h, dev->m, dev->s, dev->ms);
@@ -1036,4 +1084,2 @@
-			NULL, NULL,
-			fh->type,
-			V4L2_FIELD_INTERLACED,
-			sizeof(struct vivi_buffer),fh);
+			NULL, &dev->slock, fh->type, V4L2_FIELD_INTERLACED,
+			sizeof(struct vivi_buffer), fh);
@@ -1047 +1093 @@
-	struct vivi_fh        *fh = file->private_data;
+	struct vivi_fh *fh = file->private_data;
@@ -1049 +1095 @@
-	if (fh->type==V4L2_BUF_TYPE_VIDEO_CAPTURE) {
+	if (fh->type == V4L2_BUF_TYPE_VIDEO_CAPTURE) {
@@ -1059,0 +1106 @@
+	struct vivi_dev       *dev = fh->dev;
@@ -1062 +1109 @@
-	dprintk(1,"%s\n",__FUNCTION__);
+	dprintk(dev, 1, "%s\n", __FUNCTION__);
@@ -1070 +1117 @@
-static int vivi_release(struct inode *inode, struct file *file)
+static int vivi_close(struct inode *inode, struct file *file)
@@ -1082 +1129 @@
-	kfree (fh);
+	kfree(fh);
@@ -1086 +1133,2 @@
-	printk(KERN_DEBUG "vivi: close called (minor=%d, users=%d)\n",minor,dev->users);
+	dprintk(dev, 1, "close called (minor=%d, users=%d)\n",
+		minor, dev->users);
@@ -1091,2 +1139 @@
-static int
-vivi_mmap(struct file *file, struct vm_area_struct * vma)
+static int vivi_release(void)
@@ -1094 +1141,23 @@
-	struct vivi_fh        *fh = file->private_data;
+	struct vivi_dev *dev;
+	struct list_head *list;
+
+	while (!list_empty(&vivi_devlist)) {
+		list = vivi_devlist.next;
+		list_del(list);
+		dev = list_entry(list, struct vivi_dev, vivi_devlist);
+
+		if (-1 != dev->vfd->minor)
+			video_unregister_device(dev->vfd);
+		else
+			video_device_release(dev->vfd);
+
+		kfree(dev);
+	}
+
+	return 0;
+}
+
+static int vivi_mmap(struct file *file, struct vm_area_struct *vma)
+{
+	struct vivi_fh  *fh = file->private_data;
+	struct vivi_dev *dev = fh->dev;
@@ -1097 +1166 @@
-	dprintk (1,"mmap called, vma=0x%08lx\n",(unsigned long)vma);
+	dprintk(dev, 1, "mmap called, vma=0x%08lx\n", (unsigned long)vma);
@@ -1099 +1168 @@
-	ret=videobuf_mmap_mapper(&fh->vb_vidq, vma);
+	ret = videobuf_mmap_mapper(&fh->vb_vidq, vma);
@@ -1101 +1170 @@
-	dprintk (1,"vma start=0x%08lx, size=%ld, ret=%d\n",
+	dprintk(dev, 1, "vma start=0x%08lx, size=%ld, ret=%d\n",
@@ -1112 +1181 @@
-	.release        = vivi_release,
+	.release        = vivi_close,
@@ -1120 +1189 @@
-static struct video_device vivi = {
+static struct video_device vivi_template = {
@@ -1125 +1194 @@
-//	.release	= video_device_release,
+	.release	= video_device_release,
@@ -1148 +1217 @@
-	.tvnorms              = V4L2_STD_NTSC_M,
+	.tvnorms              = V4L2_STD_525_60,
@@ -1157 +1226 @@
-	int ret;
+	int ret = -ENOMEM, i;
@@ -1158,0 +1228 @@
+	struct video_device *vfd;
@@ -1160,4 +1230,4 @@
-	dev = kzalloc(sizeof(*dev),GFP_KERNEL);
-	if (NULL == dev)
-		return -ENOMEM;
-	list_add_tail(&dev->vivi_devlist,&vivi_devlist);
+	for (i = 0; i < n_devs; i++) {
+		dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+		if (NULL == dev)
+			break;
@@ -1165,11 +1235 @@
-	/* init video dma queues */
-	INIT_LIST_HEAD(&dev->vidq.active);
-	INIT_LIST_HEAD(&dev->vidq.queued);
-	init_waitqueue_head(&dev->vidq.wq);
-
-	/* initialize locks */
-	mutex_init(&dev->lock);
-
-	dev->vidq.timeout.function = vivi_vid_timeout;
-	dev->vidq.timeout.data     = (unsigned long)dev;
-	init_timer(&dev->vidq.timeout);
+		list_add_tail(&dev->vivi_devlist, &vivi_devlist);
@@ -1177,2 +1237,38 @@
-	ret = video_register_device(&vivi, VFL_TYPE_GRABBER, video_nr);
-	printk(KERN_INFO "Video Technology Magazine Virtual Video Capture Board (Load status: %d)\n", ret);
+		/* init video dma queues */
+		INIT_LIST_HEAD(&dev->vidq.active);
+		INIT_LIST_HEAD(&dev->vidq.queued);
+		init_waitqueue_head(&dev->vidq.wq);
+
+		/* initialize locks */
+		mutex_init(&dev->lock);
+		spin_lock_init(&dev->slock);
+
+		dev->vidq.timeout.function = vivi_vid_timeout;
+		dev->vidq.timeout.data     = (unsigned long)dev;
+		init_timer(&dev->vidq.timeout);
+
+		vfd = video_device_alloc();
+		if (NULL == vfd)
+			break;
+
+		*vfd = vivi_template;
+
+		ret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);
+		if (ret < 0)
+			break;
+
+		snprintf(vfd->name, sizeof(vfd->name), "%s (%i)",
+			 vivi_template.name, vfd->minor);
+
+		if (video_nr >= 0)
+			video_nr++;
+
+		dev->vfd = vfd;
+	}
+
+	if (ret < 0) {
+		vivi_release();
+		printk(KERN_INFO "Error %d while loading vivi driver\n", ret);
+	} else
+		printk(KERN_INFO "Video Technology Magazine Virtual Video "
+				 "Capture Board successfully loaded.\n");
@@ -1184,10 +1280 @@
-	struct vivi_dev *h;
-	struct list_head *list;
-
-	while (!list_empty(&vivi_devlist)) {
-		list = vivi_devlist.next;
-		list_del(list);
-		h = list_entry(list, struct vivi_dev, vivi_devlist);
-		kfree (h);
-	}
-	video_unregister_device(&vivi);
+	vivi_release();
@@ -1203,0 +1291 @@
+MODULE_PARM_DESC(video_nr, "video iminor start number");
@@ -1205,2 +1293,2 @@
-module_param_named(debug,vivi.debug, int, 0644);
-MODULE_PARM_DESC(debug,"activates debug info");
+module_param(n_devs, int, 0);
+MODULE_PARM_DESC(n_devs, "number of video devices to create");
@@ -1208,2 +1296,2 @@
-module_param(vid_limit,int,0644);
-MODULE_PARM_DESC(vid_limit,"capture memory limit in megabytes");
+module_param_named(debug, vivi_template.debug, int, 0444);
+MODULE_PARM_DESC(debug, "activates debug info");
@@ -1210,0 +1299,2 @@
+module_param(vid_limit, int, 0644);
+MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
--- ./projects/linux/linux-2.6.25/drivers/media/video/vivi.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/media/video/vivi.c	2008-07-13 23:51:29.000000000 +0200
@@ -149,2 +148,0 @@
-	struct list_head       queued;
-	struct timer_list      timeout;
@@ -165 +162,0 @@
-	struct mutex               lock;
@@ -166,0 +164 @@
+	struct mutex		   mutex;
@@ -324,0 +323 @@
+
@@ -331 +330 @@
-	char *tmpbuf = kmalloc(wmax * 2, GFP_KERNEL);
+	char *tmpbuf;
@@ -333,0 +333,4 @@
+	if (!vbuf)
+		return;
+
+	tmpbuf = kmalloc(wmax * 2, GFP_ATOMIC);
@@ -340,3 +343 @@
-		/* FIXME: replacing to __copy_to_user */
-		if (copy_to_user(vbuf + pos, tmpbuf, wmax * 2) != 0)
-			dprintk(dev, 2, "vivifill copy_to_user failed.\n");
+		memcpy(vbuf + pos, tmpbuf, wmax * 2);
@@ -375 +375,0 @@
-	buf->vb.state = VIDEOBUF_DONE;
@@ -379,3 +379 @@
-
-	list_del(&buf->vb.queue);
-	wake_up(&buf->vb.done);
+	buf->vb.state = VIDEOBUF_DONE;
@@ -384,3 +382 @@
-static int restart_video_queue(struct vivi_dmaqueue *dma_q);
-
-static void vivi_thread_tick(struct vivi_dmaqueue  *dma_q)
+static void vivi_thread_tick(struct vivi_fh *fh)
@@ -388,2 +384,3 @@
-	struct vivi_buffer    *buf;
-	struct vivi_dev *dev = container_of(dma_q, struct vivi_dev, vidq);
+	struct vivi_buffer *buf;
+	struct vivi_dev *dev = fh->dev;
+	struct vivi_dmaqueue *dma_q = &dev->vidq;
@@ -391 +388 @@
-	int bc;
+	unsigned long flags = 0;
@@ -393,7 +390 @@
-	spin_lock(&dev->slock);
-	/* Announces videobuf that all went ok */
-	for (bc = 0;; bc++) {
-		if (list_empty(&dma_q->active)) {
-			dprintk(dev, 1, "No active queue to serve\n");
-			break;
-		}
+	dprintk(dev, 1, "Thread tick\n");
@@ -401,2 +392,5 @@
-		buf = list_entry(dma_q->active.next,
-				 struct vivi_buffer, vb.queue);
+	spin_lock_irqsave(&dev->slock, flags);
+	if (list_empty(&dma_q->active)) {
+		dprintk(dev, 1, "No active queue to serve\n");
+		goto unlock;
+	}
@@ -404,6 +398,2 @@
-		/* Nobody is waiting something to be done, just return */
-		if (!waitqueue_active(&buf->vb.done)) {
-			mod_timer(&dma_q->timeout, jiffies+BUFFER_TIMEOUT);
-			spin_unlock(&dev->slock);
-			return;
-		}
+	buf = list_entry(dma_q->active.next,
+			 struct vivi_buffer, vb.queue);
@@ -411,2 +401,3 @@
-		do_gettimeofday(&buf->vb.ts);
-		dprintk(dev, 2, "[%p/%d] wakeup\n", buf, buf->vb. i);
+	/* Nobody is waiting on this buffer, return */
+	if (!waitqueue_active(&buf->vb.done))
+		goto unlock;
@@ -414,2 +405 @@
-		/* Fill buffer */
-		vivi_fillbuff(dev, buf);
+	list_del(&buf->vb.queue);
@@ -417,10 +407,11 @@
-		if (list_empty(&dma_q->active)) {
-			del_timer(&dma_q->timeout);
-		} else {
-			mod_timer(&dma_q->timeout, jiffies + BUFFER_TIMEOUT);
-		}
-	}
-	if (bc != 1)
-		dprintk(dev, 1, "%s: %d buffers handled (should be 1)\n",
-			__FUNCTION__, bc);
-	spin_unlock(&dev->slock);
+	do_gettimeofday(&buf->vb.ts);
+
+	/* Fill buffer */
+	vivi_fillbuff(dev, buf);
+	dprintk(dev, 1, "filled buffer %p\n", buf);
+
+	wake_up(&buf->vb.done);
+	dprintk(dev, 2, "[%p/%d] wakeup\n", buf, buf->vb. i);
+unlock:
+	spin_unlock_irqrestore(&dev->slock, flags);
+	return;
@@ -432 +423 @@
-static void vivi_sleep(struct vivi_dmaqueue  *dma_q)
+static void vivi_sleep(struct vivi_fh *fh)
@@ -434,2 +425,3 @@
-	struct vivi_dev *dev = container_of(dma_q, struct vivi_dev, vidq);
-	int timeout, running_time;
+	struct vivi_dev *dev = fh->dev;
+	struct vivi_dmaqueue *dma_q = &dev->vidq;
+	int timeout;
@@ -438 +430 @@
-	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __FUNCTION__,
+	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __func__,
@@ -445,3 +436,0 @@
-	running_time = jiffies - dma_q->ini_jiffies;
-	dma_q->frame++;
-
@@ -449,17 +438 @@
-	timeout = msecs_to_jiffies(frames_to_ms(dma_q->frame)) - running_time;
-
-	if (timeout > msecs_to_jiffies(frames_to_ms(2)) || timeout <= 0) {
-		int old = dma_q->frame;
-		int nframes;
-
-		dma_q->frame = (jiffies_to_msecs(running_time) /
-			       frames_to_ms(1)) + 1;
-
-		timeout = msecs_to_jiffies(frames_to_ms(dma_q->frame))
-			  - running_time;
-
-		if (unlikely (timeout <= 0))
-			timeout = 1;
-
-		nframes = (dma_q->frame > old)?
-				  dma_q->frame - old : old - dma_q->frame;
+	timeout = msecs_to_jiffies(frames_to_ms(1));
@@ -467,9 +440 @@
-		dprintk(dev, 1, "%ld: %s %d frames. "
-			"Current frame is %d. Will sleep for %d jiffies\n",
-			jiffies,
-			(dma_q->frame > old)? "Underrun, losed" : "Overrun of",
-			nframes, dma_q->frame, timeout);
-	} else
-		dprintk(dev, 1, "will sleep for %d jiffies\n", timeout);
-
-	vivi_thread_tick(dma_q);
+	vivi_thread_tick(fh);
@@ -486,2 +451,2 @@
-	struct vivi_dmaqueue  *dma_q = data;
-	struct vivi_dev *dev = container_of(dma_q, struct vivi_dev, vidq);
+	struct vivi_fh  *fh = data;
+	struct vivi_dev *dev = fh->dev;
@@ -491 +455,0 @@
-	mod_timer(&dma_q->timeout, jiffies+BUFFER_TIMEOUT);
@@ -495 +459 @@
-		vivi_sleep(dma_q);
+		vivi_sleep(fh);
@@ -504 +468 @@
-static int vivi_start_thread(struct vivi_dmaqueue  *dma_q)
+static int vivi_start_thread(struct vivi_fh *fh)
@@ -506 +470,2 @@
-	struct vivi_dev *dev = container_of(dma_q, struct vivi_dev, vidq);
+	struct vivi_dev *dev = fh->dev;
+	struct vivi_dmaqueue *dma_q = &dev->vidq;
@@ -511 +476 @@
-	dprintk(dev, 1, "%s\n", __FUNCTION__);
+	dprintk(dev, 1, "%s\n", __func__);
@@ -513 +478 @@
-	dma_q->kthread = kthread_run(vivi_thread, dma_q, "vivi");
+	dma_q->kthread = kthread_run(vivi_thread, fh, "vivi");
@@ -522 +487 @@
-	dprintk(dev, 1, "returning from %s\n", __FUNCTION__);
+	dprintk(dev, 1, "returning from %s\n", __func__);
@@ -530 +495 @@
-	dprintk(dev, 1, "%s\n", __FUNCTION__);
+	dprintk(dev, 1, "%s\n", __func__);
@@ -538,85 +502,0 @@
-static int restart_video_queue(struct vivi_dmaqueue *dma_q)
-{
-	struct vivi_dev *dev = container_of(dma_q, struct vivi_dev, vidq);
-	struct vivi_buffer *buf, *prev;
-
-	dprintk(dev, 1, "%s dma_q=0x%08lx\n", __FUNCTION__,
-		(unsigned long)dma_q);
-
-	if (!list_empty(&dma_q->active)) {
-		buf = list_entry(dma_q->active.next,
-				 struct vivi_buffer, vb.queue);
-		dprintk(dev, 2, "restart_queue [%p/%d]: restart dma\n",
-			buf, buf->vb.i);
-
-		dprintk(dev, 1, "Restarting video dma\n");
-		vivi_stop_thread(dma_q);
-
-		/* cancel all outstanding capture / vbi requests */
-		list_for_each_entry_safe(buf, prev, &dma_q->active, vb.queue) {
-			list_del(&buf->vb.queue);
-			buf->vb.state = VIDEOBUF_ERROR;
-			wake_up(&buf->vb.done);
-		}
-		mod_timer(&dma_q->timeout, jiffies+BUFFER_TIMEOUT);
-
-		return 0;
-	}
-
-	prev = NULL;
-	for (;;) {
-		if (list_empty(&dma_q->queued))
-			return 0;
-		buf = list_entry(dma_q->queued.next,
-				 struct vivi_buffer, vb.queue);
-		if (NULL == prev) {
-			list_del(&buf->vb.queue);
-			list_add_tail(&buf->vb.queue, &dma_q->active);
-
-			dprintk(dev, 1, "Restarting video dma\n");
-			vivi_stop_thread(dma_q);
-			vivi_start_thread(dma_q);
-
-			buf->vb.state = VIDEOBUF_ACTIVE;
-			mod_timer(&dma_q->timeout, jiffies+BUFFER_TIMEOUT);
-			dprintk(dev, 2,
-				"[%p/%d] restart_queue - first active\n",
-				buf, buf->vb.i);
-
-		} else if (prev->vb.width  == buf->vb.width  &&
-			   prev->vb.height == buf->vb.height &&
-			   prev->fmt       == buf->fmt) {
-			list_del(&buf->vb.queue);
-			list_add_tail(&buf->vb.queue, &dma_q->active);
-			buf->vb.state = VIDEOBUF_ACTIVE;
-			dprintk(dev, 2,
-				"[%p/%d] restart_queue - move to active\n",
-				buf, buf->vb.i);
-		} else {
-			return 0;
-		}
-		prev = buf;
-	}
-}
-
-static void vivi_vid_timeout(unsigned long data)
-{
-	struct vivi_dev      *dev  = (struct vivi_dev *)data;
-	struct vivi_dmaqueue *vidq = &dev->vidq;
-	struct vivi_buffer   *buf;
-
-	spin_lock(&dev->slock);
-
-	while (!list_empty(&vidq->active)) {
-		buf = list_entry(vidq->active.next,
-				 struct vivi_buffer, vb.queue);
-		list_del(&buf->vb.queue);
-		buf->vb.state = VIDEOBUF_ERROR;
-		wake_up(&buf->vb.done);
-		printk(KERN_INFO "vivi/0: [%p/%d] timeout\n", buf, buf->vb.i);
-	}
-	restart_video_queue(vidq);
-
-	spin_unlock(&dev->slock);
-}
-
@@ -640 +520 @@
-	dprintk(dev, 1, "%s, count=%d, size=%d\n", __FUNCTION__,
+	dprintk(dev, 1, "%s, count=%d, size=%d\n", __func__,
@@ -651 +531 @@
-	dprintk(dev, 1, "%s\n", __FUNCTION__);
+	dprintk(dev, 1, "%s, state: %i\n", __func__, buf->vb.state);
@@ -656 +535,0 @@
-	videobuf_waiton(&buf->vb, 0, 0);
@@ -657,0 +537 @@
+	dprintk(dev, 1, "free_buffer: freed\n");
@@ -670 +550 @@
-	int rc, init_buffer = 0;
+	int rc;
@@ -672 +552 @@
-	dprintk(dev, 1, "%s, field=%d\n", __FUNCTION__, field);
+	dprintk(dev, 1, "%s, field=%d\n", __func__, field);
@@ -674,0 +555 @@
+
@@ -677,0 +559 @@
+
@@ -682,10 +564,5 @@
-	if (buf->fmt       != fh->fmt    ||
-	    buf->vb.width  != fh->width  ||
-	    buf->vb.height != fh->height ||
-	buf->vb.field  != field) {
-		buf->fmt       = fh->fmt;
-		buf->vb.width  = fh->width;
-		buf->vb.height = fh->height;
-		buf->vb.field  = field;
-		init_buffer = 1;
-	}
+	/* These properties only change when queue is idle, see s_fmt */
+	buf->fmt       = fh->fmt;
+	buf->vb.width  = fh->width;
+	buf->vb.height = fh->height;
+	buf->vb.field  = field;
@@ -714,2 +591 @@
-	struct vivi_dmaqueue  *vidq = &dev->vidq;
-	struct vivi_buffer    *prev;
+	struct vivi_dmaqueue *vidq = &dev->vidq;
@@ -717,36 +593,4 @@
-	if (!list_empty(&vidq->queued)) {
-		dprintk(dev, 1, "adding vb queue=0x%08lx\n",
-			(unsigned long)&buf->vb.queue);
-		list_add_tail(&buf->vb.queue, &vidq->queued);
-		buf->vb.state = VIDEOBUF_QUEUED;
-		dprintk(dev, 2, "[%p/%d] buffer_queue - append to queued\n",
-			buf, buf->vb.i);
-	} else if (list_empty(&vidq->active)) {
-		list_add_tail(&buf->vb.queue, &vidq->active);
-
-		buf->vb.state = VIDEOBUF_ACTIVE;
-		mod_timer(&vidq->timeout, jiffies+BUFFER_TIMEOUT);
-		dprintk(dev, 2, "[%p/%d] buffer_queue - first active\n",
-			buf, buf->vb.i);
-
-		vivi_start_thread(vidq);
-	} else {
-		prev = list_entry(vidq->active.prev,
-				  struct vivi_buffer, vb.queue);
-		if (prev->vb.width  == buf->vb.width  &&
-		    prev->vb.height == buf->vb.height &&
-		    prev->fmt       == buf->fmt) {
-			list_add_tail(&buf->vb.queue, &vidq->active);
-			buf->vb.state = VIDEOBUF_ACTIVE;
-			dprintk(dev, 2,
-				"[%p/%d] buffer_queue - append to active\n",
-				buf, buf->vb.i);
-
-		} else {
-			list_add_tail(&buf->vb.queue, &vidq->queued);
-			buf->vb.state = VIDEOBUF_QUEUED;
-			dprintk(dev, 2,
-				"[%p/%d] buffer_queue - first queued\n",
-				buf, buf->vb.i);
-		}
-	}
+	dprintk(dev, 1, "%s\n", __func__);
+
+	buf->vb.state = VIDEOBUF_QUEUED;
+	list_add_tail(&buf->vb.queue, &vidq->active);
@@ -761,3 +604,0 @@
-	struct vivi_dmaqueue *vidq = &dev->vidq;
-
-	dprintk(dev, 1, "%s\n", __FUNCTION__);
@@ -765 +606 @@
-	vivi_stop_thread(vidq);
+	dprintk(dev, 1, "%s\n", __func__);
@@ -871,0 +713,2 @@
+	struct videobuf_queue *q = &fh->vb_vidq;
+
@@ -875,0 +719,8 @@
+	mutex_lock(&q->vb_lock);
+
+	if (videobuf_queue_is_busy(&fh->vb_vidq)) {
+		dprintk(fh->dev, 1, "%s queue busy\n", __func__);
+		ret = -EBUSY;
+		goto out;
+	}
+
@@ -882 +733,5 @@
-	return (0);
+	ret = 0;
+out:
+	mutex_unlock(&q->vb_lock);
+
+	return (ret);
@@ -1037 +892 @@
-	struct vivi_fh *fh;
+	struct vivi_fh *fh = NULL;
@@ -1038,0 +894 @@
+	int retval = 0;
@@ -1048 +904 @@
-	/* If more than one user, mutex should be added */
+	mutex_lock(&dev->mutex);
@@ -1050,0 +907,6 @@
+	if (dev->users > 1) {
+		dev->users--;
+		retval = -EBUSY;
+		goto unlock;
+	}
+
@@ -1058 +920,2 @@
-		return -ENOMEM;
+		retval = -ENOMEM;
+		goto unlock;
@@ -1059,0 +923,4 @@
+unlock:
+	mutex_unlock(&dev->mutex);
+	if (retval)
+		return retval;
@@ -1086,0 +954,2 @@
+	vivi_start_thread(fh);
+
@@ -1109 +978 @@
-	dprintk(dev, 1, "%s\n", __FUNCTION__);
+	dprintk(dev, 1, "%s\n", __func__);
@@ -1130,0 +1000 @@
+	mutex_lock(&dev->mutex);
@@ -1131,0 +1002 @@
+	mutex_unlock(&dev->mutex);
@@ -1184,0 +1056 @@
+	.compat_ioctl   = v4l_compat_ioctl32,
@@ -1239 +1110,0 @@
-		INIT_LIST_HEAD(&dev->vidq.queued);
@@ -1243 +1113,0 @@
-		mutex_init(&dev->lock);
@@ -1245,4 +1115 @@
-
-		dev->vidq.timeout.function = vivi_vid_timeout;
-		dev->vidq.timeout.data     = (unsigned long)dev;
-		init_timer(&dev->vidq.timeout);
+		mutex_init(&dev->mutex);
--- ./projects/linux/linux-2.6.26/drivers/media/video/vivi.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/media/video/vivi.c	2008-10-10 00:13:53.000000000 +0200
@@ -37,0 +38 @@
+#include <media/v4l2-ioctl.h>
@@ -41,0 +43,2 @@
+#define VIVI_MODULE_NAME "vivi"
+
@@ -50 +53 @@
-#define VIVI_MINOR_VERSION 4
+#define VIVI_MINOR_VERSION 5
@@ -633 +636 @@
-static int vidioc_enum_fmt_cap(struct file *file, void  *priv,
+static int vidioc_enum_fmt_vid_cap(struct file *file, void  *priv,
@@ -644 +647 @@
-static int vidioc_g_fmt_cap(struct file *file, void *priv,
+static int vidioc_g_fmt_vid_cap(struct file *file, void *priv,
@@ -661 +664 @@
-static int vidioc_try_fmt_cap(struct file *file, void *priv,
+static int vidioc_try_fmt_vid_cap(struct file *file, void *priv,
@@ -709 +712 @@
-static int vidioc_s_fmt_cap(struct file *file, void *priv,
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
@@ -715 +718 @@
-	int ret = vidioc_try_fmt_cap(file, fh, f);
+	int ret = vidioc_try_fmt_vid_cap(file, fh, f);
@@ -1020 +1023,3 @@
-		if (-1 != dev->vfd->minor)
+		if (-1 != dev->vfd->minor) {
+			printk(KERN_INFO "%s: unregistering /dev/video%d\n",
+				VIVI_MODULE_NAME, dev->vfd->minor);
@@ -1022 +1027,3 @@
-		else
+		} else {
+			printk(KERN_INFO "%s: releasing /dev/video%d\n",
+				VIVI_MODULE_NAME, dev->vfd->minor);
@@ -1023,0 +1031 @@
+		}
@@ -1061,7 +1069 @@
-static struct video_device vivi_template = {
-	.name		= "vivi",
-	.type		= VID_TYPE_CAPTURE,
-	.fops           = &vivi_fops,
-	.minor		= -1,
-	.release	= video_device_release,
-
+static const struct v4l2_ioctl_ops vivi_ioctl_ops = {
@@ -1069,4 +1071,4 @@
-	.vidioc_enum_fmt_cap  = vidioc_enum_fmt_cap,
-	.vidioc_g_fmt_cap     = vidioc_g_fmt_cap,
-	.vidioc_try_fmt_cap   = vidioc_try_fmt_cap,
-	.vidioc_s_fmt_cap     = vidioc_s_fmt_cap,
+	.vidioc_enum_fmt_vid_cap  = vidioc_enum_fmt_vid_cap,
+	.vidioc_g_fmt_vid_cap     = vidioc_g_fmt_vid_cap,
+	.vidioc_try_fmt_vid_cap   = vidioc_try_fmt_vid_cap,
+	.vidioc_s_fmt_vid_cap     = vidioc_s_fmt_vid_cap,
@@ -1088,0 +1091,9 @@
+};
+
+static struct video_device vivi_template = {
+	.name		= "vivi",
+	.fops           = &vivi_fops,
+	.ioctl_ops 	= &vivi_ioctl_ops,
+	.minor		= -1,
+	.release	= video_device_release,
+
@@ -1095,0 +1107,9 @@
+/* This routine allocates from 1 to n_devs virtual drivers.
+
+   The real maximum number of virtual drivers will depend on how many drivers
+   will succeed. This is limited to the maximum number of devices that
+   videodev supports. Since there are 64 minors for video grabbers, this is
+   currently the theoretical maximum limit. However, a further limit does
+   exist at videodev that forbids any driver to register more than 32 video
+   grabbers.
+ */
@@ -1101,0 +1122,3 @@
+	if (n_devs <= 0)
+		n_devs = 1;
+
@@ -1104 +1127 @@
-		if (NULL == dev)
+		if (!dev)
@@ -1107,2 +1129,0 @@
-		list_add_tail(&dev->vivi_devlist, &vivi_devlist);
-
@@ -1118 +1139,2 @@
-		if (NULL == vfd)
+		if (!vfd) {
+			kfree(dev);
@@ -1119,0 +1142 @@
+		}
@@ -1124 +1147,8 @@
-		if (ret < 0)
+		if (ret < 0) {
+			video_device_release(vfd);
+			kfree(dev);
+
+			/* If some registers succeeded, keep driver */
+			if (i)
+				ret = 0;
+
@@ -1125,0 +1156,4 @@
+		}
+
+		/* Now that everything is fine, let's add it to device list */
+		list_add_tail(&dev->vivi_devlist, &vivi_devlist);
@@ -1133,0 +1168,2 @@
+		printk(KERN_INFO "%s: V4L2 device registered as /dev/video%d\n",
+			VIVI_MODULE_NAME, vfd->minor);
@@ -1139 +1175 @@
-	} else
+	} else {
@@ -1141 +1177,8 @@
-				 "Capture Board successfully loaded.\n");
+			"Capture Board ver %u.%u.%u successfully loaded.\n",
+			(VIVI_VERSION >> 16) & 0xFF, (VIVI_VERSION >> 8) & 0xFF,
+			VIVI_VERSION & 0xFF);
+
+		/* n_devs will reflect the actual number of allocated devices */
+		n_devs = i;
+	}
+
@@ -1157 +1200 @@
-module_param(video_nr, int, 0);
+module_param(video_nr, uint, 0444);
@@ -1160 +1203 @@
-module_param(n_devs, int, 0);
+module_param(n_devs, uint, 0444);
--- ./projects/linux/linux-2.6.27/drivers/media/video/vivi.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/media/video/vivi.c	2008-12-25 00:26:37.000000000 +0100
@@ -131,4 +131,31 @@
-static struct vivi_fmt format = {
-	.name     = "4:2:2, packed, YUYV",
-	.fourcc   = V4L2_PIX_FMT_YUYV,
-	.depth    = 16,
+static struct vivi_fmt formats[] = {
+	{
+		.name     = "4:2:2, packed, YUYV",
+		.fourcc   = V4L2_PIX_FMT_YUYV,
+		.depth    = 16,
+	},
+	{
+		.name     = "4:2:2, packed, UYVY",
+		.fourcc   = V4L2_PIX_FMT_UYVY,
+		.depth    = 16,
+	},
+	{
+		.name     = "RGB565 (LE)",
+		.fourcc   = V4L2_PIX_FMT_RGB565, /* gggbbbbb rrrrrggg */
+		.depth    = 16,
+	},
+	{
+		.name     = "RGB565 (BE)",
+		.fourcc   = V4L2_PIX_FMT_RGB565X, /* rrrrrggg gggbbbbb */
+		.depth    = 16,
+	},
+	{
+		.name     = "RGB555 (LE)",
+		.fourcc   = V4L2_PIX_FMT_RGB555, /* gggbbbbb arrrrrgg */
+		.depth    = 16,
+	},
+	{
+		.name     = "RGB555 (BE)",
+		.fourcc   = V4L2_PIX_FMT_RGB555X, /* arrrrrgg gggbbbbb */
+		.depth    = 16,
+	},
@@ -136,0 +164,17 @@
+static struct vivi_fmt *get_format(struct v4l2_format *f)
+{
+	struct vivi_fmt *fmt;
+	unsigned int k;
+
+	for (k = 0; k < ARRAY_SIZE(formats); k++) {
+		fmt = &formats[k];
+		if (fmt->fourcc == f->fmt.pix.pixelformat)
+			break;
+	}
+
+	if (k == ARRAY_SIZE(formats))
+		return NULL;
+
+	return &formats[k];
+}
+
@@ -192,0 +237 @@
+	unsigned char              bars[8][3];
@@ -237,2 +282 @@
-static void gen_line(char *basep, int inipos, int wmax,
-		int hmax, int line, int count, char *timestr)
+static void gen_twopix(struct vivi_fh *fh, unsigned char *buf, int colorpos)
@@ -240,4 +284,3 @@
-	int  w, i, j, y;
-	int pos = inipos;
-	char *p, *s;
-	u8   chr, r, g, b, color;
+	unsigned char r_y, g_u, b_v;
+	unsigned char *p;
+	int color;
@@ -245,2 +288,3 @@
-	/* We will just duplicate the second pixel at the packet */
-	wmax /= 2;
+	r_y = fh->bars[colorpos][0]; /* R or precalculated Y */
+	g_u = fh->bars[colorpos][1]; /* G or precalculated U */
+	b_v = fh->bars[colorpos][2]; /* B or precalculated V */
@@ -248,9 +292,2 @@
-	/* Generate a standard color bar pattern */
-	for (w = 0; w < wmax; w++) {
-		int colorpos = ((w + count) * 8/(wmax + 1)) % 8;
-		r = bars[colorpos][0];
-		g = bars[colorpos][1];
-		b = bars[colorpos][2];
-
-		for (color = 0; color < 4; color++) {
-			p = basep + pos;
+	for (color = 0; color < 4; color++) {
+		p = buf + color;
@@ -257,0 +295,54 @@
+		switch (fh->fmt->fourcc) {
+		case V4L2_PIX_FMT_YUYV:
+			switch (color) {
+			case 0:
+			case 2:
+				*p = r_y;
+				break;
+			case 1:
+				*p = g_u;
+				break;
+			case 3:
+				*p = b_v;
+				break;
+			}
+			break;
+		case V4L2_PIX_FMT_UYVY:
+			switch (color) {
+			case 1:
+			case 3:
+				*p = r_y;
+				break;
+			case 0:
+				*p = g_u;
+				break;
+			case 2:
+				*p = b_v;
+				break;
+			}
+			break;
+		case V4L2_PIX_FMT_RGB565:
+			switch (color) {
+			case 0:
+			case 2:
+				*p = (g_u << 5) | b_v;
+				break;
+			case 1:
+			case 3:
+				*p = (r_y << 3) | (g_u >> 3);
+				break;
+			}
+			break;
+		case V4L2_PIX_FMT_RGB565X:
+			switch (color) {
+			case 0:
+			case 2:
+				*p = (r_y << 3) | (g_u >> 3);
+				break;
+			case 1:
+			case 3:
+				*p = (g_u << 5) | b_v;
+				break;
+			}
+			break;
+		case V4L2_PIX_FMT_RGB555:
@@ -261 +352 @@
-				*p = TO_Y(r, g, b);	/* Luma */
+				*p = (g_u << 5) | b_v;
@@ -264 +355,10 @@
-				*p = TO_U(r, g, b);	/* Cb */
+			case 3:
+				*p = (r_y << 2) | (g_u >> 3);
+				break;
+			}
+			break;
+		case V4L2_PIX_FMT_RGB555X:
+			switch (color) {
+			case 0:
+			case 2:
+				*p = (r_y << 2) | (g_u >> 3);
@@ -265,0 +366 @@
+			case 1:
@@ -267 +368 @@
-				*p = TO_V(r, g, b);	/* Cr */
+				*p = (g_u << 5) | b_v;
@@ -270 +371 @@
-			pos++;
+			break;
@@ -272,0 +374,20 @@
+}
+
+static void gen_line(struct vivi_fh *fh, char *basep, int inipos, int wmax,
+		int hmax, int line, int count, char *timestr)
+{
+	int  w, i, j;
+	int pos = inipos;
+	char *s;
+	u8 chr;
+
+	/* We will just duplicate the second pixel at the packet */
+	wmax /= 2;
+
+	/* Generate a standard color bar pattern */
+	for (w = 0; w < wmax; w++) {
+		int colorpos = ((w + count) * 8/(wmax + 1)) % 8;
+
+		gen_twopix(fh, basep + pos, colorpos);
+		pos += 4; /* only 16 bpp supported for now */
+	}
@@ -286,12 +406,0 @@
-				if (chr & 1 << (7 - i)) {
-					/* Font color*/
-					r = 0;
-					g = 198;
-					b = 0;
-				} else {
-					/* Background color */
-					r = bars[BLACK][0];
-					g = bars[BLACK][1];
-					b = bars[BLACK][2];
-				}
-
@@ -299,19 +408,5 @@
-				for (color = 0; color < 4; color++) {
-					p = basep + pos;
-
-					y = TO_Y(r, g, b);
-
-					switch (color) {
-					case 0:
-					case 2:
-						*p = TO_Y(r, g, b); /* Luma */
-						break;
-					case 1:
-						*p = TO_U(r, g, b); /* Cb */
-						break;
-					case 3:
-						*p = TO_V(r, g, b); /* Cr */
-						break;
-					}
-					pos++;
-				}
+				/* Draw white font on black background */
+				if (chr & 1 << (7 - i))
+					gen_twopix(fh, basep + pos, WHITE);
+				else
+					gen_twopix(fh, basep + pos, BLACK);
@@ -327 +422 @@
-static void vivi_fillbuff(struct vivi_dev *dev, struct vivi_buffer *buf)
+static void vivi_fillbuff(struct vivi_fh *fh, struct vivi_buffer *buf)
@@ -328,0 +424 @@
+	struct vivi_dev *dev = fh->dev;
@@ -344 +440 @@
-		gen_line(tmpbuf, 0, wmax, hmax, h, dev->mv_count,
+		gen_line(fh, tmpbuf, 0, wmax, hmax, h, dev->mv_count,
@@ -413 +509 @@
-	vivi_fillbuff(dev, buf);
+	vivi_fillbuff(fh, buf);
@@ -639 +735,3 @@
-	if (f->index > 0)
+	struct vivi_fmt *fmt;
+
+	if (f->index >= ARRAY_SIZE(formats))
@@ -642,2 +740,4 @@
-	strlcpy(f->description, format.name, sizeof(f->description));
-	f->pixelformat = format.fourcc;
+	fmt = &formats[f->index];
+
+	strlcpy(f->description, fmt->name, sizeof(f->description));
+	f->pixelformat = fmt->fourcc;
@@ -673,4 +773,4 @@
-	if (format.fourcc != f->fmt.pix.pixelformat) {
-		dprintk(dev, 1, "Fourcc format (0x%08x) invalid. "
-			"Driver accepts only 0x%08x\n",
-			f->fmt.pix.pixelformat, format.fourcc);
+	fmt = get_format(f);
+	if (!fmt) {
+		dprintk(dev, 1, "Fourcc format (0x%08x) invalid.\n",
+			f->fmt.pix.pixelformat);
@@ -679 +778,0 @@
-	fmt = &format;
@@ -716,0 +816,2 @@
+	unsigned char r, g, b;
+	int k, is_yuv;
@@ -730 +831 @@
-	fh->fmt           = &format;
+	fh->fmt           = get_format(f);
@@ -735,0 +837,37 @@
+	/* precalculate color bar values to speed up rendering */
+	for (k = 0; k < 8; k++) {
+		r = bars[k][0];
+		g = bars[k][1];
+		b = bars[k][2];
+		is_yuv = 0;
+
+		switch (fh->fmt->fourcc) {
+		case V4L2_PIX_FMT_YUYV:
+		case V4L2_PIX_FMT_UYVY:
+			is_yuv = 1;
+			break;
+		case V4L2_PIX_FMT_RGB565:
+		case V4L2_PIX_FMT_RGB565X:
+			r >>= 3;
+			g >>= 2;
+			b >>= 3;
+			break;
+		case V4L2_PIX_FMT_RGB555:
+		case V4L2_PIX_FMT_RGB555X:
+			r >>= 3;
+			g >>= 3;
+			b >>= 3;
+			break;
+		}
+
+		if (is_yuv) {
+			fh->bars[k][0] = TO_Y(r, g, b);	/* Luma */
+			fh->bars[k][1] = TO_U(r, g, b);	/* Cb */
+			fh->bars[k][2] = TO_V(r, g, b);	/* Cr */
+		} else {
+			fh->bars[k][0] = r;
+			fh->bars[k][1] = g;
+			fh->bars[k][2] = b;
+		}
+	}
+
@@ -889,2 +1026,0 @@
-#define line_buf_size(norm) (norm_maxw(norm)*(format.depth+7)/8)
-
@@ -900,0 +1037 @@
+	lock_kernel();
@@ -903,0 +1041 @@
+	unlock_kernel();
@@ -928 +1066,2 @@
-	if (retval)
+	if (retval) {
+		unlock_kernel();
@@ -929,0 +1069 @@
+	}
@@ -935 +1075 @@
-	fh->fmt      = &format;
+	fh->fmt      = &formats[0];
@@ -957,0 +1098 @@
+	unlock_kernel();
@@ -1025 +1166 @@
-				VIVI_MODULE_NAME, dev->vfd->minor);
+				VIVI_MODULE_NAME, dev->vfd->num);
@@ -1029 +1170 @@
-				VIVI_MODULE_NAME, dev->vfd->minor);
+				VIVI_MODULE_NAME, dev->vfd->num);
@@ -1169 +1310 @@
-			VIVI_MODULE_NAME, vfd->minor);
+			VIVI_MODULE_NAME, vfd->num);
--- ./projects/linux/linux-2.6.28/drivers/media/video/vivi.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/media/video/vivi.c	2009-03-24 00:12:14.000000000 +0100
@@ -1027 +1027 @@
-static int vivi_open(struct inode *inode, struct file *file)
+static int vivi_open(struct file *file)
@@ -1029 +1029 @@
-	int minor = iminor(inode);
+	int minor = video_devdata(file)->minor;
@@ -1130 +1130 @@
-static int vivi_close(struct inode *inode, struct file *file)
+static int vivi_close(struct file *file)
@@ -1136 +1136 @@
-	int minor = iminor(inode);
+	int minor = video_devdata(file)->minor;
@@ -1198 +1198 @@
-static const struct file_operations vivi_fops = {
+static const struct v4l2_file_operations vivi_fops = {
@@ -1205 +1204,0 @@
-	.compat_ioctl   = v4l_compat_ioctl32,
@@ -1207 +1205,0 @@
-	.llseek         = no_llseek,
--- ./projects/linux/linux-2.6.29/drivers/media/video/vivi.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/media/video/vivi.c	2009-06-27 11:32:32.000000000 +0200
@@ -31,4 +30,0 @@
-#ifdef CONFIG_VIDEO_V4L1_COMPAT
-/* Include V4L1 specific functions. Should be removed soon */
-#include <linux/videodev.h>
-#endif
@@ -36,3 +31,0 @@
-#include <media/videobuf-vmalloc.h>
-#include <media/v4l2-common.h>
-#include <media/v4l2-ioctl.h>
@@ -41,0 +35,4 @@
+#include <media/videobuf-vmalloc.h>
+#include <media/v4l2-device.h>
+#include <media/v4l2-ioctl.h>
+#include "font.h"
@@ -50,2 +46,0 @@
-#include "font.h"
-
@@ -53 +48 @@
-#define VIVI_MINOR_VERSION 5
+#define VIVI_MINOR_VERSION 6
@@ -58,4 +53,20 @@
-/* Declare static vars that will be used as parameters */
-static unsigned int vid_limit = 16;	/* Video memory limit, in Mb */
-static int video_nr = -1;		/* /dev/videoN, -1 for autodetect */
-static int n_devs = 1;			/* Number of virtual devices */
+MODULE_DESCRIPTION("Video Technology Magazine Virtual Video Capture Board");
+MODULE_AUTHOR("Mauro Carvalho Chehab, Ted Walther and John Sokol");
+MODULE_LICENSE("Dual BSD/GPL");
+
+static unsigned video_nr = -1;
+module_param(video_nr, uint, 0644);
+MODULE_PARM_DESC(video_nr, "videoX start number, -1 is autodetect");
+
+static unsigned n_devs = 1;
+module_param(n_devs, uint, 0644);
+MODULE_PARM_DESC(n_devs, "number of video devices to create");
+
+static unsigned debug;
+module_param(debug, uint, 0644);
+MODULE_PARM_DESC(debug, "activates debug info");
+
+static unsigned int vid_limit = 16;
+module_param(vid_limit, uint, 0644);
+MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
+
@@ -72 +83 @@
-		.flags         = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
@@ -82 +93 @@
-		.flags         = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
@@ -91 +102 @@
-		.flags         = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
@@ -100 +111 @@
-		.flags         = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
@@ -109 +120 @@
-		.flags         = 0,
+		.flags         = V4L2_CTRL_FLAG_SLIDER,
@@ -113,7 +124,2 @@
-static int qctl_regs[ARRAY_SIZE(vivi_qctrl)];
-
-#define dprintk(dev, level, fmt, arg...)				\
-	do {								\
-		if (dev->vfd->debug >= (level))				\
-			printk(KERN_DEBUG "vivi: " fmt , ## arg);	\
-	} while (0)
+#define dprintk(dev, level, fmt, arg...) \
+	v4l2_dbg(level, debug, &dev->v4l2_dev, fmt, ## arg)
@@ -208,0 +215 @@
+	struct v4l2_device 	   v4l2_dev;
@@ -225,0 +233,6 @@
+
+	/* Input Number */
+	int			   input;
+
+	/* Control 'registers' */
+	int 			   qctl_regs[ARRAY_SIZE(vivi_qctrl)];
@@ -237,0 +251 @@
+	int			   input; 	/* Input Number on bars */
@@ -257 +270,0 @@
-static u8 bars[8][3] = {
@@ -259,8 +272,61 @@
-	{204, 204, 204},  /* white */
-	{208, 208,   0},  /* ambar */
-	{  0, 206, 206},  /* cyan */
-	{  0, 239,   0},  /* green */
-	{239,   0, 239},  /* magenta */
-	{205,   0,   0},  /* red */
-	{  0,   0, 255},  /* blue */
-	{  0,   0,   0},  /* black */
+#define COLOR_WHITE	{204, 204, 204}
+#define COLOR_AMBAR	{208, 208,   0}
+#define COLOR_CIAN	{  0, 206, 206}
+#define	COLOR_GREEN	{  0, 239,   0}
+#define COLOR_MAGENTA	{239,   0, 239}
+#define COLOR_RED	{205,   0,   0}
+#define COLOR_BLUE	{  0,   0, 255}
+#define COLOR_BLACK	{  0,   0,   0}
+
+struct bar_std {
+	u8 bar[8][3];
+};
+
+/* Maximum number of bars are 10 - otherwise, the input print code
+   should be modified */
+static struct bar_std bars[] = {
+	{	/* Standard ITU-R color bar sequence */
+		{
+			COLOR_WHITE,
+			COLOR_AMBAR,
+			COLOR_CIAN,
+			COLOR_GREEN,
+			COLOR_MAGENTA,
+			COLOR_RED,
+			COLOR_BLUE,
+			COLOR_BLACK,
+		}
+	}, {
+		{
+			COLOR_WHITE,
+			COLOR_AMBAR,
+			COLOR_BLACK,
+			COLOR_WHITE,
+			COLOR_AMBAR,
+			COLOR_BLACK,
+			COLOR_WHITE,
+			COLOR_AMBAR,
+		}
+	}, {
+		{
+			COLOR_WHITE,
+			COLOR_CIAN,
+			COLOR_BLACK,
+			COLOR_WHITE,
+			COLOR_CIAN,
+			COLOR_BLACK,
+			COLOR_WHITE,
+			COLOR_CIAN,
+		}
+	}, {
+		{
+			COLOR_WHITE,
+			COLOR_GREEN,
+			COLOR_BLACK,
+			COLOR_WHITE,
+			COLOR_GREEN,
+			COLOR_BLACK,
+			COLOR_WHITE,
+			COLOR_GREEN,
+		}
+	},
@@ -268,0 +335,2 @@
+#define NUM_INPUTS ARRAY_SIZE(bars)
+
@@ -278,3 +346,4 @@
-#define TSTAMP_MIN_Y 24
-#define TSTAMP_MAX_Y TSTAMP_MIN_Y+15
-#define TSTAMP_MIN_X 64
+#define TSTAMP_MIN_Y	24
+#define TSTAMP_MAX_Y	(TSTAMP_MIN_Y + 15)
+#define TSTAMP_INPUT_X	10
+#define TSTAMP_MIN_X	(54 + TSTAMP_INPUT_X)
@@ -395 +464,3 @@
-	/* Checks if it is possible to show timestamp */
+	/* Prints input entry number */
+
+	/* Checks if it is possible to input number */
@@ -397,0 +469,18 @@
+
+	if (TSTAMP_INPUT_X + strlen(timestr) >= wmax)
+		goto end;
+
+	if (line >= TSTAMP_MIN_Y && line <= TSTAMP_MAX_Y) {
+		chr = rom8x16_bits[fh->input * 16 + line - TSTAMP_MIN_Y];
+		pos = TSTAMP_INPUT_X;
+		for (i = 0; i < 7; i++) {
+			/* Draw white font on black background */
+			if (chr & 1 << (7 - i))
+				gen_twopix(fh, basep + pos, WHITE);
+			else
+				gen_twopix(fh, basep + pos, BLACK);
+			pos += 2;
+		}
+	}
+
+	/* Checks if it is possible to show timestamp */
@@ -580 +669 @@
-		printk(KERN_ERR "vivi: kernel_thread() failed\n");
+		v4l2_err(&dev->v4l2_dev, "kernel_thread() failed\n");
@@ -722,0 +812,3 @@
+	struct vivi_fh  *fh  = priv;
+	struct vivi_dev *dev = fh->dev;
+
@@ -724,0 +817 @@
+	strlcpy(cap->bus_info, dev->v4l2_dev.name, sizeof(cap->bus_info));
@@ -810,3 +903,2 @@
-/*FIXME: This seems to be generic enough to be at videodev2 */
-static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
-					struct v4l2_format *f)
+/* precalculate color bar values to speed up rendering */
+static void precalculate_bars(struct vivi_fh *fh)
@@ -814,2 +906 @@
-	struct vivi_fh  *fh = priv;
-	struct videobuf_queue *q = &fh->vb_vidq;
+	struct vivi_dev *dev = fh->dev;
@@ -819,17 +910 @@
-	int ret = vidioc_try_fmt_vid_cap(file, fh, f);
-	if (ret < 0)
-		return (ret);
-
-	mutex_lock(&q->vb_lock);
-
-	if (videobuf_queue_is_busy(&fh->vb_vidq)) {
-		dprintk(fh->dev, 1, "%s queue busy\n", __func__);
-		ret = -EBUSY;
-		goto out;
-	}
-
-	fh->fmt           = get_format(f);
-	fh->width         = f->fmt.pix.width;
-	fh->height        = f->fmt.pix.height;
-	fh->vb_vidq.field = f->fmt.pix.field;
-	fh->type          = f->type;
+	fh->input = dev->input;
@@ -837 +911,0 @@
-	/* precalculate color bar values to speed up rendering */
@@ -839,3 +913,3 @@
-		r = bars[k][0];
-		g = bars[k][1];
-		b = bars[k][2];
+		r = bars[fh->input].bar[k][0];
+		g = bars[fh->input].bar[k][1];
+		b = bars[fh->input].bar[k][2];
@@ -873,0 +948,29 @@
+}
+
+/*FIXME: This seems to be generic enough to be at videodev2 */
+static int vidioc_s_fmt_vid_cap(struct file *file, void *priv,
+					struct v4l2_format *f)
+{
+	struct vivi_fh *fh = priv;
+	struct videobuf_queue *q = &fh->vb_vidq;
+
+	int ret = vidioc_try_fmt_vid_cap(file, fh, f);
+	if (ret < 0)
+		return ret;
+
+	mutex_lock(&q->vb_lock);
+
+	if (videobuf_queue_is_busy(&fh->vb_vidq)) {
+		dprintk(fh->dev, 1, "%s queue busy\n", __func__);
+		ret = -EBUSY;
+		goto out;
+	}
+
+	fh->fmt           = get_format(f);
+	fh->width         = f->fmt.pix.width;
+	fh->height        = f->fmt.pix.height;
+	fh->vb_vidq.field = f->fmt.pix.field;
+	fh->type          = f->type;
+
+	precalculate_bars(fh);
+
@@ -878 +981 @@
-	return (ret);
+	return ret;
@@ -953 +1056 @@
-	if (inp->index != 0)
+	if (inp->index >= NUM_INPUTS)
@@ -958 +1061 @@
-	strcpy(inp->name, "Camera");
+	sprintf(inp->name, "Camera %u", inp->index);
@@ -965 +1068,4 @@
-	*i = 0;
+	struct vivi_fh *fh = priv;
+	struct vivi_dev *dev = fh->dev;
+
+	*i = dev->input;
@@ -971 +1077,4 @@
-	if (i > 0)
+	struct vivi_fh *fh = priv;
+	struct vivi_dev *dev = fh->dev;
+
+	if (i >= NUM_INPUTS)
@@ -973,0 +1083,3 @@
+	dev->input = i;
+	precalculate_bars(fh);
+
@@ -995,0 +1108,2 @@
+	struct vivi_fh *fh = priv;
+	struct vivi_dev *dev = fh->dev;
@@ -1000,2 +1114,2 @@
-			ctrl->value = qctl_regs[i];
-			return (0);
+			ctrl->value = dev->qctl_regs[i];
+			return 0;
@@ -1008,0 +1123,2 @@
+	struct vivi_fh *fh = priv;
+	struct vivi_dev *dev = fh->dev;
@@ -1013,6 +1129,6 @@
-			if (ctrl->value < vivi_qctrl[i].minimum
-			    || ctrl->value > vivi_qctrl[i].maximum) {
-					return (-ERANGE);
-				}
-			qctl_regs[i] = ctrl->value;
-			return (0);
+			if (ctrl->value < vivi_qctrl[i].minimum ||
+			    ctrl->value > vivi_qctrl[i].maximum) {
+				return -ERANGE;
+			}
+			dev->qctl_regs[i] = ctrl->value;
+			return 0;
@@ -1029,2 +1145 @@
-	int minor = video_devdata(file)->minor;
-	struct vivi_dev *dev;
+	struct vivi_dev *dev = video_drvdata(file);
@@ -1032 +1146,0 @@
-	int i;
@@ -1035,10 +1148,0 @@
-	printk(KERN_DEBUG "vivi: open called (minor=%d)\n", minor);
-
-	lock_kernel();
-	list_for_each_entry(dev, &vivi_devlist, vivi_devlist)
-		if (dev->vfd->minor == minor)
-			goto found;
-	unlock_kernel();
-	return -ENODEV;
-
-found:
@@ -1050,2 +1154,2 @@
-		retval = -EBUSY;
-		goto unlock;
+		mutex_unlock(&dev->mutex);
+		return -EBUSY;
@@ -1054 +1158 @@
-	dprintk(dev, 1, "open minor=%d type=%s users=%d\n", minor,
+	dprintk(dev, 1, "open /dev/video%d type=%s users=%d\n", dev->vfd->num,
@@ -1062 +1165,0 @@
-		goto unlock;
@@ -1064 +1166,0 @@
-unlock:
@@ -1066,2 +1168,2 @@
-	if (retval) {
-		unlock_kernel();
+
+	if (retval)
@@ -1069 +1170,0 @@
-	}
@@ -1079,4 +1179,0 @@
-	/* Put all controls at a sane state */
-	for (i = 0; i < ARRAY_SIZE(vivi_qctrl); i++)
-		qctl_regs[i] = vivi_qctrl[i].default_value;
-
@@ -1098 +1194,0 @@
-	unlock_kernel();
@@ -1154,26 +1249,0 @@
-static int vivi_release(void)
-{
-	struct vivi_dev *dev;
-	struct list_head *list;
-
-	while (!list_empty(&vivi_devlist)) {
-		list = vivi_devlist.next;
-		list_del(list);
-		dev = list_entry(list, struct vivi_dev, vivi_devlist);
-
-		if (-1 != dev->vfd->minor) {
-			printk(KERN_INFO "%s: unregistering /dev/video%d\n",
-				VIVI_MODULE_NAME, dev->vfd->num);
-			video_unregister_device(dev->vfd);
-		} else {
-			printk(KERN_INFO "%s: releasing /dev/video%d\n",
-				VIVI_MODULE_NAME, dev->vfd->num);
-			video_device_release(dev->vfd);
-		}
-
-		kfree(dev);
-	}
-
-	return 0;
-}
-
@@ -1241,0 +1312 @@
+
@@ -1245,0 +1317,84 @@
+static int vivi_release(void)
+{
+	struct vivi_dev *dev;
+	struct list_head *list;
+
+	while (!list_empty(&vivi_devlist)) {
+		list = vivi_devlist.next;
+		list_del(list);
+		dev = list_entry(list, struct vivi_dev, vivi_devlist);
+
+		v4l2_info(&dev->v4l2_dev, "unregistering /dev/video%d\n",
+			dev->vfd->num);
+		video_unregister_device(dev->vfd);
+		v4l2_device_unregister(&dev->v4l2_dev);
+		kfree(dev);
+	}
+
+	return 0;
+}
+
+static int __init vivi_create_instance(int inst)
+{
+	struct vivi_dev *dev;
+	struct video_device *vfd;
+	int ret, i;
+
+	dev = kzalloc(sizeof(*dev), GFP_KERNEL);
+	if (!dev)
+		return -ENOMEM;
+
+	snprintf(dev->v4l2_dev.name, sizeof(dev->v4l2_dev.name),
+			"%s-%03d", VIVI_MODULE_NAME, inst);
+	ret = v4l2_device_register(NULL, &dev->v4l2_dev);
+	if (ret)
+		goto free_dev;
+
+	/* init video dma queues */
+	INIT_LIST_HEAD(&dev->vidq.active);
+	init_waitqueue_head(&dev->vidq.wq);
+
+	/* initialize locks */
+	spin_lock_init(&dev->slock);
+	mutex_init(&dev->mutex);
+
+	ret = -ENOMEM;
+	vfd = video_device_alloc();
+	if (!vfd)
+		goto unreg_dev;
+
+	*vfd = vivi_template;
+
+	ret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);
+	if (ret < 0)
+		goto rel_vdev;
+
+	video_set_drvdata(vfd, dev);
+
+	/* Set all controls to their default value. */
+	for (i = 0; i < ARRAY_SIZE(vivi_qctrl); i++)
+		dev->qctl_regs[i] = vivi_qctrl[i].default_value;
+
+	/* Now that everything is fine, let's add it to device list */
+	list_add_tail(&dev->vivi_devlist, &vivi_devlist);
+
+	snprintf(vfd->name, sizeof(vfd->name), "%s (%i)",
+			vivi_template.name, vfd->num);
+
+	if (video_nr >= 0)
+		video_nr++;
+
+	dev->vfd = vfd;
+	v4l2_info(&dev->v4l2_dev, "V4L2 device registered as /dev/video%d\n",
+			vfd->num);
+	return 0;
+
+rel_vdev:
+	video_device_release(vfd);
+unreg_dev:
+	v4l2_device_unregister(&dev->v4l2_dev);
+free_dev:
+	kfree(dev);
+	return ret;
+}
+
@@ -1250,4 +1405 @@
-   videodev supports. Since there are 64 minors for video grabbers, this is
-   currently the theoretical maximum limit. However, a further limit does
-   exist at videodev that forbids any driver to register more than 32 video
-   grabbers.
+   videodev supports, which is equal to VIDEO_NUM_DEVICES.
@@ -1257,3 +1409 @@
-	int ret = -ENOMEM, i;
-	struct vivi_dev *dev;
-	struct video_device *vfd;
+	int ret = 0, i;
@@ -1265,26 +1415,3 @@
-		dev = kzalloc(sizeof(*dev), GFP_KERNEL);
-		if (!dev)
-			break;
-
-		/* init video dma queues */
-		INIT_LIST_HEAD(&dev->vidq.active);
-		init_waitqueue_head(&dev->vidq.wq);
-
-		/* initialize locks */
-		spin_lock_init(&dev->slock);
-		mutex_init(&dev->mutex);
-
-		vfd = video_device_alloc();
-		if (!vfd) {
-			kfree(dev);
-			break;
-		}
-
-		*vfd = vivi_template;
-
-		ret = video_register_device(vfd, VFL_TYPE_GRABBER, video_nr);
-		if (ret < 0) {
-			video_device_release(vfd);
-			kfree(dev);
-
-			/* If some registers succeeded, keep driver */
+		ret = vivi_create_instance(i);
+		if (ret) {
+			/* If some instantiations succeeded, keep driver */
@@ -1293 +1419,0 @@
-
@@ -1296,13 +1421,0 @@
-
-		/* Now that everything is fine, let's add it to device list */
-		list_add_tail(&dev->vivi_devlist, &vivi_devlist);
-
-		snprintf(vfd->name, sizeof(vfd->name), "%s (%i)",
-			 vivi_template.name, vfd->minor);
-
-		if (video_nr >= 0)
-			video_nr++;
-
-		dev->vfd = vfd;
-		printk(KERN_INFO "%s: V4L2 device registered as /dev/video%d\n",
-			VIVI_MODULE_NAME, vfd->num);
@@ -1312 +1424,0 @@
-		vivi_release();
@@ -1314,2 +1426,4 @@
-	} else {
-		printk(KERN_INFO "Video Technology Magazine Virtual Video "
+		return ret;
+	}
+
+	printk(KERN_INFO "Video Technology Magazine Virtual Video "
@@ -1320,3 +1434,2 @@
-		/* n_devs will reflect the actual number of allocated devices */
-		n_devs = i;
-	}
+	/* n_devs will reflect the actual number of allocated devices */
+	n_devs = i;
@@ -1334,16 +1446,0 @@
-
-MODULE_DESCRIPTION("Video Technology Magazine Virtual Video Capture Board");
-MODULE_AUTHOR("Mauro Carvalho Chehab, Ted Walther and John Sokol");
-MODULE_LICENSE("Dual BSD/GPL");
-
-module_param(video_nr, uint, 0444);
-MODULE_PARM_DESC(video_nr, "video iminor start number");
-
-module_param(n_devs, uint, 0444);
-MODULE_PARM_DESC(n_devs, "number of video devices to create");
-
-module_param_named(debug, vivi_template.debug, int, 0444);
-MODULE_PARM_DESC(debug, "activates debug info");
-
-module_param(vid_limit, int, 0644);
-MODULE_PARM_DESC(vid_limit, "capture memory limit in megabytes");
--- ./projects/linux/linux-2.6.21/drivers/misc/asus-laptop.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/misc/asus-laptop.c	2007-07-09 01:32:17.000000000 +0200
@@ -6 +6 @@
- *  Copyright (C) 2006 Corentin Chary
+ *  Copyright (C) 2006-2007 Corentin Chary
@@ -33 +33 @@
- *
+ *  Sam Lin        - GPS support
@@ -51 +51 @@
-#define ASUS_LAPTOP_VERSION "0.40"
+#define ASUS_LAPTOP_VERSION "0.42"
@@ -84 +84,3 @@
-#define LCD_ON      0x40	//LCD backlight
+#define GLED_ON     0x40	//Gaming LED
+#define LCD_ON      0x80	//LCD backlight
+#define GPS_ON      0x100	//GPS
@@ -96,0 +99,13 @@
+/* WAPF defines the behavior of the Fn+Fx wlan key
+ * The significance of values is yet to be found, but
+ * most of the time:
+ * 0x0 will do nothing
+ * 0x1 will allow to control the device with Fn+Fx key.
+ * 0x4 will send an ACPI event (0x88) while pressing the Fn+Fx key
+ * 0x5 like 0x1 or 0x4
+ * So, if something doesn't work as you want, just try other values =)
+ */
+static uint wapf = 1;
+module_param(wapf, uint, 0644);
+MODULE_PARM_DESC(wapf, "WAPF value");
+
@@ -105,0 +121 @@
+ASUS_HANDLE(gled_set, ASUS_HOTK_PREFIX "GLED");	/* G1, G2 (probably) */
@@ -136 +152 @@
-					   S5A M5A z33A W1Jc W2V */
+					   S5A M5A z33A W1Jc W2V G1 */
@@ -149,0 +166,6 @@
+/* GPS */
+/* R2H use different handle for GPS on/off */
+ASUS_HANDLE(gps_on, ASUS_HOTK_PREFIX "SDON");	/* R2H */
+ASUS_HANDLE(gps_off, ASUS_HOTK_PREFIX "SDOF");	/* R2H */
+ASUS_HANDLE(gps_status, ASUS_HOTK_PREFIX "GPST");
+
@@ -223,0 +246 @@
+ASUS_LED(gled, "gaming");
@@ -248,15 +270,0 @@
-static int read_acpi_int(acpi_handle handle, const char *method, int *val,
-			 struct acpi_object_list *params)
-{
-	struct acpi_buffer output;
-	union acpi_object out_obj;
-	acpi_status status;
-
-	output.length = sizeof(out_obj);
-	output.pointer = &out_obj;
-
-	status = acpi_evaluate_object(handle, (char *)method, params, &output);
-	*val = out_obj.integer.value;
-	return (status == AE_OK) && (out_obj.type == ACPI_TYPE_INTEGER);
-}
-
@@ -265 +273,2 @@
-	int status;
+	ulong status;
+	acpi_status rv = AE_OK;
@@ -270,3 +279,2 @@
-	if (read_acpi_int(wireless_status_handle, NULL, &status, NULL)) {
-		return (status & mask) ? 1 : 0;
-	} else
+	rv = acpi_evaluate_integer(wireless_status_handle, NULL, NULL, &status);
+	if (ACPI_FAILURE(rv))
@@ -273,0 +282,2 @@
+	else
+		return (status & mask) ? 1 : 0;
@@ -277,0 +288,14 @@
+static int read_gps_status(void)
+{
+	ulong status;
+	acpi_status rv = AE_OK;
+
+	rv = acpi_evaluate_integer(gps_status_handle, NULL, NULL, &status);
+	if (ACPI_FAILURE(rv))
+		printk(ASUS_WARNING "Error reading GPS status\n");
+	else
+		return status ? 1 : 0;
+
+	return (hotk->status & GPS_ON) ? 1 : 0;
+}
+
@@ -283,0 +308,2 @@
+	else if (mask == GPS_ON)
+		return read_gps_status();
@@ -288 +314 @@
-static void write_status(acpi_handle handle, int out, int mask, int invert)
+static void write_status(acpi_handle handle, int out, int mask)
@@ -292 +318,2 @@
-	if (invert)		/* invert target value */
+	switch (mask) {
+	case MLED_ON:
@@ -293,0 +321,12 @@
+		break;
+	case GLED_ON:
+		out = (out & 0x1) + 1;
+		break;
+	case GPS_ON:
+		handle = (out) ? gps_on_handle : gps_off_handle;
+		out = 0x02;
+		break;
+	default:
+		out &= 0x1;
+		break;
+	}
@@ -296 +335 @@
-		printk(ASUS_WARNING " write failed\n");
+		printk(ASUS_WARNING " write failed %x\n", mask);
@@ -300 +339 @@
-#define ASUS_LED_HANDLER(object, mask, invert)				\
+#define ASUS_LED_HANDLER(object, mask)					\
@@ -310 +349 @@
-		write_status(object##_set_handle, value, (mask), (invert)); \
+		write_status(object##_set_handle, value, (mask));	\
@@ -313,4 +352,5 @@
-ASUS_LED_HANDLER(mled, MLED_ON, 1);
-ASUS_LED_HANDLER(pled, PLED_ON, 0);
-ASUS_LED_HANDLER(rled, RLED_ON, 0);
-ASUS_LED_HANDLER(tled, TLED_ON, 0);
+ASUS_LED_HANDLER(mled, MLED_ON);
+ASUS_LED_HANDLER(pled, PLED_ON);
+ASUS_LED_HANDLER(rled, RLED_ON);
+ASUS_LED_HANDLER(tled, TLED_ON);
+ASUS_LED_HANDLER(gled, GLED_ON);
@@ -341 +381 @@
-	write_status(NULL, lcd, LCD_ON, 0);
+	write_status(NULL, lcd, LCD_ON);
@@ -357 +397,2 @@
-	int value;
+	ulong value;
+	acpi_status rv = AE_OK;
@@ -359 +400,2 @@
-	if (!read_acpi_int(brightness_get_handle, NULL, &value, NULL))
+	rv = acpi_evaluate_integer(brightness_get_handle, NULL, NULL, &value);
+	if (ACPI_FAILURE(rv))
@@ -406 +448 @@
-	int temp;
+	ulong temp;
@@ -407,0 +450,2 @@
+	acpi_status rv = AE_OK;
+
@@ -421,3 +465,4 @@
-	if (read_acpi_int(hotk->handle, "SFUN", &temp, NULL))
-		len +=
-		    sprintf(page + len, "SFUN value         : 0x%04x\n", temp);
+	rv = acpi_evaluate_integer(hotk->handle, "SFUN", NULL, &temp);
+	if (!ACPI_FAILURE(rv))
+		len += sprintf(page + len, "SFUN value         : 0x%04x\n",
+			       (uint) temp);
@@ -431,3 +476,4 @@
-	if (read_acpi_int(hotk->handle, "ASYM", &temp, NULL))
-		len +=
-		    sprintf(page + len, "ASYM value         : 0x%04x\n", temp);
+	rv = acpi_evaluate_integer(hotk->handle, "ASYM", NULL, &temp);
+	if (!ACPI_FAILURE(rv))
+		len += sprintf(page + len, "ASYM value         : 0x%04x\n",
+			       (uint) temp);
@@ -468 +514 @@
-			    acpi_handle handle, int mask, int invert)
+			    acpi_handle handle, int mask)
@@ -477 +523 @@
-	write_status(handle, out, mask, invert);
+	write_status(handle, out, mask);
@@ -518 +564 @@
-	return store_status(buf, count, wl_switch_handle, WL_ON, 0);
+	return store_status(buf, count, wl_switch_handle, WL_ON);
@@ -534 +580 @@
-	return store_status(buf, count, bt_switch_handle, BT_ON, 0);
+	return store_status(buf, count, bt_switch_handle, BT_ON);
@@ -550 +596,2 @@
-	int value = 0;
+	ulong value = 0;
+	acpi_status rv = AE_OK;
@@ -555 +602,3 @@
-		if (!read_acpi_int(display_get_handle, NULL, &value, NULL))
+		rv = acpi_evaluate_integer(display_get_handle, NULL,
+					   NULL, &value);
+		if (ACPI_FAILURE(rv))
@@ -647,0 +697,15 @@
+/*
+ * GPS
+ */
+static ssize_t show_gps(struct device *dev,
+			struct device_attribute *attr, char *buf)
+{
+	return sprintf(buf, "%d\n", read_status(GPS_ON));
+}
+
+static ssize_t store_gps(struct device *dev, struct device_attribute *attr,
+			 const char *buf, size_t count)
+{
+	return store_status(buf, count, NULL, GPS_ON);
+}
+
@@ -659 +723 @@
-		write_status(NULL, 1, LCD_ON, 0);
+		write_status(NULL, 1, LCD_ON);
@@ -662 +726 @@
-		write_status(NULL, 0, LCD_ON, 0);
+		write_status(NULL, 0, LCD_ON);
@@ -695,0 +760 @@
+static ASUS_CREATE_DEVICE_ATTR(gps);
@@ -704,0 +770 @@
+	&dev_attr_gps.attr,
@@ -743,0 +810,3 @@
+
+	if (gps_status_handle && gps_on_handle && gps_off_handle)
+		ASUS_SET_DEVICE_ATTR(gps, 0644, show_gps, store_gps);
@@ -774 +843 @@
-	int bsts_result, hwrs_result;
+	ulong bsts_result, hwrs_result;
@@ -797 +866,3 @@
-	if (!read_acpi_int(hotk->handle, "BSTS", &bsts_result, NULL))
+	status =
+	    acpi_evaluate_integer(hotk->handle, "BSTS", NULL, &bsts_result);
+	if (ACPI_FAILURE(status))
@@ -801 +872,4 @@
-		       bsts_result);
+		       (uint) bsts_result);
+
+	/* This too ... */
+	write_acpi_int(hotk->handle, "CWAP", wapf, NULL);
@@ -833,0 +908 @@
+	ASUS_HANDLE_INIT(gled_set);
@@ -843 +918,3 @@
-	if (!read_acpi_int(hotk->handle, "HRWS", &hwrs_result, NULL))
+	status =
+	    acpi_evaluate_integer(hotk->handle, "HRWS", NULL, &hwrs_result);
+	if (ACPI_FAILURE(status))
@@ -863 +940 @@
-	if (ASUS_HANDLE_INIT(ls_switch))
+	if (!ASUS_HANDLE_INIT(ls_switch))
@@ -865,0 +943,4 @@
+	ASUS_HANDLE_INIT(gps_on);
+	ASUS_HANDLE_INIT(gps_off);
+	ASUS_HANDLE_INIT(gps_status);
+
@@ -923 +1004 @@
-	status = acpi_install_notify_handler(hotk->handle, ACPI_SYSTEM_NOTIFY,
+	status = acpi_install_notify_handler(hotk->handle, ACPI_ALL_NOTIFY,
@@ -931,2 +1012,6 @@
-	write_status(bt_switch_handle, 1, BT_ON, 0);
-	write_status(wl_switch_handle, 1, WL_ON, 0);
+	write_status(bt_switch_handle, 1, BT_ON);
+	write_status(wl_switch_handle, 1, WL_ON);
+
+	/* If the h/w switch is off, we need to check the real status */
+	write_status(NULL, read_status(BT_ON), BT_ON);
+	write_status(NULL, read_status(WL_ON), WL_ON);
@@ -935 +1020 @@
-	write_status(NULL, 1, LCD_ON, 0);
+	write_status(NULL, 1, LCD_ON);
@@ -949,0 +1035,3 @@
+	/* GPS is on by default */
+	write_status(NULL, 1, GPS_ON);
+
@@ -966 +1054 @@
-	status = acpi_remove_notify_handler(hotk->handle, ACPI_SYSTEM_NOTIFY,
+	status = acpi_remove_notify_handler(hotk->handle, ACPI_ALL_NOTIFY,
@@ -993,0 +1082 @@
+	ASUS_LED_UNREGISTER(gled);
@@ -1064,0 +1154,4 @@
+	rv = ASUS_LED_REGISTER(gled, dev);
+	if (rv)
+		return rv;
+
--- ./projects/linux/linux-2.6.22/drivers/misc/asus-laptop.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/misc/asus-laptop.c	2007-10-09 22:31:38.000000000 +0200
@@ -56 +55,0 @@
-#define ASUS_HOTK_HID           "ATK0100"
@@ -199,0 +199,6 @@
+static const struct acpi_device_id asus_device_ids[] = {
+	{"ATK0100", 0},
+	{"", 0},
+};
+MODULE_DEVICE_TABLE(acpi, asus_device_ids);
+
@@ -205 +210 @@
-	.ids = ASUS_HOTK_HID,
+	.ids = asus_device_ids,
@@ -730 +735 @@
-	acpi_bus_generate_event(hotk->device, event,
+	acpi_bus_generate_proc_event(hotk->device, event,
@@ -740,2 +745 @@
-			.mode = 0,					\
-			.owner = THIS_MODULE },				\
+			.mode = 0 },					\
@@ -983 +987 @@
-	hotk = kmalloc(sizeof(struct asus_hotk), GFP_KERNEL);
+	hotk = kzalloc(sizeof(struct asus_hotk), GFP_KERNEL);
@@ -986 +989,0 @@
-	memset(hotk, 0, sizeof(struct asus_hotk));
@@ -1072,2 +1075 @@
-	if(object##_led.class_dev				\
-	   && !IS_ERR(object##_led.class_dev))			\
+	if (object##_led.dev)					\
@@ -1077,0 +1080 @@
+	destroy_workqueue(led_workqueue);
@@ -1083,2 +1085,0 @@
-
-	destroy_workqueue(led_workqueue);
@@ -1140 +1141 @@
-		return rv;
+		goto out;
@@ -1144 +1145 @@
-		return rv;
+		goto out1;
@@ -1148 +1149 @@
-		return rv;
+		goto out2;
@@ -1152 +1153 @@
-		return rv;
+		goto out3;
@@ -1156 +1157 @@
-		return rv;
+		goto out4;
@@ -1160 +1161 @@
-		return -ENOMEM;
+		goto out5;
@@ -1162,0 +1164,13 @@
+out5:
+	rv = -ENOMEM;
+	ASUS_LED_UNREGISTER(gled);
+out4:
+	ASUS_LED_UNREGISTER(pled);
+out3:
+	ASUS_LED_UNREGISTER(rled);
+out2:
+	ASUS_LED_UNREGISTER(tled);
+out1:
+	ASUS_LED_UNREGISTER(mled);
+out:
+	return rv;
--- ./projects/linux/linux-2.6.24/drivers/misc/asus-laptop.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/misc/asus-laptop.c	2008-04-17 04:49:44.000000000 +0200
@@ -36 +35,0 @@
-#include <linux/autoconf.h>
@@ -243 +242 @@
-		.name           = "asus:" ledname,			\
+		.name           = "asus::" ledname,			\
@@ -258 +257 @@
- * returns 1 if write is successful, 0 else.
+ * returns 0 if write is successful, -1 else.
@@ -266,0 +266,3 @@
+	if (!handle)
+		return 0;
+
@@ -273 +275,4 @@
-	return (status == AE_OK);
+	if (status == AE_OK)
+		return 0;
+	else
+		return -1;
@@ -325 +330 @@
-		out = !out & 0x1;
+		out = !(out & 0x1);
@@ -339 +344 @@
-	if (handle && !write_acpi_int(handle, NULL, out, NULL))
+	if (write_acpi_int(handle, NULL, out, NULL))
@@ -419 +424 @@
-	if (!write_acpi_int(brightness_set_handle, NULL, value, NULL)) {
+	if (write_acpi_int(brightness_set_handle, NULL, value, NULL)) {
@@ -549 +554 @@
-		if (!write_acpi_int(ledd_set_handle, NULL, value, NULL))
+		if (write_acpi_int(ledd_set_handle, NULL, value, NULL))
@@ -594 +599 @@
-	if (!write_acpi_int(display_set_handle, NULL, value, NULL))
+	if (write_acpi_int(display_set_handle, NULL, value, NULL))
@@ -651 +656 @@
-	if (!write_acpi_int(ls_switch_handle, NULL, value, NULL))
+	if (write_acpi_int(ls_switch_handle, NULL, value, NULL))
@@ -676 +681 @@
-	if (!write_acpi_int(ls_level_handle, NULL, value, NULL))
+	if (write_acpi_int(ls_level_handle, NULL, value, NULL))
@@ -864 +869 @@
-	if (!write_acpi_int(hotk->handle, "INIT", 0, &buffer)) {
+	if (write_acpi_int(hotk->handle, "INIT", 0, &buffer)) {
--- ./projects/linux/linux-2.6.27/drivers/misc/asus-laptop.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/misc/asus-laptop.c	2008-12-25 00:26:37.000000000 +0100
@@ -141,0 +142 @@
+	    "\\_SB.PCI0.LPCB.EC0._Q0E", /* P30/P35 */
@@ -283 +284 @@
-	ulong status;
+	unsigned long long status;
@@ -300 +301 @@
-	ulong status;
+	unsigned long long status;
@@ -353 +354 @@
-		object##_led_wk = value;				\
+		object##_led_wk = (value > 0) ? 1 : 0;			\
@@ -407 +408 @@
-	ulong value;
+	unsigned long long value;
@@ -458 +459 @@
-	ulong temp;
+	unsigned long long temp;
@@ -606 +607 @@
-	ulong value = 0;
+	unsigned long long value = 0;
@@ -852 +853 @@
-	ulong bsts_result, hwrs_result;
+	unsigned long long bsts_result, hwrs_result;
@@ -999 +1000 @@
-	acpi_driver_data(device) = hotk;
+	device->driver_data = hotk;
@@ -1210,3 +1211,7 @@
-	result = asus_backlight_init(dev);
-	if (result)
-		goto fail_backlight;
+	if (!acpi_video_backlight_support()) {
+		result = asus_backlight_init(dev);
+		if (result)
+			goto fail_backlight;
+	} else
+		printk(ASUS_INFO "Brightness ignored, must be controlled by "
+		       "ACPI video driver\n");
--- ./projects/linux/linux-2.6.14/drivers/net/tokenring/olympic.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/net/tokenring/olympic.c	2006-01-03 04:21:10.000000000 +0100
@@ -1104 +1104 @@
-		t = schedule_timeout(60*HZ); 
+		t = schedule_timeout_interruptible(60*HZ);
--- ./projects/linux/linux-2.6.16/drivers/net/tokenring/olympic.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/net/tokenring/olympic.c	2006-06-18 03:49:35.000000000 +0200
@@ -102,0 +103 @@
+#include <linux/jiffies.h>
@@ -310 +311 @@
-		if(jiffies-t > 40*HZ) {
+		if(time_after(jiffies, t + 40*HZ)) {
@@ -362 +363 @@
-			if(jiffies-t > 2*HZ) { 
+			if(time_after(jiffies, t + 2*HZ)) {
@@ -376 +377 @@
-		if(jiffies-t > 15*HZ) {
+		if(time_after(jiffies, t + 15*HZ)) {
@@ -522 +523 @@
-			if ((jiffies-t) > 10*HZ) { 
+			if (time_after(jiffies, t + 10*HZ)) {
--- ./projects/linux/linux-2.6.17/drivers/net/tokenring/olympic.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/net/tokenring/olympic.c	2006-09-20 05:42:06.000000000 +0200
@@ -83 +82,0 @@
-#include <linux/config.h>
@@ -220 +219 @@
-		goto op_free_dev;
+		goto op_release_dev;
@@ -285 +283,0 @@
-op_free_dev:
@@ -286,0 +285 @@
+op_release_dev:
@@ -449 +448 @@
-	if(request_irq(dev->irq, &olympic_interrupt, SA_SHIRQ , "olympic", dev)) {
+	if(request_irq(dev->irq, &olympic_interrupt, IRQF_SHARED , "olympic", dev)) {
--- ./projects/linux/linux-2.6.18/drivers/net/tokenring/olympic.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/net/tokenring/olympic.c	2006-11-29 22:57:37.000000000 +0100
@@ -188 +188 @@
-static irqreturn_t olympic_interrupt(int irq, void *dev_id, struct pt_regs *regs);
+static irqreturn_t olympic_interrupt(int irq, void *dev_id);
@@ -928 +928 @@
-static irqreturn_t olympic_interrupt(int irq, void *dev_id, struct pt_regs *regs) 
+static irqreturn_t olympic_interrupt(int irq, void *dev_id) 
--- ./projects/linux/linux-2.6.19/drivers/net/tokenring/olympic.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/net/tokenring/olympic.c	2007-02-04 19:44:54.000000000 +0100
@@ -1774 +1774 @@
-	return pci_module_init (&olympic_driver) ; 
+	return pci_register_driver(&olympic_driver) ;
--- ./projects/linux/linux-2.6.21/drivers/net/tokenring/olympic.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/net/tokenring/olympic.c	2007-07-09 01:32:17.000000000 +0200
@@ -817,2 +816,0 @@
-					skb->dev = dev ; 
-
@@ -850 +848,3 @@
-							memcpy(skb_put(skb,length-4),olympic_priv->rx_ring_skb[rx_ring_last_received]->data,length-4) ; 
+							skb_copy_from_linear_data(olympic_priv->rx_ring_skb[rx_ring_last_received],
+								      skb_put(skb,length - 4),
+								      length - 4);
@@ -867 +867,3 @@
-							memcpy(skb_put(skb, cpy_length), olympic_priv->rx_ring_skb[rx_ring_last_received]->data, cpy_length) ;
+							skb_copy_from_linear_data(olympic_priv->rx_ring_skb[rx_ring_last_received],
+								      skb_put(skb, cpy_length),
+								      cpy_length);
@@ -1442,0 +1445,2 @@
+		mac_frame->protocol = tr_type_trans(mac_frame, dev);
+
@@ -1446 +1450 @@
-			mac_hdr = (struct trh_hdr *)mac_frame->data ; 
+			mac_hdr = tr_hdr(mac_frame);
@@ -1450,3 +1454 @@
-		mac_frame->dev = dev ; 
-		mac_frame->protocol = tr_type_trans(mac_frame,dev);
-		netif_rx(mac_frame) ; 	
+		netif_rx(mac_frame);
--- ./projects/linux/linux-2.6.23/drivers/net/tokenring/olympic.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/net/tokenring/olympic.c	2008-01-24 23:58:37.000000000 +0100
@@ -104,0 +105 @@
+#include <net/net_namespace.h>
@@ -222 +223 @@
-	olympic_priv = dev->priv ;
+	olympic_priv = netdev_priv(dev) ;
@@ -229 +230 @@
-	printk(KERN_INFO "pci_device: %p, dev:%p, dev->priv: %p\n", pdev, dev, dev->priv);
+	printk(KERN_INFO "pci_device: %p, dev:%p, dev->priv: %p\n", pdev, dev, netdev_priv(dev));
@@ -263 +263,0 @@
-	SET_MODULE_OWNER(dev) ; 
@@ -271 +271 @@
-		strcpy(proc_name,"net/olympic_") ; 
+		strcpy(proc_name,"olympic_") ;
@@ -273 +273 @@
-		create_proc_read_entry(proc_name,0,NULL,olympic_proc_info,(void *)dev) ; 
+		create_proc_read_entry(proc_name,0,init_net.proc_net,olympic_proc_info,(void *)dev) ;
@@ -300 +300 @@
-    	olympic_priv=(struct olympic_private *)dev->priv;
+	olympic_priv=netdev_priv(dev);
@@ -420,0 +421,2 @@
+	memcpy_fromio(&dev->dev_addr[0], adapter_addr,6);
+
@@ -422,3 +424,4 @@
-	printk("adapter address: %02x:%02x:%02x:%02x:%02x:%02x\n",
-			readb(adapter_addr), readb(adapter_addr+1),readb(adapter_addr+2),
-			readb(adapter_addr+3),readb(adapter_addr+4),readb(adapter_addr+5));
+ {
+	DECLARE_MAC_BUF(mac);
+	printk("adapter address: %s\n", print_mac(mac, dev->dev_addr));
+ }
@@ -427,2 +429,0 @@
-	memcpy_fromio(&dev->dev_addr[0], adapter_addr,6);
-
@@ -438 +439 @@
-	struct olympic_private *olympic_priv=(struct olympic_private *)dev->priv;
+	struct olympic_private *olympic_priv=netdev_priv(dev);
@@ -442,0 +444 @@
+	DECLARE_MAC_BUF(mac);
@@ -570,8 +572,2 @@
-			printk(KERN_WARNING "%s: Invalid LAA: %02x:%02x:%02x:%02x:%02x:%02x\n",
-				dev->name, 
-				olympic_priv->olympic_laa[0],
-				olympic_priv->olympic_laa[1],
-				olympic_priv->olympic_laa[2],
-				olympic_priv->olympic_laa[3],
-				olympic_priv->olympic_laa[4],
-				olympic_priv->olympic_laa[5]) ; 
+			printk(KERN_WARNING "%s: Invalid LAA: %s\n",
+			       dev->name, print_mac(mac, olympic_priv->olympic_laa));
@@ -707,12 +703,11 @@
-		u8 __iomem *oat ; 
-		u8 __iomem *opt ; 
-		oat = (olympic_priv->olympic_lap + olympic_priv->olympic_addr_table_addr) ; 
-		opt = (olympic_priv->olympic_lap + olympic_priv->olympic_parms_addr) ; 
-
-		printk("%s: Node Address: %02x:%02x:%02x:%02x:%02x:%02x\n",dev->name, 
-			readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)), 
-			readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)+1),
-			readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)+2),
-			readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)+3),
-			readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)+4),
-			readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)+5));
+		u8 __iomem *oat;
+		u8 __iomem *opt;
+		int i;
+		u8 addr[6];
+		DECLARE_MAC_BUF(mac);
+		oat = (olympic_priv->olympic_lap + olympic_priv->olympic_addr_table_addr);
+		opt = (olympic_priv->olympic_lap + olympic_priv->olympic_parms_addr);
+
+		for (i = 0; i < 6; i++)
+			addr[i] = readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)+i);
+		printk("%s: Node Address: %s\n",dev->name, print_mac(mac, addr));
@@ -724,7 +719,4 @@
-		printk("%s: NAUN Address: %02x:%02x:%02x:%02x:%02x:%02x\n",dev->name, 
-			readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)),
-			readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)+1),
-			readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)+2),
-			readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)+3),
-			readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)+4),
-			readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)+5));
+
+		for (i = 0; i < 6; i++)
+			addr[i] = readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)+i);
+		printk("%s: NAUN Address: %s\n",dev->name, print_mac(mac, addr));
@@ -758 +750 @@
-	struct olympic_private *olympic_priv=(struct olympic_private *)dev->priv;
+	struct olympic_private *olympic_priv=netdev_priv(dev);
@@ -900 +892 @@
-	struct olympic_private *olympic_priv=(struct olympic_private *)dev->priv;
+	struct olympic_private *olympic_priv=netdev_priv(dev);
@@ -933 +925 @@
-	struct olympic_private *olympic_priv=(struct olympic_private *)dev->priv;
+	struct olympic_private *olympic_priv=netdev_priv(dev);
@@ -1049 +1041 @@
-	struct olympic_private *olympic_priv=(struct olympic_private *)dev->priv;
+	struct olympic_private *olympic_priv=netdev_priv(dev);
@@ -1080 +1072 @@
-	struct olympic_private *olympic_priv=(struct olympic_private *)dev->priv;
+	struct olympic_private *olympic_priv=netdev_priv(dev);
@@ -1150 +1142 @@
-	struct olympic_private *olympic_priv = (struct olympic_private *) dev->priv ; 
+	struct olympic_private *olympic_priv = netdev_priv(dev);
@@ -1218 +1210 @@
-	struct olympic_private *olympic_priv = (struct olympic_private *) dev->priv ; 
+	struct olympic_private *olympic_priv = netdev_priv(dev);
@@ -1364 +1356 @@
-	olympic_priv=(struct olympic_private *) dev->priv;
+	olympic_priv=netdev_priv(dev);
@@ -1371 +1363 @@
-	struct olympic_private *olympic_priv = (struct olympic_private *)dev->priv ; 
+	struct olympic_private *olympic_priv = netdev_priv(dev);
@@ -1392 +1384 @@
-	struct olympic_private *olympic_priv = (struct olympic_private *) dev->priv;
+	struct olympic_private *olympic_priv = netdev_priv(dev);
@@ -1448,2 +1440,3 @@
-			struct trh_hdr *mac_hdr ; 
-			printk(KERN_WARNING "%s: Received MAC Frame, details: \n",dev->name) ;
+			struct trh_hdr *mac_hdr;
+			DECLARE_MAC_BUF(mac);
+			printk(KERN_WARNING "%s: Received MAC Frame, details: \n",dev->name);
@@ -1451,2 +1444,4 @@
-			printk(KERN_WARNING "%s: MAC Frame Dest. Addr: %02x:%02x:%02x:%02x:%02x:%02x \n", dev->name , mac_hdr->daddr[0], mac_hdr->daddr[1], mac_hdr->daddr[2], mac_hdr->daddr[3], mac_hdr->daddr[4], mac_hdr->daddr[5]) ; 
-			printk(KERN_WARNING "%s: MAC Frame Srce. Addr: %02x:%02x:%02x:%02x:%02x:%02x \n", dev->name , mac_hdr->saddr[0], mac_hdr->saddr[1], mac_hdr->saddr[2], mac_hdr->saddr[3], mac_hdr->saddr[4], mac_hdr->saddr[5]) ; 
+			printk(KERN_WARNING "%s: MAC Frame Dest. Addr: %s\n",
+			       dev->name, print_mac(mac, mac_hdr->daddr));
+			printk(KERN_WARNING "%s: MAC Frame Srce. Addr: %s\n",
+			       dev->name, print_mac(mac, mac_hdr->saddr));
@@ -1578 +1573 @@
-	struct olympic_private *olympic_priv = (struct olympic_private *) dev->priv ; 
+	struct olympic_private *olympic_priv = netdev_priv(dev);
@@ -1618 +1613 @@
-	struct olympic_private *olympic_priv = (struct olympic_private *) dev->priv;
+	struct olympic_private *olympic_priv = netdev_priv(dev);
@@ -1640 +1635 @@
-	struct olympic_private *olympic_priv=(struct olympic_private *)dev->priv;
+	struct olympic_private *olympic_priv=netdev_priv(dev);
@@ -1647 +1642,6 @@
-	
+	u8 addr[6];
+	u8 addr2[6];
+	int i;
+	DECLARE_MAC_BUF(mac);
+	DECLARE_MAC_BUF(mac2);
+
@@ -1653 +1653,4 @@
-	size += sprintf(buffer+size, "%6s: %02x:%02x:%02x:%02x:%02x:%02x : %02x:%02x:%02x:%02x:%02x:%02x : %02x:%02x:%02x:%02x\n",
+	for (i = 0 ; i < 6 ; i++)
+		addr[i] = readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr) + i);
+
+	size += sprintf(buffer+size, "%6s: %s : %s : %02x:%02x:%02x:%02x\n",
@@ -1655,12 +1658,2 @@
-           dev->dev_addr[0],
-	   dev->dev_addr[1],
-	   dev->dev_addr[2],
- 	   dev->dev_addr[3],
-	   dev->dev_addr[4],
-	   dev->dev_addr[5],
-	   readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)), 
-	   readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)+1),
-	   readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)+2),
-	   readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)+3),
-	   readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)+4),
-	   readb(oat+offsetof(struct olympic_adapter_addr_table,node_addr)+5),
+	   print_mac(mac, dev->dev_addr),
+	   print_mac(mac2, addr),
@@ -1676,2 +1669,7 @@
-	   
-	size += sprintf(buffer+size, "%6s: %02x:%02x:%02x:%02x   : %02x:%02x:%02x:%02x:%02x:%02x : %02x:%02x:%02x:%02x:%02x:%02x : %04x   : %04x     :  %04x    :\n",
+
+	for (i = 0 ; i < 6 ; i++)
+		addr[i] = readb(opt+offsetof(struct olympic_parameters_table, up_node_addr) + i);
+	for (i = 0 ; i < 6 ; i++)
+		addr2[i] =  readb(opt+offsetof(struct olympic_parameters_table, poll_addr) + i);
+
+	size += sprintf(buffer+size, "%6s: %02x:%02x:%02x:%02x   : %s : %s : %04x   : %04x     :  %04x    :\n",
@@ -1683,12 +1681,2 @@
-	  readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)),
-	  readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)+1),
-	  readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)+2),
-	  readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)+3),
-	  readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)+4),
-	  readb(opt+offsetof(struct olympic_parameters_table, up_node_addr)+5),
-	  readb(opt+offsetof(struct olympic_parameters_table, poll_addr)),
-	  readb(opt+offsetof(struct olympic_parameters_table, poll_addr)+1),
-	  readb(opt+offsetof(struct olympic_parameters_table, poll_addr)+2),
-	  readb(opt+offsetof(struct olympic_parameters_table, poll_addr)+3),
-	  readb(opt+offsetof(struct olympic_parameters_table, poll_addr)+4),
-	  readb(opt+offsetof(struct olympic_parameters_table, poll_addr)+5),
+	  print_mac(mac, addr),
+	  print_mac(mac2, addr2),
@@ -1702 +1690,3 @@
-	size += sprintf(buffer+size, "%6s: %02x:%02x:%02x:%02x:%02x:%02x : %04x  : %04x   : %04x   : %04x   : %04x    :     %04x     : \n",
+	for (i = 0 ; i < 6 ; i++)
+		addr[i] = readb(opt+offsetof(struct olympic_parameters_table, source_addr) + i);
+	size += sprintf(buffer+size, "%6s: %s : %04x  : %04x   : %04x   : %04x   : %04x    :     %04x     : \n",
@@ -1704,6 +1694 @@
-	  readb(opt+offsetof(struct olympic_parameters_table, source_addr)),
-	  readb(opt+offsetof(struct olympic_parameters_table, source_addr)+1),
-	  readb(opt+offsetof(struct olympic_parameters_table, source_addr)+2),
-	  readb(opt+offsetof(struct olympic_parameters_table, source_addr)+3),
-	  readb(opt+offsetof(struct olympic_parameters_table, source_addr)+4),
-	  readb(opt+offsetof(struct olympic_parameters_table, source_addr)+5),
+	  print_mac(mac, addr),
@@ -1720 +1705,3 @@
-	size += sprintf(buffer+size, "%6s:                :  %02x  :  %02x  : %02x:%02x:%02x:%02x:%02x:%02x : %02x:%02x:%02x:%02x    : \n",
+	for (i = 0 ; i < 6 ; i++)
+		addr[i] = readb(opt+offsetof(struct olympic_parameters_table, beacon_naun) + i);
+	size += sprintf(buffer+size, "%6s:                :  %02x  :  %02x  : %s : %02x:%02x:%02x:%02x    : \n",
@@ -1724,6 +1711 @@
-	  readb(opt+offsetof(struct olympic_parameters_table, beacon_naun)),
-	  readb(opt+offsetof(struct olympic_parameters_table, beacon_naun)+1),
-	  readb(opt+offsetof(struct olympic_parameters_table, beacon_naun)+2),
-	  readb(opt+offsetof(struct olympic_parameters_table, beacon_naun)+3),
-	  readb(opt+offsetof(struct olympic_parameters_table, beacon_naun)+4),
-	  readb(opt+offsetof(struct olympic_parameters_table, beacon_naun)+5),
+	  print_mac(mac, addr),
@@ -1751 +1733 @@
-	struct olympic_private *olympic_priv=(struct olympic_private *)dev->priv;
+	struct olympic_private *olympic_priv=netdev_priv(dev);
@@ -1755 +1737 @@
-		strcpy(proc_name,"net/olympic_") ; 
+		strcpy(proc_name,"olympic_") ;
@@ -1757 +1739 @@
-		remove_proc_entry(proc_name,NULL); 
+		remove_proc_entry(proc_name,init_net.proc_net);
--- ./projects/linux/linux-2.6.24/drivers/net/tokenring/olympic.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/net/tokenring/olympic.c	2008-04-17 04:49:44.000000000 +0200
@@ -120 +120 @@
-static char version[] __devinitdata = 
+static char version[] =
@@ -293 +293 @@
-static int __devinit olympic_init(struct net_device *dev)
+static int olympic_init(struct net_device *dev)
@@ -360 +360 @@
-		while (!readl(olympic_mmio+CLKCTL) & CLKCTL_PAUSE) { 
+		while (!(readl(olympic_mmio+CLKCTL) & CLKCTL_PAUSE)) {
@@ -437 +437 @@
-static int olympic_open(struct net_device *dev) 
+static int olympic_open(struct net_device *dev)
@@ -674 +674 @@
-		olympic_priv->olympic_tx_ring[i].buffer=0xdeadbeef;
+		olympic_priv->olympic_tx_ring[i].buffer=cpu_to_le32(0xdeadbeef);
@@ -900 +900 @@
-		if (olympic_priv->olympic_rx_ring[olympic_priv->rx_status_last_received].buffer != 0xdeadbeef) {
+		if (olympic_priv->olympic_rx_ring[olympic_priv->rx_status_last_received].buffer != cpu_to_le32(0xdeadbeef)) {
@@ -986 +986 @@
-				olympic_priv->olympic_tx_ring[olympic_priv->tx_ring_last_status].buffer=0xdeadbeef;
+				olympic_priv->olympic_tx_ring[olympic_priv->tx_ring_last_status].buffer=cpu_to_le32(0xdeadbeef);
@@ -1435 +1435 @@
-		} while (next_ptr && (buf_ptr=olympic_priv->olympic_lap + ntohs(next_ptr)));
+		} while (next_ptr && (buf_ptr=olympic_priv->olympic_lap + swab16(next_ptr)));
@@ -1441 +1440,0 @@
-			DECLARE_MAC_BUF(mac);
@@ -1444,4 +1443,10 @@
-			printk(KERN_WARNING "%s: MAC Frame Dest. Addr: %s\n",
-			       dev->name, print_mac(mac, mac_hdr->daddr));
-			printk(KERN_WARNING "%s: MAC Frame Srce. Addr: %s\n",
-			       dev->name, print_mac(mac, mac_hdr->saddr));
+			printk(KERN_WARNING "%s: MAC Frame Dest. Addr: "
+			       MAC_FMT " \n", dev->name,
+			       mac_hdr->daddr[0], mac_hdr->daddr[1],
+			       mac_hdr->daddr[2], mac_hdr->daddr[3],
+			       mac_hdr->daddr[4], mac_hdr->daddr[5]);
+			printk(KERN_WARNING "%s: MAC Frame Srce. Addr: "
+			       MAC_FMT " \n", dev->name,
+			       mac_hdr->saddr[0], mac_hdr->saddr[1],
+			       mac_hdr->saddr[2], mac_hdr->saddr[3],
+			       mac_hdr->saddr[4], mac_hdr->saddr[5]);
--- ./projects/linux/linux-2.6.28/drivers/net/tokenring/olympic.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/net/tokenring/olympic.c	2009-03-24 00:12:14.000000000 +0100
@@ -424,4 +424 @@
- {
-	DECLARE_MAC_BUF(mac);
-	printk("adapter address: %s\n", print_mac(mac, dev->dev_addr));
- }
+	printk("adapter address: %pM\n", dev->dev_addr);
@@ -444 +440,0 @@
-	DECLARE_MAC_BUF(mac);
@@ -572,2 +568,2 @@
-			printk(KERN_WARNING "%s: Invalid LAA: %s\n",
-			       dev->name, print_mac(mac, olympic_priv->olympic_laa));
+			printk(KERN_WARNING "%s: Invalid LAA: %pM\n",
+			       dev->name, olympic_priv->olympic_laa);
@@ -707 +702,0 @@
-		DECLARE_MAC_BUF(mac);
@@ -713 +708 @@
-		printk("%s: Node Address: %s\n",dev->name, print_mac(mac, addr));
+		printk("%s: Node Address: %pM\n", dev->name, addr);
@@ -722 +717 @@
-		printk("%s: NAUN Address: %s\n",dev->name, print_mac(mac, addr));
+		printk("%s: NAUN Address: %pM\n", dev->name, addr);
@@ -870 +864,0 @@
-					dev->last_rx = jiffies ; 
@@ -1443,10 +1437,4 @@
-			printk(KERN_WARNING "%s: MAC Frame Dest. Addr: "
-			       MAC_FMT " \n", dev->name,
-			       mac_hdr->daddr[0], mac_hdr->daddr[1],
-			       mac_hdr->daddr[2], mac_hdr->daddr[3],
-			       mac_hdr->daddr[4], mac_hdr->daddr[5]);
-			printk(KERN_WARNING "%s: MAC Frame Srce. Addr: "
-			       MAC_FMT " \n", dev->name,
-			       mac_hdr->saddr[0], mac_hdr->saddr[1],
-			       mac_hdr->saddr[2], mac_hdr->saddr[3],
-			       mac_hdr->saddr[4], mac_hdr->saddr[5]);
+			printk(KERN_WARNING "%s: MAC Frame Dest. Addr: %pM\n",
+			       dev->name, mac_hdr->daddr);
+			printk(KERN_WARNING "%s: MAC Frame Srce. Addr: %pM\n",
+			       dev->name, mac_hdr->saddr);
@@ -1455 +1442,0 @@
-		dev->last_rx = jiffies;
@@ -1650,2 +1636,0 @@
-	DECLARE_MAC_BUF(mac);
-	DECLARE_MAC_BUF(mac2);
@@ -1661 +1646 @@
-	size += sprintf(buffer+size, "%6s: %s : %s : %02x:%02x:%02x:%02x\n",
+	size += sprintf(buffer+size, "%6s: %pM : %pM : %02x:%02x:%02x:%02x\n",
@@ -1663,2 +1648 @@
-	   print_mac(mac, dev->dev_addr),
-	   print_mac(mac2, addr),
+	   dev->dev_addr, addr,
@@ -1680 +1664 @@
-	size += sprintf(buffer+size, "%6s: %02x:%02x:%02x:%02x   : %s : %s : %04x   : %04x     :  %04x    :\n",
+	size += sprintf(buffer+size, "%6s: %02x:%02x:%02x:%02x   : %pM : %pM : %04x   : %04x     :  %04x    :\n",
@@ -1686,2 +1670 @@
-	  print_mac(mac, addr),
-	  print_mac(mac2, addr2),
+	  addr, addr2,
@@ -1697,3 +1680,2 @@
-	size += sprintf(buffer+size, "%6s: %s : %04x  : %04x   : %04x   : %04x   : %04x    :     %04x     : \n",
-	  dev->name,
-	  print_mac(mac, addr),
+	size += sprintf(buffer+size, "%6s: %pM : %04x  : %04x   : %04x   : %04x   : %04x    :     %04x     : \n",
+	  dev->name, addr,
@@ -1712 +1694 @@
-	size += sprintf(buffer+size, "%6s:                :  %02x  :  %02x  : %s : %02x:%02x:%02x:%02x    : \n",
+	size += sprintf(buffer+size, "%6s:                :  %02x  :  %02x  : %pM : %02x:%02x:%02x:%02x    : \n",
@@ -1716 +1698 @@
-	  print_mac(mac, addr),
+	  addr,
--- ./projects/linux/linux-2.6.29/drivers/net/tokenring/olympic.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/net/tokenring/olympic.c	2009-06-27 11:32:32.000000000 +0200
@@ -190 +189,0 @@
-static struct net_device_stats * olympic_get_stats(struct net_device *dev);
@@ -197,0 +197,9 @@
+static const struct net_device_ops olympic_netdev_ops = {
+	.ndo_open		= olympic_open,
+	.ndo_stop		= olympic_close,
+	.ndo_start_xmit		= olympic_xmit,
+	.ndo_change_mtu		= olympic_change_mtu,
+	.ndo_set_multicast_list	= olympic_set_rx_mode,
+	.ndo_set_mac_address	= olympic_set_mac_address,
+};
+
@@ -256,8 +264 @@
-	dev->open=&olympic_open;
-	dev->hard_start_xmit=&olympic_xmit;
-	dev->change_mtu=&olympic_change_mtu;
-	dev->stop=&olympic_close;
-	dev->do_ioctl=NULL;
-	dev->set_multicast_list=&olympic_set_rx_mode;
-	dev->get_stats=&olympic_get_stats ;
-	dev->set_mac_address=&olympic_set_mac_address ;  
+	dev->netdev_ops = &olympic_netdev_ops;
@@ -701 +701,0 @@
-		int i;
@@ -788 +788 @@
-				olympic_priv->olympic_stats.rx_errors++;	 
+				dev->stats.rx_errors++;
@@ -799 +799 @@
-					olympic_priv->olympic_stats.rx_dropped++ ; 
+					dev->stats.rx_dropped++;
@@ -865,2 +865,2 @@
-					olympic_priv->olympic_stats.rx_packets++ ; 
-					olympic_priv->olympic_stats.rx_bytes += length ; 
+					dev->stats.rx_packets++ ;
+					dev->stats.rx_bytes += length ;
@@ -974,2 +974,2 @@
-				olympic_priv->olympic_stats.tx_bytes += olympic_priv->tx_ring_skb[olympic_priv->tx_ring_last_status]->len;
-				olympic_priv->olympic_stats.tx_packets++ ; 
+				dev->stats.tx_bytes += olympic_priv->tx_ring_skb[olympic_priv->tx_ring_last_status]->len;
+				dev->stats.tx_packets++ ;
@@ -1347,7 +1346,0 @@
-static struct net_device_stats * olympic_get_stats(struct net_device *dev)
-{
-	struct olympic_private *olympic_priv ;
-	olympic_priv=netdev_priv(dev);
-	return (struct net_device_stats *) &olympic_priv->olympic_stats; 
-}
-
--- ./projects/linux/linux-2.6.13/drivers/net/wireless/airo.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/net/wireless/airo.c	2005-10-28 02:02:08.000000000 +0200
@@ -1043 +1043 @@
-WifiCtlHdr wifictlhdr8023 = {
+static WifiCtlHdr wifictlhdr8023 = {
@@ -1114 +1114 @@
-struct iw_statistics *airo_get_wireless_stats (struct net_device *dev);
+static struct iw_statistics *airo_get_wireless_stats (struct net_device *dev);
@@ -1120 +1120 @@
-int flashcard(struct net_device *dev, aironet_ioctl *comp);
+static int flashcard(struct net_device *dev, aironet_ioctl *comp);
@@ -1228,0 +1229,6 @@
+static int cmdreset(struct airo_info *ai);
+static int setflashmode (struct airo_info *ai);
+static int flashgchar(struct airo_info *ai,int matchbyte,int dwelltime);
+static int flashputbuf(struct airo_info *ai);
+static int flashrestart(struct airo_info *ai,struct net_device *dev);
+
@@ -1237,4 +1243,5 @@
-void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen, struct crypto_tfm *);
-void emmh32_init(emmh32_context *context);
-void emmh32_update(emmh32_context *context, u8 *pOctets, int len);
-void emmh32_final(emmh32_context *context, u8 digest[4]);
+static void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen, struct crypto_tfm *);
+static void emmh32_init(emmh32_context *context);
+static void emmh32_update(emmh32_context *context, u8 *pOctets, int len);
+static void emmh32_final(emmh32_context *context, u8 digest[4]);
+static int flashpchar(struct airo_info *ai,int byte,int dwelltime);
@@ -1304 +1311 @@
-	        ai->tfm = crypto_alloc_tfm("aes", 0);
+	        ai->tfm = crypto_alloc_tfm("aes", CRYPTO_TFM_REQ_MAY_SLEEP);
@@ -1318 +1325 @@
-char micsnap[]= {0xAA,0xAA,0x03,0x00,0x40,0x96,0x00,0x02};
+static char micsnap[] = {0xAA,0xAA,0x03,0x00,0x40,0x96,0x00,0x02};
@@ -1573 +1580 @@
-void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen, struct crypto_tfm *tfm)
+static void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen, struct crypto_tfm *tfm)
@@ -1605 +1612 @@
-void emmh32_init(emmh32_context *context)
+static void emmh32_init(emmh32_context *context)
@@ -1613 +1620 @@
-void emmh32_update(emmh32_context *context, u8 *pOctets, int len)
+static void emmh32_update(emmh32_context *context, u8 *pOctets, int len)
@@ -1655 +1662 @@
-void emmh32_final(emmh32_context *context, u8 digest[4])
+static void emmh32_final(emmh32_context *context, u8 digest[4])
@@ -2235 +2242 @@
-	if (ai->power) {
+	if (ai->power.event) {
@@ -2258 +2265 @@
-struct net_device_stats *airo_get_stats(struct net_device *dev)
+static struct net_device_stats *airo_get_stats(struct net_device *dev)
@@ -2406,2 +2413 @@
-	if (ai->tfm)
-		crypto_free_tfm(ai->tfm);
+	crypto_free_tfm(ai->tfm);
@@ -2417 +2423 @@
-int wll_header_parse(struct sk_buff *skb, unsigned char *haddr)
+static int wll_header_parse(struct sk_buff *skb, unsigned char *haddr)
@@ -2684 +2690 @@
-int reset_card( struct net_device *dev , int lock) {
+static int reset_card( struct net_device *dev , int lock) {
@@ -2699,3 +2705,3 @@
-struct net_device *_init_airo_card( unsigned short irq, int port,
-				    int is_pcmcia, struct pci_dev *pci,
-				    struct device *dmdev )
+static struct net_device *_init_airo_card( unsigned short irq, int port,
+					   int is_pcmcia, struct pci_dev *pci,
+					   struct device *dmdev )
@@ -2965 +2971 @@
-		if (ai->power || test_bit(FLAG_FLASHING, &ai->flags)) {
+		if (ai->power.event || test_bit(FLAG_FLASHING, &ai->flags)) {
@@ -3255 +3261 @@
-					| IW_QUAL_NOISE_UPDATED;
+					| IW_QUAL_DBM;
@@ -3601 +3607 @@
-			| IW_QUAL_NOISE_UPDATED;
+			| IW_QUAL_DBM;
@@ -5517 +5523 @@
-	if (ai->power > 1) {
+	if (ai->power.event > 1) {
@@ -6486,3 +6492,2 @@
-	range->max_qual.level = 0;	/* 0 means we use dBm  */
-	range->max_qual.noise = 0;
-	range->max_qual.updated = 0;
+	range->max_qual.level = 0x100 - 120;	/* -120 dBm */
+	range->max_qual.noise = 0x100 - 120;	/* -120 dBm */
@@ -6494,2 +6499,2 @@
-		range->avg_qual.qual = 50;	/* % */
-		range->avg_qual.level = 186;	/* -70 dBm */
+		range->avg_qual.qual = 50;		/* % */
+		range->avg_qual.level = 0x100 - 70;	/* -70 dBm */
@@ -6498 +6503 @@
-		range->avg_qual.level = 176;	/* -80 dBm */
+		range->avg_qual.level = 0x100 - 80;	/* -80 dBm */
@@ -6500,2 +6505 @@
-	range->avg_qual.noise = 0;
-	range->avg_qual.updated = 0;
+	range->avg_qual.noise = 0x100 - 85;		/* -85 dBm */
@@ -6724 +6728,3 @@
-			qual[i].updated = IW_QUAL_QUAL_UPDATED;
+			qual[i].updated = IW_QUAL_QUAL_UPDATED
+					| IW_QUAL_LEVEL_UPDATED
+					| IW_QUAL_DBM;
@@ -6728 +6734,3 @@
-			qual[i].updated = IW_QUAL_QUAL_INVALID;
+			qual[i].updated = IW_QUAL_QUAL_INVALID
+					| IW_QUAL_LEVEL_UPDATED
+					| IW_QUAL_DBM;
@@ -6731,2 +6738,0 @@
-		qual[i].updated = IW_QUAL_LEVEL_UPDATED
-				| IW_QUAL_NOISE_UPDATED;
@@ -6849 +6855,4 @@
-	iwe.u.freq.m = frequency_list[iwe.u.freq.m] * 100000;
+	/* iwe.u.freq.m containt the channel (starting 1), our 
+	 * frequency_list array start at index 0...
+	 */
+	iwe.u.freq.m = frequency_list[iwe.u.freq.m - 1] * 100000;
@@ -6858 +6867,3 @@
-		iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED;
+		iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED
+				| IW_QUAL_LEVEL_UPDATED
+				| IW_QUAL_DBM;
@@ -6862 +6873,3 @@
-		iwe.u.qual.updated = IW_QUAL_QUAL_INVALID;
+		iwe.u.qual.updated = IW_QUAL_QUAL_INVALID
+				| IW_QUAL_LEVEL_UPDATED
+				| IW_QUAL_DBM;
@@ -6865,2 +6877,0 @@
-	iwe.u.qual.updated = IW_QUAL_LEVEL_UPDATED
-			| IW_QUAL_NOISE_UPDATED;
@@ -7119 +7130 @@
-	if (ai->power)
+	if (ai->power.event)
@@ -7198 +7209 @@
-	if (local->power) {
+	if (local->power.event) {
@@ -7219 +7229,0 @@
-	local->wstats.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED;
@@ -7222 +7232 @@
-		local->wstats.qual.updated |= IW_QUAL_NOISE_UPDATED;
+		local->wstats.qual.updated = IW_QUAL_ALL_UPDATED | IW_QUAL_DBM;
@@ -7225 +7235 @@
-		local->wstats.qual.updated |= IW_QUAL_NOISE_INVALID;
+		local->wstats.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED | IW_QUAL_NOISE_INVALID | IW_QUAL_DBM;
@@ -7238 +7248 @@
-struct iw_statistics *airo_get_wireless_stats(struct net_device *dev)
+static struct iw_statistics *airo_get_wireless_stats(struct net_device *dev)
@@ -7453 +7463 @@
-int flashcard(struct net_device *dev, aironet_ioctl *comp) {
+static int flashcard(struct net_device *dev, aironet_ioctl *comp) {
@@ -7455,6 +7464,0 @@
-	int cmdreset(struct airo_info *);
-	int setflashmode(struct airo_info *);
-	int flashgchar(struct airo_info *,int,int);
-	int flashpchar(struct airo_info *,int,int);
-	int flashputbuf(struct airo_info *);
-	int flashrestart(struct airo_info *,struct net_device *);
@@ -7518 +7522 @@
-int cmdreset(struct airo_info *ai) {
+static int cmdreset(struct airo_info *ai) {
@@ -7542 +7546 @@
-int setflashmode (struct airo_info *ai) {
+static int setflashmode (struct airo_info *ai) {
@@ -7569 +7573 @@
-int flashpchar(struct airo_info *ai,int byte,int dwelltime) {
+static int flashpchar(struct airo_info *ai,int byte,int dwelltime) {
@@ -7609 +7613 @@
-int flashgchar(struct airo_info *ai,int matchbyte,int dwelltime){
+static int flashgchar(struct airo_info *ai,int matchbyte,int dwelltime){
@@ -7640 +7644 @@
-int flashputbuf(struct airo_info *ai){
+static int flashputbuf(struct airo_info *ai){
@@ -7662 +7666 @@
-int flashrestart(struct airo_info *ai,struct net_device *dev){
+static int flashrestart(struct airo_info *ai,struct net_device *dev){
--- ./projects/linux/linux-2.6.14/drivers/net/wireless/airo.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/net/wireless/airo.c	2006-01-03 04:21:10.000000000 +0100
@@ -37,0 +38 @@
+#include <linux/scatterlist.h>
@@ -48,0 +50,2 @@
+#include "airo.h"
+
@@ -1049 +1051,0 @@
-#ifdef WIRELESS_EXT
@@ -1070 +1071,0 @@
-#endif /* WIRELESS_EXT */
@@ -1113 +1113,0 @@
-#ifdef WIRELESS_EXT
@@ -1116 +1115,0 @@
-#endif /* WIRELESS_EXT */
@@ -1190 +1188,0 @@
-#ifdef WIRELESS_EXT
@@ -1195 +1192,0 @@
-#endif /* WIRELESS_EXT */
@@ -1599,3 +1596 @@
-		sg[0].page = virt_to_page(plain);
-		sg[0].offset = ((long) plain & ~PAGE_MASK);
-		sg[0].length = 16;
+		sg_set_buf(sg, plain, 16);
@@ -1603 +1598 @@
-		cipher = kmap(sg[0].page) + sg[0].offset;
+		cipher = kmap(sg->page) + sg->offset;
@@ -2050 +2045 @@
-static void get_tx_error(struct airo_info *ai, u32 fid)
+static void get_tx_error(struct airo_info *ai, s32 fid)
@@ -2390,8 +2385,4 @@
-	if (ai->flash)
-		kfree(ai->flash);
-	if (ai->rssi)
-		kfree(ai->rssi);
-	if (ai->APList)
-		kfree(ai->APList);
-	if (ai->SSID)
-		kfree(ai->SSID);
+	kfree(ai->flash);
+	kfree(ai->rssi);
+	kfree(ai->APList);
+	kfree(ai->SSID);
@@ -2530 +2521,2 @@
-	unsigned char *busaddroff,*vpackoff;
+	dma_addr_t busaddroff;
+	unsigned char *vpackoff;
@@ -2573 +2565 @@
-	busaddroff = (unsigned char *)ai->shared_dma;
+	busaddroff = ai->shared_dma;
@@ -2582 +2574 @@
-		ai->rxfids[i].rx_desc.host_addr = (dma_addr_t) busaddroff;
+		ai->rxfids[i].rx_desc.host_addr = busaddroff;
@@ -2597 +2589 @@
-		ai->txfids[i].tx_desc.host_addr = (dma_addr_t) busaddroff;
+		ai->txfids[i].tx_desc.host_addr = busaddroff;
@@ -2610,2 +2602,2 @@
-	ai->config_desc.rid_desc.host_addr = (dma_addr_t) busaddroff;
-	ai->ridbus = (dma_addr_t)busaddroff;
+	ai->config_desc.rid_desc.host_addr = busaddroff;
+	ai->ridbus = busaddroff;
@@ -2650 +2641,0 @@
-#ifdef WIRELESS_EXT
@@ -2652 +2642,0 @@
-#endif /* WIRELESS_EXT */
@@ -2678 +2667,0 @@
-#ifdef WIRELESS_EXT
@@ -2680 +2668,0 @@
-#endif /* WIRELESS_EXT */
@@ -2758 +2745,0 @@
-#ifdef WIRELESS_EXT
@@ -2762 +2748,0 @@
-#endif /* WIRELESS_EXT */
@@ -2772,2 +2758,2 @@
-	if (test_bit(FLAG_MPI,&ai->flags))
-		reset_card (dev, 1);
+	reset_card (dev, 1);
+	msleep(400);
@@ -3640,4 +3626,2 @@
-	if (ai->flash) {
-		kfree (ai->flash);
-		ai->flash = NULL;
-	}
+	kfree (ai->flash);
+	ai->flash = NULL;
@@ -3680,8 +3664,4 @@
-		if (ai->APList) {
-			kfree(ai->APList);
-			ai->APList = NULL;
-		}
-		if (ai->SSID) {
-			kfree(ai->SSID);
-			ai->SSID = NULL;
-		}
+		kfree(ai->APList);
+		ai->APList = NULL;
+		kfree(ai->SSID);
+		ai->SSID = NULL;
@@ -3701,4 +3681,2 @@
-			if (ai->rssi) {
-				kfree(ai->rssi);
-				ai->rssi = NULL;
-			}
+			kfree(ai->rssi);
+			ai->rssi = NULL;
@@ -4560 +4538 @@
-	if ((file->private_data = kmalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
+	if ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
@@ -4562 +4539,0 @@
-	memset(file->private_data, 0, sizeof(struct proc_data));
@@ -4640 +4617 @@
-	if ((file->private_data = kmalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
+	if ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
@@ -4642 +4618,0 @@
-	memset(file->private_data, 0, sizeof(struct proc_data));
@@ -4906 +4882 @@
-	if ((file->private_data = kmalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
+	if ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
@@ -4908 +4883,0 @@
-	memset(file->private_data, 0, sizeof(struct proc_data));
@@ -4914 +4889 @@
-	if ((data->wbuffer = kmalloc( 2048, GFP_KERNEL )) == NULL) {
+	if ((data->wbuffer = kzalloc( 2048, GFP_KERNEL )) == NULL) {
@@ -4919 +4893,0 @@
-	memset( data->wbuffer, 0, 2048 );
@@ -5180 +5154 @@
-	if ((file->private_data = kmalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
+	if ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
@@ -5182 +5155,0 @@
-	memset(file->private_data, 0, sizeof(struct proc_data));
@@ -5185 +5158 @@
-	if ((data->rbuffer = kmalloc( 180, GFP_KERNEL )) == NULL) {
+	if ((data->rbuffer = kzalloc( 180, GFP_KERNEL )) == NULL) {
@@ -5189 +5161,0 @@
-	memset(data->rbuffer, 0, 180);
@@ -5192 +5164 @@
-	if ((data->wbuffer = kmalloc( 80, GFP_KERNEL )) == NULL) {
+	if ((data->wbuffer = kzalloc( 80, GFP_KERNEL )) == NULL) {
@@ -5197 +5168,0 @@
-	memset( data->wbuffer, 0, 80 );
@@ -5228 +5199 @@
-	if ((file->private_data = kmalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
+	if ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
@@ -5230 +5200,0 @@
-	memset(file->private_data, 0, sizeof(struct proc_data));
@@ -5238 +5208 @@
-	if ((data->wbuffer = kmalloc( 33*3, GFP_KERNEL )) == NULL) {
+	if ((data->wbuffer = kzalloc( 33*3, GFP_KERNEL )) == NULL) {
@@ -5243 +5212,0 @@
-	memset( data->wbuffer, 0, 33*3 );
@@ -5272 +5241 @@
-	if ((file->private_data = kmalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
+	if ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
@@ -5274 +5242,0 @@
-	memset(file->private_data, 0, sizeof(struct proc_data));
@@ -5282 +5250 @@
-	if ((data->wbuffer = kmalloc( data->maxwritelen, GFP_KERNEL )) == NULL) {
+	if ((data->wbuffer = kzalloc( data->maxwritelen, GFP_KERNEL )) == NULL) {
@@ -5287 +5254,0 @@
-	memset( data->wbuffer, 0, data->maxwritelen );
@@ -5322 +5289 @@
-	if ((file->private_data = kmalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
+	if ((file->private_data = kzalloc(sizeof(struct proc_data ), GFP_KERNEL)) == NULL)
@@ -5324 +5290,0 @@
-	memset(file->private_data, 0, sizeof(struct proc_data));
@@ -5383,5 +5349,7 @@
-	struct proc_data *data = (struct proc_data *)file->private_data;
-	if ( data->on_close != NULL ) data->on_close( inode, file );
-	if ( data->rbuffer ) kfree( data->rbuffer );
-	if ( data->wbuffer ) kfree( data->wbuffer );
-	kfree( data );
+	struct proc_data *data = file->private_data;
+
+	if (data->on_close != NULL)
+		data->on_close(inode, file);
+	kfree(data->rbuffer);
+	kfree(data->wbuffer);
+	kfree(data);
@@ -5517,0 +5486 @@
+	pci_power_t prev_state = pdev->current_state;
@@ -5519 +5488 @@
-	pci_set_power_state(pdev, 0);
+	pci_set_power_state(pdev, PCI_D0);
@@ -5521 +5490 @@
-	pci_enable_wake(pdev, pci_choose_state(pdev, ai->power), 0);
+	pci_enable_wake(pdev, PCI_D0, 0);
@@ -5523 +5492 @@
-	if (ai->power.event > 1) {
+	if (prev_state != PCI_D1) {
@@ -5601 +5569,0 @@
-#ifdef WIRELESS_EXT
@@ -7110,2 +7077,0 @@
-#endif /* WIRELESS_EXT */
-
@@ -7190 +7155,0 @@
-#ifdef WIRELESS_EXT
@@ -7263 +7227,0 @@
-#endif /* WIRELESS_EXT */
--- ./projects/linux/linux-2.6.15/drivers/net/wireless/airo.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/net/wireless/airo.c	2006-03-20 06:53:29.000000000 +0100
@@ -4040 +4040 @@
-		if (test_bit(FLAG_ENABLED, &ai->flags))
+		if (test_bit(FLAG_ENABLED, &ai->flags) && (RID_WEP_TEMP != rid))
@@ -5096 +5096 @@
-	disable_MAC(ai, lock);
+	if (perm) disable_MAC(ai, lock);
@@ -5098 +5098 @@
-	enable_MAC(ai, &rsp, lock);
+	if (perm) enable_MAC(ai, &rsp, lock);
@@ -5671 +5671 @@
-		if((channel < 1) || (channel > 16)) {
+		if((channel < 1) || (channel > 14)) {
@@ -5677 +5677 @@
-			local->config.channelSet = (u16)(channel - 1);
+			local->config.channelSet = (u16) channel;
@@ -5694,0 +5695 @@
+	int ch;
@@ -5702,7 +5703,3 @@
-#ifdef WEXT_USECHANNELS
-	fwrq->m = ((int)status_rid.channel) + 1;
-	fwrq->e = 0;
-#else
-	{
-		int f = (int)status_rid.channel;
-		fwrq->m = frequency_list[f] * 100000;
+	ch = (int)status_rid.channel;
+	if((ch > 0) && (ch < 15)) {
+		fwrq->m = frequency_list[ch - 1] * 100000;
@@ -5709,0 +5707,3 @@
+	} else {
+		fwrq->m = ch;
+		fwrq->e = 0;
@@ -5711 +5710,0 @@
-#endif
@@ -5786 +5785 @@
-	dwrq->length = status_rid.SSIDlen + 1;
+	dwrq->length = status_rid.SSIDlen;
@@ -6172,0 +6172,2 @@
+	int perm = ( dwrq->flags & IW_ENCODE_TEMP ? 0 : 1 );
+	u16 currentAuthType = local->config.authType;
@@ -6215 +6216 @@
-			set_wep_key(local, index, key.key, key.len, 1, 1);
+			set_wep_key(local, index, key.key, key.len, perm, 1);
@@ -6223 +6223,0 @@
-			set_bit (FLAG_COMMIT, &local->flags);
@@ -6229 +6229 @@
-			set_wep_key(local, index, NULL, 0, 1, 1);
+			set_wep_key(local, index, NULL, 0, perm, 1);
@@ -6244 +6244 @@
-	if(dwrq->flags & IW_ENCODE_MODE)
+	if (local->config.authType != currentAuthType)
--- ./projects/linux/linux-2.6.16/drivers/net/wireless/airo.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/net/wireless/airo.c	2006-06-18 03:49:35.000000000 +0200
@@ -38,0 +39 @@
+#include <linux/crypto.h>
@@ -90,8 +90,0 @@
-/* Support Cisco MIC feature */
-#define MICSUPPORT
-
-#if defined(MICSUPPORT) && !defined(CONFIG_CRYPTO)
-#warning MIC support requires Crypto API
-#undef MICSUPPORT
-#endif
-
@@ -779,0 +773,5 @@
+  BSSListRid bss;
+  struct list_head list;
+} BSSListElement;
+
+typedef struct {
@@ -911,0 +910 @@
+#define AIRO_DEF_MTU      2312
@@ -1121 +1119,0 @@
-#ifdef MICSUPPORT
@@ -1130,2 +1128 @@
-#include <linux/crypto.h>
-#endif
+static void airo_networks_free(struct airo_info *ai);
@@ -1164 +1161 @@
-#define JOB_MASK	0x1ff0000
+#define JOB_MASK	0x2ff0000
@@ -1173,0 +1171 @@
+#define JOB_SCAN_RESULTS  25
@@ -1190 +1188 @@
-	unsigned long		scan_timestamp;	/* Time started to scan */
+	unsigned long		scan_timeout;	/* Time scan should be read */
@@ -1193 +1190,0 @@
-#ifdef MICSUPPORT
@@ -1198 +1194,0 @@
-#endif
@@ -1213,0 +1210,4 @@
+
+	struct list_head network_list;
+	struct list_head network_free_list;
+	BSSListElement *networks;
@@ -1232 +1232,16 @@
-#ifdef MICSUPPORT
+#define airo_print(type, name, fmt, args...) \
+	{ printk(type "airo(%s): " fmt "\n", name, ##args); }
+
+#define airo_print_info(name, fmt, args...) \
+	airo_print(KERN_INFO, name, fmt, ##args)
+
+#define airo_print_dbg(name, fmt, args...) \
+	airo_print(KERN_DEBUG, name, fmt, ##args)
+
+#define airo_print_warn(name, fmt, args...) \
+	airo_print(KERN_WARNING, name, fmt, ##args)
+
+#define airo_print_err(name, fmt, args...) \
+	airo_print(KERN_ERR, name, fmt, ##args)
+
+
@@ -1311 +1326 @@
-                printk(KERN_ERR "airo: failed to load transform for AES\n");
+                airo_print_err(ai->dev->name, "failed to load transform for AES");
@@ -1689 +1703,0 @@
-#endif
@@ -1744 +1758 @@
-	if (rc!=SUCCESS) printk(KERN_ERR "airo:  WEP_TEMP set %x\n", rc);
+	if (rc!=SUCCESS) airo_print_err(ai->dev->name, "WEP_TEMP set %x", rc);
@@ -1748 +1762 @@
-			printk(KERN_ERR "airo:  WEP_PERM set %x\n", rc);
+			airo_print_err(ai->dev->name, "WEP_PERM set %x", rc);
@@ -1927 +1941 @@
-		printk(KERN_ERR "airo: %s: skb==NULL\n",__FUNCTION__);
+		airo_print_err(dev->name, "%s: skb == NULL!",__FUNCTION__);
@@ -1973,2 +1987,2 @@
-		printk (KERN_ERR
-			"airo: %s: Dequeue'd zero in send_packet()\n",
+		airo_print_err(dev->name,
+			"%s: Dequeue'd zero in send_packet()",
@@ -2008 +2021,0 @@
-#ifdef MICSUPPORT
@@ -2025,3 +2038 @@
-	} else
-#endif
-	{
+	} else {
@@ -2129 +2140 @@
-		printk( KERN_ERR "airo:  skb == NULL!!!\n" );
+		airo_print_err(dev->name, "%s: skb == NULL!", __FUNCTION__);
@@ -2200 +2211 @@
-		printk( KERN_ERR "airo:  skb == NULL!!!\n" );
+		airo_print_err(dev->name, "%s: skb == NULL!", __FUNCTION__);
@@ -2384,0 +2396,2 @@
+	airo_networks_free (ai);
+
@@ -2403 +2415,0 @@
-#ifdef MICSUPPORT
@@ -2405 +2416,0 @@
-#endif
@@ -2457 +2468 @@
-		printk(KERN_ERR "airo:  Couldn't allocate RX FID\n");
+		airo_print_err(ai->dev->name, "Couldn't allocate RX FID");
@@ -2485 +2496 @@
-		printk(KERN_ERR "airo:  Couldn't allocate TX FID\n");
+		airo_print_err(ai->dev->name, "Couldn't allocate TX FID");
@@ -2499 +2510 @@
-		printk(KERN_ERR "airo:  Couldn't allocate RID\n");
+		airo_print_err(ai->dev->name, "Couldn't allocate RID");
@@ -2531 +2542 @@
-		printk(KERN_ERR "airo: Couldn't get region %x[%x] for %s\n",
+		airo_print_err(ai->dev->name, "Couldn't get region %x[%x] for %s",
@@ -2536 +2547 @@
-		printk(KERN_ERR "airo: Couldn't get region %x[%x] for %s\n",
+		airo_print_err(ai->dev->name, "Couldn't get region %x[%x] for %s",
@@ -2543 +2554 @@
-		printk(KERN_ERR "airo: Couldn't map region %x[%x] for %s\n",
+		airo_print_err(ai->dev->name, "Couldn't map region %x[%x] for %s",
@@ -2549 +2560 @@
-		printk(KERN_ERR "airo: Couldn't map region %x[%x] for %s\n",
+		airo_print_err(ai->dev->name, "Couldn't map region %x[%x] for %s",
@@ -2557 +2568 @@
-		printk(KERN_ERR "airo: Couldn't alloc_consistent %d\n",
+		airo_print_err(ai->dev->name, "Couldn't alloc_consistent %d",
@@ -2649 +2660 @@
-	dev->mtu                = 2312;
+	dev->mtu                = AIRO_DEF_MTU;
@@ -2692,0 +2704,36 @@
+#define MAX_NETWORK_COUNT	64
+static int airo_networks_allocate(struct airo_info *ai)
+{
+	if (ai->networks)
+		return 0;
+
+	ai->networks =
+	    kzalloc(MAX_NETWORK_COUNT * sizeof(BSSListElement),
+		    GFP_KERNEL);
+	if (!ai->networks) {
+		airo_print_warn(ai->dev->name, "Out of memory allocating beacons");
+		return -ENOMEM;
+	}
+
+	return 0;
+}
+
+static void airo_networks_free(struct airo_info *ai)
+{
+	if (!ai->networks)
+		return;
+	kfree(ai->networks);
+	ai->networks = NULL;
+}
+
+static void airo_networks_initialize(struct airo_info *ai)
+{
+	int i;
+
+	INIT_LIST_HEAD(&ai->network_free_list);
+	INIT_LIST_HEAD(&ai->network_list);
+	for (i = 0; i < MAX_NETWORK_COUNT; i++)
+		list_add_tail(&ai->networks[i].list,
+			      &ai->network_free_list);
+}
+
@@ -2704 +2751 @@
-		printk(KERN_ERR "airo:  Couldn't alloc_etherdev\n");
+		airo_print_err("", "Couldn't alloc_etherdev");
@@ -2708 +2755 @@
-		printk(KERN_ERR "airo:  Couldn't get name!\n");
+		airo_print_err("", "Couldn't get name!");
@@ -2714,0 +2762 @@
+	ai->dev = dev;
@@ -2716 +2764 @@
-		printk(KERN_DEBUG "airo: Found an MPI350 card\n");
+		airo_print_dbg(dev->name, "Found an MPI350 card");
@@ -2719 +2766,0 @@
-        ai->dev = dev;
@@ -2729 +2775,0 @@
-#ifdef MICSUPPORT
@@ -2731 +2776,0 @@
-#endif
@@ -2735,0 +2781,4 @@
+	if (airo_networks_allocate (ai))
+		goto err_out_unlink;
+	airo_networks_initialize (ai);
+
@@ -2757 +2805,0 @@
-
@@ -2763 +2811,2 @@
-		printk(KERN_ERR "airo: register interrupt %d failed, rc %d\n", irq, rc );
+		airo_print_err(dev->name, "register interrupt %d failed, rc %d",
+				irq, rc);
@@ -2769 +2818 @@
-			printk(KERN_ERR "airo: Couldn't request region\n");
+			airo_print_err(dev->name, "Couldn't request region");
@@ -2776 +2825 @@
-			printk(KERN_ERR "airo: Could not map memory\n");
+			airo_print_err(dev->name, "Could not map memory");
@@ -2783 +2832 @@
-			printk( KERN_ERR "airo: MAC could not be enabled\n" );
+			airo_print_err(dev->name, "MAC could not be enabled" );
@@ -2794 +2843 @@
-		printk(KERN_ERR "airo: Couldn't register_netdev\n");
+		airo_print_err(dev->name, "Couldn't register_netdev");
@@ -2800,2 +2849 @@
-	printk( KERN_INFO "airo: MAC enabled %s %x:%x:%x:%x:%x:%x\n",
-		dev->name,
+	airo_print_info(dev->name, "MAC enabled %x:%x:%x:%x:%x:%x",
@@ -2808 +2856 @@
-			ai->fids[i] = transmit_allocate(ai,2312,i>=MAX_FIDS/2);
+			ai->fids[i] = transmit_allocate(ai,AIRO_DEF_MTU,i>=MAX_FIDS/2);
@@ -2865 +2913 @@
-		printk( KERN_ERR "airo: MAC could not be enabled\n" );
+		airo_print_err(dev->name, "MAC could not be enabled");
@@ -2868 +2916 @@
-	printk( KERN_INFO "airo: MAC enabled %s %x:%x:%x:%x:%x:%x\n", dev->name,
+	airo_print_info(dev->name, "MAC enabled %x:%x:%x:%x:%x:%x",
@@ -2874 +2922 @@
-			ai->fids[i] = transmit_allocate (ai,2312,i>=MAX_FIDS/2);
+			ai->fids[i] = transmit_allocate (ai,AIRO_DEF_MTU,i>=MAX_FIDS/2);
@@ -2899,0 +2948,59 @@
+static void airo_process_scan_results (struct airo_info *ai) {
+	union iwreq_data	wrqu;
+	BSSListRid BSSList;
+	int rc;
+	BSSListElement * loop_net;
+	BSSListElement * tmp_net;
+
+	/* Blow away current list of scan results */
+	list_for_each_entry_safe (loop_net, tmp_net, &ai->network_list, list) {
+		list_move_tail (&loop_net->list, &ai->network_free_list);
+		/* Don't blow away ->list, just BSS data */
+		memset (loop_net, 0, sizeof (loop_net->bss));
+	}
+
+	/* Try to read the first entry of the scan result */
+	rc = PC4500_readrid(ai, RID_BSSLISTFIRST, &BSSList, sizeof(BSSList), 0);
+	if((rc) || (BSSList.index == 0xffff)) {
+		/* No scan results */
+		goto out;
+	}
+
+	/* Read and parse all entries */
+	tmp_net = NULL;
+	while((!rc) && (BSSList.index != 0xffff)) {
+		/* Grab a network off the free list */
+		if (!list_empty(&ai->network_free_list)) {
+			tmp_net = list_entry(ai->network_free_list.next,
+					    BSSListElement, list);
+			list_del(ai->network_free_list.next);
+		}
+
+		if (tmp_net != NULL) {
+			memcpy(tmp_net, &BSSList, sizeof(tmp_net->bss));
+			list_add_tail(&tmp_net->list, &ai->network_list);
+			tmp_net = NULL;
+		}
+
+		/* Read next entry */
+		rc = PC4500_readrid(ai, RID_BSSLISTNEXT,
+				    &BSSList, sizeof(BSSList), 0);
+	}
+
+out:
+	ai->scan_timeout = 0;
+	clear_bit(JOB_SCAN_RESULTS, &ai->flags);
+	up(&ai->sem);
+
+	/* Send an empty event to user space.
+	 * We don't send the received data on
+	 * the event because it would require
+	 * us to do complex transcoding, and
+	 * we want to minimise the work done in
+	 * the irq handler. Use a request to
+	 * extract the data - Jean II */
+	wrqu.data.length = 0;
+	wrqu.data.flags = 0;
+	wireless_send_event(ai->dev, SIOCGIWSCAN, &wrqu, NULL);
+}
+
@@ -2929,2 +3036,7 @@
-				if (ai->expires) {
-					if (time_after_eq(jiffies,ai->expires)){
+				if (ai->expires || ai->scan_timeout) {
+					if (ai->scan_timeout &&
+							time_after_eq(jiffies,ai->scan_timeout)){
+						set_bit(JOB_SCAN_RESULTS,&ai->flags);
+						break;
+					} else if (ai->expires &&
+							time_after_eq(jiffies,ai->expires)){
@@ -2935 +3047,9 @@
-						schedule_timeout(ai->expires - jiffies);
+						unsigned long wake_at;
+						if (!ai->expires || !ai->scan_timeout) {
+							wake_at = max(ai->expires,
+								ai->scan_timeout);
+						} else {
+							wake_at = min(ai->expires,
+								ai->scan_timeout);
+						}
+						schedule_timeout(wake_at - jiffies);
@@ -2972 +3091,0 @@
-#ifdef MICSUPPORT
@@ -2975 +3093,0 @@
-#endif
@@ -2979,0 +3098,4 @@
+		else if (test_bit(JOB_SCAN_RESULTS, &ai->flags))
+			airo_process_scan_results(ai);
+		else  /* Shouldn't get here, but we make sure to unlock */
+			up(&ai->sem);
@@ -3013 +3134,0 @@
-#ifdef MICSUPPORT
@@ -3018 +3138,0 @@
-#endif
@@ -3021,0 +3142 @@
+			int scan_forceloss = 0;
@@ -3040 +3161,2 @@
-#define ASSOCIATED 0x0400 /* Assocatied */
+#define ASSOCIATED 0x0400 /* Associated */
+#define REASSOCIATED 0x0600 /* Reassociated?  Only on firmware >= 5.30.17 */
@@ -3057,7 +3179,3 @@
-			if (newStatus != ASSOCIATED) {
-				if (auto_wep && !apriv->expires) {
-					apriv->expires = RUN_AT(3*HZ);
-					wake_up_interruptible(&apriv->thr_wait);
-				}
-			} else {
-				struct task_struct *task = apriv->task;
+			if (newStatus == FORCELOSS && apriv->scan_timeout > 0)
+				scan_forceloss = 1;
+			if(newStatus == ASSOCIATED || newStatus == REASSOCIATED) {
@@ -3066,2 +3184,2 @@
-				if (task)
-					wake_up_process (task);
+				if (apriv->task)
+					wake_up_process (apriv->task);
@@ -3070,19 +3188 @@
-			}
-			/* Question : is ASSOCIATED the only status
-			 * that is valid ? We want to catch handover
-			 * and reassociations as valid status
-			 * Jean II */
-			if(newStatus == ASSOCIATED) {
-				if (apriv->scan_timestamp) {
-					/* Send an empty event to user space.
-					 * We don't send the received data on
-					 * the event because it would require
-					 * us to do complex transcoding, and
-					 * we want to minimise the work done in
-					 * the irq handler. Use a request to
-					 * extract the data - Jean II */
-					wrqu.data.length = 0;
-					wrqu.data.flags = 0;
-					wireless_send_event(dev, SIOCGIWSCAN, &wrqu, NULL);
-					apriv->scan_timestamp = 0;
-				}
+
@@ -3094,3 +3194,5 @@
-			} else {
-				memset(wrqu.ap_addr.sa_data, '\0', ETH_ALEN);
-				wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+			} else if (!scan_forceloss) {
+				if (auto_wep && !apriv->expires) {
+					apriv->expires = RUN_AT(3*HZ);
+					wake_up_interruptible(&apriv->thr_wait);
+				}
@@ -3098,0 +3201,2 @@
+				memset(wrqu.ap_addr.sa_data, '\0', ETH_ALEN);
+				wrqu.ap_addr.sa_family = ARPHRD_ETHER;
@@ -3146,2 +3250,2 @@
-			if (len > 2312) {
-				printk( KERN_ERR "airo: Bad size %d\n", len );
+			if (len > AIRO_DEF_MTU) {
+				airo_print_err(apriv->dev->name, "Bad size %d", len);
@@ -3190 +3294 @@
-					if (gap <= 8)
+					if (gap <= 8) {
@@ -3192,2 +3296,4 @@
-					else
-						printk(KERN_ERR "airo: gaplen too big. Problems will follow...\n");
+					} else {
+						airo_print_err(apriv->dev->name, "gaplen too "
+							"big. Problems will follow...");
+					}
@@ -3197 +3302,0 @@
-#ifdef MICSUPPORT
@@ -3199 +3303,0 @@
-#endif
@@ -3201 +3304,0 @@
-#ifdef MICSUPPORT
@@ -3214 +3316,0 @@
-#endif
@@ -3216 +3317,0 @@
-#ifdef MICSUPPORT
@@ -3220,3 +3320,0 @@
-#else
-				if (0) {
-#endif
@@ -3318 +3416,2 @@
-				printk( KERN_ERR "airo: Unallocated FID was used to xmit\n" );
+				airo_print_err(apriv->dev->name, "Unallocated FID was "
+					"used to xmit" );
@@ -3323 +3422 @@
-			printk( KERN_WARNING "airo: Got weird status %x\n",
+			airo_print_warn(apriv->dev->name, "Got weird status %x",
@@ -3396,2 +3495,2 @@
-		printk(KERN_ERR "%s: Cannot enable MAC, err=%d\n",
-			__FUNCTION__,rc);
+		airo_print_err(ai->dev->name, "%s: Cannot enable MAC, err=%d",
+			__FUNCTION__, rc);
@@ -3433 +3531,0 @@
-#ifdef MICSUPPORT
@@ -3436 +3533,0 @@
-#endif
@@ -3451 +3547,0 @@
-#ifdef MICSUPPORT
@@ -3473,3 +3568,0 @@
-#else
-		memcpy(buffer, ai->rxfids[0].virtual_host_addr, len);
-#endif
@@ -3532,2 +3625,2 @@
-	if (len > 2312) {
-		printk( KERN_ERR "airo: Bad size %d\n", len );
+	if (len > AIRO_DEF_MTU) {
+		airo_print_err(ai->dev->name, "Bad size %d", len);
@@ -3574,2 +3667,2 @@
-			printk(KERN_ERR
-			    "airo: gaplen too big. Problems will follow...\n");
+			airo_print_err(ai->dev->name,
+			    "gaplen too big. Problems will follow...");
@@ -3647 +3740 @@
-			printk(KERN_ERR "airo: Error checking for AUX port\n");
+			airo_print_err(ai->dev->name, "Error checking for AUX port");
@@ -3652 +3745 @@
-			printk(KERN_DEBUG "airo: Doing fast bap_reads\n");
+			airo_print_dbg(ai->dev->name, "Doing fast bap_reads");
@@ -3655 +3748 @@
-			printk(KERN_DEBUG "airo: Doing AUX bap_reads\n");
+			airo_print_dbg(ai->dev->name, "Doing AUX bap_reads");
@@ -3686 +3779,2 @@
-				printk(KERN_WARNING "airo: unknown received signal level scale\n");
+				airo_print_warn(ai->dev->name, "unknown received signal "
+						"level scale");
@@ -3692 +3785,0 @@
-#ifdef MICSUPPORT
@@ -3698 +3790,0 @@
-#endif
@@ -3751 +3843,2 @@
-		printk( KERN_ERR "airo: Bad MAC enable reason = %x, rid = %x, offset = %d\n", rsp.rsp0, rsp.rsp1, rsp.rsp2 );
+		airo_print_err(ai->dev->name, "Bad MAC enable reason = %x, rid = %x,"
+			" offset = %d", rsp.rsp0, rsp.rsp1, rsp.rsp2 );
@@ -3794,2 +3887,2 @@
-		printk( KERN_ERR
-			"airo: Max tries exceeded when issueing command\n" );
+		airo_print_err(ai->dev->name,
+			"Max tries exceeded when issueing command");
@@ -3807,5 +3900,5 @@
-		printk (KERN_ERR "airo: cmd= %x\n", pCmd->cmd);
-		printk (KERN_ERR "airo: status= %x\n", pRsp->status);
-		printk (KERN_ERR "airo: Rsp0= %x\n", pRsp->rsp0);
-		printk (KERN_ERR "airo: Rsp1= %x\n", pRsp->rsp1);
-		printk (KERN_ERR "airo: Rsp2= %x\n", pRsp->rsp2);
+		airo_print_err(ai->dev->name, "cmd= %x\n", pCmd->cmd);
+		airo_print_err(ai->dev->name, "status= %x\n", pRsp->status);
+		airo_print_err(ai->dev->name, "Rsp0= %x\n", pRsp->rsp0);
+		airo_print_err(ai->dev->name, "Rsp1= %x\n", pRsp->rsp1);
+		airo_print_err(ai->dev->name, "Rsp2= %x\n", pRsp->rsp2);
@@ -3844 +3937 @@
-			printk( KERN_ERR "airo: BAP error %x %d\n",
+			airo_print_err(ai->dev->name, "BAP error %x %d",
@@ -3851,2 +3944,2 @@
-			printk( KERN_ERR
-				"airo: BAP setup error too many retries\n" );
+			airo_print_err(ai->dev->name,
+				"airo: BAP setup error too many retries\n");
@@ -4007,2 +4100,2 @@
-			printk( KERN_ERR
-			"airo: Rid %x has a length of %d which is too short\n",
+			airo_print_err(ai->dev->name,
+				"Rid %x has a length of %d which is too short",
@@ -4041,2 +4134,2 @@
-			printk(KERN_ERR
-				"%s: MAC should be disabled (rid=%04x)\n",
+			airo_print_err(ai->dev->name,
+				"%s: MAC should be disabled (rid=%04x)",
@@ -4058 +4151 @@
-			printk(KERN_ERR "%s: len=%d\n",__FUNCTION__,len);
+			airo_print_err(ai->dev->name, "%s: len=%d", __FUNCTION__, len);
@@ -4066,4 +4159,4 @@
-				printk(KERN_ERR "%s: Write rid Error %d\n",
-					__FUNCTION__,rc);
-				printk(KERN_ERR "%s: Cmd=%04x\n",
-						__FUNCTION__,cmd.cmd);
+				airo_print_err(ai->dev->name, "%s: Write rid Error %d",
+						__FUNCTION__, rc);
+				airo_print_err(ai->dev->name, "%s: Cmd=%04x",
+						__FUNCTION__, cmd.cmd);
@@ -4168 +4261 @@
-		printk( KERN_WARNING "Short packet %d\n", len );
+		airo_print_warn(ai->dev->name, "Short packet %d", len);
@@ -4173 +4265,0 @@
-#ifdef MICSUPPORT
@@ -4180,2 +4271,0 @@
-#endif
-
@@ -4235 +4325 @@
-		printk( KERN_WARNING "Short packet %d\n", len );
+		airo_print_warn(ai->dev->name, "Short packet %d", len);
@@ -4632,2 +4722,2 @@
-			printk(KERN_WARNING
-			       "airo: Potentially disasterous buffer overflow averted!\n");
+			airo_print_warn(apriv->dev->name,
+			       "Potentially disasterous buffer overflow averted!");
@@ -4639,2 +4729 @@
-		printk(KERN_WARNING
-		       "airo: Got a short rid\n");
+		airo_print_warn(apriv->dev->name, "Got a short rid");
@@ -4802 +4891 @@
-			v = (v<0) ? 0 : ((v>2312) ? 2312 : v);
+			v = (v<0) ? 0 : ((v>AIRO_DEF_MTU) ? AIRO_DEF_MTU : v);
@@ -4836 +4925 @@
-			v = (v<256) ? 256 : ((v>2312) ? 2312 : v);
+			v = (v<256) ? 256 : ((v>AIRO_DEF_MTU) ? AIRO_DEF_MTU : v);
@@ -4846,2 +4935 @@
-			default:
-				printk( KERN_WARNING "airo: Unknown modulation\n" );
+			default: airo_print_warn(ai->dev->name, "Unknown modulation");
@@ -4855 +4943 @@
-		        default: printk(KERN_WARNING "airo: Unknown preamble\n");
+			default: airo_print_warn(ai->dev->name, "Unknown preamble");
@@ -4858 +4946 @@
-			printk( KERN_WARNING "Couldn't figure out %s\n", line );
+			airo_print_warn(ai->dev->name, "Couldn't figure out %s", line);
@@ -5084 +5171,0 @@
-		if (perm) printk(KERN_INFO "Setting transmit key to %d\n", index);
@@ -5093 +5179,0 @@
-		printk(KERN_INFO "Setting key %d\n", index);
@@ -5126 +5212 @@
-		printk(KERN_ERR "airo:  WepKey passed invalid key index\n");
+		airo_print_err(ai->dev->name, "WepKey passed invalid key index");
@@ -5539,3 +5625,2 @@
-		printk( KERN_INFO
-			"airo:  Trying to configure ISA adapter at irq=%d io=0x%x\n",
-			irq[i], io[i] );
+		airo_print_info("", "Trying to configure ISA adapter at irq=%d "
+			"io=0x%x", irq[i], io[i] );
@@ -5547 +5632 @@
-	printk( KERN_INFO "airo:  Probing for PCI adapters\n" );
+	airo_print_info("", "Probing for PCI adapters");
@@ -5549 +5634 @@
-	printk( KERN_INFO "airo:  Finished probing for PCI adapters\n" );
+	airo_print_info("", "Finished probing for PCI adapters");
@@ -5561 +5646 @@
-		printk( KERN_INFO "airo: Unregistering %s\n", airo_devices->dev->name );
+		airo_print_info(airo_devices->dev->name, "Unregistering...\n");
@@ -5672 +5757,2 @@
-			printk(KERN_DEBUG "%s: New channel value of %d is invalid!\n", dev->name, fwrq->m);
+			airo_print_dbg(dev->name, "New channel value of %d is invalid!",
+				fwrq->m);
@@ -5804 +5890,2 @@
-	static const unsigned char bcast[ETH_ALEN] = { 255, 255, 255, 255, 255, 255 };
+	static const u8 any[ETH_ALEN] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+	static const u8 off[ETH_ALEN] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
@@ -5808 +5895,2 @@
-	else if (!memcmp(bcast, awrq->sa_data, ETH_ALEN)) {
+	else if (!memcmp(any, awrq->sa_data, ETH_ALEN) ||
+	         !memcmp(off, awrq->sa_data, ETH_ALEN)) {
@@ -5994,2 +6082,2 @@
-		rthr = 2312;
-	if((rthr < 0) || (rthr > 2312)) {
+		rthr = AIRO_DEF_MTU;
+	if((rthr < 0) || (rthr > AIRO_DEF_MTU)) {
@@ -6018 +6106 @@
-	vwrq->disabled = (vwrq->value >= 2312);
+	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
@@ -6037,2 +6125,2 @@
-		fthr = 2312;
-	if((fthr < 256) || (fthr > 2312)) {
+		fthr = AIRO_DEF_MTU;
+	if((fthr < 256) || (fthr > AIRO_DEF_MTU)) {
@@ -6062 +6150 @@
-	vwrq->disabled = (vwrq->value >= 2312);
+	vwrq->disabled = (vwrq->value >= AIRO_DEF_MTU);
@@ -6298,0 +6387,266 @@
+ * Wireless Handler : set extended Encryption parameters
+ */
+static int airo_set_encodeext(struct net_device *dev,
+			   struct iw_request_info *info,
+			    union iwreq_data *wrqu,
+			    char *extra)
+{
+	struct airo_info *local = dev->priv;
+	struct iw_point *encoding = &wrqu->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	CapabilityRid cap_rid;		/* Card capability info */
+	int perm = ( encoding->flags & IW_ENCODE_TEMP ? 0 : 1 );
+	u16 currentAuthType = local->config.authType;
+	int idx, key_len, alg = ext->alg, set_key = 1;
+	wep_key_t key;
+
+	/* Is WEP supported ? */
+	readCapabilityRid(local, &cap_rid, 1);
+	/* Older firmware doesn't support this...
+	if(!(cap_rid.softCap & 2)) {
+		return -EOPNOTSUPP;
+	} */
+	readConfigRid(local, 1);
+
+	/* Determine and validate the key index */
+	idx = encoding->flags & IW_ENCODE_INDEX;
+	if (idx) {
+		if (idx < 1 || idx > ((cap_rid.softCap & 0x80) ? 4:1))
+			return -EINVAL;
+		idx--;
+	} else
+		idx = get_wep_key(local, 0xffff);
+
+	if (encoding->flags & IW_ENCODE_DISABLED)
+		alg = IW_ENCODE_ALG_NONE;
+
+	if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+		/* Only set transmit key index here, actual
+		 * key is set below if needed.
+		 */
+		set_wep_key(local, idx, NULL, 0, perm, 1);
+		set_key = ext->key_len > 0 ? 1 : 0;
+	}
+
+	if (set_key) {
+		/* Set the requested key first */
+		memset(key.key, 0, MAX_KEY_SIZE);
+		switch (alg) {
+		case IW_ENCODE_ALG_NONE:
+			key.len = 0;
+			break;
+		case IW_ENCODE_ALG_WEP:
+			if (ext->key_len > MIN_KEY_SIZE) {
+				key.len = MAX_KEY_SIZE;
+			} else if (ext->key_len > 0) {
+				key.len = MIN_KEY_SIZE;
+			} else {
+				return -EINVAL;
+			}
+			key_len = min (ext->key_len, key.len);
+			memcpy(key.key, ext->key, key_len);
+			break;
+		default:
+			return -EINVAL;
+		}
+		/* Send the key to the card */
+		set_wep_key(local, idx, key.key, key.len, perm, 1);
+	}
+
+	/* Read the flags */
+	if(encoding->flags & IW_ENCODE_DISABLED)
+		local->config.authType = AUTH_OPEN;	// disable encryption
+	if(encoding->flags & IW_ENCODE_RESTRICTED)
+		local->config.authType = AUTH_SHAREDKEY;	// Only Both
+	if(encoding->flags & IW_ENCODE_OPEN)
+		local->config.authType = AUTH_ENCRYPT;	// Only Wep
+	/* Commit the changes to flags if needed */
+	if (local->config.authType != currentAuthType)
+		set_bit (FLAG_COMMIT, &local->flags);
+
+	return -EINPROGRESS;
+}
+
+
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : get extended Encryption parameters
+ */
+static int airo_get_encodeext(struct net_device *dev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu,
+			    char *extra)
+{
+	struct airo_info *local = dev->priv;
+	struct iw_point *encoding = &wrqu->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	CapabilityRid cap_rid;		/* Card capability info */
+	int idx, max_key_len;
+
+	/* Is it supported ? */
+	readCapabilityRid(local, &cap_rid, 1);
+	if(!(cap_rid.softCap & 2)) {
+		return -EOPNOTSUPP;
+	}
+	readConfigRid(local, 1);
+
+	max_key_len = encoding->length - sizeof(*ext);
+	if (max_key_len < 0)
+		return -EINVAL;
+
+	idx = encoding->flags & IW_ENCODE_INDEX;
+	if (idx) {
+		if (idx < 1 || idx > ((cap_rid.softCap & 0x80) ? 4:1))
+			return -EINVAL;
+		idx--;
+	} else
+		idx = get_wep_key(local, 0xffff);
+
+	encoding->flags = idx + 1;
+	memset(ext, 0, sizeof(*ext));
+
+	/* Check encryption mode */
+	switch(local->config.authType) {
+		case AUTH_ENCRYPT:
+			encoding->flags = IW_ENCODE_ALG_WEP | IW_ENCODE_ENABLED;
+			break;
+		case AUTH_SHAREDKEY:
+			encoding->flags = IW_ENCODE_ALG_WEP | IW_ENCODE_ENABLED;
+			break;
+		default:
+		case AUTH_OPEN:
+			encoding->flags = IW_ENCODE_ALG_NONE | IW_ENCODE_DISABLED;
+			break;
+	}
+	/* We can't return the key, so set the proper flag and return zero */
+	encoding->flags |= IW_ENCODE_NOKEY;
+	memset(extra, 0, 16);
+	
+	/* Copy the key to the user buffer */
+	ext->key_len = get_wep_key(local, idx);
+	if (ext->key_len > 16) {
+		ext->key_len=0;
+	}
+
+	return 0;
+}
+
+
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : set extended authentication parameters
+ */
+static int airo_set_auth(struct net_device *dev,
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct airo_info *local = dev->priv;
+	struct iw_param *param = &wrqu->param;
+	u16 currentAuthType = local->config.authType;
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_WPA_VERSION:
+	case IW_AUTH_CIPHER_PAIRWISE:
+	case IW_AUTH_CIPHER_GROUP:
+	case IW_AUTH_KEY_MGMT:
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+	case IW_AUTH_PRIVACY_INVOKED:
+		/*
+		 * airo does not use these parameters
+		 */
+		break;
+
+	case IW_AUTH_DROP_UNENCRYPTED:
+		if (param->value) {
+			/* Only change auth type if unencrypted */
+			if (currentAuthType == AUTH_OPEN)
+				local->config.authType = AUTH_ENCRYPT;
+		} else {
+			local->config.authType = AUTH_OPEN;
+		}
+
+		/* Commit the changes to flags if needed */
+		if (local->config.authType != currentAuthType)
+			set_bit (FLAG_COMMIT, &local->flags);
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG: {
+			/* FIXME: What about AUTH_OPEN?  This API seems to
+			 * disallow setting our auth to AUTH_OPEN.
+			 */
+			if (param->value & IW_AUTH_ALG_SHARED_KEY) {
+				local->config.authType = AUTH_SHAREDKEY;
+			} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {
+				local->config.authType = AUTH_ENCRYPT;
+			} else
+				return -EINVAL;
+			break;
+
+			/* Commit the changes to flags if needed */
+			if (local->config.authType != currentAuthType)
+				set_bit (FLAG_COMMIT, &local->flags);
+		}
+
+	case IW_AUTH_WPA_ENABLED:
+		/* Silently accept disable of WPA */
+		if (param->value > 0)
+			return -EOPNOTSUPP;
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+	return -EINPROGRESS;
+}
+
+
+/*------------------------------------------------------------------*/
+/*
+ * Wireless Handler : get extended authentication parameters
+ */
+static int airo_get_auth(struct net_device *dev,
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct airo_info *local = dev->priv;
+	struct iw_param *param = &wrqu->param;
+	u16 currentAuthType = local->config.authType;
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_DROP_UNENCRYPTED:
+		switch (currentAuthType) {
+		case AUTH_SHAREDKEY:
+		case AUTH_ENCRYPT:
+			param->value = 1;
+			break;
+		default:
+			param->value = 0;
+			break;
+		}
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG:
+		switch (currentAuthType) {
+		case AUTH_SHAREDKEY:
+			param->value = IW_AUTH_ALG_SHARED_KEY;
+			break;
+		case AUTH_ENCRYPT:
+		default:
+			param->value = IW_AUTH_ALG_OPEN_SYSTEM;
+			break;
+		}
+		break;
+
+	case IW_AUTH_WPA_ENABLED:
+		param->value = 0;
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+
+/*------------------------------------------------------------------*/
+/*
@@ -6491 +6845 @@
-	range->max_rts = 2312;
+	range->max_rts = AIRO_DEF_MTU;
@@ -6493 +6847 @@
-	range->max_frag = 2312;
+	range->max_frag = AIRO_DEF_MTU;
@@ -6753,0 +7108 @@
+	int wake = 0;
@@ -6762,0 +7118,8 @@
+	if (down_interruptible(&ai->sem))
+		return -ERESTARTSYS;
+
+	/* If there's already a scan in progress, don't
+	 * trigger another one. */
+	if (ai->scan_timeout > 0)
+		goto out;
+
@@ -6763,0 +7127 @@
+	ai->scan_timeout = RUN_AT(3*HZ);
@@ -6766,2 +7129,0 @@
-	if (down_interruptible(&ai->sem))
-		return -ERESTARTSYS;
@@ -6769,4 +7131 @@
-	ai->scan_timestamp = jiffies;
-	up(&ai->sem);
-
-	/* At this point, just return to the user. */
+	wake = 1;
@@ -6773,0 +7133,4 @@
+out:
+	up(&ai->sem);
+	if (wake)
+		wake_up_interruptible(&ai->thr_wait);
@@ -6893,2 +7256,2 @@
-	BSSListRid BSSList;
-	int rc;
+	BSSListElement *net;
+	int err = 0;
@@ -6897,12 +7260,2 @@
-	/* When we are associated again, the scan has surely finished.
-	 * Just in case, let's make sure enough time has elapsed since
-	 * we started the scan. - Javier */
-	if(ai->scan_timestamp && time_before(jiffies,ai->scan_timestamp+3*HZ)) {
-		/* Important note : we don't want to block the caller
-		 * until results are ready for various reasons.
-		 * First, managing wait queues is complex and racy
-		 * (there may be multiple simultaneous callers).
-		 * Second, we grab some rtnetlink lock before comming
-		 * here (in dev_ioctl()).
-		 * Third, the caller can wait on the Wireless Event
-		 * - Jean II */
+	/* If a scan is in-progress, return -EAGAIN */
+	if (ai->scan_timeout > 0)
@@ -6910,2 +7262,0 @@
-	}
-	ai->scan_timestamp = 0;
@@ -6913,10 +7264,2 @@
-	/* There's only a race with proc_BSSList_open(), but its
-	 * consequences are begnign. So I don't bother fixing it - Javier */
-
-	/* Try to read the first entry of the scan result */
-	rc = PC4500_readrid(ai, RID_BSSLISTFIRST, &BSSList, sizeof(BSSList), 1);
-	if((rc) || (BSSList.index == 0xffff)) {
-		/* Client error, no scan results...
-		 * The caller need to restart the scan. */
-		return -ENODATA;
-	}
+	if (down_interruptible(&ai->sem))
+		return -EAGAIN;
@@ -6924,2 +7267 @@
-	/* Read and parse all entries */
-	while((!rc) && (BSSList.index != 0xffff)) {
+	list_for_each_entry (net, &ai->network_list, list) {
@@ -6929 +7271 @@
-						 &BSSList);
+						 &net->bss);
@@ -6934 +7276,2 @@
-			return -E2BIG;
+			err = -E2BIG;
+			goto out;
@@ -6936,4 +7278,0 @@
-
-		/* Read next entry */
-		rc = PC4500_readrid(ai, RID_BSSLISTNEXT,
-				    &BSSList, sizeof(BSSList), 1);
@@ -6940,0 +7280 @@
+
@@ -6945 +7285,3 @@
-	return 0;
+out:
+	up(&ai->sem);
+	return err;
@@ -7052,0 +7395,9 @@
+	(iw_handler) NULL,			/* -- hole -- */
+	(iw_handler) NULL,			/* -- hole -- */
+	(iw_handler) NULL,			/* SIOCSIWGENIE */
+	(iw_handler) NULL,			/* SIOCGIWGENIE */
+	(iw_handler) airo_set_auth,		/* SIOCSIWAUTH */
+	(iw_handler) airo_get_auth,		/* SIOCGIWAUTH */
+	(iw_handler) airo_set_encodeext,	/* SIOCSIWENCODEEXT */
+	(iw_handler) airo_get_encodeext,	/* SIOCGIWENCODEEXT */
+	(iw_handler) NULL,			/* SIOCSIWPMKSA */
@@ -7273 +7623,0 @@
-#ifdef MICSUPPORT
@@ -7279 +7628,0 @@
-#endif
@@ -7311 +7659,0 @@
-#ifdef MICSUPPORT
@@ -7313 +7660,0 @@
-#endif
@@ -7370 +7716,0 @@
-#ifdef MICSUPPORT
@@ -7374 +7719,0 @@
-#endif
@@ -7490 +7835 @@
-		printk(KERN_INFO "Waitbusy hang before RESET\n");
+		airo_print_info(ai->dev->name, "Waitbusy hang before RESET");
@@ -7499 +7844 @@
-		printk(KERN_INFO "Waitbusy hang AFTER RESET\n");
+		airo_print_info(ai->dev->name, "Waitbusy hang AFTER RESET");
@@ -7527 +7872 @@
-		printk(KERN_INFO "Waitbusy hang after setflash mode\n");
+		airo_print_info(ai->dev->name, "Waitbusy hang after setflash mode");
@@ -7556 +7901 @@
-		printk(KERN_INFO "flash putchar busywait timeout! \n");
+		airo_print_info(ai->dev->name, "flash putchar busywait timeout!");
@@ -7645 +7990 @@
-				( ai, 2312, i >= MAX_FIDS / 2 );
+				( ai, AIRO_DEF_MTU, i >= MAX_FIDS / 2 );
--- ./projects/linux/linux-2.6.17/drivers/net/wireless/airo.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/net/wireless/airo.c	2006-09-20 05:42:06.000000000 +0200
@@ -22 +21,0 @@
-#include <linux/config.h>
@@ -49,0 +49 @@
+#include <net/ieee80211.h>
@@ -469,0 +470,2 @@
+#define RID_WPA_BSSLISTFIRST 0xFF74
+#define RID_WPA_BSSLISTNEXT  0xFF75
@@ -741,0 +744,8 @@
+
+/* Only present on firmware >= 5.30.17 */
+typedef struct {
+  u16 unknown[4];
+  u8 fixed[12]; /* WLAN management frame */
+  u8 iep[624];
+} BSSListRidExtra;
+
@@ -769,0 +780,3 @@
+
+  /* Only present on firmware >= 5.30.17 */
+  BSSListRidExtra extra;
@@ -1143,2 +1155,0 @@
-        unsigned long flags;
-#define FLAG_PROMISC	8	/* IFF_PROMISC 0x100 - include/linux/if.h */
@@ -1153,0 +1165 @@
+#define FLAG_PROMISC	8	/* IFF_PROMISC 0x100 - include/linux/if.h */
@@ -1161,11 +1173,13 @@
-#define JOB_MASK	0x2ff0000
-#define JOB_DIE		16
-#define JOB_XMIT	17
-#define JOB_XMIT11	18
-#define JOB_STATS	19
-#define JOB_PROMISC	20
-#define JOB_MIC		21
-#define JOB_EVENT	22
-#define JOB_AUTOWEP	23
-#define JOB_WSTATS	24
-#define JOB_SCAN_RESULTS  25
+#define FLAG_WPA_CAPABLE	16
+	unsigned long flags;
+#define JOB_DIE	0
+#define JOB_XMIT	1
+#define JOB_XMIT11	2
+#define JOB_STATS	3
+#define JOB_PROMISC	4
+#define JOB_MIC	5
+#define JOB_EVENT	6
+#define JOB_AUTOWEP	7
+#define JOB_WSTATS	8
+#define JOB_SCAN_RESULTS  9
+	unsigned long jobs;
@@ -1210,0 +1225,5 @@
+	/* WPA-related stuff */
+	unsigned int bssListFirst;
+	unsigned int bssListNext;
+	unsigned int bssListRidLen;
+
@@ -1267 +1286 @@
-	clear_bit(JOB_MIC, &ai->flags);
+	clear_bit(JOB_MIC, &ai->jobs);
@@ -1708,2 +1727,2 @@
-			Cmd cmd;
-			Resp rsp;
+	Cmd cmd;
+	Resp rsp;
@@ -1712,14 +1731,14 @@
-			if (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;
-			memset(&cmd, 0, sizeof(cmd));
-			cmd.cmd=CMD_LISTBSS;
-			if (down_interruptible(&ai->sem))
-				return -ERESTARTSYS;
-			issuecommand(ai, &cmd, &rsp);
-			up(&ai->sem);
-			/* Let the command take effect */
-			ai->task = current;
-			ssleep(3);
-			ai->task = NULL;
-		}
-	rc = PC4500_readrid(ai, first ? RID_BSSLISTFIRST : RID_BSSLISTNEXT,
-			    list, sizeof(*list), 1);
+		if (ai->flags & FLAG_RADIO_MASK) return -ENETDOWN;
+		memset(&cmd, 0, sizeof(cmd));
+		cmd.cmd=CMD_LISTBSS;
+		if (down_interruptible(&ai->sem))
+			return -ERESTARTSYS;
+		issuecommand(ai, &cmd, &rsp);
+		up(&ai->sem);
+		/* Let the command take effect */
+		ai->task = current;
+		ssleep(3);
+		ai->task = NULL;
+	}
+	rc = PC4500_readrid(ai, first ? ai->bssListFirst : ai->bssListNext,
+			    list, ai->bssListRidLen, 1);
@@ -2115 +2134 @@
-	clear_bit(JOB_XMIT, &priv->flags);
+	clear_bit(JOB_XMIT, &priv->jobs);
@@ -2165 +2184 @@
-		set_bit(JOB_XMIT, &priv->flags);
+		set_bit(JOB_XMIT, &priv->jobs);
@@ -2180 +2199 @@
-	clear_bit(JOB_XMIT11, &priv->flags);
+	clear_bit(JOB_XMIT11, &priv->jobs);
@@ -2236 +2255 @@
-		set_bit(JOB_XMIT11, &priv->flags);
+		set_bit(JOB_XMIT11, &priv->jobs);
@@ -2247 +2266 @@
-	clear_bit(JOB_STATS, &ai->flags);
+	clear_bit(JOB_STATS, &ai->jobs);
@@ -2275 +2294 @@
-	if (!test_bit(JOB_STATS, &local->flags)) {
+	if (!test_bit(JOB_STATS, &local->jobs)) {
@@ -2278 +2297 @@
-			set_bit(JOB_STATS, &local->flags);
+			set_bit(JOB_STATS, &local->jobs);
@@ -2293 +2312 @@
-	clear_bit(JOB_PROMISC, &ai->flags);
+	clear_bit(JOB_PROMISC, &ai->jobs);
@@ -2305 +2324 @@
-			set_bit(JOB_PROMISC, &ai->flags);
+			set_bit(JOB_PROMISC, &ai->jobs);
@@ -2383 +2402 @@
-	set_bit(JOB_DIE, &ai->flags);
+	set_bit(JOB_DIE, &ai->jobs);
@@ -2704 +2723 @@
-#define MAX_NETWORK_COUNT	64
+#define AIRO_MAX_NETWORK_COUNT	64
@@ -2711 +2730 @@
-	    kzalloc(MAX_NETWORK_COUNT * sizeof(BSSListElement),
+	    kzalloc(AIRO_MAX_NETWORK_COUNT * sizeof(BSSListElement),
@@ -2735 +2754 @@
-	for (i = 0; i < MAX_NETWORK_COUNT; i++)
+	for (i = 0; i < AIRO_MAX_NETWORK_COUNT; i++)
@@ -2739,0 +2759,22 @@
+static int airo_test_wpa_capable(struct airo_info *ai)
+{
+	int status;
+	CapabilityRid cap_rid;
+	const char *name = ai->dev->name;
+
+	status = readCapabilityRid(ai, &cap_rid, 1);
+	if (status != SUCCESS) return 0;
+
+	/* Only firmware versions 5.30.17 or better can do WPA */
+	if ((cap_rid.softVer > 0x530)
+	  || ((cap_rid.softVer == 0x530) && (cap_rid.softSubVer >= 17))) {
+		airo_print_info(name, "WPA is supported.");
+		return 1;
+	}
+
+	/* No WPA support */
+	airo_print_info(name, "WPA unsupported (only firmware versions 5.30.17"
+		" and greater support WPA.  Detected %s)", cap_rid.prodVer);
+	return 0;
+}
+
@@ -2761,0 +2803 @@
+	ai->jobs = 0;
@@ -2809 +2851 @@
-	rc = request_irq( dev->irq, airo_interrupt, SA_SHIRQ, dev->name, dev );
+	rc = request_irq( dev->irq, airo_interrupt, IRQF_SHARED, dev->name, dev );
@@ -2840,0 +2883,12 @@
+	/* Test for WPA support */
+	if (airo_test_wpa_capable(ai)) {
+		set_bit(FLAG_WPA_CAPABLE, &ai->flags);
+		ai->bssListFirst = RID_WPA_BSSLISTFIRST;
+		ai->bssListNext = RID_WPA_BSSLISTNEXT;
+		ai->bssListRidLen = sizeof(BSSListRid);
+	} else {
+		ai->bssListFirst = RID_BSSLISTFIRST;
+		ai->bssListNext = RID_BSSLISTNEXT;
+		ai->bssListRidLen = sizeof(BSSListRid) - sizeof(BSSListRidExtra);
+	}
+
@@ -2878 +2932 @@
-	set_bit(JOB_DIE, &ai->flags);
+	set_bit(JOB_DIE, &ai->jobs);
@@ -2936 +2990 @@
-	clear_bit(JOB_EVENT, &ai->flags);
+	clear_bit(JOB_EVENT, &ai->jobs);
@@ -2950 +3004 @@
-	BSSListRid BSSList;
+	BSSListRid bss;
@@ -2963,2 +3017,2 @@
-	rc = PC4500_readrid(ai, RID_BSSLISTFIRST, &BSSList, sizeof(BSSList), 0);
-	if((rc) || (BSSList.index == 0xffff)) {
+	rc = PC4500_readrid(ai, ai->bssListFirst, &bss, ai->bssListRidLen, 0);
+	if((rc) || (bss.index == 0xffff)) {
@@ -2971 +3025 @@
-	while((!rc) && (BSSList.index != 0xffff)) {
+	while((!rc) && (bss.index != 0xffff)) {
@@ -2980 +3034 @@
-			memcpy(tmp_net, &BSSList, sizeof(tmp_net->bss));
+			memcpy(tmp_net, &bss, sizeof(tmp_net->bss));
@@ -2986,2 +3040,2 @@
-		rc = PC4500_readrid(ai, RID_BSSLISTNEXT,
-				    &BSSList, sizeof(BSSList), 0);
+		rc = PC4500_readrid(ai, ai->bssListNext,
+				    &bss, ai->bssListRidLen, 0);
@@ -2992 +3046 @@
-	clear_bit(JOB_SCAN_RESULTS, &ai->flags);
+	clear_bit(JOB_SCAN_RESULTS, &ai->jobs);
@@ -3022 +3076 @@
-		if (test_bit(JOB_DIE, &ai->flags))
+		if (test_bit(JOB_DIE, &ai->jobs))
@@ -3025 +3079 @@
-		if (ai->flags & JOB_MASK) {
+		if (ai->jobs) {
@@ -3034 +3088 @@
-				if (ai->flags & JOB_MASK)
+				if (ai->jobs)
@@ -3039 +3093 @@
-						set_bit(JOB_SCAN_RESULTS,&ai->flags);
+						set_bit(JOB_SCAN_RESULTS, &ai->jobs);
@@ -3043 +3097 @@
-						set_bit(JOB_AUTOWEP,&ai->flags);
+						set_bit(JOB_AUTOWEP, &ai->jobs);
@@ -3072 +3126 @@
-		if (test_bit(JOB_DIE, &ai->flags)) {
+		if (test_bit(JOB_DIE, &ai->jobs)) {
@@ -3082 +3136 @@
-		if (test_bit(JOB_XMIT, &ai->flags))
+		if (test_bit(JOB_XMIT, &ai->jobs))
@@ -3084 +3138 @@
-		else if (test_bit(JOB_XMIT11, &ai->flags))
+		else if (test_bit(JOB_XMIT11, &ai->jobs))
@@ -3086 +3140 @@
-		else if (test_bit(JOB_STATS, &ai->flags))
+		else if (test_bit(JOB_STATS, &ai->jobs))
@@ -3088 +3142 @@
-		else if (test_bit(JOB_WSTATS, &ai->flags))
+		else if (test_bit(JOB_WSTATS, &ai->jobs))
@@ -3090 +3144 @@
-		else if (test_bit(JOB_PROMISC, &ai->flags))
+		else if (test_bit(JOB_PROMISC, &ai->jobs))
@@ -3092 +3146 @@
-		else if (test_bit(JOB_MIC, &ai->flags))
+		else if (test_bit(JOB_MIC, &ai->jobs))
@@ -3094 +3148 @@
-		else if (test_bit(JOB_EVENT, &ai->flags))
+		else if (test_bit(JOB_EVENT, &ai->jobs))
@@ -3096 +3150 @@
-		else if (test_bit(JOB_AUTOWEP, &ai->flags))
+		else if (test_bit(JOB_AUTOWEP, &ai->jobs))
@@ -3098 +3152 @@
-		else if (test_bit(JOB_SCAN_RESULTS, &ai->flags))
+		else if (test_bit(JOB_SCAN_RESULTS, &ai->jobs))
@@ -3136 +3190 @@
-				set_bit(JOB_MIC, &apriv->flags);
+				set_bit(JOB_MIC, &apriv->jobs);
@@ -3190 +3244 @@
-					set_bit(JOB_EVENT, &apriv->flags);
+					set_bit(JOB_EVENT, &apriv->jobs);
@@ -5488 +5542 @@
-	clear_bit(JOB_AUTOWEP, &apriv->flags);
+	clear_bit(JOB_AUTOWEP, &apriv->jobs);
@@ -6879 +6933 @@
-	range->we_version_source = 12;
+	range->we_version_source = 19;
@@ -7154,0 +7209 @@
+	char *		buf;
@@ -7241,2 +7296,63 @@
-	/* The other data in the scan result are not really
-	 * interesting, so for now drop it - Jean II */
+	/* Beacon interval */
+	buf = kmalloc(30, GFP_KERNEL);
+	if (buf) {
+		iwe.cmd = IWEVCUSTOM;
+		sprintf(buf, "bcn_int=%d", bss->beaconInterval);
+		iwe.u.data.length = strlen(buf);
+		current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+		kfree(buf);
+	}
+
+	/* Put WPA/RSN Information Elements into the event stream */
+	if (test_bit(FLAG_WPA_CAPABLE, &ai->flags)) {
+		unsigned int num_null_ies = 0;
+		u16 length = sizeof (bss->extra.iep);
+		struct ieee80211_info_element *info_element =
+			(struct ieee80211_info_element *) &bss->extra.iep;
+
+		while ((length >= sizeof(*info_element)) && (num_null_ies < 2)) {
+			if (sizeof(*info_element) + info_element->len > length) {
+				/* Invalid element, don't continue parsing IE */
+				break;
+			}
+
+			switch (info_element->id) {
+			case MFIE_TYPE_SSID:
+				/* Two zero-length SSID elements
+				 * mean we're done parsing elements */
+				if (!info_element->len)
+					num_null_ies++;
+				break;
+
+			case MFIE_TYPE_GENERIC:
+				if (info_element->len >= 4 &&
+				    info_element->data[0] == 0x00 &&
+				    info_element->data[1] == 0x50 &&
+				    info_element->data[2] == 0xf2 &&
+				    info_element->data[3] == 0x01) {
+					iwe.cmd = IWEVGENIE;
+					iwe.u.data.length = min(info_element->len + 2,
+								  MAX_WPA_IE_LEN);
+					current_ev = iwe_stream_add_point(current_ev, end_buf,
+							&iwe, (char *) info_element);
+				}
+				break;
+
+			case MFIE_TYPE_RSN:
+				iwe.cmd = IWEVGENIE;
+				iwe.u.data.length = min(info_element->len + 2,
+							  MAX_WPA_IE_LEN);
+				current_ev = iwe_stream_add_point(current_ev, end_buf,
+						&iwe, (char *) info_element);
+				break;
+
+			default:
+				break;
+			}
+
+			length -= sizeof(*info_element) + info_element->len;
+			info_element =
+			    (struct ieee80211_info_element *)&info_element->
+			    data[info_element->len];
+		}
+	}
@@ -7524 +7640 @@
-	clear_bit(JOB_WSTATS, &local->flags);
+	clear_bit(JOB_WSTATS, &local->jobs);
@@ -7568 +7684 @@
-	if (!test_bit(JOB_WSTATS, &local->flags)) {
+	if (!test_bit(JOB_WSTATS, &local->jobs)) {
@@ -7571 +7687 @@
-			set_bit(JOB_WSTATS, &local->flags);
+			set_bit(JOB_WSTATS, &local->jobs);
--- ./projects/linux/linux-2.6.18/drivers/net/wireless/airo.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/net/wireless/airo.c	2006-11-29 22:57:37.000000000 +0100
@@ -21,0 +22 @@
+#include <linux/err.h>
@@ -49,0 +51 @@
+#include <linux/kthread.h>
@@ -1121,2 +1123 @@
-static irqreturn_t airo_interrupt( int irq, void* dev_id, struct pt_regs
-			    *regs);
+static irqreturn_t airo_interrupt( int irq, void* dev_id);
@@ -1190 +1191,2 @@
-	struct task_struct *task;
+	struct task_struct *list_bss_task;
+	struct task_struct *airo_thread_task;
@@ -1192 +1193,0 @@
-	pid_t thr_pid;
@@ -1194 +1194,0 @@
-	struct completion thr_exited;
@@ -1206 +1206 @@
-	struct crypto_tfm	*tfm;
+	struct crypto_cipher	*tfm;
@@ -1274 +1274,2 @@
-static void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen, struct crypto_tfm *);
+static void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen,
+			   struct crypto_cipher *tfm);
@@ -1342 +1343 @@
-	        ai->tfm = crypto_alloc_tfm("aes", CRYPTO_TFM_REQ_MAY_SLEEP);
+	        ai->tfm = crypto_alloc_cipher("aes", 0, CRYPTO_ALG_ASYNC);
@@ -1344 +1345 @@
-        if (ai->tfm == NULL) {
+        if (IS_ERR(ai->tfm)) {
@@ -1345,0 +1347 @@
+                ai->tfm = NULL;
@@ -1611 +1613,2 @@
-static void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen, struct crypto_tfm *tfm)
+static void emmh32_setseed(emmh32_context *context, u8 *pkey, int keylen,
+			   struct crypto_cipher *tfm)
@@ -1619 +1621,0 @@
-	struct scatterlist sg[1];
@@ -1630,3 +1632,2 @@
-		sg_set_buf(sg, plain, 16);
-		crypto_cipher_encrypt(tfm, sg, sg, 16);
-		cipher = kmap(sg->page) + sg->offset;
+		crypto_cipher_encrypt_one(tfm, plain, plain);
+		cipher = plain;
@@ -1735,0 +1737 @@
+		ai->list_bss_task = current;
@@ -1739,3 +1741,2 @@
-		ai->task = current;
-		ssleep(3);
-		ai->task = NULL;
+		schedule_timeout_uninterruptible(3 * HZ);
+		ai->list_bss_task = NULL;
@@ -2403,2 +2404 @@
-	kill_proc(ai->thr_pid, SIGTERM, 1);
-	wait_for_completion(&ai->thr_exited);
+	kthread_stop(ai->airo_thread_task);
@@ -2435 +2435 @@
-	crypto_free_tfm(ai->tfm);
+	crypto_free_cipher(ai->tfm);
@@ -2814,3 +2814,2 @@
-	init_completion (&ai->thr_exited);
-	ai->thr_pid = kernel_thread(airo_thread, dev, CLONE_FS | CLONE_FILES);
-	if (ai->thr_pid < 0)
+	ai->airo_thread_task = kthread_run(airo_thread, dev, dev->name);
+	if (IS_ERR(ai->airo_thread_task))
@@ -2900,0 +2900,2 @@
+	if (!ai->wifidev)
+		goto err_out_reg;
@@ -2912 +2913,3 @@
-	setup_proc_entry( dev, dev->priv ); /* XXX check for failure */
+	if (setup_proc_entry(dev, dev->priv) < 0)
+		goto err_out_wifi;
+
@@ -2916,0 +2920,5 @@
+err_out_wifi:
+	unregister_netdev(ai->wifidev);
+	free_netdev(ai->wifidev);
+err_out_reg:
+	unregister_netdev(dev);
@@ -2933,2 +2941 @@
-	kill_proc(ai->thr_pid, SIGTERM, 1);
-	wait_for_completion(&ai->thr_exited);
+	kthread_stop(ai->airo_thread_task);
@@ -3066,3 +3072,0 @@
-	daemonize("%s", dev->name);
-	allow_signal(SIGTERM);
-
@@ -3070,3 +3073,0 @@
-		if (signal_pending(current))
-			flush_signals(current);
-
@@ -3100 +3101,2 @@
-					if (!signal_pending(current)) {
+					if (!kthread_should_stop() &&
+					    !freezing(current)) {
@@ -3112 +3114,2 @@
-				} else if (!signal_pending(current)) {
+				} else if (!kthread_should_stop() &&
+					   !freezing(current)) {
@@ -3157 +3160,2 @@
-	complete_and_exit (&ai->thr_exited, 0);
+
+	return 0;
@@ -3160 +3164 @@
-static irqreturn_t airo_interrupt ( int irq, void* dev_id, struct pt_regs *regs) {
+static irqreturn_t airo_interrupt ( int irq, void* dev_id) {
@@ -3238,2 +3242,2 @@
-				if (apriv->task)
-					wake_up_process (apriv->task);
+				if (apriv->list_bss_task)
+					wake_up_process(apriv->list_bss_task);
@@ -3953,7 +3957,5 @@
-	if ((pRsp->status & 0xff00)!=0 && pCmd->cmd != CMD_SOFTRESET) {
-		airo_print_err(ai->dev->name, "cmd= %x\n", pCmd->cmd);
-		airo_print_err(ai->dev->name, "status= %x\n", pRsp->status);
-		airo_print_err(ai->dev->name, "Rsp0= %x\n", pRsp->rsp0);
-		airo_print_err(ai->dev->name, "Rsp1= %x\n", pRsp->rsp1);
-		airo_print_err(ai->dev->name, "Rsp2= %x\n", pRsp->rsp2);
-	}
+	if ((pRsp->status & 0xff00)!=0 && pCmd->cmd != CMD_SOFTRESET)
+		airo_print_err(ai->dev->name,
+			"cmd:%x status:%x rsp0:%x rsp1:%x rsp2:%x",
+			pCmd->cmd, pRsp->status, pRsp->rsp0, pRsp->rsp1,
+			pRsp->rsp2);
@@ -4507,3 +4509,5 @@
-        apriv->proc_entry->uid = proc_uid;
-        apriv->proc_entry->gid = proc_gid;
-        apriv->proc_entry->owner = THIS_MODULE;
+	if (!apriv->proc_entry)
+		goto fail;
+	apriv->proc_entry->uid = proc_uid;
+	apriv->proc_entry->gid = proc_gid;
+	apriv->proc_entry->owner = THIS_MODULE;
@@ -4515,2 +4519,4 @@
-        entry->uid = proc_uid;
-        entry->gid = proc_gid;
+	if (!entry)
+		goto fail_stats_delta;
+	entry->uid = proc_uid;
+	entry->gid = proc_gid;
@@ -4518 +4524 @@
-        entry->owner = THIS_MODULE;
+	entry->owner = THIS_MODULE;
@@ -4525,2 +4531,4 @@
-        entry->uid = proc_uid;
-        entry->gid = proc_gid;
+	if (!entry)
+		goto fail_stats;
+	entry->uid = proc_uid;
+	entry->gid = proc_gid;
@@ -4528 +4536 @@
-        entry->owner = THIS_MODULE;
+	entry->owner = THIS_MODULE;
@@ -4535,2 +4543,4 @@
-        entry->uid = proc_uid;
-        entry->gid = proc_gid;
+	if (!entry)
+		goto fail_status;
+	entry->uid = proc_uid;
+	entry->gid = proc_gid;
@@ -4538 +4548 @@
-        entry->owner = THIS_MODULE;
+	entry->owner = THIS_MODULE;
@@ -4545,2 +4555,4 @@
-        entry->uid = proc_uid;
-        entry->gid = proc_gid;
+	if (!entry)
+		goto fail_config;
+	entry->uid = proc_uid;
+	entry->gid = proc_gid;
@@ -4548 +4560 @@
-        entry->owner = THIS_MODULE;
+	entry->owner = THIS_MODULE;
@@ -4555,2 +4567,4 @@
-        entry->uid = proc_uid;
-        entry->gid = proc_gid;
+	if (!entry)
+		goto fail_ssid;
+	entry->uid = proc_uid;
+	entry->gid = proc_gid;
@@ -4558 +4572 @@
-        entry->owner = THIS_MODULE;
+	entry->owner = THIS_MODULE;
@@ -4565,2 +4579,4 @@
-        entry->uid = proc_uid;
-        entry->gid = proc_gid;
+	if (!entry)
+		goto fail_aplist;
+	entry->uid = proc_uid;
+	entry->gid = proc_gid;
@@ -4568 +4584 @@
-        entry->owner = THIS_MODULE;
+	entry->owner = THIS_MODULE;
@@ -4574,0 +4591,2 @@
+	if (!entry)
+		goto fail_bsslist;
@@ -4578 +4596 @@
-        entry->owner = THIS_MODULE;
+	entry->owner = THIS_MODULE;
@@ -4585,2 +4603,4 @@
-        entry->uid = proc_uid;
-        entry->gid = proc_gid;
+	if (!entry)
+		goto fail_wepkey;
+	entry->uid = proc_uid;
+	entry->gid = proc_gid;
@@ -4588 +4608 @@
-        entry->owner = THIS_MODULE;
+	entry->owner = THIS_MODULE;
@@ -4591,0 +4612,19 @@
+
+fail_wepkey:
+	remove_proc_entry("BSSList", apriv->proc_entry);
+fail_bsslist:
+	remove_proc_entry("APList", apriv->proc_entry);
+fail_aplist:
+	remove_proc_entry("SSID", apriv->proc_entry);
+fail_ssid:
+	remove_proc_entry("Config", apriv->proc_entry);
+fail_config:
+	remove_proc_entry("Status", apriv->proc_entry);
+fail_status:
+	remove_proc_entry("Stats", apriv->proc_entry);
+fail_stats:
+	remove_proc_entry("StatsDelta", apriv->proc_entry);
+fail_stats_delta:
+	remove_proc_entry(apriv->proc_name, airo_entry);
+fail:
+	return -ENOMEM;
@@ -5670 +5709,4 @@
-	int i, have_isa_dev = 0;
+	int i;
+#if 0
+	int have_isa_dev = 0;
+#endif
@@ -5675,2 +5717,5 @@
-        airo_entry->uid = proc_uid;
-        airo_entry->gid = proc_gid;
+
+	if (airo_entry) {
+		airo_entry->uid = proc_uid;
+		airo_entry->gid = proc_gid;
+	}
@@ -5681,0 +5727 @@
+#if 0
@@ -5682,0 +5729,3 @@
+#else
+			/* do nothing */ ;
+#endif
@@ -5687 +5736 @@
-	pci_register_driver(&airo_driver);
+	i = pci_register_driver(&airo_driver);
@@ -5688,0 +5738,5 @@
+
+	if (i) {
+		remove_proc_entry("aironet", proc_root_driver);
+		return i;
+	}
@@ -5879 +5933 @@
-		if(dwrq->length > IW_ESSID_MAX_SIZE+1) {
+		if(dwrq->length > IW_ESSID_MAX_SIZE) {
@@ -5891 +5945 @@
-		SSID_rid.ssids[index].len = dwrq->length - 1;
+		SSID_rid.ssids[index].len = dwrq->length;
@@ -5921 +5974,0 @@
-	extra[status_rid.SSIDlen] = '\0';
@@ -6001 +6054 @@
-	if(dwrq->length > 16 + 1) {
+	if(dwrq->length > 16) {
@@ -6026 +6079 @@
-	dwrq->length = strlen(extra) + 1;
+	dwrq->length = strlen(extra);
@@ -6778 +6831 @@
-		if(vwrq->flags & IW_RETRY_MAX)
+		if(vwrq->flags & IW_RETRY_LONG)
@@ -6780 +6833 @@
-		else if (vwrq->flags & IW_RETRY_MIN)
+		else if (vwrq->flags & IW_RETRY_SHORT)
@@ -6816,2 +6869,2 @@
-	} else if((vwrq->flags & IW_RETRY_MAX)) {
-		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_MAX;
+	} else if((vwrq->flags & IW_RETRY_LONG)) {
+		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;
@@ -6823 +6876 @@
-			vwrq->flags |= IW_RETRY_MIN;
+			vwrq->flags |= IW_RETRY_SHORT;
@@ -7000,0 +7054 @@
+			/* This is broken, fixme ;-) */
--- ./projects/linux/linux-2.6.19/drivers/net/wireless/airo.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/net/wireless/airo.c	2007-02-04 19:44:54.000000000 +0100
@@ -51,0 +52 @@
+#include <linux/freezer.h>
--- ./projects/linux/linux-2.6.20/drivers/net/wireless/airo.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/net/wireless/airo.c	2007-04-26 05:08:32.000000000 +0200
@@ -1626 +1626 @@
-	for (i = 0; i < (sizeof(context->coeff)/sizeof(context->coeff[0])); ) {
+	for (i = 0; i < ARRAY_SIZE(context->coeff); ) {
@@ -1635 +1635 @@
-		for (j=0; (j<16) && (i< (sizeof(context->coeff)/sizeof(context->coeff[0]))); ) {
+		for (j = 0; (j < 16) && (i < ARRAY_SIZE(context->coeff)); ) {
@@ -2855 +2855 @@
-		goto err_out_unlink;
+		goto err_out_nets;
@@ -2937,0 +2938,2 @@
+err_out_nets:
+	airo_networks_free(ai);
@@ -4433 +4435 @@
-static struct file_operations proc_statsdelta_ops = {
+static const struct file_operations proc_statsdelta_ops = {
@@ -4439 +4441 @@
-static struct file_operations proc_stats_ops = {
+static const struct file_operations proc_stats_ops = {
@@ -4445 +4447 @@
-static struct file_operations proc_status_ops = {
+static const struct file_operations proc_status_ops = {
@@ -4451 +4453 @@
-static struct file_operations proc_SSID_ops = {
+static const struct file_operations proc_SSID_ops = {
@@ -4458 +4460 @@
-static struct file_operations proc_BSSList_ops = {
+static const struct file_operations proc_BSSList_ops = {
@@ -4465 +4467 @@
-static struct file_operations proc_APList_ops = {
+static const struct file_operations proc_APList_ops = {
@@ -4472 +4474 @@
-static struct file_operations proc_config_ops = {
+static const struct file_operations proc_config_ops = {
@@ -4479 +4481 @@
-static struct file_operations proc_wepkey_ops = {
+static const struct file_operations proc_wepkey_ops = {
--- ./projects/linux/linux-2.6.21/drivers/net/wireless/airo.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/net/wireless/airo.c	2007-07-09 01:32:17.000000000 +0200
@@ -28 +27,0 @@
-#include <linux/smp_lock.h>
@@ -1147,0 +1147 @@
+	struct list_head              dev_list;
@@ -2362,0 +2363,15 @@
+static LIST_HEAD(airo_devices);
+
+static void add_airo_dev(struct airo_info *ai)
+{
+	/* Upper layers already keep track of PCI devices,
+	 * so we only need to remember our non-PCI cards. */
+	if (!ai->pci)
+		list_add_tail(&ai->dev_list, &airo_devices);
+}
+
+static void del_airo_dev(struct airo_info *ai)
+{
+	if (!ai->pci)
+		list_del(&ai->dev_list);
+}
@@ -2384,2 +2398,0 @@
-static void del_airo_dev( struct net_device *dev );
-
@@ -2437 +2450 @@
-	del_airo_dev( dev );
+	del_airo_dev(ai);
@@ -2443,2 +2455,0 @@
-static int add_airo_dev( struct net_device *dev );
-
@@ -2447 +2458 @@
-	memcpy(haddr, skb->mac.raw + 10, ETH_ALEN);
+	memcpy(haddr, skb_mac_header(skb) + 10, ETH_ALEN);
@@ -2743,2 +2753,0 @@
-	if (!ai->networks)
-		return;
@@ -2819,3 +2828 @@
-	rc = add_airo_dev( dev );
-	if (rc)
-		goto err_out_thr;
+	add_airo_dev(ai);
@@ -2824 +2831 @@
-		goto err_out_unlink;
+		goto err_out_thr;
@@ -2940,2 +2946,0 @@
-err_out_unlink:
-	del_airo_dev(dev);
@@ -2942,0 +2948 @@
+	del_airo_dev(ai);
@@ -3414 +3420 @@
-				skb->mac.raw = skb->data;
+				skb_reset_mac_header(skb);
@@ -3418,2 +3424 @@
-			} else {
-				skb->dev = dev;
+			} else
@@ -3421 +3425,0 @@
-			}
@@ -3644 +3647,0 @@
-		skb->dev = ai->dev;
@@ -3752 +3755 @@
-	skb->mac.raw = skb->data;
+	skb_reset_mac_header(skb);
@@ -5541,5 +5543,0 @@
-static struct net_device_list {
-	struct net_device *dev;
-	struct net_device_list *next;
-} *airo_devices;
-
@@ -5588,20 +5585,0 @@
-static int add_airo_dev( struct net_device *dev ) {
-	struct net_device_list *node = kmalloc( sizeof( *node ), GFP_KERNEL );
-	if ( !node )
-		return -ENOMEM;
-
-	node->dev = dev;
-	node->next = airo_devices;
-	airo_devices = node;
-
-	return 0;
-}
-
-static void del_airo_dev( struct net_device *dev ) {
-	struct net_device_list **p = &airo_devices;
-	while( *p && ( (*p)->dev != dev ) )
-		p = &(*p)->next;
-	if ( *p && (*p)->dev == dev )
-		*p = (*p)->next;
-}
-
@@ -5630,0 +5609,4 @@
+	struct net_device *dev = pci_get_drvdata(pdev);
+
+	airo_print_info(dev->name, "Unregistering...");
+	stop_airo_card(dev, 1);
@@ -5756,3 +5738,5 @@
-	while( airo_devices ) {
-		airo_print_info(airo_devices->dev->name, "Unregistering...\n");
-		stop_airo_card( airo_devices->dev, 1 );
+	struct airo_info *ai;
+	while(!list_empty(&airo_devices)) {
+		ai = list_entry(airo_devices.next, struct airo_info, dev_list);
+		airo_print_info(ai->dev->name, "Unregistering...");
+		stop_airo_card(ai->dev, 1);
--- ./projects/linux/linux-2.6.22/drivers/net/wireless/airo.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/net/wireless/airo.c	2007-10-09 22:31:38.000000000 +0200
@@ -54,0 +55,2 @@
+#define DRV_NAME "airo"
+
@@ -74 +76 @@
-	.name     = "airo",
+	.name     = DRV_NAME,
@@ -1095 +1097 @@
-static int enable_MAC( struct airo_info *ai, Resp *rsp, int lock );
+static int enable_MAC(struct airo_info *ai, int lock);
@@ -1253 +1255 @@
-	{ printk(type "airo(%s): " fmt "\n", name, ##args); }
+	printk(type DRV_NAME "(%s): " fmt "\n", name, ##args)
@@ -1928,0 +1931,8 @@
+static void try_auto_wep(struct airo_info *ai)
+{
+	if (auto_wep && !(ai->flags & FLAG_RADIO_DOWN)) {
+		ai->expires = RUN_AT(3*HZ);
+		wake_up_interruptible(&ai->thr_wait);
+	}
+}
+
@@ -1930,2 +1940,2 @@
-	struct airo_info *info = dev->priv;
-	Resp rsp;
+	struct airo_info *ai = dev->priv;
+	int rc = 0;
@@ -1933 +1943 @@
-	if (test_bit(FLAG_FLASHING, &info->flags))
+	if (test_bit(FLAG_FLASHING, &ai->flags))
@@ -1940,3 +1950,3 @@
-	if (test_bit (FLAG_COMMIT, &info->flags)) {
-		disable_MAC(info, 1);
-		writeConfigRid(info, 1);
+	if (test_bit(FLAG_COMMIT, &ai->flags)) {
+		disable_MAC(ai, 1);
+		writeConfigRid(ai, 1);
@@ -1945 +1955,17 @@
-	if (info->wifidev != dev) {
+	if (ai->wifidev != dev) {
+		clear_bit(JOB_DIE, &ai->jobs);
+		ai->airo_thread_task = kthread_run(airo_thread, dev, dev->name);
+		if (IS_ERR(ai->airo_thread_task))
+			return (int)PTR_ERR(ai->airo_thread_task);
+
+		rc = request_irq(dev->irq, airo_interrupt, IRQF_SHARED,
+			dev->name, dev);
+		if (rc) {
+			airo_print_err(dev->name,
+				"register interrupt %d failed, rc %d",
+				dev->irq, rc);
+			set_bit(JOB_DIE, &ai->jobs);
+			kthread_stop(ai->airo_thread_task);
+			return rc;
+		}
+
@@ -1947,2 +1973,4 @@
-		clear_bit(FLAG_RADIO_DOWN, &info->flags);
-		enable_interrupts(info);
+		clear_bit(FLAG_RADIO_DOWN, &ai->flags);
+		enable_interrupts(ai);
+
+		try_auto_wep(ai);
@@ -1950 +1978 @@
-	enable_MAC(info, &rsp, 1);
+	enable_MAC(ai, 1);
@@ -2341 +2368,0 @@
-	Resp rsp;
@@ -2348 +2375 @@
-	enable_MAC(ai, &rsp, 1);
+	enable_MAC(ai, 1);
@@ -2394,0 +2422,5 @@
+
+		free_irq(dev->irq, dev);
+
+		set_bit(JOB_DIE, &ai->jobs);
+		kthread_stop(ai->airo_thread_task);
@@ -2406 +2437,0 @@
-	free_irq( dev->irq, dev );
@@ -2417,3 +2447,0 @@
-	set_bit(JOB_DIE, &ai->jobs);
-	kthread_stop(ai->airo_thread_task);
-
@@ -2557,2 +2585 @@
-static int mpi_map_card(struct airo_info *ai, struct pci_dev *pci,
-		    const char *name)
+static int mpi_map_card(struct airo_info *ai, struct pci_dev *pci)
@@ -2572,3 +2599,3 @@
-	if (!request_mem_region(mem_start, mem_len, name)) {
-		airo_print_err(ai->dev->name, "Couldn't get region %x[%x] for %s",
-		       (int)mem_start, (int)mem_len, name);
+	if (!request_mem_region(mem_start, mem_len, DRV_NAME)) {
+		airo_print_err("", "Couldn't get region %x[%x]",
+			(int)mem_start, (int)mem_len);
@@ -2577,3 +2604,3 @@
-	if (!request_mem_region(aux_start, aux_len, name)) {
-		airo_print_err(ai->dev->name, "Couldn't get region %x[%x] for %s",
-		       (int)aux_start, (int)aux_len, name);
+	if (!request_mem_region(aux_start, aux_len, DRV_NAME)) {
+		airo_print_err("", "Couldn't get region %x[%x]",
+			(int)aux_start, (int)aux_len);
@@ -2585,2 +2612,2 @@
-		airo_print_err(ai->dev->name, "Couldn't map region %x[%x] for %s",
-		       (int)mem_start, (int)mem_len, name);
+		airo_print_err("", "Couldn't map region %x[%x]",
+			(int)mem_start, (int)mem_len);
@@ -2591,2 +2618,2 @@
-		airo_print_err(ai->dev->name, "Couldn't map region %x[%x] for %s",
-		       (int)aux_start, (int)aux_len, name);
+		airo_print_err("", "Couldn't map region %x[%x]",
+			(int)aux_start, (int)aux_len);
@@ -2599,2 +2626,2 @@
-		airo_print_err(ai->dev->name, "Couldn't alloc_consistent %d",
-		       PCI_SHARED_LEN);
+		airo_print_err("", "Couldn't alloc_consistent %d",
+			PCI_SHARED_LEN);
@@ -2745 +2772 @@
-		airo_print_warn(ai->dev->name, "Out of memory allocating beacons");
+		airo_print_warn("", "Out of memory allocating beacons");
@@ -2773 +2799,0 @@
-	const char *name = ai->dev->name;
@@ -2781 +2807 @@
-		airo_print_info(name, "WPA is supported.");
+		airo_print_info("", "WPA is supported.");
@@ -2786 +2812 @@
-	airo_print_info(name, "WPA unsupported (only firmware versions 5.30.17"
+	airo_print_info("", "WPA unsupported (only firmware versions 5.30.17"
@@ -2800,2 +2826,2 @@
-        dev = alloc_etherdev(sizeof(*ai));
-        if (!dev) {
+	dev = alloc_netdev(sizeof(*ai), "", ether_setup);
+	if (!dev) {
@@ -2804,4 +2829,0 @@
-        }
-	if (dev_alloc_name(dev, dev->name) < 0) {
-		airo_print_err("", "Couldn't get name!");
-		goto err_out_free;
@@ -2812 +2834 @@
-	ai->flags = 0;
+	ai->flags = 1 << FLAG_RADIO_DOWN;
@@ -2816 +2838 @@
-		airo_print_dbg(dev->name, "Found an MPI350 card");
+		airo_print_dbg("", "Found an MPI350 card");
@@ -2824,3 +2845,0 @@
-	ai->airo_thread_task = kthread_run(airo_thread, dev, dev->name);
-	if (IS_ERR(ai->airo_thread_task))
-		goto err_out_free;
@@ -2831 +2850 @@
-		goto err_out_thr;
+		goto err_out_free;
@@ -2853,0 +2873 @@
+	SET_MODULE_OWNER(dev);
@@ -2858,6 +2877,0 @@
-	rc = request_irq( dev->irq, airo_interrupt, IRQF_SHARED, dev->name, dev );
-	if (rc) {
-		airo_print_err(dev->name, "register interrupt %d failed, rc %d",
-				irq, rc);
-		goto err_out_nets;
-	}
@@ -2865 +2879 @@
-		if (!request_region( dev->base_addr, 64, dev->name )) {
+		if (!request_region(dev->base_addr, 64, DRV_NAME)) {
@@ -2868 +2882 @@
-			goto err_out_irq;
+			goto err_out_nets;
@@ -2873,2 +2887,2 @@
-		if (mpi_map_card(ai, pci, dev->name)) {
-			airo_print_err(dev->name, "Could not map memory");
+		if (mpi_map_card(ai, pci)) {
+			airo_print_err("", "Could not map memory");
@@ -2901,0 +2916 @@
+	strcpy(dev->name, "eth%d");
@@ -2924,2 +2938,0 @@
-	netif_start_queue(dev);
-	SET_MODULE_OWNER(dev);
@@ -2943,2 +2955,0 @@
-err_out_irq:
-	free_irq(dev->irq, dev);
@@ -2947 +2957,0 @@
-err_out_thr:
@@ -2949,2 +2958,0 @@
-	set_bit(JOB_DIE, &ai->jobs);
-	kthread_stop(ai->airo_thread_task);
@@ -3081 +3089,2 @@
-	
+
+	set_freezable();
@@ -3532 +3541,2 @@
-static int enable_MAC( struct airo_info *ai, Resp *rsp, int lock ) {
+static int enable_MAC(struct airo_info *ai, int lock)
+{
@@ -3534 +3544,2 @@
-        Cmd cmd;
+	Cmd cmd;
+	Resp rsp;
@@ -3550 +3561 @@
-		rc = issuecommand(ai, &cmd, rsp);
+		rc = issuecommand(ai, &cmd, &rsp);
@@ -3560,2 +3571,6 @@
-		airo_print_err(ai->dev->name, "%s: Cannot enable MAC, err=%d",
-			__FUNCTION__, rc);
+		airo_print_err(ai->dev->name, "Cannot enable MAC");
+	else if ((rsp.status & 0xFF00) != 0) {
+		airo_print_err(ai->dev->name, "Bad MAC enable reason=%x, "
+			"rid=%x, offset=%d", rsp.rsp0, rsp.rsp1, rsp.rsp2);
+		rc = ERROR;
+	}
@@ -3905,4 +3920,2 @@
-	status = enable_MAC(ai, &rsp, lock);
-	if ( status != SUCCESS || (rsp.status & 0xFF00) != 0) {
-		airo_print_err(ai->dev->name, "Bad MAC enable reason = %x, rid = %x,"
-			" offset = %d", rsp.rsp0, rsp.rsp1, rsp.rsp2 );
+	status = enable_MAC(ai, lock);
+	if (status != SUCCESS)
@@ -3910 +3922,0 @@
-	}
@@ -3922,4 +3934 @@
-	if (auto_wep) {
-		ai->expires = RUN_AT(3*HZ);
-		wake_up_interruptible(&ai->thr_wait);
-	}
+	try_auto_wep(ai);
@@ -4007 +4016 @@
-				"airo: BAP setup error too many retries\n");
+				"BAP setup error too many retries\n");
@@ -5155 +5163,0 @@
-	Resp rsp;
@@ -5180 +5188 @@
-	enable_MAC(ai, &rsp, 1);
+	enable_MAC(ai, 1);
@@ -5196 +5203,0 @@
-	Resp rsp;
@@ -5221 +5228 @@
-	enable_MAC(ai, &rsp, 1);
+	enable_MAC(ai, 1);
@@ -5228 +5234,0 @@
-	Resp rsp;
@@ -5232 +5238 @@
-	enable_MAC(ai, &rsp, 1);
+	enable_MAC(ai, 1);
@@ -5263 +5268,0 @@
-	Resp rsp;
@@ -5283 +5288 @@
-	if (perm) enable_MAC(ai, &rsp, lock);
+	if (perm) enable_MAC(ai, lock);
@@ -5551 +5555,0 @@
-	Resp rsp;
@@ -5578 +5582 @@
-	enable_MAC(apriv, &rsp, 0);
+	enable_MAC(apriv, 0);
@@ -5600 +5604,2 @@
-	if (!dev)
+	if (!dev) {
+		pci_disable_device(pdev);
@@ -5601,0 +5607 @@
+	}
@@ -5612,0 +5619,2 @@
+	pci_disable_device(pdev);
+	pci_set_drvdata(pdev, NULL);
@@ -5649 +5656,0 @@
-	Resp rsp;
@@ -5682 +5689 @@
-	enable_MAC(ai, &rsp, 0);
+	enable_MAC(ai, 0);
@@ -5906 +5912,0 @@
-	Resp rsp;
@@ -5938 +5944 @@
-	enable_MAC(local, &rsp, 1);
+	enable_MAC(local, 1);
@@ -6003 +6009 @@
-		enable_MAC(local, &rsp, 1);
+		enable_MAC(local, 1);
@@ -7457 +7462,0 @@
-	Resp rsp;
@@ -7482 +7487 @@
-	enable_MAC(local, &rsp, 0);
+	enable_MAC(local, 0);
@@ -7749 +7753,0 @@
-	Resp rsp;
@@ -7761 +7765 @@
-			enable_MAC (ai, &rsp, 1);
+			enable_MAC(ai, 1);
@@ -7818 +7821,0 @@
-	Resp      rsp;
@@ -7852 +7855 @@
-		if (enable_MAC(ai, &rsp, 1) != 0)
+		if (enable_MAC(ai, 1) != 0)
--- ./projects/linux/linux-2.6.23/drivers/net/wireless/airo.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/net/wireless/airo.c	2008-01-24 23:58:37.000000000 +0100
@@ -244,2 +244,2 @@
-                   cards.  Direct support for ISA/PCI/MPI cards and support \
-		   for PCMCIA when used with airo_cs.");
+cards.  Direct support for ISA/PCI/MPI cards and support \
+for PCMCIA when used with airo_cs.");
@@ -2484 +2484 @@
-static int wll_header_parse(struct sk_buff *skb, unsigned char *haddr)
+static int wll_header_parse(const struct sk_buff *skb, unsigned char *haddr)
@@ -2698,0 +2699,4 @@
+static const struct header_ops airo_header_ops = {
+	.parse = wll_header_parse,
+};
+
@@ -2701,6 +2705 @@
-	dev->hard_header        = NULL;
-	dev->rebuild_header     = NULL;
-	dev->hard_header_cache  = NULL;
-	dev->header_cache_update= NULL;
-
-	dev->hard_header_parse  = wll_header_parse;
+	dev->header_ops = &airo_header_ops;
@@ -2823,0 +2823 @@
+	DECLARE_MAC_BUF(mac);
@@ -2873 +2872,0 @@
-	SET_MODULE_OWNER(dev);
@@ -2927,3 +2926,2 @@
-	airo_print_info(dev->name, "MAC enabled %x:%x:%x:%x:%x:%x",
-		dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
-		dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5] );
+	airo_print_info(dev->name, "MAC enabled %s",
+			print_mac(mac, dev->dev_addr));
@@ -2985,0 +2984 @@
+	DECLARE_MAC_BUF(mac);
@@ -2994,3 +2993,2 @@
-	airo_print_info(dev->name, "MAC enabled %x:%x:%x:%x:%x:%x",
-			dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
-			dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5]);
+	airo_print_info(dev->name, "MAC enabled %s",
+			print_mac(mac, dev->dev_addr));
@@ -5429,0 +5428 @@
+	DECLARE_MAC_BUF(mac);
@@ -5453,7 +5452,2 @@
-		ptr += sprintf(ptr, "%02x:%02x:%02x:%02x:%02x:%02x\n",
-			       (int)APList_rid.ap[i][0],
-			       (int)APList_rid.ap[i][1],
-			       (int)APList_rid.ap[i][2],
-			       (int)APList_rid.ap[i][3],
-			       (int)APList_rid.ap[i][4],
-			       (int)APList_rid.ap[i][5]);
+		ptr += sprintf(ptr, "%s\n",
+			       print_mac(mac, APList_rid.ap[i]));
@@ -5477,0 +5472 @@
+	DECLARE_MAC_BUF(mac);
@@ -5514,7 +5509,2 @@
-		ptr += sprintf(ptr, "%02x:%02x:%02x:%02x:%02x:%02x %*s rssi = %d",
-				(int)BSSList_rid.bssid[0],
-				(int)BSSList_rid.bssid[1],
-				(int)BSSList_rid.bssid[2],
-				(int)BSSList_rid.bssid[3],
-				(int)BSSList_rid.bssid[4],
-				(int)BSSList_rid.bssid[5],
+		ptr += sprintf(ptr, "%s %*s rssi = %d",
+			       print_mac(mac, BSSList_rid.bssid),
@@ -7582,3 +7572,3 @@
-	.num_standard	= sizeof(airo_handler)/sizeof(iw_handler),
-	.num_private	= sizeof(airo_private_handler)/sizeof(iw_handler),
-	.num_private_args = sizeof(airo_private_args)/sizeof(struct iw_priv_args),
+	.num_standard	= ARRAY_SIZE(airo_handler),
+	.num_private	= ARRAY_SIZE(airo_private_handler),
+	.num_private_args = ARRAY_SIZE(airo_private_args),
--- ./projects/linux/linux-2.6.24/drivers/net/wireless/airo.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/net/wireless/airo.c	2008-04-17 04:49:44.000000000 +0200
@@ -40,0 +41 @@
+#include <asm/unaligned.h>
@@ -503,2 +504,2 @@
-	u16 len;
-	u16 kindex;
+	__le16 len;
+	__le16 kindex;
@@ -506 +507 @@
-	u16 klen;
+	__le16 klen;
@@ -512 +513 @@
-	u16 len;
+	__le16 len;
@@ -517 +518 @@
-	u16 len;
+	__le16 len;
@@ -522,5 +523,5 @@
-        u16 len;
-        u16 modulation;
-#define MOD_DEFAULT 0
-#define MOD_CCK 1
-#define MOD_MOK 2
+        __le16 len;
+        __le16 modulation;
+#define MOD_DEFAULT cpu_to_le16(0)
+#define MOD_CCK cpu_to_le16(1)
+#define MOD_MOK cpu_to_le16(2)
@@ -530,26 +531,29 @@
-	u16 len; /* sizeof(ConfigRid) */
-	u16 opmode; /* operating mode */
-#define MODE_STA_IBSS 0
-#define MODE_STA_ESS 1
-#define MODE_AP 2
-#define MODE_AP_RPTR 3
-#define MODE_ETHERNET_HOST (0<<8) /* rx payloads converted */
-#define MODE_LLC_HOST (1<<8) /* rx payloads left as is */
-#define MODE_AIRONET_EXTEND (1<<9) /* enable Aironet extenstions */
-#define MODE_AP_INTERFACE (1<<10) /* enable ap interface extensions */
-#define MODE_ANTENNA_ALIGN (1<<11) /* enable antenna alignment */
-#define MODE_ETHER_LLC (1<<12) /* enable ethernet LLC */
-#define MODE_LEAF_NODE (1<<13) /* enable leaf node bridge */
-#define MODE_CF_POLLABLE (1<<14) /* enable CF pollable */
-#define MODE_MIC (1<<15) /* enable MIC */
-	u16 rmode; /* receive mode */
-#define RXMODE_BC_MC_ADDR 0
-#define RXMODE_BC_ADDR 1 /* ignore multicasts */
-#define RXMODE_ADDR 2 /* ignore multicast and broadcast */
-#define RXMODE_RFMON 3 /* wireless monitor mode */
-#define RXMODE_RFMON_ANYBSS 4
-#define RXMODE_LANMON 5 /* lan style monitor -- data packets only */
-#define RXMODE_DISABLE_802_3_HEADER (1<<8) /* disables 802.3 header on rx */
-#define RXMODE_NORMALIZED_RSSI (1<<9) /* return normalized RSSI */
-	u16 fragThresh;
-	u16 rtsThres;
+	__le16 len; /* sizeof(ConfigRid) */
+	__le16 opmode; /* operating mode */
+#define MODE_STA_IBSS cpu_to_le16(0)
+#define MODE_STA_ESS cpu_to_le16(1)
+#define MODE_AP cpu_to_le16(2)
+#define MODE_AP_RPTR cpu_to_le16(3)
+#define MODE_CFG_MASK cpu_to_le16(0xff)
+#define MODE_ETHERNET_HOST cpu_to_le16(0<<8) /* rx payloads converted */
+#define MODE_LLC_HOST cpu_to_le16(1<<8) /* rx payloads left as is */
+#define MODE_AIRONET_EXTEND cpu_to_le16(1<<9) /* enable Aironet extenstions */
+#define MODE_AP_INTERFACE cpu_to_le16(1<<10) /* enable ap interface extensions */
+#define MODE_ANTENNA_ALIGN cpu_to_le16(1<<11) /* enable antenna alignment */
+#define MODE_ETHER_LLC cpu_to_le16(1<<12) /* enable ethernet LLC */
+#define MODE_LEAF_NODE cpu_to_le16(1<<13) /* enable leaf node bridge */
+#define MODE_CF_POLLABLE cpu_to_le16(1<<14) /* enable CF pollable */
+#define MODE_MIC cpu_to_le16(1<<15) /* enable MIC */
+	__le16 rmode; /* receive mode */
+#define RXMODE_BC_MC_ADDR cpu_to_le16(0)
+#define RXMODE_BC_ADDR cpu_to_le16(1) /* ignore multicasts */
+#define RXMODE_ADDR cpu_to_le16(2) /* ignore multicast and broadcast */
+#define RXMODE_RFMON cpu_to_le16(3) /* wireless monitor mode */
+#define RXMODE_RFMON_ANYBSS cpu_to_le16(4)
+#define RXMODE_LANMON cpu_to_le16(5) /* lan style monitor -- data packets only */
+#define RXMODE_MASK cpu_to_le16(255)
+#define RXMODE_DISABLE_802_3_HEADER cpu_to_le16(1<<8) /* disables 802.3 header on rx */
+#define RXMODE_FULL_MASK (RXMODE_MASK | RXMODE_DISABLE_802_3_HEADER)
+#define RXMODE_NORMALIZED_RSSI cpu_to_le16(1<<9) /* return normalized RSSI */
+	__le16 fragThresh;
+	__le16 rtsThres;
@@ -558,10 +562,10 @@
-	u16 shortRetryLimit;
-	u16 longRetryLimit;
-	u16 txLifetime; /* in kusec */
-	u16 rxLifetime; /* in kusec */
-	u16 stationary;
-	u16 ordering;
-	u16 u16deviceType; /* for overriding device type */
-	u16 cfpRate;
-	u16 cfpDuration;
-	u16 _reserved1[3];
+	__le16 shortRetryLimit;
+	__le16 longRetryLimit;
+	__le16 txLifetime; /* in kusec */
+	__le16 rxLifetime; /* in kusec */
+	__le16 stationary;
+	__le16 ordering;
+	__le16 u16deviceType; /* for overriding device type */
+	__le16 cfpRate;
+	__le16 cfpDuration;
+	__le16 _reserved1[3];
@@ -569,24 +573,24 @@
-	u16 scanMode;
-#define SCANMODE_ACTIVE 0
-#define SCANMODE_PASSIVE 1
-#define SCANMODE_AIROSCAN 2
-	u16 probeDelay; /* in kusec */
-	u16 probeEnergyTimeout; /* in kusec */
-        u16 probeResponseTimeout;
-	u16 beaconListenTimeout;
-	u16 joinNetTimeout;
-	u16 authTimeout;
-	u16 authType;
-#define AUTH_OPEN 0x1
-#define AUTH_ENCRYPT 0x101
-#define AUTH_SHAREDKEY 0x102
-#define AUTH_ALLOW_UNENCRYPTED 0x200
-	u16 associationTimeout;
-	u16 specifiedApTimeout;
-	u16 offlineScanInterval;
-	u16 offlineScanDuration;
-	u16 linkLossDelay;
-	u16 maxBeaconLostTime;
-	u16 refreshInterval;
-#define DISABLE_REFRESH 0xFFFF
-	u16 _reserved1a[1];
+	__le16 scanMode;
+#define SCANMODE_ACTIVE cpu_to_le16(0)
+#define SCANMODE_PASSIVE cpu_to_le16(1)
+#define SCANMODE_AIROSCAN cpu_to_le16(2)
+	__le16 probeDelay; /* in kusec */
+	__le16 probeEnergyTimeout; /* in kusec */
+        __le16 probeResponseTimeout;
+	__le16 beaconListenTimeout;
+	__le16 joinNetTimeout;
+	__le16 authTimeout;
+	__le16 authType;
+#define AUTH_OPEN cpu_to_le16(0x1)
+#define AUTH_ENCRYPT cpu_to_le16(0x101)
+#define AUTH_SHAREDKEY cpu_to_le16(0x102)
+#define AUTH_ALLOW_UNENCRYPTED cpu_to_le16(0x200)
+	__le16 associationTimeout;
+	__le16 specifiedApTimeout;
+	__le16 offlineScanInterval;
+	__le16 offlineScanDuration;
+	__le16 linkLossDelay;
+	__le16 maxBeaconLostTime;
+	__le16 refreshInterval;
+#define DISABLE_REFRESH cpu_to_le16(0xFFFF)
+	__le16 _reserved1a[1];
@@ -594,10 +598,10 @@
-	u16 powerSaveMode;
-#define POWERSAVE_CAM 0
-#define POWERSAVE_PSP 1
-#define POWERSAVE_PSPCAM 2
-	u16 sleepForDtims;
-	u16 listenInterval;
-	u16 fastListenInterval;
-	u16 listenDecay;
-	u16 fastListenDelay;
-	u16 _reserved2[2];
+	__le16 powerSaveMode;
+#define POWERSAVE_CAM cpu_to_le16(0)
+#define POWERSAVE_PSP cpu_to_le16(1)
+#define POWERSAVE_PSPCAM cpu_to_le16(2)
+	__le16 sleepForDtims;
+	__le16 listenInterval;
+	__le16 fastListenInterval;
+	__le16 listenDecay;
+	__le16 fastListenDelay;
+	__le16 _reserved2[2];
@@ -605,8 +609,8 @@
-	u16 beaconPeriod;
-	u16 atimDuration;
-	u16 hopPeriod;
-	u16 channelSet;
-	u16 channel;
-	u16 dtimPeriod;
-	u16 bridgeDistance;
-	u16 radioID;
+	__le16 beaconPeriod;
+	__le16 atimDuration;
+	__le16 hopPeriod;
+	__le16 channelSet;
+	__le16 channel;
+	__le16 dtimPeriod;
+	__le16 bridgeDistance;
+	__le16 radioID;
@@ -614,4 +618,4 @@
-	u16 radioType;
-#define RADIOTYPE_DEFAULT 0
-#define RADIOTYPE_802_11 1
-#define RADIOTYPE_LEGACY 2
+	__le16 radioType;
+#define RADIOTYPE_DEFAULT cpu_to_le16(0)
+#define RADIOTYPE_802_11 cpu_to_le16(1)
+#define RADIOTYPE_LEGACY cpu_to_le16(2)
@@ -620 +624 @@
-	u16 txPower;
+	__le16 txPower;
@@ -622 +626 @@
-	u16 rssiThreshold;
+	__le16 rssiThreshold;
@@ -624,7 +628,7 @@
-        u16 modulation;
-#define PREAMBLE_AUTO 0
-#define PREAMBLE_LONG 1
-#define PREAMBLE_SHORT 2
-	u16 preamble;
-	u16 homeProduct;
-	u16 radioSpecific;
+        __le16 modulation;
+#define PREAMBLE_AUTO cpu_to_le16(0)
+#define PREAMBLE_LONG cpu_to_le16(1)
+#define PREAMBLE_SHORT cpu_to_le16(2)
+	__le16 preamble;
+	__le16 homeProduct;
+	__le16 radioSpecific;
@@ -633,4 +637,4 @@
-	u16 arlThreshold;
-	u16 arlDecay;
-	u16 arlDelay;
-	u16 _reserved4[1];
+	__le16 arlThreshold;
+	__le16 arlDecay;
+	__le16 arlDelay;
+	__le16 _reserved4[1];
@@ -646 +650 @@
-	u16 autoWake;
+	__le16 autoWake;
@@ -650 +654 @@
-	u16 len;
+	__le16 len;
@@ -652,4 +656,4 @@
-	u16 mode;
-	u16 errorCode;
-	u16 sigQuality;
-	u16 SSIDlen;
+	__le16 mode;
+	__le16 errorCode;
+	__le16 sigQuality;
+	__le16 SSIDlen;
@@ -659,15 +663,15 @@
-	u16 beaconPeriod;
-	u16 dimPeriod;
-	u16 atimDuration;
-	u16 hopPeriod;
-	u16 channelSet;
-	u16 channel;
-	u16 hopsToBackbone;
-	u16 apTotalLoad;
-	u16 generatedLoad;
-	u16 accumulatedArl;
-	u16 signalQuality;
-	u16 currentXmitRate;
-	u16 apDevExtensions;
-	u16 normalizedSignalStrength;
-	u16 shortPreamble;
+	__le16 beaconPeriod;
+	__le16 dimPeriod;
+	__le16 atimDuration;
+	__le16 hopPeriod;
+	__le16 channelSet;
+	__le16 channel;
+	__le16 hopsToBackbone;
+	__le16 apTotalLoad;
+	__le16 generatedLoad;
+	__le16 accumulatedArl;
+	__le16 signalQuality;
+	__le16 currentXmitRate;
+	__le16 apDevExtensions;
+	__le16 normalizedSignalStrength;
+	__le16 shortPreamble;
@@ -681 +685 @@
-	u16 load;
+	__le16 load;
@@ -683 +687 @@
-	u16 assocStatus;
+	__le16 assocStatus;
@@ -708,3 +712,3 @@
-	u16 len;
-	u16 spacer;
-	u32 vals[100];
+	__le16 len;
+	__le16 spacer;
+	__le32 vals[100];
@@ -715 +719 @@
-	u16 len;
+	__le16 len;
@@ -720 +724 @@
-	u16 len;
+	__le16 len;
@@ -723 +727 @@
-	u16 prodNum;
+	__le16 prodNum;
@@ -729,2 +733,2 @@
-	u16 radioType;
-	u16 country;
+	__le16 radioType;
+	__le16 country;
@@ -735,11 +739,11 @@
-	u16 txPowerLevels[8];
-	u16 hardVer;
-	u16 hardCap;
-	u16 tempRange;
-	u16 softVer;
-	u16 softSubVer;
-	u16 interfaceVer;
-	u16 softCap;
-	u16 bootBlockVer;
-	u16 requiredHard;
-	u16 extSoftCap;
+	__le16 txPowerLevels[8];
+	__le16 hardVer;
+	__le16 hardCap;
+	__le16 tempRange;
+	__le16 softVer;
+	__le16 softSubVer;
+	__le16 interfaceVer;
+	__le16 softCap;
+	__le16 bootBlockVer;
+	__le16 requiredHard;
+	__le16 extSoftCap;
@@ -751 +755 @@
-  u16 unknown[4];
+  __le16 unknown[4];
@@ -757,2 +761,2 @@
-  u16 len;
-  u16 index; /* First is 0 and 0xffff means end of list */
+  __le16 len;
+  __le16 index; /* First is 0 and 0xffff means end of list */
@@ -762 +766 @@
-  u16 radioType;
+  __le16 radioType;
@@ -767,7 +771,7 @@
-  u16 dBm;
-#define CAP_ESS (1<<0)
-#define CAP_IBSS (1<<1)
-#define CAP_PRIVACY (1<<4)
-#define CAP_SHORTHDR (1<<5)
-  u16 cap;
-  u16 beaconInterval;
+  __le16 dBm;
+#define CAP_ESS cpu_to_le16(1<<0)
+#define CAP_IBSS cpu_to_le16(1<<1)
+#define CAP_PRIVACY cpu_to_le16(1<<4)
+#define CAP_SHORTHDR cpu_to_le16(1<<5)
+  __le16 cap;
+  __le16 beaconInterval;
@@ -776 +780 @@
-    u16 dwell;
+    __le16 dwell;
@@ -782,2 +786,2 @@
-  u16 dsChannel;
-  u16 atimWindow;
+  __le16 dsChannel;
+  __le16 atimWindow;
@@ -814 +818 @@
-	u16 typelen;
+	__be16 typelen;
@@ -826,2 +830,2 @@
-	u32 mic;
-	u32 seq;
+	__be32 mic;
+	__be32 seq;
@@ -946 +950 @@
-		u32 d32;
+		__be32 d32;
@@ -1103 +1107 @@
-static int aux_bap_read(struct airo_info*, u16 *pu16Dst, int bytelen,
+static int aux_bap_read(struct airo_info*, __le16 *pu16Dst, int bytelen,
@@ -1105 +1109 @@
-static int fast_bap_read(struct airo_info*, u16 *pu16Dst, int bytelen,
+static int fast_bap_read(struct airo_info*, __le16 *pu16Dst, int bytelen,
@@ -1107 +1111 @@
-static int bap_write(struct airo_info*, const u16 *pu16Src, int bytelen,
+static int bap_write(struct airo_info*, const __le16 *pu16Src, int bytelen,
@@ -1190 +1194 @@
-	int (*bap_read)(struct airo_info*, u16 *pu16Dst, int bytelen,
+	int (*bap_read)(struct airo_info*, __le16 *pu16Dst, int bytelen,
@@ -1238,2 +1242,3 @@
-static inline int bap_read(struct airo_info *ai, u16 *pu16Dst, int bytelen,
-			   int whichbap) {
+static inline int bap_read(struct airo_info *ai, __le16 *pu16Dst, int bytelen,
+			   int whichbap)
+{
@@ -1638 +1643 @@
-			context->coeff[i++] = ntohl(*(u32 *)&cipher[j]);
+			context->coeff[i++] = ntohl(*(__be32 *)&cipher[j]);
@@ -1671 +1676 @@
-		MIC_ACCUM(htonl(context->part.d32));
+		MIC_ACCUM(ntohl(context->part.d32));
@@ -1676 +1681 @@
-		MIC_ACCUM(htonl(*(u32 *)pOctets));
+		MIC_ACCUM(ntohl(*(__be32 *)pOctets));
@@ -1709 +1714 @@
-		val = htonl(context->part.d32);
+		val = ntohl(context->part.d32);
@@ -1729,2 +1734,2 @@
-		      BSSListRid *list) {
-	int rc;
+		      BSSListRid *list)
+{
@@ -1747 +1752 @@
-	rc = PC4500_readrid(ai, first ? ai->bssListFirst : ai->bssListNext,
+	return PC4500_readrid(ai, first ? ai->bssListFirst : ai->bssListNext,
@@ -1749,11 +1753,0 @@
-
-	list->len = le16_to_cpu(list->len);
-	list->index = le16_to_cpu(list->index);
-	list->radioType = le16_to_cpu(list->radioType);
-	list->cap = le16_to_cpu(list->cap);
-	list->beaconInterval = le16_to_cpu(list->beaconInterval);
-	list->fh.dwell = le16_to_cpu(list->fh.dwell);
-	list->dsChannel = le16_to_cpu(list->dsChannel);
-	list->atimWindow = le16_to_cpu(list->atimWindow);
-	list->dBm = le16_to_cpu(list->dBm);
-	return rc;
@@ -1762,2 +1756,3 @@
-static int readWepKeyRid(struct airo_info*ai, WepKeyRid *wkr, int temp, int lock) {
-	int rc = PC4500_readrid(ai, temp ? RID_WEP_TEMP : RID_WEP_PERM,
+static int readWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int temp, int lock)
+{
+	return PC4500_readrid(ai, temp ? RID_WEP_TEMP : RID_WEP_PERM,
@@ -1765,5 +1759,0 @@
-
-	wkr->len = le16_to_cpu(wkr->len);
-	wkr->kindex = le16_to_cpu(wkr->kindex);
-	wkr->klen = le16_to_cpu(wkr->klen);
-	return rc;
@@ -1771,5 +1760,0 @@
-/* In the writeXXXRid routines we copy the rids so that we don't screwup
- * the originals when we endian them... */
-static int writeWepKeyRid(struct airo_info*ai, WepKeyRid *pwkr, int perm, int lock) {
-	int rc;
-	WepKeyRid wkr = *pwkr;
@@ -1777,5 +1762,6 @@
-	wkr.len = cpu_to_le16(wkr.len);
-	wkr.kindex = cpu_to_le16(wkr.kindex);
-	wkr.klen = cpu_to_le16(wkr.klen);
-	rc = PC4500_writerid(ai, RID_WEP_TEMP, &wkr, sizeof(wkr), lock);
-	if (rc!=SUCCESS) airo_print_err(ai->dev->name, "WEP_TEMP set %x", rc);
+static int writeWepKeyRid(struct airo_info *ai, WepKeyRid *wkr, int perm, int lock)
+{
+	int rc;
+	rc = PC4500_writerid(ai, RID_WEP_TEMP, wkr, sizeof(*wkr), lock);
+	if (rc!=SUCCESS)
+		airo_print_err(ai->dev->name, "WEP_TEMP set %x", rc);
@@ -1783,2 +1769,2 @@
-		rc = PC4500_writerid(ai, RID_WEP_PERM, &wkr, sizeof(wkr), lock);
-		if (rc!=SUCCESS) {
+		rc = PC4500_writerid(ai, RID_WEP_PERM, wkr, sizeof(*wkr), lock);
+		if (rc!=SUCCESS)
@@ -1786 +1771,0 @@
-		}
@@ -1791,9 +1776,3 @@
-static int readSsidRid(struct airo_info*ai, SsidRid *ssidr) {
-	int i;
-	int rc = PC4500_readrid(ai, RID_SSID, ssidr, sizeof(*ssidr), 1);
-
-	ssidr->len = le16_to_cpu(ssidr->len);
-	for(i = 0; i < 3; i++) {
-		ssidr->ssids[i].len = le16_to_cpu(ssidr->ssids[i].len);
-	}
-	return rc;
+static int readSsidRid(struct airo_info*ai, SsidRid *ssidr)
+{
+	return PC4500_readrid(ai, RID_SSID, ssidr, sizeof(*ssidr), 1);
@@ -1801,4 +1779,0 @@
-static int writeSsidRid(struct airo_info*ai, SsidRid *pssidr, int lock) {
-	int rc;
-	int i;
-	SsidRid ssidr = *pssidr;
@@ -1806,6 +1781,3 @@
-	ssidr.len = cpu_to_le16(ssidr.len);
-	for(i = 0; i < 3; i++) {
-		ssidr.ssids[i].len = cpu_to_le16(ssidr.ssids[i].len);
-	}
-	rc = PC4500_writerid(ai, RID_SSID, &ssidr, sizeof(ssidr), lock);
-	return rc;
+static int writeSsidRid(struct airo_info*ai, SsidRid *pssidr, int lock)
+{
+	return PC4500_writerid(ai, RID_SSID, pssidr, sizeof(*pssidr), lock);
@@ -1813 +1785,3 @@
-static int readConfigRid(struct airo_info*ai, int lock) {
+
+static int readConfigRid(struct airo_info *ai, int lock)
+{
@@ -1815 +1788,0 @@
-	u16 *s;
@@ -1825,14 +1797,0 @@
-	for(s = &cfg.len; s <= &cfg.rtsThres; s++) *s = le16_to_cpu(*s);
-
-	for(s = &cfg.shortRetryLimit; s <= &cfg.radioType; s++)
-		*s = le16_to_cpu(*s);
-
-	for(s = &cfg.txPower; s <= &cfg.radioSpecific; s++)
-		*s = le16_to_cpu(*s);
-
-	for(s = &cfg.arlThreshold; s <= &cfg._reserved4[0]; s++)
-		*s = cpu_to_le16(*s);
-
-	for(s = &cfg.autoWake; s <= &cfg.autoWake; s++)
-		*s = cpu_to_le16(*s);
-
@@ -1842 +1801,3 @@
-static inline void checkThrottle(struct airo_info *ai) {
+
+static inline void checkThrottle(struct airo_info *ai)
+{
@@ -1853,2 +1814,3 @@
-static int writeConfigRid(struct airo_info*ai, int lock) {
-	u16 *s;
+
+static int writeConfigRid(struct airo_info *ai, int lock)
+{
@@ -1865 +1827 @@
-	if ((cfgr.opmode & 0xFF) == MODE_STA_IBSS)
+	if ((cfgr.opmode & MODE_CFG_MASK) == MODE_STA_IBSS)
@@ -1870,14 +1831,0 @@
-	for(s = &cfgr.len; s <= &cfgr.rtsThres; s++) *s = cpu_to_le16(*s);
-
-	for(s = &cfgr.shortRetryLimit; s <= &cfgr.radioType; s++)
-		*s = cpu_to_le16(*s);
-
-	for(s = &cfgr.txPower; s <= &cfgr.radioSpecific; s++)
-		*s = cpu_to_le16(*s);
-
-	for(s = &cfgr.arlThreshold; s <= &cfgr._reserved4[0]; s++)
-		*s = cpu_to_le16(*s);
-
-	for(s = &cfgr.autoWake; s <= &cfgr.autoWake; s++)
-		*s = cpu_to_le16(*s);
-
@@ -1886,12 +1834,4 @@
-static int readStatusRid(struct airo_info*ai, StatusRid *statr, int lock) {
-	int rc = PC4500_readrid(ai, RID_STATUS, statr, sizeof(*statr), lock);
-	u16 *s;
-
-	statr->len = le16_to_cpu(statr->len);
-	for(s = &statr->mode; s <= &statr->SSIDlen; s++) *s = le16_to_cpu(*s);
-
-	for(s = &statr->beaconPeriod; s <= &statr->shortPreamble; s++)
-		*s = le16_to_cpu(*s);
-	statr->load = le16_to_cpu(statr->load);
-	statr->assocStatus = le16_to_cpu(statr->assocStatus);
-	return rc;
+
+static int readStatusRid(struct airo_info *ai, StatusRid *statr, int lock)
+{
+	return PC4500_readrid(ai, RID_STATUS, statr, sizeof(*statr), lock);
@@ -1899,4 +1839,4 @@
-static int readAPListRid(struct airo_info*ai, APListRid *aplr) {
-	int rc =  PC4500_readrid(ai, RID_APLIST, aplr, sizeof(*aplr), 1);
-	aplr->len = le16_to_cpu(aplr->len);
-	return rc;
+
+static int readAPListRid(struct airo_info *ai, APListRid *aplr)
+{
+	return PC4500_readrid(ai, RID_APLIST, aplr, sizeof(*aplr), 1);
@@ -1904,5 +1844,4 @@
-static int writeAPListRid(struct airo_info*ai, APListRid *aplr, int lock) {
-	int rc;
-	aplr->len = cpu_to_le16(aplr->len);
-	rc = PC4500_writerid(ai, RID_APLIST, aplr, sizeof(*aplr), lock);
-	return rc;
+
+static int writeAPListRid(struct airo_info *ai, APListRid *aplr, int lock)
+{
+	return PC4500_writerid(ai, RID_APLIST, aplr, sizeof(*aplr), lock);
@@ -1910,11 +1849,4 @@
-static int readCapabilityRid(struct airo_info*ai, CapabilityRid *capr, int lock) {
-	int rc = PC4500_readrid(ai, RID_CAPABILITIES, capr, sizeof(*capr), lock);
-	u16 *s;
-
-	capr->len = le16_to_cpu(capr->len);
-	capr->prodNum = le16_to_cpu(capr->prodNum);
-	capr->radioType = le16_to_cpu(capr->radioType);
-	capr->country = le16_to_cpu(capr->country);
-	for(s = &capr->txPowerLevels[0]; s <= &capr->requiredHard; s++)
-		*s = le16_to_cpu(*s);
-	return rc;
+
+static int readCapabilityRid(struct airo_info *ai, CapabilityRid *capr, int lock)
+{
+	return PC4500_readrid(ai, RID_CAPABILITIES, capr, sizeof(*capr), lock);
@@ -1922,3 +1853,0 @@
-static int readStatsRid(struct airo_info*ai, StatsRid *sr, int rid, int lock) {
-	int rc = PC4500_readrid(ai, rid, sr, sizeof(*sr), lock);
-	u32 *i;
@@ -1926,3 +1855,3 @@
-	sr->len = le16_to_cpu(sr->len);
-	for(i = &sr->vals[0]; i <= &sr->vals[99]; i++) *i = le32_to_cpu(*i);
-	return rc;
+static int readStatsRid(struct airo_info*ai, StatsRid *sr, int rid, int lock)
+{
+	return PC4500_readrid(ai, rid, sr, sizeof(*sr), lock);
@@ -2029 +1958,2 @@
-	s16 len, *payloadLen;
+	s16 len;
+	__le16 *payloadLen;
@@ -2035 +1965 @@
-	if ((skb = skb_dequeue(&ai->txq)) == 0) {
+	if ((skb = skb_dequeue(&ai->txq)) == NULL) {
@@ -2062 +1992 @@
-	payloadLen = (s16 *)(ai->txfids[0].virtual_host_addr +
+	payloadLen = (__le16 *)(ai->txfids[0].virtual_host_addr +
@@ -2072 +2002 @@
-		(ntohs(((u16 *)buffer)[6]) != 0x888E)) {
+		(ntohs(((__be16 *)buffer)[6]) != 0x888E)) {
@@ -2107 +2037 @@
-	u16 status;
+	__le16 status;
@@ -2138 +2068 @@
-		bap_read(ai, (u16 *) junk, 0x18, BAP0);
+		bap_read(ai, (__le16 *) junk, 0x18, BAP0);
@@ -2292 +2222,2 @@
-static void airo_read_stats(struct airo_info *ai) {
+static void airo_read_stats(struct airo_info *ai)
+{
@@ -2294 +2225 @@
-	u32 *vals = stats_rid.vals;
+	__le32 *vals = stats_rid.vals;
@@ -2304,8 +2235,11 @@
-	ai->stats.rx_packets = vals[43] + vals[44] + vals[45];
-	ai->stats.tx_packets = vals[39] + vals[40] + vals[41];
-	ai->stats.rx_bytes = vals[92];
-	ai->stats.tx_bytes = vals[91];
-	ai->stats.rx_errors = vals[0] + vals[2] + vals[3] + vals[4];
-	ai->stats.tx_errors = vals[42] + ai->stats.tx_fifo_errors;
-	ai->stats.multicast = vals[43];
-	ai->stats.collisions = vals[89];
+	ai->stats.rx_packets = le32_to_cpu(vals[43]) + le32_to_cpu(vals[44]) +
+			       le32_to_cpu(vals[45]);
+	ai->stats.tx_packets = le32_to_cpu(vals[39]) + le32_to_cpu(vals[40]) +
+			       le32_to_cpu(vals[41]);
+	ai->stats.rx_bytes = le32_to_cpu(vals[92]);
+	ai->stats.tx_bytes = le32_to_cpu(vals[91]);
+	ai->stats.rx_errors = le32_to_cpu(vals[0]) + le32_to_cpu(vals[2]) +
+			      le32_to_cpu(vals[3]) + le32_to_cpu(vals[4]);
+	ai->stats.tx_errors = le32_to_cpu(vals[42]) + ai->stats.tx_fifo_errors;
+	ai->stats.multicast = le32_to_cpu(vals[43]);
+	ai->stats.collisions = le32_to_cpu(vals[89]);
@@ -2314,4 +2248,4 @@
-	ai->stats.rx_length_errors = vals[3];
-	ai->stats.rx_crc_errors = vals[4];
-	ai->stats.rx_frame_errors = vals[2];
-	ai->stats.rx_fifo_errors = vals[0];
+	ai->stats.rx_length_errors = le32_to_cpu(vals[3]);
+	ai->stats.rx_crc_errors = le32_to_cpu(vals[4]);
+	ai->stats.rx_frame_errors = le32_to_cpu(vals[2]);
+	ai->stats.rx_fifo_errors = le32_to_cpu(vals[0]);
@@ -2804,2 +2738,3 @@
-	if ((cap_rid.softVer > 0x530)
-	  || ((cap_rid.softVer == 0x530) && (cap_rid.softSubVer >= 17))) {
+	if (le16_to_cpu(cap_rid.softVer) > 0x530
+	  || (le16_to_cpu(cap_rid.softVer) == 0x530
+	      && le16_to_cpu(cap_rid.softSubVer) >= 17)) {
@@ -3040 +2975 @@
-	if((rc) || (bss.index == 0xffff)) {
+	if((rc) || (bss.index == cpu_to_le16(0xffff))) {
@@ -3047 +2982 @@
-	while((!rc) && (bss.index != 0xffff)) {
+	while((!rc) && (bss.index != cpu_to_le16(0xffff))) {
@@ -3180,2 +3115,18 @@
-static irqreturn_t airo_interrupt ( int irq, void* dev_id) {
-	struct net_device *dev = (struct net_device *)dev_id;
+static int header_len(__le16 ctl)
+{
+	u16 fc = le16_to_cpu(ctl);
+	switch (fc & 0xc) {
+	case 4:
+		if ((fc & 0xe0) == 0xc0)
+			return 10;	/* one-address control packet */
+		return 16;	/* two-address control packet */
+	case 8:
+		if ((fc & 0x300) == 0x300)
+			return 30;	/* WDS packet */
+	}
+	return 24;
+}
+
+static irqreturn_t airo_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
@@ -3284 +3235,2 @@
-			u16 fc, len, hdrlen = 0;
+			__le16 fc, v;
+			u16 len, hdrlen = 0;
@@ -3287 +3239 @@
-				u16 status, len;
+				__le16 status, len;
@@ -3291 +3243 @@
-				u16 tmp[4];
+				__le16 tmp[4];
@@ -3295,2 +3247,2 @@
-			u16 tmpbuf[4];
-			u16 *buffer;
+			__le16 tmpbuf[4];
+			__le16 *buffer;
@@ -3312 +3264 @@
-				bap_read (apriv, (u16*)&hdr, sizeof(hdr), BAP0);
+				bap_read (apriv, (__le16*)&hdr, sizeof(hdr), BAP0);
@@ -3320 +3272 @@
-				bap_read (apriv, (u16*)&hdr.len, 2, BAP0);
+				bap_read (apriv, &hdr.len, 2, BAP0);
@@ -3332,17 +3284,2 @@
-				bap_read (apriv, (u16*)&fc, sizeof(fc), BAP0);
-				fc = le16_to_cpu(fc);
-				switch (fc & 0xc) {
-					case 4:
-						if ((fc & 0xe0) == 0xc0)
-							hdrlen = 10;
-						else
-							hdrlen = 16;
-						break;
-					case 8:
-						if ((fc&0x300)==0x300){
-							hdrlen = 30;
-							break;
-						}
-					default:
-						hdrlen = 24;
-				}
+				bap_read (apriv, &fc, sizeof(fc), BAP0);
+				hdrlen = header_len(fc);
@@ -3358 +3295 @@
-			buffer = (u16*)skb_put (skb, len + hdrlen);
+			buffer = (__le16*)skb_put (skb, len + hdrlen);
@@ -3365,2 +3302,2 @@
-				bap_read (apriv, &gap, sizeof(gap), BAP0);
-				gap = le16_to_cpu(gap);
+				bap_read (apriv, &v, sizeof(v), BAP0);
+				gap = le16_to_cpu(v);
@@ -3380 +3317 @@
-					bap_read (apriv,(u16*)&micbuf,sizeof(micbuf),BAP0);
+					bap_read (apriv,(__le16*)&micbuf,sizeof(micbuf),BAP0);
@@ -3408 +3345 @@
-					bap_read (apriv, (u16*)hdr.rssi, 2, BAP0);
+					bap_read (apriv, (__le16*)hdr.rssi, 2, BAP0);
@@ -3679 +3616,2 @@
-	u16 fc, len, hdrlen = 0;
+	u16 len, hdrlen = 0;
+	__le16 fc;
@@ -3682 +3620 @@
-		u16 status, len;
+		__le16 status, len;
@@ -3686 +3624 @@
-		u16 tmp[4];
+		__le16 tmp[4];
@@ -3709,17 +3647,2 @@
-	memcpy ((char *)&fc, ptr, sizeof(fc));
-	fc = le16_to_cpu(fc);
-	switch (fc & 0xc) {
-		case 4:
-			if ((fc & 0xe0) == 0xc0)
-				hdrlen = 10;
-			else
-				hdrlen = 16;
-			break;
-		case 8:
-			if ((fc&0x300)==0x300){
-				hdrlen = 30;
-				break;
-			}
-		default:
-			hdrlen = 24;
-	}
+	fc = get_unaligned((__le16 *)ptr);
+	hdrlen = header_len(fc);
@@ -3737,3 +3660,2 @@
-	memcpy ((char *)&gap, ptr, sizeof(gap));
-	ptr += sizeof(gap);
-	gap = le16_to_cpu(gap);
+	gap = le16_to_cpu(get_unaligned((__le16 *)ptr));
+	ptr += sizeof(__le16);
@@ -3791 +3713 @@
-	u16 lastindex;
+	__le16 lastindex;
@@ -3853 +3775 @@
-			if (cap_rid.softCap & 8)
+			if (cap_rid.softCap & cpu_to_le16(8))
@@ -3863,2 +3785,3 @@
-		if ((cap_rid.len>=sizeof(cap_rid)) && (cap_rid.extSoftCap&1) &&
-		    (micsetup(ai) == SUCCESS)) {
+		if (le16_to_cpu(cap_rid.len) >= sizeof(cap_rid) &&
+		    (cap_rid.extSoftCap & cpu_to_le16(1)) &&
+		    micsetup(ai) == SUCCESS) {
@@ -3900,5 +3823,5 @@
-			mySsid.ssids[i].len = strlen(ssids[i]);
-			if ( mySsid.ssids[i].len > 32 )
-				mySsid.ssids[i].len = 32;
-			memcpy(mySsid.ssids[i].ssid, ssids[i],
-			       mySsid.ssids[i].len);
+			size_t len = strlen(ssids[i]);
+			if (len > 32)
+				len = 32;
+			mySsid.ssids[i].len = cpu_to_le16(len);
+			memcpy(mySsid.ssids[i].ssid, ssids[i], len);
@@ -3906 +3829 @@
-		mySsid.len = sizeof(mySsid);
+		mySsid.len = cpu_to_le16(sizeof(mySsid));
@@ -3926 +3849 @@
-		if (wkr.kindex == 0xffff) {
+		if (wkr.kindex == cpu_to_le16(0xffff)) {
@@ -4041 +3964 @@
-static int aux_bap_read(struct airo_info *ai, u16 *pu16Dst,
+static int aux_bap_read(struct airo_info *ai, __le16 *pu16Dst,
@@ -4078 +4001 @@
-static int fast_bap_read(struct airo_info *ai, u16 *pu16Dst,
+static int fast_bap_read(struct airo_info *ai, __le16 *pu16Dst,
@@ -4090 +4013 @@
-static int bap_write(struct airo_info *ai, const u16 *pu16Src,
+static int bap_write(struct airo_info *ai, const __le16 *pu16Src,
@@ -4166 +4089 @@
-		len = min(len, (int)le16_to_cpu(*(u16*)pBuf)) - 2;
+		len = min(len, (int)le16_to_cpu(*(__le16*)pBuf)) - 2;
@@ -4176 +4099 @@
-		rc = bap_read(ai, ((u16*)pBuf)+1, len, BAP1);
+		rc = bap_read(ai, ((__le16*)pBuf)+1, len, BAP1);
@@ -4192 +4115 @@
-	*(u16*)pBuf = cpu_to_le16((u16)len);
+	*(__le16*)pBuf = cpu_to_le16((u16)len);
@@ -4266 +4189 @@
-	u16 txControl;
+	__le16 txControl;
@@ -4320 +4243 @@
-	u16 payloadLen;
+	__le16 payloadLen;
@@ -4336 +4259 @@
-	    (ntohs(((u16 *)pPacket)[6]) != 0x888E)) {
+	    (ntohs(((__be16 *)pPacket)[6]) != 0x888E)) {
@@ -4348 +4271 @@
-	bap_write(ai, (const u16*)pPacket, sizeof(etherHead), BAP1);
+	bap_write(ai, (__le16*)pPacket, sizeof(etherHead), BAP1);
@@ -4350,2 +4273,2 @@
-		bap_write(ai, (const u16*)&pMic, miclen, BAP1);
-	bap_write(ai, (const u16*)(pPacket + sizeof(etherHead)), len, BAP1);
+		bap_write(ai, (__le16*)&pMic, miclen, BAP1);
+	bap_write(ai, (__le16*)(pPacket + sizeof(etherHead)), len, BAP1);
@@ -4363 +4286 @@
-	u16 fc, payloadLen;
+	__le16 fc, payloadLen;
@@ -4367,5 +4290,2 @@
-	struct {
-		u8 addr4[ETH_ALEN];
-		u16 gaplen;
-		u8 gap[6];
-	} gap;
+	static u8 tail[(30-10) + 2 + 6] = {[30-10] = 6};
+	/* padding of header to full size + le16 gaplen (6) + gaplen bytes */
@@ -4374 +4293,0 @@
-	gap.gaplen = 6;
@@ -4376,16 +4295,2 @@
-	fc = le16_to_cpu(*(const u16*)pPacket);
-	switch (fc & 0xc) {
-		case 4:
-			if ((fc & 0xe0) == 0xc0)
-				hdrlen = 10;
-			else
-				hdrlen = 16;
-			break;
-		case 8:
-			if ((fc&0x300)==0x300){
-				hdrlen = 30;
-				break;
-			}
-		default:
-			hdrlen = 24;
-	}
+	fc = *(__le16*)pPacket;
+	hdrlen = header_len(fc);
@@ -4406,3 +4311,2 @@
-	bap_write(ai, (const u16*)pPacket, hdrlen, BAP1);
-	bap_write(ai, hdrlen == 30 ?
-		(const u16*)&gap.gaplen : (const u16*)&gap, 38 - hdrlen, BAP1);
+	bap_write(ai, (__le16 *)pPacket, hdrlen, BAP1);
+	bap_write(ai, (__le16 *)(tail + (hdrlen - 10)), 38 - hdrlen, BAP1);
@@ -4410 +4314 @@
-	bap_write(ai, (const u16*)(pPacket + hdrlen), len - hdrlen, BAP1);
+	bap_write(ai, (__le16 *)(pPacket + hdrlen), len - hdrlen, BAP1);
@@ -4725 +4629,2 @@
-static int proc_status_open( struct inode *inode, struct file *file ) {
+static int proc_status_open(struct inode *inode, struct file *file)
+{
@@ -4731,0 +4637 @@
+	u16 mode;
@@ -4744,0 +4651,2 @@
+	mode = le16_to_cpu(status_rid.mode);
+
@@ -4746,9 +4654,9 @@
-                    status_rid.mode & 1 ? "CFG ": "",
-                    status_rid.mode & 2 ? "ACT ": "",
-                    status_rid.mode & 0x10 ? "SYN ": "",
-                    status_rid.mode & 0x20 ? "LNK ": "",
-                    status_rid.mode & 0x40 ? "LEAP ": "",
-                    status_rid.mode & 0x80 ? "PRIV ": "",
-                    status_rid.mode & 0x100 ? "KEY ": "",
-                    status_rid.mode & 0x200 ? "WEP ": "",
-                    status_rid.mode & 0x8000 ? "ERR ": "");
+                    mode & 1 ? "CFG ": "",
+                    mode & 2 ? "ACT ": "",
+                    mode & 0x10 ? "SYN ": "",
+                    mode & 0x20 ? "LNK ": "",
+                    mode & 0x40 ? "LEAP ": "",
+                    mode & 0x80 ? "PRIV ": "",
+                    mode & 0x100 ? "KEY ": "",
+                    mode & 0x200 ? "WEP ": "",
+                    mode & 0x8000 ? "ERR ": "");
@@ -4767,4 +4675,4 @@
-		 (int)status_rid.mode,
-		 (int)status_rid.normalizedSignalStrength,
-		 (int)status_rid.signalQuality,
-		 (int)status_rid.SSIDlen,
+		 le16_to_cpu(status_rid.mode),
+		 le16_to_cpu(status_rid.normalizedSignalStrength),
+		 le16_to_cpu(status_rid.signalQuality),
+		 le16_to_cpu(status_rid.SSIDlen),
@@ -4773,2 +4681,2 @@
-		 (int)status_rid.channel,
-		 (int)status_rid.currentXmitRate/2,
+		 le16_to_cpu(status_rid.channel),
+		 le16_to_cpu(status_rid.currentXmitRate) / 2,
@@ -4779,6 +4687,6 @@
-		 cap_rid.radioType,
-		 cap_rid.country,
-		 cap_rid.hardVer,
-		 (int)cap_rid.softVer,
-		 (int)cap_rid.softSubVer,
-		 (int)cap_rid.bootBlockVer );
+		 le16_to_cpu(cap_rid.radioType),
+		 le16_to_cpu(cap_rid.country),
+		 le16_to_cpu(cap_rid.hardVer),
+		 le16_to_cpu(cap_rid.softVer),
+		 le16_to_cpu(cap_rid.softSubVer),
+		 le16_to_cpu(cap_rid.bootBlockVer));
@@ -4804 +4712,2 @@
-				u16 rid ) {
+				u16 rid )
+{
@@ -4811 +4720,2 @@
-	u32 *vals = stats.vals;
+	__le32 *vals = stats.vals;
+	int len = le16_to_cpu(stats.len);
@@ -4824,2 +4734 @@
-	for(i=0; statsLabels[i]!=(char *)-1 &&
-		    i*4<stats.len; i++){
+	for(i=0; statsLabels[i]!=(char *)-1 && i*4<len; i++) {
@@ -4832 +4741,2 @@
-		j+=sprintf(data->rbuffer+j, "%s: %u\n", statsLabels[i], vals[i]);
+		j+=sprintf(data->rbuffer+j, "%s: %u\n", statsLabels[i],
+				le32_to_cpu(vals[i]));
@@ -4834 +4744 @@
-	if (i*4>=stats.len){
+	if (i*4 >= len) {
@@ -4859 +4769,8 @@
-static void proc_config_on_close( struct inode *inode, struct file *file ) {
+static inline int sniffing_mode(struct airo_info *ai)
+{
+	return le16_to_cpu(ai->config.rmode & RXMODE_MASK) >=
+		le16_to_cpu(RXMODE_RFMON);
+}
+
+static void proc_config_on_close(struct inode *inode, struct file *file)
+{
@@ -4876,3 +4793,3 @@
-			if ((ai->config.rmode & 0xff) >= RXMODE_RFMON)
-					set_bit (FLAG_RESET, &ai->flags);
-			ai->config.rmode &= 0xfe00;
+			if (sniffing_mode(ai))
+				set_bit (FLAG_RESET, &ai->flags);
+			ai->config.rmode &= ~RXMODE_FULL_MASK;
@@ -4880 +4797 @@
-			ai->config.opmode &= 0xFF00;
+			ai->config.opmode &= ~MODE_CFG_MASK;
@@ -4883 +4800 @@
-				ai->config.opmode |= 0;
+				ai->config.opmode |= MODE_STA_IBSS;
@@ -4885 +4802 @@
-				ai->config.opmode |= 1;
+				ai->config.opmode |= MODE_STA_ESS;
@@ -4951 +4868 @@
-				ai->config.channelSet = (u16)v;
+				ai->config.channelSet = cpu_to_le16(v);
@@ -4959 +4876 @@
-				ai->config.txPower = (u16)v;
+				ai->config.txPower = cpu_to_le16(v);
@@ -4966 +4883 @@
-				ai->config.authType = (u16)AUTH_SHAREDKEY;
+				ai->config.authType = AUTH_SHAREDKEY;
@@ -4969 +4886 @@
-				ai->config.authType = (u16)AUTH_ENCRYPT;
+				ai->config.authType = AUTH_ENCRYPT;
@@ -4972 +4889 @@
-				ai->config.authType = (u16)AUTH_OPEN;
+				ai->config.authType = AUTH_OPEN;
@@ -4982 +4899 @@
-			ai->config.longRetryLimit = (u16)v;
+			ai->config.longRetryLimit = cpu_to_le16(v);
@@ -4990 +4907 @@
-			ai->config.shortRetryLimit = (u16)v;
+			ai->config.shortRetryLimit = cpu_to_le16(v);
@@ -4998 +4915 @@
-			ai->config.rtsThres = (u16)v;
+			ai->config.rtsThres = cpu_to_le16(v);
@@ -5006 +4923 @@
-			ai->config.txLifetime = (u16)v;
+			ai->config.txLifetime = cpu_to_le16(v);
@@ -5014 +4931 @@
-			ai->config.rxLifetime = (u16)v;
+			ai->config.rxLifetime = cpu_to_le16(v);
@@ -5033 +4950 @@
-			ai->config.fragThresh = (u16)v;
+			ai->config.fragThresh = cpu_to_le16(v);
@@ -5060,2 +4977,3 @@
-static char *get_rmode(u16 mode) {
-        switch(mode&0xff) {
+static char *get_rmode(__le16 mode)
+{
+        switch(mode & RXMODE_MASK) {
@@ -5069 +4987,2 @@
-static int proc_config_open( struct inode *inode, struct file *file ) {
+static int proc_config_open(struct inode *inode, struct file *file)
+{
@@ -5074,0 +4994 @@
+	__le16 mode;
@@ -5092,0 +5013 @@
+	mode = ai->config.opmode & MODE_CFG_MASK;
@@ -5101,4 +5022,4 @@
-		     (ai->config.opmode & 0xFF) == 0 ? "adhoc" :
-		     (ai->config.opmode & 0xFF) == 1 ? get_rmode(ai->config.rmode):
-		     (ai->config.opmode & 0xFF) == 2 ? "AP" :
-		     (ai->config.opmode & 0xFF) == 3 ? "AP RPTR" : "Error",
+		     mode == MODE_STA_IBSS ? "adhoc" :
+		     mode == MODE_STA_ESS ? get_rmode(ai->config.rmode):
+		     mode == MODE_AP ? "AP" :
+		     mode == MODE_AP_RPTR ? "AP RPTR" : "Error",
@@ -5107,3 +5028,4 @@
-		     ai->config.powerSaveMode == 0 ? "CAM" :
-		     ai->config.powerSaveMode == 1 ? "PSP" :
-		     ai->config.powerSaveMode == 2 ? "PSPCAM" : "Error",
+		     ai->config.powerSaveMode == POWERSAVE_CAM ? "CAM" :
+		     ai->config.powerSaveMode == POWERSAVE_PSP ? "PSP" :
+		     ai->config.powerSaveMode == POWERSAVE_PSPCAM ? "PSPCAM" :
+		     "Error",
@@ -5118,2 +5040,2 @@
-		     (int)ai->config.channelSet,
-		     (int)ai->config.txPower
+		     le16_to_cpu(ai->config.channelSet),
+		     le16_to_cpu(ai->config.txPower)
@@ -5133,5 +5055,5 @@
-		 (int)ai->config.longRetryLimit,
-		 (int)ai->config.shortRetryLimit,
-		 (int)ai->config.rtsThres,
-		 (int)ai->config.txLifetime,
-		 (int)ai->config.rxLifetime,
+		 le16_to_cpu(ai->config.longRetryLimit),
+		 le16_to_cpu(ai->config.shortRetryLimit),
+		 le16_to_cpu(ai->config.rtsThres),
+		 le16_to_cpu(ai->config.txLifetime),
+		 le16_to_cpu(ai->config.rxLifetime),
@@ -5142 +5064 @@
-		 (int)ai->config.fragThresh,
+		 le16_to_cpu(ai->config.fragThresh),
@@ -5145 +5067 @@
-		 ai->config.modulation == 0 ? "default" :
+		 ai->config.modulation == MOD_DEFAULT ? "default" :
@@ -5156 +5078,2 @@
-static void proc_SSID_on_close( struct inode *inode, struct file *file ) {
+static void proc_SSID_on_close(struct inode *inode, struct file *file)
+{
@@ -5163 +5086,2 @@
-	int offset = 0;
+	char *p = data->wbuffer;
+	char *end = p + data->writelen;
@@ -5165 +5089,2 @@
-	if ( !data->writelen ) return;
+	if (!data->writelen)
+		return;
@@ -5167 +5092 @@
-	memset( &SSID_rid, 0, sizeof( SSID_rid ) );
+	*end = '\n'; /* sentinel; we have space for it */
@@ -5169,12 +5094,13 @@
-	for( i = 0; i < 3; i++ ) {
-		int j;
-		for( j = 0; j+offset < data->writelen && j < 32 &&
-			     data->wbuffer[offset+j] != '\n'; j++ ) {
-			SSID_rid.ssids[i].ssid[j] = data->wbuffer[offset+j];
-		}
-		if ( j == 0 ) break;
-		SSID_rid.ssids[i].len = j;
-		offset += j;
-		while( data->wbuffer[offset] != '\n' &&
-		       offset < data->writelen ) offset++;
-		offset++;
+	memset(&SSID_rid, 0, sizeof(SSID_rid));
+
+	for (i = 0; i < 3 && p < end; i++) {
+		int j = 0;
+		/* copy up to 32 characters from this line */
+		while (*p != '\n' && j < 32)
+			SSID_rid.ssids[i].ssid[j++] = *p++;
+		if (j == 0)
+			break;
+		SSID_rid.ssids[i].len = cpu_to_le16(j);
+		/* skip to the beginning of the next line */
+		while (*p++ != '\n')
+			;
@@ -5183 +5109 @@
-		SSID_rid.len = sizeof(SSID_rid);
+		SSID_rid.len = cpu_to_le16(sizeof(SSID_rid));
@@ -5207 +5133 @@
-	APList_rid.len = sizeof(APList_rid);
+	APList_rid.len = cpu_to_le16(sizeof(APList_rid));
@@ -5247 +5173 @@
-	u16 lastindex;
+	__le16 lastindex;
@@ -5252 +5178 @@
-		if (wkr.kindex == index) {
+		if (wkr.kindex == cpu_to_le16(index)) {
@@ -5256 +5182 @@
-			return wkr.klen;
+			return le16_to_cpu(wkr.klen);
@@ -5259 +5185 @@
-	} while(lastindex != wkr.kindex);
+	} while (lastindex != wkr.kindex);
@@ -5264 +5190,2 @@
-		       const char *key, u16 keylen, int perm, int lock ) {
+		       const char *key, u16 keylen, int perm, int lock )
+{
@@ -5271,2 +5198,2 @@
-		wkr.len = sizeof(wkr);
-		wkr.kindex = 0xffff;
+		wkr.len = cpu_to_le16(sizeof(wkr));
+		wkr.kindex = cpu_to_le16(0xffff);
@@ -5277,3 +5204,3 @@
-		wkr.len = sizeof(wkr);
-		wkr.kindex = index;
-		wkr.klen = keylen;
+		wkr.len = cpu_to_le16(sizeof(wkr));
+		wkr.kindex = cpu_to_le16(index);
+		wkr.klen = cpu_to_le16(keylen);
@@ -5331 +5258,2 @@
-static int proc_wepkey_open( struct inode *inode, struct file *file ) {
+static int proc_wepkey_open( struct inode *inode, struct file *file )
+{
@@ -5338 +5266 @@
-	u16 lastindex;
+	__le16 lastindex;
@@ -5364 +5292 @@
-		if (wkr.kindex == 0xffff) {
+		if (wkr.kindex == cpu_to_le16(0xffff)) {
@@ -5369 +5297,2 @@
-				     (int)wkr.kindex, (int)wkr.klen);
+				     le16_to_cpu(wkr.kindex),
+				     le16_to_cpu(wkr.klen));
@@ -5378 +5307,2 @@
-static int proc_SSID_open( struct inode *inode, struct file *file ) {
+static int proc_SSID_open(struct inode *inode, struct file *file)
+{
@@ -5396 +5326,2 @@
-	if ((data->wbuffer = kzalloc( 33*3, GFP_KERNEL )) == NULL) {
+	/* allocate maxwritelen + 1; we'll want a sentinel */
+	if ((data->wbuffer = kzalloc(33*3 + 1, GFP_KERNEL)) == NULL) {
@@ -5405 +5336 @@
-	for( i = 0; i < 3; i++ ) {
+	for (i = 0; i < 3; i++) {
@@ -5407,4 +5338,6 @@
-		if ( !SSID_rid.ssids[i].len ) break;
-		for( j = 0; j < 32 &&
-			     j < SSID_rid.ssids[i].len &&
-			     SSID_rid.ssids[i].ssid[j]; j++ ) {
+		size_t len = le16_to_cpu(SSID_rid.ssids[i].len);
+		if (!len)
+			break;
+		if (len > 32)
+			len = 32;
+		for (j = 0; j < len && SSID_rid.ssids[i].ssid[j]; j++)
@@ -5412 +5344,0 @@
-		}
@@ -5508 +5440 @@
-	while(rc == 0 && BSSList_rid.index != 0xffff) {
+	while(rc == 0 && BSSList_rid.index != cpu_to_le16(0xffff)) {
@@ -5513 +5445 @@
-				(int)BSSList_rid.dBm);
+				le16_to_cpu(BSSList_rid.dBm));
@@ -5515 +5447 @@
-				(int)BSSList_rid.dsChannel,
+				le16_to_cpu(BSSList_rid.dsChannel),
@@ -5782,0 +5715 @@
+	u16 sq;
@@ -5784,6 +5717,10 @@
-	if ((status_rid->mode & 0x3f) == 0x3f && (cap_rid->hardCap & 8)) {
-		if (memcmp(cap_rid->prodName, "350", 3))
-			if (status_rid->signalQuality > 0x20)
-				quality = 0;
-			else
-				quality = 0x20 - status_rid->signalQuality;
+	if ((status_rid->mode & cpu_to_le16(0x3f)) != cpu_to_le16(0x3f))
+		return 0;
+
+	if (!(cap_rid->hardCap & cpu_to_le16(8)))
+		return 0;
+
+	sq = le16_to_cpu(status_rid->signalQuality);
+	if (memcmp(cap_rid->prodName, "350", 3))
+		if (sq > 0x20)
+			quality = 0;
@@ -5791,7 +5728,8 @@
-			if (status_rid->signalQuality > 0xb0)
-				quality = 0;
-			else if (status_rid->signalQuality < 0x10)
-				quality = 0xa0;
-			else
-				quality = 0xb0 - status_rid->signalQuality;
-	}
+			quality = 0x20 - sq;
+	else
+		if (sq > 0xb0)
+			quality = 0;
+		else if (sq < 0x10)
+			quality = 0xa0;
+		else
+			quality = 0xb0 - sq;
@@ -5855 +5793 @@
-			local->config.channelSet = (u16) channel;
+			local->config.channelSet = cpu_to_le16(channel);
@@ -5876 +5814 @@
-	if ((local->config.opmode & 0xFF) == MODE_STA_ESS)
+	if ((local->config.opmode & MODE_CFG_MASK) == MODE_STA_ESS)
@@ -5881 +5819 @@
-	ch = (int)status_rid.channel;
+	ch = le16_to_cpu(status_rid.channel);
@@ -5928 +5866 @@
-		SSID_rid.ssids[index].len = dwrq->length;
+		SSID_rid.ssids[index].len = cpu_to_le16(dwrq->length);
@@ -5930 +5868 @@
-	SSID_rid.len = sizeof(SSID_rid);
+	SSID_rid.len = cpu_to_le16(sizeof(SSID_rid));
@@ -5957 +5895 @@
-	memcpy(extra, status_rid.SSID, status_rid.SSIDlen);
+	memcpy(extra, status_rid.SSID, le16_to_cpu(status_rid.SSIDlen));
@@ -5961 +5899 @@
-	dwrq->length = status_rid.SSIDlen;
+	dwrq->length = le16_to_cpu(status_rid.SSIDlen);
@@ -5995 +5933 @@
-		APList_rid.len = sizeof(APList_rid);
+		APList_rid.len = cpu_to_le16(sizeof(APList_rid));
@@ -6151 +6089 @@
-	vwrq->value = status_rid.currentXmitRate * 500000;
+	vwrq->value = le16_to_cpu(status_rid.currentXmitRate) * 500000;
@@ -6177 +6115 @@
-	local->config.rtsThres = rthr;
+	local->config.rtsThres = cpu_to_le16(rthr);
@@ -6195 +6133 @@
-	vwrq->value = local->config.rtsThres;
+	vwrq->value = le16_to_cpu(local->config.rtsThres);
@@ -6221 +6159 @@
-	local->config.fragThresh = (u16)fthr;
+	local->config.fragThresh = cpu_to_le16(fthr);
@@ -6239 +6177 @@
-	vwrq->value = local->config.fragThresh;
+	vwrq->value = le16_to_cpu(local->config.fragThresh);
@@ -6259 +6197 @@
-	if ((local->config.rmode & 0xff) >= RXMODE_RFMON)
+	if (sniffing_mode(local))
@@ -6264 +6202 @@
-			local->config.opmode &= 0xFF00;
+			local->config.opmode &= ~MODE_CFG_MASK;
@@ -6266 +6204 @@
-			local->config.rmode &= 0xfe00;
+			local->config.rmode &= ~RXMODE_FULL_MASK;
@@ -6271 +6209 @@
-			local->config.opmode &= 0xFF00;
+			local->config.opmode &= ~MODE_CFG_MASK;
@@ -6273 +6211 @@
-			local->config.rmode &= 0xfe00;
+			local->config.rmode &= ~RXMODE_FULL_MASK;
@@ -6278 +6216 @@
-			local->config.opmode &= 0xFF00;
+			local->config.opmode &= ~MODE_CFG_MASK;
@@ -6280 +6218 @@
-			local->config.rmode &= 0xfe00;
+			local->config.rmode &= ~RXMODE_FULL_MASK;
@@ -6285 +6223 @@
-			local->config.opmode &= 0xFF00;
+			local->config.opmode &= ~MODE_CFG_MASK;
@@ -6287 +6225 @@
-			local->config.rmode &= 0xfe00;
+			local->config.rmode &= ~RXMODE_FULL_MASK;
@@ -6292 +6230 @@
-			local->config.opmode &= 0xFF00;
+			local->config.opmode &= ~MODE_CFG_MASK;
@@ -6294 +6232 @@
-			local->config.rmode &= 0xfe00;
+			local->config.rmode &= ~RXMODE_FULL_MASK;
@@ -6322 +6260 @@
-	switch (local->config.opmode & 0xFF) {
+	switch (local->config.opmode & MODE_CFG_MASK) {
@@ -6338,0 +6277,7 @@
+static inline int valid_index(CapabilityRid *p, int index)
+{
+	if (index < 0)
+		return 0;
+	return index < (p->softCap & cpu_to_le16(0x80) ? 4 : 1);
+}
+
@@ -6351 +6296 @@
-	u16 currentAuthType = local->config.authType;
+	__le16 currentAuthType = local->config.authType;
@@ -6356 +6301 @@
-	if(!(cap_rid.softCap & 2)) {
+	if(!(cap_rid.softCap & cpu_to_le16(2))) {
@@ -6376 +6321 @@
-		if ((index < 0) || (index >= ((cap_rid.softCap & 0x80) ? 4:1)))
+		if (!valid_index(&cap_rid, index))
@@ -6406 +6351 @@
-		if ((index >= 0) && (index < ((cap_rid.softCap & 0x80)?4:1))) {
+		if (valid_index(&cap_rid, index)) {
@@ -6410 +6355 @@
-			if(!dwrq->flags & IW_ENCODE_MODE) {
+			if (!(dwrq->flags & IW_ENCODE_MODE))
@@ -6412 +6356,0 @@
-			}
@@ -6442 +6386 @@
-	if(!(cap_rid.softCap & 2)) {
+	if(!(cap_rid.softCap & cpu_to_le16(2))) {
@@ -6464 +6408 @@
-	if ((index < 0) || (index >= ((cap_rid.softCap & 0x80) ? 4 : 1)))
+	if (!valid_index(&cap_rid, index))
@@ -6489 +6433 @@
-	u16 currentAuthType = local->config.authType;
+	__le16 currentAuthType = local->config.authType;
@@ -6496 +6440 @@
-	if(!(cap_rid.softCap & 2)) {
+	if(!(cap_rid.softCap & cpu_to_le16(2))) {
@@ -6504 +6448 @@
-		if (idx < 1 || idx > ((cap_rid.softCap & 0x80) ? 4:1))
+		if (!valid_index(&cap_rid, idx - 1))
@@ -6578 +6522 @@
-	if(!(cap_rid.softCap & 2)) {
+	if(!(cap_rid.softCap & cpu_to_le16(2))) {
@@ -6589 +6533 @@
-		if (idx < 1 || idx > ((cap_rid.softCap & 0x80) ? 4:1))
+		if (!valid_index(&cap_rid, idx - 1))
@@ -6635 +6579 @@
-	u16 currentAuthType = local->config.authType;
+	__le16 currentAuthType = local->config.authType;
@@ -6703 +6647 @@
-	u16 currentAuthType = local->config.authType;
+	__le16 currentAuthType = local->config.authType;
@@ -6753,0 +6698 @@
+	__le16 v = cpu_to_le16(vwrq->value);
@@ -6767 +6712 @@
-		if ((vwrq->value==cap_rid.txPowerLevels[i])) {
+		if (v == cap_rid.txPowerLevels[i]) {
@@ -6769 +6714 @@
-			local->config.txPower = vwrq->value;
+			local->config.txPower = v;
@@ -6789 +6734 @@
-	vwrq->value = local->config.txPower;
+	vwrq->value = le16_to_cpu(local->config.txPower);
@@ -6813,0 +6759 @@
+		__le16 v = cpu_to_le16(vwrq->value);
@@ -6815 +6761 @@
-			local->config.longRetryLimit = vwrq->value;
+			local->config.longRetryLimit = v;
@@ -6817 +6763 @@
-			local->config.shortRetryLimit = vwrq->value;
+			local->config.shortRetryLimit = v;
@@ -6820,2 +6766,2 @@
-			local->config.longRetryLimit = vwrq->value;
-			local->config.shortRetryLimit = vwrq->value;
+			local->config.longRetryLimit = v;
+			local->config.shortRetryLimit = v;
@@ -6827 +6773 @@
-		local->config.txLifetime = vwrq->value / 1024;
+		local->config.txLifetime = cpu_to_le16(vwrq->value / 1024);
@@ -6851 +6797 @@
-		vwrq->value = (int)local->config.txLifetime * 1024;
+		vwrq->value = le16_to_cpu(local->config.txLifetime) * 1024;
@@ -6854 +6800 @@
-		vwrq->value = (int)local->config.longRetryLimit;
+		vwrq->value = le16_to_cpu(local->config.longRetryLimit);
@@ -6857,2 +6803,2 @@
-		vwrq->value = (int)local->config.shortRetryLimit;
-		if((int)local->config.shortRetryLimit != (int)local->config.longRetryLimit)
+		vwrq->value = le16_to_cpu(local->config.shortRetryLimit);
+		if(local->config.shortRetryLimit != local->config.longRetryLimit)
@@ -6939 +6885 @@
-	if(cap_rid.softCap & 2) {
+	if(cap_rid.softCap & cpu_to_le16(2)) {
@@ -6943 +6889 @@
-		if (cap_rid.softCap & 0x100) {
+		if (cap_rid.softCap & cpu_to_le16(0x100)) {
@@ -6948 +6894,2 @@
-		range->max_encoding_tokens = (cap_rid.softCap & 0x80) ? 4 : 1;
+		range->max_encoding_tokens =
+			cap_rid.softCap & cpu_to_le16(0x80) ? 4 : 1;
@@ -6963 +6910 @@
-		range->txpower[i] = cap_rid.txPowerLevels[i];
+		range->txpower[i] = le16_to_cpu(cap_rid.txPowerLevels[i]);
@@ -7002 +6949 @@
-		if ((local->config.rmode & 0xFF) >= RXMODE_RFMON) {
+		if (sniffing_mode(local))
@@ -7004 +6950,0 @@
-		}
@@ -7006 +6952 @@
-		local->config.rmode &= 0xFF00;
+		local->config.rmode &= ~RXMODE_MASK;
@@ -7012 +6958 @@
-		local->config.fastListenDelay = (vwrq->value + 500) / 1024;
+		local->config.fastListenDelay = cpu_to_le16((vwrq->value + 500) / 1024);
@@ -7016 +6962,3 @@
-		local->config.fastListenInterval = local->config.listenInterval = (vwrq->value + 500) / 1024;
+		local->config.fastListenInterval =
+		local->config.listenInterval =
+			cpu_to_le16((vwrq->value + 500) / 1024);
@@ -7022 +6970 @@
-			if ((local->config.rmode & 0xFF) >= RXMODE_RFMON) {
+			if (sniffing_mode(local))
@@ -7024,2 +6972 @@
-			}
-			local->config.rmode &= 0xFF00;
+			local->config.rmode &= ~RXMODE_MASK;
@@ -7030 +6977 @@
-			if ((local->config.rmode & 0xFF) >= RXMODE_RFMON) {
+			if (sniffing_mode(local))
@@ -7032,2 +6979 @@
-			}
-			local->config.rmode &= 0xFF00;
+			local->config.rmode &= ~RXMODE_MASK;
@@ -7057 +7003 @@
-	int mode;
+	__le16 mode;
@@ -7064 +7010 @@
-		vwrq->value = (int)local->config.fastListenDelay * 1024;
+		vwrq->value = le16_to_cpu(local->config.fastListenDelay) * 1024;
@@ -7067 +7013 @@
-		vwrq->value = (int)local->config.fastListenInterval * 1024;
+		vwrq->value = le16_to_cpu(local->config.fastListenInterval) * 1024;
@@ -7070 +7016 @@
-	if ((local->config.rmode & 0xFF) == RXMODE_ADDR)
+	if ((local->config.rmode & RXMODE_MASK) == RXMODE_ADDR)
@@ -7090 +7036,2 @@
-	local->config.rssiThreshold = vwrq->disabled ? RSSI_DEFAULT : vwrq->value;
+	local->config.rssiThreshold =
+		cpu_to_le16(vwrq->disabled ? RSSI_DEFAULT : vwrq->value);
@@ -7108 +7055 @@
-	vwrq->value = local->config.rssiThreshold;
+	vwrq->value = le16_to_cpu(local->config.rssiThreshold);
@@ -7132,0 +7080 @@
+		u16 dBm;
@@ -7137,0 +7086 @@
+		dBm = le16_to_cpu(BSSList.dBm);
@@ -7139,2 +7088,2 @@
-			qual[i].level = 0x100 - BSSList.dBm;
-			qual[i].qual = airo_dbm_to_pct( local->rssi, BSSList.dBm );
+			qual[i].level = 0x100 - dBm;
+			qual[i].qual = airo_dbm_to_pct(local->rssi, dBm);
@@ -7145 +7094 @@
-			qual[i].level = (BSSList.dBm + 321) / 2;
+			qual[i].level = (dBm + 321) / 2;
@@ -7152 +7101 @@
-		if (BSSList.index == 0xffff)
+		if (BSSList.index == cpu_to_le16(0xffff))
@@ -7243 +7192 @@
-	u16			capabilities;
+	__le16			capabilities;
@@ -7246,0 +7196 @@
+	u16 dBm;
@@ -7266 +7216 @@
-	capabilities = le16_to_cpu(bss->cap);
+	capabilities = bss->cap;
@@ -7284,0 +7235,2 @@
+	dBm = le16_to_cpu(bss->dBm);
+
@@ -7288,2 +7240,2 @@
-		iwe.u.qual.level = 0x100 - bss->dBm;
-		iwe.u.qual.qual = airo_dbm_to_pct( ai->rssi, bss->dBm );
+		iwe.u.qual.level = 0x100 - dBm;
+		iwe.u.qual.qual = airo_dbm_to_pct(ai->rssi, dBm);
@@ -7294 +7246 @@
-		iwe.u.qual.level = (bss->dBm + 321) / 2;
+		iwe.u.qual.level = (dBm + 321) / 2;
@@ -7673 +7625 @@
-	u32 *vals = stats_rid.vals;
+	__le32 *vals = stats_rid.vals;
@@ -7687 +7639 @@
-	local->wstats.status = status_rid.mode;
+	local->wstats.status = le16_to_cpu(status_rid.mode);
@@ -7691 +7643,3 @@
-		local->wstats.qual.level = airo_rssi_to_dbm( local->rssi, status_rid.sigQuality );
+		local->wstats.qual.level =
+			airo_rssi_to_dbm(local->rssi,
+					 le16_to_cpu(status_rid.sigQuality));
@@ -7693 +7647,2 @@
-		local->wstats.qual.qual = status_rid.normalizedSignalStrength;
+		local->wstats.qual.qual =
+			le16_to_cpu(status_rid.normalizedSignalStrength);
@@ -7695 +7650,2 @@
-		local->wstats.qual.level = (status_rid.normalizedSignalStrength + 321) / 2;
+		local->wstats.qual.level =
+			(le16_to_cpu(status_rid.normalizedSignalStrength) + 321) / 2;
@@ -7698 +7654 @@
-	if (status_rid.len >= 124) {
+	if (le16_to_cpu(status_rid.len) >= 124) {
@@ -7708,6 +7664,9 @@
-	local->wstats.discard.nwid = vals[56] + vals[57] + vals[58];/* SSID Mismatch */
-	local->wstats.discard.code = vals[6];/* RxWepErr */
-	local->wstats.discard.fragment = vals[30];
-	local->wstats.discard.retries = vals[10];
-	local->wstats.discard.misc = vals[1] + vals[32];
-	local->wstats.miss.beacon = vals[34];
+	local->wstats.discard.nwid = le32_to_cpu(vals[56]) +
+				     le32_to_cpu(vals[57]) +
+				     le32_to_cpu(vals[58]); /* SSID Mismatch */
+	local->wstats.discard.code = le32_to_cpu(vals[6]);/* RxWepErr */
+	local->wstats.discard.fragment = le32_to_cpu(vals[30]);
+	local->wstats.discard.retries = le32_to_cpu(vals[10]);
+	local->wstats.discard.misc = le32_to_cpu(vals[1]) +
+				     le32_to_cpu(vals[32]);
+	local->wstats.miss.beacon = le32_to_cpu(vals[34]);
@@ -7899 +7858 @@
-		if ((cfg->opmode & 0xFF) == MODE_STA_IBSS)
+		if ((cfg->opmode & MODE_CFG_MASK) == MODE_STA_IBSS)
--- ./projects/linux/linux-2.6.25/drivers/net/wireless/airo.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/net/wireless/airo.c	2008-07-13 23:51:29.000000000 +0200
@@ -2670,0 +2671 @@
+	SET_NETDEV_DEV(dev, ethdev->dev.parent);
@@ -2907 +2908 @@
-	while ((IN4500 (ai, COMMAND) & COMMAND_BUSY) & (delay < 10000)) {
+	while ((IN4500(ai, COMMAND) & COMMAND_BUSY) && (delay < 10000)) {
@@ -3660 +3661 @@
-	gap = le16_to_cpu(get_unaligned((__le16 *)ptr));
+	gap = get_unaligned_le16(ptr);
@@ -4349,0 +4351 @@
+	.owner		= THIS_MODULE,
@@ -4355,0 +4358 @@
+	.owner		= THIS_MODULE,
@@ -4361,0 +4365 @@
+	.owner		= THIS_MODULE,
@@ -4367,0 +4372 @@
+	.owner		= THIS_MODULE,
@@ -4374,0 +4380 @@
+	.owner		= THIS_MODULE,
@@ -4381,0 +4388 @@
+	.owner		= THIS_MODULE,
@@ -4388,0 +4396 @@
+	.owner		= THIS_MODULE,
@@ -4395,0 +4404 @@
+	.owner		= THIS_MODULE,
@@ -4414,4 +4422,0 @@
-#ifndef SETPROC_OPS
-#define SETPROC_OPS(entry, ops) (entry)->proc_fops = &(ops)
-#endif
-
@@ -4433,3 +4438,3 @@
-	entry = create_proc_entry("StatsDelta",
-				  S_IFREG | (S_IRUGO&proc_perm),
-				  apriv->proc_entry);
+	entry = proc_create_data("StatsDelta",
+				 S_IFREG | (S_IRUGO&proc_perm),
+				 apriv->proc_entry, &proc_statsdelta_ops, dev);
@@ -4440,3 +4444,0 @@
-	entry->data = dev;
-	entry->owner = THIS_MODULE;
-	SETPROC_OPS(entry, proc_statsdelta_ops);
@@ -4445,3 +4447,3 @@
-	entry = create_proc_entry("Stats",
-				  S_IFREG | (S_IRUGO&proc_perm),
-				  apriv->proc_entry);
+	entry = proc_create_data("Stats",
+				 S_IFREG | (S_IRUGO&proc_perm),
+				 apriv->proc_entry, &proc_stats_ops, dev);
@@ -4452,3 +4453,0 @@
-	entry->data = dev;
-	entry->owner = THIS_MODULE;
-	SETPROC_OPS(entry, proc_stats_ops);
@@ -4457,3 +4456,3 @@
-	entry = create_proc_entry("Status",
-				  S_IFREG | (S_IRUGO&proc_perm),
-				  apriv->proc_entry);
+	entry = proc_create_data("Status",
+				 S_IFREG | (S_IRUGO&proc_perm),
+				 apriv->proc_entry, &proc_status_ops, dev);
@@ -4464,3 +4462,0 @@
-	entry->data = dev;
-	entry->owner = THIS_MODULE;
-	SETPROC_OPS(entry, proc_status_ops);
@@ -4469,3 +4465,3 @@
-	entry = create_proc_entry("Config",
-				  S_IFREG | proc_perm,
-				  apriv->proc_entry);
+	entry = proc_create_data("Config",
+				 S_IFREG | proc_perm,
+				 apriv->proc_entry, &proc_config_ops, dev);
@@ -4476,3 +4471,0 @@
-	entry->data = dev;
-	entry->owner = THIS_MODULE;
-	SETPROC_OPS(entry, proc_config_ops);
@@ -4481,3 +4474,3 @@
-	entry = create_proc_entry("SSID",
-				  S_IFREG | proc_perm,
-				  apriv->proc_entry);
+	entry = proc_create_data("SSID",
+				 S_IFREG | proc_perm,
+				 apriv->proc_entry, &proc_SSID_ops, dev);
@@ -4488,3 +4480,0 @@
-	entry->data = dev;
-	entry->owner = THIS_MODULE;
-	SETPROC_OPS(entry, proc_SSID_ops);
@@ -4493,3 +4483,3 @@
-	entry = create_proc_entry("APList",
-				  S_IFREG | proc_perm,
-				  apriv->proc_entry);
+	entry = proc_create_data("APList",
+				 S_IFREG | proc_perm,
+				 apriv->proc_entry, &proc_APList_ops, dev);
@@ -4500,3 +4489,0 @@
-	entry->data = dev;
-	entry->owner = THIS_MODULE;
-	SETPROC_OPS(entry, proc_APList_ops);
@@ -4505,3 +4492,3 @@
-	entry = create_proc_entry("BSSList",
-				  S_IFREG | proc_perm,
-				  apriv->proc_entry);
+	entry = proc_create_data("BSSList",
+				 S_IFREG | proc_perm,
+				 apriv->proc_entry, &proc_BSSList_ops, dev);
@@ -4512,3 +4498,0 @@
-	entry->data = dev;
-	entry->owner = THIS_MODULE;
-	SETPROC_OPS(entry, proc_BSSList_ops);
@@ -4517,3 +4501,3 @@
-	entry = create_proc_entry("WepKey",
-				  S_IFREG | proc_perm,
-				  apriv->proc_entry);
+	entry = proc_create_data("WepKey",
+				 S_IFREG | proc_perm,
+				 apriv->proc_entry, &proc_wepkey_ops, dev);
@@ -4524,3 +4507,0 @@
-	entry->data = dev;
-	entry->owner = THIS_MODULE;
-	SETPROC_OPS(entry, proc_wepkey_ops);
@@ -5628 +5609 @@
-	airo_entry = create_proc_entry("aironet",
+	airo_entry = create_proc_entry("driver/aironet",
@@ -5630 +5611 @@
-				       proc_root_driver);
+				       NULL);
@@ -5654 +5635 @@
-		remove_proc_entry("aironet", proc_root_driver);
+		remove_proc_entry("driver/aironet", NULL);
@@ -5676 +5657 @@
-	remove_proc_entry("aironet", proc_root_driver);
+	remove_proc_entry("driver/aironet", NULL);
--- ./projects/linux/linux-2.6.26/drivers/net/wireless/airo.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/net/wireless/airo.c	2008-10-10 00:13:53.000000000 +0200
@@ -88,2 +88,2 @@
-#define WIRELESS_SPY		// enable iwspy support
-#include <net/iw_handler.h>	// New driver API
+#define WIRELESS_SPY		/* enable iwspy support */
+#include <net/iw_handler.h>	/* New driver API */
@@ -91 +91 @@
-#define CISCO_EXT		// enable Cisco extensions
+#define CISCO_EXT		/* enable Cisco extensions */
@@ -284 +284 @@
-static int do8bitIO = 0;
+static int do8bitIO /* = 0 */;
@@ -401,2 +401,2 @@
-#define BAP0 0 // Used for receiving packets
-#define BAP1 2 // Used for xmiting packets and working with RIDS
+#define BAP0 0 /* Used for receiving packets */
+#define BAP1 2 /* Used for xmiting packets and working with RIDS */
@@ -1151 +1150,0 @@
-	struct net_device_stats	stats;
@@ -1927 +1926 @@
-			ai->stats.tx_fifo_errors++;
+			dev->stats.tx_fifo_errors++;
@@ -2047 +2046 @@
-		ai->stats.tx_aborted_errors++;
+		ai->dev->stats.tx_aborted_errors++;
@@ -2049 +2048 @@
-		ai->stats.tx_heartbeat_errors++;
+		ai->dev->stats.tx_heartbeat_errors++;
@@ -2053 +2052 @@
-		ai->stats.tx_carrier_errors++;
+		ai->dev->stats.tx_carrier_errors++;
@@ -2105 +2104 @@
-		priv->stats.tx_window_errors++;
+		dev->stats.tx_window_errors++;
@@ -2131 +2130 @@
-			priv->stats.tx_fifo_errors++;
+			dev->stats.tx_fifo_errors++;
@@ -2170 +2169 @@
-		priv->stats.tx_window_errors++;
+		dev->stats.tx_window_errors++;
@@ -2202 +2201 @@
-			priv->stats.tx_fifo_errors++;
+			dev->stats.tx_fifo_errors++;
@@ -2222 +2221 @@
-static void airo_read_stats(struct airo_info *ai)
+static void airo_read_stats(struct net_device *dev)
@@ -2223,0 +2223 @@
+	struct airo_info *ai = dev->priv;
@@ -2235 +2235 @@
-	ai->stats.rx_packets = le32_to_cpu(vals[43]) + le32_to_cpu(vals[44]) +
+	dev->stats.rx_packets = le32_to_cpu(vals[43]) + le32_to_cpu(vals[44]) +
@@ -2237 +2237 @@
-	ai->stats.tx_packets = le32_to_cpu(vals[39]) + le32_to_cpu(vals[40]) +
+	dev->stats.tx_packets = le32_to_cpu(vals[39]) + le32_to_cpu(vals[40]) +
@@ -2239,3 +2239,3 @@
-	ai->stats.rx_bytes = le32_to_cpu(vals[92]);
-	ai->stats.tx_bytes = le32_to_cpu(vals[91]);
-	ai->stats.rx_errors = le32_to_cpu(vals[0]) + le32_to_cpu(vals[2]) +
+	dev->stats.rx_bytes = le32_to_cpu(vals[92]);
+	dev->stats.tx_bytes = le32_to_cpu(vals[91]);
+	dev->stats.rx_errors = le32_to_cpu(vals[0]) + le32_to_cpu(vals[2]) +
@@ -2243,3 +2243,4 @@
-	ai->stats.tx_errors = le32_to_cpu(vals[42]) + ai->stats.tx_fifo_errors;
-	ai->stats.multicast = le32_to_cpu(vals[43]);
-	ai->stats.collisions = le32_to_cpu(vals[89]);
+	dev->stats.tx_errors = le32_to_cpu(vals[42]) +
+			      dev->stats.tx_fifo_errors;
+	dev->stats.multicast = le32_to_cpu(vals[43]);
+	dev->stats.collisions = le32_to_cpu(vals[89]);
@@ -2248,4 +2249,4 @@
-	ai->stats.rx_length_errors = le32_to_cpu(vals[3]);
-	ai->stats.rx_crc_errors = le32_to_cpu(vals[4]);
-	ai->stats.rx_frame_errors = le32_to_cpu(vals[2]);
-	ai->stats.rx_fifo_errors = le32_to_cpu(vals[0]);
+	dev->stats.rx_length_errors = le32_to_cpu(vals[3]);
+	dev->stats.rx_crc_errors = le32_to_cpu(vals[4]);
+	dev->stats.rx_frame_errors = le32_to_cpu(vals[2]);
+	dev->stats.rx_fifo_errors = le32_to_cpu(vals[0]);
@@ -2264 +2265 @@
-			airo_read_stats(local);
+			airo_read_stats(dev);
@@ -2267 +2268 @@
-	return &local->stats;
+	return &dev->stats;
@@ -3096 +3097 @@
-			airo_read_stats(ai);
+			airo_read_stats(dev);
@@ -3292 +3293 @@
-				apriv->stats.rx_dropped++;
+				dev->stats.rx_dropped++;
@@ -3560 +3561 @@
-			ai->stats.rx_dropped++;
+			ai->dev->stats.rx_dropped++;
@@ -3653 +3654 @@
-		ai->stats.rx_dropped++;
+		ai->dev->stats.rx_dropped++;
@@ -4563,2 +4564 @@
-	loff_t pos = *offset;
-	struct proc_data *priv = (struct proc_data*)file->private_data;
+	struct proc_data *priv = file->private_data;
@@ -4569,10 +4569,2 @@
-	if (pos < 0)
-		return -EINVAL;
-	if (pos >= priv->readlen)
-		return 0;
-	if (len > priv->readlen - pos)
-		len = priv->readlen - pos;
-	if (copy_to_user(buffer, priv->rbuffer + pos, len))
-		return -EFAULT;
-	*offset = pos + len;
-	return len;
+	return simple_read_from_buffer(buffer, len, offset, priv->rbuffer,
+					priv->readlen);
@@ -5533,2 +5525,3 @@
-	if ((ai->APList == NULL) &&
-		(ai->APList = kmalloc(sizeof(APListRid), GFP_KERNEL)) == NULL)
+	if (!ai->APList)
+		ai->APList = kmalloc(sizeof(APListRid), GFP_KERNEL);
+	if (!ai->APList)
@@ -5536,2 +5529,3 @@
-	if ((ai->SSID == NULL) &&
-		(ai->SSID = kmalloc(sizeof(SsidRid), GFP_KERNEL)) == NULL)
+	if (!ai->SSID)
+		ai->SSID = kmalloc(sizeof(SsidRid), GFP_KERNEL);
+	if (!ai->SSID)
@@ -5548 +5542 @@
-	cmd.cmd=HOSTSLEEP;
+	cmd.cmd = HOSTSLEEP;
@@ -5578 +5572 @@
-	set_bit (FLAG_COMMIT, &ai->flags);
+	set_bit(FLAG_COMMIT, &ai->flags);
@@ -5605,3 +5598,0 @@
-#if 0
-	int have_isa_dev = 0;
-#endif
@@ -5618 +5609 @@
-	for( i = 0; i < 4 && io[i] && irq[i]; i++ ) {
+	for (i = 0; i < 4 && io[i] && irq[i]; i++) {
@@ -5622,3 +5612,0 @@
-#if 0
-			have_isa_dev = 1;
-#else
@@ -5626 +5613,0 @@
-#endif
@@ -5672 +5659 @@
-	if( !rssi_rid )
+	if (!rssi_rid)
@@ -5682 +5669 @@
-	if( !rssi_rid )
+	if (!rssi_rid)
@@ -5685 +5672 @@
-	for( i = 0; i < 256; i++ )
+	for (i = 0; i < 256; i++)
@@ -7166,0 +7154 @@
+					struct iw_request_info *info,
@@ -7183 +7171,2 @@
-	current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_ADDR_LEN);
+	current_ev = iwe_stream_add_event(info, current_ev, end_buf,
+					  &iwe, IW_EV_ADDR_LEN);
@@ -7193 +7182,2 @@
-	current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, bss->ssid);
+	current_ev = iwe_stream_add_point(info, current_ev, end_buf,
+					  &iwe, bss->ssid);
@@ -7203 +7193,2 @@
-		current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_UINT_LEN);
+		current_ev = iwe_stream_add_event(info, current_ev, end_buf,
+						  &iwe, IW_EV_UINT_LEN);
@@ -7214 +7205,2 @@
-	current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_FREQ_LEN);
+	current_ev = iwe_stream_add_event(info, current_ev, end_buf,
+					  &iwe, IW_EV_FREQ_LEN);
@@ -7234 +7226,2 @@
-	current_ev = iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_QUAL_LEN);
+	current_ev = iwe_stream_add_event(info, current_ev, end_buf,
+					  &iwe, IW_EV_QUAL_LEN);
@@ -7243 +7236,2 @@
-	current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, bss->ssid);
+	current_ev = iwe_stream_add_point(info, current_ev, end_buf,
+					  &iwe, bss->ssid);
@@ -7247 +7241 @@
-	current_val = current_ev + IW_EV_LCP_LEN;
+	current_val = current_ev + iwe_stream_lcp_len(info);
@@ -7260 +7254,3 @@
-		current_val = iwe_stream_add_value(current_ev, current_val, end_buf, &iwe, IW_EV_PARAM_LEN);
+		current_val = iwe_stream_add_value(info, current_ev,
+						   current_val, end_buf,
+						   &iwe, IW_EV_PARAM_LEN);
@@ -7263 +7259 @@
-	if((current_val - current_ev) > IW_EV_LCP_LEN)
+	if ((current_val - current_ev) > iwe_stream_lcp_len(info))
@@ -7272 +7268,2 @@
-		current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, buf);
+		current_ev = iwe_stream_add_point(info, current_ev, end_buf,
+						  &iwe, buf);
@@ -7306,2 +7303,4 @@
-					current_ev = iwe_stream_add_point(current_ev, end_buf,
-							&iwe, (char *) info_element);
+					current_ev = iwe_stream_add_point(
+							info, current_ev,
+							end_buf, &iwe,
+							(char *) info_element);
@@ -7315,2 +7314,3 @@
-				current_ev = iwe_stream_add_point(current_ev, end_buf,
-						&iwe, (char *) info_element);
+				current_ev = iwe_stream_add_point(
+					info, current_ev, end_buf,
+					&iwe, (char *) info_element);
@@ -7355 +7355 @@
-		current_ev = airo_translate_scan(dev, current_ev,
+		current_ev = airo_translate_scan(dev, info, current_ev,
--- ./projects/linux/linux-2.6.27/drivers/net/wireless/airo.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/net/wireless/airo.c	2008-12-25 00:26:37.000000000 +0100
@@ -1918 +1918 @@
-		airo_print_err(dev->name, "%s: skb == NULL!",__FUNCTION__);
+		airo_print_err(dev->name, "%s: skb == NULL!",__func__);
@@ -1967 +1967 @@
-			__FUNCTION__);
+			__func__);
@@ -2118 +2118 @@
-		airo_print_err(dev->name, "%s: skb == NULL!", __FUNCTION__);
+		airo_print_err(dev->name, "%s: skb == NULL!", __func__);
@@ -2189 +2189 @@
-		airo_print_err(dev->name, "%s: skb == NULL!", __FUNCTION__);
+		airo_print_err(dev->name, "%s: skb == NULL!", __func__);
@@ -4130 +4130 @@
-				__FUNCTION__, rid);
+				__func__, rid);
@@ -4145 +4145 @@
-			airo_print_err(ai->dev->name, "%s: len=%d", __FUNCTION__, len);
+			airo_print_err(ai->dev->name, "%s: len=%d", __func__, len);
@@ -4154 +4154 @@
-						__FUNCTION__, rc);
+						__func__, rc);
@@ -4156 +4156 @@
-						__FUNCTION__, cmd.cmd);
+						__func__, cmd.cmd);
@@ -7110 +7110 @@
-			 struct iw_param *vwrq,
+			 struct iw_point *dwrq,
--- ./projects/linux/linux-2.6.28/drivers/net/wireless/airo.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/net/wireless/airo.c	2009-03-24 00:12:14.000000000 +0100
@@ -50 +49,0 @@
-#include <net/ieee80211.h>
@@ -53,0 +53,2 @@
+#include <linux/ieee80211.h>
+
@@ -1272,0 +1274 @@
+#define AIRO_FLASH(dev) (((struct airo_info *)dev->ml_priv)->flash)
@@ -1868 +1870 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -1915 +1917 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -1959 +1961 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -2088 +2090 @@
-	struct airo_info *priv = dev->priv;
+	struct airo_info *priv = dev->ml_priv;
@@ -2114 +2116 @@
-	struct airo_info *priv = dev->priv;
+	struct airo_info *priv = dev->ml_priv;
@@ -2153 +2155 @@
-	struct airo_info *priv = dev->priv;
+	struct airo_info *priv = dev->ml_priv;
@@ -2179 +2181 @@
-	struct airo_info *priv = dev->priv;
+	struct airo_info *priv = dev->ml_priv;
@@ -2223 +2225 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -2257 +2259 @@
-	struct airo_info *local =  dev->priv;
+	struct airo_info *local =  dev->ml_priv;
@@ -2284 +2286 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -2302 +2304 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -2342 +2344 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -2368 +2370 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -2668 +2670 @@
-	dev->priv = ethdev->priv;
+	dev->ml_priv = ethdev->ml_priv;
@@ -2683 +2685 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -2760 +2761,0 @@
-	DECLARE_MAC_BUF(mac);
@@ -2769 +2770 @@
-	ai = dev->priv;
+	ai = dev->ml_priv = netdev_priv(dev);
@@ -2863,2 +2864 @@
-	airo_print_info(dev->name, "MAC enabled %s",
-			print_mac(mac, dev->dev_addr));
+	airo_print_info(dev->name, "MAC enabled %pM", dev->dev_addr);
@@ -2871 +2871 @@
-	if (setup_proc_entry(dev, dev->priv) < 0)
+	if (setup_proc_entry(dev, dev->ml_priv) < 0)
@@ -2920,2 +2920 @@
-	struct airo_info *ai = dev->priv;
-	DECLARE_MAC_BUF(mac);
+	struct airo_info *ai = dev->ml_priv;
@@ -2930,2 +2929 @@
-	airo_print_info(dev->name, "MAC enabled %s",
-			print_mac(mac, dev->dev_addr));
+	airo_print_info(dev->name, "MAC enabled %pM", dev->dev_addr);
@@ -2945 +2943 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -3022 +3020 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -3137 +3135 @@
-	struct airo_info *apriv = dev->priv;
+	struct airo_info *apriv = dev->ml_priv;
@@ -3372 +3369,0 @@
-			skb->dev->last_rx = jiffies;
@@ -3602 +3598,0 @@
-		skb->dev->last_rx = jiffies;
@@ -3614 +3610 @@
-void mpi_receive_802_11 (struct airo_info *ai)
+static void mpi_receive_802_11(struct airo_info *ai)
@@ -3696 +3691,0 @@
-	skb->dev->last_rx = jiffies;
@@ -4607 +4602 @@
-	struct airo_info *apriv = dev->priv;
+	struct airo_info *apriv = dev->ml_priv;
@@ -4690 +4685 @@
-	struct airo_info *apriv = dev->priv;
+	struct airo_info *apriv = dev->ml_priv;
@@ -4753 +4748 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -4965 +4960 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -5056 +5051 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -5099 +5094 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -5194 +5189 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -5236 +5231 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -5285 +5280 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -5329 +5324 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -5333 +5327,0 @@
-	DECLARE_MAC_BUF(mac);
@@ -5357,2 +5351 @@
-		ptr += sprintf(ptr, "%s\n",
-			       print_mac(mac, APList_rid.ap[i]));
+		ptr += sprintf(ptr, "%pM\n", APList_rid.ap[i]);
@@ -5371 +5364 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -5377 +5369,0 @@
-	DECLARE_MAC_BUF(mac);
@@ -5414,2 +5406,2 @@
-		ptr += sprintf(ptr, "%s %*s rssi = %d",
-			       print_mac(mac, BSSList_rid.bssid),
+		ptr += sprintf(ptr, "%pM %*s rssi = %d",
+			       BSSList_rid.bssid,
@@ -5450 +5442 @@
-	struct airo_info *apriv = dev->priv;
+	struct airo_info *apriv = dev->ml_priv;
@@ -5521 +5513 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -5553 +5545 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -5732 +5724 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -5777 +5769 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -5808 +5800 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -5854 +5846 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -5882 +5874 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -5919 +5911 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -5940 +5932 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -5963 +5955 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -5982 +5974 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6052 +6044 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6074 +6066 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6098 +6090 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6117 +6109 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6142 +6134 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6161 +6153 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6224 +6216 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6261 +6253 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6348 +6340 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6396 +6388 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6482 +6474 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6545 +6537 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6613 +6605 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6662 +6654 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6699 +6691 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6719 +6711 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6757 +6749 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6788 +6780 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6913 +6905 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -6970 +6962 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -7001 +6993 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -7020 +7012 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -7040 +7032 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -7113 +7105 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -7159 +7151 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -7277,2 +7269 @@
-		struct ieee80211_info_element *info_element =
-			(struct ieee80211_info_element *) &bss->extra.iep;
+		u8 *ie = (void *)&bss->extra.iep;
@@ -7280,2 +7271,2 @@
-		while ((length >= sizeof(*info_element)) && (num_null_ies < 2)) {
-			if (sizeof(*info_element) + info_element->len > length) {
+		while ((length >= 2) && (num_null_ies < 2)) {
+			if (2 + ie[1] > length) {
@@ -7286,2 +7277,2 @@
-			switch (info_element->id) {
-			case MFIE_TYPE_SSID:
+			switch (ie[0]) {
+			case WLAN_EID_SSID:
@@ -7290 +7281 @@
-				if (!info_element->len)
+				if (!ie[1])
@@ -7294,6 +7285,6 @@
-			case MFIE_TYPE_GENERIC:
-				if (info_element->len >= 4 &&
-				    info_element->data[0] == 0x00 &&
-				    info_element->data[1] == 0x50 &&
-				    info_element->data[2] == 0xf2 &&
-				    info_element->data[3] == 0x01) {
+			case WLAN_EID_GENERIC:
+				if (ie[1] >= 4 &&
+				    ie[2] == 0x00 &&
+				    ie[3] == 0x50 &&
+				    ie[4] == 0xf2 &&
+				    ie[5] == 0x01) {
@@ -7301,2 +7292,3 @@
-					iwe.u.data.length = min(info_element->len + 2,
-								  MAX_WPA_IE_LEN);
+					/* 64 is an arbitrary cut-off */
+					iwe.u.data.length = min(ie[1] + 2,
+								64);
@@ -7305,2 +7297 @@
-							end_buf, &iwe,
-							(char *) info_element);
+							end_buf, &iwe, ie);
@@ -7310 +7301 @@
-			case MFIE_TYPE_RSN:
+			case WLAN_EID_RSN:
@@ -7312,2 +7303,2 @@
-				iwe.u.data.length = min(info_element->len + 2,
-							  MAX_WPA_IE_LEN);
+				/* 64 is an arbitrary cut-off */
+				iwe.u.data.length = min(ie[1] + 2, 64);
@@ -7316 +7307 @@
-					&iwe, (char *) info_element);
+					&iwe, ie);
@@ -7323,4 +7314,2 @@
-			length -= sizeof(*info_element) + info_element->len;
-			info_element =
-			    (struct ieee80211_info_element *)&info_element->
-			    data[info_element->len];
+			length -= 2 + ie[1];
+			ie += 2 + ie[1];
@@ -7341 +7330 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -7385 +7374 @@
-	struct airo_info *local = dev->priv;
+	struct airo_info *local = dev->ml_priv;
@@ -7530 +7519 @@
-	struct airo_info *ai = (struct airo_info *)dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -7658 +7647 @@
-	struct airo_info *local =  dev->priv;
+	struct airo_info *local =  dev->ml_priv;
@@ -7683 +7672 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -7749 +7738 @@
-	struct airo_info *ai = dev->priv;
+	struct airo_info *ai = dev->ml_priv;
@@ -7872 +7861 @@
-		return cmdreset((struct airo_info *)dev->priv);
+		return cmdreset((struct airo_info *)dev->ml_priv);
@@ -7875,2 +7864,2 @@
-		if (!((struct airo_info *)dev->priv)->flash &&
-			(((struct airo_info *)dev->priv)->flash = kmalloc (FLASHSIZE, GFP_KERNEL)) == NULL)
+		if (!AIRO_FLASH(dev) &&
+		    (AIRO_FLASH(dev) = kmalloc(FLASHSIZE, GFP_KERNEL)) == NULL)
@@ -7878 +7867 @@
-		return setflashmode((struct airo_info *)dev->priv);
+		return setflashmode((struct airo_info *)dev->ml_priv);
@@ -7885 +7874 @@
-		return flashgchar((struct airo_info *)dev->priv,z,8000);
+		return flashgchar((struct airo_info *)dev->ml_priv, z, 8000);
@@ -7892 +7881 @@
-		return flashpchar((struct airo_info *)dev->priv,z,8000);
+		return flashpchar((struct airo_info *)dev->ml_priv, z, 8000);
@@ -7895 +7884 @@
-		if (!((struct airo_info *)dev->priv)->flash)
+		if (!AIRO_FLASH(dev))
@@ -7899 +7888 @@
-		if(copy_from_user(((struct airo_info *)dev->priv)->flash,comp->data,comp->len))
+		if (copy_from_user(AIRO_FLASH(dev), comp->data, comp->len))
@@ -7902 +7891 @@
-		flashputbuf((struct airo_info *)dev->priv);
+		flashputbuf((struct airo_info *)dev->ml_priv);
@@ -7906 +7895 @@
-		if(flashrestart((struct airo_info *)dev->priv,dev))
+		if (flashrestart((struct airo_info *)dev->ml_priv, dev))
--- ./projects/linux/linux-2.6.29/drivers/net/wireless/airo.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/net/wireless/airo.c	2009-06-27 11:32:32.000000000 +0200
@@ -499,3 +498,0 @@
-/* This is redundant for x86 archs, but it seems necessary for ARM */
-#pragma pack(1)
-
@@ -504 +501,2 @@
-typedef struct {
+typedef struct WepKeyRid WepKeyRid;
+struct WepKeyRid {
@@ -510 +508 @@
-} WepKeyRid;
+} __attribute__ ((packed));
@@ -513 +511,2 @@
-typedef struct {
+typedef struct Ssid Ssid;
+struct Ssid {
@@ -516 +515 @@
-} Ssid;
+} __attribute__ ((packed));
@@ -518 +517,2 @@
-typedef struct {
+typedef struct SsidRid SsidRid;
+struct SsidRid {
@@ -521 +521 @@
-} SsidRid;
+} __attribute__ ((packed));
@@ -523 +523,2 @@
-typedef struct {
+typedef struct ModulationRid ModulationRid;
+struct ModulationRid {
@@ -529 +530 @@
-} ModulationRid;
+} __attribute__ ((packed));
@@ -531 +532,2 @@
-typedef struct {
+typedef struct ConfigRid ConfigRid;
+struct ConfigRid {
@@ -652 +654 @@
-} ConfigRid;
+} __attribute__ ((packed));
@@ -654 +656,2 @@
-typedef struct {
+typedef struct StatusRid StatusRid;
+struct StatusRid {
@@ -710 +713 @@
-} StatusRid;
+} __attribute__ ((packed));
@@ -712 +715,2 @@
-typedef struct {
+typedef struct StatsRid StatsRid;
+struct StatsRid {
@@ -716,2 +720 @@
-} StatsRid;
-
+} __attribute__ ((packed));
@@ -719 +722,2 @@
-typedef struct {
+typedef struct APListRid APListRid;
+struct APListRid {
@@ -722 +726 @@
-} APListRid;
+} __attribute__ ((packed));
@@ -724 +728,2 @@
-typedef struct {
+typedef struct CapabilityRid CapabilityRid;
+struct CapabilityRid {
@@ -751,2 +756 @@
-} CapabilityRid;
-
+} __attribute__ ((packed));
@@ -755 +759,2 @@
-typedef struct {
+typedef struct BSSListRidExtra BSSListRidExtra;
+struct BSSListRidExtra {
@@ -759 +764 @@
-} BSSListRidExtra;
+} __attribute__ ((packed));
@@ -761 +766,2 @@
-typedef struct {
+typedef struct BSSListRid BSSListRid;
+struct BSSListRid {
@@ -792 +798 @@
-} BSSListRid;
+} __attribute__ ((packed));
@@ -799 +805,2 @@
-typedef struct {
+typedef struct tdsRssiEntry tdsRssiEntry;
+struct tdsRssiEntry {
@@ -802 +809 @@
-} tdsRssiEntry;
+} __attribute__ ((packed));
@@ -804 +811,2 @@
-typedef struct {
+typedef struct tdsRssiRid tdsRssiRid;
+struct tdsRssiRid {
@@ -807 +815 @@
-} tdsRssiRid;
+} __attribute__ ((packed));
@@ -809,4 +817,5 @@
-typedef struct {
-	u16 len;
-	u16 state;
-	u16 multicastValid;
+typedef struct MICRid MICRid;
+struct MICRid {
+	__le16 len;
+	__le16 state;
+	__le16 multicastValid;
@@ -814 +823 @@
-	u16 unicastValid;
+	__le16 unicastValid;
@@ -816 +825 @@
-} MICRid;
+} __attribute__ ((packed));
@@ -818 +827,2 @@
-typedef struct {
+typedef struct MICBuffer MICBuffer;
+struct MICBuffer {
@@ -833 +843 @@
-} MICBuffer;
+} __attribute__ ((packed));
@@ -840,2 +849,0 @@
-#pragma pack()
-
@@ -983,0 +992,8 @@
+struct rx_hdr {
+	__le16 status, len;
+	u8 rssi[2];
+	u8 rate;
+	u8 freq;
+	__le16 tmp[4];
+} __attribute__ ((packed));
+
@@ -1073,4 +1088,0 @@
-// Frequency list (map channels to frequencies)
-static const long frequency_list[] = { 2412, 2417, 2422, 2427, 2432, 2437, 2442,
-				2447, 2452, 2457, 2462, 2467, 2472, 2484 };
-
@@ -1085,6 +1096,0 @@
-/* Backward compatibility */
-#ifndef IW_ENCODE_NOKEY
-#define IW_ENCODE_NOKEY         0x0800  /* Key is write only, so not present */
-#define IW_ENCODE_MODE  (IW_ENCODE_DISABLED | IW_ENCODE_RESTRICTED | IW_ENCODE_OPEN)
-#endif /* IW_ENCODE_NOKEY */
-
@@ -1158 +1164 @@
-	int                           fids[MAX_FIDS];
+	u32                           fids[MAX_FIDS];
@@ -1231,0 +1238,3 @@
+	int			wep_capable;
+	int			max_wep_idx;
+
@@ -1289,0 +1299,23 @@
+static void age_mic_context(miccntx *cur, miccntx *old, u8 *key, int key_len,
+			    struct crypto_cipher *tfm)
+{
+	/* If the current MIC context is valid and its key is the same as
+	 * the MIC register, there's nothing to do.
+	 */
+	if (cur->valid && (memcmp(cur->key, key, key_len) == 0))
+		return;
+
+	/* Age current mic Context */
+	memcpy(old, cur, sizeof(*cur));
+
+	/* Initialize new context */
+	memcpy(cur->key, key, key_len);
+	cur->window  = 33; /* Window always points to the middle */
+	cur->rx      = 0;  /* Rx Sequence numbers */
+	cur->tx      = 0;  /* Tx sequence numbers */
+	cur->valid   = 1;  /* Key is now valid */
+
+	/* Give key to mic seed */
+	emmh32_setseed(&cur->seed, key, key_len, tfm);
+}
+
@@ -1300,41 +1332,5 @@
-	ai->micstats.enabled = (mic_rid.state & 0x00FF) ? 1 : 0;
-
-	if (ai->micstats.enabled) {
-		/* Key must be valid and different */
-		if (mic_rid.multicastValid && (!ai->mod[0].mCtx.valid ||
-		    (memcmp (ai->mod[0].mCtx.key, mic_rid.multicast,
-			     sizeof(ai->mod[0].mCtx.key)) != 0))) {
-			/* Age current mic Context */
-			memcpy(&ai->mod[1].mCtx,&ai->mod[0].mCtx,sizeof(miccntx));
-			/* Initialize new context */
-			memcpy(&ai->mod[0].mCtx.key,mic_rid.multicast,sizeof(mic_rid.multicast));
-			ai->mod[0].mCtx.window  = 33; //Window always points to the middle
-			ai->mod[0].mCtx.rx      = 0;  //Rx Sequence numbers
-			ai->mod[0].mCtx.tx      = 0;  //Tx sequence numbers
-			ai->mod[0].mCtx.valid   = 1;  //Key is now valid
-  
-			/* Give key to mic seed */
-			emmh32_setseed(&ai->mod[0].mCtx.seed,mic_rid.multicast,sizeof(mic_rid.multicast), ai->tfm);
-		}
-
-		/* Key must be valid and different */
-		if (mic_rid.unicastValid && (!ai->mod[0].uCtx.valid || 
-		    (memcmp(ai->mod[0].uCtx.key, mic_rid.unicast,
-			    sizeof(ai->mod[0].uCtx.key)) != 0))) {
-			/* Age current mic Context */
-			memcpy(&ai->mod[1].uCtx,&ai->mod[0].uCtx,sizeof(miccntx));
-			/* Initialize new context */
-			memcpy(&ai->mod[0].uCtx.key,mic_rid.unicast,sizeof(mic_rid.unicast));
-	
-			ai->mod[0].uCtx.window  = 33; //Window always points to the middle
-			ai->mod[0].uCtx.rx      = 0;  //Rx Sequence numbers
-			ai->mod[0].uCtx.tx      = 0;  //Tx sequence numbers
-			ai->mod[0].uCtx.valid   = 1;  //Key is now valid
-	
-			//Give key to mic seed
-			emmh32_setseed(&ai->mod[0].uCtx.seed, mic_rid.unicast, sizeof(mic_rid.unicast), ai->tfm);
-		}
-	} else {
-      /* So next time we have a valid key and mic is enabled, we will update
-       * the sequence number if the key is the same as before.
-       */
+	ai->micstats.enabled = (le16_to_cpu(mic_rid.state) & 0x00FF) ? 1 : 0;
+	if (!ai->micstats.enabled) {
+		/* So next time we have a valid key and mic is enabled, we will
+		 * update the sequence number if the key is the same as before.
+		 */
@@ -1342,0 +1339,13 @@
+		return;
+	}
+
+	if (mic_rid.multicastValid) {
+		age_mic_context(&ai->mod[0].mCtx, &ai->mod[1].mCtx,
+		                mic_rid.multicast, sizeof(mic_rid.multicast),
+		                ai->tfm);
+	}
+
+	if (mic_rid.unicastValid) {
+		age_mic_context(&ai->mod[0].uCtx, &ai->mod[1].uCtx,
+				mic_rid.unicast, sizeof(mic_rid.unicast),
+				ai->tfm);
@@ -2639,0 +2649,10 @@
+static const struct net_device_ops airo11_netdev_ops = {
+	.ndo_open 		= airo_open,
+	.ndo_stop 		= airo_close,
+	.ndo_start_xmit 	= airo_start_xmit11,
+	.ndo_get_stats 		= airo_get_stats,
+	.ndo_set_mac_address	= airo_set_mac_address,
+	.ndo_do_ioctl		= airo_ioctl,
+	.ndo_change_mtu		= airo_change_mtu,
+};
+
@@ -2641,0 +2661 @@
+	dev->netdev_ops = &airo11_netdev_ops;
@@ -2643,4 +2662,0 @@
-	dev->hard_start_xmit = &airo_start_xmit11;
-	dev->get_stats = &airo_get_stats;
-	dev->set_mac_address = &airo_set_mac_address;
-	dev->do_ioctl = &airo_ioctl;
@@ -2648,3 +2663,0 @@
-	dev->change_mtu = &airo_change_mtu;
-	dev->open = &airo_open;
-	dev->stop = &airo_close;
@@ -2733,7 +2746,11 @@
-static int airo_test_wpa_capable(struct airo_info *ai)
-{
-	int status;
-	CapabilityRid cap_rid;
-
-	status = readCapabilityRid(ai, &cap_rid, 1);
-	if (status != SUCCESS) return 0;
+static const struct net_device_ops airo_netdev_ops = {
+	.ndo_open		= airo_open,
+	.ndo_stop		= airo_close,
+	.ndo_start_xmit		= airo_start_xmit,
+	.ndo_get_stats		= airo_get_stats,
+	.ndo_set_multicast_list	= airo_set_multicast_list,
+	.ndo_set_mac_address	= airo_set_mac_address,
+	.ndo_do_ioctl		= airo_ioctl,
+	.ndo_change_mtu		= airo_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+};
@@ -2741,7 +2758,11 @@
-	/* Only firmware versions 5.30.17 or better can do WPA */
-	if (le16_to_cpu(cap_rid.softVer) > 0x530
-	  || (le16_to_cpu(cap_rid.softVer) == 0x530
-	      && le16_to_cpu(cap_rid.softSubVer) >= 17)) {
-		airo_print_info("", "WPA is supported.");
-		return 1;
-	}
+static const struct net_device_ops mpi_netdev_ops = {
+	.ndo_open		= airo_open,
+	.ndo_stop		= airo_close,
+	.ndo_start_xmit		= mpi_start_xmit,
+	.ndo_get_stats		= airo_get_stats,
+	.ndo_set_multicast_list	= airo_set_multicast_list,
+	.ndo_set_mac_address	= airo_set_mac_address,
+	.ndo_do_ioctl		= airo_ioctl,
+	.ndo_change_mtu		= airo_change_mtu,
+	.ndo_validate_addr	= eth_validate_addr,
+};
@@ -2749,5 +2769,0 @@
-	/* No WPA support */
-	airo_print_info("", "WPA unsupported (only firmware versions 5.30.17"
-		" and greater support WPA.  Detected %s)", cap_rid.prodVer);
-	return 0;
-}
@@ -2761,0 +2778 @@
+	CapabilityRid cap_rid;
@@ -2790,0 +2808,2 @@
+	skb_queue_head_init (&ai->txq);
+
@@ -2792,9 +2811,4 @@
-	if (test_bit(FLAG_MPI,&ai->flags)) {
-		skb_queue_head_init (&ai->txq);
-		dev->hard_start_xmit = &mpi_start_xmit;
-	} else
-		dev->hard_start_xmit = &airo_start_xmit;
-	dev->get_stats = &airo_get_stats;
-	dev->set_multicast_list = &airo_set_multicast_list;
-	dev->set_mac_address = &airo_set_mac_address;
-	dev->do_ioctl = &airo_ioctl;
+	if (test_bit(FLAG_MPI,&ai->flags))
+		dev->netdev_ops = &mpi_netdev_ops;
+	else
+		dev->netdev_ops = &airo_netdev_ops;
@@ -2804,3 +2817,0 @@
-	dev->change_mtu = &airo_change_mtu;
-	dev->open = &airo_open;
-	dev->stop = &airo_close;
@@ -2831 +2842 @@
-		if ( setup_card( ai, dev->dev_addr, 1 ) != SUCCESS ) {
+		if (setup_card(ai, dev->dev_addr, 1) != SUCCESS) {
@@ -2840,0 +2852,24 @@
+	strcpy(dev->name, "eth%d");
+	rc = register_netdev(dev);
+	if (rc) {
+		airo_print_err(dev->name, "Couldn't register_netdev");
+		goto err_out_map;
+	}
+	ai->wifidev = init_wifidev(ai, dev);
+	if (!ai->wifidev)
+		goto err_out_reg;
+
+	rc = readCapabilityRid(ai, &cap_rid, 1);
+	if (rc != SUCCESS) {
+		rc = -EIO;
+		goto err_out_wifi;
+	}
+	/* WEP capability discovery */
+	ai->wep_capable = (cap_rid.softCap & cpu_to_le16(0x02)) ? 1 : 0;
+	ai->max_wep_idx = (cap_rid.softCap & cpu_to_le16(0x80)) ? 3 : 0;
+
+	airo_print_info(dev->name, "Firmware version %x.%x.%02x",
+	                ((le16_to_cpu(cap_rid.softVer) >> 8) & 0xF),
+	                (le16_to_cpu(cap_rid.softVer) & 0xFF),
+	                le16_to_cpu(cap_rid.softSubVer));
+
@@ -2842 +2877,6 @@
-	if (airo_test_wpa_capable(ai)) {
+	/* Only firmware versions 5.30.17 or better can do WPA */
+	if (le16_to_cpu(cap_rid.softVer) > 0x530
+	 || (le16_to_cpu(cap_rid.softVer) == 0x530
+	      && le16_to_cpu(cap_rid.softSubVer) >= 17)) {
+		airo_print_info(ai->dev->name, "WPA supported.");
+
@@ -2847,0 +2888,3 @@
+		airo_print_info(ai->dev->name, "WPA unsupported with firmware "
+			"versions older than 5.30.17.");
+
@@ -2853,10 +2895,0 @@
-	strcpy(dev->name, "eth%d");
-	rc = register_netdev(dev);
-	if (rc) {
-		airo_print_err(dev->name, "Couldn't register_netdev");
-		goto err_out_map;
-	}
-	ai->wifidev = init_wifidev(ai, dev);
-	if (!ai->wifidev)
-		goto err_out_reg;
-
@@ -3130 +3163 @@
-static irqreturn_t airo_interrupt(int irq, void *dev_id)
+static void airo_handle_cisco_mic(struct airo_info *ai)
@@ -3132,6 +3165,5 @@
-	struct net_device *dev = dev_id;
-	u16 status;
-	u16 fid;
-	struct airo_info *apriv = dev->ml_priv;
-	u16 savedInterrupts = 0;
-	int handled = 0;
+	if (test_bit(FLAG_MIC_CAPABLE, &ai->flags)) {
+		set_bit(JOB_MIC, &ai->jobs);
+		wake_up_interruptible(&ai->thr_wait);
+	}
+}
@@ -3139,2 +3171,49 @@
-	if (!netif_device_present(dev))
-		return IRQ_NONE;
+/* Airo Status codes */
+#define STAT_NOBEACON	0x8000 /* Loss of sync - missed beacons */
+#define STAT_MAXRETRIES	0x8001 /* Loss of sync - max retries */
+#define STAT_MAXARL	0x8002 /* Loss of sync - average retry level exceeded*/
+#define STAT_FORCELOSS	0x8003 /* Loss of sync - host request */
+#define STAT_TSFSYNC	0x8004 /* Loss of sync - TSF synchronization */
+#define STAT_DEAUTH	0x8100 /* low byte is 802.11 reason code */
+#define STAT_DISASSOC	0x8200 /* low byte is 802.11 reason code */
+#define STAT_ASSOC_FAIL	0x8400 /* low byte is 802.11 reason code */
+#define STAT_AUTH_FAIL	0x0300 /* low byte is 802.11 reason code */
+#define STAT_ASSOC	0x0400 /* Associated */
+#define STAT_REASSOC    0x0600 /* Reassociated?  Only on firmware >= 5.30.17 */
+
+static void airo_print_status(const char *devname, u16 status)
+{
+	u8 reason = status & 0xFF;
+
+	switch (status) {
+	case STAT_NOBEACON:
+		airo_print_dbg(devname, "link lost (missed beacons)");
+		break;
+	case STAT_MAXRETRIES:
+	case STAT_MAXARL:
+		airo_print_dbg(devname, "link lost (max retries)");
+		break;
+	case STAT_FORCELOSS:
+		airo_print_dbg(devname, "link lost (local choice)");
+		break;
+	case STAT_TSFSYNC:
+		airo_print_dbg(devname, "link lost (TSF sync lost)");
+		break;
+	case STAT_DEAUTH:
+		airo_print_dbg(devname, "deauthenticated (reason: %d)", reason);
+		break;
+	case STAT_DISASSOC:
+		airo_print_dbg(devname, "disassociated (reason: %d)", reason);
+		break;
+	case STAT_ASSOC_FAIL:
+		airo_print_dbg(devname, "association failed (reason: %d)",
+			       reason);
+		break;
+	case STAT_AUTH_FAIL:
+		airo_print_dbg(devname, "authentication failed (reason: %d)",
+			       reason);
+		break;
+	default:
+		break;
+	}
+}
@@ -3142,3 +3221,5 @@
-	for (;;) {
-		status = IN4500( apriv, EVSTAT );
-		if ( !(status & STATUS_INTS) || status == 0xffff ) break;
+static void airo_handle_link(struct airo_info *ai)
+{
+	union iwreq_data wrqu;
+	int scan_forceloss = 0;
+	u16 status;
@@ -3146 +3227,16 @@
-		handled = 1;
+	/* Get new status and acknowledge the link change */
+	status = le16_to_cpu(IN4500(ai, LINKSTAT));
+	OUT4500(ai, EVACK, EV_LINK);
+
+	if ((status == STAT_FORCELOSS) && (ai->scan_timeout > 0))
+		scan_forceloss = 1;
+
+	airo_print_status(ai->dev->name, status);
+
+	if ((status == STAT_ASSOC) || (status == STAT_REASSOC)) {
+		if (auto_wep)
+			ai->expires = 0;
+		if (ai->list_bss_task)
+			wake_up_process(ai->list_bss_task);
+		set_bit(FLAG_UPDATE_UNI, &ai->flags);
+		set_bit(FLAG_UPDATE_MULTI, &ai->flags);
@@ -3148,3 +3244,9 @@
-		if ( status & EV_AWAKE ) {
-			OUT4500( apriv, EVACK, EV_AWAKE );
-			OUT4500( apriv, EVACK, EV_AWAKE );
+		if (down_trylock(&ai->sem) != 0) {
+			set_bit(JOB_EVENT, &ai->jobs);
+			wake_up_interruptible(&ai->thr_wait);
+		} else
+			airo_send_event(ai->dev);
+	} else if (!scan_forceloss) {
+		if (auto_wep && !ai->expires) {
+			ai->expires = RUN_AT(3*HZ);
+			wake_up_interruptible(&ai->thr_wait);
@@ -3153,4 +3255,6 @@
-		if (!savedInterrupts) {
-			savedInterrupts = IN4500( apriv, EVINTEN );
-			OUT4500( apriv, EVINTEN, 0 );
-		}
+		/* Send event to user space */
+		memset(wrqu.ap_addr.sa_data, '\0', ETH_ALEN);
+		wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+		wireless_send_event(ai->dev, SIOCGIWAP, &wrqu, NULL);
+	}
+}
@@ -3158,66 +3262,7 @@
-		if ( status & EV_MIC ) {
-			OUT4500( apriv, EVACK, EV_MIC );
-			if (test_bit(FLAG_MIC_CAPABLE, &apriv->flags)) {
-				set_bit(JOB_MIC, &apriv->jobs);
-				wake_up_interruptible(&apriv->thr_wait);
-			}
-		}
-		if ( status & EV_LINK ) {
-			union iwreq_data	wrqu;
-			int scan_forceloss = 0;
-			/* The link status has changed, if you want to put a
-			   monitor hook in, do it here.  (Remember that
-			   interrupts are still disabled!)
-			*/
-			u16 newStatus = IN4500(apriv, LINKSTAT);
-			OUT4500( apriv, EVACK, EV_LINK);
-			/* Here is what newStatus means: */
-#define NOBEACON 0x8000 /* Loss of sync - missed beacons */
-#define MAXRETRIES 0x8001 /* Loss of sync - max retries */
-#define MAXARL 0x8002 /* Loss of sync - average retry level exceeded*/
-#define FORCELOSS 0x8003 /* Loss of sync - host request */
-#define TSFSYNC 0x8004 /* Loss of sync - TSF synchronization */
-#define DEAUTH 0x8100 /* Deauthentication (low byte is reason code) */
-#define DISASS 0x8200 /* Disassociation (low byte is reason code) */
-#define ASSFAIL 0x8400 /* Association failure (low byte is reason
-			  code) */
-#define AUTHFAIL 0x0300 /* Authentication failure (low byte is reason
-			   code) */
-#define ASSOCIATED 0x0400 /* Associated */
-#define REASSOCIATED 0x0600 /* Reassociated?  Only on firmware >= 5.30.17 */
-#define RC_RESERVED 0 /* Reserved return code */
-#define RC_NOREASON 1 /* Unspecified reason */
-#define RC_AUTHINV 2 /* Previous authentication invalid */
-#define RC_DEAUTH 3 /* Deauthenticated because sending station is
-		       leaving */
-#define RC_NOACT 4 /* Disassociated due to inactivity */
-#define RC_MAXLOAD 5 /* Disassociated because AP is unable to handle
-			all currently associated stations */
-#define RC_BADCLASS2 6 /* Class 2 frame received from
-			  non-Authenticated station */
-#define RC_BADCLASS3 7 /* Class 3 frame received from
-			  non-Associated station */
-#define RC_STATLEAVE 8 /* Disassociated because sending station is
-			  leaving BSS */
-#define RC_NOAUTH 9 /* Station requesting (Re)Association is not
-		       Authenticated with the responding station */
-			if (newStatus == FORCELOSS && apriv->scan_timeout > 0)
-				scan_forceloss = 1;
-			if(newStatus == ASSOCIATED || newStatus == REASSOCIATED) {
-				if (auto_wep)
-					apriv->expires = 0;
-				if (apriv->list_bss_task)
-					wake_up_process(apriv->list_bss_task);
-				set_bit(FLAG_UPDATE_UNI, &apriv->flags);
-				set_bit(FLAG_UPDATE_MULTI, &apriv->flags);
-
-				if (down_trylock(&apriv->sem) != 0) {
-					set_bit(JOB_EVENT, &apriv->jobs);
-					wake_up_interruptible(&apriv->thr_wait);
-				} else
-					airo_send_event(dev);
-			} else if (!scan_forceloss) {
-				if (auto_wep && !apriv->expires) {
-					apriv->expires = RUN_AT(3*HZ);
-					wake_up_interruptible(&apriv->thr_wait);
-				}
+static void airo_handle_rx(struct airo_info *ai)
+{
+	struct sk_buff *skb = NULL;
+	__le16 fc, v, *buffer, tmpbuf[4];
+	u16 len, hdrlen = 0, gap, fid;
+	struct rx_hdr hdr;
+	int success = 0;
@@ -3225,6 +3270,8 @@
-				/* Send event to user space */
-				memset(wrqu.ap_addr.sa_data, '\0', ETH_ALEN);
-				wrqu.ap_addr.sa_family = ARPHRD_ETHER;
-				wireless_send_event(dev, SIOCGIWAP, &wrqu,NULL);
-			}
-		}
+	if (test_bit(FLAG_MPI, &ai->flags)) {
+		if (test_bit(FLAG_802_11, &ai->flags))
+			mpi_receive_802_11(ai);
+		else
+			mpi_receive_802_3(ai);
+		OUT4500(ai, EVACK, EV_RX);
+		return;
+	}
@@ -3232,26 +3279 @@
-		/* Check to see if there is something to receive */
-		if ( status & EV_RX  ) {
-			struct sk_buff *skb = NULL;
-			__le16 fc, v;
-			u16 len, hdrlen = 0;
-#pragma pack(1)
-			struct {
-				__le16 status, len;
-				u8 rssi[2];
-				u8 rate;
-				u8 freq;
-				__le16 tmp[4];
-			} hdr;
-#pragma pack()
-			u16 gap;
-			__le16 tmpbuf[4];
-			__le16 *buffer;
-
-			if (test_bit(FLAG_MPI,&apriv->flags)) {
-				if (test_bit(FLAG_802_11, &apriv->flags))
-					mpi_receive_802_11(apriv);
-				else
-					mpi_receive_802_3(apriv);
-				OUT4500(apriv, EVACK, EV_RX);
-				goto exitrx;
-			}
+	fid = IN4500(ai, RXFID);
@@ -3259 +3281,14 @@
-			fid = IN4500( apriv, RXFID );
+	/* Get the packet length */
+	if (test_bit(FLAG_802_11, &ai->flags)) {
+		bap_setup (ai, fid, 4, BAP0);
+		bap_read (ai, (__le16*)&hdr, sizeof(hdr), BAP0);
+		/* Bad CRC. Ignore packet */
+		if (le16_to_cpu(hdr.status) & 2)
+			hdr.len = 0;
+		if (ai->wifidev == NULL)
+			hdr.len = 0;
+	} else {
+		bap_setup(ai, fid, 0x36, BAP0);
+		bap_read(ai, &hdr.len, 2, BAP0);
+	}
+	len = le16_to_cpu(hdr.len);
@@ -3261,14 +3296,6 @@
-			/* Get the packet length */
-			if (test_bit(FLAG_802_11, &apriv->flags)) {
-				bap_setup (apriv, fid, 4, BAP0);
-				bap_read (apriv, (__le16*)&hdr, sizeof(hdr), BAP0);
-				/* Bad CRC. Ignore packet */
-				if (le16_to_cpu(hdr.status) & 2)
-					hdr.len = 0;
-				if (apriv->wifidev == NULL)
-					hdr.len = 0;
-			} else {
-				bap_setup (apriv, fid, 0x36, BAP0);
-				bap_read (apriv, &hdr.len, 2, BAP0);
-			}
-			len = le16_to_cpu(hdr.len);
+	if (len > AIRO_DEF_MTU) {
+		airo_print_err(ai->dev->name, "Bad size %d", len);
+		goto done;
+	}
+	if (len == 0)
+		goto done;
@@ -3276,6 +3303,5 @@
-			if (len > AIRO_DEF_MTU) {
-				airo_print_err(apriv->dev->name, "Bad size %d", len);
-				goto badrx;
-			}
-			if (len == 0)
-				goto badrx;
+	if (test_bit(FLAG_802_11, &ai->flags)) {
+		bap_read(ai, &fc, sizeof (fc), BAP0);
+		hdrlen = header_len(fc);
+	} else
+		hdrlen = ETH_ALEN * 2;
@@ -3283,5 +3309,5 @@
-			if (test_bit(FLAG_802_11, &apriv->flags)) {
-				bap_read (apriv, &fc, sizeof(fc), BAP0);
-				hdrlen = header_len(fc);
-			} else
-				hdrlen = ETH_ALEN * 2;
+	skb = dev_alloc_skb(len + hdrlen + 2 + 2);
+	if (!skb) {
+		ai->dev->stats.rx_dropped++;
+		goto done;
+	}
@@ -3289,24 +3315,13 @@
-			skb = dev_alloc_skb( len + hdrlen + 2 + 2 );
-			if ( !skb ) {
-				dev->stats.rx_dropped++;
-				goto badrx;
-			}
-			skb_reserve(skb, 2); /* This way the IP header is aligned */
-			buffer = (__le16*)skb_put (skb, len + hdrlen);
-			if (test_bit(FLAG_802_11, &apriv->flags)) {
-				buffer[0] = fc;
-				bap_read (apriv, buffer + 1, hdrlen - 2, BAP0);
-				if (hdrlen == 24)
-					bap_read (apriv, tmpbuf, 6, BAP0);
-
-				bap_read (apriv, &v, sizeof(v), BAP0);
-				gap = le16_to_cpu(v);
-				if (gap) {
-					if (gap <= 8) {
-						bap_read (apriv, tmpbuf, gap, BAP0);
-					} else {
-						airo_print_err(apriv->dev->name, "gaplen too "
-							"big. Problems will follow...");
-					}
-				}
-				bap_read (apriv, buffer + hdrlen/2, len, BAP0);
+	skb_reserve(skb, 2); /* This way the IP header is aligned */
+	buffer = (__le16 *) skb_put(skb, len + hdrlen);
+	if (test_bit(FLAG_802_11, &ai->flags)) {
+		buffer[0] = fc;
+		bap_read(ai, buffer + 1, hdrlen - 2, BAP0);
+		if (hdrlen == 24)
+			bap_read(ai, tmpbuf, 6, BAP0);
+
+		bap_read(ai, &v, sizeof(v), BAP0);
+		gap = le16_to_cpu(v);
+		if (gap) {
+			if (gap <= 8) {
+				bap_read(ai, tmpbuf, gap, BAP0);
@@ -3314,9 +3329,7 @@
-				MICBuffer micbuf;
-				bap_read (apriv, buffer, ETH_ALEN*2, BAP0);
-				if (apriv->micstats.enabled) {
-					bap_read (apriv,(__le16*)&micbuf,sizeof(micbuf),BAP0);
-					if (ntohs(micbuf.typelen) > 0x05DC)
-						bap_setup (apriv, fid, 0x44, BAP0);
-					else {
-						if (len <= sizeof(micbuf))
-							goto badmic;
+				airo_print_err(ai->dev->name, "gaplen too "
+					"big. Problems will follow...");
+			}
+		}
+		bap_read(ai, buffer + hdrlen/2, len, BAP0);
+	} else {
+		MICBuffer micbuf;
@@ -3324,11 +3337,9 @@
-						len -= sizeof(micbuf);
-						skb_trim (skb, len + hdrlen);
-					}
-				}
-				bap_read(apriv,buffer+ETH_ALEN,len,BAP0);
-				if (decapsulate(apriv,&micbuf,(etherHead*)buffer,len)) {
-badmic:
-					dev_kfree_skb_irq (skb);
-badrx:
-					OUT4500( apriv, EVACK, EV_RX);
-					goto exitrx;
+		bap_read(ai, buffer, ETH_ALEN * 2, BAP0);
+		if (ai->micstats.enabled) {
+			bap_read(ai, (__le16 *) &micbuf, sizeof (micbuf), BAP0);
+			if (ntohs(micbuf.typelen) > 0x05DC)
+				bap_setup(ai, fid, 0x44, BAP0);
+			else {
+				if (len <= sizeof (micbuf)) {
+					dev_kfree_skb_irq(skb);
+					goto done;
@@ -3335,0 +3347,3 @@
+
+				len -= sizeof(micbuf);
+				skb_trim(skb, len + hdrlen);
@@ -3336,0 +3351,9 @@
+		}
+
+		bap_read(ai, buffer + ETH_ALEN, len, BAP0);
+		if (decapsulate(ai, &micbuf, (etherHead*) buffer, len))
+			dev_kfree_skb_irq (skb);
+		else
+			success = 1;
+	}
+
@@ -3338,22 +3361,23 @@
-			if (apriv->spy_data.spy_number > 0) {
-				char *sa;
-				struct iw_quality wstats;
-				/* Prepare spy data : addr + qual */
-				if (!test_bit(FLAG_802_11, &apriv->flags)) {
-					sa = (char*)buffer + 6;
-					bap_setup (apriv, fid, 8, BAP0);
-					bap_read (apriv, (__le16*)hdr.rssi, 2, BAP0);
-				} else
-					sa = (char*)buffer + 10;
-				wstats.qual = hdr.rssi[0];
-				if (apriv->rssi)
-					wstats.level = 0x100 - apriv->rssi[hdr.rssi[1]].rssidBm;
-				else
-					wstats.level = (hdr.rssi[1] + 321) / 2;
-				wstats.noise = apriv->wstats.qual.noise;
-				wstats.updated = IW_QUAL_LEVEL_UPDATED
-					| IW_QUAL_QUAL_UPDATED
-					| IW_QUAL_DBM;
-				/* Update spy records */
-				wireless_spy_update(dev, sa, &wstats);
-			}
+	if (success && (ai->spy_data.spy_number > 0)) {
+		char *sa;
+		struct iw_quality wstats;
+
+		/* Prepare spy data : addr + qual */
+		if (!test_bit(FLAG_802_11, &ai->flags)) {
+			sa = (char *) buffer + 6;
+			bap_setup(ai, fid, 8, BAP0);
+			bap_read(ai, (__le16 *) hdr.rssi, 2, BAP0);
+		} else
+			sa = (char *) buffer + 10;
+		wstats.qual = hdr.rssi[0];
+		if (ai->rssi)
+			wstats.level = 0x100 - ai->rssi[hdr.rssi[1]].rssidBm;
+		else
+			wstats.level = (hdr.rssi[1] + 321) / 2;
+		wstats.noise = ai->wstats.qual.noise;
+		wstats.updated =  IW_QUAL_LEVEL_UPDATED
+				| IW_QUAL_QUAL_UPDATED
+				| IW_QUAL_DBM;
+		/* Update spy records */
+		wireless_spy_update(ai->dev, sa, &wstats);
+	}
@@ -3361 +3384,0 @@
-			OUT4500( apriv, EVACK, EV_RX);
@@ -3363,8 +3386,12 @@
-			if (test_bit(FLAG_802_11, &apriv->flags)) {
-				skb_reset_mac_header(skb);
-				skb->pkt_type = PACKET_OTHERHOST;
-				skb->dev = apriv->wifidev;
-				skb->protocol = htons(ETH_P_802_2);
-			} else
-				skb->protocol = eth_type_trans(skb,dev);
-			skb->ip_summed = CHECKSUM_NONE;
+done:
+	OUT4500(ai, EVACK, EV_RX);
+
+	if (success) {
+		if (test_bit(FLAG_802_11, &ai->flags)) {
+			skb_reset_mac_header(skb);
+			skb->pkt_type = PACKET_OTHERHOST;
+			skb->dev = ai->wifidev;
+			skb->protocol = htons(ETH_P_802_2);
+		} else
+			skb->protocol = eth_type_trans(skb, ai->dev);
+		skb->ip_summed = CHECKSUM_NONE;
@@ -3372 +3399,23 @@
-			netif_rx( skb );
+		netif_rx(skb);
+	}
+}
+
+static void airo_handle_tx(struct airo_info *ai, u16 status)
+{
+	int i, len = 0, index = -1;
+	u16 fid;
+
+	if (test_bit(FLAG_MPI, &ai->flags)) {
+		unsigned long flags;
+
+		if (status & EV_TXEXC)
+			get_tx_error(ai, -1);
+
+		spin_lock_irqsave(&ai->aux_lock, flags);
+		if (!skb_queue_empty(&ai->txq)) {
+			spin_unlock_irqrestore(&ai->aux_lock,flags);
+			mpi_send_packet(ai->dev);
+		} else {
+			clear_bit(FLAG_PENDING_XMIT, &ai->flags);
+			spin_unlock_irqrestore(&ai->aux_lock,flags);
+			netif_wake_queue(ai->dev);
@@ -3374 +3423,3 @@
-exitrx:
+		OUT4500(ai, EVACK, status & (EV_TX | EV_TXCPY | EV_TXEXC));
+		return;
+	}
@@ -3376,24 +3427 @@
-		/* Check to see if a packet has been transmitted */
-		if (  status & ( EV_TX|EV_TXCPY|EV_TXEXC ) ) {
-			int i;
-			int len = 0;
-			int index = -1;
-
-			if (test_bit(FLAG_MPI,&apriv->flags)) {
-				unsigned long flags;
-
-				if (status & EV_TXEXC)
-					get_tx_error(apriv, -1);
-				spin_lock_irqsave(&apriv->aux_lock, flags);
-				if (!skb_queue_empty(&apriv->txq)) {
-					spin_unlock_irqrestore(&apriv->aux_lock,flags);
-					mpi_send_packet (dev);
-				} else {
-					clear_bit(FLAG_PENDING_XMIT, &apriv->flags);
-					spin_unlock_irqrestore(&apriv->aux_lock,flags);
-					netif_wake_queue (dev);
-				}
-				OUT4500( apriv, EVACK,
-					status & (EV_TX|EV_TXCPY|EV_TXEXC));
-				goto exittx;
-			}
+	fid = IN4500(ai, TXCOMPLFID);
@@ -3401 +3429,6 @@
-			fid = IN4500(apriv, TXCOMPLFID);
+	for(i = 0; i < MAX_FIDS; i++) {
+		if ((ai->fids[i] & 0xffff) == fid) {
+			len = ai->fids[i] >> 16;
+			index = i;
+		}
+	}
@@ -3403,24 +3436,14 @@
-			for( i = 0; i < MAX_FIDS; i++ ) {
-				if ( ( apriv->fids[i] & 0xffff ) == fid ) {
-					len = apriv->fids[i] >> 16;
-					index = i;
-				}
-			}
-			if (index != -1) {
-				if (status & EV_TXEXC)
-					get_tx_error(apriv, index);
-				OUT4500( apriv, EVACK, status & (EV_TX | EV_TXEXC));
-				/* Set up to be used again */
-				apriv->fids[index] &= 0xffff;
-				if (index < MAX_FIDS / 2) {
-					if (!test_bit(FLAG_PENDING_XMIT, &apriv->flags))
-						netif_wake_queue(dev);
-				} else {
-					if (!test_bit(FLAG_PENDING_XMIT11, &apriv->flags))
-						netif_wake_queue(apriv->wifidev);
-				}
-			} else {
-				OUT4500( apriv, EVACK, status & (EV_TX | EV_TXCPY | EV_TXEXC));
-				airo_print_err(apriv->dev->name, "Unallocated FID was "
-					"used to xmit" );
-			}
+	if (index != -1) {
+		if (status & EV_TXEXC)
+			get_tx_error(ai, index);
+
+		OUT4500(ai, EVACK, status & (EV_TX | EV_TXEXC));
+
+		/* Set up to be used again */
+		ai->fids[index] &= 0xffff;
+		if (index < MAX_FIDS / 2) {
+			if (!test_bit(FLAG_PENDING_XMIT, &ai->flags))
+				netif_wake_queue(ai->dev);
+		} else {
+			if (!test_bit(FLAG_PENDING_XMIT11, &ai->flags))
+				netif_wake_queue(ai->wifidev);
@@ -3428,3 +3451,53 @@
-exittx:
-		if ( status & ~STATUS_INTS & ~IGNORE_INTS )
-			airo_print_warn(apriv->dev->name, "Got weird status %x",
+	} else {
+		OUT4500(ai, EVACK, status & (EV_TX | EV_TXCPY | EV_TXEXC));
+		airo_print_err(ai->dev->name, "Unallocated FID was used to xmit");
+	}
+}
+
+static irqreturn_t airo_interrupt(int irq, void *dev_id)
+{
+	struct net_device *dev = dev_id;
+	u16 status, savedInterrupts = 0;
+	struct airo_info *ai = dev->ml_priv;
+	int handled = 0;
+
+	if (!netif_device_present(dev))
+		return IRQ_NONE;
+
+	for (;;) {
+		status = IN4500(ai, EVSTAT);
+		if (!(status & STATUS_INTS) || (status == 0xffff))
+			break;
+
+		handled = 1;
+
+		if (status & EV_AWAKE) {
+			OUT4500(ai, EVACK, EV_AWAKE);
+			OUT4500(ai, EVACK, EV_AWAKE);
+		}
+
+		if (!savedInterrupts) {
+			savedInterrupts = IN4500(ai, EVINTEN);
+			OUT4500(ai, EVINTEN, 0);
+		}
+
+		if (status & EV_MIC) {
+			OUT4500(ai, EVACK, EV_MIC);
+			airo_handle_cisco_mic(ai);
+		}
+
+		if (status & EV_LINK) {
+			/* Link status changed */
+			airo_handle_link(ai);
+		}
+
+		/* Check to see if there is something to receive */
+		if (status & EV_RX)
+			airo_handle_rx(ai);
+
+		/* Check to see if a packet has been transmitted */
+		if (status & (EV_TX | EV_TXCPY | EV_TXEXC))
+			airo_handle_tx(ai, status);
+
+		if ( status & ~STATUS_INTS & ~IGNORE_INTS ) {
+			airo_print_warn(ai->dev->name, "Got weird status %x",
@@ -3431,0 +3505 @@
+		}
@@ -3435 +3509 @@
-		OUT4500( apriv, EVINTEN, savedInterrupts );
+		OUT4500(ai, EVINTEN, savedInterrupts);
@@ -3437 +3510,0 @@
-	/* done.. */
@@ -3616,9 +3689 @@
-#pragma pack(1)
-	struct {
-		__le16 status, len;
-		u8 rssi[2];
-		u8 rate;
-		u8 freq;
-		__le16 tmp[4];
-	} hdr;
-#pragma pack()
+	struct rx_hdr hdr;
@@ -3627 +3692 @@
-	char *ptr = ai->rxfids[0].virtual_host_addr+4;
+	char *ptr = ai->rxfids[0].virtual_host_addr + 4;
@@ -3693,0 +3759 @@
+
@@ -3708 +3773,0 @@
-	int i;
@@ -3749,0 +3815 @@
+		int i;
@@ -3797 +3862,0 @@
-			int i = 0;
@@ -3804 +3868,0 @@
-			int i;
@@ -4431 +4494,0 @@
-	apriv->proc_entry->owner = THIS_MODULE;
@@ -4689 +4752 @@
-	int len = le16_to_cpu(stats.len);
+	int len;
@@ -4699,0 +4763 @@
+	len = le16_to_cpu(stats.len);
@@ -5134,3 +5198,2 @@
-/* Returns the length of the key at the index.  If index == 0xffff
- * the index of the transmit key is returned.  If the key doesn't exist,
- * -1 will be returned.
+/* Returns the WEP key at the specified index, or -1 if that key does
+ * not exist.  The buffer is assumed to be at least 16 bytes in length.
@@ -5138 +5201,2 @@
-static int get_wep_key(struct airo_info *ai, u16 index) {
+static int get_wep_key(struct airo_info *ai, u16 index, char *buf, u16 buflen)
+{
@@ -5144 +5208,3 @@
-	if (rc == SUCCESS) do {
+	if (rc != SUCCESS)
+		return -1;
+	do {
@@ -5146,7 +5212,8 @@
-		if (wkr.kindex == cpu_to_le16(index)) {
-			if (index == 0xffff) {
-				return wkr.mac[0];
-			}
-			return le16_to_cpu(wkr.klen);
-		}
-		readWepKeyRid(ai, &wkr, 0, 1);
+		if (le16_to_cpu(wkr.kindex) == index) {
+			int klen = min_t(int, buflen, le16_to_cpu(wkr.klen));
+			memcpy(buf, wkr.key, klen);
+			return klen;
+		}
+		rc = readWepKeyRid(ai, &wkr, 0, 1);
+		if (rc != SUCCESS)
+			return -1;
@@ -5157,2 +5224,22 @@
-static int set_wep_key(struct airo_info *ai, u16 index,
-		       const char *key, u16 keylen, int perm, int lock )
+static int get_wep_tx_idx(struct airo_info *ai)
+{
+	WepKeyRid wkr;
+	int rc;
+	__le16 lastindex;
+
+	rc = readWepKeyRid(ai, &wkr, 1, 1);
+	if (rc != SUCCESS)
+		return -1;
+	do {
+		lastindex = wkr.kindex;
+		if (wkr.kindex == cpu_to_le16(0xffff))
+			return wkr.mac[0];
+		rc = readWepKeyRid(ai, &wkr, 0, 1);
+		if (rc != SUCCESS)
+			return -1;
+	} while (lastindex != wkr.kindex);
+	return -1;
+}
+
+static int set_wep_key(struct airo_info *ai, u16 index, const char *key,
+		       u16 keylen, int perm, int lock)
@@ -5161,0 +5249 @@
+	int rc;
@@ -5163 +5250,0 @@
-	memset(&wkr, 0, sizeof(wkr));
@@ -5165,12 +5252,3 @@
-// We are selecting which key to use
-		wkr.len = cpu_to_le16(sizeof(wkr));
-		wkr.kindex = cpu_to_le16(0xffff);
-		wkr.mac[0] = (char)index;
-		if (perm) ai->defindex = (char)index;
-	} else {
-// We are actually setting the key
-		wkr.len = cpu_to_le16(sizeof(wkr));
-		wkr.kindex = cpu_to_le16(index);
-		wkr.klen = cpu_to_le16(keylen);
-		memcpy( wkr.key, key, keylen );
-		memcpy( wkr.mac, macaddr, ETH_ALEN );
+		airo_print_err(ai->dev->name, "%s: key length to set was zero",
+			       __func__);
+		return -1;
@@ -5178,0 +5257,7 @@
+	memset(&wkr, 0, sizeof(wkr));
+	wkr.len = cpu_to_le16(sizeof(wkr));
+	wkr.kindex = cpu_to_le16(index);
+	wkr.klen = cpu_to_le16(keylen);
+	memcpy(wkr.key, key, keylen);
+	memcpy(wkr.mac, macaddr, ETH_ALEN);
+
@@ -5180 +5265 @@
-	writeWepKeyRid(ai, &wkr, perm, lock);
+	rc = writeWepKeyRid(ai, &wkr, perm, lock);
@@ -5182 +5267,23 @@
-	return 0;
+	return rc;
+}
+
+static int set_wep_tx_idx(struct airo_info *ai, u16 index, int perm, int lock)
+{
+	WepKeyRid wkr;
+	int rc;
+
+	memset(&wkr, 0, sizeof(wkr));
+	wkr.len = cpu_to_le16(sizeof(wkr));
+	wkr.kindex = cpu_to_le16(0xffff);
+	wkr.mac[0] = (char)index;
+
+	if (perm) {
+		ai->defindex = (char)index;
+		disable_MAC(ai, lock);
+	}
+
+	rc = writeWepKeyRid(ai, &wkr, perm, lock);
+
+	if (perm)
+		enable_MAC(ai, lock);
+	return rc;
@@ -5190 +5297 @@
-	int i;
+	int i, rc;
@@ -5204 +5311,6 @@
-			set_wep_key(ai, index, NULL, 0, 1, 1);
+			rc = set_wep_tx_idx(ai, index, 1, 1);
+			if (rc < 0) {
+				airo_print_err(ai->dev->name, "failed to set "
+				               "WEP transmit index to %d: %d.",
+				               index, rc);
+			}
@@ -5223 +5335,6 @@
-	set_wep_key(ai, index, key, i/3, 1, 1);
+
+	rc = set_wep_key(ai, index, key, i/3, 1, 1);
+	if (rc < 0) {
+		airo_print_err(ai->dev->name, "failed to set WEP key at index "
+		               "%d: %d.", index, rc);
+	}
@@ -5454 +5571 @@
-				set_wep_key(apriv, apriv->keyindex, NULL, 0, 0, 0);
+				set_wep_tx_idx(apriv, apriv->keyindex, 0, 0);
@@ -5460 +5577 @@
-				set_wep_key(apriv, apriv->defindex, NULL, 0, 0, 0);
+				set_wep_tx_idx(apriv, apriv->defindex, 0, 0);
@@ -5728,3 +5845 @@
-	if((fwrq->e == 1) &&
-	   (fwrq->m >= (int) 2.412e8) &&
-	   (fwrq->m <= (int) 2.487e8)) {
+	if(fwrq->e == 1) {
@@ -5732,3 +5847 @@
-		int c = 0;
-		while((c < 14) && (f != frequency_list[c]))
-			c++;
+
@@ -5737 +5850 @@
-		fwrq->m = c + 1;
+		fwrq->m = ieee80211_freq_to_dsss_chan(f);
@@ -5781 +5894 @@
-		fwrq->m = frequency_list[ch - 1] * 100000;
+		fwrq->m = ieee80211_dsss_chan_to_freq(ch) * 100000;
@@ -6237 +6350 @@
-static inline int valid_index(CapabilityRid *p, int index)
+static inline int valid_index(struct airo_info *ai, int index)
@@ -6239,3 +6352 @@
-	if (index < 0)
-		return 0;
-	return index < (p->softCap & cpu_to_le16(0x80) ? 4 : 1);
+	return (index >= 0) && (index <= ai->max_wep_idx);
@@ -6254,2 +6365 @@
-	CapabilityRid cap_rid;		/* Card capability info */
-	int perm = ( dwrq->flags & IW_ENCODE_TEMP ? 0 : 1 );
+	int perm = (dwrq->flags & IW_ENCODE_TEMP ? 0 : 1);
@@ -6256,0 +6367 @@
+	int rc = 0;
@@ -6258,4 +6369 @@
-	/* Is WEP supported ? */
-	readCapabilityRid(local, &cap_rid, 1);
-	/* Older firmware doesn't support this...
-	if(!(cap_rid.softCap & cpu_to_le16(2))) {
+	if (!local->wep_capable)
@@ -6263 +6371 @@
-	} */
+
@@ -6275 +6383,2 @@
-		int current_index = get_wep_key(local, 0xffff);
+		int current_index;
+
@@ -6279,0 +6389,5 @@
+
+		current_index = get_wep_tx_idx(local);
+		if (current_index < 0)
+			current_index = 0;
+
@@ -6281 +6395 @@
-		if (!valid_index(&cap_rid, index))
+		if (!valid_index(local, index))
@@ -6282,0 +6397 @@
+
@@ -6299 +6414,7 @@
-			set_wep_key(local, index, key.key, key.len, perm, 1);
+			rc = set_wep_key(local, index, key.key, key.len, perm, 1);
+			if (rc < 0) {
+				airo_print_err(local->dev->name, "failed to set"
+				               " WEP key at index %d: %d.",
+				               index, rc);
+				return rc;
+			}
@@ -6311,3 +6432,9 @@
-		if (valid_index(&cap_rid, index)) {
-			set_wep_key(local, index, NULL, 0, perm, 1);
-		} else
+		if (valid_index(local, index)) {
+			rc = set_wep_tx_idx(local, index, perm, 1);
+			if (rc < 0) {
+				airo_print_err(local->dev->name, "failed to set"
+				               " WEP transmit index to %d: %d.",
+				               index, rc);
+				return rc;
+			}
+		} else {
@@ -6316,0 +6444 @@
+		}
@@ -6342 +6470,2 @@
-	CapabilityRid cap_rid;		/* Card capability info */
+	int wep_key_len;
+	u8 buf[16];
@@ -6344,3 +6473 @@
-	/* Is it supported ? */
-	readCapabilityRid(local, &cap_rid, 1);
-	if(!(cap_rid.softCap & cpu_to_le16(2))) {
+	if (!local->wep_capable)
@@ -6348 +6475 @@
-	}
+
@@ -6349,0 +6477 @@
+
@@ -6368,2 +6496,5 @@
-	if (!valid_index(&cap_rid, index))
-		index = get_wep_key(local, 0xffff);
+	if (!valid_index(local, index)) {
+		index = get_wep_tx_idx(local);
+		if (index < 0)
+			index = 0;
+	}
@@ -6370,0 +6502 @@
+
@@ -6372,3 +6504,6 @@
-	dwrq->length = get_wep_key(local, index);
-	if (dwrq->length > 16) {
-		dwrq->length=0;
+	wep_key_len = get_wep_key(local, index, &buf[0], sizeof(buf));
+	if (wep_key_len < 0) {
+		dwrq->length = 0;
+	} else {
+		dwrq->length = wep_key_len;
+		memcpy(extra, buf, dwrq->length);
@@ -6375,0 +6511 @@
+
@@ -6391 +6526,0 @@
-	CapabilityRid cap_rid;		/* Card capability info */
@@ -6394 +6529 @@
-	int idx, key_len, alg = ext->alg, set_key = 1;
+	int idx, key_len, alg = ext->alg, set_key = 1, rc;
@@ -6397,4 +6532 @@
-	/* Is WEP supported ? */
-	readCapabilityRid(local, &cap_rid, 1);
-	/* Older firmware doesn't support this...
-	if(!(cap_rid.softCap & cpu_to_le16(2))) {
+	if (!local->wep_capable)
@@ -6402 +6534 @@
-	} */
+
@@ -6408 +6540 @@
-		if (!valid_index(&cap_rid, idx - 1))
+		if (!valid_index(local, idx - 1))
@@ -6411,2 +6543,5 @@
-	} else
-		idx = get_wep_key(local, 0xffff);
+	} else {
+		idx = get_wep_tx_idx(local);
+		if (idx < 0)
+			idx = 0;
+	}
@@ -6421 +6556,7 @@
-		set_wep_key(local, idx, NULL, 0, perm, 1);
+		rc = set_wep_tx_idx(local, idx, perm, 1);
+		if (rc < 0) {
+			airo_print_err(local->dev->name, "failed to set "
+			               "WEP transmit index to %d: %d.",
+			               idx, rc);
+			return rc;
+		}
@@ -6447 +6588,6 @@
-		set_wep_key(local, idx, key.key, key.len, perm, 1);
+		rc = set_wep_key(local, idx, key.key, key.len, perm, 1);
+		if (rc < 0) {
+			airo_print_err(local->dev->name, "failed to set WEP key"
+			               " at index %d: %d.", idx, rc);
+			return rc;
+		}
@@ -6477,2 +6623,2 @@
-	CapabilityRid cap_rid;		/* Card capability info */
-	int idx, max_key_len;
+	int idx, max_key_len, wep_key_len;
+	u8 buf[16];
@@ -6480,3 +6626 @@
-	/* Is it supported ? */
-	readCapabilityRid(local, &cap_rid, 1);
-	if(!(cap_rid.softCap & cpu_to_le16(2))) {
+	if (!local->wep_capable)
@@ -6484 +6628 @@
-	}
+
@@ -6493 +6637 @@
-		if (!valid_index(&cap_rid, idx - 1))
+		if (!valid_index(local, idx - 1))
@@ -6496,2 +6640,5 @@
-	} else
-		idx = get_wep_key(local, 0xffff);
+	} else {
+		idx = get_wep_tx_idx(local);
+		if (idx < 0)
+			idx = 0;
+	}
@@ -6520,3 +6667,6 @@
-	ext->key_len = get_wep_key(local, idx);
-	if (ext->key_len > 16) {
-		ext->key_len=0;
+	wep_key_len = get_wep_key(local, idx, &buf[0], sizeof(buf));
+	if (wep_key_len < 0) {
+		ext->key_len = 0;
+	} else {
+		ext->key_len = wep_key_len;
+		memcpy(extra, buf, ext->key_len);
@@ -6577 +6726,0 @@
-			break;
@@ -6581,0 +6731 @@
+			break;
@@ -6798,2 +6948,2 @@
-		range->freq[k].m = frequency_list[i] * 100000;
-		range->freq[k++].e = 1;	/* Values in table in MHz -> * 10^5 * 10 */
+		range->freq[k].m = ieee80211_dsss_chan_to_freq(i + 1) * 100000;
+		range->freq[k++].e = 1;	/* Values in MHz -> * 10^5 * 10 */
@@ -7034 +7184 @@
-	struct iw_quality qual[IW_MAX_AP];
+	struct iw_quality *qual;
@@ -7038,0 +7189,4 @@
+	qual = kmalloc(IW_MAX_AP * sizeof(*qual), GFP_KERNEL);
+	if (!qual)
+		return -ENOMEM;
+
@@ -7092,0 +7247 @@
+	kfree(qual);
@@ -7192,4 +7347 @@
-	/* iwe.u.freq.m containt the channel (starting 1), our 
-	 * frequency_list array start at index 0...
-	 */
-	iwe.u.freq.m = frequency_list[iwe.u.freq.m - 1] * 100000;
+	iwe.u.freq.m = ieee80211_dsss_chan_to_freq(iwe.u.freq.m) * 100000;
--- ./projects/linux/linux-2.6.13/drivers/net/wireless/atmel.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/net/wireless/atmel.c	2005-10-28 02:02:08.000000000 +0200
@@ -71 +71 @@
-#include "ieee802_11.h"
+#include <net/ieee80211.h>
@@ -621 +621 @@
-static void atmel_management_frame(struct atmel_private *priv, struct ieee802_11_hdr *header, 
+static void atmel_management_frame(struct atmel_private *priv, struct ieee80211_hdr *header, 
@@ -626 +626 @@
-static void atmel_transmit_management_frame(struct atmel_private *priv, struct ieee802_11_hdr *header,
+static void atmel_transmit_management_frame(struct atmel_private *priv, struct ieee80211_hdr *header,
@@ -830 +830 @@
-	struct ieee802_11_hdr header;
+	struct ieee80211_hdr header;
@@ -866 +866 @@
-	frame_ctl = IEEE802_11_FTYPE_DATA;
+	frame_ctl = IEEE80211_FTYPE_DATA;
@@ -870 +870 @@
-		frame_ctl |= IEEE802_11_FCTL_WEP;
+		frame_ctl |= IEEE80211_FCTL_PROTECTED;
@@ -876 +876 @@
-		frame_ctl |= IEEE802_11_FCTL_TODS;
+		frame_ctl |= IEEE80211_FCTL_TODS;
@@ -905 +905 @@
-					    struct ieee802_11_hdr *header,
+					    struct ieee80211_hdr *header,
@@ -920 +920 @@
-static void fast_rx_path(struct atmel_private *priv, struct ieee802_11_hdr *header, 
+static void fast_rx_path(struct atmel_private *priv, struct ieee80211_hdr *header, 
@@ -958 +958 @@
-	if (le16_to_cpu(header->frame_ctl) & IEEE802_11_FCTL_FROMDS) 
+	if (le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_FROMDS) 
@@ -993 +993 @@
-static void frag_rx_path(struct atmel_private *priv, struct ieee802_11_hdr *header, 
+static void frag_rx_path(struct atmel_private *priv, struct ieee80211_hdr *header, 
@@ -1000 +1000 @@
-	if (le16_to_cpu(header->frame_ctl) & IEEE802_11_FCTL_FROMDS) 
+	if (le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_FROMDS) 
@@ -1085 +1085 @@
-	struct ieee802_11_hdr header;
+	struct ieee80211_hdr header;
@@ -1120 +1120 @@
-			if (!priv->wep_is_on || !(frame_ctl & IEEE802_11_FCTL_WEP)) {
+			if (!priv->wep_is_on || !(frame_ctl & IEEE80211_FCTL_PROTECTED)) {
@@ -1135 +1135 @@
-		if (priv->do_rx_crc && (!priv->wep_is_on || !(frame_ctl & IEEE802_11_FCTL_WEP))) {
+		if (priv->do_rx_crc && (!priv->wep_is_on || !(frame_ctl & IEEE80211_FCTL_PROTECTED))) {
@@ -1140 +1140 @@
-		if ((frame_ctl & IEEE802_11_FCTL_FTYPE) == IEEE802_11_FTYPE_DATA) { 
+		if ((frame_ctl & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA) { 
@@ -1142,3 +1142,3 @@
-			int more_fragments = frame_ctl & IEEE802_11_FCTL_MOREFRAGS;
-			u8 packet_fragment_no = seq_control & IEEE802_11_SCTL_FRAG;
-			u16 packet_sequence_no = (seq_control & IEEE802_11_SCTL_SEQ) >> 4;
+			int more_fragments = frame_ctl & IEEE80211_FCTL_MOREFRAGS;
+			u8 packet_fragment_no = seq_control & IEEE80211_SCTL_FRAG;
+			u16 packet_sequence_no = (seq_control & IEEE80211_SCTL_SEQ) >> 4;
@@ -1154 +1154 @@
-		if ((frame_ctl & IEEE802_11_FCTL_FTYPE) == IEEE802_11_FTYPE_MGMT) {
+		if ((frame_ctl & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_MGMT) {
@@ -1596 +1595,0 @@
-	dev->get_wireless_stats = atmel_get_wireless_stats;
@@ -2414 +2413,2 @@
-	.private_args	= (struct iw_priv_args *) atmel_private_args
+	.private_args	= (struct iw_priv_args *) atmel_private_args,
+	.get_wireless_stats = atmel_get_wireless_stats
@@ -2427,13 +2426,0 @@
-	case SIOCGIWPRIV:
-		if(wrq->u.data.pointer) {
-			/* Set the number of ioctl available */
-			wrq->u.data.length = sizeof(atmel_private_args) / sizeof(atmel_private_args[0]);
-			
-			/* Copy structure to the user buffer */
-			if (copy_to_user(wrq->u.data.pointer,
-					 (u_char *) atmel_private_args,
-					 sizeof(atmel_private_args)))
-				rc = -EFAULT;
-		}
-		break;
-
@@ -2666 +2653 @@
-	struct ieee802_11_hdr header;
+	struct ieee80211_hdr header;
@@ -2669 +2656 @@
-	header.frame_ctl = cpu_to_le16(IEEE802_11_FTYPE_MGMT | IEEE802_11_STYPE_AUTH); 
+	header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH); 
@@ -2680 +2667 @@
-			header.frame_ctl |=  cpu_to_le16(IEEE802_11_FCTL_WEP); 
+			header.frame_ctl |=  cpu_to_le16(IEEE80211_FCTL_PROTECTED);
@@ -2704 +2691 @@
-	struct ieee802_11_hdr header;
+	struct ieee80211_hdr header;
@@ -2717,2 +2704,2 @@
-	header.frame_ctl = cpu_to_le16(IEEE802_11_FTYPE_MGMT | 
-		(is_reassoc ? IEEE802_11_STYPE_REASSOC_REQ : IEEE802_11_STYPE_ASSOC_REQ));
+	header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT | 
+		(is_reassoc ? IEEE80211_STYPE_REASSOC_REQ : IEEE80211_STYPE_ASSOC_REQ));
@@ -2754 +2741 @@
-static int is_frame_from_current_bss(struct atmel_private *priv, struct ieee802_11_hdr *header)
+static int is_frame_from_current_bss(struct atmel_private *priv, struct ieee80211_hdr *header)
@@ -2756 +2743 @@
-	if (le16_to_cpu(header->frame_ctl) & IEEE802_11_FCTL_FROMDS)
+	if (le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_FROMDS)
@@ -2804 +2791 @@
-static void store_bss_info(struct atmel_private *priv, struct ieee802_11_hdr *header,
+static void store_bss_info(struct atmel_private *priv, struct ieee80211_hdr *header,
@@ -3088 +3075 @@
-static void atmel_management_frame(struct atmel_private *priv, struct ieee802_11_hdr *header, 
+static void atmel_management_frame(struct atmel_private *priv, struct ieee80211_hdr *header, 
@@ -3093 +3080 @@
-	switch (subtype = le16_to_cpu(header->frame_ctl) & IEEE802_11_FCTL_STYPE) {
+	switch (subtype = le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_STYPE) {
--- ./projects/linux/linux-2.6.14/drivers/net/wireless/atmel.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/net/wireless/atmel.c	2006-01-03 04:21:10.000000000 +0100
@@ -75 +75 @@
-#define DRIVER_MINOR 96
+#define DRIVER_MINOR 98
@@ -621 +621 @@
-static void atmel_management_frame(struct atmel_private *priv, struct ieee80211_hdr *header, 
+static void atmel_management_frame(struct atmel_private *priv, struct ieee80211_hdr_4addr *header, 
@@ -626 +626 @@
-static void atmel_transmit_management_frame(struct atmel_private *priv, struct ieee80211_hdr *header,
+static void atmel_transmit_management_frame(struct atmel_private *priv, struct ieee80211_hdr_4addr *header,
@@ -830 +830 @@
-	struct ieee80211_hdr header;
+	struct ieee80211_hdr_4addr header;
@@ -905 +905 @@
-					    struct ieee80211_hdr *header,
+					    struct ieee80211_hdr_4addr *header,
@@ -920 +920 @@
-static void fast_rx_path(struct atmel_private *priv, struct ieee80211_hdr *header, 
+static void fast_rx_path(struct atmel_private *priv, struct ieee80211_hdr_4addr *header, 
@@ -993 +993 @@
-static void frag_rx_path(struct atmel_private *priv, struct ieee80211_hdr *header, 
+static void frag_rx_path(struct atmel_private *priv, struct ieee80211_hdr_4addr *header, 
@@ -1085 +1085 @@
-	struct ieee80211_hdr header;
+	struct ieee80211_hdr_4addr header;
@@ -1507 +1507 @@
-struct net_device *init_atmel_card( unsigned short irq, int port, const AtmelFWType fw_type,  
+struct net_device *init_atmel_card( unsigned short irq, unsigned long port, const AtmelFWType fw_type,  
@@ -1608,2 +1608,2 @@
-	if (priv->bus_type == BUS_TYPE_PCI &&
-	    !request_region( dev->base_addr, 64, dev->name )) {
+	if (!request_region(dev->base_addr, 32, 
+			    priv->bus_type == BUS_TYPE_PCCARD ?  "atmel_cs" : "atmel_pci")) {
@@ -1625,2 +1625,4 @@
-	printk(KERN_INFO "%s: Atmel at76c50x wireless. Version %d.%d simon@thekelleys.org.uk\n",
-	       dev->name, DRIVER_MAJOR, DRIVER_MINOR);
+	printk(KERN_INFO "%s: Atmel at76c50x. Version %d.%d. MAC %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
+	       dev->name, DRIVER_MAJOR, DRIVER_MINOR,
+	       dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
+	       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5] );
@@ -1632,2 +1634 @@
-	if (priv->bus_type == BUS_TYPE_PCI)
-	        release_region( dev->base_addr, 64 );
+	release_region( dev->base_addr, 32);
@@ -1643 +1644 @@
-void stop_atmel_card(struct net_device *dev, int freeres)
+void stop_atmel_card(struct net_device *dev)
@@ -1656,6 +1657,2 @@
-	if (priv->firmware)
-		kfree(priv->firmware);
-	if (freeres) {
-		/* PCMCIA frees this stuff, so only for PCI */
-	        release_region(dev->base_addr, 64);
-        }
+	kfree(priv->firmware);
+	release_region(dev->base_addr, 32);
@@ -1814 +1811 @@
-	if(dwrq->flags & IW_ENCODE_OPEN)
+       	if(dwrq->flags & IW_ENCODE_OPEN) 
@@ -1816 +1813 @@
-	
+       
@@ -1831,5 +1828,6 @@
-	else if (priv->exclude_unencrypted)
-		dwrq->flags = IW_ENCODE_RESTRICTED;
-	else
-		dwrq->flags = IW_ENCODE_OPEN;
-		
+	else {
+		if (priv->exclude_unencrypted)
+			dwrq->flags = IW_ENCODE_RESTRICTED;
+		else
+			dwrq->flags = IW_ENCODE_OPEN;
+	}
@@ -2221 +2219 @@
-	memset(range, 0, sizeof(range));
+	memset(range, 0, sizeof(struct iw_range));
@@ -2453,2 +2451 @@
-		if (priv->firmware)
-			kfree(priv->firmware);
+		kfree(priv->firmware);
@@ -2650,2 +2647,2 @@
- 
-static void send_authentication_request(struct atmel_private *priv, u8 *challenge, int challenge_len)
+
+static void send_authentication_request(struct atmel_private *priv, u16 system, u8 *challenge, int challenge_len)
@@ -2653 +2650 @@
-	struct ieee80211_hdr header;
+	struct ieee80211_hdr_4addr header;
@@ -2663,2 +2660 @@
-	if (priv->wep_is_on) {
-		auth.alg = cpu_to_le16(C80211_MGMT_AAN_SHAREDKEY); 
+	if (priv->wep_is_on && priv->CurrentAuthentTransactionSeqNum != 1) 
@@ -2666,5 +2662,3 @@
-		if (priv->CurrentAuthentTransactionSeqNum != 1)
-			header.frame_ctl |=  cpu_to_le16(IEEE80211_FCTL_PROTECTED);
-	} else {
-		auth.alg = cpu_to_le16(C80211_MGMT_AAN_OPENSYSTEM);
-	}
+                header.frame_ctl |=  cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+	
+	auth.alg = cpu_to_le16(system); 
@@ -2691 +2685 @@
-	struct ieee80211_hdr header;
+	struct ieee80211_hdr_4addr header;
@@ -2741 +2735 @@
-static int is_frame_from_current_bss(struct atmel_private *priv, struct ieee80211_hdr *header)
+static int is_frame_from_current_bss(struct atmel_private *priv, struct ieee80211_hdr_4addr *header)
@@ -2791 +2785 @@
-static void store_bss_info(struct atmel_private *priv, struct ieee80211_hdr *header,
+static void store_bss_info(struct atmel_private *priv, struct ieee80211_hdr_4addr *header,
@@ -2838,0 +2833 @@
+	u16 system = le16_to_cpu(auth->alg);
@@ -2860 +2855 @@
-			send_authentication_request(priv, auth->chall_text, auth->chall_text_len);
+			send_authentication_request(priv, system, auth->chall_text, auth->chall_text_len);
@@ -2877,8 +2872,14 @@
-	if (status == C80211_MGMT_SC_AuthAlgNotSupported && priv->connect_to_any_BSS) {
-		int bss_index;
-		
-		priv->BSSinfo[(int)(priv->current_BSS)].channel |= 0x80;
-		
-		if ((bss_index  = retrieve_bss(priv)) != -1) {
-			atmel_join_bss(priv, bss_index);
-			return;
+	if (status == C80211_MGMT_SC_AuthAlgNotSupported) {
+		/* Do opensystem first, then try sharedkey */
+		if (system ==  C80211_MGMT_AAN_OPENSYSTEM) {
+			priv->CurrentAuthentTransactionSeqNum = 0x001;
+			send_authentication_request(priv, C80211_MGMT_AAN_SHAREDKEY, NULL, 0);
+		} else if (priv->connect_to_any_BSS) {
+			int bss_index;
+			
+			priv->BSSinfo[(int)(priv->current_BSS)].channel |= 0x80;
+			
+			if ((bss_index  = retrieve_bss(priv)) != -1) {
+				atmel_join_bss(priv, bss_index);
+				return;
+			}
@@ -3075 +3076 @@
-static void atmel_management_frame(struct atmel_private *priv, struct ieee80211_hdr *header, 
+static void atmel_management_frame(struct atmel_private *priv, struct ieee80211_hdr_4addr *header, 
@@ -3210 +3211 @@
-		  send_authentication_request(priv, NULL, 0);
+		  send_authentication_request(priv, C80211_MGMT_AAN_OPENSYSTEM, NULL, 0);
@@ -3317 +3318 @@
-				send_authentication_request(priv, NULL, 0);
+				send_authentication_request(priv, C80211_MGMT_AAN_SHAREDKEY, NULL, 0);
@@ -3487,5 +3487,0 @@
-		printk(KERN_INFO "%s: MAC address %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
-		       dev->name,
-		       dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
-		       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5] );
-		
--- ./projects/linux/linux-2.6.15/drivers/net/wireless/atmel.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/net/wireless/atmel.c	2006-03-20 06:53:29.000000000 +0100
@@ -8,3 +8,3 @@
-    This code was developed from version 2.1.1 of the Atmel drivers, 
-    released by Atmel corp. under the GPL in December 2002. It also 
-    includes code from the Linux aironet drivers (C) Benjamin Reed, 
+    This code was developed from version 2.1.1 of the Atmel drivers,
+    released by Atmel corp. under the GPL in December 2002. It also
+    includes code from the Linux aironet drivers (C) Benjamin Reed,
@@ -34 +34 @@
-    For all queries about this code, please contact the current author, 
+    For all queries about this code, please contact the current author,
@@ -82 +82 @@
-/* The name of the firmware file to be loaded 
+/* The name of the firmware file to be loaded
@@ -88 +88 @@
-static struct { 
+static struct {
@@ -107 +107 @@
-#define MAX_BSS_ENTRIES	64	
+#define MAX_BSS_ENTRIES	64
@@ -110,2 +110,2 @@
-#define GCR  0x00    //      (SIR0)  General Configuration Register        
-#define BSR  0x02    //      (SIR1)  Bank Switching Select Register 
+#define GCR  0x00    //      (SIR0)  General Configuration Register
+#define BSR  0x02    //      (SIR1)  Bank Switching Select Register
@@ -114,4 +114,4 @@
-#define MR1  0x12    //      Mirror Register 1                  
-#define MR2  0x14    //      Mirror Register 2  
-#define MR3  0x16    //      Mirror Register 3  
-#define MR4  0x18    //      Mirror Register 4   
+#define MR1  0x12    //      Mirror Register 1
+#define MR2  0x14    //      Mirror Register 2
+#define MR3  0x16    //      Mirror Register 3
+#define MR4  0x18    //      Mirror Register 4
@@ -126 +126 @@
-#define GCR_SWRES     0x0080          // BIU reset (ARM and PAI are NOT reset) 
+#define GCR_SWRES     0x0080          // BIU reset (ARM and PAI are NOT reset)
@@ -128 +128 @@
-#define GCR_ENINT     0x0002          // Enable Interrupts    
+#define GCR_ENINT     0x0002          // Enable Interrupts
@@ -193 +193 @@
-	
+
@@ -202 +201,0 @@
-
@@ -221 +219,0 @@
-
@@ -226 +224 @@
-	
+
@@ -230 +228 @@
-	
+
@@ -241 +238,0 @@
-	
@@ -244 +240,0 @@
-
@@ -258,2 +253,0 @@
-
-
@@ -269 +262,0 @@
-
@@ -283,2 +276 @@
-#define ISR_GENERIC_IRQ         0x80                
-
+#define ISR_GENERIC_IRQ         0x80
@@ -320 +311,0 @@
-
@@ -341 +331,0 @@
-
@@ -350 +340 @@
-#define MAX_ASSOCIATION_RETRIES 	3
+#define MAX_ASSOCIATION_RETRIES		3
@@ -357,2 +347,2 @@
-#define ACTIVE_MODE 	1
-#define PS_MODE 	2
+#define ACTIVE_MODE	1
+#define PS_MODE		2
@@ -380 +370 @@
-#define BSS_TYPE_AD_HOC 	1
+#define BSS_TYPE_AD_HOC		1
@@ -392 +382 @@
-/* promiscuous mode control */ 
+/* promiscuous mode control */
@@ -401,2 +391 @@
-
-#define IFACE_INT_STATUS_OFFSET 	0
+#define IFACE_INT_STATUS_OFFSET		0
@@ -410 +399 @@
-#define CIPHER_SUITE_NONE     0 
+#define CIPHER_SUITE_NONE     0
@@ -422 +411 @@
-// FuncCtrl field: 
+// FuncCtrl field:
@@ -426 +415 @@
-#define FUNC_CTRL_INIT_COMPLETE 	0x01
+#define FUNC_CTRL_INIT_COMPLETE		0x01
@@ -489,2 +478,2 @@
-	enum { 
-		CARD_TYPE_PARALLEL_FLASH, 
+	enum {
+		CARD_TYPE_PARALLEL_FLASH,
@@ -492 +481 @@
-		CARD_TYPE_EEPROM 
+		CARD_TYPE_EEPROM
@@ -500 +489 @@
-	
+
@@ -502,2 +491,2 @@
-	u8 frag_source[6]; 
-	
+	u8 frag_source[6];
+
@@ -507 +496 @@
-	int wep_key_len[MAX_ENCRYPTION_KEYS]; 
+	int wep_key_len[MAX_ENCRYPTION_KEYS];
@@ -511 +500 @@
-	struct host_info_struct { 
+	struct host_info_struct {
@@ -527 +516 @@
-		
+
@@ -529,2 +518,2 @@
-		u16 command_pos; 	
-		
+		u16 command_pos;
+
@@ -533 +522 @@
-		
+
@@ -540 +529 @@
-	enum { 
+	enum {
@@ -550 +539 @@
-	
+
@@ -563 +552 @@
-	int CurrentAuthentTransactionSeqNum, ExpectedAuthentTransactionSeqNum;	
+	int CurrentAuthentTransactionSeqNum, ExpectedAuthentTransactionSeqNum;
@@ -568 +557 @@
-		SITE_SURVEY_COMPLETED 
+		SITE_SURVEY_COMPLETED
@@ -574 +563 @@
-				
+
@@ -587 +576 @@
-	int connect_to_any_BSS; 
+	int connect_to_any_BSS;
@@ -593 +581,0 @@
-	
@@ -601 +589 @@
-	char *name; 
+	char *name;
@@ -606 +594 @@
-		      { REG_DOMAIN_FRANCE, 10, 13, "France" }, 
+		      { REG_DOMAIN_FRANCE, 10, 13, "France" },
@@ -613,2 +601,4 @@
-static void atmel_copy_to_card(struct net_device *dev, u16 dest, unsigned char *src, u16 len);
-static void atmel_copy_to_host(struct net_device *dev, unsigned char *dest, u16 src, u16 len);
+static void atmel_copy_to_card(struct net_device *dev, u16 dest,
+			       unsigned char *src, u16 len);
+static void atmel_copy_to_host(struct net_device *dev, unsigned char *dest,
+			       u16 src, u16 len);
@@ -621 +611,2 @@
-static void atmel_management_frame(struct atmel_private *priv, struct ieee80211_hdr_4addr *header, 
+static void atmel_management_frame(struct atmel_private *priv,
+				   struct ieee80211_hdr_4addr *header,
@@ -624,3 +615,6 @@
-static void atmel_send_command(struct atmel_private *priv, int command, void *cmd, int cmd_size);
-static int atmel_send_command_wait(struct atmel_private *priv, int command, void *cmd, int cmd_size);
-static void atmel_transmit_management_frame(struct atmel_private *priv, struct ieee80211_hdr_4addr *header,
+static void atmel_send_command(struct atmel_private *priv, int command,
+			       void *cmd, int cmd_size);
+static int atmel_send_command_wait(struct atmel_private *priv, int command,
+				   void *cmd, int cmd_size);
+static void atmel_transmit_management_frame(struct atmel_private *priv,
+					    struct ieee80211_hdr_4addr *header,
@@ -630,4 +624,8 @@
-static void atmel_set_mib8(struct atmel_private *priv, u8 type, u8 index, u8 data);
-static void atmel_set_mib16(struct atmel_private *priv, u8 type, u8 index, u16 data);
-static void atmel_set_mib(struct atmel_private *priv, u8 type, u8 index, u8 *data, int data_len);
-static void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index, u8 *data, int data_len);
+static void atmel_set_mib8(struct atmel_private *priv, u8 type, u8 index,
+			   u8 data);
+static void atmel_set_mib16(struct atmel_private *priv, u8 type, u8 index,
+			    u16 data);
+static void atmel_set_mib(struct atmel_private *priv, u8 type, u8 index,
+			  u8 *data, int data_len);
+static void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index,
+			  u8 *data, int data_len);
@@ -653 +651 @@
-static inline u16 atmel_rx(struct atmel_private *priv, u16 offset, u16  desc)
+static inline u16 atmel_rx(struct atmel_private *priv, u16 offset, u16 desc)
@@ -658 +656 @@
-static inline u16 atmel_tx(struct atmel_private *priv, u16 offset, u16  desc)
+static inline u16 atmel_tx(struct atmel_private *priv, u16 offset, u16 desc)
@@ -685 +683 @@
-	atmel_writeAR(priv->dev, pos);	
+	atmel_writeAR(priv->dev, pos);
@@ -691 +689 @@
-	atmel_writeAR(priv->dev, pos);	
+	atmel_writeAR(priv->dev, pos);
@@ -697 +695 @@
-       	atmel_writeAR(priv->dev, pos);	
+	atmel_writeAR(priv->dev, pos);
@@ -703 +701 @@
-       	atmel_writeAR(priv->dev, pos);	
+	atmel_writeAR(priv->dev, pos);
@@ -713 +711 @@
-	for (i = 0; 
+	for (i = 0;
@@ -717 +714,0 @@
-		
@@ -731 +728 @@
-			
+
@@ -733 +730 @@
-			priv->tx_desc_head++ ;					
+			priv->tx_desc_head++ ;
@@ -736 +733 @@
-		
+
@@ -740 +737 @@
-			else 
+			else
@@ -751 +748 @@
-	if (priv->tx_desc_free == 3 || priv->tx_free_mem < len) 
+	if (priv->tx_desc_free == 3 || priv->tx_free_mem < len)
@@ -753 +750 @@
-	
+
@@ -756 +753 @@
-	
+
@@ -761 +758 @@
-	
+
@@ -765 +762,2 @@
-static void tx_update_descriptor(struct atmel_private *priv, int is_bcast, u16 len, u16 buff, u8 type)
+static void tx_update_descriptor(struct atmel_private *priv, int is_bcast,
+				 u16 len, u16 buff, u8 type)
@@ -778,2 +776,2 @@
-			if (cipher_type == CIPHER_SUITE_WEP_64 || 
-			    cipher_type == CIPHER_SUITE_WEP_128 )
+			if (cipher_type == CIPHER_SUITE_WEP_64 ||
+			    cipher_type == CIPHER_SUITE_WEP_128)
@@ -793,2 +791,2 @@
-			if (cipher_type == CIPHER_SUITE_WEP_64 || 
-			    cipher_type == CIPHER_SUITE_WEP_128 )
+			if (cipher_type == CIPHER_SUITE_WEP_64 ||
+			    cipher_type == CIPHER_SUITE_WEP_128)
@@ -807 +805 @@
-		
+
@@ -809 +807 @@
-			    cipher_type);	
+			    cipher_type);
@@ -818 +816 @@
-	if (priv->tx_desc_tail < (priv->host_info.tx_desc_count -1 ))
+	if (priv->tx_desc_tail < (priv->host_info.tx_desc_count - 1))
@@ -824 +821,0 @@
-
@@ -827 +824 @@
-static int start_tx (struct sk_buff *skb, struct net_device *dev)
+static int start_tx(struct sk_buff *skb, struct net_device *dev)
@@ -834,2 +831,2 @@
- 
-	if (priv->card && priv->present_callback && 
+
+	if (priv->card && priv->present_callback &&
@@ -841 +838 @@
-	
+
@@ -847 +844 @@
-	
+
@@ -849 +846 @@
-	spin_lock_bh(&priv->timerlock); 
+	spin_lock_bh(&priv->timerlock);
@@ -851 +848 @@
-	spin_lock_irqsave(&priv->irqlock, flags); 
+	spin_lock_irqsave(&priv->irqlock, flags);
@@ -853 +850 @@
-	
+
@@ -855,3 +852,4 @@
-	   12 first bytes (containing DA/SA) and put them in the appropriate fields of
-	   the Wireless Header. Thus the packet length is then the initial + 18 (+30-12) */
-	
+	   12 first bytes (containing DA/SA) and put them in the appropriate
+	   fields of the Wireless Header. Thus the packet length is then the
+	   initial + 18 (+30-12) */
+
@@ -865 +863 @@
-	
+
@@ -881 +879 @@
-	
+
@@ -891 +889 @@
-	
+
@@ -896 +894 @@
-	
+
@@ -900,2 +898,2 @@
-	
-	return 0;	
+
+	return 0;
@@ -904 +902 @@
-static void atmel_transmit_management_frame(struct atmel_private *priv, 
+static void atmel_transmit_management_frame(struct atmel_private *priv,
@@ -909,3 +907,3 @@
-	int len =  MGMT_FRAME_BODY_OFFSET + body_len;
-	
-	if (!(buff = find_tx_buff(priv, len))) 
+	int len = MGMT_FRAME_BODY_OFFSET + body_len;
+
+	if (!(buff = find_tx_buff(priv, len)))
@@ -919,2 +917,3 @@
-	
-static void fast_rx_path(struct atmel_private *priv, struct ieee80211_hdr_4addr *header, 
+
+static void fast_rx_path(struct atmel_private *priv,
+			 struct ieee80211_hdr_4addr *header,
@@ -924,2 +923,2 @@
-	u8 mac4[6]; 
-	struct sk_buff 	*skb;
+	u8 mac4[6];
+	struct sk_buff	*skb;
@@ -927 +926 @@
-	
+
@@ -931 +930 @@
-	
+
@@ -936 +935 @@
-	
+
@@ -945 +944 @@
-	
+
@@ -956 +955 @@
-	
+
@@ -958 +957 @@
-	if (le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_FROMDS) 
+	if (le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_FROMDS)
@@ -962,2 +961,2 @@
-	
-	priv->dev->last_rx=jiffies;
+
+	priv->dev->last_rx = jiffies;
@@ -966 +965 @@
-	skb->ip_summed = CHECKSUM_NONE;	
+	skb->ip_summed = CHECKSUM_NONE;
@@ -973 +972,2 @@
-   It doesn't matter that this is slow: it is only used to proble the first few packets. */
+   It doesn't matter that this is slow: it is only used to proble the first few
+   packets. */
@@ -983 +983 @@
-	
+
@@ -993,2 +993,4 @@
-static void frag_rx_path(struct atmel_private *priv, struct ieee80211_hdr_4addr *header, 
-			 u16 msdu_size, u16 rx_packet_loc, u32 crc, u16 seq_no, u8 frag_no, int more_frags)
+static void frag_rx_path(struct atmel_private *priv,
+			 struct ieee80211_hdr_4addr *header,
+			 u16 msdu_size, u16 rx_packet_loc, u32 crc, u16 seq_no,
+			 u8 frag_no, int more_frags)
@@ -996 +998 @@
-	u8 mac4[6]; 
+	u8 mac4[6];
@@ -1000 +1002 @@
-	if (le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_FROMDS) 
+	if (le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_FROMDS)
@@ -1003,2 +1005,2 @@
-		memcpy(source, header->addr2, 6); 
-	
+		memcpy(source, header->addr2, 6);
+
@@ -1006 +1008 @@
-	
+
@@ -1015 +1017 @@
-		if (priv->do_rx_crc) 
+		if (priv->do_rx_crc)
@@ -1017 +1019 @@
-	       
+
@@ -1021 +1023 @@
-		memcpy(priv->frag_source, source, 6); 
+		memcpy(priv->frag_source, source, 6);
@@ -1024 +1026 @@
-				
+
@@ -1036 +1038 @@
-		
+
@@ -1040,2 +1042,2 @@
-		
-		atmel_copy_to_host(priv->dev, &priv->rx_buf[12 + priv->frag_len], 
+
+		atmel_copy_to_host(priv->dev, &priv->rx_buf[12 + priv->frag_len],
@@ -1045,2 +1047,2 @@
-			crc = crc32_le(crc, 
-				       &priv->rx_buf[12 + priv->frag_len], 
+			crc = crc32_le(crc,
+				       &priv->rx_buf[12 + priv->frag_len],
@@ -1055 +1057 @@
-		
+
@@ -1065 +1067 @@
-				memcpy(skb_put(skb, priv->frag_len + 12), 
+				memcpy(skb_put(skb, priv->frag_len + 12),
@@ -1071 +1073 @@
-				skb->ip_summed = CHECKSUM_NONE;	
+				skb->ip_summed = CHECKSUM_NONE;
@@ -1077 +1078,0 @@
-		
@@ -1081 +1082 @@
-		
+
@@ -1086,2 +1087,2 @@
-	
-	for (i = 0; 
+
+	for (i = 0;
@@ -1091 +1092 @@
-				
+
@@ -1095 +1096 @@
-		
+
@@ -1100 +1101 @@
-				priv->stats.rx_errors++; 
+				priv->stats.rx_errors++;
@@ -1106 +1107 @@
-		
+
@@ -1108 +1109 @@
-			priv->stats.rx_errors++; 
+			priv->stats.rx_errors++;
@@ -1111 +1112 @@
-		
+
@@ -1117,2 +1118,3 @@
-		/* probe for CRC use here if needed  once five packets have arrived with
-		   the same crc status, we assume we know what's happening and stop probing */
+		/* probe for CRC use here if needed  once five packets have
+		   arrived with the same crc status, we assume we know what's
+		   happening and stop probing */
@@ -1133 +1135 @@
-		    
+
@@ -1140,2 +1142 @@
-		if ((frame_ctl & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA) { 
-			
+		if ((frame_ctl & IEEE80211_FCTL_FTYPE) == IEEE80211_FTYPE_DATA) {
@@ -1145,2 +1146,2 @@
-			
-			if (!more_fragments && packet_fragment_no == 0 ) {
+
+			if (!more_fragments && packet_fragment_no == 0) {
@@ -1153 +1154 @@
-		
+
@@ -1157 +1158 @@
-			
+
@@ -1160 +1161 @@
-			
+
@@ -1173 +1174 @@
-		} 
+		}
@@ -1175 +1176 @@
-	next:
+next:
@@ -1177,2 +1178,2 @@
-		atmel_wmem8(priv, atmel_rx(priv, RX_DESC_FLAGS_OFFSET, priv->rx_desc_head), RX_DESC_FLAG_CONSUMED);  
-		
+		atmel_wmem8(priv, atmel_rx(priv, RX_DESC_FLAGS_OFFSET, priv->rx_desc_head), RX_DESC_FLAG_CONSUMED);
+
@@ -1180 +1181 @@
-			priv->rx_desc_head++;					
+			priv->rx_desc_head++;
@@ -1184 +1185 @@
-}	
+}
@@ -1192 +1193 @@
-	static u8 irq_order[] = { 
+	static u8 irq_order[] = {
@@ -1202 +1202,0 @@
-		
@@ -1204 +1204 @@
-	if (priv->card && priv->present_callback && 
+	if (priv->card && priv->present_callback &&
@@ -1211 +1211 @@
-	   the inturrupt line may be shared. This allows card setup 
+	   the inturrupt line may be shared. This allows card setup
@@ -1215 +1215 @@
-     	
+
@@ -1224 +1224 @@
-		
+
@@ -1227 +1227 @@
-		
+
@@ -1232 +1232 @@
-		
+
@@ -1234 +1234 @@
-		
+
@@ -1238 +1238 @@
-		
+
@@ -1244 +1244 @@
-		
+
@@ -1249 +1249 @@
-		
+
@@ -1251,3 +1251,3 @@
-			
-		case ISR_OUT_OF_RANGE: 
-			if (priv->operating_mode == IW_MODE_INFRA && 
+
+		case ISR_OUT_OF_RANGE:
+			if (priv->operating_mode == IW_MODE_INFRA &&
@@ -1264 +1264 @@
-			rx_done_irq(priv); 
+			rx_done_irq(priv);
@@ -1266 +1266 @@
-			
+
@@ -1268 +1268 @@
-			tx_done_irq(priv); 
+			tx_done_irq(priv);
@@ -1270 +1270 @@
-			
+
@@ -1275,2 +1275,2 @@
-			
-		case ISR_COMMAND_COMPLETE: 
+
+		case ISR_COMMAND_COMPLETE:
@@ -1281 +1281 @@
-			atmel_get_mib(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_BSSID_POS, 
+			atmel_get_mib(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_CUR_BSSID_POS,
@@ -1291 +1291 @@
-	}	
+	}
@@ -1294,2 +1294 @@
-
-static struct net_device_stats *atmel_get_stats (struct net_device *dev)
+static struct net_device_stats *atmel_get_stats(struct net_device *dev)
@@ -1301 +1300 @@
-static struct iw_statistics *atmel_get_wireless_stats (struct net_device *dev)
+static struct iw_statistics *atmel_get_wireless_stats(struct net_device *dev)
@@ -1305 +1304 @@
-	/* update the link quality here in case we are seeing no beacons 
+	/* update the link quality here in case we are seeing no beacons
@@ -1308 +1307 @@
-	
+
@@ -1331,2 +1330,2 @@
-	
-	return (&priv->wstats);
+
+	return &priv->wstats;
@@ -1346 +1345 @@
-        
+
@@ -1353 +1352 @@
-int atmel_open (struct net_device *dev)
+int atmel_open(struct net_device *dev)
@@ -1360 +1359 @@
-	
+
@@ -1380 +1379 @@
-	if (!reset_atmel_card(dev)) 
+	if (!reset_atmel_card(dev))
@@ -1394 +1393 @@
-		} 
+		}
@@ -1396 +1395 @@
-	
+
@@ -1400,2 +1399,2 @@
-	/* this moves station_state on.... */ 
-	atmel_scan(priv, 1);	
+	/* this moves station_state on.... */
+	atmel_scan(priv, 1);
@@ -1407 +1406 @@
-static int atmel_close (struct net_device *dev)
+static int atmel_close(struct net_device *dev)
@@ -1410 +1409,12 @@
-		
+
+	/* Send event to userspace that we are disassociating */
+	if (priv->station_state == STATION_STATE_READY) {
+		union iwreq_data wrqu;
+
+		wrqu.data.length = 0;
+		wrqu.data.flags = 0;
+		wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+		memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
+		wireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);
+	}
+
@@ -1412,2 +1422,2 @@
-	
-	if (priv->bus_type == BUS_TYPE_PCCARD) 
+
+	if (priv->bus_type == BUS_TYPE_PCCARD)
@@ -1441,3 +1451,4 @@
-	
-	p += sprintf(p, "Driver version:\t\t%d.%d\n", DRIVER_MAJOR, DRIVER_MINOR);
-	
+
+	p += sprintf(p, "Driver version:\t\t%d.%d\n",
+		     DRIVER_MAJOR, DRIVER_MINOR);
+
@@ -1445 +1456,2 @@
-		p += sprintf(p, "Firmware version:\t%d.%d build %d\nFirmware location:\t", 
+		p += sprintf(p, "Firmware version:\t%d.%d build %d\n"
+				"Firmware location:\t",
@@ -1449,2 +1461,2 @@
-		
-		if (priv->card_type != CARD_TYPE_EEPROM) 
+
+		if (priv->card_type != CARD_TYPE_EEPROM)
@@ -1452,2 +1464,3 @@
-		else if (priv->firmware) 
-			p += sprintf(p, "%s loaded by host\n", priv->firmware_id);
+		else if (priv->firmware)
+			p += sprintf(p, "%s loaded by host\n",
+				     priv->firmware_id);
@@ -1455,3 +1468,4 @@
-			p += sprintf(p, "%s loaded by hotplug\n", priv->firmware_id);
-		
-		switch(priv->card_type) {
+			p += sprintf(p, "%s loaded by hotplug\n",
+				     priv->firmware_id);
+
+		switch (priv->card_type) {
@@ -1464 +1477,0 @@
-		
@@ -1469 +1482 @@
-		
+
@@ -1472 +1485 @@
-		p += sprintf(p, "Host CRC checking:\t%s\n", 
+		p += sprintf(p, "Host CRC checking:\t%s\n",
@@ -1477 +1490 @@
-	
+
@@ -1489 +1502 @@
-      
+
@@ -1491 +1504 @@
-	return  p - buf;
+	return p - buf;
@@ -1507,2 +1520,4 @@
-struct net_device *init_atmel_card( unsigned short irq, unsigned long port, const AtmelFWType fw_type,  
-				    struct device *sys_dev, int (*card_present)(void *), void *card)
+struct net_device *init_atmel_card(unsigned short irq, unsigned long port,
+				   const AtmelFWType fw_type,
+				   struct device *sys_dev,
+				   int (*card_present)(void *), void *card)
@@ -1509,0 +1525 @@
+	struct proc_dir_entry *ent;
@@ -1517 +1533 @@
-		printk(KERN_ERR "atmel:  Couldn't alloc_etherdev\n");
+		printk(KERN_ERR "atmel: Couldn't alloc_etherdev\n");
@@ -1521 +1537 @@
-		printk(KERN_ERR "atmel:  Couldn't get name!\n");
+		printk(KERN_ERR "atmel: Couldn't get name!\n");
@@ -1553 +1569 @@
-	
+
@@ -1589 +1605 @@
-	
+
@@ -1600 +1616 @@
-	
+
@@ -1602 +1618 @@
-	
+
@@ -1604 +1620 @@
-		printk(KERN_ERR "%s: register interrupt %d failed, rc %d\n", dev->name, irq, rc );
+		printk(KERN_ERR "%s: register interrupt %d failed, rc %d\n", dev->name, irq, rc);
@@ -1608 +1624 @@
-	if (!request_region(dev->base_addr, 32, 
+	if (!request_region(dev->base_addr, 32,
@@ -1612 +1628 @@
-	
+
@@ -1615 +1631 @@
-	
+
@@ -1620 +1636 @@
-	
+
@@ -1622,3 +1638,5 @@
-	
-	create_proc_read_entry ("driver/atmel", 0, NULL, atmel_read_proc, priv);	
-	
+
+	ent = create_proc_read_entry ("driver/atmel", 0, NULL, atmel_read_proc, priv);
+	if (!ent)
+		printk(KERN_WARNING "atmel: unable to create /proc entry.\n");
+
@@ -1629 +1647 @@
-	
+
@@ -1632,2 +1650,2 @@
-	
- err_out_res:
+
+err_out_res:
@@ -1635 +1653 @@
- err_out_irq:
+err_out_irq:
@@ -1637 +1655 @@
- err_out_free:
+err_out_free:
@@ -1647 +1665 @@
-		
+
@@ -1649 +1667 @@
-	if (priv->bus_type == BUS_TYPE_PCCARD) 
+	if (priv->bus_type == BUS_TYPE_PCCARD)
@@ -1652 +1670 @@
-	
+
@@ -1678 +1696 @@
-		
+
@@ -1681 +1699 @@
-			 return -E2BIG ;
+			 return -E2BIG;
@@ -1684 +1702 @@
-		
+
@@ -1703 +1721 @@
-		dwrq->length = priv->new_SSID_size + 1;
+		dwrq->length = priv->new_SSID_size;
@@ -1707 +1725 @@
-		dwrq->length = priv->SSID_size + 1;
+		dwrq->length = priv->SSID_size;
@@ -1709 +1727 @@
-	
+
@@ -1771 +1789 @@
-		if (index == current_index && 
+		if (index == current_index &&
@@ -1776 +1794 @@
-				priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;
+				priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;
@@ -1779 +1797 @@
-				priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;
+				priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;
@@ -1786 +1804 @@
-		if ( index>=0 && index < 4 ) {
+		if (index >= 0 && index < 4) {
@@ -1790 +1808 @@
-			if(!dwrq->flags & IW_ENCODE_MODE) {
+			if (!dwrq->flags & IW_ENCODE_MODE) {
@@ -1795 +1813 @@
-	if(dwrq->flags & IW_ENCODE_DISABLED) {
+	if (dwrq->flags & IW_ENCODE_DISABLED) {
@@ -1797 +1815 @@
-		priv->encryption_level = 0; 	
+		priv->encryption_level = 0;
@@ -1809 +1827 @@
-	if(dwrq->flags & IW_ENCODE_RESTRICTED)
+	if (dwrq->flags & IW_ENCODE_RESTRICTED)
@@ -1811 +1829 @@
-       	if(dwrq->flags & IW_ENCODE_OPEN) 
+	if(dwrq->flags & IW_ENCODE_OPEN)
@@ -1813 +1831 @@
-       
+
@@ -1817 +1834,0 @@
-
@@ -1825 +1842 @@
-	
+
@@ -1846,3 +1862,0 @@
-	
-	return 0;
-}
@@ -1850,6 +1863,0 @@
-static int atmel_get_name(struct net_device *dev,
-			  struct iw_request_info *info,
-			  char *cwrq,
-			  char *extra)
-{
-	strcpy(cwrq, "IEEE 802.11-DS");
@@ -1859,4 +1867,4 @@
-static int atmel_set_rate(struct net_device *dev,
-			  struct iw_request_info *info,
-			  struct iw_param *vwrq,
-			  char *extra)
+static int atmel_set_encodeext(struct net_device *dev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu,
+			    char *extra)
@@ -1865,19 +1873,40 @@
-	
-	if (vwrq->fixed == 0) {
-		priv->tx_rate = 3;
-		priv->auto_tx_rate = 1;
-	} else {
-		priv->auto_tx_rate = 0;
-		
-		/* Which type of value ? */
-		if((vwrq->value < 4) && (vwrq->value >= 0)) {
-			/* Setting by rate index */
-		priv->tx_rate = vwrq->value;
-		} else {
-		/* Setting by frequency value */
-			switch (vwrq->value) {
-			case  1000000: priv->tx_rate = 0; break;
-			case  2000000: priv->tx_rate = 1; break;
-			case  5500000: priv->tx_rate = 2; break;
-			case 11000000: priv->tx_rate = 3; break;
-			default: return -EINVAL;
+	struct iw_point *encoding = &wrqu->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	int idx, key_len, alg = ext->alg, set_key = 1;
+
+	/* Determine and validate the key index */
+	idx = encoding->flags & IW_ENCODE_INDEX;
+	if (idx) {
+		if (idx < 1 || idx > WEP_KEYS)
+			return -EINVAL;
+		idx--;
+	} else
+		idx = priv->default_key;
+
+	if (encoding->flags & IW_ENCODE_DISABLED)
+	    alg = IW_ENCODE_ALG_NONE;
+
+	if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+		priv->default_key = idx;
+		set_key = ext->key_len > 0 ? 1 : 0;
+	}
+
+	if (set_key) {
+		/* Set the requested key first */
+		switch (alg) {
+		case IW_ENCODE_ALG_NONE:
+			priv->wep_is_on = 0;
+			priv->encryption_level = 0;
+			priv->pairwise_cipher_suite = CIPHER_SUITE_NONE;
+			break;
+		case IW_ENCODE_ALG_WEP:
+			if (ext->key_len > 5) {
+				priv->wep_key_len[idx] = 13;
+				priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_128;
+				priv->encryption_level = 2;
+			} else if (ext->key_len > 0) {
+				priv->wep_key_len[idx] = 5;
+				priv->pairwise_cipher_suite = CIPHER_SUITE_WEP_64;
+				priv->encryption_level = 1;
+			} else {
+				return -EINVAL;
@@ -1884,0 +1914,7 @@
+			priv->wep_is_on = 1;
+			memset(priv->wep_keys[idx], 0, 13);
+			key_len = min ((int)ext->key_len, priv->wep_key_len[idx]);
+			memcpy(priv->wep_keys[idx], ext->key, key_len);
+			break;
+		default:
+			return -EINVAL;
@@ -1891,4 +1927,4 @@
-static int atmel_set_mode(struct net_device *dev,
-			  struct iw_request_info *info,
-			  __u32 *uwrq,
-			  char *extra)
+static int atmel_get_encodeext(struct net_device *dev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu,
+			    char *extra)
@@ -1896,0 +1933,3 @@
+	struct iw_point *encoding = &wrqu->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	int idx, max_key_len;
@@ -1898 +1937,2 @@
-	if (*uwrq != IW_MODE_ADHOC && *uwrq != IW_MODE_INFRA)
+	max_key_len = encoding->length - sizeof(*ext);
+	if (max_key_len < 0)
@@ -1901,3 +1941,7 @@
-	priv->operating_mode = *uwrq;
-	return -EINPROGRESS;  
-}
+	idx = encoding->flags & IW_ENCODE_INDEX;
+	if (idx) {
+		if (idx < 1 || idx > WEP_KEYS)
+			return -EINVAL;
+		idx--;
+	} else
+		idx = priv->default_key;
@@ -1905,6 +1949,2 @@
-static int atmel_get_mode(struct net_device *dev,
-			  struct iw_request_info *info,
-			  __u32 *uwrq,
-			  char *extra)
-{
-	struct atmel_private *priv = netdev_priv(dev);
+	encoding->flags = idx + 1;
+	memset(ext, 0, sizeof(*ext));
@@ -1912 +1952,15 @@
-	*uwrq = priv->operating_mode;
+	if (!priv->wep_is_on) {
+		ext->alg = IW_ENCODE_ALG_NONE;
+		ext->key_len = 0;
+		encoding->flags |= IW_ENCODE_DISABLED;
+	} else {
+		if (priv->encryption_level > 0)
+			ext->alg = IW_ENCODE_ALG_WEP;
+		else
+			return -EINVAL;
+
+		ext->key_len = priv->wep_key_len[idx];
+		memcpy(ext->key, priv->wep_keys[idx], ext->key_len);
+		encoding->flags |= IW_ENCODE_ENABLED;
+	}
+
@@ -1916,2 +1970,143 @@
-static int atmel_get_rate(struct net_device *dev,
-			 struct iw_request_info *info,
+static int atmel_set_auth(struct net_device *dev,
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct atmel_private *priv = netdev_priv(dev);
+	struct iw_param *param = &wrqu->param;
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_WPA_VERSION:
+	case IW_AUTH_CIPHER_PAIRWISE:
+	case IW_AUTH_CIPHER_GROUP:
+	case IW_AUTH_KEY_MGMT:
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+	case IW_AUTH_PRIVACY_INVOKED:
+		/*
+		 * atmel does not use these parameters
+		 */
+		break;
+
+	case IW_AUTH_DROP_UNENCRYPTED:
+		priv->exclude_unencrypted = param->value ? 1 : 0;
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG: {
+			if (param->value & IW_AUTH_ALG_SHARED_KEY) {
+				priv->exclude_unencrypted = 1;
+			} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {
+				priv->exclude_unencrypted = 0;
+			} else
+				return -EINVAL;
+			break;
+		}
+
+	case IW_AUTH_WPA_ENABLED:
+		/* Silently accept disable of WPA */
+		if (param->value > 0)
+			return -EOPNOTSUPP;
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+	return -EINPROGRESS;
+}
+
+static int atmel_get_auth(struct net_device *dev,
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct atmel_private *priv = netdev_priv(dev);
+	struct iw_param *param = &wrqu->param;
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_DROP_UNENCRYPTED:
+		param->value = priv->exclude_unencrypted;
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG:
+		if (priv->exclude_unencrypted == 1)
+			param->value = IW_AUTH_ALG_SHARED_KEY;
+		else
+			param->value = IW_AUTH_ALG_OPEN_SYSTEM;
+		break;
+
+	case IW_AUTH_WPA_ENABLED:
+		param->value = 0;
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+	return 0;
+}
+
+
+static int atmel_get_name(struct net_device *dev,
+			  struct iw_request_info *info,
+			  char *cwrq,
+			  char *extra)
+{
+	strcpy(cwrq, "IEEE 802.11-DS");
+	return 0;
+}
+
+static int atmel_set_rate(struct net_device *dev,
+			  struct iw_request_info *info,
+			  struct iw_param *vwrq,
+			  char *extra)
+{
+	struct atmel_private *priv = netdev_priv(dev);
+
+	if (vwrq->fixed == 0) {
+		priv->tx_rate = 3;
+		priv->auto_tx_rate = 1;
+	} else {
+		priv->auto_tx_rate = 0;
+
+		/* Which type of value ? */
+		if ((vwrq->value < 4) && (vwrq->value >= 0)) {
+			/* Setting by rate index */
+			priv->tx_rate = vwrq->value;
+		} else {
+		/* Setting by frequency value */
+			switch (vwrq->value) {
+			case  1000000: priv->tx_rate = 0; break;
+			case  2000000: priv->tx_rate = 1; break;
+			case  5500000: priv->tx_rate = 2; break;
+			case 11000000: priv->tx_rate = 3; break;
+			default: return -EINVAL;
+			}
+		}
+	}
+
+	return -EINPROGRESS;
+}
+
+static int atmel_set_mode(struct net_device *dev,
+			  struct iw_request_info *info,
+			  __u32 *uwrq,
+			  char *extra)
+{
+	struct atmel_private *priv = netdev_priv(dev);
+
+	if (*uwrq != IW_MODE_ADHOC && *uwrq != IW_MODE_INFRA)
+		return -EINVAL;
+
+	priv->operating_mode = *uwrq;
+	return -EINPROGRESS;
+}
+
+static int atmel_get_mode(struct net_device *dev,
+			  struct iw_request_info *info,
+			  __u32 *uwrq,
+			  char *extra)
+{
+	struct atmel_private *priv = netdev_priv(dev);
+
+	*uwrq = priv->operating_mode;
+	return 0;
+}
+
+static int atmel_get_rate(struct net_device *dev,
+			 struct iw_request_info *info,
@@ -1965,3 +2160,3 @@
-	
-	if(!vwrq->disabled && (vwrq->flags & IW_RETRY_LIMIT)) {
-		if(vwrq->flags & IW_RETRY_MAX)
+
+	if (!vwrq->disabled && (vwrq->flags & IW_RETRY_LIMIT)) {
+		if (vwrq->flags & IW_RETRY_MAX)
@@ -1976 +2171 @@
-		return -EINPROGRESS;		
+		return -EINPROGRESS;
@@ -1978 +2173 @@
-	   
+
@@ -1992 +2187 @@
-	if((vwrq->flags & IW_RETRY_MAX)) {
+	if (vwrq->flags & IW_RETRY_MAX) {
@@ -1998 +2193 @@
-		if(priv->long_retry != priv->short_retry)
+		if (priv->long_retry != priv->short_retry)
@@ -2013 +2208 @@
-	if(vwrq->disabled)
+	if (vwrq->disabled)
@@ -2015 +2210 @@
-	if((rthr < 0) || (rthr > 2347)) {
+	if ((rthr < 0) || (rthr > 2347)) {
@@ -2019 +2214 @@
-	
+
@@ -2029 +2224 @@
-	
+
@@ -2045 +2240 @@
-	if(vwrq->disabled)
+	if (vwrq->disabled)
@@ -2047 +2242 @@
-	if((fthr < 256) || (fthr > 2346)) {
+	if ((fthr < 256) || (fthr > 2346)) {
@@ -2052 +2247 @@
-	
+
@@ -2080 +2275 @@
-	
+
@@ -2082,3 +2277,3 @@
-	if((fwrq->e == 1) &&
-	   (fwrq->m >= (int) 241200000) &&
-	   (fwrq->m <= (int) 248700000)) {
+	if ((fwrq->e == 1) &&
+	    (fwrq->m >= (int) 241200000) &&
+	    (fwrq->m <= (int) 248700000)) {
@@ -2087 +2282 @@
-		while((c < 14) && (f != frequency_list[c]))
+		while ((c < 14) && (f != frequency_list[c]))
@@ -2094 +2289 @@
-	if((fwrq->m > 1000) || (fwrq->e > 0))
+	if ((fwrq->m > 1000) || (fwrq->e > 0))
@@ -2102 +2297 @@
-		} 
+		}
@@ -2133 +2328 @@
-	
+
@@ -2145 +2340 @@
-		
+
@@ -2148 +2343 @@
-	
+
@@ -2153 +2348 @@
-	
+
@@ -2166 +2361 @@
-	
+
@@ -2169,2 +2364,2 @@
-	
-	for(i=0; i<priv->BSS_list_entries; i++) { 
+
+	for (i = 0; i < priv->BSS_list_entries; i++) {
@@ -2182 +2377 @@
-		
+
@@ -2186 +2381 @@
-	
+
@@ -2191 +2386 @@
-		
+
@@ -2199 +2393,0 @@
-		
@@ -2204,2 +2398,2 @@
-	dwrq->flags = 0;   
-	
+	dwrq->flags = 0;
+
@@ -2216 +2410 @@
-	int k,i,j;
+	int k, i, j;
@@ -2229 +2423 @@
-		for(k = 0, i = channel_table[j].min; i <= channel_table[j].max; i++) {
+		for (k = 0, i = channel_table[j].min; i <= channel_table[j].max; i++) {
@@ -2231 +2425 @@
-			range->freq[k].m = frequency_list[i-1] * 100000;
+			range->freq[k].m = frequency_list[i - 1] * 100000;
@@ -2236 +2430 @@
-	
+
@@ -2264 +2458 @@
-	
+
@@ -2268 +2462 @@
-	
+
@@ -2287 +2481,2 @@
-	static const u8 bcast[] = { 255, 255, 255, 255, 255, 255 };
+	static const u8 any[] = { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };
+	static const u8 off[] = { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };
@@ -2292,2 +2487,3 @@
-	
-	if (memcmp(bcast, awrq->sa_data, 6) == 0) {
+
+	if (!memcmp(any, awrq->sa_data, 6) ||
+	    !memcmp(off, awrq->sa_data, 6)) {
@@ -2300,2 +2496,2 @@
-	
-	for(i=0; i<priv->BSS_list_entries; i++) {
+
+	for (i = 0; i < priv->BSS_list_entries; i++) {
@@ -2316 +2512 @@
-		
+
@@ -2319 +2515 @@
-	
+
@@ -2328 +2524 @@
-static const iw_handler		atmel_handler[] =
+static const iw_handler atmel_handler[] =
@@ -2331 +2527 @@
-	(iw_handler) atmel_get_name,    	/* SIOCGIWNAME */
+	(iw_handler) atmel_get_name,		/* SIOCGIWNAME */
@@ -2338,2 +2534,2 @@
-	(iw_handler) NULL,                  	/* SIOCSIWSENS */
-	(iw_handler) NULL,           		/* SIOCGIWSENS */
+	(iw_handler) NULL,			/* SIOCSIWSENS */
+	(iw_handler) NULL,			/* SIOCGIWSENS */
@@ -2353 +2549 @@
-	(iw_handler) NULL,       		/* SIOCGIWAPLIST */
+	(iw_handler) NULL,			/* SIOCGIWAPLIST */
@@ -2358,2 +2554,2 @@
-	(iw_handler) NULL,         		/* SIOCSIWNICKN */
-	(iw_handler) NULL,          		/* SIOCGIWNICKN */
+	(iw_handler) NULL,			/* SIOCSIWNICKN */
+	(iw_handler) NULL,			/* SIOCGIWNICKN */
@@ -2368,2 +2564,2 @@
-	(iw_handler) NULL,         		/* SIOCSIWTXPOW */
-	(iw_handler) NULL,          		/* SIOCGIWTXPOW */
+	(iw_handler) NULL,			/* SIOCSIWTXPOW */
+	(iw_handler) NULL,			/* SIOCGIWTXPOW */
@@ -2375,0 +2572,9 @@
+	(iw_handler) NULL,			/* -- hole -- */
+	(iw_handler) NULL,			/* -- hole -- */
+	(iw_handler) NULL,			/* SIOCSIWGENIE */
+	(iw_handler) NULL,			/* SIOCGIWGENIE */
+	(iw_handler) atmel_set_auth,		/* SIOCSIWAUTH */
+	(iw_handler) atmel_get_auth,		/* SIOCGIWAUTH */
+	(iw_handler) atmel_set_encodeext,	/* SIOCSIWENCODEEXT */
+	(iw_handler) atmel_get_encodeext,	/* SIOCGIWENCODEEXT */
+	(iw_handler) NULL,			/* SIOCSIWPMKSA */
@@ -2378,2 +2583 @@
-
-static const iw_handler		atmel_private_handler[] =
+static const iw_handler atmel_private_handler[] =
@@ -2386,2 +2590,2 @@
-	unsigned char __user *data;		
-	unsigned short len;		
+	unsigned char __user *data;
+	unsigned short len;
@@ -2390,5 +2594,4 @@
-	
-#define ATMELFWL SIOCIWFIRSTPRIV
-#define ATMELIDIFC ATMELFWL + 1
-#define ATMELRD ATMELFWL + 2
-#define ATMELMAGIC 0x51807 
+#define ATMELFWL	SIOCIWFIRSTPRIV
+#define ATMELIDIFC	ATMELFWL + 1
+#define ATMELRD		ATMELFWL + 2
+#define ATMELMAGIC 0x51807
@@ -2398,4 +2601,18 @@
-/*{ cmd,         set_args,                            get_args, name } */
-  { ATMELFWL, IW_PRIV_TYPE_BYTE | IW_PRIV_SIZE_FIXED | sizeof (atmel_priv_ioctl), IW_PRIV_TYPE_NONE, "atmelfwl" },
-  { ATMELIDIFC, IW_PRIV_TYPE_NONE, IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1, "atmelidifc" },
-  { ATMELRD, IW_PRIV_TYPE_CHAR | REGDOMAINSZ, IW_PRIV_TYPE_NONE, "regdomain" },
+	{
+		.cmd = ATMELFWL,
+		.set_args = IW_PRIV_TYPE_BYTE
+				| IW_PRIV_SIZE_FIXED
+				| sizeof (atmel_priv_ioctl),
+		.get_args = IW_PRIV_TYPE_NONE,
+		.name = "atmelfwl"
+	}, {
+		.cmd = ATMELIDIFC,
+		.set_args = IW_PRIV_TYPE_NONE,
+		.get_args = IW_PRIV_TYPE_INT | IW_PRIV_SIZE_FIXED | 1,
+		.name = "atmelidifc"
+	}, {
+		.cmd = ATMELRD,
+		.set_args = IW_PRIV_TYPE_CHAR | REGDOMAINSZ,
+		.get_args = IW_PRIV_TYPE_NONE,
+		.name = "regdomain"
+	},
@@ -2404 +2621 @@
-static const struct iw_handler_def	atmel_handler_def =
+static const struct iw_handler_def atmel_handler_def =
@@ -2407,2 +2624,2 @@
-	.num_private	= sizeof(atmel_private_handler)/sizeof(iw_handler), 
-	.num_private_args = sizeof(atmel_private_args)/sizeof(struct iw_priv_args), 
+	.num_private	= sizeof(atmel_private_handler)/sizeof(iw_handler),
+	.num_private_args = sizeof(atmel_private_args)/sizeof(struct iw_priv_args),
@@ -2410 +2627 @@
-	.private	= (iw_handler *) atmel_private_handler, 
+	.private	= (iw_handler *) atmel_private_handler,
@@ -2422 +2639 @@
-	char domain[REGDOMAINSZ+1];
+	char domain[REGDOMAINSZ + 1];
@@ -2426 +2643 @@
-		wrq->u.param.value = ATMELMAGIC;		
+		wrq->u.param.value = ATMELMAGIC;
@@ -2428 +2645 @@
-	
+
@@ -2452 +2669 @@
-		
+
@@ -2464 +2681 @@
-		
+
@@ -2487 +2704 @@
-		
+
@@ -2491 +2708 @@
-		
+
@@ -2495 +2712 @@
-	
+
@@ -2506 +2723 @@
-}; 
+};
@@ -2511 +2728 @@
-		
+
@@ -2514 +2731 @@
-	
+
@@ -2516 +2733 @@
-		
+
@@ -2543 +2760 @@
-	
+
@@ -2557 +2774 @@
-	
+
@@ -2559 +2776 @@
-	
+
@@ -2562,2 +2779,2 @@
-	
-	cmd.channel = (priv->channel & 0x7f); 
+
+	cmd.channel = (priv->channel & 0x7f);
@@ -2565 +2782 @@
-	cmd.BSS_type = cpu_to_le16(priv->operating_mode == IW_MODE_ADHOC ? 
+	cmd.BSS_type = cpu_to_le16(priv->operating_mode == IW_MODE_ADHOC ?
@@ -2567 +2784 @@
-	
+
@@ -2594 +2811 @@
- 	atmel_send_command(priv, CMD_Join, &cmd, sizeof(cmd));
+	atmel_send_command(priv, CMD_Join, &cmd, sizeof(cmd));
@@ -2597 +2813,0 @@
-
@@ -2603 +2819 @@
-		u8 BSS_type;                                
+		u8 BSS_type;
@@ -2615 +2831 @@
-	atmel_send_command(priv, CMD_Start, &cmd, sizeof(cmd)); 
+	atmel_send_command(priv, CMD_Start, &cmd, sizeof(cmd));
@@ -2618 +2834,2 @@
-static void handle_beacon_probe(struct atmel_private *priv, u16 capability, u8 channel)
+static void handle_beacon_probe(struct atmel_private *priv, u16 capability,
+				u8 channel)
@@ -2621 +2838 @@
-	int new = capability  & C80211_MGMT_CAPABILITY_ShortPreamble ? 
+	int new = capability  & C80211_MGMT_CAPABILITY_ShortPreamble ?
@@ -2629 +2846 @@
-		
+
@@ -2635 +2852 @@
-	
+
@@ -2639 +2856 @@
-		
+
@@ -2642 +2859 @@
-		else 
+		else
@@ -2644 +2861 @@
-	} 
+	}
@@ -2647,2 +2864,2 @@
-
-static void send_authentication_request(struct atmel_private *priv, u16 system, u8 *challenge, int challenge_len)
+static void send_authentication_request(struct atmel_private *priv, u16 system,
+					u8 *challenge, int challenge_len)
@@ -2652,3 +2869,3 @@
-	
-	header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH); 
-	header.duration_id	= cpu_to_le16(0x8000);	
+
+	header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH);
+	header.duration_id = cpu_to_le16(0x8000);
@@ -2659,2 +2876,2 @@
-	
-	if (priv->wep_is_on && priv->CurrentAuthentTransactionSeqNum != 1) 
+
+	if (priv->wep_is_on && priv->CurrentAuthentTransactionSeqNum != 1)
@@ -2663,2 +2880,2 @@
-	
-	auth.alg = cpu_to_le16(system); 
+
+	auth.alg = cpu_to_le16(system);
@@ -2668 +2885 @@
-	priv->ExpectedAuthentTransactionSeqNum = priv->CurrentAuthentTransactionSeqNum+1; 
+	priv->ExpectedAuthentTransactionSeqNum = priv->CurrentAuthentTransactionSeqNum+1;
@@ -2670 +2887 @@
-	
+
@@ -2688 +2905 @@
-		u16 listen_interval; 
+		u16 listen_interval;
@@ -2697,2 +2914,2 @@
-		
-	header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT | 
+
+	header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT |
@@ -2703 +2920 @@
-	memcpy(header.addr1, priv->CurrentBSSID, 6); 
+	memcpy(header.addr1, priv->CurrentBSSID, 6);
@@ -2705 +2922 @@
-	memcpy(header.addr3, priv->CurrentBSSID, 6); 
+	memcpy(header.addr3, priv->CurrentBSSID, 6);
@@ -2714 +2931 @@
-	
+
@@ -2717 +2934 @@
-		memcpy(body.ap,  priv->CurrentBSSID, 6);
+		memcpy(body.ap, priv->CurrentBSSID, 6);
@@ -2724,2 +2941,2 @@
-		
-	ssid_el_p[0]= C80211_MGMT_ElementID_SSID;
+
+	ssid_el_p[0] = C80211_MGMT_ElementID_SSID;
@@ -2735 +2952,2 @@
-static int is_frame_from_current_bss(struct atmel_private *priv, struct ieee80211_hdr_4addr *header)
+static int is_frame_from_current_bss(struct atmel_private *priv,
+				     struct ieee80211_hdr_4addr *header)
@@ -2748 +2966 @@
-	
+
@@ -2751 +2969 @@
-			
+
@@ -2753,3 +2971,4 @@
-		/* Select a BSS with the max-RSSI but of the same type and of the same WEP mode
-		   and that it is not marked as 'bad' (i.e. we had previously failed to connect to
-		   this BSS with the settings that we currently use) */
+		/* Select a BSS with the max-RSSI but of the same type and of
+		   the same WEP mode and that it is not marked as 'bad' (i.e.
+		   we had previously failed to connect to this BSS with the
+		   settings that we currently use) */
@@ -2757 +2976 @@
-		for(i=0; i<priv->BSS_list_entries; i++) { 
+		for (i = 0; i < priv->BSS_list_entries; i++) {
@@ -2759 +2978 @@
-			    ((!priv->wep_is_on && !priv->BSSinfo[i].UsingWEP) || 
+			    ((!priv->wep_is_on && !priv->BSSinfo[i].UsingWEP) ||
@@ -2765 +2983,0 @@
-			
@@ -2769,2 +2987,2 @@
-		
-	for(i=0; i<priv->BSS_list_entries; i++) {
+
+	for (i = 0; i < priv->BSS_list_entries; i++) {
@@ -2784,4 +3002,4 @@
-
-static void store_bss_info(struct atmel_private *priv, struct ieee80211_hdr_4addr *header,
-			   u16 capability, u16 beacon_period, u8 channel, u8 rssi, 
-			   u8 ssid_len, u8 *ssid, int is_beacon)
+static void store_bss_info(struct atmel_private *priv,
+			   struct ieee80211_hdr_4addr *header, u16 capability,
+			   u16 beacon_period, u8 channel, u8 rssi, u8 ssid_len,
+			   u8 *ssid, int is_beacon)
@@ -2791,3 +3009,3 @@
-		
-	for (index = -1, i = 0; i < priv->BSS_list_entries; i++) 
-		if (memcmp(bss, priv->BSSinfo[i].BSSID, 6) == 0) 
+
+	for (index = -1, i = 0; i < priv->BSS_list_entries; i++)
+		if (memcmp(bss, priv->BSSinfo[i].BSSID, 6) == 0)
@@ -2796 +3014 @@
-        /* If we process a probe and an entry from this BSS exists 
+        /* If we process a probe and an entry from this BSS exists
@@ -2823,2 +3041,2 @@
-	
-	priv->BSSinfo[index].preamble = capability  & C80211_MGMT_CAPABILITY_ShortPreamble ? 
+
+	priv->BSSinfo[index].preamble = capability & C80211_MGMT_CAPABILITY_ShortPreamble ?
@@ -2834,2 +3052,2 @@
-	
-	if (status == C80211_MGMT_SC_Success && !priv->wep_is_on) { 
+
+	if (status == C80211_MGMT_SC_Success && !priv->wep_is_on) {
@@ -2845 +3063 @@
-		} 
+		}
@@ -2847,2 +3065,3 @@
-		
-	if (status == C80211_MGMT_SC_Success && priv->wep_is_on) { 
+
+	if (status == C80211_MGMT_SC_Success && priv->wep_is_on) {
+		int should_associate = 0;
@@ -2852,5 +3071,13 @@
-				
-		if (trans_seq_no == 0x0002 &&
-		    auth->el_id == C80211_MGMT_ElementID_ChallengeText) {
-			send_authentication_request(priv, system, auth->chall_text, auth->chall_text_len);
-			return;
+
+		if (system == C80211_MGMT_AAN_OPENSYSTEM) {
+			if (trans_seq_no == 0x0002) {
+				should_associate = 1;
+			}
+		} else if (system == C80211_MGMT_AAN_SHAREDKEY) {
+			if (trans_seq_no == 0x0002 &&
+			    auth->el_id == C80211_MGMT_ElementID_ChallengeText) {
+				send_authentication_request(priv, system, auth->chall_text, auth->chall_text_len);
+				return;
+			} else if (trans_seq_no == 0x0004) {
+				should_associate = 1;
+			}
@@ -2858,2 +3085,2 @@
-		
-		if (trans_seq_no == 0x0004) {
+
+		if (should_associate) {
@@ -2868 +3095 @@
-			} 
+			}
@@ -2870,3 +3097,3 @@
-	}			
-	
-	if (status == C80211_MGMT_SC_AuthAlgNotSupported) {
+	}
+
+	if (status == WLAN_STATUS_NOT_SUPPORTED_AUTH_ALG) {
@@ -2874 +3101 @@
-		if (system ==  C80211_MGMT_AAN_OPENSYSTEM) {
+		if (system == WLAN_AUTH_OPEN) {
@@ -2876 +3103,3 @@
-			send_authentication_request(priv, C80211_MGMT_AAN_SHAREDKEY, NULL, 0);
+			priv->exclude_unencrypted = 1;
+			send_authentication_request(priv, WLAN_AUTH_SHARED_KEY, NULL, 0);
+			return;
@@ -2879 +3108 @@
-			
+
@@ -2881 +3110 @@
-			
+
@@ -2888,2 +3117 @@
-	
-	
+
@@ -2905,2 +3133,2 @@
-	
-       	u16 status = le16_to_cpu(ass_resp->status);
+
+	u16 status = le16_to_cpu(ass_resp->status);
@@ -2908,2 +3136,4 @@
-   	u16 rates_len = ass_resp->length > 4 ? 4 : ass_resp->length;
-	
+	u16 rates_len = ass_resp->length > 4 ? 4 : ass_resp->length;
+
+	union iwreq_data wrqu;
+
@@ -2912 +3142 @@
-	
+
@@ -2918,3 +3148,5 @@
-		
-		atmel_set_mib16(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_STATION_ID_POS, ass_id & 0x3fff);
-		atmel_set_mib(priv, Phy_Mib_Type, PHY_MIB_RATE_SET_POS, ass_resp->rates, rates_len);
+
+		atmel_set_mib16(priv, Mac_Mgmt_Mib_Type,
+				MAC_MGMT_MIB_STATION_ID_POS, ass_id & 0x3fff);
+		atmel_set_mib(priv, Phy_Mib_Type,
+			      PHY_MIB_RATE_SET_POS, ass_resp->rates, rates_len);
@@ -2923,2 +3155,4 @@
-			atmel_set_mib8(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_PS_MODE_POS,  ACTIVE_MODE);
-			atmel_set_mib16(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_LISTEN_INTERVAL_POS, 1);
+			atmel_set_mib8(priv, Mac_Mgmt_Mib_Type,
+				       MAC_MGMT_MIB_PS_MODE_POS, ACTIVE_MODE);
+			atmel_set_mib16(priv, Mac_Mgmt_Mib_Type,
+					MAC_MGMT_MIB_LISTEN_INTERVAL_POS, 1);
@@ -2927,2 +3161,4 @@
-			atmel_set_mib8(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_PS_MODE_POS,  PS_MODE);
-			atmel_set_mib16(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_LISTEN_INTERVAL_POS, 2);
+			atmel_set_mib8(priv, Mac_Mgmt_Mib_Type,
+				       MAC_MGMT_MIB_PS_MODE_POS,  PS_MODE);
+			atmel_set_mib16(priv, Mac_Mgmt_Mib_Type,
+					MAC_MGMT_MIB_LISTEN_INTERVAL_POS, 2);
@@ -2930 +3166 @@
-		
+
@@ -2933,0 +3170,8 @@
+
+		/* Send association event to userspace */
+		wrqu.data.length = 0;
+		wrqu.data.flags = 0;
+		memcpy(wrqu.ap_addr.sa_data, priv->CurrentBSSID, ETH_ALEN);
+		wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+		wireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);
+
@@ -2936 +3180 @@
-	
+
@@ -2946 +3190 @@
-		
+
@@ -2956 +3200 @@
-	
+
@@ -2959,2 +3203,2 @@
-	
-	if(priv->connect_to_any_BSS) {
+
+	if (priv->connect_to_any_BSS) {
@@ -2963,2 +3207,2 @@
-		
-		if ((bss_index = retrieve_bss(priv)) != -1) 
+
+		if ((bss_index = retrieve_bss(priv)) != -1)
@@ -2966 +3209,0 @@
-		
@@ -2980 +3223 @@
-	
+
@@ -2988,2 +3231,4 @@
-		atmel_set_mib8(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_PS_MODE_POS,  ACTIVE_MODE);
-		atmel_set_mib16(priv, Mac_Mgmt_Mib_Type, MAC_MGMT_MIB_LISTEN_INTERVAL_POS, 1);
+		atmel_set_mib8(priv, Mac_Mgmt_Mib_Type,
+			       MAC_MGMT_MIB_PS_MODE_POS,  ACTIVE_MODE);
+		atmel_set_mib16(priv, Mac_Mgmt_Mib_Type,
+				MAC_MGMT_MIB_LISTEN_INTERVAL_POS, 1);
@@ -2991 +3236 @@
-		
+
@@ -2993 +3238 @@
-	priv->channel = bss->channel & 0x7f; 	
+	priv->channel = bss->channel & 0x7f;
@@ -2995 +3240 @@
-	
+
@@ -2998 +3243,2 @@
-		atmel_set_mib8(priv, Local_Mib_Type, LOCAL_MIB_PREAMBLE_TYPE, bss->preamble);
+		atmel_set_mib8(priv, Local_Mib_Type,
+			       LOCAL_MIB_PREAMBLE_TYPE, bss->preamble);
@@ -3000 +3246 @@
-	
+
@@ -3006 +3252 @@
-		
+
@@ -3014 +3260 @@
-	
+
@@ -3017 +3263 @@
-	else 
+	else
@@ -3021 +3266,0 @@
-
@@ -3025 +3270 @@
-	
+
@@ -3030,2 +3275,2 @@
-		
-		if ((bss_index = retrieve_bss(priv)) != -1) 
+
+		if ((bss_index = retrieve_bss(priv)) != -1)
@@ -3035,3 +3280,2 @@
-		
-	} 
-}	
+	}
+}
@@ -3053,2 +3297,2 @@
-	if((rssi + old) % 2)
-		priv->wstats.qual.level =  ((rssi + old)/2) + 1;
+	if ((rssi + old) % 2)
+		priv->wstats.qual.level = (rssi + old) / 2 + 1;
@@ -3056 +3300 @@
-		priv->wstats.qual.level =  ((rssi + old)/2);		
+		priv->wstats.qual.level = (rssi + old) / 2;
@@ -3063 +3307 @@
-	unsigned long time_diff = (jiffies - priv->last_qual)/HZ;
+	unsigned long time_diff = (jiffies - priv->last_qual) / HZ;
@@ -3066,2 +3310,2 @@
-		priv->wstats.qual.qual = priv->wstats.qual.qual/2;
-		priv->wstats.qual.qual += 
+		priv->wstats.qual.qual = priv->wstats.qual.qual / 2;
+		priv->wstats.qual.qual +=
@@ -3076,2 +3320,3 @@
-static void atmel_management_frame(struct atmel_private *priv, struct ieee80211_hdr_4addr *header, 
-		      u16 frame_len, u8 rssi)
+static void atmel_management_frame(struct atmel_private *priv,
+				   struct ieee80211_hdr_4addr *header,
+				   u16 frame_len, u8 rssi)
@@ -3080,3 +3325,4 @@
-	
-	switch (subtype = le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_STYPE) {
-	case C80211_SUBTYPE_MGMT_BEACON :
+
+	subtype = le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_STYPE;
+	switch (subtype) {
+	case C80211_SUBTYPE_MGMT_BEACON:
@@ -3084 +3330 @@
-		
+
@@ -3102 +3348 @@
-			
+
@@ -3110 +3356 @@
-			if (frame_len < 14 || frame_len < ssid_length + 15) 
+			if (frame_len < 14 || frame_len < ssid_length + 15)
@@ -3118 +3364 @@
-		       
+
@@ -3121 +3367 @@
-				if (is_frame_from_current_bss(priv, header)) { 
+				if (is_frame_from_current_bss(priv, header)) {
@@ -3135,5 +3381,7 @@
-			
-			if (priv->station_state == STATION_STATE_SCANNING ) 
-				store_bss_info(priv, header, capability, beacon_interval, channel,
-					       rssi, ssid_length, &beacon->rates_el_id,
-					       subtype == C80211_SUBTYPE_MGMT_BEACON) ;
+
+			if (priv->station_state == STATION_STATE_SCANNING)
+				store_bss_info(priv, header, capability,
+					       beacon_interval, channel, rssi,
+					       ssid_length,
+					       &beacon->rates_el_id,
+					       subtype == C80211_SUBTYPE_MGMT_BEACON);
@@ -3142 +3390 @@
-		
+
@@ -3147 +3395 @@
-	
+
@@ -3149 +3397 @@
-		
+
@@ -3152,2 +3400,2 @@
-		
-		if (priv->station_state == STATION_STATE_ASSOCIATING || 
+
+		if (priv->station_state == STATION_STATE_ASSOCIATING ||
@@ -3156 +3404 @@
-		
+
@@ -3160,2 +3408,2 @@
-		if (priv->station_is_associated && 
-		    priv->operating_mode == IW_MODE_INFRA && 
+		if (priv->station_is_associated &&
+		    priv->operating_mode == IW_MODE_INFRA &&
@@ -3165 +3413 @@
-			
+
@@ -3169 +3417 @@
-		
+
@@ -3180 +3428 @@
-		
+
@@ -3188,27 +3436,3 @@
-  struct net_device *dev = (struct net_device *) a;
-  struct atmel_private *priv = netdev_priv(dev);
-  unsigned long flags;
-  
-  /* Check if the card has been yanked. */
-  if (priv->card && priv->present_callback && 
-      !(*priv->present_callback)(priv->card))
-	  return;
-  
-  spin_lock_irqsave(&priv->irqlock, flags);
-
-  switch (priv->station_state) {
-	  
-  case STATION_STATE_AUTHENTICATING:
-	  if (priv->AuthenticationRequestRetryCnt >= MAX_AUTHENTICATION_RETRIES) {
-		  atmel_enter_state(priv, STATION_STATE_MGMT_ERROR);
-		  priv->station_is_associated = 0;
-		  priv->AuthenticationRequestRetryCnt = 0;
-		  restart_search(priv);
-	  } else {
-		  priv->AuthenticationRequestRetryCnt++;
-		  priv->CurrentAuthentTransactionSeqNum = 0x0001;
-		  mod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);
-		  send_authentication_request(priv, C80211_MGMT_AAN_OPENSYSTEM, NULL, 0);
-	  }
-	  
-	  break;
+	struct net_device *dev = (struct net_device *) a;
+	struct atmel_private *priv = netdev_priv(dev);
+	unsigned long flags;
@@ -3216,11 +3440,4 @@
-  case STATION_STATE_ASSOCIATING:
-	  if (priv->AssociationRequestRetryCnt == MAX_ASSOCIATION_RETRIES) {
-		  atmel_enter_state(priv, STATION_STATE_MGMT_ERROR);
-		  priv->station_is_associated = 0;
-		  priv->AssociationRequestRetryCnt = 0;
-		  restart_search(priv);
-	  } else {
-		  priv->AssociationRequestRetryCnt++;
-		  mod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);
-		  send_association_request(priv, 0);
-	  }
+	/* Check if the card has been yanked. */
+	if (priv->card && priv->present_callback &&
+		!(*priv->present_callback)(priv->card))
+		return;
@@ -3228,13 +3445 @@
-	  break;
-		  
-  case STATION_STATE_REASSOCIATING:	
-	  if (priv->ReAssociationRequestRetryCnt == MAX_ASSOCIATION_RETRIES) {
-		  atmel_enter_state(priv, STATION_STATE_MGMT_ERROR);
-		  priv->station_is_associated = 0;
-		  priv->ReAssociationRequestRetryCnt = 0;
-		  restart_search(priv);
-	  } else {
-		  priv->ReAssociationRequestRetryCnt++;
-		  mod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);
-		  send_association_request(priv, 1);
-	  }
+	spin_lock_irqsave(&priv->irqlock, flags);
@@ -3241,0 +3447,17 @@
+	switch (priv->station_state) {
+
+	case STATION_STATE_AUTHENTICATING:
+		if (priv->AuthenticationRequestRetryCnt >= MAX_AUTHENTICATION_RETRIES) {
+			atmel_enter_state(priv, STATION_STATE_MGMT_ERROR);
+			priv->station_is_associated = 0;
+			priv->AuthenticationRequestRetryCnt = 0;
+			restart_search(priv);
+		} else {
+			int auth = C80211_MGMT_AAN_OPENSYSTEM;
+			priv->AuthenticationRequestRetryCnt++;
+			priv->CurrentAuthentTransactionSeqNum = 0x0001;
+			mod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);
+			if (priv->wep_is_on && priv->exclude_unencrypted)
+				auth = C80211_MGMT_AAN_SHAREDKEY;
+			send_authentication_request(priv, auth, NULL, 0);
+	  }
@@ -3243,2 +3465,12 @@
-  
-  default:
+
+	case STATION_STATE_ASSOCIATING:
+		if (priv->AssociationRequestRetryCnt == MAX_ASSOCIATION_RETRIES) {
+			atmel_enter_state(priv, STATION_STATE_MGMT_ERROR);
+			priv->station_is_associated = 0;
+			priv->AssociationRequestRetryCnt = 0;
+			restart_search(priv);
+		} else {
+			priv->AssociationRequestRetryCnt++;
+			mod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);
+			send_association_request(priv, 0);
+		}
@@ -3246,3 +3478,19 @@
-  }
-  
-  spin_unlock_irqrestore(&priv->irqlock, flags);
+
+	case STATION_STATE_REASSOCIATING:
+		if (priv->ReAssociationRequestRetryCnt == MAX_ASSOCIATION_RETRIES) {
+			atmel_enter_state(priv, STATION_STATE_MGMT_ERROR);
+			priv->station_is_associated = 0;
+			priv->ReAssociationRequestRetryCnt = 0;
+			restart_search(priv);
+		} else {
+			priv->ReAssociationRequestRetryCnt++;
+			mod_timer(&priv->management_timer, jiffies + MGMT_JIFFIES);
+			send_association_request(priv, 1);
+		}
+		break;
+
+	default:
+		break;
+	}
+
+	spin_unlock_irqrestore(&priv->irqlock, flags);
@@ -3250 +3498 @@
-  
+
@@ -3256,2 +3504,2 @@
-	
-	if (status == CMD_STATUS_IDLE || 
+
+	if (status == CMD_STATUS_IDLE ||
@@ -3269 +3517 @@
-		}			
+		}
@@ -3271 +3519 @@
-		
+
@@ -3275 +3523 @@
-		
+
@@ -3282 +3530 @@
-			} else if (priv->operating_mode == IW_MODE_ADHOC && 
+			} else if (priv->operating_mode == IW_MODE_ADHOC &&
@@ -3292 +3540 @@
-		
+
@@ -3295 +3543 @@
-		
+
@@ -3298 +3546 @@
-		
+
@@ -3301 +3549 @@
-			atmel_enter_state(priv, STATION_STATE_READY);				
+			atmel_enter_state(priv, STATION_STATE_READY);
@@ -3312,0 +3561 @@
+				int auth = C80211_MGMT_AAN_OPENSYSTEM;
@@ -3315 +3564 @@
-				
+
@@ -3318 +3567,3 @@
-				send_authentication_request(priv, C80211_MGMT_AAN_SHAREDKEY, NULL, 0);
+				if (priv->wep_is_on && priv->exclude_unencrypted)
+					auth = C80211_MGMT_AAN_SHAREDKEY;
+				send_authentication_request(priv, auth, NULL, 0);
@@ -3322 +3573 @@
-		
+
@@ -3324 +3574,0 @@
-		
@@ -3336 +3586 @@
-	
+
@@ -3340 +3590 @@
-	
+
@@ -3345 +3595 @@
-	for (i =  LOOP_RETRY_LIMIT; i; i--) {
+	for (i = LOOP_RETRY_LIMIT; i; i--) {
@@ -3348,2 +3598,2 @@
-		
-		if (mr3 & MAC_BOOT_COMPLETE) 
+
+		if (mr3 & MAC_BOOT_COMPLETE)
@@ -3360 +3610 @@
-		
+
@@ -3365,6 +3615,6 @@
-	
-	/* now check for completion of MAC initialization through  
-	   the FunCtrl field of the IFACE, poll MR1 to detect completion of	  
-	   MAC initialization, check completion status, set interrupt mask,  
-	   enables interrupts and calls Tx and Rx initialization functions */  
-	
+
+	/* now check for completion of MAC initialization through
+	   the FunCtrl field of the IFACE, poll MR1 to detect completion of
+	   MAC initialization, check completion status, set interrupt mask,
+	   enables interrupts and calls Tx and Rx initialization functions */
+
@@ -3372,2 +3622,2 @@
-	
-	for (i =  LOOP_RETRY_LIMIT; i; i--) {
+
+	for (i = LOOP_RETRY_LIMIT; i; i--) {
@@ -3376,2 +3626,2 @@
-		
-		if (mr3 & MAC_INIT_COMPLETE) 
+
+		if (mr3 & MAC_INIT_COMPLETE)
@@ -3383 +3633 @@
-	
+
@@ -3385 +3635,2 @@
-		printk(KERN_ALERT "%s: MAC failed to initialise.\n", priv->dev->name);
+		printk(KERN_ALERT "%s: MAC failed to initialise.\n",
+				priv->dev->name);
@@ -3388 +3639 @@
-	
+
@@ -3401 +3652 @@
-	atmel_copy_to_host(priv->dev, (unsigned char *)iface, 
+	atmel_copy_to_host(priv->dev, (unsigned char *)iface,
@@ -3403 +3654 @@
-        
+
@@ -3427 +3678 @@
-	 
+
@@ -3429 +3680 @@
-	if (priv->bus_type == BUS_TYPE_PCCARD) 
+	if (priv->bus_type == BUS_TYPE_PCCARD)
@@ -3431 +3682 @@
-	
+
@@ -3434 +3685 @@
-	
+
@@ -3436 +3687 @@
-		/* No stored firmware so load a small stub which just 
+		/* No stored firmware so load a small stub which just
@@ -3445 +3696 @@
-		for (i =  LOOP_RETRY_LIMIT; i; i--) 
+		for (i = LOOP_RETRY_LIMIT; i; i--)
@@ -3454 +3705 @@
-			if (priv->bus_type == BUS_TYPE_PCCARD) 
+			if (priv->bus_type == BUS_TYPE_PCCARD)
@@ -3462 +3713 @@
-		atmel_write16(dev,  BSR, 1);	
+		atmel_write16(dev,  BSR, 1);
@@ -3472 +3723 @@
-			
+
@@ -3475 +3726 @@
-			if (priv->bus_type == BUS_TYPE_PCCARD) 
+			if (priv->bus_type == BUS_TYPE_PCCARD)
@@ -3481 +3732 @@
-	
+
@@ -3489 +3740 @@
-	
+
@@ -3493 +3743,0 @@
-static void build_wep_mib(struct atmel_private *priv)
@@ -3496,0 +3747 @@
+static void build_wep_mib(struct atmel_private *priv)
@@ -3499 +3750 @@
-		u8 wep_is_on;                 
+		u8 wep_is_on;
@@ -3503 +3754 @@
-		
+
@@ -3506 +3757 @@
-		
+
@@ -3508,2 +3759,2 @@
- 		u8 encryption_level; /* 0, 1, 2 */
-		u8 reserved2[3]; 
+		u8 encryption_level; /* 0, 1, 2 */
+		u8 reserved2[3];
@@ -3518 +3769 @@
-			mib.encryption_level = 1;	
+			mib.encryption_level = 1;
@@ -3525,2 +3776,2 @@
-	
-	for(i = 0; i < MAX_ENCRYPTION_KEYS;  i++)
+
+	for (i = 0; i < MAX_ENCRYPTION_KEYS; i++)
@@ -3528 +3779 @@
-		
+
@@ -3534 +3785 @@
-	/* This is for the later (WPA enabled) firmware. */	   
+	/* This is for the later (WPA enabled) firmware. */
@@ -3539 +3790 @@
-		u8 wep_is_on;                 
+		u8 wep_is_on;
@@ -3545 +3796 @@
-		
+
@@ -3548 +3799 @@
-		
+
@@ -3551 +3802 @@
-	
+
@@ -3557 +3808 @@
-	
+
@@ -3560 +3811 @@
-	
+
@@ -3562,2 +3813,3 @@
-		/* There's a comment in the Atmel code to the effect that this is only valid
-		   when still using WEP, it may need to be set to something to use WPA */
+		/* There's a comment in the Atmel code to the effect that this
+		   is only valid when still using WEP, it may need to be set to
+		   something to use WPA */
@@ -3565 +3817 @@
-		
+
@@ -3573 +3825 @@
-					mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-2] = priv->pairwise_cipher_suite; 
+					mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-2] = priv->pairwise_cipher_suite;
@@ -3578 +3830 @@
-					mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-2] = priv->group_cipher_suite;	
+					mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-2] = priv->group_cipher_suite;
@@ -3586 +3838 @@
-		
+
@@ -3588 +3840 @@
-	
+
@@ -3591,2 +3843,2 @@
-					
-static int reset_atmel_card(struct net_device *dev) 
+
+static int reset_atmel_card(struct net_device *dev)
@@ -3597 +3849 @@
-	   set all the Mib values which matter in the card to match 
+	   set all the Mib values which matter in the card to match
@@ -3603,2 +3855,2 @@
-	   This routine is also responsible for initialising some 
-	   hardware-specific fields in the atmel_private structure, 
+	   This routine is also responsible for initialising some
+	   hardware-specific fields in the atmel_private structure,
@@ -3610 +3862,2 @@
-	
+	int old_state = priv->station_state;
+
@@ -3613 +3866 @@
-	
+
@@ -3619 +3872 @@
-		
+
@@ -3621 +3874 @@
-	if (priv->bus_type == BUS_TYPE_PCCARD) 
+	if (priv->bus_type == BUS_TYPE_PCCARD)
@@ -3623 +3876 @@
-		
+
@@ -3626 +3879 @@
-		
+
@@ -3639 +3892 @@
-					       "%s: if not, use the firmware= module parameter.\n", 
+					       "%s: if not, use the firmware= module parameter.\n",
@@ -3644,2 +3897,2 @@
-					printk(KERN_ALERT 
-					       "%s: firmware %s is missing, cannot continue.\n", 
+					printk(KERN_ALERT
+					       "%s: firmware %s is missing, cannot continue.\n",
@@ -3657 +3910 @@
-				
+
@@ -3672,2 +3925,2 @@
-					printk(KERN_ALERT 
-					       "%s: firmware %s is missing, cannot start.\n", 
+					printk(KERN_ALERT
+					       "%s: firmware %s is missing, cannot start.\n",
@@ -3676 +3929 @@
-					return 0;	
+					return 0;
@@ -3679 +3932 @@
-			
+
@@ -3683 +3936 @@
-		
+
@@ -3689 +3942 @@
-			/* Remap */ 
+			/* Remap */
@@ -3711 +3964 @@
-	
+
@@ -3714 +3967 @@
-	
+
@@ -3721,3 +3974,3 @@
-	priv->tx_desc_free = priv->host_info.tx_desc_count;		
-	priv->tx_desc_head = 0;									
-	priv->tx_desc_tail = 0;									
+	priv->tx_desc_free = priv->host_info.tx_desc_count;
+	priv->tx_desc_head = 0;
+	priv->tx_desc_tail = 0;
@@ -3726,5 +3979,5 @@
-	priv->tx_buff_head = 0;	
-	priv->tx_buff_tail = 0;	
-		
-	configuration = atmel_rmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET)); 
-	atmel_wmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET), 
+	priv->tx_buff_head = 0;
+	priv->tx_buff_tail = 0;
+
+	configuration = atmel_rmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET));
+	atmel_wmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET),
@@ -3735,3 +3988,3 @@
-	
-	configuration = atmel_rmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET)); 
-	atmel_wmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET), 
+
+	configuration = atmel_rmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET));
+	atmel_wmem8(priv, atmel_hi(priv, IFACE_FUNC_CTRL_OFFSET),
@@ -3739 +3992 @@
-			
+
@@ -3741 +3994 @@
-		if (atmel_send_command_wait(priv, CMD_EnableRadio, NULL, 0) == 
+		if (atmel_send_command_wait(priv, CMD_EnableRadio, NULL, 0) ==
@@ -3743 +3996 @@
-			printk(KERN_INFO 
+			printk(KERN_INFO
@@ -3749 +4002 @@
-	
+
@@ -3758 +4011 @@
-	atmel_set_mib(priv, Mac_Address_Mib_Type, MAC_ADDR_MIB_MAC_ADDR_POS, 
+	atmel_set_mib(priv, Mac_Address_Mib_Type, MAC_ADDR_MIB_MAC_ADDR_POS,
@@ -3769 +4022,12 @@
-	
+
+	if (old_state == STATION_STATE_READY)
+	{
+		union iwreq_data wrqu;
+
+		wrqu.data.length = 0;
+		wrqu.data.flags = 0;
+		wrqu.ap_addr.sa_family = ARPHRD_ETHER;
+		memset(wrqu.ap_addr.sa_data, 0, ETH_ALEN);
+		wireless_send_event(priv->dev, SIOCGIWAP, &wrqu, NULL);
+	}
+
@@ -3773 +4037,2 @@
-static void atmel_send_command(struct atmel_private *priv, int command, void *cmd, int cmd_size)
+static void atmel_send_command(struct atmel_private *priv, int command,
+			       void *cmd, int cmd_size)
@@ -3776 +4041 @@
-		atmel_copy_to_card(priv->dev, atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET), 
+		atmel_copy_to_card(priv->dev, atmel_co(priv, CMD_BLOCK_PARAMETERS_OFFSET),
@@ -3778 +4043 @@
-	
+
@@ -3782,2 +4047,3 @@
-	
-static int atmel_send_command_wait(struct atmel_private *priv, int command, void *cmd, int cmd_size)
+
+static int atmel_send_command_wait(struct atmel_private *priv, int command,
+				   void *cmd, int cmd_size)
@@ -3786 +4052 @@
-	
+
@@ -3788 +4054 @@
-	
+
@@ -3791 +4057 @@
-		if (status != CMD_STATUS_IDLE && 
+		if (status != CMD_STATUS_IDLE &&
@@ -3796 +4062 @@
-	
+
@@ -3800 +4066 @@
-	} else { 
+	} else {
@@ -3804 +4070 @@
-	
+
@@ -3830 +4096,2 @@
-static void atmel_set_mib16(struct atmel_private *priv, u8 type, u8 index, u16 data)
+static void atmel_set_mib16(struct atmel_private *priv, u8 type, u8 index,
+			    u16 data)
@@ -3842 +4109,2 @@
-static void atmel_set_mib(struct atmel_private *priv, u8 type, u8 index, u8 *data, int data_len)
+static void atmel_set_mib(struct atmel_private *priv, u8 type, u8 index,
+			  u8 *data, int data_len)
@@ -3851 +4119 @@
-	
+
@@ -3856 +4124,2 @@
-static void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index, u8 *data, int data_len)
+static void atmel_get_mib(struct atmel_private *priv, u8 type, u8 index,
+			  u8 *data, int data_len)
@@ -3862 +4131 @@
-	
+
@@ -3865 +4134 @@
-	
+
@@ -3867 +4136 @@
-	atmel_copy_to_host(priv->dev, data, 
+	atmel_copy_to_host(priv->dev, data,
@@ -3876 +4145 @@
-	for (i = 0; data != inw(dev->base_addr + AR) && i<10; i++)
+	for (i = 0; data != inw(dev->base_addr + AR) && i < 10; i++)
@@ -3880 +4149,2 @@
-static void atmel_copy_to_card(struct net_device *dev, u16 dest, unsigned char *src, u16 len)
+static void atmel_copy_to_card(struct net_device *dev, u16 dest,
+			       unsigned char *src, u16 len)
@@ -3897 +4167,2 @@
-static void atmel_copy_to_host(struct net_device *dev, unsigned char *dest, u16 src, u16 len)
+static void atmel_copy_to_host(struct net_device *dev, unsigned char *dest,
+			       u16 src, u16 len)
@@ -3933,3 +4204,4 @@
-	
-	if (!i) return 0; /* timed out */
-	
+
+	if (!i)
+		return 0; /* timed out */
+
@@ -3939 +4211,2 @@
-		if (!j--) return 0; /* timed out */
+		if (!j--)
+			return 0; /* timed out */
@@ -3942 +4215 @@
-	
+
@@ -3948 +4221 @@
-       	atmel_writeAR(priv->dev, pos);	
+	atmel_writeAR(priv->dev, pos);
@@ -4020 +4293 @@
-				  controller (e.g. AT91M55800) timing and 4K 
+				  controller (e.g. AT91M55800) timing and 4K
@@ -4022 +4295 @@
-				 
+
@@ -4035 +4308 @@
-UNDEF_VECTOR:  
+UNDEF_VECTOR:
@@ -4037 +4310 @@
-SWI_VECTOR:            
+SWI_VECTOR:
@@ -4039 +4312 @@
-IABORT_VECTOR: 
+IABORT_VECTOR:
@@ -4041,2 +4314,2 @@
-DABORT_VECTOR:         
-RESERVED_VECTOR:    
+DABORT_VECTOR:
+RESERVED_VECTOR:
@@ -4044 +4317 @@
-IRQ_VECTOR:    
+IRQ_VECTOR:
@@ -4046 +4319 @@
-FIQ_VECTOR:    
+FIQ_VECTOR:
@@ -4052 +4325 @@
-			
+
@@ -4064 +4337 @@
-	
+
@@ -4097 +4370 @@
-	
+
@@ -4113 +4386 @@
-DELAYLOOP:	
+DELAYLOOP:
@@ -4117 +4390 @@
-DELAY9_done:	
+DELAY9_done:
@@ -4119 +4392 @@
-.endfunc	
+.endfunc
@@ -4148 +4421 @@
-.func NVRAM_Init, NVRAM_INIT	
+.func NVRAM_Init, NVRAM_INIT
@@ -4154 +4427 @@
-SP_loop1:	
+SP_loop1:
@@ -4160,2 +4433,2 @@
-	str	r0, [r1, #SP_TDR] 
-SP_loop2:	
+	str	r0, [r1, #SP_TDR]
+SP_loop2:
@@ -4167 +4440 @@
-SP_loop3:	
+SP_loop3:
@@ -4176 +4449 @@
-	
+
@@ -4188 +4461 @@
-	add	r0, r0, #NVRAM_CMD_READ 
+	add	r0, r0, #NVRAM_CMD_READ
@@ -4192 +4465 @@
-_local1:	
+_local1:
@@ -4214 +4487 @@
-_local4:	
+_local4:
@@ -4228 +4501 @@
-_local5:	
+_local5:
@@ -4236 +4509 @@
-_local7:	
+_local7:
@@ -4241 +4514 @@
-_local8:	
+_local8:
--- ./projects/linux/linux-2.6.16/drivers/net/wireless/atmel.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/net/wireless/atmel.c	2006-06-18 03:49:35.000000000 +0200
@@ -140,38 +139,0 @@
-#define C80211_SUBTYPE_MGMT_ASS_REQUEST                 0x00
-#define C80211_SUBTYPE_MGMT_ASS_RESPONSE                0x10
-#define C80211_SUBTYPE_MGMT_REASS_REQUEST               0x20
-#define C80211_SUBTYPE_MGMT_REASS_RESPONSE              0x30
-#define C80211_SUBTYPE_MGMT_ProbeRequest                0x40
-#define C80211_SUBTYPE_MGMT_ProbeResponse               0x50
-#define C80211_SUBTYPE_MGMT_BEACON                      0x80
-#define C80211_SUBTYPE_MGMT_ATIM                        0x90
-#define C80211_SUBTYPE_MGMT_DISASSOSIATION              0xA0
-#define C80211_SUBTYPE_MGMT_Authentication              0xB0
-#define C80211_SUBTYPE_MGMT_Deauthentication    0xC0
-
-#define C80211_MGMT_AAN_OPENSYSTEM              0x0000
-#define C80211_MGMT_AAN_SHAREDKEY               0x0001
-
-#define C80211_MGMT_CAPABILITY_ESS              0x0001  // see 802.11 p.58
-#define C80211_MGMT_CAPABILITY_IBSS             0x0002  //      - " -
-#define C80211_MGMT_CAPABILITY_CFPollable       0x0004  //      - " -
-#define C80211_MGMT_CAPABILITY_CFPollRequest    0x0008  //      - " -
-#define C80211_MGMT_CAPABILITY_Privacy          0x0010  //      - " -
-
-#define C80211_MGMT_SC_Success                  0
-#define C80211_MGMT_SC_Unspecified              1
-#define C80211_MGMT_SC_SupportCapabilities      10
-#define C80211_MGMT_SC_ReassDenied              11
-#define C80211_MGMT_SC_AssDenied                12
-#define C80211_MGMT_SC_AuthAlgNotSupported      13
-#define C80211_MGMT_SC_AuthTransSeqNumError     14
-#define C80211_MGMT_SC_AuthRejectChallenge      15
-#define C80211_MGMT_SC_AuthRejectTimeout        16
-#define C80211_MGMT_SC_AssDeniedHandleAP        17
-#define C80211_MGMT_SC_AssDeniedBSSRate         18
-
-#define C80211_MGMT_ElementID_SSID              0
-#define C80211_MGMT_ElementID_SupportedRates    1
-#define C80211_MGMT_ElementID_ChallengeText     16
-#define C80211_MGMT_CAPABILITY_ShortPreamble    0x0020
-
@@ -2838 +2800 @@
-	int new = capability  & C80211_MGMT_CAPABILITY_ShortPreamble ?
+	int new = capability & MFIE_TYPE_POWER_CONSTRAINT ?
@@ -2924 +2886 @@
-	body.capability = cpu_to_le16(C80211_MGMT_CAPABILITY_ESS);
+	body.capability = cpu_to_le16(WLAN_CAPABILITY_ESS);
@@ -2926 +2888 @@
-		body.capability |= cpu_to_le16(C80211_MGMT_CAPABILITY_Privacy);
+		body.capability |= cpu_to_le16(WLAN_CAPABILITY_PRIVACY);
@@ -2928 +2890 @@
-		body.capability |= cpu_to_le16(C80211_MGMT_CAPABILITY_ShortPreamble);
+		body.capability |= cpu_to_le16(MFIE_TYPE_POWER_CONSTRAINT);
@@ -2942 +2904 @@
-	ssid_el_p[0] = C80211_MGMT_ElementID_SSID;
+	ssid_el_p[0] = MFIE_TYPE_SSID;
@@ -2945 +2907 @@
-	ssid_el_p[2 + priv->SSID_size] = C80211_MGMT_ElementID_SupportedRates;
+	ssid_el_p[2 + priv->SSID_size] = MFIE_TYPE_RATES;
@@ -3007 +2969 @@
-	u8 *bss = capability & C80211_MGMT_CAPABILITY_ESS ? header->addr2 : header->addr3;
+	u8 *bss = capability & WLAN_CAPABILITY_ESS ? header->addr2 : header->addr3;
@@ -3033 +2995 @@
-	priv->BSSinfo[index].UsingWEP = capability & C80211_MGMT_CAPABILITY_Privacy;
+	priv->BSSinfo[index].UsingWEP = capability & WLAN_CAPABILITY_PRIVACY;
@@ -3037 +2999 @@
-	if (capability & C80211_MGMT_CAPABILITY_IBSS)
+	if (capability & WLAN_CAPABILITY_IBSS)
@@ -3039 +3001 @@
-	else if (capability & C80211_MGMT_CAPABILITY_ESS)
+	else if (capability & WLAN_CAPABILITY_ESS)
@@ -3042 +3004 @@
-	priv->BSSinfo[index].preamble = capability & C80211_MGMT_CAPABILITY_ShortPreamble ?
+	priv->BSSinfo[index].preamble = capability & MFIE_TYPE_POWER_CONSTRAINT ?
@@ -3053 +3015 @@
-	if (status == C80211_MGMT_SC_Success && !priv->wep_is_on) {
+	if (status == WLAN_STATUS_SUCCESS && !priv->wep_is_on) {
@@ -3066 +3028 @@
-	if (status == C80211_MGMT_SC_Success && priv->wep_is_on) {
+	if (status == WLAN_STATUS_SUCCESS && priv->wep_is_on) {
@@ -3072 +3034 @@
-		if (system == C80211_MGMT_AAN_OPENSYSTEM) {
+		if (system == WLAN_AUTH_OPEN) {
@@ -3076 +3038 @@
-		} else if (system == C80211_MGMT_AAN_SHAREDKEY) {
+		} else if (system == WLAN_AUTH_SHARED_KEY) {
@@ -3078 +3040 @@
-			    auth->el_id == C80211_MGMT_ElementID_ChallengeText) {
+			    auth->el_id == MFIE_TYPE_CHALLENGE) {
@@ -3143,2 +3105,2 @@
-	if (status == C80211_MGMT_SC_Success) {
-		if (subtype == C80211_SUBTYPE_MGMT_ASS_RESPONSE)
+	if (status == WLAN_STATUS_SUCCESS) {
+		if (subtype == IEEE80211_STYPE_ASSOC_RESP)
@@ -3181,3 +3143,3 @@
-	if (subtype == C80211_SUBTYPE_MGMT_ASS_RESPONSE &&
-	    status != C80211_MGMT_SC_AssDeniedBSSRate &&
-	    status != C80211_MGMT_SC_SupportCapabilities &&
+	if (subtype == IEEE80211_STYPE_ASSOC_RESP &&
+	    status != WLAN_STATUS_ASSOC_DENIED_RATES &&
+	    status != WLAN_STATUS_CAPS_UNSUPPORTED &&
@@ -3191,3 +3153,3 @@
-	if (subtype == C80211_SUBTYPE_MGMT_REASS_RESPONSE &&
-	    status != C80211_MGMT_SC_AssDeniedBSSRate &&
-	    status != C80211_MGMT_SC_SupportCapabilities &&
+	if (subtype == IEEE80211_STYPE_REASSOC_RESP &&
+	    status != WLAN_STATUS_ASSOC_DENIED_RATES &&
+	    status != WLAN_STATUS_CAPS_UNSUPPORTED &&
@@ -3328,2 +3290,2 @@
-	case C80211_SUBTYPE_MGMT_BEACON:
-	case C80211_SUBTYPE_MGMT_ProbeResponse:
+	case IEEE80211_STYPE_BEACON:
+	case IEEE80211_STYPE_PROBE_RESP:
@@ -3387 +3349 @@
-					       subtype == C80211_SUBTYPE_MGMT_BEACON);
+					       subtype == IEEE80211_STYPE_BEACON);
@@ -3391 +3353 @@
-	case C80211_SUBTYPE_MGMT_Authentication:
+	case IEEE80211_STYPE_AUTH:
@@ -3398,2 +3360,2 @@
-	case C80211_SUBTYPE_MGMT_ASS_RESPONSE:
-	case C80211_SUBTYPE_MGMT_REASS_RESPONSE:
+	case IEEE80211_STYPE_ASSOC_RESP:
+	case IEEE80211_STYPE_REASSOC_RESP:
@@ -3407 +3369 @@
-	case C80211_SUBTYPE_MGMT_DISASSOSIATION:
+	case IEEE80211_STYPE_DISASSOC:
@@ -3420 +3382 @@
-	case C80211_SUBTYPE_MGMT_Deauthentication:
+	case IEEE80211_STYPE_DEAUTH:
@@ -3456 +3418 @@
-			int auth = C80211_MGMT_AAN_OPENSYSTEM;
+			int auth = WLAN_AUTH_OPEN;
@@ -3461 +3423 @@
-				auth = C80211_MGMT_AAN_SHAREDKEY;
+				auth = WLAN_AUTH_SHARED_KEY;
@@ -3503,0 +3466 @@
+	union iwreq_data wrqu;
@@ -3527,0 +3491 @@
+			int notify_scan_complete = 1;
@@ -3535,0 +3500 @@
+				notify_scan_complete = 0;
@@ -3537,0 +3503,5 @@
+			if (notify_scan_complete) {
+				wrqu.data.length = 0;
+				wrqu.data.flags = 0;
+				wireless_send_event(priv->dev, SIOCGIWSCAN, &wrqu, NULL);
+			}
@@ -3549,0 +3520,3 @@
+			wrqu.data.length = 0;
+			wrqu.data.flags = 0;
+			wireless_send_event(priv->dev, SIOCGIWSCAN, &wrqu, NULL);
@@ -3561 +3534 @@
-				int auth = C80211_MGMT_AAN_OPENSYSTEM;
+				int auth = WLAN_AUTH_OPEN;
@@ -3568 +3541 @@
-					auth = C80211_MGMT_AAN_SHAREDKEY;
+					auth = WLAN_AUTH_SHARED_KEY;
--- ./projects/linux/linux-2.6.17/drivers/net/wireless/atmel.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/net/wireless/atmel.c	2006-09-20 05:42:06.000000000 +0200
@@ -42 +41,0 @@
-#include <linux/config.h>
@@ -1581 +1580 @@
-	if ((rc = request_irq(dev->irq, service_interrupt, SA_SHIRQ, dev->name, dev))) {
+	if ((rc = request_irq(dev->irq, service_interrupt, IRQF_SHARED, dev->name, dev))) {
--- ./projects/linux/linux-2.6.18/drivers/net/wireless/atmel.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/net/wireless/atmel.c	2006-11-29 22:57:37.000000000 +0100
@@ -1148 +1148 @@
-static irqreturn_t service_interrupt(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t service_interrupt(int irq, void *dev_id)
@@ -1659 +1659 @@
-		if (dwrq->length > MAX_SSID_LENGTH + 1)
+		if (dwrq->length > MAX_SSID_LENGTH)
@@ -1664,2 +1664,2 @@
-		memcpy(priv->new_SSID, extra, dwrq->length - 1);
-		priv->new_SSID_size = dwrq->length - 1;
+		memcpy(priv->new_SSID, extra, dwrq->length);
+		priv->new_SSID_size = dwrq->length;
@@ -1681 +1680,0 @@
-		extra[priv->new_SSID_size] = '\0';
@@ -1685 +1683,0 @@
-		extra[priv->SSID_size] = '\0';
@@ -2123 +2121 @@
-		if (vwrq->flags & IW_RETRY_MAX)
+		if (vwrq->flags & IW_RETRY_LONG)
@@ -2125 +2123 @@
-		else if (vwrq->flags & IW_RETRY_MIN)
+		else if (vwrq->flags & IW_RETRY_SHORT)
@@ -2147,3 +2145,3 @@
-	/* Note : by default, display the min retry number */
-	if (vwrq->flags & IW_RETRY_MAX) {
-		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_MAX;
+	/* Note : by default, display the short retry number */
+	if (vwrq->flags & IW_RETRY_LONG) {
+		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;
@@ -2155 +2153 @@
-			vwrq->flags |= IW_RETRY_MIN;
+			vwrq->flags |= IW_RETRY_SHORT;
--- ./projects/linux/linux-2.6.19/drivers/net/wireless/atmel.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/net/wireless/atmel.c	2007-02-04 19:44:54.000000000 +0100
@@ -598 +598 @@
-static int reset_atmel_card(struct net_device *dev );
+static int reset_atmel_card(struct net_device *dev);
@@ -786,0 +787 @@
+	static const u8 SNAP_RFC1024[6] = { 0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00 };
@@ -791 +791,0 @@
-	u8 SNAP_RFC1024[6] = {0xaa, 0xaa, 0x03, 0x00, 0x00, 0x00};
@@ -1196 +1196 @@
-		for (i = 0; i < sizeof(irq_order)/sizeof(u8); i++)
+		for (i = 0; i < ARRAY_SIZE(irq_order); i++)
@@ -1348 +1348 @@
-		for (i = 0; i < sizeof(channel_table)/sizeof(channel_table[0]); i++)
+		for (i = 0; i < ARRAY_SIZE(channel_table); i++)
@@ -1351 +1351 @@
-		if (i == sizeof(channel_table)/sizeof(channel_table[0])) {
+		if (i == ARRAY_SIZE(channel_table)) {
@@ -1396 +1396 @@
-	for (i = 0; i < sizeof(channel_table)/sizeof(channel_table[0]); i++)
+	for (i = 0; i < ARRAY_SIZE(channel_table); i++)
@@ -1440 +1440 @@
-		for (i = 0; i < sizeof(channel_table)/sizeof(channel_table[0]); i++)
+		for (i = 0; i < ARRAY_SIZE(channel_table); i++)
@@ -1739 +1739 @@
-		if(!(dwrq->flags & IW_ENCODE_NOKEY)) {
+		if (!(dwrq->flags & IW_ENCODE_NOKEY)) {
@@ -1910 +1910 @@
-	
+
@@ -2345,0 +2346,8 @@
+		/* Add quality statistics */
+		iwe.cmd = IWEVQUAL;
+		iwe.u.qual.level = priv->BSSinfo[i].RSSI;
+		iwe.u.qual.qual  = iwe.u.qual.level;
+		/* iwe.u.qual.noise  = SOMETHING */
+		current_ev = iwe_stream_add_event(current_ev, extra + IW_SCAN_MAX_DATA , &iwe, IW_EV_QUAL_LEN);
+
+
@@ -2376 +2384 @@
-	for (j = 0; j < sizeof(channel_table)/sizeof(channel_table[0]); j++)
+	for (j = 0; j < ARRAY_SIZE(channel_table); j++)
@@ -2582,3 +2590,3 @@
-	.num_standard	= sizeof(atmel_handler)/sizeof(iw_handler),
-	.num_private	= sizeof(atmel_private_handler)/sizeof(iw_handler),
-	.num_private_args = sizeof(atmel_private_args)/sizeof(struct iw_priv_args),
+	.num_standard	= ARRAY_SIZE(atmel_handler),
+	.num_private	= ARRAY_SIZE(atmel_private_handler),
+	.num_private_args = ARRAY_SIZE(atmel_private_args),
@@ -2648 +2656 @@
-		for (i = 0; i < sizeof(channel_table)/sizeof(channel_table[0]); i++) {
+		for (i = 0; i < ARRAY_SIZE(channel_table); i++) {
--- ./projects/linux/linux-2.6.20/drivers/net/wireless/atmel.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/net/wireless/atmel.c	2007-04-26 05:08:32.000000000 +0200
@@ -45 +44,0 @@
-#include <linux/sched.h>
--- ./projects/linux/linux-2.6.21/drivers/net/wireless/atmel.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/net/wireless/atmel.c	2007-07-09 01:32:17.000000000 +0200
@@ -830 +830 @@
-		memcpy(&header.addr1, skb->data, 6);
+		skb_copy_from_linear_data(skb, &header.addr1, 6);
@@ -837 +837 @@
-		memcpy(&header.addr3, skb->data, 6);
+		skb_copy_from_linear_data(skb, &header.addr3, 6);
@@ -923 +922,0 @@
-	skb->dev = priv->dev;
@@ -1031 +1029,0 @@
-				skb->dev = priv->dev;
--- ./projects/linux/linux-2.6.23/drivers/net/wireless/atmel.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/net/wireless/atmel.c	2008-01-24 23:58:37.000000000 +0100
@@ -1486,0 +1487 @@
+	DECLARE_MAC_BUF(mac);
@@ -1601,4 +1602,2 @@
-	printk(KERN_INFO "%s: Atmel at76c50x. Version %d.%d. MAC %.2x:%.2x:%.2x:%.2x:%.2x:%.2x\n",
-	       dev->name, DRIVER_MAJOR, DRIVER_MINOR,
-	       dev->dev_addr[0], dev->dev_addr[1], dev->dev_addr[2],
-	       dev->dev_addr[3], dev->dev_addr[4], dev->dev_addr[5] );
+	printk(KERN_INFO "%s: Atmel at76c50x. Version %d.%d. MAC %s\n",
+	       dev->name, DRIVER_MAJOR, DRIVER_MINOR, print_mac(mac, dev->dev_addr));
@@ -1606 +1604,0 @@
-	SET_MODULE_OWNER(dev);
--- ./projects/linux/linux-2.6.24/drivers/net/wireless/atmel.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/net/wireless/atmel.c	2008-04-17 04:49:44.000000000 +0200
@@ -1762 +1762 @@
-			if (!dwrq->flags & IW_ENCODE_MODE) {
+			if (!(dwrq->flags & IW_ENCODE_MODE))
@@ -1764 +1763,0 @@
-			}
@@ -2679,3 +2678,3 @@
-	u16 alg;
-	u16 trans_seq;
-	u16 status;
+	__le16 alg;
+	__le16 trans_seq;
+	__le16 status;
@@ -2716,3 +2715,3 @@
-		u16 BSS_type;
-		u16 min_channel_time;
-		u16 max_channel_time;
+		__le16 BSS_type;
+		__le16 min_channel_time;
+		__le16 max_channel_time;
@@ -2761 +2760 @@
-		u16 timeout;
+		__le16 timeout;
@@ -2866,2 +2865,2 @@
-		u16 capability;
-		u16 listen_interval;
+		__le16 capability;
+		__le16 listen_interval;
@@ -3088,3 +3087,3 @@
-		u16 capability;
-		u16 status;
-		u16 ass_id;
+		__le16 capability;
+		__le16 status;
+		__le16 ass_id;
@@ -3297,3 +3296,3 @@
-				u64 timestamp;
-				u16 interval;
-				u16 capability;
+				__le64 timestamp;
+				__le16 interval;
+				__le16 capability;
--- ./projects/linux/linux-2.6.25/drivers/net/wireless/atmel.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/net/wireless/atmel.c	2008-07-13 23:51:29.000000000 +0200
@@ -49,0 +50 @@
+#include <asm/byteorder.h>
@@ -63 +63,0 @@
-#include <linux/byteorder/generic.h>
@@ -68,0 +69 @@
+#include <linux/jiffies.h>
@@ -519 +520 @@
-	time_t last_survey;
+	unsigned long last_survey;
@@ -2286 +2287 @@
-	if ((jiffies - priv->last_survey) > (20 * HZ))
+	if (time_after(jiffies, priv->last_survey + 20 * HZ))
--- ./projects/linux/linux-2.6.26/drivers/net/wireless/atmel.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/net/wireless/atmel.c	2008-10-10 00:13:53.000000000 +0200
@@ -436 +435,0 @@
-	struct net_device_stats	stats;	// device stats
@@ -563 +562 @@
-			       unsigned char *src, u16 len);
+			       const unsigned char *src, u16 len);
@@ -697 +696 @@
-				priv->stats.tx_packets++;
+				priv->dev->stats.tx_packets++;
@@ -699 +698 @@
-				priv->stats.tx_errors++;
+				priv->dev->stats.tx_errors++;
@@ -795 +794 @@
-		priv->stats.tx_errors++;
+		dev->stats.tx_errors++;
@@ -801 +800 @@
-		priv->stats.tx_errors++;
+		dev->stats.tx_errors++;
@@ -818 +817 @@
-		priv->stats.tx_dropped++;
+		dev->stats.tx_dropped++;
@@ -854 +853 @@
-	priv->stats.tx_bytes += len;
+	dev->stats.tx_bytes += len;
@@ -898 +897 @@
-		priv->stats.rx_dropped++;
+		priv->dev->stats.rx_dropped++;
@@ -911 +910 @@
-			priv->stats.rx_crc_errors++;
+			priv->dev->stats.rx_crc_errors++;
@@ -927,2 +926,2 @@
-	priv->stats.rx_bytes += 12 + msdu_size;
-	priv->stats.rx_packets++;
+	priv->dev->stats.rx_bytes += 12 + msdu_size;
+	priv->dev->stats.rx_packets++;
@@ -994 +993 @@
-				priv->stats.rx_crc_errors++;
+				priv->dev->stats.rx_crc_errors++;
@@ -1012 +1011 @@
-				priv->stats.rx_crc_errors++;
+				priv->dev->stats.rx_crc_errors++;
@@ -1024 +1023 @@
-				priv->stats.rx_dropped++;
+				priv->dev->stats.rx_dropped++;
@@ -1034,2 +1033,2 @@
-				priv->stats.rx_bytes += priv->frag_len + 12;
-				priv->stats.rx_packets++;
+				priv->dev->stats.rx_bytes += priv->frag_len + 12;
+				priv->dev->stats.rx_packets++;
@@ -1060 +1059 @@
-				priv->stats.rx_errors++;
+				priv->dev->stats.rx_errors++;
@@ -1068 +1067 @@
-			priv->stats.rx_errors++;
+			priv->dev->stats.rx_errors++;
@@ -1126 +1125 @@
-					priv->stats.rx_crc_errors++;
+					priv->dev->stats.rx_crc_errors++;
@@ -1253,6 +1251,0 @@
-static struct net_device_stats *atmel_get_stats(struct net_device *dev)
-{
-	struct atmel_private *priv = netdev_priv(dev);
-	return &priv->stats;
-}
-
@@ -1314 +1307 @@
-	int i, channel;
+	int i, channel, err;
@@ -1338,2 +1331,3 @@
-	if (!reset_atmel_card(dev))
-		return -EAGAIN;
+	err = reset_atmel_card(dev);
+	if (err)
+		return err;
@@ -1521,2 +1514,0 @@
-	memset(&priv->stats, 0, sizeof(priv->stats));
-	memset(&priv->wstats, 0, sizeof(priv->wstats));
@@ -1571 +1562,0 @@
-	dev->get_stats = atmel_get_stats;
@@ -2323 +2314,3 @@
-		current_ev = iwe_stream_add_event(current_ev, extra + IW_SCAN_MAX_DATA, &iwe, IW_EV_ADDR_LEN);
+		current_ev = iwe_stream_add_event(info, current_ev,
+						  extra + IW_SCAN_MAX_DATA,
+						  &iwe, IW_EV_ADDR_LEN);
@@ -2330 +2323,3 @@
-		current_ev = iwe_stream_add_point(current_ev, extra + IW_SCAN_MAX_DATA, &iwe, priv->BSSinfo[i].SSID);
+		current_ev = iwe_stream_add_point(info, current_ev,
+						  extra + IW_SCAN_MAX_DATA,
+						  &iwe, priv->BSSinfo[i].SSID);
@@ -2334 +2329,3 @@
-		current_ev = iwe_stream_add_event(current_ev, extra + IW_SCAN_MAX_DATA, &iwe, IW_EV_UINT_LEN);
+		current_ev = iwe_stream_add_event(info, current_ev,
+						  extra + IW_SCAN_MAX_DATA,
+						  &iwe, IW_EV_UINT_LEN);
@@ -2339 +2336,3 @@
-		current_ev = iwe_stream_add_event(current_ev, extra + IW_SCAN_MAX_DATA, &iwe, IW_EV_FREQ_LEN);
+		current_ev = iwe_stream_add_event(info, current_ev,
+						  extra + IW_SCAN_MAX_DATA,
+						  &iwe, IW_EV_FREQ_LEN);
@@ -2346 +2345,3 @@
-		current_ev = iwe_stream_add_event(current_ev, extra + IW_SCAN_MAX_DATA , &iwe, IW_EV_QUAL_LEN);
+		current_ev = iwe_stream_add_event(info, current_ev,
+						  extra + IW_SCAN_MAX_DATA,
+						  &iwe, IW_EV_QUAL_LEN);
@@ -2355 +2356,3 @@
-		current_ev = iwe_stream_add_point(current_ev, extra + IW_SCAN_MAX_DATA, &iwe, NULL);
+		current_ev = iwe_stream_add_point(info, current_ev,
+						  extra + IW_SCAN_MAX_DATA,
+						  &iwe, NULL);
@@ -3062 +3065,3 @@
-		/* Do opensystem first, then try sharedkey */
+		/* Flip back and forth between WEP auth modes until the max
+		 * authentication tries has been exceeded.
+		 */
@@ -3067,0 +3073,6 @@
+		} else if (   system == WLAN_AUTH_SHARED_KEY
+		           && priv->wep_is_on) {
+			priv->CurrentAuthentTransactionSeqNum = 0x001;
+			priv->exclude_unencrypted = 0;
+			send_authentication_request(priv, WLAN_AUTH_OPEN, NULL, 0);
+			return;
@@ -3581 +3592 @@
-		return 0;
+		return -EIO;
@@ -3586 +3597 @@
-		return 0;
+		return -ENODEV;
@@ -3610 +3621 @@
-		return 0;
+		return -EIO;
@@ -3617 +3628 @@
-		return 0;
+		return -EIO;
@@ -3622 +3633 @@
-		return 0;
+		return -EIO;
@@ -3643 +3654 @@
-	return 1;
+	return 0;
@@ -3694 +3705 @@
-		if (atmel_wakeup_firmware(priv)) {
+		if (atmel_wakeup_firmware(priv) == 0) {
@@ -3835,0 +3847 @@
+	int err = 0;
@@ -3856 +3868 @@
-		unsigned char *fw;
+		const unsigned char *fw;
@@ -3869 +3881,2 @@
-				if (request_firmware(&fw_entry, priv->firmware_id, priv->sys_dev) != 0) {
+				err = request_firmware(&fw_entry, priv->firmware_id, priv->sys_dev);
+				if (err != 0) {
@@ -3873 +3886 @@
-					return 0;
+					return err;
@@ -3902 +3915 @@
-					return 0;
+					return -ENOENT;
@@ -3927,2 +3940,3 @@
-	if (!atmel_wakeup_firmware(priv))
-		return 0;
+	err = atmel_wakeup_firmware(priv);
+	if (err != 0)
+		return err;
@@ -3969,2 +3983 @@
-			printk(KERN_INFO
-			       "%s: cannot turn the radio on. (Hey radio, you're beautiful!)\n",
+			printk(KERN_INFO "%s: cannot turn the radio on.\n",
@@ -3972 +3985 @@
-                        return 0;
+                        return -EIO;
@@ -4007 +4020 @@
-	return 1;
+	return 0;
@@ -4123 +4136 @@
-			       unsigned char *src, u16 len)
+			       const unsigned char *src, u16 len)
--- ./projects/linux/linux-2.6.27/drivers/net/wireless/atmel.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/net/wireless/atmel.c	2008-12-25 00:26:37.000000000 +0100
@@ -2261 +2261 @@
-			  struct iw_param *vwrq,
+			  struct iw_point *dwrq,
--- ./projects/linux/linux-2.6.28/drivers/net/wireless/atmel.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/net/wireless/atmel.c	2009-03-24 00:12:14.000000000 +0100
@@ -70 +70 @@
-#include <net/ieee80211.h>
+#include <linux/ieee80211.h>
@@ -572 +572 @@
-				   struct ieee80211_hdr_4addr *header,
+				   struct ieee80211_hdr *header,
@@ -580 +580 @@
-					    struct ieee80211_hdr_4addr *header,
+					    struct ieee80211_hdr *header,
@@ -788 +788 @@
-	struct ieee80211_hdr_4addr header;
+	struct ieee80211_hdr header;
@@ -826 +826 @@
-	header.seq_ctl = 0;
+	header.seq_ctrl = 0;
@@ -843 +843 @@
-	header.frame_ctl = cpu_to_le16(frame_ctl);
+	header.frame_control = cpu_to_le16(frame_ctl);
@@ -863 +863 @@
-					    struct ieee80211_hdr_4addr *header,
+					    struct ieee80211_hdr *header,
@@ -879 +879 @@
-			 struct ieee80211_hdr_4addr *header,
+			 struct ieee80211_hdr *header,
@@ -917 +917 @@
-	if (le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_FROMDS)
+	if (le16_to_cpu(header->frame_control) & IEEE80211_FCTL_FROMDS)
@@ -922 +921,0 @@
-	priv->dev->last_rx = jiffies;
@@ -953 +952 @@
-			 struct ieee80211_hdr_4addr *header,
+			 struct ieee80211_hdr *header,
@@ -961 +960 @@
-	if (le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_FROMDS)
+	if (le16_to_cpu(header->frame_control) & IEEE80211_FCTL_FROMDS)
@@ -1029 +1027,0 @@
-				priv->dev->last_rx = jiffies;
@@ -1044 +1042 @@
-	struct ieee80211_hdr_4addr header;
+	struct ieee80211_hdr header;
@@ -1071 +1069 @@
-		/* Get header as far as end of seq_ctl */
+		/* Get header as far as end of seq_ctrl */
@@ -1073,2 +1071,2 @@
-		frame_ctl = le16_to_cpu(header.frame_ctl);
-		seq_control = le16_to_cpu(header.seq_ctl);
+		frame_ctl = le16_to_cpu(header.frame_control);
+		seq_control = le16_to_cpu(header.seq_ctrl);
@@ -1482 +1479,0 @@
-	DECLARE_MAC_BUF(mac);
@@ -1594,2 +1591,2 @@
-	printk(KERN_INFO "%s: Atmel at76c50x. Version %d.%d. MAC %s\n",
-	       dev->name, DRIVER_MAJOR, DRIVER_MINOR, print_mac(mac, dev->dev_addr));
+	printk(KERN_INFO "%s: Atmel at76c50x. Version %d.%d. MAC %pM\n",
+	       dev->name, DRIVER_MAJOR, DRIVER_MINOR, dev->dev_addr);
@@ -1825 +1822 @@
-		if (idx < 1 || idx > WEP_KEYS)
+		if (idx < 1 || idx > 4)
@@ -1888 +1885 @@
-		if (idx < 1 || idx > WEP_KEYS)
+		if (idx < 1 || idx > 4)
@@ -2803 +2800 @@
-	int new = capability & MFIE_TYPE_POWER_CONSTRAINT ?
+	int new = capability & WLAN_CAPABILITY_SHORT_PREAMBLE ?
@@ -2832 +2829 @@
-	struct ieee80211_hdr_4addr header;
+	struct ieee80211_hdr header;
@@ -2835 +2832 @@
-	header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH);
+	header.frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT | IEEE80211_STYPE_AUTH);
@@ -2837 +2834 @@
-	header.seq_ctl = 0;
+	header.seq_ctrl = 0;
@@ -2844 +2841 @@
-                header.frame_ctl |=  cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+                header.frame_control |=  cpu_to_le16(IEEE80211_FCTL_PROTECTED);
@@ -2867 +2864 @@
-	struct ieee80211_hdr_4addr header;
+	struct ieee80211_hdr header;
@@ -2880 +2877 @@
-	header.frame_ctl = cpu_to_le16(IEEE80211_FTYPE_MGMT |
+	header.frame_control = cpu_to_le16(IEEE80211_FTYPE_MGMT |
@@ -2883 +2880 @@
-	header.seq_ctl = 0;
+	header.seq_ctrl = 0;
@@ -2893 +2890 @@
-		body.capability |= cpu_to_le16(MFIE_TYPE_POWER_CONSTRAINT);
+		body.capability |= cpu_to_le16(WLAN_CAPABILITY_SHORT_PREAMBLE);
@@ -2907 +2904 @@
-	ssid_el_p[0] = MFIE_TYPE_SSID;
+	ssid_el_p[0] = WLAN_EID_SSID;
@@ -2910 +2907 @@
-	ssid_el_p[2 + priv->SSID_size] = MFIE_TYPE_RATES;
+	ssid_el_p[2 + priv->SSID_size] = WLAN_EID_SUPP_RATES;
@@ -2918 +2915 @@
-				     struct ieee80211_hdr_4addr *header)
+				     struct ieee80211_hdr *header)
@@ -2920 +2917 @@
-	if (le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_FROMDS)
+	if (le16_to_cpu(header->frame_control) & IEEE80211_FCTL_FROMDS)
@@ -2968 +2965 @@
-			   struct ieee80211_hdr_4addr *header, u16 capability,
+			   struct ieee80211_hdr *header, u16 capability,
@@ -3007 +3004 @@
-	priv->BSSinfo[index].preamble = capability & MFIE_TYPE_POWER_CONSTRAINT ?
+	priv->BSSinfo[index].preamble = capability & WLAN_CAPABILITY_SHORT_PREAMBLE ?
@@ -3043 +3040 @@
-			    auth->el_id == MFIE_TYPE_CHALLENGE) {
+			    auth->el_id == WLAN_EID_CHALLENGE) {
@@ -3186 +3183 @@
-void atmel_join_bss(struct atmel_private *priv, int bss_index)
+static void atmel_join_bss(struct atmel_private *priv, int bss_index)
@@ -3294 +3291 @@
-				   struct ieee80211_hdr_4addr *header,
+				   struct ieee80211_hdr *header,
@@ -3299 +3296 @@
-	subtype = le16_to_cpu(header->frame_ctl) & IEEE80211_FCTL_STYPE;
+	subtype = le16_to_cpu(header->frame_control) & IEEE80211_FCTL_STYPE;
@@ -3842 +3839 @@
-	   which is the route into the rest of the firmare datastructures. */
+	   which is the route into the rest of the firmware datastructures. */
--- ./projects/linux/linux-2.6.29/drivers/net/wireless/atmel.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/net/wireless/atmel.c	2009-06-27 11:32:32.000000000 +0200
@@ -5,2 +5,2 @@
-        Copyright 2000-2001 ATMEL Corporation.
-        Copyright 2003-2004 Simon Kelley.
+	Copyright 2000-2001 ATMEL Corporation.
+	Copyright 2003-2004 Simon Kelley.
@@ -92,9 +92,9 @@
-	{ ATMEL_FW_TYPE_502,      "atmel_at76c502",      "bin" },
-	{ ATMEL_FW_TYPE_502D,     "atmel_at76c502d",     "bin" },
-	{ ATMEL_FW_TYPE_502E,     "atmel_at76c502e",     "bin" },
-	{ ATMEL_FW_TYPE_502_3COM, "atmel_at76c502_3com", "bin" },
-	{ ATMEL_FW_TYPE_504,      "atmel_at76c504",      "bin" },
-	{ ATMEL_FW_TYPE_504_2958, "atmel_at76c504_2958", "bin" },
-	{ ATMEL_FW_TYPE_504A_2958,"atmel_at76c504a_2958","bin" },
-	{ ATMEL_FW_TYPE_506,      "atmel_at76c506",      "bin" },
-	{ ATMEL_FW_TYPE_NONE,      NULL,                  NULL }
+	{ ATMEL_FW_TYPE_502,		"atmel_at76c502",	"bin" },
+	{ ATMEL_FW_TYPE_502D,		"atmel_at76c502d",	"bin" },
+	{ ATMEL_FW_TYPE_502E,		"atmel_at76c502e",	"bin" },
+	{ ATMEL_FW_TYPE_502_3COM,	"atmel_at76c502_3com",	"bin" },
+	{ ATMEL_FW_TYPE_504,		"atmel_at76c504",	"bin" },
+	{ ATMEL_FW_TYPE_504_2958,	"atmel_at76c504_2958",	"bin" },
+	{ ATMEL_FW_TYPE_504A_2958,	"atmel_at76c504a_2958",	"bin" },
+	{ ATMEL_FW_TYPE_506,		"atmel_at76c506",	"bin" },
+	{ ATMEL_FW_TYPE_NONE,		NULL,			NULL }
@@ -109,2 +109,2 @@
-#define GCR  0x00    //      (SIR0)  General Configuration Register
-#define BSR  0x02    //      (SIR1)  Bank Switching Select Register
+#define GCR  0x00    /* (SIR0)  General Configuration Register */
+#define BSR  0x02    /* (SIR1)  Bank Switching Select Register */
@@ -113,4 +113,4 @@
-#define MR1  0x12    //      Mirror Register 1
-#define MR2  0x14    //      Mirror Register 2
-#define MR3  0x16    //      Mirror Register 3
-#define MR4  0x18    //      Mirror Register 4
+#define MR1  0x12    /* Mirror Register 1 */
+#define MR2  0x14    /* Mirror Register 2 */
+#define MR3  0x16    /* Mirror Register 3 */
+#define MR4  0x18    /* Mirror Register 4 */
@@ -121,17 +121,17 @@
-//
-// Constants for the GCR register.
-//
-#define GCR_REMAP     0x0400          // Remap internal SRAM to 0
-#define GCR_SWRES     0x0080          // BIU reset (ARM and PAI are NOT reset)
-#define GCR_CORES     0x0060          // Core Reset (ARM and PAI are reset)
-#define GCR_ENINT     0x0002          // Enable Interrupts
-#define GCR_ACKINT    0x0008          // Acknowledge Interrupts
-
-#define BSS_SRAM      0x0200          // AMBA module selection --> SRAM
-#define BSS_IRAM      0x0100          // AMBA module selection --> IRAM
-//
-// Constants for the MR registers.
-//
-#define MAC_INIT_COMPLETE       0x0001        // MAC init has been completed
-#define MAC_BOOT_COMPLETE       0x0010        // MAC boot has been completed
-#define MAC_INIT_OK             0x0002        // MAC boot has been completed
+/*
+ * Constants for the GCR register.
+ */
+#define GCR_REMAP     0x0400          /* Remap internal SRAM to 0 */
+#define GCR_SWRES     0x0080          /* BIU reset (ARM and PAI are NOT reset) */
+#define GCR_CORES     0x0060          /* Core Reset (ARM and PAI are reset) */
+#define GCR_ENINT     0x0002          /* Enable Interrupts */
+#define GCR_ACKINT    0x0008          /* Acknowledge Interrupts */
+
+#define BSS_SRAM      0x0200          /* AMBA module selection --> SRAM */
+#define BSS_IRAM      0x0100          /* AMBA module selection --> IRAM */
+/*
+ *Constants for the MR registers.
+ */
+#define MAC_INIT_COMPLETE       0x0001        /* MAC init has been completed */
+#define MAC_BOOT_COMPLETE       0x0010        /* MAC boot has been completed */
+#define MAC_INIT_OK             0x0002        /* MAC boot has been completed */
@@ -143,5 +143,5 @@
-        u8 type;
-        u8 size;
-        u8 index;
-        u8 reserved;
-        u8 data[MIB_MAX_DATA_BYTES];
+	u8 type;
+	u8 size;
+	u8 index;
+	u8 reserved;
+	u8 data[MIB_MAX_DATA_BYTES];
@@ -151,12 +151,12 @@
-        u32          Next;
-        u16          MsduPos;
-        u16          MsduSize;
-
-        u8           State;
-        u8           Status;
-        u8           Rate;
-        u8           Rssi;
-        u8           LinkQuality;
-        u8           PreambleType;
-        u16          Duration;
-        u32          RxTime;
+	u32          Next;
+	u16          MsduPos;
+	u16          MsduSize;
+
+	u8           State;
+	u8           Status;
+	u8           Rate;
+	u8           Rssi;
+	u8           LinkQuality;
+	u8           PreambleType;
+	u16          Duration;
+	u32          RxTime;
@@ -195 +195 @@
-        u8        Reserved1;
+	u8        Reserved1;
@@ -215,3 +215,3 @@
-///////////////////////////////////////////////////////
-// Host-MAC interface
-///////////////////////////////////////////////////////
+/*
+ * Host-MAC interface
+ */
@@ -229,8 +229,8 @@
-#define ISR_EMPTY               0x00        // no bits set in ISR
-#define ISR_TxCOMPLETE          0x01        // packet transmitted
-#define ISR_RxCOMPLETE          0x02        // packet received
-#define ISR_RxFRAMELOST         0x04        // Rx Frame lost
-#define ISR_FATAL_ERROR         0x08        // Fatal error
-#define ISR_COMMAND_COMPLETE    0x10        // command completed
-#define ISR_OUT_OF_RANGE        0x20        // command completed
-#define ISR_IBSS_MERGE          0x40        // (4.1.2.30): IBSS merge
+#define ISR_EMPTY               0x00        /* no bits set in ISR */
+#define ISR_TxCOMPLETE          0x01        /* packet transmitted */
+#define ISR_RxCOMPLETE          0x02        /* packet received */
+#define ISR_RxFRAMELOST         0x04        /* Rx Frame lost */
+#define ISR_FATAL_ERROR         0x08        /* Fatal error */
+#define ISR_COMMAND_COMPLETE    0x10        /* command completed */
+#define ISR_OUT_OF_RANGE        0x20        /* command completed */
+#define ISR_IBSS_MERGE          0x40        /* (4.1.2.30): IBSS merge */
@@ -314,16 +314,16 @@
-///////////////////////////////////////////////////////////////////////////
-// 802.11 related definitions
-///////////////////////////////////////////////////////////////////////////
-
-//
-// Regulatory Domains
-//
-
-#define REG_DOMAIN_FCC		0x10	//Channels	1-11	USA
-#define REG_DOMAIN_DOC		0x20	//Channel	1-11	Canada
-#define REG_DOMAIN_ETSI		0x30	//Channel	1-13	Europe (ex Spain/France)
-#define REG_DOMAIN_SPAIN	0x31	//Channel	10-11	Spain
-#define REG_DOMAIN_FRANCE	0x32	//Channel	10-13	France
-#define REG_DOMAIN_MKK		0x40	//Channel	14	Japan
-#define REG_DOMAIN_MKK1		0x41	//Channel	1-14	Japan(MKK1)
-#define REG_DOMAIN_ISRAEL	0x50	//Channel	3-9	ISRAEL
+/*
+ * 802.11 related definitions
+ */
+
+/*
+ * Regulatory Domains
+ */
+
+#define REG_DOMAIN_FCC		0x10	/* Channels	1-11	USA				*/
+#define REG_DOMAIN_DOC		0x20	/* Channel	1-11	Canada				*/
+#define REG_DOMAIN_ETSI		0x30	/* Channel	1-13	Europe (ex Spain/France)	*/
+#define REG_DOMAIN_SPAIN	0x31	/* Channel	10-11	Spain				*/
+#define REG_DOMAIN_FRANCE	0x32	/* Channel	10-13	France				*/
+#define REG_DOMAIN_MKK		0x40	/* Channel	14	Japan				*/
+#define REG_DOMAIN_MKK1		0x41	/* Channel	1-14	Japan(MKK1)			*/
+#define REG_DOMAIN_ISRAEL	0x50	/* Channel	3-9	ISRAEL				*/
@@ -367,7 +367,7 @@
-//
-// IFACE MACROS & definitions
-//
-//
-
-// FuncCtrl field:
-//
+/*
+ * IFACE MACROS & definitions
+ */
+
+/*
+ * FuncCtrl field:
+ */
@@ -381,42 +381,42 @@
-	0x06,0x00,0x00,0xea,0x04,0x00,0x00,0xea,0x03,0x00,0x00,0xea,0x02,0x00,0x00,0xea,
-	0x01,0x00,0x00,0xea,0x00,0x00,0x00,0xea,0xff,0xff,0xff,0xea,0xfe,0xff,0xff,0xea,
-	0xd3,0x00,0xa0,0xe3,0x00,0xf0,0x21,0xe1,0x0e,0x04,0xa0,0xe3,0x00,0x10,0xa0,0xe3,
-	0x81,0x11,0xa0,0xe1,0x00,0x10,0x81,0xe3,0x00,0x10,0x80,0xe5,0x1c,0x10,0x90,0xe5,
-	0x10,0x10,0xc1,0xe3,0x1c,0x10,0x80,0xe5,0x01,0x10,0xa0,0xe3,0x08,0x10,0x80,0xe5,
-	0x02,0x03,0xa0,0xe3,0x00,0x10,0xa0,0xe3,0xb0,0x10,0xc0,0xe1,0xb4,0x10,0xc0,0xe1,
-	0xb8,0x10,0xc0,0xe1,0xbc,0x10,0xc0,0xe1,0x56,0xdc,0xa0,0xe3,0x21,0x00,0x00,0xeb,
-	0x0a,0x00,0xa0,0xe3,0x1a,0x00,0x00,0xeb,0x10,0x00,0x00,0xeb,0x07,0x00,0x00,0xeb,
-	0x02,0x03,0xa0,0xe3,0x02,0x14,0xa0,0xe3,0xb4,0x10,0xc0,0xe1,0x4c,0x10,0x9f,0xe5,
-	0xbc,0x10,0xc0,0xe1,0x10,0x10,0xa0,0xe3,0xb8,0x10,0xc0,0xe1,0xfe,0xff,0xff,0xea,
-	0x00,0x40,0x2d,0xe9,0x00,0x20,0xa0,0xe3,0x02,0x3c,0xa0,0xe3,0x00,0x10,0xa0,0xe3,
-	0x28,0x00,0x9f,0xe5,0x37,0x00,0x00,0xeb,0x00,0x40,0xbd,0xe8,0x1e,0xff,0x2f,0xe1,
-	0x00,0x40,0x2d,0xe9,0x12,0x2e,0xa0,0xe3,0x06,0x30,0xa0,0xe3,0x00,0x10,0xa0,0xe3,
-	0x02,0x04,0xa0,0xe3,0x2f,0x00,0x00,0xeb,0x00,0x40,0xbd,0xe8,0x1e,0xff,0x2f,0xe1,
-	0x00,0x02,0x00,0x02,0x80,0x01,0x90,0xe0,0x01,0x00,0x00,0x0a,0x01,0x00,0x50,0xe2,
-	0xfc,0xff,0xff,0xea,0x1e,0xff,0x2f,0xe1,0x80,0x10,0xa0,0xe3,0xf3,0x06,0xa0,0xe3,
-	0x00,0x10,0x80,0xe5,0x00,0x10,0xa0,0xe3,0x00,0x10,0x80,0xe5,0x01,0x10,0xa0,0xe3,
-	0x04,0x10,0x80,0xe5,0x00,0x10,0x80,0xe5,0x0e,0x34,0xa0,0xe3,0x1c,0x10,0x93,0xe5,
-	0x02,0x1a,0x81,0xe3,0x1c,0x10,0x83,0xe5,0x58,0x11,0x9f,0xe5,0x30,0x10,0x80,0xe5,
-	0x54,0x11,0x9f,0xe5,0x34,0x10,0x80,0xe5,0x38,0x10,0x80,0xe5,0x3c,0x10,0x80,0xe5,
-	0x10,0x10,0x90,0xe5,0x08,0x00,0x90,0xe5,0x1e,0xff,0x2f,0xe1,0xf3,0x16,0xa0,0xe3,
-	0x08,0x00,0x91,0xe5,0x05,0x00,0xa0,0xe3,0x0c,0x00,0x81,0xe5,0x10,0x00,0x91,0xe5,
-	0x02,0x00,0x10,0xe3,0xfc,0xff,0xff,0x0a,0xff,0x00,0xa0,0xe3,0x0c,0x00,0x81,0xe5,
-	0x10,0x00,0x91,0xe5,0x02,0x00,0x10,0xe3,0xfc,0xff,0xff,0x0a,0x08,0x00,0x91,0xe5,
-	0x10,0x00,0x91,0xe5,0x01,0x00,0x10,0xe3,0xfc,0xff,0xff,0x0a,0x08,0x00,0x91,0xe5,
-	0xff,0x00,0x00,0xe2,0x1e,0xff,0x2f,0xe1,0x30,0x40,0x2d,0xe9,0x00,0x50,0xa0,0xe1,
-	0x03,0x40,0xa0,0xe1,0xa2,0x02,0xa0,0xe1,0x08,0x00,0x00,0xe2,0x03,0x00,0x80,0xe2,
-	0xd8,0x10,0x9f,0xe5,0x00,0x00,0xc1,0xe5,0x01,0x20,0xc1,0xe5,0xe2,0xff,0xff,0xeb,
-	0x01,0x00,0x10,0xe3,0xfc,0xff,0xff,0x1a,0x14,0x00,0xa0,0xe3,0xc4,0xff,0xff,0xeb,
-	0x04,0x20,0xa0,0xe1,0x05,0x10,0xa0,0xe1,0x02,0x00,0xa0,0xe3,0x01,0x00,0x00,0xeb,
-	0x30,0x40,0xbd,0xe8,0x1e,0xff,0x2f,0xe1,0x70,0x40,0x2d,0xe9,0xf3,0x46,0xa0,0xe3,
-	0x00,0x30,0xa0,0xe3,0x00,0x00,0x50,0xe3,0x08,0x00,0x00,0x9a,0x8c,0x50,0x9f,0xe5,
-	0x03,0x60,0xd5,0xe7,0x0c,0x60,0x84,0xe5,0x10,0x60,0x94,0xe5,0x02,0x00,0x16,0xe3,
-	0xfc,0xff,0xff,0x0a,0x01,0x30,0x83,0xe2,0x00,0x00,0x53,0xe1,0xf7,0xff,0xff,0x3a,
-	0xff,0x30,0xa0,0xe3,0x0c,0x30,0x84,0xe5,0x08,0x00,0x94,0xe5,0x10,0x00,0x94,0xe5,
-	0x01,0x00,0x10,0xe3,0xfc,0xff,0xff,0x0a,0x08,0x00,0x94,0xe5,0x00,0x00,0xa0,0xe3,
-	0x00,0x00,0x52,0xe3,0x0b,0x00,0x00,0x9a,0x10,0x50,0x94,0xe5,0x02,0x00,0x15,0xe3,
-	0xfc,0xff,0xff,0x0a,0x0c,0x30,0x84,0xe5,0x10,0x50,0x94,0xe5,0x01,0x00,0x15,0xe3,
-	0xfc,0xff,0xff,0x0a,0x08,0x50,0x94,0xe5,0x01,0x50,0xc1,0xe4,0x01,0x00,0x80,0xe2,
-	0x02,0x00,0x50,0xe1,0xf3,0xff,0xff,0x3a,0xc8,0x00,0xa0,0xe3,0x98,0xff,0xff,0xeb,
-	0x70,0x40,0xbd,0xe8,0x1e,0xff,0x2f,0xe1,0x01,0x0c,0x00,0x02,0x01,0x02,0x00,0x02,
-	0x00,0x01,0x00,0x02
+	0x06, 0x00, 0x00, 0xea, 0x04, 0x00, 0x00, 0xea, 0x03, 0x00, 0x00, 0xea, 0x02, 0x00, 0x00, 0xea,
+	0x01, 0x00, 0x00, 0xea, 0x00, 0x00, 0x00, 0xea, 0xff, 0xff, 0xff, 0xea, 0xfe, 0xff, 0xff, 0xea,
+	0xd3, 0x00, 0xa0, 0xe3, 0x00, 0xf0, 0x21, 0xe1, 0x0e, 0x04, 0xa0, 0xe3, 0x00, 0x10, 0xa0, 0xe3,
+	0x81, 0x11, 0xa0, 0xe1, 0x00, 0x10, 0x81, 0xe3, 0x00, 0x10, 0x80, 0xe5, 0x1c, 0x10, 0x90, 0xe5,
+	0x10, 0x10, 0xc1, 0xe3, 0x1c, 0x10, 0x80, 0xe5, 0x01, 0x10, 0xa0, 0xe3, 0x08, 0x10, 0x80, 0xe5,
+	0x02, 0x03, 0xa0, 0xe3, 0x00, 0x10, 0xa0, 0xe3, 0xb0, 0x10, 0xc0, 0xe1, 0xb4, 0x10, 0xc0, 0xe1,
+	0xb8, 0x10, 0xc0, 0xe1, 0xbc, 0x10, 0xc0, 0xe1, 0x56, 0xdc, 0xa0, 0xe3, 0x21, 0x00, 0x00, 0xeb,
+	0x0a, 0x00, 0xa0, 0xe3, 0x1a, 0x00, 0x00, 0xeb, 0x10, 0x00, 0x00, 0xeb, 0x07, 0x00, 0x00, 0xeb,
+	0x02, 0x03, 0xa0, 0xe3, 0x02, 0x14, 0xa0, 0xe3, 0xb4, 0x10, 0xc0, 0xe1, 0x4c, 0x10, 0x9f, 0xe5,
+	0xbc, 0x10, 0xc0, 0xe1, 0x10, 0x10, 0xa0, 0xe3, 0xb8, 0x10, 0xc0, 0xe1, 0xfe, 0xff, 0xff, 0xea,
+	0x00, 0x40, 0x2d, 0xe9, 0x00, 0x20, 0xa0, 0xe3, 0x02, 0x3c, 0xa0, 0xe3, 0x00, 0x10, 0xa0, 0xe3,
+	0x28, 0x00, 0x9f, 0xe5, 0x37, 0x00, 0x00, 0xeb, 0x00, 0x40, 0xbd, 0xe8, 0x1e, 0xff, 0x2f, 0xe1,
+	0x00, 0x40, 0x2d, 0xe9, 0x12, 0x2e, 0xa0, 0xe3, 0x06, 0x30, 0xa0, 0xe3, 0x00, 0x10, 0xa0, 0xe3,
+	0x02, 0x04, 0xa0, 0xe3, 0x2f, 0x00, 0x00, 0xeb, 0x00, 0x40, 0xbd, 0xe8, 0x1e, 0xff, 0x2f, 0xe1,
+	0x00, 0x02, 0x00, 0x02, 0x80, 0x01, 0x90, 0xe0, 0x01, 0x00, 0x00, 0x0a, 0x01, 0x00, 0x50, 0xe2,
+	0xfc, 0xff, 0xff, 0xea, 0x1e, 0xff, 0x2f, 0xe1, 0x80, 0x10, 0xa0, 0xe3, 0xf3, 0x06, 0xa0, 0xe3,
+	0x00, 0x10, 0x80, 0xe5, 0x00, 0x10, 0xa0, 0xe3, 0x00, 0x10, 0x80, 0xe5, 0x01, 0x10, 0xa0, 0xe3,
+	0x04, 0x10, 0x80, 0xe5, 0x00, 0x10, 0x80, 0xe5, 0x0e, 0x34, 0xa0, 0xe3, 0x1c, 0x10, 0x93, 0xe5,
+	0x02, 0x1a, 0x81, 0xe3, 0x1c, 0x10, 0x83, 0xe5, 0x58, 0x11, 0x9f, 0xe5, 0x30, 0x10, 0x80, 0xe5,
+	0x54, 0x11, 0x9f, 0xe5, 0x34, 0x10, 0x80, 0xe5, 0x38, 0x10, 0x80, 0xe5, 0x3c, 0x10, 0x80, 0xe5,
+	0x10, 0x10, 0x90, 0xe5, 0x08, 0x00, 0x90, 0xe5, 0x1e, 0xff, 0x2f, 0xe1, 0xf3, 0x16, 0xa0, 0xe3,
+	0x08, 0x00, 0x91, 0xe5, 0x05, 0x00, 0xa0, 0xe3, 0x0c, 0x00, 0x81, 0xe5, 0x10, 0x00, 0x91, 0xe5,
+	0x02, 0x00, 0x10, 0xe3, 0xfc, 0xff, 0xff, 0x0a, 0xff, 0x00, 0xa0, 0xe3, 0x0c, 0x00, 0x81, 0xe5,
+	0x10, 0x00, 0x91, 0xe5, 0x02, 0x00, 0x10, 0xe3, 0xfc, 0xff, 0xff, 0x0a, 0x08, 0x00, 0x91, 0xe5,
+	0x10, 0x00, 0x91, 0xe5, 0x01, 0x00, 0x10, 0xe3, 0xfc, 0xff, 0xff, 0x0a, 0x08, 0x00, 0x91, 0xe5,
+	0xff, 0x00, 0x00, 0xe2, 0x1e, 0xff, 0x2f, 0xe1, 0x30, 0x40, 0x2d, 0xe9, 0x00, 0x50, 0xa0, 0xe1,
+	0x03, 0x40, 0xa0, 0xe1, 0xa2, 0x02, 0xa0, 0xe1, 0x08, 0x00, 0x00, 0xe2, 0x03, 0x00, 0x80, 0xe2,
+	0xd8, 0x10, 0x9f, 0xe5, 0x00, 0x00, 0xc1, 0xe5, 0x01, 0x20, 0xc1, 0xe5, 0xe2, 0xff, 0xff, 0xeb,
+	0x01, 0x00, 0x10, 0xe3, 0xfc, 0xff, 0xff, 0x1a, 0x14, 0x00, 0xa0, 0xe3, 0xc4, 0xff, 0xff, 0xeb,
+	0x04, 0x20, 0xa0, 0xe1, 0x05, 0x10, 0xa0, 0xe1, 0x02, 0x00, 0xa0, 0xe3, 0x01, 0x00, 0x00, 0xeb,
+	0x30, 0x40, 0xbd, 0xe8, 0x1e, 0xff, 0x2f, 0xe1, 0x70, 0x40, 0x2d, 0xe9, 0xf3, 0x46, 0xa0, 0xe3,
+	0x00, 0x30, 0xa0, 0xe3, 0x00, 0x00, 0x50, 0xe3, 0x08, 0x00, 0x00, 0x9a, 0x8c, 0x50, 0x9f, 0xe5,
+	0x03, 0x60, 0xd5, 0xe7, 0x0c, 0x60, 0x84, 0xe5, 0x10, 0x60, 0x94, 0xe5, 0x02, 0x00, 0x16, 0xe3,
+	0xfc, 0xff, 0xff, 0x0a, 0x01, 0x30, 0x83, 0xe2, 0x00, 0x00, 0x53, 0xe1, 0xf7, 0xff, 0xff, 0x3a,
+	0xff, 0x30, 0xa0, 0xe3, 0x0c, 0x30, 0x84, 0xe5, 0x08, 0x00, 0x94, 0xe5, 0x10, 0x00, 0x94, 0xe5,
+	0x01, 0x00, 0x10, 0xe3, 0xfc, 0xff, 0xff, 0x0a, 0x08, 0x00, 0x94, 0xe5, 0x00, 0x00, 0xa0, 0xe3,
+	0x00, 0x00, 0x52, 0xe3, 0x0b, 0x00, 0x00, 0x9a, 0x10, 0x50, 0x94, 0xe5, 0x02, 0x00, 0x15, 0xe3,
+	0xfc, 0xff, 0xff, 0x0a, 0x0c, 0x30, 0x84, 0xe5, 0x10, 0x50, 0x94, 0xe5, 0x01, 0x00, 0x15, 0xe3,
+	0xfc, 0xff, 0xff, 0x0a, 0x08, 0x50, 0x94, 0xe5, 0x01, 0x50, 0xc1, 0xe4, 0x01, 0x00, 0x80, 0xe2,
+	0x02, 0x00, 0x50, 0xe1, 0xf3, 0xff, 0xff, 0x3a, 0xc8, 0x00, 0xa0, 0xe3, 0x98, 0xff, 0xff, 0xeb,
+	0x70, 0x40, 0xbd, 0xe8, 0x1e, 0xff, 0x2f, 0xe1, 0x01, 0x0c, 0x00, 0x02, 0x01, 0x02, 0x00, 0x02,
+	0x00, 0x01, 0x00, 0x02
@@ -436 +436 @@
-	spinlock_t irqlock, timerlock;	// spinlocks
+	spinlock_t irqlock, timerlock;	/* spinlocks */
@@ -544 +544 @@
-static u8 atmel_basic_rates[4] = {0x82,0x84,0x0b,0x16};
+static u8 atmel_basic_rates[4] = {0x82, 0x84, 0x0b, 0x16};
@@ -1286,4 +1286,4 @@
-        if ((new_mtu < 68) || (new_mtu > 2312))
-                return -EINVAL;
-        dev->mtu = new_mtu;
-        return 0;
+	if ((new_mtu < 68) || (new_mtu > 2312))
+		return -EINVAL;
+	dev->mtu = new_mtu;
+	return 0;
@@ -1296 +1296 @@
-        memcpy (dev->dev_addr, addr->sa_data, dev->addr_len);
+	memcpy (dev->dev_addr, addr->sa_data, dev->addr_len);
@@ -1423,4 +1423,11 @@
-		case CARD_TYPE_PARALLEL_FLASH: c = "Parallel flash"; break;
-		case CARD_TYPE_SPI_FLASH: c = "SPI flash\n"; break;
-		case CARD_TYPE_EEPROM: c = "EEPROM"; break;
-		default: c = "<unknown>";
+		case CARD_TYPE_PARALLEL_FLASH:
+			c = "Parallel flash";
+			break;
+		case CARD_TYPE_SPI_FLASH:
+			c = "SPI flash\n";
+			break;
+		case CARD_TYPE_EEPROM:
+			c = "EEPROM";
+			break;
+		default:
+			c = "<unknown>";
@@ -1442,10 +1449,27 @@
-	switch(priv->station_state) {
-	case STATION_STATE_SCANNING: s = "Scanning"; break;
-	case STATION_STATE_JOINNING: s = "Joining"; break;
-	case STATION_STATE_AUTHENTICATING: s = "Authenticating"; break;
-	case STATION_STATE_ASSOCIATING: s = "Associating"; break;
-	case STATION_STATE_READY: s = "Ready"; break;
-	case STATION_STATE_REASSOCIATING: s = "Reassociating"; break;
-	case STATION_STATE_MGMT_ERROR: s = "Management error"; break;
-	case STATION_STATE_DOWN: s = "Down"; break;
-	default: s = "<unknown>";
+	switch (priv->station_state) {
+	case STATION_STATE_SCANNING:
+		s = "Scanning";
+		break;
+	case STATION_STATE_JOINNING:
+		s = "Joining";
+		break;
+	case STATION_STATE_AUTHENTICATING:
+		s = "Authenticating";
+		break;
+	case STATION_STATE_ASSOCIATING:
+		s = "Associating";
+		break;
+	case STATION_STATE_READY:
+		s = "Ready";
+		break;
+	case STATION_STATE_REASSOCIATING:
+		s = "Reassociating";
+		break;
+	case STATION_STATE_MGMT_ERROR:
+		s = "Management error";
+		break;
+	case STATION_STATE_DOWN:
+		s = "Down";
+		break;
+	default:
+		s = "<unknown>";
@@ -1461 +1485 @@
-        struct atmel_private *priv = data;
+	struct atmel_private *priv = data;
@@ -1463,7 +1487,20 @@
-        if (len <= off+count) *eof = 1;
-        *start = page + off;
-        len -= off;
-        if (len>count) len = count;
-        if (len<0) len = 0;
-        return len;
-}
+	if (len <= off+count)
+		*eof = 1;
+	*start = page + off;
+	len -= off;
+	if (len > count)
+		len = count;
+	if (len < 0)
+		len = 0;
+	return len;
+}
+
+static const struct net_device_ops atmel_netdev_ops = {
+	.ndo_open 		= atmel_open,
+	.ndo_stop		= atmel_close,
+	.ndo_change_mtu 	= atmel_change_mtu,
+	.ndo_set_mac_address 	= atmel_set_mac_address,
+	.ndo_start_xmit 	= start_tx,
+	.ndo_do_ioctl 		= atmel_ioctl,
+	.ndo_validate_addr	= eth_validate_addr,
+};
@@ -1482,2 +1519,2 @@
-        dev = alloc_etherdev(sizeof(*priv));
-        if (!dev) {
+	dev = alloc_etherdev(sizeof(*priv));
+	if (!dev) {
@@ -1486 +1523 @@
-        }
+	}
@@ -1555,7 +1592,2 @@
-	dev->open = atmel_open;
-	dev->stop = atmel_close;
-	dev->change_mtu = atmel_change_mtu;
-	dev->set_mac_address = atmel_set_mac_address;
-	dev->hard_start_xmit = start_tx;
-	dev->wireless_handlers = (struct iw_handler_def *)&atmel_handler_def;
-	dev->do_ioctl = atmel_ioctl;
+	dev->netdev_ops = &atmel_netdev_ops;
+	dev->wireless_handlers = &atmel_handler_def;
@@ -1580 +1612 @@
-	if (!probe_atmel_card(dev)){
+	if (!probe_atmel_card(dev)) {
@@ -1597 +1629 @@
-	release_region( dev->base_addr, 32);
+	release_region(dev->base_addr, 32);
@@ -1635 +1667 @@
-	if(dwrq->flags == 0) {
+	if (dwrq->flags == 0) {
@@ -1771 +1803 @@
-	if(dwrq->flags & IW_ENCODE_OPEN)
+	if (dwrq->flags & IW_ENCODE_OPEN)
@@ -1800 +1832 @@
-		dwrq->length=0;
+		dwrq->length = 0;
@@ -2016,5 +2048,14 @@
-			case  1000000: priv->tx_rate = 0; break;
-			case  2000000: priv->tx_rate = 1; break;
-			case  5500000: priv->tx_rate = 2; break;
-			case 11000000: priv->tx_rate = 3; break;
-			default: return -EINVAL;
+			case  1000000:
+				priv->tx_rate = 0;
+				break;
+			case  2000000:
+				priv->tx_rate = 1;
+				break;
+			case  5500000:
+				priv->tx_rate = 2;
+				break;
+			case 11000000:
+				priv->tx_rate = 3;
+				break;
+			default:
+				return -EINVAL;
@@ -2065,5 +2106,13 @@
-		switch(priv->tx_rate) {
-		case 0: vwrq->value =  1000000; break;
-		case 1: vwrq->value =  2000000; break;
-		case 2: vwrq->value =  5500000; break;
-		case 3: vwrq->value = 11000000; break;
+		switch (priv->tx_rate) {
+		case 0:
+			vwrq->value =  1000000;
+			break;
+		case 1:
+			vwrq->value =  2000000;
+			break;
+		case 2:
+			vwrq->value =  5500000;
+			break;
+		case 3:
+			vwrq->value = 11000000;
+			break;
@@ -2207,3 +2255,0 @@
-static const long frequency_list[] = { 2412, 2417, 2422, 2427, 2432, 2437, 2442,
-				2447, 2452, 2457, 2462, 2467, 2472, 2484 };
-
@@ -2219,3 +2265 @@
-	if ((fwrq->e == 1) &&
-	    (fwrq->m >= (int) 241200000) &&
-	    (fwrq->m <= (int) 248700000)) {
+	if (fwrq->e == 1) {
@@ -2223,3 +2267 @@
-		int c = 0;
-		while ((c < 14) && (f != frequency_list[c]))
-			c++;
+
@@ -2228 +2270 @@
-		fwrq->m = c + 1;
+		fwrq->m = ieee80211_freq_to_dsss_chan(f);
@@ -2387,2 +2429,5 @@
-			range->freq[k].m = frequency_list[i - 1] * 100000;
-			range->freq[k++].e = 1;	/* Values in table in MHz -> * 10^5 * 10 */
+
+			/* Values in MHz -> * 10^5 * 10 */
+			range->freq[k].m = (ieee80211_dsss_chan_to_freq(i) *
+					    100000);
+			range->freq[k++].e = 1;
@@ -2583,2 +2628 @@
-static const struct iw_handler_def atmel_handler_def =
-{
+static const struct iw_handler_def atmel_handler_def = {
@@ -2841 +2885 @@
-                header.frame_control |=  cpu_to_le16(IEEE80211_FCTL_PROTECTED);
+		header.frame_control |=  cpu_to_le16(IEEE80211_FCTL_PROTECTED);
@@ -2976 +3020 @@
-        /* If we process a probe and an entry from this BSS exists
+	/* If we process a probe and an entry from this BSS exists
@@ -3002 +3046 @@
-		priv->BSSinfo[index].BSStype =IW_MODE_INFRA;
+		priv->BSSinfo[index].BSStype = IW_MODE_INFRA;
@@ -3049 +3093 @@
-			if(priv->station_was_associated) {
+			if (priv->station_was_associated) {
@@ -3070,2 +3114,2 @@
-		} else if (   system == WLAN_AUTH_SHARED_KEY
-		           && priv->wep_is_on) {
+		} else if (system == WLAN_AUTH_SHARED_KEY
+			   && priv->wep_is_on) {
@@ -3259,5 +3303,5 @@
-		case ATMEL_FW_TYPE_502E:
-			max_rssi = 63; /* 502-rmfd-reve max by experiment */
-			break;
-		default:
-			break;
+	case ATMEL_FW_TYPE_502E:
+		max_rssi = 63; /* 502-rmfd-reve max by experiment */
+		break;
+	default:
+		break;
@@ -3480,2 +3524 @@
-	switch (command){
-
+	switch (command) {
@@ -3716 +3759 @@
-			u8 default_mac[] = {0x00,0x04, 0x25, 0x00, 0x00, 0x00};
+			u8 default_mac[] = {0x00, 0x04, 0x25, 0x00, 0x00, 0x00};
@@ -3810 +3853 @@
-				        mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-1] = 1;
+					mib.cipher_default_key_value[i][MAX_ENCRYPTION_KEY_SIZE-1] = 1;
@@ -3920 +3963 @@
-	        if (len <= 0x6000) {
+		if (len <= 0x6000) {
@@ -3949 +3992 @@
-        /* unmask all irq sources */
+	/* unmask all irq sources */
@@ -3982 +4025 @@
-                        return -EIO;
+			return -EIO;
@@ -4006,2 +4049 @@
-	if (old_state == STATION_STATE_READY)
-	{
+	if (old_state == STATION_STATE_READY) {
@@ -4284 +4326 @@
-        .set MAC_BOOT_FLAG, 0x10
+	.set MAC_BOOT_FLAG, 0x10
@@ -4290 +4332 @@
-        b RESET_HANDLER
+	b RESET_HANDLER
@@ -4292 +4334 @@
-        b HALT1
+	b HALT1
@@ -4294 +4336 @@
-        b HALT1
+	b HALT1
@@ -4296 +4338 @@
-        b HALT1
+	b HALT1
@@ -4299 +4341 @@
-        b HALT1
+	b HALT1
@@ -4301 +4343 @@
-        b HALT1
+	b HALT1
@@ -4313 +4355 @@
-	orr	r1,r1, #0
+	orr	r1, r1, #0
--- ./projects/linux/linux-2.6.22/drivers/net/wireless/libertas/wext.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/net/wireless/libertas/wext.c	2007-10-09 22:31:38.000000000 +0200
@@ -1722,3 +1721,0 @@
-		} else {
-			ret = -EINVAL;
-			goto out;
--- ./projects/linux/linux-2.6.23/drivers/net/wireless/libertas/wext.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/net/wireless/libertas/wext.c	2008-01-24 23:58:37.000000000 +0100
@@ -25,54 +24,0 @@
- * the rates supported by the card
- */
-static u8 libertas_wlan_data_rates[WLAN_SUPPORTED_RATES] =
-    { 0x02, 0x04, 0x0B, 0x16, 0x00, 0x0C, 0x12,
-      0x18, 0x24, 0x30, 0x48, 0x60, 0x6C, 0x00
-};
-
-/**
- *  @brief Convert mw value to dbm value
- *
- *  @param mw	   the value of mw
- *  @return 	   the value of dbm
- */
-static int mw_to_dbm(int mw)
-{
-	if (mw < 2)
-		return 0;
-	else if (mw < 3)
-		return 3;
-	else if (mw < 4)
-		return 5;
-	else if (mw < 6)
-		return 7;
-	else if (mw < 7)
-		return 8;
-	else if (mw < 8)
-		return 9;
-	else if (mw < 10)
-		return 10;
-	else if (mw < 13)
-		return 11;
-	else if (mw < 16)
-		return 12;
-	else if (mw < 20)
-		return 13;
-	else if (mw < 25)
-		return 14;
-	else if (mw < 32)
-		return 15;
-	else if (mw < 40)
-		return 16;
-	else if (mw < 50)
-		return 17;
-	else if (mw < 63)
-		return 18;
-	else if (mw < 79)
-		return 19;
-	else if (mw < 100)
-		return 20;
-	else
-		return 21;
-}
-
-/**
@@ -168 +114 @@
-int wlan_radio_ioctl(wlan_private * priv, u8 option)
+static int wlan_radio_ioctl(wlan_private * priv, u8 option)
@@ -180,3 +126,3 @@
-					    cmd_802_11_radio_control,
-					    cmd_act_set,
-					    cmd_option_waitforrsp, 0, NULL);
+					    CMD_802_11_RADIO_CONTROL,
+					    CMD_ACT_SET,
+					    CMD_OPTION_WAITFORRSP, 0, NULL);
@@ -190,22 +136 @@
- *  @brief Copy rates
- *
- *  @param dest                 A pointer to Dest Buf
- *  @param src		        A pointer to Src Buf
- *  @param len                  The len of Src Buf
- *  @return 	   	        Number of rates copyed
- */
-static inline int copyrates(u8 * dest, int pos, u8 * src, int len)
-{
-	int i;
-
-	for (i = 0; i < len && src[i]; i++, pos++) {
-		if (pos >= sizeof(u8) * WLAN_SUPPORTED_RATES)
-			break;
-		dest[pos] = src[i];
-	}
-
-	return pos;
-}
-
-/**
- *  @brief Get active data rates
+ *  @brief Copy active data rates based on adapter mode and status
@@ -215 +139,0 @@
- *  @return 	   	        The number of rates
@@ -217,2 +141 @@
-static int get_active_data_rates(wlan_adapter * adapter,
-				 u8* rates)
+static void copy_active_data_rates(wlan_adapter * adapter, u8 * rates)
@@ -220,2 +142,0 @@
-	int k = 0;
-
@@ -224,14 +145,4 @@
-	if (adapter->connect_status != libertas_connected) {
-		if (adapter->mode == IW_MODE_INFRA) {
-			lbs_deb_wext("infra\n");
-			k = copyrates(rates, k, libertas_supported_rates,
-				      sizeof(libertas_supported_rates));
-		} else {
-			lbs_deb_wext("Adhoc G\n");
-			k = copyrates(rates, k, libertas_adhoc_rates_g,
-				      sizeof(libertas_adhoc_rates_g));
-		}
-	} else {
-		k = copyrates(rates, 0, adapter->curbssparams.datarates,
-			      adapter->curbssparams.numofrates);
-	}
+	if (adapter->connect_status != LIBERTAS_CONNECTED)
+		memcpy(rates, libertas_bg_rates, MAX_RATES);
+	else
+		memcpy(rates, adapter->curbssparams.rates, MAX_RATES);
@@ -239,2 +150 @@
-	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", k);
-	return k;
+	lbs_deb_leave(LBS_DEB_WEXT);
@@ -246,4 +155,0 @@
-	const char *cp;
-	char comm[6] = { "COMM-" };
-	char mrvl[6] = { "MRVL-" };
-	int cnt;
@@ -253,15 +159,2 @@
-	strcpy(cwrq, mrvl);
-
-	cp = strstr(libertas_driver_version, comm);
-	if (cp == libertas_driver_version)	//skip leading "COMM-"
-		cp = libertas_driver_version + strlen(comm);
-	else
-		cp = libertas_driver_version;
-
-	cnt = strlen(mrvl);
-	cwrq += cnt;
-	while (cnt < 16 && (*cp != '-')) {
-		*cwrq++ = toupper(*cp++);
-		cnt++;
-	}
-	*cwrq = '\0';
+	/* We could add support for 802.11n here as needed. Jean II */
+	snprintf(cwrq, IFNAMSIZ, "IEEE 802.11b/g");
@@ -308 +201 @@
-	if (adapter->connect_status == libertas_connected) {
+	if (adapter->connect_status == LIBERTAS_CONNECTED) {
@@ -352,9 +245,3 @@
-	/*
-	 * Get the Nick Name saved
-	 */
-
-	mutex_lock(&adapter->lock);
-	strncpy(extra, adapter->nodename, 16);
-	mutex_unlock(&adapter->lock);
-
-	extra[16] = '\0';
+	dwrq->length = strlen(adapter->nodename);
+	memcpy(extra, adapter->nodename, dwrq->length);
+	extra[dwrq->length] = '\0';
@@ -362,8 +249 @@
-	/*
-	 * If none, we may want to get the one that was set
-	 */
-
-	/*
-	 * Push it out !
-	 */
-	dwrq->length = strlen(extra) + 1;
+	dwrq->flags = 1;	/* active */
@@ -385 +265 @@
-	if (adapter->connect_status == libertas_connected) {
+	if (adapter->connect_status == LIBERTAS_CONNECTED) {
@@ -388 +268 @@
-		dwrq->length = strlen(extra) + 1;
+		dwrq->length = strlen(extra);
@@ -393 +273 @@
-		dwrq->length = 1 ;
+		dwrq->length = 0;
@@ -398,0 +279 @@
+
@@ -417,2 +298,2 @@
-	ret = libertas_prepare_and_send_command(priv, cmd_802_11_snmp_mib,
-				    cmd_act_set, cmd_option_waitforrsp,
+	ret = libertas_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
+				    CMD_ACT_SET, CMD_OPTION_WAITFORRSP,
@@ -435,2 +316,2 @@
-	ret = libertas_prepare_and_send_command(priv, cmd_802_11_snmp_mib,
-				    cmd_act_get, cmd_option_waitforrsp,
+	ret = libertas_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
+				    CMD_ACT_GET, CMD_OPTION_WAITFORRSP,
@@ -470,2 +351,2 @@
-	ret = libertas_prepare_and_send_command(priv, cmd_802_11_snmp_mib,
-				    cmd_act_set, cmd_option_waitforrsp,
+	ret = libertas_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
+				    CMD_ACT_SET, CMD_OPTION_WAITFORRSP,
@@ -489,2 +370,2 @@
-				    cmd_802_11_snmp_mib,
-				    cmd_act_get, cmd_option_waitforrsp,
+				    CMD_802_11_SNMP_MIB,
+				    CMD_ACT_GET, CMD_OPTION_WAITFORRSP,
@@ -542,3 +423,3 @@
-				    cmd_802_11_rf_tx_power,
-				    cmd_act_tx_power_opt_get,
-				    cmd_option_waitforrsp, 0, NULL);
+				    CMD_802_11_RF_TX_POWER,
+				    CMD_ACT_TX_POWER_OPT_GET,
+				    CMD_OPTION_WAITFORRSP, 0, NULL);
@@ -584,3 +465,3 @@
-		ret = libertas_prepare_and_send_command(priv, cmd_802_11_snmp_mib,
-					    cmd_act_set,
-					    cmd_option_waitforrsp,
+		ret = libertas_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
+					    CMD_ACT_SET,
+					    CMD_OPTION_WAITFORRSP,
@@ -611,2 +492,2 @@
-				    cmd_802_11_snmp_mib,
-				    cmd_act_get, cmd_option_waitforrsp,
+				    CMD_802_11_SNMP_MIB,
+				    CMD_ACT_GET, CMD_OPTION_WAITFORRSP,
@@ -676 +557 @@
-	u8 rates[WLAN_SUPPORTED_RATES];
+	u8 rates[MAX_RATES + 1];
@@ -689,6 +570,4 @@
-	range->num_bitrates = get_active_data_rates(adapter, rates);
-
-	for (i = 0; i < min_t(__u8, range->num_bitrates, IW_MAX_BITRATES) && rates[i];
-	     i++) {
-		range->bitrate[i] = (rates[i] & 0x7f) * 500000;
-	}
+	copy_active_data_rates(adapter, rates);
+	range->num_bitrates = strnlen(rates, IW_MAX_BITRATES);
+	for (i = 0; i < range->num_bitrates; i++)
+		range->bitrate[i] = rates[i] * 500000;
@@ -701 +580 @@
-	    adapter->connect_status == libertas_connected) {
+	    adapter->connect_status == LIBERTAS_CONNECTED) {
@@ -861 +740 @@
-		adapter->psmode = wlan802_11powermodecam;
+		adapter->psmode = WLAN802_11POWERMODECAM;
@@ -863 +742 @@
-			libertas_ps_wakeup(priv, cmd_option_waitforrsp);
+			libertas_ps_wakeup(priv, CMD_OPTION_WAITFORRSP);
@@ -878 +757 @@
-	if (adapter->psmode != wlan802_11powermodecam) {
+	if (adapter->psmode != WLAN802_11POWERMODECAM) {
@@ -882 +761 @@
-	adapter->psmode = wlan802_11powermodemax_psp;
+	adapter->psmode = WLAN802_11POWERMODEMAX_PSP;
@@ -884,2 +763,2 @@
-	if (adapter->connect_status == libertas_connected) {
-		libertas_ps_sleep(priv, cmd_option_waitforrsp);
+	if (adapter->connect_status == LIBERTAS_CONNECTED) {
+		libertas_ps_sleep(priv, CMD_OPTION_WAITFORRSP);
@@ -903,2 +782,2 @@
-	if ((vwrq->disabled = (mode == wlan802_11powermodecam))
-	    || adapter->connect_status == libertas_disconnected)
+	if ((vwrq->disabled = (mode == WLAN802_11POWERMODECAM))
+	    || adapter->connect_status == LIBERTAS_DISCONNECTED)
@@ -940 +819 @@
-	if (adapter->connect_status != libertas_connected)
+	if (adapter->connect_status != LIBERTAS_CONNECTED)
@@ -976 +855 @@
-	tx_retries = le16_to_cpu(adapter->logmsg.retry);
+	tx_retries = le32_to_cpu(adapter->logmsg.retry);
@@ -992,2 +871,2 @@
-	priv->wstats.discard.code = le16_to_cpu(adapter->logmsg.wepundecryptable);
-	priv->wstats.discard.fragment = le16_to_cpu(adapter->logmsg.rxfrag);
+	priv->wstats.discard.code = le32_to_cpu(adapter->logmsg.wepundecryptable);
+	priv->wstats.discard.fragment = le32_to_cpu(adapter->logmsg.rxfrag);
@@ -995 +874 @@
-	priv->wstats.discard.misc = le16_to_cpu(adapter->logmsg.ackfailure);
+	priv->wstats.discard.misc = le32_to_cpu(adapter->logmsg.ackfailure);
@@ -998 +877 @@
-	priv->wstats.qual.qual = max(quality, (u32)100);
+	priv->wstats.qual.qual = min_t(u8, quality, 100);
@@ -1003 +882 @@
-	libertas_prepare_and_send_command(priv, cmd_802_11_rssi, 0,
+	libertas_prepare_and_send_command(priv, CMD_802_11_RSSI, 0,
@@ -1005 +884 @@
-	libertas_prepare_and_send_command(priv, cmd_802_11_get_log, 0,
+	libertas_prepare_and_send_command(priv, CMD_802_11_GET_LOG, 0,
@@ -1083,32 +961,0 @@
-/**
- *  @brief use index to get the data rate
- *
- *  @param index                The index of data rate
- *  @return 	   		data rate or 0
- */
-u32 libertas_index_to_data_rate(u8 index)
-{
-	if (index >= sizeof(libertas_wlan_data_rates))
-		index = 0;
-
-	return libertas_wlan_data_rates[index];
-}
-
-/**
- *  @brief use rate to get the index
- *
- *  @param rate                 data rate
- *  @return 	   		index or 0
- */
-u8 libertas_data_rate_to_index(u32 rate)
-{
-	u8 *ptr;
-
-	if (rate)
-		if ((ptr = memchr(libertas_wlan_data_rates, (u8) rate,
-				  sizeof(libertas_wlan_data_rates))))
-			return (ptr - libertas_wlan_data_rates);
-
-	return 0;
-}
-
@@ -1120 +967 @@
-	u32 data_rate;
+	u32 new_rate;
@@ -1122,3 +969,2 @@
-	int ret = 0;
-	u8 rates[WLAN_SUPPORTED_RATES];
-	u8 *rate;
+	int ret = -EINVAL;
+	u8 rates[MAX_RATES + 1];
@@ -1127 +972,0 @@
-
@@ -1129,0 +975 @@
+	/* Auto rate? */
@@ -1131,3 +977,3 @@
-		action = cmd_act_set_tx_auto;	// Auto
-		adapter->is_datarate_auto = 1;
-		adapter->datarate = 0;
+		action = CMD_ACT_SET_TX_AUTO;
+		adapter->auto_rate = 1;
+		adapter->cur_rate = 0;
@@ -1135,5 +981,2 @@
-		if (vwrq->value % 100000) {
-			return -EINVAL;
-		}
-
-		data_rate = vwrq->value / 500000;
+		if (vwrq->value % 100000)
+			goto out;
@@ -1142,13 +985,6 @@
-		get_active_data_rates(adapter, rates);
-		rate = rates;
-		while (*rate) {
-			lbs_deb_wext("rate=0x%X, wanted data_rate 0x%X\n", *rate,
-			       data_rate);
-			if ((*rate & 0x7f) == (data_rate & 0x7f))
-				break;
-			rate++;
-		}
-		if (!*rate) {
-			lbs_pr_alert("fixed data rate 0x%X out "
-			       "of range\n", data_rate);
-			return -EINVAL;
+		copy_active_data_rates(adapter, rates);
+		new_rate = vwrq->value / 500000;
+		if (!memchr(rates, new_rate, sizeof(rates))) {
+			lbs_pr_alert("fixed data rate 0x%X out of range\n",
+				new_rate);
+			goto out;
@@ -1157,3 +993,3 @@
-		adapter->datarate = data_rate;
-		action = cmd_act_set_tx_fix_rate;
-		adapter->is_datarate_auto = 0;
+		adapter->cur_rate = new_rate;
+		action = CMD_ACT_SET_TX_FIX_RATE;
+		adapter->auto_rate = 0;
@@ -1162,2 +998,2 @@
-	ret = libertas_prepare_and_send_command(priv, cmd_802_11_data_rate,
-				    action, cmd_option_waitforrsp, 0, NULL);
+	ret = libertas_prepare_and_send_command(priv, CMD_802_11_DATA_RATE,
+				    action, CMD_OPTION_WAITFORRSP, 0, NULL);
@@ -1164,0 +1001 @@
+out:
@@ -1177,2 +1014,8 @@
-	if (adapter->is_datarate_auto) {
-		vwrq->fixed = 0;
+	if (adapter->connect_status == LIBERTAS_CONNECTED) {
+		vwrq->value = adapter->cur_rate * 500000;
+
+		if (adapter->auto_rate)
+			vwrq->fixed = 0;
+		else
+			vwrq->fixed = 1;
+
@@ -1180 +1023,2 @@
-		vwrq->fixed = 1;
+		vwrq->fixed = 0;
+		vwrq->value = 0;
@@ -1183,2 +1026,0 @@
-	vwrq->value = adapter->datarate * 500000;
-
@@ -1301 +1143 @@
-	lbs_deb_wext("key: " MAC_FMT ", keylen %d\n",
+	lbs_deb_wext("key: %02x:%02x:%02x:%02x:%02x:%02x, keylen %d\n",
@@ -1328 +1170 @@
-	struct WLAN_802_11_KEY *pkey;
+	struct enc_key *pkey;
@@ -1347 +1189 @@
-		memset(pkey, 0, sizeof(struct WLAN_802_11_KEY));
+		memset(pkey, 0, sizeof(struct enc_key));
@@ -1415 +1257 @@
-	memset(&assoc_req->wpa_mcast_key, 0, sizeof (struct WLAN_802_11_KEY));
+	memset(&assoc_req->wpa_mcast_key, 0, sizeof (struct enc_key));
@@ -1419 +1261 @@
-	memset(&assoc_req->wpa_unicast_key, 0, sizeof (struct WLAN_802_11_KEY));
+	memset(&assoc_req->wpa_unicast_key, 0, sizeof (struct enc_key));
@@ -1570 +1412 @@
-			struct WLAN_802_11_KEY * pkey = NULL;
+			struct enc_key * pkey = NULL;
@@ -1682 +1524 @@
-		struct WLAN_802_11_KEY * pkey;
+		struct enc_key * pkey;
@@ -1689 +1531 @@
-				lbs_deb_wext("invalid size %d for key of alg"
+				lbs_deb_wext("invalid size %d for key of alg "
@@ -1705 +1547 @@
-		memset(pkey, 0, sizeof (struct WLAN_802_11_KEY));
+		memset(pkey, 0, sizeof (struct enc_key));
@@ -1979 +1821 @@
-	adapter->preamble = cmd_type_auto_preamble;
+	adapter->preamble = CMD_TYPE_AUTO_PREAMBLE;
@@ -1982,0 +1825,2 @@
+	/* Userspace check in iwrange if it should use dBm or mW,
+	 * therefore this should never happen... Jean II */
@@ -1984 +1828 @@
-		dbm = (u16) mw_to_dbm(vwrq->value);
+		return -EOPNOTSUPP;
@@ -1996,3 +1840,3 @@
-				    cmd_802_11_rf_tx_power,
-				    cmd_act_tx_power_opt_set_low,
-				    cmd_option_waitforrsp, 0, (void *)&dbm);
+				    CMD_802_11_RF_TX_POWER,
+				    CMD_ACT_TX_POWER_OPT_SET_LOW,
+				    CMD_OPTION_WAITFORRSP, 0, (void *)&dbm);
@@ -2020 +1864 @@
-	if (adapter->connect_status == libertas_connected) {
+	if (adapter->connect_status == LIBERTAS_CONNECTED) {
@@ -2032,6 +1876 @@
-	/* To make the driver backward compatible with WPA supplicant v0.2.4 */
-	if (dwrq->length == 32)	/* check with WPA supplicant buffer size */
-		dwrq->length = min_t(size_t, adapter->curbssparams.ssid_len,
-				   IW_ESSID_MAX_SIZE);
-	else
-		dwrq->length = adapter->curbssparams.ssid_len + 1;
+	dwrq->length = adapter->curbssparams.ssid_len;
@@ -2058,8 +1896,0 @@
-	/*
-	 * WE-20 and earlier NULL pad the end of the SSID and increment
-	 * SSID length so it can be used like a string.  WE-21 and later don't,
-	 * but some userspace tools aren't able to cope with the change.
-	 */
-	if ((in_ssid_len > 0) && (extra[in_ssid_len - 1] == '\0'))
-		in_ssid_len--;
-
@@ -2131,0 +1963 @@
+	DECLARE_MAC_BUF(mac);
@@ -2138 +1970 @@
-	lbs_deb_wext("ASSOC: WAP: sa_data " MAC_FMT "\n", MAC_ARG(awrq->sa_data));
+	lbs_deb_wext("ASSOC: WAP: sa_data %s\n", print_mac(mac, awrq->sa_data));
@@ -2301 +2133 @@
-	.num_standard	= sizeof(wlan_handler) / sizeof(iw_handler),
+	.num_standard	= ARRAY_SIZE(wlan_handler),
@@ -2307 +2139 @@
-	.num_standard	= sizeof(mesh_wlan_handler) / sizeof(iw_handler),
+	.num_standard	= ARRAY_SIZE(mesh_wlan_handler),
--- ./projects/linux/linux-2.6.24/drivers/net/wireless/libertas/wext.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/net/wireless/libertas/wext.c	2008-04-17 04:49:44.000000000 +0200
@@ -21,0 +22,17 @@
+#include "cmd.h"
+
+
+static inline void lbs_postpone_association_work(struct lbs_private *priv)
+{
+	if (priv->surpriseremoved)
+		return;
+	cancel_delayed_work(&priv->assoc_work);
+	queue_delayed_work(priv->work_thread, &priv->assoc_work, HZ / 2);
+}
+
+static inline void lbs_cancel_association_work(struct lbs_private *priv)
+{
+	cancel_delayed_work(&priv->assoc_work);
+	kfree(priv->pending_assoc_req);
+	priv->pending_assoc_req = NULL;
+}
@@ -27 +44 @@
- *  @param adapter 	A pointer to wlan_adapter structure
+ *  @param priv 	A pointer to struct lbs_private structure
@@ -32,2 +49,4 @@
-struct chan_freq_power *libertas_find_cfp_by_band_and_channel(wlan_adapter * adapter,
-						 u8 band, u16 channel)
+struct chan_freq_power *lbs_find_cfp_by_band_and_channel(
+	struct lbs_private *priv,
+	u8 band,
+	u16 channel)
@@ -37,2 +55,0 @@
-	int count = sizeof(adapter->region_channel) /
-	    sizeof(adapter->region_channel[0]);
@@ -41,2 +58,2 @@
-	for (j = 0; !cfp && (j < count); j++) {
-		rc = &adapter->region_channel[j];
+	for (j = 0; !cfp && (j < ARRAY_SIZE(priv->region_channel)); j++) {
+		rc = &priv->region_channel[j];
@@ -44,2 +61,2 @@
-		if (adapter->enable11d)
-			rc = &adapter->universal_channel[j];
+		if (priv->enable11d)
+			rc = &priv->universal_channel[j];
@@ -59 +76 @@
-		lbs_deb_wext("libertas_find_cfp_by_band_and_channel: can't find "
+		lbs_deb_wext("lbs_find_cfp_by_band_and_channel: can't find "
@@ -68 +85 @@
- *  @param adapter 	A pointer to wlan_adapter structure
+ *  @param priv 	A pointer to struct lbs_private structure
@@ -73,2 +90,4 @@
-static struct chan_freq_power *find_cfp_by_band_and_freq(wlan_adapter * adapter,
-						     u8 band, u32 freq)
+static struct chan_freq_power *find_cfp_by_band_and_freq(
+	struct lbs_private *priv,
+	u8 band,
+	u32 freq)
@@ -78,2 +96,0 @@
-	int count = sizeof(adapter->region_channel) /
-	    sizeof(adapter->region_channel[0]);
@@ -82,2 +99,2 @@
-	for (j = 0; !cfp && (j < count); j++) {
-		rc = &adapter->region_channel[j];
+	for (j = 0; !cfp && (j < ARRAY_SIZE(priv->region_channel)); j++) {
+		rc = &priv->region_channel[j];
@@ -85,2 +102,2 @@
-		if (adapter->enable11d)
-			rc = &adapter->universal_channel[j];
+		if (priv->enable11d)
+			rc = &priv->universal_channel[j];
@@ -110 +127 @@
- *  @param priv                 A pointer to wlan_private structure
+ *  @param priv                 A pointer to struct lbs_private structure
@@ -114 +131 @@
-static int wlan_radio_ioctl(wlan_private * priv, u8 option)
+static int lbs_radio_ioctl(struct lbs_private *priv, u8 option)
@@ -117 +133,0 @@
-	wlan_adapter *adapter = priv->adapter;
@@ -121 +137 @@
-	if (adapter->radioon != option) {
+	if (priv->radioon != option) {
@@ -123 +139 @@
-		adapter->radioon = option;
+		priv->radioon = option;
@@ -125 +141 @@
-		ret = libertas_prepare_and_send_command(priv,
+		ret = lbs_prepare_and_send_command(priv,
@@ -138 +154 @@
- *  @param adapter              A pointer to wlan_adapter structure
+ *  @param priv              A pointer to struct lbs_private structure
@@ -141 +157 @@
-static void copy_active_data_rates(wlan_adapter * adapter, u8 * rates)
+static void copy_active_data_rates(struct lbs_private *priv, u8 *rates)
@@ -145,2 +161,3 @@
-	if (adapter->connect_status != LIBERTAS_CONNECTED)
-		memcpy(rates, libertas_bg_rates, MAX_RATES);
+	if ((priv->connect_status != LBS_CONNECTED) &&
+		(priv->mesh_connect_status != LBS_CONNECTED))
+		memcpy(rates, lbs_bg_rates, MAX_RATES);
@@ -148 +165 @@
-		memcpy(rates, adapter->curbssparams.rates, MAX_RATES);
+		memcpy(rates, priv->curbssparams.rates, MAX_RATES);
@@ -153 +170 @@
-static int wlan_get_name(struct net_device *dev, struct iw_request_info *info,
+static int lbs_get_name(struct net_device *dev, struct iw_request_info *info,
@@ -166 +183 @@
-static int wlan_get_freq(struct net_device *dev, struct iw_request_info *info,
+static int lbs_get_freq(struct net_device *dev, struct iw_request_info *info,
@@ -169,2 +186 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -175,2 +191,2 @@
-	cfp = libertas_find_cfp_by_band_and_channel(adapter, 0,
-					   adapter->curbssparams.channel);
+	cfp = lbs_find_cfp_by_band_and_channel(priv, 0,
+					   priv->curbssparams.channel);
@@ -179 +195 @@
-		if (adapter->curbssparams.channel)
+		if (priv->curbssparams.channel)
@@ -181 +197 @@
-			       adapter->curbssparams.channel);
+			       priv->curbssparams.channel);
@@ -193 +209 @@
-static int wlan_get_wap(struct net_device *dev, struct iw_request_info *info,
+static int lbs_get_wap(struct net_device *dev, struct iw_request_info *info,
@@ -196,2 +212 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -201,2 +216,2 @@
-	if (adapter->connect_status == LIBERTAS_CONNECTED) {
-		memcpy(awrq->sa_data, adapter->curbssparams.bssid, ETH_ALEN);
+	if (priv->connect_status == LBS_CONNECTED) {
+		memcpy(awrq->sa_data, priv->curbssparams.bssid, ETH_ALEN);
@@ -212 +227 @@
-static int wlan_set_nick(struct net_device *dev, struct iw_request_info *info,
+static int lbs_set_nick(struct net_device *dev, struct iw_request_info *info,
@@ -215,2 +230 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -228,4 +242,4 @@
-	mutex_lock(&adapter->lock);
-	memset(adapter->nodename, 0, sizeof(adapter->nodename));
-	memcpy(adapter->nodename, extra, dwrq->length);
-	mutex_unlock(&adapter->lock);
+	mutex_lock(&priv->lock);
+	memset(priv->nodename, 0, sizeof(priv->nodename));
+	memcpy(priv->nodename, extra, dwrq->length);
+	mutex_unlock(&priv->lock);
@@ -237 +251 @@
-static int wlan_get_nick(struct net_device *dev, struct iw_request_info *info,
+static int lbs_get_nick(struct net_device *dev, struct iw_request_info *info,
@@ -240,2 +254 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -245,2 +258,2 @@
-	dwrq->length = strlen(adapter->nodename);
-	memcpy(extra, adapter->nodename, dwrq->length);
+	dwrq->length = strlen(priv->nodename);
+	memcpy(extra, priv->nodename, dwrq->length);
@@ -258,2 +271 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -265 +277 @@
-	if (adapter->connect_status == LIBERTAS_CONNECTED) {
+	if (priv->mesh_connect_status == LBS_CONNECTED) {
@@ -280 +292 @@
-static int wlan_set_rts(struct net_device *dev, struct iw_request_info *info,
+static int lbs_set_rts(struct net_device *dev, struct iw_request_info *info,
@@ -284,2 +296 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -291 +302 @@
-		adapter->rtsthsd = rthr = MRVDRV_RTS_MAX_VALUE;
+		priv->rtsthsd = rthr = MRVDRV_RTS_MAX_VALUE;
@@ -295 +306 @@
-		adapter->rtsthsd = rthr;
+		priv->rtsthsd = rthr;
@@ -298 +309 @@
-	ret = libertas_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
+	ret = lbs_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
@@ -306 +317 @@
-static int wlan_get_rts(struct net_device *dev, struct iw_request_info *info,
+static int lbs_get_rts(struct net_device *dev, struct iw_request_info *info,
@@ -310,2 +321 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -315,2 +325,2 @@
-	adapter->rtsthsd = 0;
-	ret = libertas_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
+	priv->rtsthsd = 0;
+	ret = lbs_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
@@ -322 +332 @@
-	vwrq->value = adapter->rtsthsd;
+	vwrq->value = priv->rtsthsd;
@@ -332 +342 @@
-static int wlan_set_frag(struct net_device *dev, struct iw_request_info *info,
+static int lbs_set_frag(struct net_device *dev, struct iw_request_info *info,
@@ -337,2 +347 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -343 +352 @@
-		adapter->fragthsd = fthr = MRVDRV_FRAG_MAX_VALUE;
+		priv->fragthsd = fthr = MRVDRV_FRAG_MAX_VALUE;
@@ -348 +357 @@
-		adapter->fragthsd = fthr;
+		priv->fragthsd = fthr;
@@ -351 +360 @@
-	ret = libertas_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
+	ret = lbs_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
@@ -359 +368 @@
-static int wlan_get_frag(struct net_device *dev, struct iw_request_info *info,
+static int lbs_get_frag(struct net_device *dev, struct iw_request_info *info,
@@ -363,2 +372 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -368,2 +376,2 @@
-	adapter->fragthsd = 0;
-	ret = libertas_prepare_and_send_command(priv,
+	priv->fragthsd = 0;
+	ret = lbs_prepare_and_send_command(priv,
@@ -376 +384 @@
-	vwrq->value = adapter->fragthsd;
+	vwrq->value = priv->fragthsd;
@@ -386 +394 @@
-static int wlan_get_mode(struct net_device *dev,
+static int lbs_get_mode(struct net_device *dev,
@@ -389,2 +397 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -394 +401 @@
-	*uwrq = adapter->mode;
+	*uwrq = priv->mode;
@@ -412 +419 @@
-static int wlan_get_txpow(struct net_device *dev,
+static int lbs_get_txpow(struct net_device *dev,
@@ -417,2 +424 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -422 +428 @@
-	ret = libertas_prepare_and_send_command(priv,
+	ret = lbs_prepare_and_send_command(priv,
@@ -430,2 +436,2 @@
-	lbs_deb_wext("tx power level %d dbm\n", adapter->txpowerlevel);
-	vwrq->value = adapter->txpowerlevel;
+	lbs_deb_wext("tx power level %d dbm\n", priv->txpowerlevel);
+	vwrq->value = priv->txpowerlevel;
@@ -433 +439 @@
-	if (adapter->radioon) {
+	if (priv->radioon) {
@@ -445 +451 @@
-static int wlan_set_retry(struct net_device *dev, struct iw_request_info *info,
+static int lbs_set_retry(struct net_device *dev, struct iw_request_info *info,
@@ -449,2 +455 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -463 +468 @@
-		adapter->txretrycount = vwrq->value + 1;
+		priv->txretrycount = vwrq->value + 1;
@@ -465 +470 @@
-		ret = libertas_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
+		ret = lbs_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
@@ -481 +486 @@
-static int wlan_get_retry(struct net_device *dev, struct iw_request_info *info,
+static int lbs_get_retry(struct net_device *dev, struct iw_request_info *info,
@@ -484,2 +489 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -490,2 +494,2 @@
-	adapter->txretrycount = 0;
-	ret = libertas_prepare_and_send_command(priv,
+	priv->txretrycount = 0;
+	ret = lbs_prepare_and_send_command(priv,
@@ -502 +506 @@
-		vwrq->value = adapter->txretrycount - 1;
+		vwrq->value = priv->txretrycount - 1;
@@ -549 +553 @@
-static int wlan_get_range(struct net_device *dev, struct iw_request_info *info,
+static int lbs_get_range(struct net_device *dev, struct iw_request_info *info,
@@ -553,2 +557 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -570 +573 @@
-	copy_active_data_rates(adapter, rates);
+	copy_active_data_rates(priv, rates);
@@ -579,2 +582,3 @@
-	if (priv->adapter->enable11d &&
-	    adapter->connect_status == LIBERTAS_CONNECTED) {
+	if (priv->enable11d &&
+	    (priv->connect_status == LBS_CONNECTED ||
+	    priv->mesh_connect_status == LBS_CONNECTED)) {
@@ -585 +589 @@
-		    &adapter->parsed_region_chan;
+		    &priv->parsed_region_chan;
@@ -601 +605 @@
-			    (long)libertas_chan_2_freq(chan_no, band) * 100000;
+			    (long)lbs_chan_2_freq(chan_no, band) * 100000;
@@ -609,3 +613,2 @@
-		     && (j < sizeof(adapter->region_channel)
-			 / sizeof(adapter->region_channel[0])); j++) {
-			cfp = adapter->region_channel[j].CFP;
+		     && (j < ARRAY_SIZE(priv->region_channel)); j++) {
+			cfp = priv->region_channel[j].CFP;
@@ -613 +616 @@
-			     && adapter->region_channel[j].valid
+			     && priv->region_channel[j].valid
@@ -615 +618 @@
-			     && (i < adapter->region_channel[j].nrcfp); i++) {
+			     && (i < priv->region_channel[j].nrcfp); i++) {
@@ -715 +718 @@
-	if (adapter->fwcapinfo & FW_CAPINFO_WPA) {
+	if (priv->fwcapinfo & FW_CAPINFO_WPA) {
@@ -727 +730 @@
-static int wlan_set_power(struct net_device *dev, struct iw_request_info *info,
+static int lbs_set_power(struct net_device *dev, struct iw_request_info *info,
@@ -730,2 +733 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -734,0 +737,7 @@
+	if (!priv->ps_supported) {
+		if (vwrq->disabled)
+			return 0;
+		else
+			return -EINVAL;
+	}
+
@@ -740,3 +749,3 @@
-		adapter->psmode = WLAN802_11POWERMODECAM;
-		if (adapter->psstate != PS_STATE_FULL_POWER) {
-			libertas_ps_wakeup(priv, CMD_OPTION_WAITFORRSP);
+		priv->psmode = LBS802_11POWERMODECAM;
+		if (priv->psstate != PS_STATE_FULL_POWER) {
+			lbs_ps_wakeup(priv, CMD_OPTION_WAITFORRSP);
@@ -757 +766 @@
-	if (adapter->psmode != WLAN802_11POWERMODECAM) {
+	if (priv->psmode != LBS802_11POWERMODECAM) {
@@ -761 +770 @@
-	adapter->psmode = WLAN802_11POWERMODEMAX_PSP;
+	priv->psmode = LBS802_11POWERMODEMAX_PSP;
@@ -763,2 +772,2 @@
-	if (adapter->connect_status == LIBERTAS_CONNECTED) {
-		libertas_ps_sleep(priv, CMD_OPTION_WAITFORRSP);
+	if (priv->connect_status == LBS_CONNECTED) {
+		lbs_ps_sleep(priv, CMD_OPTION_WAITFORRSP);
@@ -771 +780 @@
-static int wlan_get_power(struct net_device *dev, struct iw_request_info *info,
+static int lbs_get_power(struct net_device *dev, struct iw_request_info *info,
@@ -774,2 +783 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -780 +788 @@
-	mode = adapter->psmode;
+	mode = priv->psmode;
@@ -782,2 +790,2 @@
-	if ((vwrq->disabled = (mode == WLAN802_11POWERMODECAM))
-	    || adapter->connect_status == LIBERTAS_DISCONNECTED)
+	if ((vwrq->disabled = (mode == LBS802_11POWERMODECAM))
+	    || priv->connect_status == LBS_DISCONNECTED)
@@ -795 +803 @@
-static struct iw_statistics *wlan_get_wireless_stats(struct net_device *dev)
+static struct iw_statistics *lbs_get_wireless_stats(struct net_device *dev)
@@ -805,2 +813 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -816 +823 @@
-	priv->wstats.status = adapter->mode;
+	priv->wstats.status = priv->mode;
@@ -819 +826,2 @@
-	if (adapter->connect_status != LIBERTAS_CONNECTED)
+	if ((priv->connect_status != LBS_CONNECTED) &&
+	    (priv->mesh_connect_status != LBS_CONNECTED))
@@ -824,2 +832,2 @@
-	    CAL_RSSI(adapter->SNR[TYPE_BEACON][TYPE_NOAVG],
-	     adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+	    CAL_RSSI(priv->SNR[TYPE_BEACON][TYPE_NOAVG],
+	     priv->NF[TYPE_BEACON][TYPE_NOAVG]);
@@ -827 +835 @@
-	if (adapter->NF[TYPE_BEACON][TYPE_NOAVG] == 0) {
+	if (priv->NF[TYPE_BEACON][TYPE_NOAVG] == 0) {
@@ -831 +839 @@
-		    CAL_NF(adapter->NF[TYPE_BEACON][TYPE_NOAVG]);
+		    CAL_NF(priv->NF[TYPE_BEACON][TYPE_NOAVG]);
@@ -855 +863 @@
-	tx_retries = le32_to_cpu(adapter->logmsg.retry);
+	tx_retries = le32_to_cpu(priv->logmsg.retry);
@@ -871,2 +879,2 @@
-	priv->wstats.discard.code = le32_to_cpu(adapter->logmsg.wepundecryptable);
-	priv->wstats.discard.fragment = le32_to_cpu(adapter->logmsg.rxfrag);
+	priv->wstats.discard.code = le32_to_cpu(priv->logmsg.wepundecryptable);
+	priv->wstats.discard.fragment = le32_to_cpu(priv->logmsg.rxfrag);
@@ -874 +882 @@
-	priv->wstats.discard.misc = le32_to_cpu(adapter->logmsg.ackfailure);
+	priv->wstats.discard.misc = le32_to_cpu(priv->logmsg.ackfailure);
@@ -882 +890 @@
-	libertas_prepare_and_send_command(priv, CMD_802_11_RSSI, 0,
+	lbs_prepare_and_send_command(priv, CMD_802_11_RSSI, 0,
@@ -884 +892 @@
-	libertas_prepare_and_send_command(priv, CMD_802_11_GET_LOG, 0,
+	lbs_prepare_and_send_command(priv, CMD_802_11_GET_LOG, 0,
@@ -904 +912 @@
-static int wlan_set_freq(struct net_device *dev, struct iw_request_info *info,
+static int lbs_set_freq(struct net_device *dev, struct iw_request_info *info,
@@ -908,2 +916 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -915,2 +922,2 @@
-	mutex_lock(&adapter->lock);
-	assoc_req = wlan_get_association_request(adapter);
+	mutex_lock(&priv->lock);
+	assoc_req = lbs_get_association_request(priv);
@@ -926 +933 @@
-		cfp = find_cfp_by_band_and_freq(adapter, 0, f);
+		cfp = find_cfp_by_band_and_freq(priv, 0, f);
@@ -941 +948 @@
-	cfp = libertas_find_cfp_by_band_and_channel(adapter, 0, fwrq->m);
+	cfp = lbs_find_cfp_by_band_and_channel(priv, 0, fwrq->m);
@@ -952 +959 @@
-		wlan_postpone_association_work(priv);
+		lbs_postpone_association_work(priv);
@@ -954 +961,48 @@
-		wlan_cancel_association_work(priv);
+		lbs_cancel_association_work(priv);
+	}
+	mutex_unlock(&priv->lock);
+
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
+	return ret;
+}
+
+static int lbs_mesh_set_freq(struct net_device *dev,
+			     struct iw_request_info *info,
+			     struct iw_freq *fwrq, char *extra)
+{
+	struct lbs_private *priv = dev->priv;
+	struct chan_freq_power *cfp;
+	int ret = -EINVAL;
+
+	lbs_deb_enter(LBS_DEB_WEXT);
+
+	/* If setting by frequency, convert to a channel */
+	if (fwrq->e == 1) {
+		long f = fwrq->m / 100000;
+
+		cfp = find_cfp_by_band_and_freq(priv, 0, f);
+		if (!cfp) {
+			lbs_deb_wext("invalid freq %ld\n", f);
+			goto out;
+		}
+
+		fwrq->e = 0;
+		fwrq->m = (int) cfp->channel;
+	}
+
+	/* Setting by channel number */
+	if (fwrq->m > 1000 || fwrq->e > 0) {
+		goto out;
+	}
+
+	cfp = lbs_find_cfp_by_band_and_channel(priv, 0, fwrq->m);
+	if (!cfp) {
+		goto out;
+	}
+
+	if (fwrq->m != priv->curbssparams.channel) {
+		lbs_deb_wext("mesh channel change forces eth disconnect\n");
+		if (priv->mode == IW_MODE_INFRA)
+			lbs_send_deauthentication(priv);
+		else if (priv->mode == IW_MODE_ADHOC)
+			lbs_stop_adhoc_network(priv);
@@ -956 +1010,3 @@
-	mutex_unlock(&adapter->lock);
+	lbs_mesh_config(priv, 1, fwrq->m);
+	lbs_update_channel(priv);
+	ret = 0;
@@ -957,0 +1014 @@
+out:
@@ -962 +1019 @@
-static int wlan_set_rate(struct net_device *dev, struct iw_request_info *info,
+static int lbs_set_rate(struct net_device *dev, struct iw_request_info *info,
@@ -965,4 +1022,2 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
-	u32 new_rate;
-	u16 action;
+	struct lbs_private *priv = dev->priv;
+	u8 new_rate = 0;
@@ -977,3 +1032,2 @@
-		action = CMD_ACT_SET_TX_AUTO;
-		adapter->auto_rate = 1;
-		adapter->cur_rate = 0;
+		priv->auto_rate = 1;
+		priv->cur_rate = 0;
@@ -985 +1039 @@
-		copy_active_data_rates(adapter, rates);
+		copy_active_data_rates(priv, rates);
@@ -993,3 +1047,2 @@
-		adapter->cur_rate = new_rate;
-		action = CMD_ACT_SET_TX_FIX_RATE;
-		adapter->auto_rate = 0;
+		priv->cur_rate = new_rate;
+		priv->auto_rate = 0;
@@ -998,2 +1051 @@
-	ret = libertas_prepare_and_send_command(priv, CMD_802_11_DATA_RATE,
-				    action, CMD_OPTION_WAITFORRSP, 0, NULL);
+	ret = lbs_set_data_rate(priv, new_rate);
@@ -1006 +1058 @@
-static int wlan_get_rate(struct net_device *dev, struct iw_request_info *info,
+static int lbs_get_rate(struct net_device *dev, struct iw_request_info *info,
@@ -1009,2 +1061 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1014,2 +1065,2 @@
-	if (adapter->connect_status == LIBERTAS_CONNECTED) {
-		vwrq->value = adapter->cur_rate * 500000;
+	if (priv->connect_status == LBS_CONNECTED) {
+		vwrq->value = priv->cur_rate * 500000;
@@ -1017 +1068 @@
-		if (adapter->auto_rate)
+		if (priv->auto_rate)
@@ -1031 +1082 @@
-static int wlan_set_mode(struct net_device *dev,
+static int lbs_set_mode(struct net_device *dev,
@@ -1035,2 +1086 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1049,2 +1099,2 @@
-	mutex_lock(&adapter->lock);
-	assoc_req = wlan_get_association_request(adapter);
+	mutex_lock(&priv->lock);
+	assoc_req = lbs_get_association_request(priv);
@@ -1053 +1103 @@
-		wlan_cancel_association_work(priv);
+		lbs_cancel_association_work(priv);
@@ -1057 +1107 @@
-		wlan_postpone_association_work(priv);
+		lbs_postpone_association_work(priv);
@@ -1060 +1110 @@
-	mutex_unlock(&adapter->lock);
+	mutex_unlock(&priv->lock);
@@ -1077 +1127 @@
-static int wlan_get_encode(struct net_device *dev,
+static int lbs_get_encode(struct net_device *dev,
@@ -1081,2 +1131 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1088 +1137 @@
-	       dwrq->flags, index, dwrq->length, adapter->wep_tx_keyidx);
+	       dwrq->flags, index, dwrq->length, priv->wep_tx_keyidx);
@@ -1093 +1142 @@
-	switch (adapter->secinfo.auth_mode) {
+	switch (priv->secinfo.auth_mode) {
@@ -1107,8 +1155,0 @@
-	if (   adapter->secinfo.wep_enabled
-	    || adapter->secinfo.WPAenabled
-	    || adapter->secinfo.WPA2enabled) {
-		dwrq->flags &= ~IW_ENCODE_DISABLED;
-	} else {
-		dwrq->flags |= IW_ENCODE_DISABLED;
-	}
-
@@ -1117 +1158 @@
-	mutex_lock(&adapter->lock);
+	mutex_lock(&priv->lock);
@@ -1121 +1162 @@
-		index = adapter->wep_tx_keyidx;
+		index = priv->wep_tx_keyidx;
@@ -1123,4 +1164,4 @@
-	if ((adapter->wep_keys[index].len) && adapter->secinfo.wep_enabled) {
-		memcpy(extra, adapter->wep_keys[index].key,
-		       adapter->wep_keys[index].len);
-		dwrq->length = adapter->wep_keys[index].len;
+	if ((priv->wep_keys[index].len) && priv->secinfo.wep_enabled) {
+		memcpy(extra, priv->wep_keys[index].key,
+		       priv->wep_keys[index].len);
+		dwrq->length = priv->wep_keys[index].len;
@@ -1131,2 +1172,2 @@
-	} else if ((adapter->secinfo.WPAenabled)
-		   || (adapter->secinfo.WPA2enabled)) {
+	} else if ((priv->secinfo.WPAenabled)
+		   || (priv->secinfo.WPA2enabled)) {
@@ -1134,0 +1176 @@
+		dwrq->flags |= IW_ENCODE_NOKEY;
@@ -1139,3 +1181 @@
-	mutex_unlock(&adapter->lock);
-
-	dwrq->flags |= IW_ENCODE_NOKEY;
+	mutex_unlock(&priv->lock);
@@ -1163 +1203 @@
-static int wlan_set_wep_key(struct assoc_request *assoc_req,
+static int lbs_set_wep_key(struct assoc_request *assoc_req,
@@ -1281 +1321 @@
-static int wlan_set_encode(struct net_device *dev,
+static int lbs_set_encode(struct net_device *dev,
@@ -1286,2 +1326 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1293,2 +1332,2 @@
-	mutex_lock(&adapter->lock);
-	assoc_req = wlan_get_association_request(adapter);
+	mutex_lock(&priv->lock);
+	assoc_req = lbs_get_association_request(priv);
@@ -1320 +1359 @@
-	ret = wlan_set_wep_key(assoc_req, extra, dwrq->length, index, set_tx_key);
+	ret = lbs_set_wep_key(assoc_req, extra, dwrq->length, index, set_tx_key);
@@ -1338 +1377 @@
-		wlan_postpone_association_work(priv);
+		lbs_postpone_association_work(priv);
@@ -1340 +1379 @@
-		wlan_cancel_association_work(priv);
+		lbs_cancel_association_work(priv);
@@ -1342 +1381 @@
-	mutex_unlock(&adapter->lock);
+	mutex_unlock(&priv->lock);
@@ -1357 +1396 @@
-static int wlan_get_encodeext(struct net_device *dev,
+static int lbs_get_encodeext(struct net_device *dev,
@@ -1363,2 +1402 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1380 +1418 @@
-		index = adapter->wep_tx_keyidx;
+		index = priv->wep_tx_keyidx;
@@ -1383 +1421 @@
-	if (!ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY &&
+	if (!(ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) &&
@@ -1385 +1423 @@
-		if (index != 0 || adapter->mode != IW_MODE_INFRA)
+		if (index != 0 || priv->mode != IW_MODE_INFRA)
@@ -1392,3 +1430,3 @@
-	if (   !adapter->secinfo.wep_enabled
-	    && !adapter->secinfo.WPAenabled
-	    && !adapter->secinfo.WPA2enabled) {
+	if (   !priv->secinfo.wep_enabled
+	    && !priv->secinfo.WPAenabled
+	    && !priv->secinfo.WPA2enabled) {
@@ -1401,3 +1439,3 @@
-		if (   adapter->secinfo.wep_enabled
-		    && !adapter->secinfo.WPAenabled
-		    && !adapter->secinfo.WPA2enabled) {
+		if (   priv->secinfo.wep_enabled
+		    && !priv->secinfo.WPAenabled
+		    && !priv->secinfo.WPA2enabled) {
@@ -1406,5 +1444,5 @@
-			ext->key_len = adapter->wep_keys[index].len;
-			key = &adapter->wep_keys[index].key[0];
-		} else if (   !adapter->secinfo.wep_enabled
-		           && (adapter->secinfo.WPAenabled ||
-		               adapter->secinfo.WPA2enabled)) {
+			ext->key_len = priv->wep_keys[index].len;
+			key = &priv->wep_keys[index].key[0];
+		} else if (   !priv->secinfo.wep_enabled
+		           && (priv->secinfo.WPAenabled ||
+		               priv->secinfo.WPA2enabled)) {
@@ -1414,6 +1452,6 @@
-			if (   adapter->wpa_mcast_key.len
-			    && (adapter->wpa_mcast_key.flags & KEY_INFO_WPA_ENABLED))
-				pkey = &adapter->wpa_mcast_key;
-			else if (   adapter->wpa_unicast_key.len
-			         && (adapter->wpa_unicast_key.flags & KEY_INFO_WPA_ENABLED))
-				pkey = &adapter->wpa_unicast_key;
+			if (   priv->wpa_mcast_key.len
+			    && (priv->wpa_mcast_key.flags & KEY_INFO_WPA_ENABLED))
+				pkey = &priv->wpa_mcast_key;
+			else if (   priv->wpa_unicast_key.len
+			         && (priv->wpa_unicast_key.flags & KEY_INFO_WPA_ENABLED))
+				pkey = &priv->wpa_unicast_key;
@@ -1464 +1502 @@
-static int wlan_set_encodeext(struct net_device *dev,
+static int lbs_set_encodeext(struct net_device *dev,
@@ -1470,2 +1508 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1478,2 +1515,2 @@
-	mutex_lock(&adapter->lock);
-	assoc_req = wlan_get_association_request(adapter);
+	mutex_lock(&priv->lock);
+	assoc_req = lbs_get_association_request(priv);
@@ -1506 +1543 @@
-		ret = wlan_set_wep_key (assoc_req, ext->key, ext->key_len, index,
+		ret = lbs_set_wep_key(assoc_req, ext->key, ext->key_len, index,
@@ -1579 +1616 @@
-		wlan_postpone_association_work(priv);
+		lbs_postpone_association_work(priv);
@@ -1581 +1618 @@
-		wlan_cancel_association_work(priv);
+		lbs_cancel_association_work(priv);
@@ -1583 +1620 @@
-	mutex_unlock(&adapter->lock);
+	mutex_unlock(&priv->lock);
@@ -1590 +1627 @@
-static int wlan_set_genie(struct net_device *dev,
+static int lbs_set_genie(struct net_device *dev,
@@ -1595,2 +1632 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1602,2 +1638,2 @@
-	mutex_lock(&adapter->lock);
-	assoc_req = wlan_get_association_request(adapter);
+	mutex_lock(&priv->lock);
+	assoc_req = lbs_get_association_request(priv);
@@ -1619 +1655 @@
-		memset(&assoc_req->wpa_ie[0], 0, sizeof(adapter->wpa_ie));
+		memset(&assoc_req->wpa_ie[0], 0, sizeof(priv->wpa_ie));
@@ -1626 +1662 @@
-		wlan_postpone_association_work(priv);
+		lbs_postpone_association_work(priv);
@@ -1628 +1664 @@
-		wlan_cancel_association_work(priv);
+		lbs_cancel_association_work(priv);
@@ -1630 +1666 @@
-	mutex_unlock(&adapter->lock);
+	mutex_unlock(&priv->lock);
@@ -1636 +1672 @@
-static int wlan_get_genie(struct net_device *dev,
+static int lbs_get_genie(struct net_device *dev,
@@ -1642,2 +1678 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1647 +1682 @@
-	if (adapter->wpa_ie_len == 0) {
+	if (priv->wpa_ie_len == 0) {
@@ -1652 +1687 @@
-	if (dwrq->length < adapter->wpa_ie_len) {
+	if (dwrq->length < priv->wpa_ie_len) {
@@ -1657,2 +1692,2 @@
-	dwrq->length = adapter->wpa_ie_len;
-	memcpy(extra, &adapter->wpa_ie[0], adapter->wpa_ie_len);
+	dwrq->length = priv->wpa_ie_len;
+	memcpy(extra, &priv->wpa_ie[0], priv->wpa_ie_len);
@@ -1666 +1701 @@
-static int wlan_set_auth(struct net_device *dev,
+static int lbs_set_auth(struct net_device *dev,
@@ -1671,2 +1706 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1679,2 +1713,2 @@
-	mutex_lock(&adapter->lock);
-	assoc_req = wlan_get_association_request(adapter);
+	mutex_lock(&priv->lock);
+	assoc_req = lbs_get_association_request(priv);
@@ -1755 +1789 @@
-		wlan_postpone_association_work(priv);
+		lbs_postpone_association_work(priv);
@@ -1757 +1791 @@
-		wlan_cancel_association_work(priv);
+		lbs_cancel_association_work(priv);
@@ -1759 +1793 @@
-	mutex_unlock(&adapter->lock);
+	mutex_unlock(&priv->lock);
@@ -1765 +1799 @@
-static int wlan_get_auth(struct net_device *dev,
+static int lbs_get_auth(struct net_device *dev,
@@ -1771,2 +1805 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1779 +1812 @@
-		if (adapter->secinfo.WPAenabled)
+		if (priv->secinfo.WPAenabled)
@@ -1781 +1814 @@
-		if (adapter->secinfo.WPA2enabled)
+		if (priv->secinfo.WPA2enabled)
@@ -1788 +1821 @@
-		dwrq->value = adapter->secinfo.auth_mode;
+		dwrq->value = priv->secinfo.auth_mode;
@@ -1792 +1825 @@
-		if (adapter->secinfo.WPAenabled && adapter->secinfo.WPA2enabled)
+		if (priv->secinfo.WPAenabled && priv->secinfo.WPA2enabled)
@@ -1805 +1838 @@
-static int wlan_set_txpow(struct net_device *dev, struct iw_request_info *info,
+static int lbs_set_txpow(struct net_device *dev, struct iw_request_info *info,
@@ -1809,2 +1842 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1817 +1849 @@
-		wlan_radio_ioctl(priv, RADIO_OFF);
+		lbs_radio_ioctl(priv, RADIO_OFF);
@@ -1821 +1853 @@
-	adapter->preamble = CMD_TYPE_AUTO_PREAMBLE;
+	priv->preamble = CMD_TYPE_AUTO_PREAMBLE;
@@ -1823 +1855 @@
-	wlan_radio_ioctl(priv, RADIO_ON);
+	lbs_radio_ioctl(priv, RADIO_ON);
@@ -1839 +1871 @@
-	ret = libertas_prepare_and_send_command(priv,
+	ret = lbs_prepare_and_send_command(priv,
@@ -1848 +1880 @@
-static int wlan_get_essid(struct net_device *dev, struct iw_request_info *info,
+static int lbs_get_essid(struct net_device *dev, struct iw_request_info *info,
@@ -1851,2 +1883 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1864,4 +1895,4 @@
-	if (adapter->connect_status == LIBERTAS_CONNECTED) {
-		memcpy(extra, adapter->curbssparams.ssid,
-		       adapter->curbssparams.ssid_len);
-		extra[adapter->curbssparams.ssid_len] = '\0';
+	if (priv->connect_status == LBS_CONNECTED) {
+		memcpy(extra, priv->curbssparams.ssid,
+		       priv->curbssparams.ssid_len);
+		extra[priv->curbssparams.ssid_len] = '\0';
@@ -1870 +1901 @@
-		extra[adapter->curbssparams.ssid_len] = '\0';
+		extra[priv->curbssparams.ssid_len] = '\0';
@@ -1876 +1907 @@
-	dwrq->length = adapter->curbssparams.ssid_len;
+	dwrq->length = priv->curbssparams.ssid_len;
@@ -1884 +1915 @@
-static int wlan_set_essid(struct net_device *dev, struct iw_request_info *info,
+static int lbs_set_essid(struct net_device *dev, struct iw_request_info *info,
@@ -1887,2 +1918 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1921 +1951 @@
-	mutex_lock(&adapter->lock);
+	mutex_lock(&priv->lock);
@@ -1924 +1954 @@
-		assoc_req = wlan_get_association_request(adapter);
+		assoc_req = lbs_get_association_request(priv);
@@ -1932 +1962 @@
-			wlan_postpone_association_work(priv);
+			lbs_postpone_association_work(priv);
@@ -1938 +1968,40 @@
-		wlan_cancel_association_work(priv);
+		lbs_cancel_association_work(priv);
+	}
+
+	mutex_unlock(&priv->lock);
+
+	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
+	return ret;
+}
+
+static int lbs_mesh_get_essid(struct net_device *dev,
+			      struct iw_request_info *info,
+			      struct iw_point *dwrq, char *extra)
+{
+	struct lbs_private *priv = dev->priv;
+
+	lbs_deb_enter(LBS_DEB_WEXT);
+
+	memcpy(extra, priv->mesh_ssid, priv->mesh_ssid_len);
+
+	dwrq->length = priv->mesh_ssid_len;
+
+	dwrq->flags = 1;	/* active */
+
+	lbs_deb_leave(LBS_DEB_WEXT);
+	return 0;
+}
+
+static int lbs_mesh_set_essid(struct net_device *dev,
+			      struct iw_request_info *info,
+			      struct iw_point *dwrq, char *extra)
+{
+	struct lbs_private *priv = dev->priv;
+	int ret = 0;
+
+	lbs_deb_enter(LBS_DEB_WEXT);
+
+	/* Check the size of the string */
+	if (dwrq->length > IW_ESSID_MAX_SIZE) {
+		ret = -E2BIG;
+		goto out;
@@ -1941 +2010,8 @@
-	mutex_unlock(&adapter->lock);
+	if (!dwrq->flags || !dwrq->length) {
+		ret = -EINVAL;
+		goto out;
+	} else {
+		/* Specific SSID requested */
+		memcpy(priv->mesh_ssid, extra, dwrq->length);
+		priv->mesh_ssid_len = dwrq->length;
+	}
@@ -1942,0 +2019,2 @@
+	lbs_mesh_config(priv, 1, priv->curbssparams.channel);
+ out:
@@ -1956 +2034 @@
-static int wlan_set_wap(struct net_device *dev, struct iw_request_info *info,
+static int lbs_set_wap(struct net_device *dev, struct iw_request_info *info,
@@ -1959,2 +2037 @@
-	wlan_private *priv = dev->priv;
-	wlan_adapter *adapter = priv->adapter;
+	struct lbs_private *priv = dev->priv;
@@ -1972 +2049 @@
-	mutex_lock(&adapter->lock);
+	mutex_lock(&priv->lock);
@@ -1975 +2052 @@
-	assoc_req = wlan_get_association_request(adapter);
+	assoc_req = lbs_get_association_request(priv);
@@ -1977 +2054 @@
-		wlan_cancel_association_work(priv);
+		lbs_cancel_association_work(priv);
@@ -1983 +2060 @@
-		wlan_postpone_association_work(priv);
+		lbs_postpone_association_work(priv);
@@ -1986 +2063 @@
-	mutex_unlock(&adapter->lock);
+	mutex_unlock(&priv->lock);
@@ -1991 +2068 @@
-void libertas_get_fwversion(wlan_adapter * adapter, char *fwversion, int maxlen)
+void lbs_get_fwversion(struct lbs_private *priv, char *fwversion, int maxlen)
@@ -1995 +2072 @@
-	mutex_lock(&adapter->lock);
+	mutex_lock(&priv->lock);
@@ -1997,11 +2074,5 @@
-	if (adapter->fwreleasenumber[3] == 0)
-		sprintf(fwver, "%u.%u.%u",
-			adapter->fwreleasenumber[2],
-			adapter->fwreleasenumber[1],
-			adapter->fwreleasenumber[0]);
-	else
-		sprintf(fwver, "%u.%u.%u.p%u",
-			adapter->fwreleasenumber[2],
-			adapter->fwreleasenumber[1],
-			adapter->fwreleasenumber[0],
-			adapter->fwreleasenumber[3]);
+	sprintf(fwver, "%u.%u.%u.p%u",
+		priv->fwrelease >> 24 & 0xff,
+		priv->fwrelease >> 16 & 0xff,
+		priv->fwrelease >>  8 & 0xff,
+		priv->fwrelease       & 0xff);
@@ -2009 +2080 @@
-	mutex_unlock(&adapter->lock);
+	mutex_unlock(&priv->lock);
@@ -2017 +2088 @@
-static const iw_handler wlan_handler[] = {
+static const iw_handler lbs_handler[] = {
@@ -2019 +2090 @@
-	(iw_handler) wlan_get_name,	/* SIOCGIWNAME */
+	(iw_handler) lbs_get_name,	/* SIOCGIWNAME */
@@ -2022,4 +2093,4 @@
-	(iw_handler) wlan_set_freq,	/* SIOCSIWFREQ */
-	(iw_handler) wlan_get_freq,	/* SIOCGIWFREQ */
-	(iw_handler) wlan_set_mode,	/* SIOCSIWMODE */
-	(iw_handler) wlan_get_mode,	/* SIOCGIWMODE */
+	(iw_handler) lbs_set_freq,	/* SIOCSIWFREQ */
+	(iw_handler) lbs_get_freq,	/* SIOCGIWFREQ */
+	(iw_handler) lbs_set_mode,	/* SIOCSIWMODE */
+	(iw_handler) lbs_get_mode,	/* SIOCGIWMODE */
@@ -2029 +2100 @@
-	(iw_handler) wlan_get_range,	/* SIOCGIWRANGE */
+	(iw_handler) lbs_get_range,	/* SIOCGIWRANGE */
@@ -2038,2 +2109,2 @@
-	(iw_handler) wlan_set_wap,	/* SIOCSIWAP */
-	(iw_handler) wlan_get_wap,	/* SIOCGIWAP */
+	(iw_handler) lbs_set_wap,	/* SIOCSIWAP */
+	(iw_handler) lbs_get_wap,	/* SIOCGIWAP */
@@ -2042,6 +2113,6 @@
-	(iw_handler) libertas_set_scan,	/* SIOCSIWSCAN */
-	(iw_handler) libertas_get_scan,	/* SIOCGIWSCAN */
-	(iw_handler) wlan_set_essid,	/* SIOCSIWESSID */
-	(iw_handler) wlan_get_essid,	/* SIOCGIWESSID */
-	(iw_handler) wlan_set_nick,	/* SIOCSIWNICKN */
-	(iw_handler) wlan_get_nick,	/* SIOCGIWNICKN */
+	(iw_handler) lbs_set_scan,	/* SIOCSIWSCAN */
+	(iw_handler) lbs_get_scan,	/* SIOCGIWSCAN */
+	(iw_handler) lbs_set_essid,	/* SIOCSIWESSID */
+	(iw_handler) lbs_get_essid,	/* SIOCGIWESSID */
+	(iw_handler) lbs_set_nick,	/* SIOCSIWNICKN */
+	(iw_handler) lbs_get_nick,	/* SIOCGIWNICKN */
@@ -2050,14 +2121,14 @@
-	(iw_handler) wlan_set_rate,	/* SIOCSIWRATE */
-	(iw_handler) wlan_get_rate,	/* SIOCGIWRATE */
-	(iw_handler) wlan_set_rts,	/* SIOCSIWRTS */
-	(iw_handler) wlan_get_rts,	/* SIOCGIWRTS */
-	(iw_handler) wlan_set_frag,	/* SIOCSIWFRAG */
-	(iw_handler) wlan_get_frag,	/* SIOCGIWFRAG */
-	(iw_handler) wlan_set_txpow,	/* SIOCSIWTXPOW */
-	(iw_handler) wlan_get_txpow,	/* SIOCGIWTXPOW */
-	(iw_handler) wlan_set_retry,	/* SIOCSIWRETRY */
-	(iw_handler) wlan_get_retry,	/* SIOCGIWRETRY */
-	(iw_handler) wlan_set_encode,	/* SIOCSIWENCODE */
-	(iw_handler) wlan_get_encode,	/* SIOCGIWENCODE */
-	(iw_handler) wlan_set_power,	/* SIOCSIWPOWER */
-	(iw_handler) wlan_get_power,	/* SIOCGIWPOWER */
+	(iw_handler) lbs_set_rate,	/* SIOCSIWRATE */
+	(iw_handler) lbs_get_rate,	/* SIOCGIWRATE */
+	(iw_handler) lbs_set_rts,	/* SIOCSIWRTS */
+	(iw_handler) lbs_get_rts,	/* SIOCGIWRTS */
+	(iw_handler) lbs_set_frag,	/* SIOCSIWFRAG */
+	(iw_handler) lbs_get_frag,	/* SIOCGIWFRAG */
+	(iw_handler) lbs_set_txpow,	/* SIOCSIWTXPOW */
+	(iw_handler) lbs_get_txpow,	/* SIOCGIWTXPOW */
+	(iw_handler) lbs_set_retry,	/* SIOCSIWRETRY */
+	(iw_handler) lbs_get_retry,	/* SIOCGIWRETRY */
+	(iw_handler) lbs_set_encode,	/* SIOCSIWENCODE */
+	(iw_handler) lbs_get_encode,	/* SIOCGIWENCODE */
+	(iw_handler) lbs_set_power,	/* SIOCSIWPOWER */
+	(iw_handler) lbs_get_power,	/* SIOCGIWPOWER */
@@ -2066,6 +2137,6 @@
-	(iw_handler) wlan_set_genie,	/* SIOCSIWGENIE */
-	(iw_handler) wlan_get_genie,	/* SIOCGIWGENIE */
-	(iw_handler) wlan_set_auth,	/* SIOCSIWAUTH */
-	(iw_handler) wlan_get_auth,	/* SIOCGIWAUTH */
-	(iw_handler) wlan_set_encodeext,/* SIOCSIWENCODEEXT */
-	(iw_handler) wlan_get_encodeext,/* SIOCGIWENCODEEXT */
+	(iw_handler) lbs_set_genie,	/* SIOCSIWGENIE */
+	(iw_handler) lbs_get_genie,	/* SIOCGIWGENIE */
+	(iw_handler) lbs_set_auth,	/* SIOCSIWAUTH */
+	(iw_handler) lbs_get_auth,	/* SIOCGIWAUTH */
+	(iw_handler) lbs_set_encodeext,/* SIOCSIWENCODEEXT */
+	(iw_handler) lbs_get_encodeext,/* SIOCGIWENCODEEXT */
@@ -2077 +2148 @@
-	(iw_handler) wlan_get_name,	/* SIOCGIWNAME */
+	(iw_handler) lbs_get_name,	/* SIOCGIWNAME */
@@ -2080,2 +2151,2 @@
-	(iw_handler) wlan_set_freq,	/* SIOCSIWFREQ */
-	(iw_handler) wlan_get_freq,	/* SIOCGIWFREQ */
+	(iw_handler) lbs_mesh_set_freq,	/* SIOCSIWFREQ */
+	(iw_handler) lbs_get_freq,	/* SIOCGIWFREQ */
@@ -2087 +2158 @@
-	(iw_handler) wlan_get_range,	/* SIOCGIWRANGE */
+	(iw_handler) lbs_get_range,	/* SIOCGIWRANGE */
@@ -2100,4 +2171,4 @@
-	(iw_handler) libertas_set_scan,	/* SIOCSIWSCAN */
-	(iw_handler) libertas_get_scan,	/* SIOCGIWSCAN */
-	(iw_handler) NULL,		/* SIOCSIWESSID */
-	(iw_handler) NULL,		/* SIOCGIWESSID */
+	(iw_handler) lbs_set_scan,	/* SIOCSIWSCAN */
+	(iw_handler) lbs_get_scan,	/* SIOCGIWSCAN */
+	(iw_handler) lbs_mesh_set_essid,/* SIOCSIWESSID */
+	(iw_handler) lbs_mesh_get_essid,/* SIOCGIWESSID */
@@ -2108,14 +2179,14 @@
-	(iw_handler) wlan_set_rate,	/* SIOCSIWRATE */
-	(iw_handler) wlan_get_rate,	/* SIOCGIWRATE */
-	(iw_handler) wlan_set_rts,	/* SIOCSIWRTS */
-	(iw_handler) wlan_get_rts,	/* SIOCGIWRTS */
-	(iw_handler) wlan_set_frag,	/* SIOCSIWFRAG */
-	(iw_handler) wlan_get_frag,	/* SIOCGIWFRAG */
-	(iw_handler) wlan_set_txpow,	/* SIOCSIWTXPOW */
-	(iw_handler) wlan_get_txpow,	/* SIOCGIWTXPOW */
-	(iw_handler) wlan_set_retry,	/* SIOCSIWRETRY */
-	(iw_handler) wlan_get_retry,	/* SIOCGIWRETRY */
-	(iw_handler) wlan_set_encode,	/* SIOCSIWENCODE */
-	(iw_handler) wlan_get_encode,	/* SIOCGIWENCODE */
-	(iw_handler) wlan_set_power,	/* SIOCSIWPOWER */
-	(iw_handler) wlan_get_power,	/* SIOCGIWPOWER */
+	(iw_handler) lbs_set_rate,	/* SIOCSIWRATE */
+	(iw_handler) lbs_get_rate,	/* SIOCGIWRATE */
+	(iw_handler) lbs_set_rts,	/* SIOCSIWRTS */
+	(iw_handler) lbs_get_rts,	/* SIOCGIWRTS */
+	(iw_handler) lbs_set_frag,	/* SIOCSIWFRAG */
+	(iw_handler) lbs_get_frag,	/* SIOCGIWFRAG */
+	(iw_handler) lbs_set_txpow,	/* SIOCSIWTXPOW */
+	(iw_handler) lbs_get_txpow,	/* SIOCGIWTXPOW */
+	(iw_handler) lbs_set_retry,	/* SIOCSIWRETRY */
+	(iw_handler) lbs_get_retry,	/* SIOCGIWRETRY */
+	(iw_handler) lbs_set_encode,	/* SIOCSIWENCODE */
+	(iw_handler) lbs_get_encode,	/* SIOCGIWENCODE */
+	(iw_handler) lbs_set_power,	/* SIOCSIWPOWER */
+	(iw_handler) lbs_get_power,	/* SIOCGIWPOWER */
@@ -2124,6 +2195,6 @@
-	(iw_handler) wlan_set_genie,	/* SIOCSIWGENIE */
-	(iw_handler) wlan_get_genie,	/* SIOCGIWGENIE */
-	(iw_handler) wlan_set_auth,	/* SIOCSIWAUTH */
-	(iw_handler) wlan_get_auth,	/* SIOCGIWAUTH */
-	(iw_handler) wlan_set_encodeext,/* SIOCSIWENCODEEXT */
-	(iw_handler) wlan_get_encodeext,/* SIOCGIWENCODEEXT */
+	(iw_handler) lbs_set_genie,	/* SIOCSIWGENIE */
+	(iw_handler) lbs_get_genie,	/* SIOCGIWGENIE */
+	(iw_handler) lbs_set_auth,	/* SIOCSIWAUTH */
+	(iw_handler) lbs_get_auth,	/* SIOCGIWAUTH */
+	(iw_handler) lbs_set_encodeext,/* SIOCSIWENCODEEXT */
+	(iw_handler) lbs_get_encodeext,/* SIOCGIWENCODEEXT */
@@ -2132,4 +2203,4 @@
-struct iw_handler_def libertas_handler_def = {
-	.num_standard	= ARRAY_SIZE(wlan_handler),
-	.standard	= (iw_handler *) wlan_handler,
-	.get_wireless_stats = wlan_get_wireless_stats,
+struct iw_handler_def lbs_handler_def = {
+	.num_standard	= ARRAY_SIZE(lbs_handler),
+	.standard	= (iw_handler *) lbs_handler,
+	.get_wireless_stats = lbs_get_wireless_stats,
@@ -2141 +2212 @@
-	.get_wireless_stats = wlan_get_wireless_stats,
+	.get_wireless_stats = lbs_get_wireless_stats,
--- ./projects/linux/linux-2.6.25/drivers/net/wireless/libertas/wext.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/net/wireless/libertas/wext.c	2008-07-13 23:51:29.000000000 +0200
@@ -19 +18,0 @@
-#include "join.h"
@@ -20,0 +20 @@
+#include "scan.h"
@@ -581,0 +582,3 @@
+
+	range->scan_capa = IW_SCAN_CAPA_ESSID;
+
@@ -605 +608 @@
-			    (long)lbs_chan_2_freq(chan_no, band) * 100000;
+			    (long)lbs_chan_2_freq(chan_no) * 100000;
@@ -656,7 +659,4 @@
-	range->min_pmp = 1000000;
-	range->max_pmp = 120000000;
-	range->min_pmt = 1000;
-	range->max_pmt = 1000000;
-	range->pmp_flags = IW_POWER_PERIOD;
-	range->pmt_flags = IW_POWER_TIMEOUT;
-	range->pm_capa = IW_POWER_PERIOD | IW_POWER_TIMEOUT | IW_POWER_ALL_R;
+	/*
+	 * Right now we support only "iwconfig ethX power on|off"
+	 */
+	range->pm_capa = IW_POWER_ON;
@@ -784 +783,0 @@
-	int mode;
@@ -788,8 +786,0 @@
-	mode = priv->psmode;
-
-	if ((vwrq->disabled = (mode == LBS802_11POWERMODECAM))
-	    || priv->connect_status == LBS_DISCONNECTED)
-	{
-		goto out;
-	}
-
@@ -796,0 +788,3 @@
+	vwrq->flags = 0;
+	vwrq->disabled = priv->psmode == LBS802_11POWERMODECAM
+		|| priv->connect_status == LBS_DISCONNECTED;
@@ -798 +791,0 @@
-out:
@@ -819,0 +813 @@
+	struct cmd_ds_802_11_get_log log;
@@ -863 +857,5 @@
-	tx_retries = le32_to_cpu(priv->logmsg.retry);
+	memset(&log, 0, sizeof(log));
+	log.hdr.size = cpu_to_le16(sizeof(log));
+	lbs_cmd_with_response(priv, CMD_802_11_GET_LOG, &log);
+
+	tx_retries = le32_to_cpu(log.retry);
@@ -879,2 +877 @@
-	priv->wstats.discard.code = le32_to_cpu(priv->logmsg.wepundecryptable);
-	priv->wstats.discard.fragment = le32_to_cpu(priv->logmsg.rxfrag);
+	priv->wstats.discard.code = le32_to_cpu(log.wepundecryptable);
@@ -882 +879 @@
-	priv->wstats.discard.misc = le32_to_cpu(priv->logmsg.ackfailure);
+	priv->wstats.discard.misc = le32_to_cpu(log.ackfailure);
@@ -892,2 +888,0 @@
-	lbs_prepare_and_send_command(priv, CMD_802_11_GET_LOG, 0,
-					0, 0, NULL);
@@ -2068,17 +2062,0 @@
-void lbs_get_fwversion(struct lbs_private *priv, char *fwversion, int maxlen)
-{
-	char fwver[32];
-
-	mutex_lock(&priv->lock);
-
-	sprintf(fwver, "%u.%u.%u.p%u",
-		priv->fwrelease >> 24 & 0xff,
-		priv->fwrelease >> 16 & 0xff,
-		priv->fwrelease >>  8 & 0xff,
-		priv->fwrelease       & 0xff);
-
-	mutex_unlock(&priv->lock);
-	snprintf(fwversion, maxlen, fwver);
-}
-
-
--- ./projects/linux/linux-2.6.26/drivers/net/wireless/libertas/wext.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/net/wireless/libertas/wext.c	2008-10-10 00:13:53.000000000 +0200
@@ -1005 +1005 @@
-	lbs_mesh_config(priv, 1, fwrq->m);
+	lbs_mesh_config(priv, CMD_ACT_MESH_CONFIG_START, fwrq->m);
@@ -1023,0 +1024,4 @@
+	lbs_deb_wext("vwrq->fixed %d\n", vwrq->fixed);
+
+	if (vwrq->fixed && vwrq->value == -1)
+		goto out;
@@ -1026,2 +1030,3 @@
-	if (vwrq->value == -1) {
-		priv->auto_rate = 1;
+	priv->enablehwauto = !vwrq->fixed;
+
+	if (vwrq->value == -1)
@@ -1029 +1034 @@
-	} else {
+	else {
@@ -1032,0 +1038,3 @@
+		new_rate = vwrq->value / 500000;
+		priv->cur_rate = new_rate;
+		/* the rest is only needed for lbs_set_data_rate() */
@@ -1035 +1042,0 @@
-		new_rate = vwrq->value / 500000;
@@ -1041,3 +1047,0 @@
-
-		priv->cur_rate = new_rate;
-		priv->auto_rate = 0;
@@ -1046 +1050,6 @@
-	ret = lbs_set_data_rate(priv, new_rate);
+	/* Try the newer command first (Firmware Spec 5.1 and above) */
+	ret = lbs_cmd_802_11_rate_adapt_rateset(priv, CMD_ACT_SET);
+
+	/* Fallback to older version */
+	if (ret)
+		ret = lbs_set_data_rate(priv, new_rate);
@@ -1063 +1072 @@
-		if (priv->auto_rate)
+		if (priv->enablehwauto)
@@ -2014 +2023,2 @@
-	lbs_mesh_config(priv, 1, priv->curbssparams.channel);
+	lbs_mesh_config(priv, CMD_ACT_MESH_CONFIG_START,
+			priv->curbssparams.channel);
--- ./projects/linux/linux-2.6.27/drivers/net/wireless/libertas/wext.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/net/wireless/libertas/wext.c	2008-12-25 00:26:37.000000000 +0100
@@ -32,0 +33,8 @@
+static inline void lbs_do_association_work(struct lbs_private *priv)
+{
+	if (priv->surpriseremoved)
+		return;
+	cancel_delayed_work(&priv->assoc_work);
+	queue_delayed_work(priv->work_thread, &priv->assoc_work, 0);
+}
+
@@ -123,28 +130,0 @@
-
-/**
- *  @brief Set Radio On/OFF
- *
- *  @param priv                 A pointer to struct lbs_private structure
- *  @option 			Radio Option
- *  @return 	   		0 --success, otherwise fail
- */
-static int lbs_radio_ioctl(struct lbs_private *priv, u8 option)
-{
-	int ret = 0;
-
-	lbs_deb_enter(LBS_DEB_WEXT);
-
-	if (priv->radioon != option) {
-		lbs_deb_wext("switching radio %s\n", option ? "on" : "off");
-		priv->radioon = option;
-
-		ret = lbs_prepare_and_send_command(priv,
-					    CMD_802_11_RADIO_CONTROL,
-					    CMD_ACT_SET,
-					    CMD_OPTION_WAITFORRSP, 0, NULL);
-	}
-
-	lbs_deb_leave_args(LBS_DEB_WEXT, "ret %d", ret);
-	return ret;
-}
-
@@ -297 +277 @@
-	u32 rthr = vwrq->value;
+	u32 val = vwrq->value;
@@ -301,7 +281,2 @@
-	if (vwrq->disabled) {
-		priv->rtsthsd = rthr = MRVDRV_RTS_MAX_VALUE;
-	} else {
-		if (rthr < MRVDRV_RTS_MIN_VALUE || rthr > MRVDRV_RTS_MAX_VALUE)
-			return -EINVAL;
-		priv->rtsthsd = rthr;
-	}
+	if (vwrq->disabled)
+		val = MRVDRV_RTS_MAX_VALUE;
@@ -309,3 +284,4 @@
-	ret = lbs_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
-				    CMD_ACT_SET, CMD_OPTION_WAITFORRSP,
-				    OID_802_11_RTS_THRESHOLD, &rthr);
+	if (val > MRVDRV_RTS_MAX_VALUE) /* min rts value is 0 */
+		return -EINVAL;
+
+	ret = lbs_set_snmp_mib(priv, SNMP_MIB_OID_RTS_THRESHOLD, (u16) val);
@@ -320 +295,0 @@
-	int ret = 0;
@@ -321,0 +297,2 @@
+	int ret = 0;
+	u16 val = 0;
@@ -325,4 +302 @@
-	priv->rtsthsd = 0;
-	ret = lbs_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
-				    CMD_ACT_GET, CMD_OPTION_WAITFORRSP,
-				    OID_802_11_RTS_THRESHOLD, NULL);
+	ret = lbs_get_snmp_mib(priv, SNMP_MIB_OID_RTS_THRESHOLD, &val);
@@ -332,3 +306,2 @@
-	vwrq->value = priv->rtsthsd;
-	vwrq->disabled = ((vwrq->value < MRVDRV_RTS_MIN_VALUE)
-			  || (vwrq->value > MRVDRV_RTS_MAX_VALUE));
+	vwrq->value = val;
+	vwrq->disabled = val > MRVDRV_RTS_MAX_VALUE; /* min rts value is 0 */
@@ -345,2 +317,0 @@
-	int ret = 0;
-	u32 fthr = vwrq->value;
@@ -347,0 +319,2 @@
+	int ret = 0;
+	u32 val = vwrq->value;
@@ -351,8 +324,5 @@
-	if (vwrq->disabled) {
-		priv->fragthsd = fthr = MRVDRV_FRAG_MAX_VALUE;
-	} else {
-		if (fthr < MRVDRV_FRAG_MIN_VALUE
-		    || fthr > MRVDRV_FRAG_MAX_VALUE)
-			return -EINVAL;
-		priv->fragthsd = fthr;
-	}
+	if (vwrq->disabled)
+		val = MRVDRV_FRAG_MAX_VALUE;
+
+	if (val < MRVDRV_FRAG_MIN_VALUE || val > MRVDRV_FRAG_MAX_VALUE)
+		return -EINVAL;
@@ -360,3 +330 @@
-	ret = lbs_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
-				    CMD_ACT_SET, CMD_OPTION_WAITFORRSP,
-				    OID_802_11_FRAGMENTATION_THRESHOLD, &fthr);
+	ret = lbs_set_snmp_mib(priv, SNMP_MIB_OID_FRAG_THRESHOLD, (u16) val);
@@ -371 +338,0 @@
-	int ret = 0;
@@ -372,0 +340,2 @@
+	int ret = 0;
+	u16 val = 0;
@@ -376,5 +345 @@
-	priv->fragthsd = 0;
-	ret = lbs_prepare_and_send_command(priv,
-				    CMD_802_11_SNMP_MIB,
-				    CMD_ACT_GET, CMD_OPTION_WAITFORRSP,
-				    OID_802_11_FRAGMENTATION_THRESHOLD, NULL);
+	ret = lbs_get_snmp_mib(priv, SNMP_MIB_OID_FRAG_THRESHOLD, &val);
@@ -384,3 +349,3 @@
-	vwrq->value = priv->fragthsd;
-	vwrq->disabled = ((vwrq->value < MRVDRV_FRAG_MIN_VALUE)
-			  || (vwrq->value > MRVDRV_FRAG_MAX_VALUE));
+	vwrq->value = val;
+	vwrq->disabled = ((val < MRVDRV_FRAG_MIN_VALUE)
+			  || (val > MRVDRV_FRAG_MAX_VALUE));
@@ -413 +378 @@
-	*uwrq = IW_MODE_REPEAT ;
+	*uwrq = IW_MODE_REPEAT;
@@ -423 +387,0 @@
-	int ret = 0;
@@ -424,0 +389,2 @@
+	s16 curlevel = 0;
+	int ret = 0;
@@ -428,4 +394,6 @@
-	ret = lbs_prepare_and_send_command(priv,
-				    CMD_802_11_RF_TX_POWER,
-				    CMD_ACT_TX_POWER_OPT_GET,
-				    CMD_OPTION_WAITFORRSP, 0, NULL);
+	if (!priv->radio_on) {
+		lbs_deb_wext("tx power off\n");
+		vwrq->value = 0;
+		vwrq->disabled = 1;
+		goto out;
+	}
@@ -432,0 +401 @@
+	ret = lbs_get_tx_power(priv, &curlevel, NULL, NULL);
@@ -436,2 +405,4 @@
-	lbs_deb_wext("tx power level %d dbm\n", priv->txpowerlevel);
-	vwrq->value = priv->txpowerlevel;
+	lbs_deb_wext("tx power level %d dbm\n", curlevel);
+	priv->txpower_cur = curlevel;
+
+	vwrq->value = curlevel;
@@ -439,6 +410,2 @@
-	if (priv->radioon) {
-		vwrq->disabled = 0;
-		vwrq->flags = IW_TXPOW_DBM;
-	} else {
-		vwrq->disabled = 1;
-	}
+	vwrq->disabled = 0;
+	vwrq->flags = IW_TXPOW_DBM;
@@ -454 +420,0 @@
-	int ret = 0;
@@ -455,0 +422,2 @@
+	int ret = 0;
+	u16 slimit = 0, llimit = 0;
@@ -459,3 +427,5 @@
-	if (vwrq->flags == IW_RETRY_LIMIT) {
-		/* The MAC has a 4-bit Total_Tx_Count register
-		   Total_Tx_Count = 1 + Tx_Retry_Count */
+        if ((vwrq->flags & IW_RETRY_TYPE) != IW_RETRY_LIMIT)
+                return -EOPNOTSUPP;
+
+	/* The MAC has a 4-bit Total_Tx_Count register
+	   Total_Tx_Count = 1 + Tx_Retry_Count */
@@ -464,2 +434,2 @@
-		if (vwrq->value < TX_RETRY_MIN || vwrq->value > TX_RETRY_MAX)
-			return -EINVAL;
+	if (vwrq->value < TX_RETRY_MIN || vwrq->value > TX_RETRY_MAX)
+		return -EINVAL;
@@ -467,2 +437,7 @@
-		/* Adding 1 to convert retry count to try count */
-		priv->txretrycount = vwrq->value + 1;
+	/* Add 1 to convert retry count to try count */
+	if (vwrq->flags & IW_RETRY_SHORT)
+		slimit = (u16) (vwrq->value + 1);
+	else if (vwrq->flags & IW_RETRY_LONG)
+		llimit = (u16) (vwrq->value + 1);
+	else
+		slimit = llimit = (u16) (vwrq->value + 1); /* set both */
@@ -470,4 +445,6 @@
-		ret = lbs_prepare_and_send_command(priv, CMD_802_11_SNMP_MIB,
-					    CMD_ACT_SET,
-					    CMD_OPTION_WAITFORRSP,
-					    OID_802_11_TX_RETRYCOUNT, NULL);
+	if (llimit) {
+		ret = lbs_set_snmp_mib(priv, SNMP_MIB_OID_LONG_RETRY_LIMIT,
+				       llimit);
+		if (ret)
+			goto out;
+	}
@@ -474,0 +452,5 @@
+	if (slimit) {
+		/* txretrycount follows the short retry limit */
+		priv->txretrycount = slimit;
+		ret = lbs_set_snmp_mib(priv, SNMP_MIB_OID_SHORT_RETRY_LIMIT,
+				       slimit);
@@ -477,2 +458,0 @@
-	} else {
-		return -EOPNOTSUPP;
@@ -490,0 +471 @@
+	u16 val = 0;
@@ -494,8 +474,0 @@
-	priv->txretrycount = 0;
-	ret = lbs_prepare_and_send_command(priv,
-				    CMD_802_11_SNMP_MIB,
-				    CMD_ACT_GET, CMD_OPTION_WAITFORRSP,
-				    OID_802_11_TX_RETRYCOUNT, NULL);
-	if (ret)
-		goto out;
-
@@ -503,2 +476,16 @@
-	if (!vwrq->flags) {
-		vwrq->flags = IW_RETRY_LIMIT;
+
+	if (vwrq->flags & IW_RETRY_LONG) {
+		ret = lbs_get_snmp_mib(priv, SNMP_MIB_OID_LONG_RETRY_LIMIT, &val);
+		if (ret)
+			goto out;
+
+		/* Subtract 1 to convert try count to retry count */
+		vwrq->value = val - 1;
+		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;
+	} else {
+		ret = lbs_get_snmp_mib(priv, SNMP_MIB_OID_SHORT_RETRY_LIMIT, &val);
+		if (ret)
+			goto out;
+
+		/* txretry count follows the short retry limit */
+		priv->txretrycount = val;
@@ -506 +493,2 @@
-		vwrq->value = priv->txretrycount - 1;
+		vwrq->value = val - 1;
+		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_SHORT;
@@ -696,3 +684 @@
-	/*
-	 * Setup the supported power level ranges
-	 */
+	/* Setup the supported power level ranges */
@@ -700,12 +686,4 @@
-	range->txpower[0] = 5;
-	range->txpower[1] = 7;
-	range->txpower[2] = 9;
-	range->txpower[3] = 11;
-	range->txpower[4] = 13;
-	range->txpower[5] = 15;
-	range->txpower[6] = 17;
-	range->txpower[7] = 19;
-
-	range->num_txpower = 8;
-	range->txpower_capa = IW_TXPOW_DBM;
-	range->txpower_capa |= IW_TXPOW_RANGE;
+	range->txpower_capa = IW_TXPOW_DBM | IW_TXPOW_RANGE;
+	range->txpower[0] = priv->txpower_min;
+	range->txpower[1] = priv->txpower_max;
+	range->num_txpower = 2;
@@ -1001 +979,3 @@
-			lbs_send_deauthentication(priv);
+			lbs_cmd_80211_deauthenticate(priv,
+						     priv->curbssparams.bssid,
+						     WLAN_REASON_DEAUTH_LEAVING);
@@ -1003 +983 @@
-			lbs_stop_adhoc_network(priv);
+			lbs_adhoc_stop(priv);
@@ -1047,0 +1028,12 @@
+		if (priv->fwrelease < 0x09000000) {
+			ret = lbs_set_power_adapt_cfg(priv, 0,
+					POW_ADAPT_DEFAULT_P0,
+					POW_ADAPT_DEFAULT_P1,
+					POW_ADAPT_DEFAULT_P2);
+			if (ret)
+				goto out;
+		}
+		ret = lbs_set_tpc_cfg(priv, 0, TPC_DEFAULT_P0, TPC_DEFAULT_P1,
+				TPC_DEFAULT_P2, 1);
+		if (ret)
+			goto out;
@@ -1615 +1607,3 @@
-		disable_wep (assoc_req);
+		/* Only disable wep if necessary: can't waste time here. */
+		if (priv->mac_control & CMD_ACT_MAC_WEP_ENABLE)
+			disable_wep(assoc_req);
@@ -1620 +1614,13 @@
-		lbs_postpone_association_work(priv);
+		/* 802.1x and WPA rekeying must happen as quickly as possible,
+		 * especially during the 4-way handshake; thus if in
+		 * infrastructure mode, and either (a) 802.1x is enabled or
+		 * (b) WPA is being used, set the key right away.
+		 */
+		if (assoc_req->mode == IW_MODE_INFRA &&
+		    ((assoc_req->secinfo.key_mgmt & IW_AUTH_KEY_MGMT_802_1X) ||
+		     (assoc_req->secinfo.key_mgmt & IW_AUTH_KEY_MGMT_PSK) ||
+		      assoc_req->secinfo.WPAenabled ||
+		      assoc_req->secinfo.WPA2enabled)) {
+			lbs_do_association_work(priv);
+		} else
+			lbs_postpone_association_work(priv);
@@ -1728 +1733,0 @@
-	case IW_AUTH_KEY_MGMT:
@@ -1734,0 +1740,5 @@
+	case IW_AUTH_KEY_MGMT:
+		assoc_req->secinfo.key_mgmt = dwrq->value;
+		updated = 1;
+		break;
+
@@ -1813,0 +1824,4 @@
+	case IW_AUTH_KEY_MGMT:
+		dwrq->value = priv->secinfo.key_mgmt;
+		break;
+
@@ -1847,2 +1861 @@
-
-	u16 dbm;
+	s16 dbm = (s16) vwrq->value;
@@ -1853,2 +1866,2 @@
-		lbs_radio_ioctl(priv, RADIO_OFF);
-		return 0;
+		lbs_set_radio(priv, RADIO_PREAMBLE_AUTO, 0);
+		goto out;
@@ -1857,3 +1870,24 @@
-	priv->preamble = CMD_TYPE_AUTO_PREAMBLE;
-
-	lbs_radio_ioctl(priv, RADIO_ON);
+	if (vwrq->fixed == 0) {
+		/* User requests automatic tx power control, however there are
+		 * many auto tx settings.  For now use firmware defaults until
+		 * we come up with a good way to expose these to the user. */
+		if (priv->fwrelease < 0x09000000) {
+			ret = lbs_set_power_adapt_cfg(priv, 1,
+					POW_ADAPT_DEFAULT_P0,
+					POW_ADAPT_DEFAULT_P1,
+					POW_ADAPT_DEFAULT_P2);
+			if (ret)
+				goto out;
+		}
+		ret = lbs_set_tpc_cfg(priv, 0, TPC_DEFAULT_P0, TPC_DEFAULT_P1,
+				TPC_DEFAULT_P2, 1);
+		if (ret)
+			goto out;
+		dbm = priv->txpower_max;
+	} else {
+		/* Userspace check in iwrange if it should use dBm or mW,
+		 * therefore this should never happen... Jean II */
+		if ((vwrq->flags & IW_TXPOW_TYPE) != IW_TXPOW_DBM) {
+			ret = -EOPNOTSUPP;
+			goto out;
+		}
@@ -1861,6 +1895,6 @@
-	/* Userspace check in iwrange if it should use dBm or mW,
-	 * therefore this should never happen... Jean II */
-	if ((vwrq->flags & IW_TXPOW_TYPE) == IW_TXPOW_MWATT) {
-		return -EOPNOTSUPP;
-	} else
-		dbm = (u16) vwrq->value;
+		/* Validate requested power level against firmware allowed
+		 * levels */
+		if (priv->txpower_min && (dbm < priv->txpower_min)) {
+			ret = -EINVAL;
+			goto out;
+		}
@@ -1868 +1902,17 @@
-	/* auto tx power control */
+		if (priv->txpower_max && (dbm > priv->txpower_max)) {
+			ret = -EINVAL;
+			goto out;
+		}
+		if (priv->fwrelease < 0x09000000) {
+			ret = lbs_set_power_adapt_cfg(priv, 0,
+					POW_ADAPT_DEFAULT_P0,
+					POW_ADAPT_DEFAULT_P1,
+					POW_ADAPT_DEFAULT_P2);
+			if (ret)
+				goto out;
+		}
+		ret = lbs_set_tpc_cfg(priv, 0, TPC_DEFAULT_P0, TPC_DEFAULT_P1,
+				TPC_DEFAULT_P2, 1);
+		if (ret)
+			goto out;
+	}
@@ -1870,2 +1920,6 @@
-	if (vwrq->fixed == 0)
-		dbm = 0xffff;
+	/* If the radio was off, turn it on */
+	if (!priv->radio_on) {
+		ret = lbs_set_radio(priv, RADIO_PREAMBLE_AUTO, 1);
+		if (ret)
+			goto out;
+	}
@@ -1873 +1927 @@
-	lbs_deb_wext("txpower set %d dbm\n", dbm);
+	lbs_deb_wext("txpower set %d dBm\n", dbm);
@@ -1875,4 +1929 @@
-	ret = lbs_prepare_and_send_command(priv,
-				    CMD_802_11_RF_TX_POWER,
-				    CMD_ACT_TX_POWER_OPT_SET_LOW,
-				    CMD_OPTION_WAITFORRSP, 0, (void *)&dbm);
+	ret = lbs_set_tx_power(priv, dbm);
@@ -1879,0 +1931 @@
+out:
@@ -1930,0 +1983,5 @@
+	if (!priv->radio_on) {
+		ret = -EINVAL;
+		goto out;
+	}
+
@@ -2007,0 +2065,5 @@
+	if (!priv->radio_on) {
+		ret = -EINVAL;
+		goto out;
+	}
+
@@ -2048,0 +2111,3 @@
+	if (!priv->radio_on)
+		return -EINVAL;
+
--- ./projects/linux/linux-2.6.28/drivers/net/wireless/libertas/wext.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/net/wireless/libertas/wext.c	2009-03-24 00:12:14.000000000 +0100
@@ -11 +11 @@
-#include <net/ieee80211.h>
+#include <net/lib80211.h>
@@ -166 +166 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -192 +192 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -210 +210 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -234 +234 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -251 +251 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -276 +276 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -296 +296 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -318 +318 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -339 +339 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -362 +362 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -388 +388 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -421 +421 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -469 +469 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -545 +545 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -711 +711 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -761 +761 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -784 +784 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -889 +889 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -946 +946 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -997 +997 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1057 +1057 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1082 +1082 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1127 +1127 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1322 +1322 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1398 +1398 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1504 +1504 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1642 +1642 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1688 +1688 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1716 +1716 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1819 +1819 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1860 +1860 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1939 +1939 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1974 +1974 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -1979,0 +1980 @@
+	DECLARE_SSID_BUF(ssid_buf);
@@ -2008 +2009 @@
-		             escape_essid(ssid, ssid_len));
+		             print_ssid(ssid_buf, ssid, ssid_len));
@@ -2042 +2043 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -2060 +2061 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -2104 +2105 @@
-	struct lbs_private *priv = dev->priv;
+	struct lbs_private *priv = dev->ml_priv;
@@ -2107 +2107,0 @@
-	DECLARE_MAC_BUF(mac);
@@ -2117 +2117 @@
-	lbs_deb_wext("ASSOC: WAP: sa_data %s\n", print_mac(mac, awrq->sa_data));
+	lbs_deb_wext("ASSOC: WAP: sa_data %pM\n", awrq->sa_data);
--- ./projects/linux/linux-2.6.29/drivers/net/wireless/libertas/wext.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/net/wireless/libertas/wext.c	2009-06-27 11:32:32.000000000 +0200
@@ -833 +833 @@
-	priv->wstats.discard.retries = priv->stats.tx_errors;
+	priv->wstats.discard.retries = dev->stats.tx_errors;
--- ./projects/linux/linux-2.6.24/drivers/net/wireless/p54common.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/net/wireless/p54common.c	2008-04-17 04:49:44.000000000 +0200
@@ -57 +57 @@
-			switch (be32_to_cpu(*bootrec->data)) {
+			switch (be32_to_cpu(*(__be32 *)bootrec->data)) {
@@ -81 +81 @@
-			priv->rx_start = le32_to_cpu(bootrec->data[1]);
+			priv->rx_start = le32_to_cpu(((__le32 *)bootrec->data)[1]);
@@ -83 +83 @@
-			priv->rx_end = le32_to_cpu(bootrec->data[2]) - 0x3500;
+			priv->rx_end = le32_to_cpu(((__le32 *)bootrec->data)[2]) - 0x3500;
@@ -88 +88 @@
-				if (exp_if[i].if_id == 0x1a)
+				if (exp_if[i].if_id == cpu_to_le16(0x1a))
@@ -169 +168,0 @@
-	int i = 0;
@@ -172,0 +172 @@
+	u8 *end = (u8 *)eeprom + len;
@@ -175,4 +175,4 @@
-	entry = (void *)wrap->data + wrap->len;
-	i += 2;
-	i += le16_to_cpu(entry->len)*2;
-	while (i < len) {
+	entry = (void *)wrap->data + le16_to_cpu(wrap->len);
+
+	/* verify that at least the entry length/code fits */
+	while ((u8 *)entry <= end - sizeof(*entry)) {
@@ -180,0 +181,5 @@
+
+		/* abort if entry exceeds whole structure */
+		if ((u8 *)entry + sizeof(*entry) + data_len > end)
+			break;
+
@@ -252 +257,2 @@
-			i = len;
+			/* make it overrun */
+			entry_len = len;
@@ -257,2 +262,0 @@
-		i += 2;
-		i += entry_len*2;
@@ -316,0 +321 @@
+	rx_status.flag |= RX_FLAG_TSFT;
@@ -377 +382 @@
-			if (!status.control.flags & IEEE80211_TXCTL_NO_ACK) {
+			if (!(status.control.flags & IEEE80211_TXCTL_NO_ACK)) {
@@ -856 +861,2 @@
-static int p54_config_interface(struct ieee80211_hw *dev, int if_id,
+static int p54_config_interface(struct ieee80211_hw *dev,
+				struct ieee80211_vif *vif,
--- ./projects/linux/linux-2.6.13/drivers/net/wireless/prism54/isl_ioctl.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/net/wireless/prism54/isl_ioctl.c	2005-10-28 02:02:08.000000000 +0200
@@ -2729,0 +2730,3 @@
+#if WIRELESS_EXT > 16
+	.get_wireless_stats = prism54_get_wireless_stats,
+#endif /* WIRELESS_EXT > 16 */
--- ./projects/linux/linux-2.6.14/drivers/net/wireless/prism54/isl_ioctl.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/net/wireless/prism54/isl_ioctl.c	2006-01-03 04:21:10.000000000 +0100
@@ -23 +22,0 @@
-#include <linux/version.h>
@@ -465 +463,0 @@
-#if WIRELESS_EXT > 16
@@ -472 +469,0 @@
-#endif /* WIRELESS_EXT > 16 */
@@ -696 +693 @@
-#if WIRELESS_EXT > 16
+
@@ -703 +699,0 @@
-#endif /* WIRELESS_EXT > 16 */
@@ -2730 +2725,0 @@
-#if WIRELESS_EXT > 16
@@ -2732,4 +2726,0 @@
-#endif /* WIRELESS_EXT > 16 */
-#if WIRELESS_EXT == 16
-	.spy_offset = offsetof(islpci_private, spy_data),
-#endif /* WIRELESS_EXT == 16 */
--- ./projects/linux/linux-2.6.15/drivers/net/wireless/prism54/isl_ioctl.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/net/wireless/prism54/isl_ioctl.c	2006-03-20 06:53:29.000000000 +0100
@@ -751 +751 @@
-		dwrq->length = min(IW_ESSID_MAX_SIZE, essid->length + 1);
+		dwrq->length = min((u8)IW_ESSID_MAX_SIZE, essid->length);
--- ./projects/linux/linux-2.6.16/drivers/net/wireless/prism54/isl_ioctl.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/net/wireless/prism54/isl_ioctl.c	2006-06-18 03:49:35.000000000 +0200
@@ -750 +750 @@
-		/* if it is to big, trunk it */
+		/* if it is too big, trunk it */
--- ./projects/linux/linux-2.6.18/drivers/net/wireless/prism54/isl_ioctl.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/net/wireless/prism54/isl_ioctl.c	2006-11-29 22:57:37.000000000 +0100
@@ -37,0 +38,4 @@
+#define KEY_SIZE_WEP104 13	/* 104/128-bit WEP keys */
+#define KEY_SIZE_WEP40  5	/* 40/64-bit WEP keys */
+/* KEY_SIZE_TKIP should match isl_oid.h, struct obj_key.key[] size */
+#define KEY_SIZE_TKIP   32	/* TKIP keys */
@@ -39 +43 @@
-static void prism54_wpa_ie_add(islpci_private *priv, u8 *bssid,
+static void prism54_wpa_bss_ie_add(islpci_private *priv, u8 *bssid,
@@ -41 +45 @@
-static size_t prism54_wpa_ie_get(islpci_private *priv, u8 *bssid, u8 *wpa_ie);
+static size_t prism54_wpa_bss_ie_get(islpci_private *priv, u8 *bssid, u8 *wpa_ie);
@@ -44,0 +49,4 @@
+/* In 500 kbps */
+static const unsigned char scan_rate_list[] = { 2, 4, 11, 22,
+						12, 18, 24, 36,
+						48, 72, 96, 108 };
@@ -470,0 +479,3 @@
+	range->enc_capa = IW_ENC_CAPA_WPA | IW_ENC_CAPA_WPA2 |
+		IW_ENC_CAPA_CIPHER_TKIP;
+
@@ -569,0 +581,2 @@
+	u8 wpa_ie[MAX_WPA_IE_LEN];
+	size_t wpa_ie_len;
@@ -630,4 +643,11 @@
-	if (priv->wpa) {
-		u8 wpa_ie[MAX_WPA_IE_LEN];
-		char *buf, *p;
-		size_t wpa_ie_len;
+	/* Add WPA/RSN Information Element, if any */
+	wpa_ie_len = prism54_wpa_bss_ie_get(priv, bss->address, wpa_ie);
+	if (wpa_ie_len > 0) {
+		iwe.cmd = IWEVGENIE;
+		iwe.u.data.length = min(wpa_ie_len, (size_t)MAX_WPA_IE_LEN);
+		current_ev = iwe_stream_add_point(current_ev, end_buf,
+				&iwe, wpa_ie);
+	}
+	/* Do the bitrates */
+	{
+		char *	current_val = current_ev + IW_EV_LCP_LEN;
@@ -634,0 +655 @@
+		int mask;
@@ -636,7 +657,12 @@
-		wpa_ie_len = prism54_wpa_ie_get(priv, bss->address, wpa_ie);
-		if (wpa_ie_len > 0 &&
-		    (buf = kmalloc(wpa_ie_len * 2 + 10, GFP_ATOMIC))) {
-			p = buf;
-			p += sprintf(p, "wpa_ie=");
-			for (i = 0; i < wpa_ie_len; i++) {
-				p += sprintf(p, "%02x", wpa_ie[i]);
+		iwe.cmd = SIOCGIWRATE;
+		/* Those two flags are ignored... */
+		iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+
+		/* Parse the bitmask */
+		mask = 0x1;
+		for(i = 0; i < sizeof(scan_rate_list); i++) {
+			if(bss->rates & mask) {
+				iwe.u.bitrate.value = (scan_rate_list[i] * 500000);
+				current_val = iwe_stream_add_value(current_ev, current_val,
+								   end_buf, &iwe,
+								   IW_EV_PARAM_LEN);
@@ -644,6 +670 @@
-			memset(&iwe, 0, sizeof (iwe));
-			iwe.cmd = IWEVCUSTOM;
-			iwe.u.data.length = strlen(buf);
-			current_ev = iwe_stream_add_point(current_ev, end_buf,
-							  &iwe, buf);
-			kfree(buf);
+			mask <<= 1;
@@ -650,0 +672,3 @@
+		/* Check if we added any event */
+		if ((current_val - current_ev) > IW_EV_LCP_LEN)
+			current_ev = current_val;
@@ -651,0 +676 @@
+
@@ -720 +745 @@
-		if (dwrq->length > min(33, IW_ESSID_MAX_SIZE + 1))
+		if (dwrq->length > 32)
@@ -722 +747 @@
-		essid.length = dwrq->length - 1;
+		essid.length = dwrq->length;
@@ -792 +817 @@
-	dwrq->length = strlen(priv->nickname) + 1;
+	dwrq->length = strlen(priv->nickname);
@@ -970 +995 @@
-		if (vwrq->flags & IW_RETRY_MIN)
+		if (vwrq->flags & IW_RETRY_SHORT)
@@ -972 +997 @@
-		else if (vwrq->flags & IW_RETRY_MAX)
+		else if (vwrq->flags & IW_RETRY_LONG)
@@ -1013 +1038 @@
-	} else if ((vwrq->flags & IW_RETRY_MAX)) {
+	} else if ((vwrq->flags & IW_RETRY_LONG)) {
@@ -1018 +1043 @@
-		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_MAX;
+		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_LONG;
@@ -1024 +1049 @@
-		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_MIN;
+		vwrq->flags = IW_RETRY_LIMIT | IW_RETRY_SHORT;
@@ -1054,5 +1079,6 @@
-			key.length = dwrq->length > sizeof (key.key) ?
-			    sizeof (key.key) : dwrq->length;
-			memcpy(key.key, extra, key.length);
-			if (key.length == 32)
-				/* we want WPA-PSK */
+			if (dwrq->length > KEY_SIZE_TKIP) {
+				/* User-provided key data too big */
+				return -EINVAL;
+			}
+			if (dwrq->length > KEY_SIZE_WEP104) {
+				/* WPA-PSK TKIP */
@@ -1059,0 +1086,11 @@
+				key.length = KEY_SIZE_TKIP;
+			} else if (dwrq->length > KEY_SIZE_WEP40) {
+				/* WEP 104/128 */
+				key.length = KEY_SIZE_WEP104;
+			} else {
+				/* WEP 40/64 */
+				key.length = KEY_SIZE_WEP40;
+			}
+			memset(key.key, 0, sizeof (key.key));
+			memcpy(key.key, extra, dwrq->length);
+
@@ -1212,0 +1250,483 @@
+static int prism54_set_genie(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     struct iw_point *data, char *extra)
+{
+	islpci_private *priv = netdev_priv(ndev);
+	int alen, ret = 0;
+	struct obj_attachment *attach;
+
+	if (data->length > MAX_WPA_IE_LEN ||
+	    (data->length && extra == NULL))
+		return -EINVAL;
+
+	memcpy(priv->wpa_ie, extra, data->length);
+	priv->wpa_ie_len = data->length;
+
+	alen = sizeof(*attach) + priv->wpa_ie_len;
+	attach = kzalloc(alen, GFP_KERNEL);
+	if (attach == NULL)
+		return -ENOMEM;
+
+#define WLAN_FC_TYPE_MGMT 0
+#define WLAN_FC_STYPE_ASSOC_REQ 0
+#define WLAN_FC_STYPE_REASSOC_REQ 2
+
+	/* Note: endianness is covered by mgt_set_varlen */
+	attach->type = (WLAN_FC_TYPE_MGMT << 2) |
+               (WLAN_FC_STYPE_ASSOC_REQ << 4);
+	attach->id = -1;
+	attach->size = priv->wpa_ie_len;
+	memcpy(attach->data, extra, priv->wpa_ie_len);
+
+	ret = mgt_set_varlen(priv, DOT11_OID_ATTACHMENT, attach,
+		priv->wpa_ie_len);
+	if (ret == 0) {
+		attach->type = (WLAN_FC_TYPE_MGMT << 2) |
+			(WLAN_FC_STYPE_REASSOC_REQ << 4);
+
+		ret = mgt_set_varlen(priv, DOT11_OID_ATTACHMENT, attach,
+			priv->wpa_ie_len);
+		if (ret == 0)
+			printk(KERN_DEBUG "%s: WPA IE Attachment was set\n",
+				ndev->name);
+	}
+
+	kfree(attach);
+	return ret;
+}
+
+
+static int prism54_get_genie(struct net_device *ndev,
+			     struct iw_request_info *info,
+			     struct iw_point *data, char *extra)
+{
+	islpci_private *priv = netdev_priv(ndev);
+	int len = priv->wpa_ie_len;
+
+	if (len <= 0) {
+		data->length = 0;
+		return 0;
+	}
+
+	if (data->length < len)
+		return -E2BIG;
+
+	data->length = len;
+	memcpy(extra, priv->wpa_ie, len);
+
+	return 0;
+}
+
+static int prism54_set_auth(struct net_device *ndev,
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
+{
+	islpci_private *priv = netdev_priv(ndev);
+	struct iw_param *param = &wrqu->param;
+	u32 mlmelevel = 0, authen = 0, dot1x = 0;
+	u32 exunencrypt = 0, privinvoked = 0, wpa = 0;
+	u32 old_wpa;
+	int ret = 0;
+	union oid_res_t r;
+
+	if (islpci_get_state(priv) < PRV_STATE_INIT)
+		return 0;
+
+	/* first get the flags */
+	down_write(&priv->mib_sem);
+	wpa = old_wpa = priv->wpa;
+	up_write(&priv->mib_sem);
+	ret = mgt_get_request(priv, DOT11_OID_AUTHENABLE, 0, NULL, &r);
+	authen = r.u;
+	ret = mgt_get_request(priv, DOT11_OID_PRIVACYINVOKED, 0, NULL, &r);
+	privinvoked = r.u;
+	ret = mgt_get_request(priv, DOT11_OID_EXUNENCRYPTED, 0, NULL, &r);
+	exunencrypt = r.u;
+	ret = mgt_get_request(priv, DOT11_OID_DOT1XENABLE, 0, NULL, &r);
+	dot1x = r.u;
+	ret = mgt_get_request(priv, DOT11_OID_MLMEAUTOLEVEL, 0, NULL, &r);
+	mlmelevel = r.u;
+
+	if (ret < 0)
+		goto out;
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_CIPHER_PAIRWISE:
+	case IW_AUTH_CIPHER_GROUP:
+	case IW_AUTH_KEY_MGMT:
+		break;
+
+	case IW_AUTH_WPA_ENABLED:
+		/* Do the same thing as IW_AUTH_WPA_VERSION */
+		if (param->value) {
+			wpa = 1;
+			privinvoked = 1; /* For privacy invoked */
+			exunencrypt = 1; /* Filter out all unencrypted frames */
+			dot1x = 0x01; /* To enable eap filter */
+			mlmelevel = DOT11_MLME_EXTENDED;
+			authen = DOT11_AUTH_OS; /* Only WEP uses _SK and _BOTH */
+		} else {
+			wpa = 0;
+			privinvoked = 0;
+			exunencrypt = 0; /* Do not filter un-encrypted data */
+			dot1x = 0;
+			mlmelevel = DOT11_MLME_AUTO;
+		}
+		break;
+
+	case IW_AUTH_WPA_VERSION:
+		if (param->value & IW_AUTH_WPA_VERSION_DISABLED) {
+			wpa = 0;
+			privinvoked = 0;
+			exunencrypt = 0; /* Do not filter un-encrypted data */
+			dot1x = 0;
+			mlmelevel = DOT11_MLME_AUTO;
+		} else {
+			if (param->value & IW_AUTH_WPA_VERSION_WPA)
+				wpa = 1;
+			else if (param->value & IW_AUTH_WPA_VERSION_WPA2)
+				wpa = 2;
+			privinvoked = 1; /* For privacy invoked */
+			exunencrypt = 1; /* Filter out all unencrypted frames */
+			dot1x = 0x01; /* To enable eap filter */
+			mlmelevel = DOT11_MLME_EXTENDED;
+			authen = DOT11_AUTH_OS; /* Only WEP uses _SK and _BOTH */
+		}
+		break;
+
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		dot1x = param->value ? 1 : 0;
+		break;
+
+	case IW_AUTH_PRIVACY_INVOKED:
+		privinvoked = param->value ? 1 : 0;
+
+	case IW_AUTH_DROP_UNENCRYPTED:
+		exunencrypt = param->value ? 1 : 0;
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG:
+		if (param->value & IW_AUTH_ALG_SHARED_KEY) {
+			/* Only WEP uses _SK and _BOTH */
+			if (wpa > 0) {
+				ret = -EINVAL;
+				goto out;
+			}
+			authen = DOT11_AUTH_SK;
+		} else if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {
+			authen = DOT11_AUTH_OS;
+		} else {
+			ret = -EINVAL;
+			goto out;
+		}
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+
+	/* Set all the values */
+	down_write(&priv->mib_sem);
+	priv->wpa = wpa;
+	up_write(&priv->mib_sem);
+	mgt_set_request(priv, DOT11_OID_AUTHENABLE, 0, &authen);
+	mgt_set_request(priv, DOT11_OID_PRIVACYINVOKED, 0, &privinvoked);
+	mgt_set_request(priv, DOT11_OID_EXUNENCRYPTED, 0, &exunencrypt);
+	mgt_set_request(priv, DOT11_OID_DOT1XENABLE, 0, &dot1x);
+	mgt_set_request(priv, DOT11_OID_MLMEAUTOLEVEL, 0, &mlmelevel);
+
+out:
+	return ret;
+}
+
+static int prism54_get_auth(struct net_device *ndev,
+			    struct iw_request_info *info,
+			    union iwreq_data *wrqu, char *extra)
+{
+	islpci_private *priv = netdev_priv(ndev);
+	struct iw_param *param = &wrqu->param;
+	u32 wpa = 0;
+	int ret = 0;
+	union oid_res_t r;
+
+	if (islpci_get_state(priv) < PRV_STATE_INIT)
+		return 0;
+
+	/* first get the flags */
+	down_write(&priv->mib_sem);
+	wpa = priv->wpa;
+	up_write(&priv->mib_sem);
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_CIPHER_PAIRWISE:
+	case IW_AUTH_CIPHER_GROUP:
+	case IW_AUTH_KEY_MGMT:
+		/*
+		 * wpa_supplicant will control these internally
+		 */
+		ret = -EOPNOTSUPP;
+		break;
+
+	case IW_AUTH_WPA_VERSION:
+		switch (wpa) {
+		case 1:
+			param->value = IW_AUTH_WPA_VERSION_WPA;
+			break;
+		case 2:
+			param->value = IW_AUTH_WPA_VERSION_WPA2;
+			break;
+		case 0:
+		default:
+			param->value = IW_AUTH_WPA_VERSION_DISABLED;
+			break;
+		}
+		break;
+
+	case IW_AUTH_DROP_UNENCRYPTED:
+		ret = mgt_get_request(priv, DOT11_OID_EXUNENCRYPTED, 0, NULL, &r);
+		if (ret >= 0)
+			param->value = r.u > 0 ? 1 : 0;
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG:
+		ret = mgt_get_request(priv, DOT11_OID_AUTHENABLE, 0, NULL, &r);
+		if (ret >= 0) {
+			switch (r.u) {
+			case DOT11_AUTH_OS:
+				param->value = IW_AUTH_ALG_OPEN_SYSTEM;
+				break;
+			case DOT11_AUTH_BOTH:
+			case DOT11_AUTH_SK:
+				param->value = IW_AUTH_ALG_SHARED_KEY;
+			case DOT11_AUTH_NONE:
+			default:
+				param->value = 0;
+				break;
+			}
+		}
+		break;
+
+	case IW_AUTH_WPA_ENABLED:
+		param->value = wpa > 0 ? 1 : 0;
+		break;
+
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		ret = mgt_get_request(priv, DOT11_OID_DOT1XENABLE, 0, NULL, &r);
+		if (ret >= 0)
+			param->value = r.u > 0 ? 1 : 0;
+		break;
+
+	case IW_AUTH_PRIVACY_INVOKED:
+		ret = mgt_get_request(priv, DOT11_OID_PRIVACYINVOKED, 0, NULL, &r);
+		if (ret >= 0)
+			param->value = r.u > 0 ? 1 : 0;
+		break;
+
+	default:
+		return -EOPNOTSUPP;
+	}
+	return ret;
+}
+
+static int prism54_set_encodeext(struct net_device *ndev,
+				 struct iw_request_info *info,
+				 union iwreq_data *wrqu,
+				 char *extra)
+{
+	islpci_private *priv = netdev_priv(ndev);
+	struct iw_point *encoding = &wrqu->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	int idx, alg = ext->alg, set_key = 1;
+	union oid_res_t r;
+	int authen = DOT11_AUTH_OS, invoke = 0, exunencrypt = 0;
+	int ret = 0;
+
+	if (islpci_get_state(priv) < PRV_STATE_INIT)
+		return 0;
+
+	/* Determine and validate the key index */
+	idx = (encoding->flags & IW_ENCODE_INDEX) - 1;
+	if (idx) {
+		if (idx < 0 || idx > 3)
+			return -EINVAL;
+	} else {
+		ret = mgt_get_request(priv, DOT11_OID_DEFKEYID, 0, NULL, &r);
+		if (ret < 0)
+			goto out;
+		idx = r.u;
+	}
+
+	if (encoding->flags & IW_ENCODE_DISABLED)
+		alg = IW_ENCODE_ALG_NONE;
+
+	if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+		/* Only set transmit key index here, actual
+		 * key is set below if needed.
+		 */
+		ret = mgt_set_request(priv, DOT11_OID_DEFKEYID, 0, &idx);
+		set_key = ext->key_len > 0 ? 1 : 0;
+	}
+
+	if (set_key) {
+		struct obj_key key = { DOT11_PRIV_WEP, 0, "" };
+		switch (alg) {
+		case IW_ENCODE_ALG_NONE:
+			break;
+		case IW_ENCODE_ALG_WEP:
+			if (ext->key_len > KEY_SIZE_WEP104) {
+				ret = -EINVAL;
+				goto out;
+			}
+			if (ext->key_len > KEY_SIZE_WEP40)
+				key.length = KEY_SIZE_WEP104;
+			else
+				key.length = KEY_SIZE_WEP40;
+			break;
+		case IW_ENCODE_ALG_TKIP:
+			if (ext->key_len > KEY_SIZE_TKIP) {
+				ret = -EINVAL;
+				goto out;
+			}
+			key.type = DOT11_PRIV_TKIP;
+			key.length = KEY_SIZE_TKIP;
+		default:
+			return -EINVAL;
+		}
+
+		if (key.length) {
+			memset(key.key, 0, sizeof(key.key));
+			memcpy(key.key, ext->key, ext->key_len);
+			ret = mgt_set_request(priv, DOT11_OID_DEFKEYX, idx,
+					    &key);
+			if (ret < 0)
+				goto out;
+		}
+	}
+
+	/* Read the flags */
+	if (encoding->flags & IW_ENCODE_DISABLED) {
+		/* Encoding disabled,
+		 * authen = DOT11_AUTH_OS;
+		 * invoke = 0;
+		 * exunencrypt = 0; */
+	}
+	if (encoding->flags & IW_ENCODE_OPEN) {
+		/* Encode but accept non-encoded packets. No auth */
+		invoke = 1;
+	}
+	if (encoding->flags & IW_ENCODE_RESTRICTED) {
+		/* Refuse non-encoded packets. Auth */
+		authen = DOT11_AUTH_BOTH;
+		invoke = 1;
+		exunencrypt = 1;
+	}
+
+	/* do the change if requested  */
+	if (encoding->flags & IW_ENCODE_MODE) {
+		ret = mgt_set_request(priv, DOT11_OID_AUTHENABLE, 0,
+				      &authen);
+		ret = mgt_set_request(priv, DOT11_OID_PRIVACYINVOKED, 0,
+				      &invoke);
+		ret = mgt_set_request(priv, DOT11_OID_EXUNENCRYPTED, 0,
+				      &exunencrypt);
+	}
+
+out:
+	return ret;
+}
+
+
+static int prism54_get_encodeext(struct net_device *ndev,
+				 struct iw_request_info *info,
+				 union iwreq_data *wrqu,
+				 char *extra)
+{
+	islpci_private *priv = netdev_priv(ndev);
+	struct iw_point *encoding = &wrqu->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	int idx, max_key_len;
+	union oid_res_t r;
+	int authen = DOT11_AUTH_OS, invoke = 0, exunencrypt = 0, wpa = 0;
+	int ret = 0;
+
+	if (islpci_get_state(priv) < PRV_STATE_INIT)
+		return 0;
+
+	/* first get the flags */
+	ret = mgt_get_request(priv, DOT11_OID_AUTHENABLE, 0, NULL, &r);
+	authen = r.u;
+	ret = mgt_get_request(priv, DOT11_OID_PRIVACYINVOKED, 0, NULL, &r);
+	invoke = r.u;
+	ret = mgt_get_request(priv, DOT11_OID_EXUNENCRYPTED, 0, NULL, &r);
+	exunencrypt = r.u;
+	if (ret < 0)
+		goto out;
+
+	max_key_len = encoding->length - sizeof(*ext);
+	if (max_key_len < 0)
+		return -EINVAL;
+
+	idx = (encoding->flags & IW_ENCODE_INDEX) - 1;
+	if (idx) {
+		if (idx < 0 || idx > 3)
+			return -EINVAL;
+	} else {
+		ret = mgt_get_request(priv, DOT11_OID_DEFKEYID, 0, NULL, &r);
+		if (ret < 0)
+			goto out;
+		idx = r.u;
+	}
+
+	encoding->flags = idx + 1;
+	memset(ext, 0, sizeof(*ext));
+
+	switch (authen) {
+	case DOT11_AUTH_BOTH:
+	case DOT11_AUTH_SK:
+		wrqu->encoding.flags |= IW_ENCODE_RESTRICTED;
+	case DOT11_AUTH_OS:
+	default:
+		wrqu->encoding.flags |= IW_ENCODE_OPEN;
+		break;
+	}
+
+	down_write(&priv->mib_sem);
+	wpa = priv->wpa;
+	up_write(&priv->mib_sem);
+
+	if (authen == DOT11_AUTH_OS && !exunencrypt && !invoke && !wpa) {
+		/* No encryption */
+		ext->alg = IW_ENCODE_ALG_NONE;
+		ext->key_len = 0;
+		wrqu->encoding.flags |= IW_ENCODE_DISABLED;
+	} else {
+		struct obj_key *key;
+
+		ret = mgt_get_request(priv, DOT11_OID_DEFKEYX, idx, NULL, &r);
+		if (ret < 0)
+			goto out;
+		key = r.ptr;
+		if (max_key_len < key->length) {
+			ret = -E2BIG;
+			goto out;
+		}
+		memcpy(ext->key, key->key, key->length);
+		ext->key_len = key->length;
+
+		switch (key->type) {
+		case DOT11_PRIV_TKIP:
+			ext->alg = IW_ENCODE_ALG_TKIP;
+			break;
+		default:
+		case DOT11_PRIV_WEP:
+			ext->alg = IW_ENCODE_ALG_WEP;
+			break;
+		}
+		wrqu->encoding.flags |= IW_ENCODE_ENABLED;
+	}
+
+out:
+	return ret;
+}
+
+
@@ -1594,2 +2114,2 @@
-prism54_wpa_ie_add(islpci_private *priv, u8 *bssid,
-		   u8 *wpa_ie, size_t wpa_ie_len)
+prism54_wpa_bss_ie_add(islpci_private *priv, u8 *bssid,
+		       u8 *wpa_ie, size_t wpa_ie_len)
@@ -1661 +2181 @@
-prism54_wpa_ie_get(islpci_private *priv, u8 *bssid, u8 *wpa_ie)
+prism54_wpa_bss_ie_get(islpci_private *priv, u8 *bssid, u8 *wpa_ie)
@@ -1686 +2206 @@
-prism54_wpa_ie_init(islpci_private *priv)
+prism54_wpa_bss_ie_init(islpci_private *priv)
@@ -1693 +2213 @@
-prism54_wpa_ie_clean(islpci_private *priv)
+prism54_wpa_bss_ie_clean(islpci_private *priv)
@@ -1725 +2245 @@
-			prism54_wpa_ie_add(priv, addr, pos, pos[1] + 2);
+			prism54_wpa_bss_ie_add(priv, addr, pos, pos[1] + 2);
@@ -1882 +2402 @@
-				&& mlmeex->state != DOT11_STATE_AUTHING)
+				&& mlmeex->state != DOT11_STATE_ASSOCING)
@@ -1896 +2416 @@
-		wpa_ie_len = prism54_wpa_ie_get(priv, mlmeex->address, wpa_ie);
+		wpa_ie_len = prism54_wpa_bss_ie_get(priv, mlmeex->address, wpa_ie);
@@ -1940 +2460 @@
-		wpa_ie_len = prism54_wpa_ie_get(priv, mlmeex->address, wpa_ie);
+		wpa_ie_len = prism54_wpa_bss_ie_get(priv, mlmeex->address, wpa_ie);
@@ -2555,0 +3076,9 @@
+	NULL,			/* -- hole -- */
+	NULL,			/* -- hole -- */
+	(iw_handler) prism54_set_genie,	/* SIOCSIWGENIE */
+	(iw_handler) prism54_get_genie,	/* SIOCGIWGENIE */
+	(iw_handler) prism54_set_auth,	/* SIOCSIWAUTH */
+	(iw_handler) prism54_get_auth,	/* SIOCGIWAUTH */
+	(iw_handler) prism54_set_encodeext, /* SIOCSIWENCODEEXT */
+	(iw_handler) prism54_get_encodeext, /* SIOCGIWENCODEEXT */
+	NULL,			/* SIOCSIWPMKSA */
--- ./projects/linux/linux-2.6.19/drivers/net/wireless/prism54/isl_ioctl.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/net/wireless/prism54/isl_ioctl.c	2007-02-04 19:44:54.000000000 +0100
@@ -2 +1,0 @@
- *  
@@ -58 +57 @@
- * 
+ *
@@ -60,4 +59,4 @@
- *  caller deals with locking *if* necessary. This function sets the 
- *  mode-dependent mib values and does the mapping of the Linux 
- *  Wireless API modes to Device firmware modes. It also checks for 
- *  correct valid Linux wireless modes. 
+ *  caller deals with locking *if* necessary. This function sets the
+ *  mode-dependent mib values and does the mapping of the Linux
+ *  Wireless API modes to Device firmware modes. It also checks for
+ *  correct valid Linux wireless modes.
@@ -121 +120 @@
- *  variables.  
+ *  variables.
@@ -137 +136 @@
-	dot1x = CARD_DEFAULT_DOT1X; 
+	dot1x = CARD_DEFAULT_DOT1X;
@@ -161 +160 @@
-prism54_update_stats(islpci_private *priv)
+prism54_update_stats(struct work_struct *work)
@@ -162,0 +162 @@
+	islpci_private *priv = container_of(work, islpci_private, stats_work);
@@ -231 +231 @@
-	/* Update our wireless stats, but do not schedule to often 
+	/* Update our wireless stats, but do not schedule to often
@@ -708 +708 @@
-	
+
@@ -788 +788 @@
-/* Provides no functionality, just completes the ioctl. In essence this is a 
+/* Provides no functionality, just completes the ioctl. In essence this is a
@@ -1107 +1107 @@
-		 * If a valid key is set, encryption should be enabled 
+		 * If a valid key is set, encryption should be enabled
@@ -1129 +1129 @@
-		/* Encoding disabled, 
+		/* Encoding disabled,
@@ -1217 +1217 @@
-	 * btw: how is possible to turn off only the radio 
+	 * btw: how is possible to turn off only the radio
@@ -2144,2 +2144,2 @@
-			bss = kmalloc(sizeof (*bss), GFP_ATOMIC);
-			if (bss != NULL) {
+			bss = kzalloc(sizeof (*bss), GFP_ATOMIC);
+			if (bss != NULL)
@@ -2147,2 +2146,0 @@
-				memset(bss, 0, sizeof (*bss));
-			}
@@ -2357 +2355 @@
-		if (priv->iw_mode != IW_MODE_MASTER 
+		if (priv->iw_mode != IW_MODE_MASTER
@@ -2363 +2361 @@
-		if (!confirm) 
+		if (!confirm)
@@ -2367 +2365 @@
-		printk(KERN_DEBUG "Authenticate from: address:\t%02x:%02x:%02x:%02x:%02x:%02x\n", 
+		printk(KERN_DEBUG "Authenticate from: address:\t%02x:%02x:%02x:%02x:%02x:%02x\n",
@@ -2401 +2399 @@
-		if (priv->iw_mode != IW_MODE_MASTER 
+		if (priv->iw_mode != IW_MODE_MASTER
@@ -2404 +2402 @@
-		
+
@@ -2420 +2418 @@
-					"address:\t%02x:%02x:%02x:%02x:%02x:%02x\n", 
+					"address:\t%02x:%02x:%02x:%02x:%02x:%02x\n",
@@ -2438 +2436 @@
-		
+
@@ -2445 +2443 @@
-		if (priv->iw_mode != IW_MODE_MASTER 
+		if (priv->iw_mode != IW_MODE_MASTER
@@ -2464 +2462 @@
-					"address:\t%02x:%02x:%02x:%02x:%02x:%02x\n", 
+					"address:\t%02x:%02x:%02x:%02x:%02x:%02x\n",
@@ -2476 +2474 @@
-		confirm->size = wpa_ie_len; 
+		confirm->size = wpa_ie_len;
@@ -2482 +2480 @@
-		
+
@@ -2497 +2495 @@
-prism54_process_trap(void *data)
+prism54_process_trap(struct work_struct *work)
@@ -2499 +2497,2 @@
-	struct islpci_mgmtframe *frame = data;
+	struct islpci_mgmtframe *frame =
+		container_of(work, struct islpci_mgmtframe, ws);
@@ -2548 +2547 @@
-/* Maximum length for algorithm names (-1 for nul termination) 
+/* Maximum length for algorithm names (-1 for nul termination)
@@ -2551 +2550 @@
-	
+
@@ -2624 +2623 @@
-		 * If a valid key is set, encryption should be enabled 
+		 * If a valid key is set, encryption should be enabled
@@ -2646 +2645 @@
-		/* Encoding disabled, 
+		/* Encoding disabled,
@@ -2688 +2687 @@
-       attach = kmalloc(alen, GFP_KERNEL);
+       attach = kzalloc(alen, GFP_KERNEL);
@@ -2692 +2690,0 @@
-       memset(attach, 0, alen);
@@ -2713 +2711 @@
-	       if (ret == 0) 
+	       if (ret == 0)
@@ -2780 +2778 @@
-       param = (struct prism2_hostapd_param *) kmalloc(p->length, GFP_KERNEL);
+       param = kmalloc(p->length, GFP_KERNEL);
@@ -2873 +2871 @@
-		case 2: 
+		case 2:
--- ./projects/linux/linux-2.6.20/drivers/net/wireless/prism54/isl_ioctl.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/net/wireless/prism54/isl_ioctl.c	2007-04-26 05:08:32.000000000 +0200
@@ -1398 +1398,5 @@
-		dot1x = param->value ? 1 : 0;
+		/* dot1x should be the opposite of RX_UNENCRYPTED_EAPOL;
+		 * turn off dot1x when allowing receipt of unencrypted EAPOL
+		 * frames, turn on dot1x when receipt should be disallowed
+		 */
+		dot1x = param->value ? 0 : 0x01;
@@ -1402,0 +1407 @@
+		break;
@@ -1591,0 +1597 @@
+			break;
--- ./projects/linux/linux-2.6.21/drivers/net/wireless/prism54/isl_ioctl.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/net/wireless/prism54/isl_ioctl.c	2007-07-09 01:32:17.000000000 +0200
@@ -3057 +3057 @@
-	(iw_handler) NULL,	/* SIOCGIWAPLIST depreciated */
+	(iw_handler) NULL,	/* SIOCGIWAPLIST deprecated */
--- ./projects/linux/linux-2.6.22/drivers/net/wireless/prism54/isl_ioctl.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/net/wireless/prism54/isl_ioctl.c	2007-10-09 22:31:38.000000000 +0200
@@ -1856 +1855,0 @@
-	struct list_head *ptr;
@@ -1864,3 +1863 @@
-	for (ptr = acl->mac_list.next; ptr != &acl->mac_list; ptr = ptr->next) {
-		entry = list_entry(ptr, struct mac_entry, _list);
-
+	list_for_each_entry(entry, &acl->mac_list, _list) {
@@ -1868 +1865 @@
-			list_del(ptr);
+			list_del(&entry->_list);
@@ -1886 +1882,0 @@
-	struct list_head *ptr;
@@ -1894,3 +1890 @@
-	for (ptr = acl->mac_list.next; ptr != &acl->mac_list; ptr = ptr->next) {
-		entry = list_entry(ptr, struct mac_entry, _list);
-
+	list_for_each_entry(entry, &acl->mac_list, _list) {
@@ -1963 +1956,0 @@
-	struct list_head *ptr;
@@ -1975,2 +1968 @@
-	for (ptr = acl->mac_list.next; ptr != &acl->mac_list; ptr = ptr->next) {
-		entry = list_entry(ptr, struct mac_entry, _list);
+	list_for_each_entry(entry, &acl->mac_list, _list) {
@@ -2219 +2211 @@
-	struct list_head *ptr, *n;
+	struct islpci_bss_wpa_ie *bss, *n;
@@ -2221,3 +2213 @@
-	list_for_each_safe(ptr, n, &priv->bss_wpa_list) {
-		struct islpci_bss_wpa_ie *bss;
-		bss = list_entry(ptr, struct islpci_bss_wpa_ie, list);
+	list_for_each_entry_safe(bss, n, &priv->bss_wpa_list, list) {
--- ./projects/linux/linux-2.6.23/drivers/net/wireless/prism54/isl_ioctl.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/net/wireless/prism54/isl_ioctl.c	2008-01-24 23:58:37.000000000 +0100
@@ -1756 +1756 @@
-	rvalue = mgt_get_request((islpci_private *) ndev->priv, n, 0, NULL, &r);
+	rvalue = mgt_get_request(netdev_priv(ndev), n, 0, NULL, &r);
@@ -1769 +1769 @@
-	return mgt_set_request((islpci_private *) ndev->priv, oid, 0, &u);
+	return mgt_set_request(netdev_priv(ndev), oid, 0, &u);
@@ -1778 +1778 @@
-	return mgt_set_request((islpci_private *) ndev->priv, oid, 0, extra);
+	return mgt_set_request(netdev_priv(ndev), oid, 0, extra);
@@ -2032 +2032 @@
-	const u8 *a = mlme->address;
+	DECLARE_MAC_BUF(mac);
@@ -2034 +2034 @@
-			 "%s %s %2.2X:%2.2X:%2.2X:%2.2X:%2.2X:%2.2X %s (%2.2X)",
+			 "%s %s %s %s (%2.2X)",
@@ -2037 +2037 @@
-			 a[0], a[1], a[2], a[3], a[4], a[5],
+			 print_mac(mac, mlme->address),
@@ -2108,3 +2107,0 @@
-#define MAC2STR(a) (a)[0], (a)[1], (a)[2], (a)[3], (a)[4], (a)[5]
-#define MACSTR "%02x:%02x:%02x:%02x:%02x:%02x"
-
@@ -2116,0 +2114 @@
+	DECLARE_MAC_BUF(mac);
@@ -2157,2 +2155,2 @@
-		printk(KERN_DEBUG "Failed to add BSS WPA entry for " MACSTR
-		       "\n", MAC2STR(bssid));
+		printk(KERN_DEBUG "Failed to add BSS WPA entry for "
+		       "%s\n", print_mac(mac, bssid));
@@ -2223,0 +2222 @@
+	DECLARE_MAC_BUF(mac);
@@ -2234 +2233 @@
-			       "for " MACSTR "\n", MAC2STR(addr));
+			       "for %s\n", print_mac(mac, addr));
@@ -2272,0 +2272 @@
+	DECLARE_MAC_BUF(mac);
@@ -2361,8 +2361,2 @@
-		printk(KERN_DEBUG "Authenticate from: address:\t%02x:%02x:%02x:%02x:%02x:%02x\n",
-				mlmeex->address[0],
-				mlmeex->address[1],
-				mlmeex->address[2],
-				mlmeex->address[3],
-				mlmeex->address[4],
-				mlmeex->address[5]
-				);
+		printk(KERN_DEBUG "Authenticate from: address:\t%s\n",
+		       print_mac(mac, mlmeex->address));
@@ -2413,9 +2407,2 @@
-			printk(KERN_DEBUG "No WPA IE found from "
-					"address:\t%02x:%02x:%02x:%02x:%02x:%02x\n",
-				mlmeex->address[0],
-				mlmeex->address[1],
-				mlmeex->address[2],
-				mlmeex->address[3],
-				mlmeex->address[4],
-				mlmeex->address[5]
-				);
+			printk(KERN_DEBUG "No WPA IE found from address:\t%s\n",
+			       print_mac(mac, mlmeex->address));
@@ -2457,9 +2444,2 @@
-			printk(KERN_DEBUG "No WPA IE found from "
-					"address:\t%02x:%02x:%02x:%02x:%02x:%02x\n",
-				mlmeex->address[0],
-				mlmeex->address[1],
-				mlmeex->address[2],
-				mlmeex->address[3],
-				mlmeex->address[4],
-				mlmeex->address[5]
-				);
+			printk(KERN_DEBUG "No WPA IE found from address:\t%s\n",
+			       print_mac(mac, mlmeex->address));
@@ -3242,4 +3222,3 @@
-	.num_standard = sizeof (prism54_handler) / sizeof (iw_handler),
-	.num_private = sizeof (prism54_private_handler) / sizeof (iw_handler),
-	.num_private_args =
-	    sizeof (prism54_private_args) / sizeof (struct iw_priv_args),
+	.num_standard = ARRAY_SIZE(prism54_handler),
+	.num_private = ARRAY_SIZE(prism54_private_handler),
+	.num_private_args = ARRAY_SIZE(prism54_private_args),
--- ./projects/linux/linux-2.6.24/drivers/net/wireless/prism54/isl_ioctl.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/net/wireless/prism54/isl_ioctl.c	2008-04-17 04:49:44.000000000 +0200
@@ -168,2 +168 @@
-	if (down_interruptible(&priv->stats_sem))
-		return;
+	down(&priv->stats_sem);
@@ -1121 +1120 @@
-			if (!dwrq->flags & IW_ENCODE_MODE) {
+			if (!(dwrq->flags & IW_ENCODE_MODE)) {
@@ -1796,2 +1795 @@
-	if (down_interruptible(&acl->sem))
-		return;
+	down(&acl->sem);
@@ -2119,2 +2117 @@
-	if (down_interruptible(&priv->wpa_sem))
-		return;
+	down(&priv->wpa_sem);
@@ -2181,2 +2178 @@
-	if (down_interruptible(&priv->wpa_sem))
-		return 0;
+	down(&priv->wpa_sem);
@@ -2613 +2609 @@
-			if (!param->u.crypt.flags & IW_ENCODE_MODE) {
+			if (!(param->u.crypt.flags & IW_ENCODE_MODE)) {
--- ./projects/linux/linux-2.6.25/drivers/net/wireless/prism54/isl_ioctl.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/net/wireless/prism54/isl_ioctl.c	2008-07-13 23:51:29.000000000 +0200
@@ -168 +168 @@
-	down(&priv->stats_sem);
+	mutex_lock(&priv->stats_lock);
@@ -210 +210 @@
-	up(&priv->stats_sem);
+	mutex_unlock(&priv->stats_lock);
@@ -221 +221 @@
-	if (down_trylock(&priv->stats_sem) == 0) {
+	if (mutex_trylock(&priv->stats_lock)) {
@@ -226 +226 @@
-		up(&priv->stats_sem);
+		mutex_unlock(&priv->stats_lock);
@@ -1189 +1189 @@
-	if ((index < 0) || (index > 3))
+	if (index == -1 || index > 3)
@@ -1783 +1783 @@
-	sema_init(&acl->sem, 1);
+	mutex_init(&acl->lock);
@@ -1795 +1795 @@
-	down(&acl->sem);
+	mutex_lock(&acl->lock);
@@ -1798 +1798 @@
-		up(&acl->sem);
+		mutex_unlock(&acl->lock);
@@ -1809 +1809 @@
-	up(&acl->sem);
+	mutex_unlock(&acl->lock);
@@ -1836 +1836 @@
-	if (down_interruptible(&acl->sem)) {
+	if (mutex_lock_interruptible(&acl->lock)) {
@@ -1842 +1842 @@
-	up(&acl->sem);
+	mutex_unlock(&acl->lock);
@@ -1859 +1859 @@
-	if (down_interruptible(&acl->sem))
+	if (mutex_lock_interruptible(&acl->lock))
@@ -1866 +1866 @@
-			up(&acl->sem);
+			mutex_unlock(&acl->lock);
@@ -1870 +1870 @@
-	up(&acl->sem);
+	mutex_unlock(&acl->lock);
@@ -1885 +1885 @@
-	if (down_interruptible(&acl->sem))
+	if (mutex_lock_interruptible(&acl->lock))
@@ -1894 +1894 @@
-	up(&acl->sem);
+	mutex_unlock(&acl->lock);
@@ -1958 +1958 @@
-	if (down_interruptible(&acl->sem))
+	if (mutex_lock_interruptible(&acl->lock))
@@ -1962 +1962 @@
-		up(&acl->sem);
+		mutex_unlock(&acl->lock);
@@ -1973 +1973 @@
-	up(&acl->sem);
+	mutex_unlock(&acl->lock);
@@ -2083,0 +2084 @@
+		netif_carrier_on(ndev);
@@ -2092 +2093,2 @@
-	} else
+	} else {
+		netif_carrier_off(ndev);
@@ -2093,0 +2096 @@
+	}
@@ -2117 +2120 @@
-	down(&priv->wpa_sem);
+	mutex_lock(&priv->wpa_lock);
@@ -2168 +2171 @@
-	up(&priv->wpa_sem);
+	mutex_unlock(&priv->wpa_lock);
@@ -2178 +2181 @@
-	down(&priv->wpa_sem);
+	mutex_lock(&priv->wpa_lock);
@@ -2190 +2193 @@
-	up(&priv->wpa_sem);
+	mutex_unlock(&priv->wpa_lock);
@@ -2199 +2202 @@
-	sema_init(&priv->wpa_sem, 1);
+	mutex_init(&priv->wpa_lock);
--- ./projects/linux/linux-2.6.26/drivers/net/wireless/prism54/isl_ioctl.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/net/wireless/prism54/isl_ioctl.c	2008-10-10 00:13:53.000000000 +0200
@@ -574,2 +574,3 @@
-prism54_translate_bss(struct net_device *ndev, char *current_ev,
-		      char *end_buf, struct obj_bss *bss, char noise)
+prism54_translate_bss(struct net_device *ndev, struct iw_request_info *info,
+		      char *current_ev, char *end_buf, struct obj_bss *bss,
+		      char noise)
@@ -587,2 +588,2 @@
-	current_ev =
-	    iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_ADDR_LEN);
+	current_ev = iwe_stream_add_event(info, current_ev, end_buf,
+					  &iwe, IW_EV_ADDR_LEN);
@@ -596 +597 @@
-	current_ev = iwe_stream_add_point(current_ev, end_buf,
+	current_ev = iwe_stream_add_point(info, current_ev, end_buf,
@@ -613,3 +614,2 @@
-		current_ev =
-		    iwe_stream_add_event(current_ev, end_buf, &iwe,
-					 IW_EV_UINT_LEN);
+		current_ev = iwe_stream_add_event(info, current_ev, end_buf,
+						  &iwe, IW_EV_UINT_LEN);
@@ -624 +624,2 @@
-	current_ev = iwe_stream_add_point(current_ev, end_buf, &iwe, NULL);
+	current_ev = iwe_stream_add_point(info, current_ev, end_buf,
+					  &iwe, NULL);
@@ -630,2 +631,2 @@
-	current_ev =
-	    iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_FREQ_LEN);
+	current_ev = iwe_stream_add_event(info, current_ev, end_buf,
+					  &iwe, IW_EV_FREQ_LEN);
@@ -639,2 +640,2 @@
-	current_ev =
-	    iwe_stream_add_event(current_ev, end_buf, &iwe, IW_EV_QUAL_LEN);
+	current_ev = iwe_stream_add_event(info, current_ev, end_buf,
+					  &iwe, IW_EV_QUAL_LEN);
@@ -647,2 +648,2 @@
-		current_ev = iwe_stream_add_point(current_ev, end_buf,
-				&iwe, wpa_ie);
+		current_ev = iwe_stream_add_point(info, current_ev, end_buf,
+						  &iwe, wpa_ie);
@@ -652 +653 @@
-		char *	current_val = current_ev + IW_EV_LCP_LEN;
+		char *current_val = current_ev + iwe_stream_lcp_len(info);
@@ -665,3 +666,3 @@
-				current_val = iwe_stream_add_value(current_ev, current_val,
-								   end_buf, &iwe,
-								   IW_EV_PARAM_LEN);
+				current_val = iwe_stream_add_value(
+					info, current_ev, current_val,
+					end_buf, &iwe, IW_EV_PARAM_LEN);
@@ -672 +673 @@
-		if ((current_val - current_ev) > IW_EV_LCP_LEN)
+		if ((current_val - current_ev) > iwe_stream_lcp_len(info))
@@ -713 +714 @@
-		current_ev = prism54_translate_bss(ndev, current_ev,
+		current_ev = prism54_translate_bss(ndev, info, current_ev,
@@ -2520 +2521 @@
-((int) (&((struct prism2_hostapd_param *) 0)->u.generic_elem.data))
+	offsetof(struct prism2_hostapd_param, u.generic_elem.data)
@@ -2706,0 +2708 @@
+	struct iw_request_info info;
@@ -2729,0 +2732,3 @@
+	info.cmd = PRISM54_HOSTAPD;
+	info.flags = 0;
+
@@ -2732 +2737 @@
-		current_ev = prism54_translate_bss(ndev, current_ev,
+		current_ev = prism54_translate_bss(ndev, &info, current_ev,
--- ./projects/linux/linux-2.6.27/drivers/net/wireless/prism54/isl_ioctl.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/net/wireless/prism54/isl_ioctl.c	2008-12-25 00:26:37.000000000 +0100
@@ -74 +74 @@
-		       "are not yet supported by this driver.\n", __FUNCTION__);
+		       "are not yet supported by this driver.\n", __func__);
@@ -336 +336 @@
-		       priv->ndev->name, __FUNCTION__);
+		       priv->ndev->name, __func__);
@@ -1237 +1237 @@
-		       priv->ndev->name, __FUNCTION__);
+		       priv->ndev->name, __func__);
@@ -1245 +1245 @@
-		       priv->ndev->name, __FUNCTION__);
+		       priv->ndev->name, __func__);
--- ./projects/linux/linux-2.6.28/drivers/net/wireless/prism54/isl_ioctl.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/net/wireless/prism54/isl_ioctl.c	2009-03-24 00:12:14.000000000 +0100
@@ -2031 +2030,0 @@
-	DECLARE_MAC_BUF(mac);
@@ -2033 +2032 @@
-			 "%s %s %s %s (%2.2X)",
+			 "%s %s %pM %s (%2.2X)",
@@ -2036 +2035 @@
-			 print_mac(mac, mlme->address),
+			 mlme->address,
@@ -2116 +2114,0 @@
-	DECLARE_MAC_BUF(mac);
@@ -2157 +2155 @@
-		       "%s\n", print_mac(mac, bssid));
+		       "%pM\n", bssid);
@@ -2222 +2219,0 @@
-	DECLARE_MAC_BUF(mac);
@@ -2233 +2230 @@
-			       "for %s\n", print_mac(mac, addr));
+			       "for %pM\n", addr);
@@ -2272 +2268,0 @@
-	DECLARE_MAC_BUF(mac);
@@ -2361,2 +2357,2 @@
-		printk(KERN_DEBUG "Authenticate from: address:\t%s\n",
-		       print_mac(mac, mlmeex->address));
+		printk(KERN_DEBUG "Authenticate from: address:\t%pM\n",
+		       mlmeex->address);
@@ -2407,2 +2403,2 @@
-			printk(KERN_DEBUG "No WPA IE found from address:\t%s\n",
-			       print_mac(mac, mlmeex->address));
+			printk(KERN_DEBUG "No WPA IE found from address:\t%pM\n",
+			       mlmeex->address);
@@ -2444,2 +2440,2 @@
-			printk(KERN_DEBUG "No WPA IE found from address:\t%s\n",
-			       print_mac(mac, mlmeex->address));
+			printk(KERN_DEBUG "No WPA IE found from address:\t%pM\n",
+			       mlmeex->address);
--- ./projects/linux/linux-2.6.29/drivers/net/wireless/prism54/isl_ioctl.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/net/wireless/prism54/isl_ioctl.c	2009-06-27 11:32:32.000000000 +0200
@@ -2984 +2984,2 @@
-	u32 u, oid = OID_INL_CONFIG;
+	u32 u;
+	enum oid_num_t oid = OID_INL_CONFIG;
--- ./projects/linux/linux-2.6.24/drivers/net/wireless/zd1211rw/zd_rf_uw2453.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/net/wireless/zd1211rw/zd_rf_uw2453.c	2008-04-17 04:49:44.000000000 +0200
@@ -1 +1,4 @@
-/* zd_rf_uw2453.c: Functions for the UW2453 RF controller
+/* ZD1211 USB-WLAN driver for Linux
+ *
+ * Copyright (C) 2005-2007 Ulrich Kunitz <kune@deine-taler.de>
+ * Copyright (C) 2006-2007 Daniel Drake <dsd@gentoo.org>
@@ -406 +409 @@
-		if (!intr_status & 0xf) {
+		if (!(intr_status & 0xf)) {
--- ./projects/linux/linux-2.6.27/drivers/s390/cio/chsc_sch.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/s390/cio/chsc_sch.c	2008-12-25 00:26:37.000000000 +0100
@@ -264 +264 @@
-	if (!scsw_stctl(&request->irb.scsw) & SCSW_STCTL_STATUS_PEND)
+	if (!(scsw_stctl(&request->irb.scsw) & SCSW_STCTL_STATUS_PEND))
--- ./projects/linux/linux-2.6.28/drivers/s390/cio/chsc_sch.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/s390/cio/chsc_sch.c	2009-03-24 00:12:14.000000000 +0100
@@ -64 +64 @@
-	stsch(sch->schid, &sch->schib);
+	cio_update_schib(sch);
--- ./projects/linux/linux-2.6.29/drivers/s390/cio/chsc_sch.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/s390/cio/chsc_sch.c	2009-06-27 11:32:32.000000000 +0200
@@ -87,2 +87,2 @@
-		if (sch->dev.uevent_suppress) {
-			sch->dev.uevent_suppress = 0;
+		if (dev_get_uevent_suppress(&sch->dev)) {
+			dev_set_uevent_suppress(&sch->dev, 0);
--- ./projects/linux/linux-2.6.14/drivers/s390/cio/cmf.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/s390/cio/cmf.c	2006-01-03 04:21:10.000000000 +0100
@@ -32,0 +33,2 @@
+#include <linux/slab.h>
+#include <linux/timex.h>	/* get_clock() */
@@ -36,0 +39 @@
+#include <asm/div64.h>
@@ -642,2 +645 @@
-	if (cdev->private->cmb)
-		kfree(cdev->private->cmb);
+	kfree(cdev->private->cmb);
--- ./projects/linux/linux-2.6.15/drivers/s390/cio/cmf.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/s390/cio/cmf.c	2006-03-20 06:53:29.000000000 +0100
@@ -2 +2 @@
- * linux/drivers/s390/cio/cmf.c ($Revision: 1.16 $)
+ * linux/drivers/s390/cio/cmf.c
@@ -181 +181 @@
-		stsch(sch->irq, schib);
+		stsch(sch->schid, schib);
@@ -191 +191 @@
-		switch(ret = msch_err(sch->irq, schib)) {
+		switch(ret = msch_err(sch->schid, schib)) {
@@ -205 +205 @@
-		stsch(sch->irq, schib); /* restore the schib */
+		stsch(sch->schid, schib); /* restore the schib */
--- ./projects/linux/linux-2.6.17/drivers/s390/cio/cmf.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/s390/cio/cmf.c	2006-09-20 05:42:06.000000000 +0200
@@ -6 +6 @@
- * Copyright 2000,2003 IBM Corporation
+ * Copyright 2000,2006 IBM Corporation
@@ -8 +8,2 @@
- * Author: Arnd Bergmann <arndb@de.ibm.com>
+ * Authors: Arnd Bergmann <arndb@de.ibm.com>
+ *	    Cornelia Huck <cornelia.huck@de.ibm.com>
@@ -99,3 +100,3 @@
- * all these functions operate on a struct cmf_device. There is only
- * one instance of struct cmb_operations because all cmf_device
- * objects are guaranteed to be of the same type.
+ * Most of these functions operate on a struct ccw_device. There is only
+ * one instance of struct cmb_operations because the format of the measurement
+ * data is guaranteed to be the same for every ccw_device.
@@ -109,0 +111 @@
+ * @align:	align an allocated block so that the hardware can use it
@@ -117,0 +120 @@
+	void * (*align) (void *);
@@ -122,0 +126,7 @@
+struct cmb_data {
+	void *hw_block;   /* Pointer to block updated by hardware */
+	void *last_block; /* Last changed block copied from hardware block */
+	int size;	  /* Size of hw_block and last_block */
+	unsigned long long last_update;  /* when last_block was updated */
+};
+
@@ -228,0 +239 @@
+	struct kref kref;
@@ -230,0 +242,10 @@
+static void cmf_set_schib_release(struct kref *kref)
+{
+	struct set_schib_struct *set_data;
+
+	set_data = container_of(kref, struct set_schib_struct, kref);
+	kfree(set_data);
+}
+
+#define CMF_PENDING 1
+
@@ -234,6 +255,2 @@
-	struct set_schib_struct s = {
-		.mme = mme,
-		.mbfc = mbfc,
-		.address = address,
-		.wait = __WAIT_QUEUE_HEAD_INITIALIZER(s.wait),
-	};
+	struct set_schib_struct *set_data;
+	int ret;
@@ -242,3 +259,3 @@
-	s.ret = set_schib(cdev, mme, mbfc, address);
-	if (s.ret != -EBUSY) {
-		goto out_nowait;
+	if (!cdev->private->cmb) {
+		ret = -ENODEV;
+		goto out;
@@ -245,0 +263,14 @@
+	set_data = kzalloc(sizeof(struct set_schib_struct), GFP_ATOMIC);
+	if (!set_data) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	init_waitqueue_head(&set_data->wait);
+	kref_init(&set_data->kref);
+	set_data->mme = mme;
+	set_data->mbfc = mbfc;
+	set_data->address = address;
+
+	ret = set_schib(cdev, mme, mbfc, address);
+	if (ret != -EBUSY)
+		goto out_put;
@@ -248 +278,0 @@
-		s.ret = -EBUSY;
@@ -250 +280,2 @@
-		goto out_nowait;
+		ret = -EBUSY;
+		goto out_put;
@@ -251,0 +283 @@
+
@@ -253,2 +285,2 @@
-	cdev->private->cmb_wait = &s;
-	s.ret = 1;
+	set_data->ret = CMF_PENDING;
+	cdev->private->cmb_wait = set_data;
@@ -257 +289,2 @@
-	if (wait_event_interruptible(s.wait, s.ret != 1)) {
+	if (wait_event_interruptible(set_data->wait,
+				     set_data->ret != CMF_PENDING)) {
@@ -259,3 +292,2 @@
-		if (s.ret == 1) {
-			s.ret = -ERESTARTSYS;
-			cdev->private->cmb_wait = 0;
+		if (set_data->ret == CMF_PENDING) {
+			set_data->ret = -ERESTARTSYS;
@@ -267,3 +299,6 @@
-	return s.ret;
-
-out_nowait:
+	spin_lock_irq(cdev->ccwlock);
+	cdev->private->cmb_wait = NULL;
+	ret = set_data->ret;
+out_put:
+	kref_put(&set_data->kref, cmf_set_schib_release);
+out:
@@ -271 +306 @@
-	return s.ret;
+	return ret;
@@ -276 +311 @@
-	struct set_schib_struct *s;
+	struct set_schib_struct *set_data;
@@ -278,3 +313,2 @@
-	s = cdev->private->cmb_wait;
-	cdev->private->cmb_wait = 0;
-	if (!s) {
+	set_data = cdev->private->cmb_wait;
+	if (!set_data) {
@@ -284,2 +318,144 @@
-	s->ret = set_schib(cdev, s->mme, s->mbfc, s->address);
-	wake_up(&s->wait);
+	kref_get(&set_data->kref);
+	set_data->ret = set_schib(cdev, set_data->mme, set_data->mbfc,
+				  set_data->address);
+	wake_up(&set_data->wait);
+	kref_put(&set_data->kref, cmf_set_schib_release);
+}
+
+static int cmf_copy_block(struct ccw_device *cdev)
+{
+	struct subchannel *sch;
+	void *reference_buf;
+	void *hw_block;
+	struct cmb_data *cmb_data;
+
+	sch = to_subchannel(cdev->dev.parent);
+
+	if (stsch(sch->schid, &sch->schib))
+		return -ENODEV;
+
+	if (sch->schib.scsw.fctl & SCSW_FCTL_START_FUNC) {
+		/* Don't copy if a start function is in progress. */
+		if ((!sch->schib.scsw.actl & SCSW_ACTL_SUSPENDED) &&
+		    (sch->schib.scsw.actl &
+		     (SCSW_ACTL_DEVACT | SCSW_ACTL_SCHACT)) &&
+		    (!sch->schib.scsw.stctl & SCSW_STCTL_SEC_STATUS))
+			return -EBUSY;
+	}
+	cmb_data = cdev->private->cmb;
+	hw_block = cmbops->align(cmb_data->hw_block);
+	if (!memcmp(cmb_data->last_block, hw_block, cmb_data->size))
+		/* No need to copy. */
+		return 0;
+	reference_buf = kzalloc(cmb_data->size, GFP_ATOMIC);
+	if (!reference_buf)
+		return -ENOMEM;
+	/* Ensure consistency of block copied from hardware. */
+	do {
+		memcpy(cmb_data->last_block, hw_block, cmb_data->size);
+		memcpy(reference_buf, hw_block, cmb_data->size);
+	} while (memcmp(cmb_data->last_block, reference_buf, cmb_data->size));
+	cmb_data->last_update = get_clock();
+	kfree(reference_buf);
+	return 0;
+}
+
+struct copy_block_struct {
+	wait_queue_head_t wait;
+	int ret;
+	struct kref kref;
+};
+
+static void cmf_copy_block_release(struct kref *kref)
+{
+	struct copy_block_struct *copy_block;
+
+	copy_block = container_of(kref, struct copy_block_struct, kref);
+	kfree(copy_block);
+}
+
+static int cmf_cmb_copy_wait(struct ccw_device *cdev)
+{
+	struct copy_block_struct *copy_block;
+	int ret;
+	unsigned long flags;
+
+	spin_lock_irqsave(cdev->ccwlock, flags);
+	if (!cdev->private->cmb) {
+		ret = -ENODEV;
+		goto out;
+	}
+	copy_block = kzalloc(sizeof(struct copy_block_struct), GFP_ATOMIC);
+	if (!copy_block) {
+		ret = -ENOMEM;
+		goto out;
+	}
+	init_waitqueue_head(&copy_block->wait);
+	kref_init(&copy_block->kref);
+
+	ret = cmf_copy_block(cdev);
+	if (ret != -EBUSY)
+		goto out_put;
+
+	if (cdev->private->state != DEV_STATE_ONLINE) {
+		ret = -EBUSY;
+		goto out_put;
+	}
+
+	cdev->private->state = DEV_STATE_CMFUPDATE;
+	copy_block->ret = CMF_PENDING;
+	cdev->private->cmb_wait = copy_block;
+
+	spin_unlock_irqrestore(cdev->ccwlock, flags);
+	if (wait_event_interruptible(copy_block->wait,
+				     copy_block->ret != CMF_PENDING)) {
+		spin_lock_irqsave(cdev->ccwlock, flags);
+		if (copy_block->ret == CMF_PENDING) {
+			copy_block->ret = -ERESTARTSYS;
+			if (cdev->private->state == DEV_STATE_CMFUPDATE)
+				cdev->private->state = DEV_STATE_ONLINE;
+		}
+		spin_unlock_irqrestore(cdev->ccwlock, flags);
+	}
+	spin_lock_irqsave(cdev->ccwlock, flags);
+	cdev->private->cmb_wait = NULL;
+	ret = copy_block->ret;
+out_put:
+	kref_put(&copy_block->kref, cmf_copy_block_release);
+out:
+	spin_unlock_irqrestore(cdev->ccwlock, flags);
+	return ret;
+}
+
+void cmf_retry_copy_block(struct ccw_device *cdev)
+{
+	struct copy_block_struct *copy_block;
+
+	copy_block = cdev->private->cmb_wait;
+	if (!copy_block) {
+		WARN_ON(1);
+		return;
+	}
+	kref_get(&copy_block->kref);
+	copy_block->ret = cmf_copy_block(cdev);
+	wake_up(&copy_block->wait);
+	kref_put(&copy_block->kref, cmf_copy_block_release);
+}
+
+static void cmf_generic_reset(struct ccw_device *cdev)
+{
+	struct cmb_data *cmb_data;
+
+	spin_lock_irq(cdev->ccwlock);
+	cmb_data = cdev->private->cmb;
+	if (cmb_data) {
+		memset(cmb_data->last_block, 0, cmb_data->size);
+		/*
+		 * Need to reset hw block as well to make the hardware start
+		 * from 0 again.
+		 */
+		memset(cmbops->align(cmb_data->hw_block), 0, cmb_data->size);
+		cmb_data->last_update = 0;
+	}
+	cdev->private->cmb_start_time = get_clock();
+	spin_unlock_irq(cdev->ccwlock);
@@ -346,2 +522,2 @@
-static inline int
-alloc_cmb_single (struct ccw_device *cdev)
+static inline int alloc_cmb_single (struct ccw_device *cdev,
+				    struct cmb_data *cmb_data)
@@ -361 +537 @@
-	 * remains sorted by ->cmb pointers */
+	 * remains sorted by ->cmb->hw_data pointers */
@@ -364 +540,3 @@
-		if ((struct cmb*)node->cmb > cmb)
+		struct cmb_data *data;
+		data = node->cmb;
+		if ((struct cmb*)data->hw_block > cmb)
@@ -375 +553,2 @@
-	cdev->private->cmb = cmb;
+	cmb_data->hw_block = cmb;
+	cdev->private->cmb = cmb_data;
@@ -387,0 +567,6 @@
+	struct cmb_data *cmb_data;
+
+	/* Allocate private cmb_data. */
+	cmb_data = kzalloc(sizeof(struct cmb_data), GFP_KERNEL);
+	if (!cmb_data)
+		return -ENOMEM;
@@ -388,0 +574,6 @@
+	cmb_data->last_block = kzalloc(sizeof(struct cmb), GFP_KERNEL);
+	if (!cmb_data->last_block) {
+		kfree(cmb_data);
+		return -ENOMEM;
+	}
+	cmb_data->size = sizeof(struct cmb);
@@ -417 +608 @@
-	ret = alloc_cmb_single(cdev);
+	ret = alloc_cmb_single(cdev, cmb_data);
@@ -420 +611,4 @@
-
+	if (ret) {
+		kfree(cmb_data->last_block);
+		kfree(cmb_data);
+	}
@@ -424,2 +618 @@
-static void
-free_cmb(struct ccw_device *cdev)
+static void free_cmb(struct ccw_device *cdev)
@@ -428,2 +621 @@
-
-	priv = cdev->private;
+	struct cmb_data *cmb_data;
@@ -433,0 +626,2 @@
+	priv = cdev->private;
+
@@ -438,0 +633 @@
+	cmb_data = priv->cmb;
@@ -439,0 +635,3 @@
+	if (cmb_data)
+		kfree(cmb_data->last_block);
+	kfree(cmb_data);
@@ -454,2 +652 @@
-static int
-set_cmb(struct ccw_device *cdev, u32 mme)
+static int set_cmb(struct ccw_device *cdev, u32 mme)
@@ -457,0 +655,2 @@
+	struct cmb_data *cmb_data;
+	unsigned long flags;
@@ -459 +658,3 @@
-	if (!cdev->private->cmb)
+	spin_lock_irqsave(cdev->ccwlock, flags);
+	if (!cdev->private->cmb) {
+		spin_unlock_irqrestore(cdev->ccwlock, flags);
@@ -461,2 +662,4 @@
-
-	offset = mme ? (struct cmb *)cdev->private->cmb - cmb_area.mem : 0;
+	}
+	cmb_data = cdev->private->cmb;
+	offset = mme ? (struct cmb *)cmb_data->hw_block - cmb_area.mem : 0;
+	spin_unlock_irqrestore(cdev->ccwlock, flags);
@@ -467,2 +670 @@
-static u64
-read_cmb (struct ccw_device *cdev, int index)
+static u64 read_cmb (struct ccw_device *cdev, int index)
@@ -470,5 +672 @@
-	/* yes, we have to put it on the stack
-	 * because the cmb must only be accessed
-	 * atomically, e.g. with mvc */
-	struct cmb cmb;
-	unsigned long flags;
+	struct cmb *cmb;
@@ -475,0 +674,6 @@
+	int ret;
+	unsigned long flags;
+
+	ret = cmf_cmb_copy_wait(cdev);
+	if (ret < 0)
+		return 0;
@@ -479,2 +683,2 @@
-		spin_unlock_irqrestore(cdev->ccwlock, flags);
-		return 0;
+		ret = 0;
+		goto out;
@@ -482,3 +686 @@
-
-	cmb = *(struct cmb*)cdev->private->cmb;
-	spin_unlock_irqrestore(cdev->ccwlock, flags);
+	cmb = ((struct cmb_data *)cdev->private->cmb)->last_block;
@@ -488 +690,2 @@
-		return cmb.ssch_rsch_count;
+		ret = cmb->ssch_rsch_count;
+		goto out;
@@ -490 +693,2 @@
-		return cmb.sample_count;
+		ret = cmb->sample_count;
+		goto out;
@@ -492 +696 @@
-		val = cmb.device_connect_time;
+		val = cmb->device_connect_time;
@@ -495 +699 @@
-		val = cmb.function_pending_time;
+		val = cmb->function_pending_time;
@@ -498 +702 @@
-		val = cmb.device_disconnect_time;
+		val = cmb->device_disconnect_time;
@@ -501 +705 @@
-		val = cmb.control_unit_queuing_time;
+		val = cmb->control_unit_queuing_time;
@@ -504 +708 @@
-		val = cmb.device_active_only_time;
+		val = cmb->device_active_only_time;
@@ -507 +711,2 @@
-		return 0;
+		ret = 0;
+		goto out;
@@ -509 +714,4 @@
-	return time_to_avg_nsec(val, cmb.sample_count);
+	ret = time_to_avg_nsec(val, cmb->sample_count);
+out:
+	spin_unlock_irqrestore(cdev->ccwlock, flags);
+	return ret;
@@ -512,2 +720 @@
-static int
-readall_cmb (struct ccw_device *cdev, struct cmbdata *data)
+static int readall_cmb (struct ccw_device *cdev, struct cmbdata *data)
@@ -515,5 +722,2 @@
-	/* yes, we have to put it on the stack
-	 * because the cmb must only be accessed
-	 * atomically, e.g. with mvc */
-	struct cmb cmb;
-	unsigned long flags;
+	struct cmb *cmb;
+	struct cmb_data *cmb_data;
@@ -520,0 +725,2 @@
+	unsigned long flags;
+	int ret;
@@ -521,0 +728,3 @@
+	ret = cmf_cmb_copy_wait(cdev);
+	if (ret < 0)
+		return ret;
@@ -523,3 +732,4 @@
-	if (!cdev->private->cmb) {
-		spin_unlock_irqrestore(cdev->ccwlock, flags);
-		return -ENODEV;
+	cmb_data = cdev->private->cmb;
+	if (!cmb_data) {
+		ret = -ENODEV;
+		goto out;
@@ -527,4 +737,6 @@
-
-	cmb = *(struct cmb*)cdev->private->cmb;
-	time = get_clock() - cdev->private->cmb_start_time;
-	spin_unlock_irqrestore(cdev->ccwlock, flags);
+	if (cmb_data->last_update == 0) {
+		ret = -EAGAIN;
+		goto out;
+	}
+	cmb = cmb_data->last_block;
+	time = cmb_data->last_update - cdev->private->cmb_start_time;
@@ -541,2 +753,2 @@
-	data->ssch_rsch_count = cmb.ssch_rsch_count;
-	data->sample_count = cmb.sample_count;
+	data->ssch_rsch_count = cmb->ssch_rsch_count;
+	data->sample_count = cmb->sample_count;
@@ -545,3 +757,4 @@
-	data->device_connect_time = time_to_nsec(cmb.device_connect_time);
-	data->function_pending_time = time_to_nsec(cmb.function_pending_time);
-	data->device_disconnect_time = time_to_nsec(cmb.device_disconnect_time);
+	data->device_connect_time = time_to_nsec(cmb->device_connect_time);
+	data->function_pending_time = time_to_nsec(cmb->function_pending_time);
+	data->device_disconnect_time =
+		time_to_nsec(cmb->device_disconnect_time);
@@ -549 +762 @@
-		= time_to_nsec(cmb.control_unit_queuing_time);
+		= time_to_nsec(cmb->control_unit_queuing_time);
@@ -551 +764,6 @@
-		= time_to_nsec(cmb.device_active_only_time);
+		= time_to_nsec(cmb->device_active_only_time);
+	ret = 0;
+out:
+	spin_unlock_irqrestore(cdev->ccwlock, flags);
+	return ret;
+}
@@ -553 +771,3 @@
-	return 0;
+static void reset_cmb(struct ccw_device *cdev)
+{
+	cmf_generic_reset(cdev);
@@ -556,2 +776 @@
-static void
-reset_cmb(struct ccw_device *cdev)
+static void * align_cmb(void *area)
@@ -559,7 +778 @@
-	struct cmb *cmb;
-	spin_lock_irq(cdev->ccwlock);
-	cmb = cdev->private->cmb;
-	if (cmb)
-		memset (cmb, 0, sizeof (*cmb));
-	cdev->private->cmb_start_time = get_clock();
-	spin_unlock_irq(cdev->ccwlock);
+	return area;
@@ -576,0 +790 @@
+	.align	    = align_cmb,
@@ -613,2 +827 @@
-static int
-alloc_cmbe (struct ccw_device *cdev)
+static int alloc_cmbe (struct ccw_device *cdev)
@@ -617 +830,4 @@
-	cmbe = kmalloc (sizeof (*cmbe) * 2, GFP_KERNEL);
+	struct cmb_data *cmb_data;
+	int ret;
+
+	cmbe = kzalloc (sizeof (*cmbe) * 2, GFP_KERNEL);
@@ -620 +836,11 @@
-
+	cmb_data = kzalloc(sizeof(struct cmb_data), GFP_KERNEL);
+	if (!cmb_data) {
+		ret = -ENOMEM;
+		goto out_free;
+	}
+	cmb_data->last_block = kzalloc(sizeof(struct cmbe), GFP_KERNEL);
+	if (!cmb_data->last_block) {
+		ret = -ENOMEM;
+		goto out_free;
+	}
+	cmb_data->size = sizeof(struct cmbe);
@@ -623 +848,0 @@
-		kfree(cmbe);
@@ -625 +850,2 @@
-		return -EBUSY;
+		ret = -EBUSY;
+		goto out_free;
@@ -627,2 +853,2 @@
-
-	cdev->private->cmb = cmbe;
+	cmb_data->hw_block = cmbe;
+	cdev->private->cmb = cmb_data;
@@ -638,0 +865,6 @@
+out_free:
+	if (cmb_data)
+		kfree(cmb_data->last_block);
+	kfree(cmb_data);
+	kfree(cmbe);
+	return ret;
@@ -641,2 +873 @@
-static void
-free_cmbe (struct ccw_device *cdev)
+static void free_cmbe (struct ccw_device *cdev)
@@ -643,0 +875,2 @@
+	struct cmb_data *cmb_data;
+
@@ -645 +878 @@
-	kfree(cdev->private->cmb);
+	cmb_data = cdev->private->cmb;
@@ -646,0 +880,3 @@
+	if (cmb_data)
+		kfree(cmb_data->last_block);
+	kfree(cmb_data);
@@ -657,2 +893 @@
-static int
-set_cmbe(struct ccw_device *cdev, u32 mme)
+static int set_cmbe(struct ccw_device *cdev, u32 mme)
@@ -660,0 +896,2 @@
+	struct cmb_data *cmb_data;
+	unsigned long flags;
@@ -662 +899,3 @@
-	if (!cdev->private->cmb)
+	spin_lock_irqsave(cdev->ccwlock, flags);
+	if (!cdev->private->cmb) {
+		spin_unlock_irqrestore(cdev->ccwlock, flags);
@@ -664 +903,4 @@
-	mba = mme ? (unsigned long) cmbe_align(cdev->private->cmb) : 0;
+	}
+	cmb_data = cdev->private->cmb;
+	mba = mme ? (unsigned long) cmbe_align(cmb_data->hw_block) : 0;
+	spin_unlock_irqrestore(cdev->ccwlock, flags);
@@ -670,2 +912 @@
-u64
-read_cmbe (struct ccw_device *cdev, int index)
+static u64 read_cmbe (struct ccw_device *cdev, int index)
@@ -673,5 +914,2 @@
-	/* yes, we have to put it on the stack
-	 * because the cmb must only be accessed
-	 * atomically, e.g. with mvc */
-	struct cmbe cmb;
-	unsigned long flags;
+	struct cmbe *cmb;
+	struct cmb_data *cmb_data;
@@ -678,0 +917,2 @@
+	int ret;
+	unsigned long flags;
@@ -680,3 +920,2 @@
-	spin_lock_irqsave(cdev->ccwlock, flags);
-	if (!cdev->private->cmb) {
-		spin_unlock_irqrestore(cdev->ccwlock, flags);
+	ret = cmf_cmb_copy_wait(cdev);
+	if (ret < 0)
@@ -684 +922,0 @@
-	}
@@ -686,2 +924,7 @@
-	cmb = *cmbe_align(cdev->private->cmb);
-	spin_unlock_irqrestore(cdev->ccwlock, flags);
+	spin_lock_irqsave(cdev->ccwlock, flags);
+	cmb_data = cdev->private->cmb;
+	if (!cmb_data) {
+		ret = 0;
+		goto out;
+	}
+	cmb = cmb_data->last_block;
@@ -691 +934,2 @@
-		return cmb.ssch_rsch_count;
+		ret = cmb->ssch_rsch_count;
+		goto out;
@@ -693 +937,2 @@
-		return cmb.sample_count;
+		ret = cmb->sample_count;
+		goto out;
@@ -695 +940 @@
-		val = cmb.device_connect_time;
+		val = cmb->device_connect_time;
@@ -698 +943 @@
-		val = cmb.function_pending_time;
+		val = cmb->function_pending_time;
@@ -701 +946 @@
-		val = cmb.device_disconnect_time;
+		val = cmb->device_disconnect_time;
@@ -704 +949 @@
-		val = cmb.control_unit_queuing_time;
+		val = cmb->control_unit_queuing_time;
@@ -707 +952 @@
-		val = cmb.device_active_only_time;
+		val = cmb->device_active_only_time;
@@ -710 +955 @@
-		val = cmb.device_busy_time;
+		val = cmb->device_busy_time;
@@ -713 +958 @@
-		val = cmb.initial_command_response_time;
+		val = cmb->initial_command_response_time;
@@ -716 +961,2 @@
-		return 0;
+		ret = 0;
+		goto out;
@@ -718 +964,4 @@
-	return time_to_avg_nsec(val, cmb.sample_count);
+	ret = time_to_avg_nsec(val, cmb->sample_count);
+out:
+	spin_unlock_irqrestore(cdev->ccwlock, flags);
+	return ret;
@@ -721,2 +970 @@
-static int
-readall_cmbe (struct ccw_device *cdev, struct cmbdata *data)
+static int readall_cmbe (struct ccw_device *cdev, struct cmbdata *data)
@@ -724,5 +972,2 @@
-	/* yes, we have to put it on the stack
-	 * because the cmb must only be accessed
-	 * atomically, e.g. with mvc */
-	struct cmbe cmb;
-	unsigned long flags;
+	struct cmbe *cmb;
+	struct cmb_data *cmb_data;
@@ -729,0 +975,2 @@
+	unsigned long flags;
+	int ret;
@@ -730,0 +978,3 @@
+	ret = cmf_cmb_copy_wait(cdev);
+	if (ret < 0)
+		return ret;
@@ -732,3 +982,4 @@
-	if (!cdev->private->cmb) {
-		spin_unlock_irqrestore(cdev->ccwlock, flags);
-		return -ENODEV;
+	cmb_data = cdev->private->cmb;
+	if (!cmb_data) {
+		ret = -ENODEV;
+		goto out;
@@ -736,4 +987,5 @@
-
-	cmb = *cmbe_align(cdev->private->cmb);
-	time = get_clock() - cdev->private->cmb_start_time;
-	spin_unlock_irqrestore(cdev->ccwlock, flags);
+	if (cmb_data->last_update == 0) {
+		ret = -EAGAIN;
+		goto out;
+	}
+	time = cmb_data->last_update - cdev->private->cmb_start_time;
@@ -748,0 +1001 @@
+	cmb = cmb_data->last_block;
@@ -750,2 +1003,2 @@
-	data->ssch_rsch_count = cmb.ssch_rsch_count;
-	data->sample_count = cmb.sample_count;
+	data->ssch_rsch_count = cmb->ssch_rsch_count;
+	data->sample_count = cmb->sample_count;
@@ -754,3 +1007,4 @@
-	data->device_connect_time = time_to_nsec(cmb.device_connect_time);
-	data->function_pending_time = time_to_nsec(cmb.function_pending_time);
-	data->device_disconnect_time = time_to_nsec(cmb.device_disconnect_time);
+	data->device_connect_time = time_to_nsec(cmb->device_connect_time);
+	data->function_pending_time = time_to_nsec(cmb->function_pending_time);
+	data->device_disconnect_time =
+		time_to_nsec(cmb->device_disconnect_time);
@@ -758 +1012 @@
-		= time_to_nsec(cmb.control_unit_queuing_time);
+		= time_to_nsec(cmb->control_unit_queuing_time);
@@ -760,2 +1014,2 @@
-		= time_to_nsec(cmb.device_active_only_time);
-	data->device_busy_time = time_to_nsec(cmb.device_busy_time);
+		= time_to_nsec(cmb->device_active_only_time);
+	data->device_busy_time = time_to_nsec(cmb->device_busy_time);
@@ -763 +1017 @@
-		= time_to_nsec(cmb.initial_command_response_time);
+		= time_to_nsec(cmb->initial_command_response_time);
@@ -765 +1019,4 @@
-	return 0;
+	ret = 0;
+out:
+	spin_unlock_irqrestore(cdev->ccwlock, flags);
+	return ret;
@@ -768,2 +1025 @@
-static void
-reset_cmbe(struct ccw_device *cdev)
+static void reset_cmbe(struct ccw_device *cdev)
@@ -771,7 +1027,6 @@
-	struct cmbe *cmb;
-	spin_lock_irq(cdev->ccwlock);
-	cmb = cmbe_align(cdev->private->cmb);
-	if (cmb)
-		memset (cmb, 0, sizeof (*cmb));
-	cdev->private->cmb_start_time = get_clock();
-	spin_unlock_irq(cdev->ccwlock);
+	cmf_generic_reset(cdev);
+}
+
+static void * align_cmbe(void *area)
+{
+	return cmbe_align(area);
@@ -788,0 +1044 @@
+	.align	    = align_cmbe,
@@ -805,0 +1062 @@
+	struct cmb_data *cmb_data;
@@ -808 +1064,0 @@
-	interval  = get_clock() - cdev->private->cmb_start_time;
@@ -810 +1066,6 @@
-	if (count)
+	spin_lock_irq(cdev->ccwlock);
+	cmb_data = cdev->private->cmb;
+	if (count) {
+		interval = cmb_data->last_update -
+			cdev->private->cmb_start_time;
+		interval = (interval * 1000) >> 12;
@@ -812 +1073 @@
-	else
+	} else
@@ -813,0 +1075 @@
+	spin_unlock_irq(cdev->ccwlock);
@@ -826 +1088,4 @@
-	if (ret)
+	if (ret == -EAGAIN || ret == -ENODEV)
+		/* No data (yet/currently) available to use for calculation. */
+		return sprintf(buf, "n/a\n");
+	else if (ret)
@@ -879 +1144 @@
-	0,
+	NULL,
@@ -899 +1164 @@
-	0,
+	NULL,
@@ -984,0 +1250,7 @@
+/* Reenable cmf when a disconnected device becomes available again. */
+int cmf_reenable(struct ccw_device *cdev)
+{
+	cmbops->reset(cdev);
+	return cmbops->set(cdev, 2);
+}
+
--- ./projects/linux/linux-2.6.20/drivers/s390/cio/cmf.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/s390/cio/cmf.c	2007-04-26 05:08:32.000000000 +0200
@@ -522,2 +522,2 @@
-static inline int alloc_cmb_single (struct ccw_device *cdev,
-				    struct cmb_data *cmb_data)
+static int alloc_cmb_single(struct ccw_device *cdev,
+			    struct cmb_data *cmb_data)
--- ./projects/linux/linux-2.6.21/drivers/s390/cio/cmf.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/s390/cio/cmf.c	2007-07-09 01:32:17.000000000 +0200
@@ -479 +479 @@
-	.lock = SPIN_LOCK_UNLOCKED,
+	.lock = __SPIN_LOCK_UNLOCKED(cmb_area.lock),
--- ./projects/linux/linux-2.6.22/drivers/s390/cio/cmf.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/s390/cio/cmf.c	2007-10-09 22:31:38.000000000 +0200
@@ -596,0 +597,3 @@
+			printk(KERN_WARNING "cio: failed to allocate area "
+			       "for measuring %d subchannels\n",
+			       cmb_area.num_channels);
@@ -1188 +1191 @@
-			printk(KERN_INFO "disable_cmf failed (%d)\n", ret);
+			dev_info(&cdev->dev, "disable_cmf failed (%d)\n", ret);
@@ -1193 +1196 @@
-			printk(KERN_INFO "enable_cmf failed (%d)\n", ret);
+			dev_info(&cdev->dev, "enable_cmf failed (%d)\n", ret);
@@ -1282,7 +1284,0 @@
-		if (cmb_area.num_channels > 4096 || cmb_area.num_channels < 1) {
-			printk(KERN_ERR "Basic channel measurement facility"
-					" can only use 1 to 4096 devices\n"
-			       KERN_ERR "when the cmf driver is built"
-					" as a loadable module\n");
-			return 1;
-		}
@@ -1295 +1291 @@
-		printk(KERN_ERR "Invalid format %d for channel "
+		printk(KERN_ERR "cio: Invalid format %d for channel "
@@ -1300,2 +1296,2 @@
-	printk(KERN_INFO "Channel measurement facility using %s format (%s)\n",
-		format_string, detect_string);
+	printk(KERN_INFO "cio: Channel measurement facility using %s "
+	       "format (%s)\n", format_string, detect_string);
--- ./projects/linux/linux-2.6.23/drivers/s390/cio/cmf.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/s390/cio/cmf.c	2008-01-24 23:58:37.000000000 +0100
@@ -48 +48,2 @@
-/* parameter to enable cmf during boot, possible uses are:
+/*
+ * parameter to enable cmf during boot, possible uses are:
@@ -76 +77 @@
- * 		    by all machines that we run on
+ *		    by all machines that we run on
@@ -78,4 +79,5 @@
- * 		    machine
- * @CMF_AUTODETECT: default: use extended format when running on a z990
- *                  or later machine, otherwise fall back to basic format
- **/
+ *		    machine
+ * @CMF_AUTODETECT: default: use extended format when running on a machine
+ *		    supporting extended format, otherwise fall back to
+ *		    basic format
+ */
@@ -87 +89,2 @@
-/**
+
+/*
@@ -107,0 +111 @@
+ * @read:	read a measurement entry at an index
@@ -114,8 +118,8 @@
-	int (*alloc)  (struct ccw_device*);
-	void(*free)   (struct ccw_device*);
-	int (*set)    (struct ccw_device*, u32);
-	u64 (*read)   (struct ccw_device*, int);
-	int (*readall)(struct ccw_device*, struct cmbdata *);
-	void (*reset) (struct ccw_device*);
-	void * (*align) (void *);
-
+	int  (*alloc)  (struct ccw_device *);
+	void (*free)   (struct ccw_device *);
+	int  (*set)    (struct ccw_device *, u32);
+	u64  (*read)   (struct ccw_device *, int);
+	int  (*readall)(struct ccw_device *, struct cmbdata *);
+	void (*reset)  (struct ccw_device *);
+	void *(*align) (void *);
+/* private: */
@@ -133 +137,2 @@
-/* our user interface is designed in terms of nanoseconds,
+/*
+ * Our user interface is designed in terms of nanoseconds,
@@ -135 +140,2 @@
- * unit.*/
+ * unit.
+ */
@@ -155 +161 @@
-	/* value comes in units of 128 sec */
+	/* value comes in units of 128 sec */
@@ -162 +168,2 @@
-/* activate or deactivate the channel monitor. When area is NULL,
+/*
+ * Activate or deactivate the channel monitor. When area is NULL,
@@ -165,3 +172,3 @@
- * to be enabled. */
-static inline void
-cmf_activate(void *area, unsigned int onoff)
+ * to be enabled.
+ */
+static inline void cmf_activate(void *area, unsigned int onoff)
@@ -178,2 +185,2 @@
-static int
-set_schib(struct ccw_device *cdev, u32 mme, int mbfc, unsigned long address)
+static int set_schib(struct ccw_device *cdev, u32 mme, int mbfc,
+		     unsigned long address)
@@ -339 +346 @@
-		if ((!sch->schib.scsw.actl & SCSW_ACTL_SUSPENDED) &&
+		if ((!(sch->schib.scsw.actl & SCSW_ACTL_SUSPENDED)) &&
@@ -342 +349 @@
-		    (!sch->schib.scsw.stctl & SCSW_STCTL_SEC_STATUS))
+		    (!(sch->schib.scsw.stctl & SCSW_STCTL_SEC_STATUS)))
@@ -468,0 +476 @@
+ * @num_channels: number of channels to be measured
@@ -484 +491,0 @@
-
@@ -487,2 +494 @@
-/** int maxchannels
- *
+/*
@@ -495 +501 @@
- * maximum is 4096
+ * maximum is 4096.
@@ -501,0 +508,11 @@
+ * @ssch_rsch_count: number of ssch and rsch
+ * @sample_count: number of samples
+ * @device_connect_time: time of device connect
+ * @function_pending_time: time of function pending
+ * @device_disconnect_time: time of device disconnect
+ * @control_unit_queuing_time: time of control unit queuing
+ * @device_active_only_time: time of device active only
+ * @reserved: unused in basic measurement mode
+ *
+ * The measurement block as used by the hardware. The fields are described
+ * further in z/Architecture Principles of Operation, chapter 17.
@@ -503,3 +520,2 @@
- * cmb as used by the hardware the fields are described in z/Architecture
- * Principles of Operation, chapter 17.
- * The area to be a contiguous array and may not be reallocated or freed.
+ * The cmb area made up from these blocks must be a contiguous array and may
+ * not be reallocated or freed.
@@ -519,2 +535,3 @@
-/* insert a single device into the cmb_area list
- * called with cmb_area.lock held from alloc_cmb
+/*
+ * Insert a single device into the cmb_area list.
+ * Called with cmb_area.lock held from alloc_cmb.
@@ -535,3 +552,5 @@
-	/* find first unused cmb in cmb_area.mem.
-	 * this is a little tricky: cmb_area.list
-	 * remains sorted by ->cmb->hw_data pointers */
+	/*
+	 * Find first unused cmb in cmb_area.mem.
+	 * This is a little tricky: cmb_area.list
+	 * remains sorted by ->cmb->hw_data pointers.
+	 */
@@ -561,2 +580 @@
-static int
-alloc_cmb (struct ccw_device *cdev)
+static int alloc_cmb(struct ccw_device *cdev)
@@ -673 +691 @@
-static u64 read_cmb (struct ccw_device *cdev, int index)
+static u64 read_cmb(struct ccw_device *cdev, int index)
@@ -723 +741 @@
-static int readall_cmb (struct ccw_device *cdev, struct cmbdata *data)
+static int readall_cmb(struct ccw_device *cdev, struct cmbdata *data)
@@ -796 +814 @@
-
+
@@ -800,0 +819,10 @@
+ * @ssch_rsch_count: number of ssch and rsch
+ * @sample_count: number of samples
+ * @device_connect_time: time of device connect
+ * @function_pending_time: time of function pending
+ * @device_disconnect_time: time of device disconnect
+ * @control_unit_queuing_time: time of control unit queuing
+ * @device_active_only_time: time of device active only
+ * @device_busy_time: time of device busy
+ * @initial_command_response_time: initial command response time
+ * @reserved: unused
@@ -802,2 +830,3 @@
- * cmb as used by the hardware, may be in any 64 bit physical location,
- * the fields are described in z/Architecture Principles of Operation,
+ * The measurement block as used by the hardware. May be in any 64 bit physical
+ * location.
+ * The fields are described further in z/Architecture Principles of Operation,
@@ -819 +848,2 @@
-/* kmalloc only guarantees 8 byte alignment, but we need cmbe
+/*
+ * kmalloc only guarantees 8 byte alignment, but we need cmbe
@@ -821,2 +851,3 @@
- * enough space for two cmbes */
-static inline struct cmbe* cmbe_align(struct cmbe *c)
+ * enough space for two cmbes.
+ */
+static inline struct cmbe *cmbe_align(struct cmbe *c)
@@ -830 +861 @@
-static int alloc_cmbe (struct ccw_device *cdev)
+static int alloc_cmbe(struct ccw_device *cdev)
@@ -876 +907 @@
-static void free_cmbe (struct ccw_device *cdev)
+static void free_cmbe(struct ccw_device *cdev)
@@ -915 +946 @@
-static u64 read_cmbe (struct ccw_device *cdev, int index)
+static u64 read_cmbe(struct ccw_device *cdev, int index)
@@ -973 +1004 @@
-static int readall_cmbe (struct ccw_device *cdev, struct cmbdata *data)
+static int readall_cmbe(struct ccw_device *cdev, struct cmbdata *data)
@@ -1050 +1080,0 @@
-
@@ -1052,2 +1082 @@
-static ssize_t
-cmb_show_attr(struct device *dev, char *buf, enum cmb_index idx)
+static ssize_t cmb_show_attr(struct device *dev, char *buf, enum cmb_index idx)
@@ -1059,2 +1088,3 @@
-static ssize_t
-cmb_show_avg_sample_interval(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t cmb_show_avg_sample_interval(struct device *dev,
+					    struct device_attribute *attr,
+					    char *buf)
@@ -1082,2 +1112,3 @@
-static ssize_t
-cmb_show_avg_utilization(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t cmb_show_avg_utilization(struct device *dev,
+					struct device_attribute *attr,
+					char *buf)
@@ -1115,3 +1146,4 @@
-static ssize_t show_ ## name (struct device * dev, struct device_attribute *attr, char * buf) \
-{ return cmb_show_attr((dev), buf, cmb_ ## name); } \
-static DEVICE_ATTR(name, 0444, show_ ## name, NULL);
+static ssize_t show_##name(struct device *dev, \
+			   struct device_attribute *attr, char *buf)	\
+{ return cmb_show_attr((dev), buf, cmb_##name); } \
+static DEVICE_ATTR(name, 0444, show_##name, NULL);
@@ -1120,3 +1152,4 @@
-static ssize_t show_avg_ ## name (struct device * dev, struct device_attribute *attr, char * buf) \
-{ return cmb_show_attr((dev), buf, cmb_ ## name); } \
-static DEVICE_ATTR(avg_ ## name, 0444, show_avg_ ## name, NULL);
+static ssize_t show_avg_##name(struct device *dev, \
+			       struct device_attribute *attr, char *buf) \
+{ return cmb_show_attr((dev), buf, cmb_##name); } \
+static DEVICE_ATTR(avg_##name, 0444, show_avg_##name, NULL);
@@ -1134 +1167,2 @@
-static DEVICE_ATTR(avg_sample_interval, 0444, cmb_show_avg_sample_interval, NULL);
+static DEVICE_ATTR(avg_sample_interval, 0444, cmb_show_avg_sample_interval,
+		   NULL);
@@ -1175 +1209,3 @@
-static ssize_t cmb_enable_show(struct device *dev, struct device_attribute *attr, char *buf)
+static ssize_t cmb_enable_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
@@ -1180 +1216,3 @@
-static ssize_t cmb_enable_store(struct device *dev, struct device_attribute *attr, const char *buf, size_t c)
+static ssize_t cmb_enable_store(struct device *dev,
+				struct device_attribute *attr, const char *buf,
+				size_t c)
@@ -1205,3 +1243,10 @@
-/* enable_cmf/disable_cmf: module interface for cmf (de)activation */
-int
-enable_cmf(struct ccw_device *cdev)
+/**
+ * enable_cmf() - switch on the channel measurement for a specific device
+ *  @cdev:	The ccw device to be enabled
+ *
+ *  Returns %0 for success or a negative error value.
+ *
+ *  Context:
+ *    non-atomic
+ */
+int enable_cmf(struct ccw_device *cdev)
@@ -1228,2 +1273,10 @@
-int
-disable_cmf(struct ccw_device *cdev)
+/**
+ * disable_cmf() - switch off the channel measurement for a specific device
+ *  @cdev:	The ccw device to be disabled
+ *
+ *  Returns %0 for success or a negative error value.
+ *
+ *  Context:
+ *    non-atomic
+ */
+int disable_cmf(struct ccw_device *cdev)
@@ -1241,2 +1294,11 @@
-u64
-cmf_read(struct ccw_device *cdev, int index)
+/**
+ * cmf_read() - read one value from the current channel measurement block
+ * @cdev:	the channel to be read
+ * @index:	the index of the value to be read
+ *
+ * Returns the value read or %0 if the value cannot be read.
+ *
+ *  Context:
+ *    any
+ */
+u64 cmf_read(struct ccw_device *cdev, int index)
@@ -1247,2 +1309,11 @@
-int
-cmf_readall(struct ccw_device *cdev, struct cmbdata *data)
+/**
+ * cmf_readall() - read the current channel measurement block
+ * @cdev:	the channel to be read
+ * @data:	a pointer to a data block that will be filled
+ *
+ * Returns %0 on success, a negative error value otherwise.
+ *
+ *  Context:
+ *    any
+ */
+int cmf_readall(struct ccw_device *cdev, struct cmbdata *data)
@@ -1260,2 +1331 @@
-static int __init
-init_cmf(void)
+static int __init init_cmf(void)
@@ -1266,3 +1336,5 @@
-	/* We cannot really autoprobe this. If the user did not give a parameter,
-	   see if we are running on z990 or up, otherwise fall back to basic mode. */
-
+	/*
+	 * If the user did not give a parameter, see if we are running on a
+	 * machine supporting extended measurement blocks, otherwise fall back
+	 * to basic mode.
+	 */
@@ -1287 +1359 @@
- 		format_string = "extended";
+		format_string = "extended";
--- ./projects/linux/linux-2.6.25/drivers/s390/cio/cmf.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/s390/cio/cmf.c	2008-07-13 23:51:29.000000000 +0200
@@ -1221,0 +1222,5 @@
+	unsigned long val;
+
+	ret = strict_strtoul(buf, 16, &val);
+	if (ret)
+		return ret;
@@ -1225,2 +1230,2 @@
-	switch (buf[0]) {
-	case '0':
+	switch (val) {
+	case 0:
@@ -1231 +1236 @@
-	case '1':
+	case 1:
--- ./projects/linux/linux-2.6.26/drivers/s390/cio/cmf.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/s390/cio/cmf.c	2008-10-10 00:13:53.000000000 +0200
@@ -344 +344 @@
-	if (sch->schib.scsw.fctl & SCSW_FCTL_START_FUNC) {
+	if (scsw_fctl(&sch->schib.scsw) & SCSW_FCTL_START_FUNC) {
@@ -346,2 +346,2 @@
-		if ((!(sch->schib.scsw.actl & SCSW_ACTL_SUSPENDED)) &&
-		    (sch->schib.scsw.actl &
+		if ((!(scsw_actl(&sch->schib.scsw) & SCSW_ACTL_SUSPENDED)) &&
+		    (scsw_actl(&sch->schib.scsw) &
@@ -349 +349 @@
-		    (!(sch->schib.scsw.stctl & SCSW_STCTL_SEC_STATUS)))
+		    (!(scsw_stctl(&sch->schib.scsw) & SCSW_STCTL_SEC_STATUS)))
@@ -615,3 +614,0 @@
-			printk(KERN_WARNING "cio: failed to allocate area "
-			       "for measuring %d subchannels\n",
-			       cmb_area.num_channels);
@@ -1233,2 +1229,0 @@
-		if (ret)
-			dev_info(&cdev->dev, "disable_cmf failed (%d)\n", ret);
@@ -1238,2 +1232,0 @@
-		if (ret && ret != -EBUSY)
-			dev_info(&cdev->dev, "enable_cmf failed (%d)\n", ret);
@@ -1347,2 +1340 @@
-		if (!css_characteristics_avail ||
-		    !css_general_characteristics.ext_mb) {
+		if (!css_general_characteristics.ext_mb) {
@@ -1368,2 +1359,0 @@
-		printk(KERN_ERR "cio: Invalid format %d for channel "
-			"measurement facility\n", format);
--- ./projects/linux/linux-2.6.28/drivers/s390/cio/cmf.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/s390/cio/cmf.c	2009-03-24 00:12:14.000000000 +0100
@@ -27,0 +28,3 @@
+#define KMSG_COMPONENT "cio"
+#define pr_fmt(fmt) KMSG_COMPONENT ": " fmt
+
@@ -188,2 +190,0 @@
-	int ret;
-	int retry;
@@ -191 +191,0 @@
-	struct schib *schib;
@@ -194,32 +193,0 @@
-	schib = &sch->schib;
-	/* msch can silently fail, so do it again if necessary */
-	for (retry = 0; retry < 3; retry++) {
-		/* prepare schib */
-		stsch(sch->schid, schib);
-		schib->pmcw.mme  = mme;
-		schib->pmcw.mbfc = mbfc;
-		/* address can be either a block address or a block index */
-		if (mbfc)
-			schib->mba = address;
-		else
-			schib->pmcw.mbi = address;
-
-		/* try to submit it */
-		switch(ret = msch_err(sch->schid, schib)) {
-			case 0:
-				break;
-			case 1:
-			case 2: /* in I/O or status pending */
-				ret = -EBUSY;
-				break;
-			case 3: /* subchannel is no longer valid */
-				ret = -ENODEV;
-				break;
-			default: /* msch caught an exception */
-				ret = -EINVAL;
-				break;
-		}
-		stsch(sch->schid, schib); /* restore the schib */
-
-		if (ret)
-			break;
@@ -227,6 +195,7 @@
-		/* check if it worked */
-		if (schib->pmcw.mme  == mme &&
-		    schib->pmcw.mbfc == mbfc &&
-		    (mbfc ? (schib->mba == address)
-			  : (schib->pmcw.mbi == address)))
-			return 0;
+	sch->config.mme = mme;
+	sch->config.mbfc = mbfc;
+	/* address can be either a block address or a block index */
+	if (mbfc)
+		sch->config.mba = address;
+	else
+		sch->config.mbi = address;
@@ -234,4 +203 @@
-		ret = -EINVAL;
-	}
-
-	return ret;
+	return cio_commit_config(sch);
@@ -341 +307 @@
-	if (stsch(sch->schid, &sch->schib))
+	if (cio_update_schib(sch))
@@ -1362,3 +1328,2 @@
-
-	printk(KERN_INFO "cio: Channel measurement facility using %s "
-	       "format (%s)\n", format_string, detect_string);
+	pr_info("Channel measurement facility initialized using format "
+		"%s (mode %s)\n", format_string, detect_string);
--- ./projects/linux/linux-2.6.14/drivers/scsi/atari_NCR5380.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/scsi/atari_NCR5380.c	2006-01-03 04:21:10.000000000 +0100
@@ -258 +258 @@
-static Scsi_Host_Template *the_template = NULL;
+static struct scsi_host_template *the_template = NULL;
--- ./projects/linux/linux-2.6.15/drivers/scsi/atari_NCR5380.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/scsi/atari_NCR5380.c	2006-03-20 06:53:29.000000000 +0100
@@ -76,0 +77 @@
+#include <scsi/scsi_transport_spi.h>
@@ -2358 +2359 @@
- * byte, since scsi_print_msg() wants the whole thing.  
+ * byte, since spi_print_msg() wants the whole thing.  
@@ -2411 +2412 @@
-			scsi_print_msg (extended_msg);
+			spi_print_msg(extended_msg);
@@ -2544 +2545 @@
-	scsi_print_msg(msg);
+	spi_print_msg(msg);
--- ./projects/linux/linux-2.6.17/drivers/scsi/atari_NCR5380.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/scsi/atari_NCR5380.c	2006-09-20 05:42:06.000000000 +0200
@@ -510 +510 @@
-	cmd->SCp.buffer = (struct scatterlist *) cmd->buffer;
+	cmd->SCp.buffer = (struct scatterlist *) cmd->request_buffer;
@@ -527 +526,0 @@
-#include <linux/config.h>
--- ./projects/linux/linux-2.6.18/drivers/scsi/atari_NCR5380.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/scsi/atari_NCR5380.c	2006-11-29 22:57:37.000000000 +0100
@@ -1265 +1265 @@
-static irqreturn_t NCR5380_intr (int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t NCR5380_intr (int irq, void *dev_id)
--- ./projects/linux/linux-2.6.21/drivers/scsi/atari_NCR5380.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/scsi/atari_NCR5380.c	2007-07-09 01:32:17.000000000 +0200
@@ -1 +1 @@
-/* 
+/*
@@ -3 +3 @@
- * 	to implement 5380 SCSI drivers under Linux with a non-trantor
+ *	to implement 5380 SCSI drivers under Linux with a non-trantor
@@ -9 +9 @@
- *	Visionary Computing 
+ *	Visionary Computing
@@ -11 +11 @@
- * 	drew@colorado.edu
+ *	drew@colorado.edu
@@ -14 +14 @@
- * DISTRIBUTION RELEASE 6. 
+ * DISTRIBUTION RELEASE 6.
@@ -16 +16 @@
- * For more information, please consult 
+ * For more information, please consult
@@ -60 +60 @@
- * 
+ *
@@ -72,2 +72,2 @@
- * Further development / testing that should be done : 
- * 1.  Test linked command handling code after Eric is ready with 
+ * Further development / testing that should be done :
+ * 1.  Test linked command handling code after Eric is ready with
@@ -80,7 +80,15 @@
-#define LIST(x,y) \
-  { printk("LINE:%d   Adding %p to %p\n", __LINE__, (void*)(x), (void*)(y)); \
-    if ((x)==(y)) udelay(5); }
-#define REMOVE(w,x,y,z) \
-  { printk("LINE:%d   Removing: %p->%p  %p->%p \n", __LINE__, \
-	   (void*)(w), (void*)(x), (void*)(y), (void*)(z)); \
-    if ((x)==(y)) udelay(5); }
+#define LIST(x, y)						\
+	do {							\
+		printk("LINE:%d   Adding %p to %p\n",		\
+		       __LINE__, (void*)(x), (void*)(y));	\
+		if ((x) == (y))					\
+			udelay(5);				\
+	} while (0)
+#define REMOVE(w, x, y, z)					\
+	do {							\
+		printk("LINE:%d   Removing: %p->%p  %p->%p \n",	\
+		       __LINE__, (void*)(w), (void*)(x),	\
+		       (void*)(y), (void*)(z));			\
+		if ((x) == (y))					\
+			udelay(5);				\
+	} while (0)
@@ -106 +114 @@
- * routines were implemented, meaning their implementations of queued 
+ * routines were implemented, meaning their implementations of queued
@@ -109 +117 @@
- * When I designed the Linux SCSI drivers I figured that 
+ * When I designed the Linux SCSI drivers I figured that
@@ -115 +123 @@
- * Finally, when I get questions from users, I have no idea what 
+ * Finally, when I get questions from users, I have no idea what
@@ -119 +127 @@
- * This is a generic 5380 driver.  To use it on a different platform, 
+ * This is a generic 5380 driver.  To use it on a different platform,
@@ -121 +129 @@
- * transfer - some PC's will use the I/O bus, 68K's must use 
+ * transfer - some PC's will use the I/O bus, 68K's must use
@@ -124 +132 @@
- * As far as command queueing, two queues are maintained for 
+ * As far as command queueing, two queues are maintained for
@@ -126,5 +134,5 @@
- * and commands that are currently executing.  This means that an 
- * unlimited number of commands may be queued, letting 
- * more commands propagate from the higher driver levels giving higher 
- * throughput.  Note that both I_T_L and I_T_L_Q nexuses are supported, 
- * allowing multiple commands to propagate all the way to a SCSI-II device 
+ * and commands that are currently executing.  This means that an
+ * unlimited number of commands may be queued, letting
+ * more commands propagate from the higher driver levels giving higher
+ * throughput.  Note that both I_T_L and I_T_L_Q nexuses are supported,
+ * allowing multiple commands to propagate all the way to a SCSI-II device
@@ -133 +141 @@
- * To solve the multiple-boards-in-the-same-system problem, 
+ * To solve the multiple-boards-in-the-same-system problem,
@@ -137 +145 @@
- * SCSI code.  
+ * SCSI code.
@@ -140,2 +148,2 @@
- * number (updated for each public release) printed by the 
- * NCR5380_print_options command, which should be called from the 
+ * number (updated for each public release) printed by the
+ * NCR5380_print_options command, which should be called from the
@@ -145 +153 @@
- * Issues specific to the NCR5380 : 
+ * Issues specific to the NCR5380 :
@@ -147,4 +155,4 @@
- * When used in a PIO or pseudo-dma mode, the NCR5380 is a braindead 
- * piece of hardware that requires you to sit in a loop polling for 
- * the REQ signal as long as you are connected.  Some devices are 
- * brain dead (ie, many TEXEL CD ROM drives) and won't disconnect 
+ * When used in a PIO or pseudo-dma mode, the NCR5380 is a braindead
+ * piece of hardware that requires you to sit in a loop polling for
+ * the REQ signal as long as you are connected.  Some devices are
+ * brain dead (ie, many TEXEL CD ROM drives) and won't disconnect
@@ -152 +160 @@
- * 
+ *
@@ -155 +163 @@
- * should disconnect, we do something like 
+ * should disconnect, we do something like
@@ -158,2 +166,2 @@
- * 
- * Some tweaking of N and M needs to be done.  An algorithm based 
+ *
+ * Some tweaking of N and M needs to be done.  An algorithm based
@@ -161 +169 @@
- * to datas (ie, on the same track) were considered, however these 
+ * to datas (ie, on the same track) were considered, however these
@@ -170,3 +178,3 @@
- * I_T_L or I_T_L_Q nexuses by removing the commands from the 
- * issue queue and calling NCR5380_select() if a nexus 
- * is not established. 
+ * I_T_L or I_T_L_Q nexuses by removing the commands from the
+ * issue queue and calling NCR5380_select() if a nexus
+ * is not established.
@@ -186 +194 @@
- * On command termination, the done function will be called as 
+ * On command termination, the done function will be called as
@@ -189 +197 @@
- * SCSI pointers are maintained in the SCp field of SCSI command 
+ * SCSI pointers are maintained in the SCp field of SCSI command
@@ -199 +207 @@
- * of chips.  To use it, you write an architecture specific functions 
+ * of chips.  To use it, you write an architecture specific functions
@@ -202 +210 @@
- * These macros control options : 
+ * These macros control options :
@@ -204 +212 @@
- *	for commands that return with a CHECK CONDITION status. 
+ *	for commands that return with a CHECK CONDITION status.
@@ -213 +221 @@
- * 
+ *
@@ -216 +224 @@
- * NCR5380_write(register, value) - write to the specific register 
+ * NCR5380_write(register, value) - write to the specific register
@@ -219 +227 @@
- * REAL functions : 
+ * REAL functions :
@@ -221 +229 @@
- * Note that the DMA setup functions should return the number of bytes 
+ * Note that the DMA setup functions should return the number of bytes
@@ -224 +232 @@
- * Also note that generic i386/PC versions of these macros are 
+ * Also note that generic i386/PC versions of these macros are
@@ -237,2 +245,2 @@
- * hardware), you must also define 
- *  
+ * hardware), you must also define
+ *
@@ -244 +252 @@
- * to be the global entry points into the specific driver, ie 
+ * to be the global entry points into the specific driver, ie
@@ -252 +260 @@
- * after setting the appropriate host specific fields and ID.  If the 
+ * after setting the appropriate host specific fields and ID.  If the
@@ -267,2 +275,3 @@
-#define	NEXT(cmd)	((Scsi_Cmnd *)((cmd)->host_scribble))
-#define	NEXTADDR(cmd)	((Scsi_Cmnd **)&((cmd)->host_scribble))
+#define	NEXT(cmd)		((Scsi_Cmnd *)(cmd)->host_scribble)
+#define	SET_NEXT(cmd,next)	((cmd)->host_scribble = (void *)(next))
+#define	NEXTADDR(cmd)		((Scsi_Cmnd **)&(cmd)->host_scribble)
@@ -315,3 +324,3 @@
-    DECLARE_BITMAP(allocated, MAX_TAGS);
-    int		nr_allocated;
-    int		queue_size;
+	DECLARE_BITMAP(allocated, MAX_TAGS);
+	int nr_allocated;
+	int queue_size;
@@ -320 +329 @@
-static TAG_ALLOC TagAlloc[8][8]; /* 8 targets and 8 LUNs */
+static TAG_ALLOC TagAlloc[8][8];	/* 8 targets and 8 LUNs */
@@ -323 +332 @@
-static void __init init_tags( void )
+static void __init init_tags(void)
@@ -325,16 +334,17 @@
-    int target, lun;
-    TAG_ALLOC *ta;
-    
-    if (!setup_use_tagged_queuing)
-	return;
-    
-    for( target = 0; target < 8; ++target ) {
-	for( lun = 0; lun < 8; ++lun ) {
-	    ta = &TagAlloc[target][lun];
-	    bitmap_zero(ta->allocated, MAX_TAGS);
-	    ta->nr_allocated = 0;
-	    /* At the beginning, assume the maximum queue size we could
-	     * support (MAX_TAGS). This value will be decreased if the target
-	     * returns QUEUE_FULL status.
-	     */
-	    ta->queue_size = MAX_TAGS;
+	int target, lun;
+	TAG_ALLOC *ta;
+
+	if (!setup_use_tagged_queuing)
+		return;
+
+	for (target = 0; target < 8; ++target) {
+		for (lun = 0; lun < 8; ++lun) {
+			ta = &TagAlloc[target][lun];
+			bitmap_zero(ta->allocated, MAX_TAGS);
+			ta->nr_allocated = 0;
+			/* At the beginning, assume the maximum queue size we could
+			 * support (MAX_TAGS). This value will be decreased if the target
+			 * returns QUEUE_FULL status.
+			 */
+			ta->queue_size = MAX_TAGS;
+		}
@@ -342 +351,0 @@
-    }
@@ -351 +360 @@
- */ 
+ */
@@ -353 +362 @@
-static int is_lun_busy( Scsi_Cmnd *cmd, int should_be_tagged )
+static int is_lun_busy(Scsi_Cmnd *cmd, int should_be_tagged)
@@ -355 +364 @@
-    SETUP_HOSTDATA(cmd->device->host);
+	SETUP_HOSTDATA(cmd->device->host);
@@ -357,12 +366,12 @@
-    if (hostdata->busy[cmd->device->id] & (1 << cmd->device->lun))
-	return( 1 );
-    if (!should_be_tagged ||
-	!setup_use_tagged_queuing || !cmd->device->tagged_supported)
-	return( 0 );
-    if (TagAlloc[cmd->device->id][cmd->device->lun].nr_allocated >=
-	TagAlloc[cmd->device->id][cmd->device->lun].queue_size ) {
-	TAG_PRINTK( "scsi%d: target %d lun %d: no free tags\n",
-		    H_NO(cmd), cmd->device->id, cmd->device->lun );
-	return( 1 );
-    }
-    return( 0 );
+	if (hostdata->busy[cmd->device->id] & (1 << cmd->device->lun))
+		return 1;
+	if (!should_be_tagged ||
+	    !setup_use_tagged_queuing || !cmd->device->tagged_supported)
+		return 0;
+	if (TagAlloc[cmd->device->id][cmd->device->lun].nr_allocated >=
+	    TagAlloc[cmd->device->id][cmd->device->lun].queue_size) {
+		TAG_PRINTK("scsi%d: target %d lun %d: no free tags\n",
+			   H_NO(cmd), cmd->device->id, cmd->device->lun);
+		return 1;
+	}
+	return 0;
@@ -377 +386 @@
-static void cmd_get_tag( Scsi_Cmnd *cmd, int should_be_tagged )
+static void cmd_get_tag(Scsi_Cmnd *cmd, int should_be_tagged)
@@ -379 +388 @@
-    SETUP_HOSTDATA(cmd->device->host);
+	SETUP_HOSTDATA(cmd->device->host);
@@ -381,21 +390,20 @@
-    /* If we or the target don't support tagged queuing, allocate the LUN for
-     * an untagged command.
-     */
-    if (!should_be_tagged ||
-	!setup_use_tagged_queuing || !cmd->device->tagged_supported) {
-	cmd->tag = TAG_NONE;
-	hostdata->busy[cmd->device->id] |= (1 << cmd->device->lun);
-	TAG_PRINTK( "scsi%d: target %d lun %d now allocated by untagged "
-		    "command\n", H_NO(cmd), cmd->device->id, cmd->device->lun );
-    }
-    else {
-	TAG_ALLOC *ta = &TagAlloc[cmd->device->id][cmd->device->lun];
-
-	cmd->tag = find_first_zero_bit( ta->allocated, MAX_TAGS );
-	set_bit( cmd->tag, ta->allocated );
-	ta->nr_allocated++;
-	TAG_PRINTK( "scsi%d: using tag %d for target %d lun %d "
-		    "(now %d tags in use)\n",
-		    H_NO(cmd), cmd->tag, cmd->device->id, cmd->device->lun,
-		    ta->nr_allocated );
-    }
+	/* If we or the target don't support tagged queuing, allocate the LUN for
+	 * an untagged command.
+	 */
+	if (!should_be_tagged ||
+	    !setup_use_tagged_queuing || !cmd->device->tagged_supported) {
+		cmd->tag = TAG_NONE;
+		hostdata->busy[cmd->device->id] |= (1 << cmd->device->lun);
+		TAG_PRINTK("scsi%d: target %d lun %d now allocated by untagged "
+			   "command\n", H_NO(cmd), cmd->device->id, cmd->device->lun);
+	} else {
+		TAG_ALLOC *ta = &TagAlloc[cmd->device->id][cmd->device->lun];
+
+		cmd->tag = find_first_zero_bit(ta->allocated, MAX_TAGS);
+		set_bit(cmd->tag, ta->allocated);
+		ta->nr_allocated++;
+		TAG_PRINTK("scsi%d: using tag %d for target %d lun %d "
+			   "(now %d tags in use)\n",
+			   H_NO(cmd), cmd->tag, cmd->device->id,
+			   cmd->device->lun, ta->nr_allocated);
+	}
@@ -409 +417 @@
-static void cmd_free_tag( Scsi_Cmnd *cmd )
+static void cmd_free_tag(Scsi_Cmnd *cmd)
@@ -411 +419 @@
-    SETUP_HOSTDATA(cmd->device->host);
+	SETUP_HOSTDATA(cmd->device->host);
@@ -413,16 +421,14 @@
-    if (cmd->tag == TAG_NONE) {
-	hostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);
-	TAG_PRINTK( "scsi%d: target %d lun %d untagged cmd finished\n",
-		    H_NO(cmd), cmd->device->id, cmd->device->lun );
-    }
-    else if (cmd->tag >= MAX_TAGS) {
-	printk(KERN_NOTICE "scsi%d: trying to free bad tag %d!\n",
-		H_NO(cmd), cmd->tag );
-    }
-    else {
-	TAG_ALLOC *ta = &TagAlloc[cmd->device->id][cmd->device->lun];
-	clear_bit( cmd->tag, ta->allocated );
-	ta->nr_allocated--;
-	TAG_PRINTK( "scsi%d: freed tag %d for target %d lun %d\n",
-		    H_NO(cmd), cmd->tag, cmd->device->id, cmd->device->lun );
-    }
+	if (cmd->tag == TAG_NONE) {
+		hostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);
+		TAG_PRINTK("scsi%d: target %d lun %d untagged cmd finished\n",
+			   H_NO(cmd), cmd->device->id, cmd->device->lun);
+	} else if (cmd->tag >= MAX_TAGS) {
+		printk(KERN_NOTICE "scsi%d: trying to free bad tag %d!\n",
+		       H_NO(cmd), cmd->tag);
+	} else {
+		TAG_ALLOC *ta = &TagAlloc[cmd->device->id][cmd->device->lun];
+		clear_bit(cmd->tag, ta->allocated);
+		ta->nr_allocated--;
+		TAG_PRINTK("scsi%d: freed tag %d for target %d lun %d\n",
+			   H_NO(cmd), cmd->tag, cmd->device->id, cmd->device->lun);
+	}
@@ -432,13 +438,14 @@
-static void free_all_tags( void )
-{
-    int target, lun;
-    TAG_ALLOC *ta;
-
-    if (!setup_use_tagged_queuing)
-	return;
-    
-    for( target = 0; target < 8; ++target ) {
-	for( lun = 0; lun < 8; ++lun ) {
-	    ta = &TagAlloc[target][lun];
-	    bitmap_zero(ta->allocated, MAX_TAGS);
-	    ta->nr_allocated = 0;
+static void free_all_tags(void)
+{
+	int target, lun;
+	TAG_ALLOC *ta;
+
+	if (!setup_use_tagged_queuing)
+		return;
+
+	for (target = 0; target < 8; ++target) {
+		for (lun = 0; lun < 8; ++lun) {
+			ta = &TagAlloc[target][lun];
+			bitmap_zero(ta->allocated, MAX_TAGS);
+			ta->nr_allocated = 0;
+		}
@@ -446 +452,0 @@
-    }
@@ -464 +470 @@
-static void merge_contiguous_buffers( Scsi_Cmnd *cmd )
+static void merge_contiguous_buffers(Scsi_Cmnd *cmd)
@@ -466 +472 @@
-    unsigned long endaddr;
+	unsigned long endaddr;
@@ -468,2 +474,2 @@
-    unsigned long oldlen = cmd->SCp.this_residual;
-    int		  cnt = 1;
+	unsigned long oldlen = cmd->SCp.this_residual;
+	int cnt = 1;
@@ -472,6 +478,6 @@
-    for (endaddr = virt_to_phys(cmd->SCp.ptr + cmd->SCp.this_residual - 1) + 1;
-	 cmd->SCp.buffers_residual &&
-	 virt_to_phys(page_address(cmd->SCp.buffer[1].page)+
-		      cmd->SCp.buffer[1].offset) == endaddr; ) {
-	MER_PRINTK("VTOP(%p) == %08lx -> merging\n",
-		   cmd->SCp.buffer[1].address, endaddr);
+	for (endaddr = virt_to_phys(cmd->SCp.ptr + cmd->SCp.this_residual - 1) + 1;
+	     cmd->SCp.buffers_residual &&
+	     virt_to_phys(page_address(cmd->SCp.buffer[1].page) +
+			  cmd->SCp.buffer[1].offset) == endaddr;) {
+		MER_PRINTK("VTOP(%p) == %08lx -> merging\n",
+			   page_address(cmd->SCp.buffer[1].page), endaddr);
@@ -479 +485 @@
-	++cnt;
+		++cnt;
@@ -481,5 +487,5 @@
-	++cmd->SCp.buffer;
-	--cmd->SCp.buffers_residual;
-	cmd->SCp.this_residual += cmd->SCp.buffer->length;
-	endaddr += cmd->SCp.buffer->length;
-    }
+		++cmd->SCp.buffer;
+		--cmd->SCp.buffers_residual;
+		cmd->SCp.this_residual += cmd->SCp.buffer->length;
+		endaddr += cmd->SCp.buffer->length;
+	}
@@ -487,3 +493,3 @@
-    if (oldlen != cmd->SCp.this_residual)
-	MER_PRINTK("merged %d buffers from %p, new length %08x\n",
-		   cnt, cmd->SCp.ptr, cmd->SCp.this_residual);
+	if (oldlen != cmd->SCp.this_residual)
+		MER_PRINTK("merged %d buffers from %p, new length %08x\n",
+			   cnt, cmd->SCp.ptr, cmd->SCp.this_residual);
@@ -496 +502 @@
- * Purpose : initialize the saved data pointers for cmd to point to the 
+ * Purpose : initialize the saved data pointers for cmd to point to the
@@ -502 +508 @@
-static __inline__ void initialize_SCp(Scsi_Cmnd *cmd)
+static inline void initialize_SCp(Scsi_Cmnd *cmd)
@@ -504,21 +510,21 @@
-    /* 
-     * Initialize the Scsi Pointer field so that all of the commands in the 
-     * various queues are valid.
-     */
-
-    if (cmd->use_sg) {
-	cmd->SCp.buffer = (struct scatterlist *) cmd->request_buffer;
-	cmd->SCp.buffers_residual = cmd->use_sg - 1;
-	cmd->SCp.ptr = (char *)page_address(cmd->SCp.buffer->page)+
-		       cmd->SCp.buffer->offset;
-	cmd->SCp.this_residual = cmd->SCp.buffer->length;
-	/* ++roman: Try to merge some scatter-buffers if they are at
-	 * contiguous physical addresses.
-	 */
-	merge_contiguous_buffers( cmd );
-    } else {
-	cmd->SCp.buffer = NULL;
-	cmd->SCp.buffers_residual = 0;
-	cmd->SCp.ptr = (char *) cmd->request_buffer;
-	cmd->SCp.this_residual = cmd->request_bufflen;
-    }
+	/*
+	 * Initialize the Scsi Pointer field so that all of the commands in the
+	 * various queues are valid.
+	 */
+
+	if (cmd->use_sg) {
+		cmd->SCp.buffer = (struct scatterlist *)cmd->request_buffer;
+		cmd->SCp.buffers_residual = cmd->use_sg - 1;
+		cmd->SCp.ptr = (char *)page_address(cmd->SCp.buffer->page) +
+			       cmd->SCp.buffer->offset;
+		cmd->SCp.this_residual = cmd->SCp.buffer->length;
+		/* ++roman: Try to merge some scatter-buffers if they are at
+		 * contiguous physical addresses.
+		 */
+		merge_contiguous_buffers(cmd);
+	} else {
+		cmd->SCp.buffer = NULL;
+		cmd->SCp.buffers_residual = 0;
+		cmd->SCp.ptr = (char *)cmd->request_buffer;
+		cmd->SCp.this_residual = cmd->request_bufflen;
+	}
@@ -531,16 +537,21 @@
-    unsigned char mask;
-    const char * name;} 
-signals[] = {{ SR_DBP, "PARITY"}, { SR_RST, "RST" }, { SR_BSY, "BSY" }, 
-    { SR_REQ, "REQ" }, { SR_MSG, "MSG" }, { SR_CD,  "CD" }, { SR_IO, "IO" }, 
-    { SR_SEL, "SEL" }, {0, NULL}}, 
-basrs[] = {{BASR_ATN, "ATN"}, {BASR_ACK, "ACK"}, {0, NULL}},
-icrs[] = {{ICR_ASSERT_RST, "ASSERT RST"},{ICR_ASSERT_ACK, "ASSERT ACK"},
-    {ICR_ASSERT_BSY, "ASSERT BSY"}, {ICR_ASSERT_SEL, "ASSERT SEL"}, 
-    {ICR_ASSERT_ATN, "ASSERT ATN"}, {ICR_ASSERT_DATA, "ASSERT DATA"}, 
-    {0, NULL}},
-mrs[] = {{MR_BLOCK_DMA_MODE, "MODE BLOCK DMA"}, {MR_TARGET, "MODE TARGET"}, 
-    {MR_ENABLE_PAR_CHECK, "MODE PARITY CHECK"}, {MR_ENABLE_PAR_INTR, 
-    "MODE PARITY INTR"}, {MR_ENABLE_EOP_INTR,"MODE EOP INTR"},
-    {MR_MONITOR_BSY, "MODE MONITOR BSY"},
-    {MR_DMA_MODE, "MODE DMA"}, {MR_ARBITRATE, "MODE ARBITRATION"}, 
-    {0, NULL}};
+	unsigned char mask;
+	const char *name;
+} signals[] = {
+	{ SR_DBP, "PARITY"}, { SR_RST, "RST" }, { SR_BSY, "BSY" },
+	{ SR_REQ, "REQ" }, { SR_MSG, "MSG" }, { SR_CD,  "CD" }, { SR_IO, "IO" },
+	{ SR_SEL, "SEL" }, {0, NULL}
+}, basrs[] = {
+	{BASR_ATN, "ATN"}, {BASR_ACK, "ACK"}, {0, NULL}
+}, icrs[] = {
+	{ICR_ASSERT_RST, "ASSERT RST"},{ICR_ASSERT_ACK, "ASSERT ACK"},
+	{ICR_ASSERT_BSY, "ASSERT BSY"}, {ICR_ASSERT_SEL, "ASSERT SEL"},
+	{ICR_ASSERT_ATN, "ASSERT ATN"}, {ICR_ASSERT_DATA, "ASSERT DATA"},
+	{0, NULL}
+}, mrs[] = {
+	{MR_BLOCK_DMA_MODE, "MODE BLOCK DMA"}, {MR_TARGET, "MODE TARGET"},
+	{MR_ENABLE_PAR_CHECK, "MODE PARITY CHECK"}, {MR_ENABLE_PAR_INTR,
+	"MODE PARITY INTR"}, {MR_ENABLE_EOP_INTR,"MODE EOP INTR"},
+	{MR_MONITOR_BSY, "MODE MONITOR BSY"},
+	{MR_DMA_MODE, "MODE DMA"}, {MR_ARBITRATE, "MODE ARBITRATION"},
+	{0, NULL}
+};
@@ -556,28 +567,29 @@
-static void NCR5380_print(struct Scsi_Host *instance) {
-    unsigned char status, data, basr, mr, icr, i;
-    unsigned long flags;
-
-    local_irq_save(flags);
-    data = NCR5380_read(CURRENT_SCSI_DATA_REG);
-    status = NCR5380_read(STATUS_REG);
-    mr = NCR5380_read(MODE_REG);
-    icr = NCR5380_read(INITIATOR_COMMAND_REG);
-    basr = NCR5380_read(BUS_AND_STATUS_REG);
-    local_irq_restore(flags);
-    printk("STATUS_REG: %02x ", status);
-    for (i = 0; signals[i].mask ; ++i) 
-	if (status & signals[i].mask)
-	    printk(",%s", signals[i].name);
-    printk("\nBASR: %02x ", basr);
-    for (i = 0; basrs[i].mask ; ++i) 
-	if (basr & basrs[i].mask)
-	    printk(",%s", basrs[i].name);
-    printk("\nICR: %02x ", icr);
-    for (i = 0; icrs[i].mask; ++i) 
-	if (icr & icrs[i].mask)
-	    printk(",%s", icrs[i].name);
-    printk("\nMODE: %02x ", mr);
-    for (i = 0; mrs[i].mask; ++i) 
-	if (mr & mrs[i].mask)
-	    printk(",%s", mrs[i].name);
-    printk("\n");
+static void NCR5380_print(struct Scsi_Host *instance)
+{
+	unsigned char status, data, basr, mr, icr, i;
+	unsigned long flags;
+
+	local_irq_save(flags);
+	data = NCR5380_read(CURRENT_SCSI_DATA_REG);
+	status = NCR5380_read(STATUS_REG);
+	mr = NCR5380_read(MODE_REG);
+	icr = NCR5380_read(INITIATOR_COMMAND_REG);
+	basr = NCR5380_read(BUS_AND_STATUS_REG);
+	local_irq_restore(flags);
+	printk("STATUS_REG: %02x ", status);
+	for (i = 0; signals[i].mask; ++i)
+		if (status & signals[i].mask)
+			printk(",%s", signals[i].name);
+	printk("\nBASR: %02x ", basr);
+	for (i = 0; basrs[i].mask; ++i)
+		if (basr & basrs[i].mask)
+			printk(",%s", basrs[i].name);
+	printk("\nICR: %02x ", icr);
+	for (i = 0; icrs[i].mask; ++i)
+		if (icr & icrs[i].mask)
+			printk(",%s", icrs[i].name);
+	printk("\nMODE: %02x ", mr);
+	for (i = 0; mrs[i].mask; ++i)
+		if (mr & mrs[i].mask)
+			printk(",%s", mrs[i].name);
+	printk("\n");
@@ -587,2 +599,2 @@
-    unsigned char value;
-    const char *name;
+	unsigned char value;
+	const char *name;
@@ -590,3 +602,4 @@
-    {PHASE_DATAOUT, "DATAOUT"}, {PHASE_DATAIN, "DATAIN"}, {PHASE_CMDOUT, "CMDOUT"},
-    {PHASE_STATIN, "STATIN"}, {PHASE_MSGOUT, "MSGOUT"}, {PHASE_MSGIN, "MSGIN"},
-    {PHASE_UNKNOWN, "UNKNOWN"}};
+	{PHASE_DATAOUT, "DATAOUT"}, {PHASE_DATAIN, "DATAIN"}, {PHASE_CMDOUT, "CMDOUT"},
+	{PHASE_STATIN, "STATIN"}, {PHASE_MSGOUT, "MSGOUT"}, {PHASE_MSGIN, "MSGIN"},
+	{PHASE_UNKNOWN, "UNKNOWN"}
+};
@@ -594 +607 @@
-/* 
+/*
@@ -604,2 +617,2 @@
-    unsigned char status;
-    int i;
+	unsigned char status;
+	int i;
@@ -607,8 +620,9 @@
-    status = NCR5380_read(STATUS_REG);
-    if (!(status & SR_REQ)) 
-	printk(KERN_DEBUG "scsi%d: REQ not asserted, phase unknown.\n", HOSTNO);
-    else {
-	for (i = 0; (phases[i].value != PHASE_UNKNOWN) && 
-	    (phases[i].value != (status & PHASE_MASK)); ++i); 
-	printk(KERN_DEBUG "scsi%d: phase %s\n", HOSTNO, phases[i].name);
-    }
+	status = NCR5380_read(STATUS_REG);
+	if (!(status & SR_REQ))
+		printk(KERN_DEBUG "scsi%d: REQ not asserted, phase unknown.\n", HOSTNO);
+	else {
+		for (i = 0; (phases[i].value != PHASE_UNKNOWN) &&
+		     (phases[i].value != (status & PHASE_MASK)); ++i)
+			;
+		printk(KERN_DEBUG "scsi%d: phase %s\n", HOSTNO, phases[i].name);
+	}
@@ -620,2 +634,6 @@
-__inline__ void NCR5380_print(struct Scsi_Host *instance) { };
-__inline__ void NCR5380_print_phase(struct Scsi_Host *instance) { };
+static inline void NCR5380_print(struct Scsi_Host *instance)
+{
+};
+static inline void NCR5380_print_phase(struct Scsi_Host *instance)
+{
+};
@@ -627 +645 @@
- * 
+ *
@@ -641,2 +659,2 @@
-static volatile int main_running = 0;
-static DECLARE_WORK(NCR5380_tqueue, (void (*)(void*))NCR5380_main, NULL);
+static volatile int main_running;
+static DECLARE_WORK(NCR5380_tqueue, NCR5380_main);
@@ -644 +662 @@
-static __inline__ void queue_main(void)
+static inline void queue_main(void)
@@ -646,9 +664,9 @@
-    if (!main_running) {
-	/* If in interrupt and NCR5380_main() not already running,
-	   queue it on the 'immediate' task queue, to be processed
-	   immediately after the current interrupt processing has
-	   finished. */
-	schedule_work(&NCR5380_tqueue);
-    }
-    /* else: nothing to do: the running NCR5380_main() will pick up
-       any newly queued command. */
+	if (!main_running) {
+		/* If in interrupt and NCR5380_main() not already running,
+		   queue it on the 'immediate' task queue, to be processed
+		   immediately after the current interrupt processing has
+		   finished. */
+		schedule_work(&NCR5380_tqueue);
+	}
+	/* else: nothing to do: the running NCR5380_main() will pick up
+	   any newly queued command. */
@@ -658 +676 @@
-static inline void NCR5380_all_init (void)
+static inline void NCR5380_all_init(void)
@@ -660,5 +678,5 @@
-    static int done = 0;
-    if (!done) {
-	INI_PRINTK("scsi : NCR5380_all_init()\n");
-	done = 1;
-    }
+	static int done = 0;
+	if (!done) {
+		INI_PRINTK("scsi : NCR5380_all_init()\n");
+		done = 1;
+	}
@@ -667 +685 @@
- 
+
@@ -677 +695 @@
-static void __init NCR5380_print_options (struct Scsi_Host *instance)
+static void __init NCR5380_print_options(struct Scsi_Host *instance)
@@ -679,3 +697,3 @@
-    printk(" generic options"
-#ifdef AUTOSENSE 
-    " AUTOSENSE"
+	printk(" generic options"
+#ifdef AUTOSENSE
+	       " AUTOSENSE"
@@ -684 +702 @@
-    " REAL DMA"
+	       " REAL DMA"
@@ -687 +705 @@
-    " PARITY"
+	       " PARITY"
@@ -690 +708 @@
-    " SCSI-2 TAGGED QUEUING"
+	       " SCSI-2 TAGGED QUEUING"
@@ -692,2 +710,2 @@
-    );
-    printk(" generic release=%d", NCR5380_PUBLIC_RELEASE);
+	       );
+	printk(" generic release=%d", NCR5380_PUBLIC_RELEASE);
@@ -702 +720 @@
- * Inputs : instance, pointer to this instance.  
+ * Inputs : instance, pointer to this instance.
@@ -705 +723 @@
-static void NCR5380_print_status (struct Scsi_Host *instance)
+static void NCR5380_print_status(struct Scsi_Host *instance)
@@ -707,16 +725,16 @@
-    char *pr_bfr;
-    char *start;
-    int len;
-
-    NCR_PRINT(NDEBUG_ANY);
-    NCR_PRINT_PHASE(NDEBUG_ANY);
-
-    pr_bfr = (char *) __get_free_page(GFP_ATOMIC);
-    if (!pr_bfr) {
-	printk("NCR5380_print_status: no memory for print buffer\n");
-	return;
-    }
-    len = NCR5380_proc_info(pr_bfr, &start, 0, PAGE_SIZE, HOSTNO, 0);
-    pr_bfr[len] = 0;
-    printk("\n%s\n", pr_bfr);
-    free_page((unsigned long) pr_bfr);
+	char *pr_bfr;
+	char *start;
+	int len;
+
+	NCR_PRINT(NDEBUG_ANY);
+	NCR_PRINT_PHASE(NDEBUG_ANY);
+
+	pr_bfr = (char *)__get_free_page(GFP_ATOMIC);
+	if (!pr_bfr) {
+		printk("NCR5380_print_status: no memory for print buffer\n");
+		return;
+	}
+	len = NCR5380_proc_info(instance, pr_bfr, &start, 0, PAGE_SIZE, 0);
+	pr_bfr[len] = 0;
+	printk("\n%s\n", pr_bfr);
+	free_page((unsigned long)pr_bfr);
@@ -741,42 +759,28 @@
-#define SPRINTF(fmt,args...) \
-  do { if (pos + strlen(fmt) + 20 /* slop */ < buffer + length) \
-	 pos += sprintf(pos, fmt , ## args); } while(0)
-static
-char *lprint_Scsi_Cmnd (Scsi_Cmnd *cmd, char *pos, char *buffer, int length);
-
-static
-int NCR5380_proc_info (struct Scsi_Host *instance, char *buffer, char **start, off_t offset,
-		       int length, int inout)
-{
-    char *pos = buffer;
-    struct NCR5380_hostdata *hostdata;
-    Scsi_Cmnd *ptr;
-    unsigned long flags;
-    off_t begin = 0;
-#define check_offset()				\
-    do {					\
-	if (pos - buffer < offset - begin) {	\
-	    begin += pos - buffer;		\
-	    pos = buffer;			\
-	}					\
-    } while (0)
-
-    hostdata = (struct NCR5380_hostdata *)instance->hostdata;
-
-    if (inout) { /* Has data been written to the file ? */
-	return(-ENOSYS);  /* Currently this is a no-op */
-    }
-    SPRINTF("NCR5380 core release=%d.\n", NCR5380_PUBLIC_RELEASE);
-    check_offset();
-    local_irq_save(flags);
-    SPRINTF("NCR5380: coroutine is%s running.\n", main_running ? "" : "n't");
-    check_offset();
-    if (!hostdata->connected)
-	SPRINTF("scsi%d: no currently connected command\n", HOSTNO);
-    else
-	pos = lprint_Scsi_Cmnd ((Scsi_Cmnd *) hostdata->connected,
-				pos, buffer, length);
-    SPRINTF("scsi%d: issue_queue\n", HOSTNO);
-    check_offset();
-    for (ptr = (Scsi_Cmnd *) hostdata->issue_queue; ptr; ptr = NEXT(ptr)) {
-	pos = lprint_Scsi_Cmnd (ptr, pos, buffer, length);
+#define SPRINTF(fmt,args...)							\
+	do {									\
+		if (pos + strlen(fmt) + 20 /* slop */ < buffer + length)	\
+			pos += sprintf(pos, fmt , ## args);			\
+	} while(0)
+static char *lprint_Scsi_Cmnd(Scsi_Cmnd *cmd, char *pos, char *buffer, int length);
+
+static int NCR5380_proc_info(struct Scsi_Host *instance, char *buffer,
+			     char **start, off_t offset, int length, int inout)
+{
+	char *pos = buffer;
+	struct NCR5380_hostdata *hostdata;
+	Scsi_Cmnd *ptr;
+	unsigned long flags;
+	off_t begin = 0;
+#define check_offset()					\
+	do {						\
+		if (pos - buffer < offset - begin) {	\
+			begin += pos - buffer;		\
+			pos = buffer;			\
+		}					\
+	} while (0)
+
+	hostdata = (struct NCR5380_hostdata *)instance->hostdata;
+
+	if (inout)			/* Has data been written to the file ? */
+		return -ENOSYS;		/* Currently this is a no-op */
+	SPRINTF("NCR5380 core release=%d.\n", NCR5380_PUBLIC_RELEASE);
@@ -784,7 +788,10 @@
-    }
-
-    SPRINTF("scsi%d: disconnected_queue\n", HOSTNO);
-    check_offset();
-    for (ptr = (Scsi_Cmnd *) hostdata->disconnected_queue; ptr;
-	 ptr = NEXT(ptr)) {
-	pos = lprint_Scsi_Cmnd (ptr, pos, buffer, length);
+	local_irq_save(flags);
+	SPRINTF("NCR5380: coroutine is%s running.\n",
+		main_running ? "" : "n't");
+	check_offset();
+	if (!hostdata->connected)
+		SPRINTF("scsi%d: no currently connected command\n", HOSTNO);
+	else
+		pos = lprint_Scsi_Cmnd((Scsi_Cmnd *) hostdata->connected,
+				       pos, buffer, length);
+	SPRINTF("scsi%d: issue_queue\n", HOSTNO);
@@ -792 +799,4 @@
-    }
+	for (ptr = (Scsi_Cmnd *)hostdata->issue_queue; ptr; ptr = NEXT(ptr)) {
+		pos = lprint_Scsi_Cmnd(ptr, pos, buffer, length);
+		check_offset();
+	}
@@ -794,8 +804,7 @@
-    local_irq_restore(flags);
-    *start = buffer + (offset - begin);
-    if (pos - buffer < offset - begin)
-	return 0;
-    else if (pos - buffer - (offset - begin) < length)
-	return pos - buffer - (offset - begin);
-    return length;
-}
+	SPRINTF("scsi%d: disconnected_queue\n", HOSTNO);
+	check_offset();
+	for (ptr = (Scsi_Cmnd *) hostdata->disconnected_queue; ptr;
+	     ptr = NEXT(ptr)) {
+		pos = lprint_Scsi_Cmnd(ptr, pos, buffer, length);
+		check_offset();
+	}
@@ -803,14 +812,22 @@
-static char *
-lprint_Scsi_Cmnd (Scsi_Cmnd *cmd, char *pos, char *buffer, int length)
-{
-    int i, s;
-    unsigned char *command;
-    SPRINTF("scsi%d: destination target %d, lun %d\n",
-	    H_NO(cmd), cmd->device->id, cmd->device->lun);
-    SPRINTF("        command = ");
-    command = cmd->cmnd;
-    SPRINTF("%2d (0x%02x)", command[0], command[0]);
-    for (i = 1, s = COMMAND_SIZE(command[0]); i < s; ++i)
-	SPRINTF(" %02x", command[i]);
-    SPRINTF("\n");
-    return pos;
+	local_irq_restore(flags);
+	*start = buffer + (offset - begin);
+	if (pos - buffer < offset - begin)
+		return 0;
+	else if (pos - buffer - (offset - begin) < length)
+		return pos - buffer - (offset - begin);
+	return length;
+}
+
+static char *lprint_Scsi_Cmnd(Scsi_Cmnd *cmd, char *pos, char *buffer, int length)
+{
+	int i, s;
+	unsigned char *command;
+	SPRINTF("scsi%d: destination target %d, lun %d\n",
+		H_NO(cmd), cmd->device->id, cmd->device->lun);
+	SPRINTF("        command = ");
+	command = cmd->cmnd;
+	SPRINTF("%2d (0x%02x)", command[0], command[0]);
+	for (i = 1, s = COMMAND_SIZE(command[0]); i < s; ++i)
+		SPRINTF(" %02x", command[i]);
+	SPRINTF("\n");
+	return pos;
@@ -820 +837 @@
-/* 
+/*
@@ -825 +842 @@
- * Inputs : instance - instantiation of the 5380 driver.  
+ * Inputs : instance - instantiation of the 5380 driver.
@@ -828,2 +845,2 @@
- * 	set correctly.  I don't care about the irq and other fields. 
- * 
+ *	set correctly.  I don't care about the irq and other fields.
+ *
@@ -832 +849 @@
-static int NCR5380_init (struct Scsi_Host *instance, int flags)
+static int NCR5380_init(struct Scsi_Host *instance, int flags)
@@ -834,2 +851,2 @@
-    int i;
-    SETUP_HOSTDATA(instance);
+	int i;
+	SETUP_HOSTDATA(instance);
@@ -837 +854 @@
-    NCR5380_all_init();
+	NCR5380_all_init();
@@ -839,8 +856,8 @@
-    hostdata->aborted = 0;
-    hostdata->id_mask = 1 << instance->this_id;
-    hostdata->id_higher_mask = 0;
-    for (i = hostdata->id_mask; i <= 0x80; i <<= 1)
-	if (i > hostdata->id_mask)
-	    hostdata->id_higher_mask |= i;
-    for (i = 0; i < 8; ++i)
-	hostdata->busy[i] = 0;
+	hostdata->aborted = 0;
+	hostdata->id_mask = 1 << instance->this_id;
+	hostdata->id_higher_mask = 0;
+	for (i = hostdata->id_mask; i <= 0x80; i <<= 1)
+		if (i > hostdata->id_mask)
+			hostdata->id_higher_mask |= i;
+	for (i = 0; i < 8; ++i)
+		hostdata->busy[i] = 0;
@@ -848 +865 @@
-    init_tags();
+	init_tags();
@@ -851 +868 @@
-    hostdata->dma_len = 0;
+	hostdata->dma_len = 0;
@@ -853,11 +870,10 @@
-    hostdata->targets_present = 0;
-    hostdata->connected = NULL;
-    hostdata->issue_queue = NULL;
-    hostdata->disconnected_queue = NULL;
-    hostdata->flags = FLAG_CHECK_LAST_BYTE_SENT;
-
-    if (!the_template) {
-	the_template = instance->hostt;
-	first_instance = instance;
-    }
-	
+	hostdata->targets_present = 0;
+	hostdata->connected = NULL;
+	hostdata->issue_queue = NULL;
+	hostdata->disconnected_queue = NULL;
+	hostdata->flags = FLAG_CHECK_LAST_BYTE_SENT;
+
+	if (!the_template) {
+		the_template = instance->hostt;
+		first_instance = instance;
+	}
@@ -866,4 +882,4 @@
-    if ((instance->cmd_per_lun > 1) || (instance->can_queue > 1))
-	 printk("scsi%d: WARNING : support for multiple outstanding commands enabled\n"
-	        "        without AUTOSENSE option, contingent allegiance conditions may\n"
-	        "        be incorrectly cleared.\n", HOSTNO);
+	if ((instance->cmd_per_lun > 1) || (instance->can_queue > 1))
+		printk("scsi%d: WARNING : support for multiple outstanding commands enabled\n"
+		       "        without AUTOSENSE option, contingent allegiance conditions may\n"
+		       "        be incorrectly cleared.\n", HOSTNO);
@@ -872,4 +888,4 @@
-    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-    NCR5380_write(MODE_REG, MR_BASE);
-    NCR5380_write(TARGET_COMMAND_REG, 0);
-    NCR5380_write(SELECT_ENABLE_REG, 0);
+	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+	NCR5380_write(MODE_REG, MR_BASE);
+	NCR5380_write(TARGET_COMMAND_REG, 0);
+	NCR5380_write(SELECT_ENABLE_REG, 0);
@@ -877 +893 @@
-    return 0;
+	return 0;
@@ -880,3 +896,3 @@
-/* 
- * Function : int NCR5380_queue_command (Scsi_Cmnd *cmd, 
- *	void (*done)(Scsi_Cmnd *)) 
+/*
+ * Function : int NCR5380_queue_command (Scsi_Cmnd *cmd,
+ *	void (*done)(Scsi_Cmnd *))
@@ -888 +904 @@
- * 
+ *
@@ -891,3 +907,3 @@
- * Side effects : 
- *      cmd is added to the per instance issue_queue, with minor 
- *	twiddling done to the host specific fields of cmd.  If the 
+ * Side effects :
+ *      cmd is added to the per instance issue_queue, with minor
+ *	twiddling done to the host specific fields of cmd.  If the
@@ -898,2 +914 @@
-static
-int NCR5380_queue_command (Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
+static int NCR5380_queue_command(Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
@@ -901,5 +916,4 @@
-    SETUP_HOSTDATA(cmd->device->host);
-    Scsi_Cmnd *tmp;
-    int oldto;
-    unsigned long flags;
-    extern int update_timeout(Scsi_Cmnd * SCset, int timeout);
+	SETUP_HOSTDATA(cmd->device->host);
+	Scsi_Cmnd *tmp;
+	int oldto;
+	unsigned long flags;
@@ -908,9 +922,9 @@
-    switch (cmd->cmnd[0]) {
-    case WRITE_6:
-    case WRITE_10:
-	printk(KERN_NOTICE "scsi%d: WRITE attempted with NO_WRITE debugging flag set\n",
-	       H_NO(cmd));
-	cmd->result = (DID_ERROR << 16);
-	done(cmd);
-	return 0;
-    }
+	switch (cmd->cmnd[0]) {
+	case WRITE_6:
+	case WRITE_10:
+		printk(KERN_NOTICE "scsi%d: WRITE attempted with NO_WRITE debugging flag set\n",
+		       H_NO(cmd));
+		cmd->result = (DID_ERROR << 16);
+		done(cmd);
+		return 0;
+	}
@@ -919 +932,0 @@
-
@@ -922,4 +935,4 @@
-    if (!hostdata->connected && !hostdata->issue_queue &&
-	!hostdata->disconnected_queue) {
-	hostdata->timebase = jiffies;
-    }
+	if (!hostdata->connected && !hostdata->issue_queue &&
+	    !hostdata->disconnected_queue) {
+		hostdata->timebase = jiffies;
+	}
@@ -928 +941 @@
-    if (cmd->request_bufflen > NCR5380_STAT_LIMIT)
+	if (cmd->request_bufflen > NCR5380_STAT_LIMIT)
@@ -930,91 +943,89 @@
-	switch (cmd->cmnd[0])
-	{
-	    case WRITE:
-	    case WRITE_6:
-	    case WRITE_10:
-		hostdata->time_write[cmd->device->id] -= (jiffies - hostdata->timebase);
-		hostdata->bytes_write[cmd->device->id] += cmd->request_bufflen;
-		hostdata->pendingw++;
-		break;
-	    case READ:
-	    case READ_6:
-	    case READ_10:
-		hostdata->time_read[cmd->device->id] -= (jiffies - hostdata->timebase);
-		hostdata->bytes_read[cmd->device->id] += cmd->request_bufflen;
-		hostdata->pendingr++;
-		break;
-	}
-#endif
-
-    /* 
-     * We use the host_scribble field as a pointer to the next command  
-     * in a queue 
-     */
-
-    NEXT(cmd) = NULL;
-    cmd->scsi_done = done;
-
-    cmd->result = 0;
-
-
-    /* 
-     * Insert the cmd into the issue queue. Note that REQUEST SENSE 
-     * commands are added to the head of the queue since any command will
-     * clear the contingent allegiance condition that exists and the 
-     * sense data is only guaranteed to be valid while the condition exists.
-     */
-
-    local_irq_save(flags);
-    /* ++guenther: now that the issue queue is being set up, we can lock ST-DMA.
-     * Otherwise a running NCR5380_main may steal the lock.
-     * Lock before actually inserting due to fairness reasons explained in
-     * atari_scsi.c. If we insert first, then it's impossible for this driver
-     * to release the lock.
-     * Stop timer for this command while waiting for the lock, or timeouts
-     * may happen (and they really do), and it's no good if the command doesn't
-     * appear in any of the queues.
-     * ++roman: Just disabling the NCR interrupt isn't sufficient here,
-     * because also a timer int can trigger an abort or reset, which would
-     * alter queues and touch the lock.
-     */
-    if (!IS_A_TT()) {
-	oldto = update_timeout(cmd, 0);
-	falcon_get_lock();
-	update_timeout(cmd, oldto);
-    }
-    if (!(hostdata->issue_queue) || (cmd->cmnd[0] == REQUEST_SENSE)) {
-	LIST(cmd, hostdata->issue_queue);
-	NEXT(cmd) = hostdata->issue_queue;
-	hostdata->issue_queue = cmd;
-    } else {
-	for (tmp = (Scsi_Cmnd *)hostdata->issue_queue;
-	     NEXT(tmp); tmp = NEXT(tmp))
-	    ;
-	LIST(cmd, tmp);
-	NEXT(tmp) = cmd;
-    }
-    local_irq_restore(flags);
-
-    QU_PRINTK("scsi%d: command added to %s of queue\n", H_NO(cmd),
-	      (cmd->cmnd[0] == REQUEST_SENSE) ? "head" : "tail");
-
-    /* If queue_command() is called from an interrupt (real one or bottom
-     * half), we let queue_main() do the job of taking care about main. If it
-     * is already running, this is a no-op, else main will be queued.
-     *
-     * If we're not in an interrupt, we can call NCR5380_main()
-     * unconditionally, because it cannot be already running.
-     */
-    if (in_interrupt() || ((flags >> 8) & 7) >= 6)
-	queue_main();
-    else
-	NCR5380_main(NULL);
-    return 0;
-}
-
-/*
- * Function : NCR5380_main (void) 
- *
- * Purpose : NCR5380_main is a coroutine that runs as long as more work can 
- *	be done on the NCR5380 host adapters in a system.  Both 
- *	NCR5380_queue_command() and NCR5380_intr() will try to start it 
+		switch (cmd->cmnd[0]) {
+		case WRITE:
+		case WRITE_6:
+		case WRITE_10:
+			hostdata->time_write[cmd->device->id] -= (jiffies - hostdata->timebase);
+			hostdata->bytes_write[cmd->device->id] += cmd->request_bufflen;
+			hostdata->pendingw++;
+			break;
+		case READ:
+		case READ_6:
+		case READ_10:
+			hostdata->time_read[cmd->device->id] -= (jiffies - hostdata->timebase);
+			hostdata->bytes_read[cmd->device->id] += cmd->request_bufflen;
+			hostdata->pendingr++;
+			break;
+		}
+#endif
+
+	/*
+	 * We use the host_scribble field as a pointer to the next command
+	 * in a queue
+	 */
+
+	SET_NEXT(cmd, NULL);
+	cmd->scsi_done = done;
+
+	cmd->result = 0;
+
+	/*
+	 * Insert the cmd into the issue queue. Note that REQUEST SENSE
+	 * commands are added to the head of the queue since any command will
+	 * clear the contingent allegiance condition that exists and the
+	 * sense data is only guaranteed to be valid while the condition exists.
+	 */
+
+	local_irq_save(flags);
+	/* ++guenther: now that the issue queue is being set up, we can lock ST-DMA.
+	 * Otherwise a running NCR5380_main may steal the lock.
+	 * Lock before actually inserting due to fairness reasons explained in
+	 * atari_scsi.c. If we insert first, then it's impossible for this driver
+	 * to release the lock.
+	 * Stop timer for this command while waiting for the lock, or timeouts
+	 * may happen (and they really do), and it's no good if the command doesn't
+	 * appear in any of the queues.
+	 * ++roman: Just disabling the NCR interrupt isn't sufficient here,
+	 * because also a timer int can trigger an abort or reset, which would
+	 * alter queues and touch the lock.
+	 */
+	if (!IS_A_TT()) {
+		/* perhaps stop command timer here */
+		falcon_get_lock();
+		/* perhaps restart command timer here */
+	}
+	if (!(hostdata->issue_queue) || (cmd->cmnd[0] == REQUEST_SENSE)) {
+		LIST(cmd, hostdata->issue_queue);
+		SET_NEXT(cmd, hostdata->issue_queue);
+		hostdata->issue_queue = cmd;
+	} else {
+		for (tmp = (Scsi_Cmnd *)hostdata->issue_queue;
+		     NEXT(tmp); tmp = NEXT(tmp))
+			;
+		LIST(cmd, tmp);
+		SET_NEXT(tmp, cmd);
+	}
+	local_irq_restore(flags);
+
+	QU_PRINTK("scsi%d: command added to %s of queue\n", H_NO(cmd),
+		  (cmd->cmnd[0] == REQUEST_SENSE) ? "head" : "tail");
+
+	/* If queue_command() is called from an interrupt (real one or bottom
+	 * half), we let queue_main() do the job of taking care about main. If it
+	 * is already running, this is a no-op, else main will be queued.
+	 *
+	 * If we're not in an interrupt, we can call NCR5380_main()
+	 * unconditionally, because it cannot be already running.
+	 */
+	if (in_interrupt() || ((flags >> 8) & 7) >= 6)
+		queue_main();
+	else
+		NCR5380_main(NULL);
+	return 0;
+}
+
+/*
+ * Function : NCR5380_main (void)
+ *
+ * Purpose : NCR5380_main is a coroutine that runs as long as more work can
+ *	be done on the NCR5380 host adapters in a system.  Both
+ *	NCR5380_queue_command() and NCR5380_intr() will try to start it
@@ -1022,2 +1033,2 @@
- * 
- * NOTE : NCR5380_main exits with interrupts *disabled*, the caller should 
+ *
+ * NOTE : NCR5380_main exits with interrupts *disabled*, the caller should
@@ -1025,46 +1036,46 @@
- */ 	
-    
-static void NCR5380_main (void *bl)
-{
-    Scsi_Cmnd *tmp, *prev;
-    struct Scsi_Host *instance = first_instance;
-    struct NCR5380_hostdata *hostdata = HOSTDATA(instance);
-    int done;
-    unsigned long flags;
-    
-    /*
-     * We run (with interrupts disabled) until we're sure that none of 
-     * the host adapters have anything that can be done, at which point 
-     * we set main_running to 0 and exit.
-     *
-     * Interrupts are enabled before doing various other internal 
-     * instructions, after we've decided that we need to run through
-     * the loop again.
-     *
-     * this should prevent any race conditions.
-     * 
-     * ++roman: Just disabling the NCR interrupt isn't sufficient here,
-     * because also a timer int can trigger an abort or reset, which can
-     * alter queues and touch the Falcon lock.
-     */
-
-    /* Tell int handlers main() is now already executing.  Note that
-       no races are possible here. If an int comes in before
-       'main_running' is set here, and queues/executes main via the
-       task queue, it doesn't do any harm, just this instance of main
-       won't find any work left to do. */
-    if (main_running)
-    	return;
-    main_running = 1;
-
-    local_save_flags(flags);
-    do {
-	local_irq_disable(); /* Freeze request queues */
-	done = 1;
-	
-	if (!hostdata->connected) {
-	    MAIN_PRINTK( "scsi%d: not connected\n", HOSTNO );
-	    /*
-	     * Search through the issue_queue for a command destined
-	     * for a target that's not busy.
-	     */
+ */
+
+static void NCR5380_main(struct work_struct *work)
+{
+	Scsi_Cmnd *tmp, *prev;
+	struct Scsi_Host *instance = first_instance;
+	struct NCR5380_hostdata *hostdata = HOSTDATA(instance);
+	int done;
+	unsigned long flags;
+
+	/*
+	 * We run (with interrupts disabled) until we're sure that none of
+	 * the host adapters have anything that can be done, at which point
+	 * we set main_running to 0 and exit.
+	 *
+	 * Interrupts are enabled before doing various other internal
+	 * instructions, after we've decided that we need to run through
+	 * the loop again.
+	 *
+	 * this should prevent any race conditions.
+	 *
+	 * ++roman: Just disabling the NCR interrupt isn't sufficient here,
+	 * because also a timer int can trigger an abort or reset, which can
+	 * alter queues and touch the Falcon lock.
+	 */
+
+	/* Tell int handlers main() is now already executing.  Note that
+	   no races are possible here. If an int comes in before
+	   'main_running' is set here, and queues/executes main via the
+	   task queue, it doesn't do any harm, just this instance of main
+	   won't find any work left to do. */
+	if (main_running)
+		return;
+	main_running = 1;
+
+	local_save_flags(flags);
+	do {
+		local_irq_disable();	/* Freeze request queues */
+		done = 1;
+
+		if (!hostdata->connected) {
+			MAIN_PRINTK("scsi%d: not connected\n", HOSTNO);
+			/*
+			 * Search through the issue_queue for a command destined
+			 * for a target that's not busy.
+			 */
@@ -1072,5 +1083,7 @@
-	    for (tmp = (Scsi_Cmnd *) hostdata->issue_queue, prev = NULL;
-		 tmp && (tmp != prev); prev = tmp, tmp = NEXT(tmp))
-		;
-		/*printk("%p  ", tmp);*/
-	    if ((tmp == prev) && tmp) printk(" LOOP\n");/* else printk("\n");*/
+			for (tmp = (Scsi_Cmnd *) hostdata->issue_queue, prev = NULL;
+			     tmp && (tmp != prev); prev = tmp, tmp = NEXT(tmp))
+				;
+			/*printk("%p  ", tmp);*/
+			if ((tmp == prev) && tmp)
+				printk(" LOOP\n");
+			/* else printk("\n"); */
@@ -1078,2 +1091,2 @@
-	    for (tmp = (Scsi_Cmnd *) hostdata->issue_queue, 
-		 prev = NULL; tmp; prev = tmp, tmp = NEXT(tmp) ) {
+			for (tmp = (Scsi_Cmnd *) hostdata->issue_queue,
+			     prev = NULL; tmp; prev = tmp, tmp = NEXT(tmp)) {
@@ -1082,8 +1095,8 @@
-		if (prev != tmp)
-		    printk("MAIN tmp=%p   target=%d   busy=%d lun=%d\n",
-			   tmp, tmp->device->id, hostdata->busy[tmp->device->id],
-			   tmp->device->lun);
-#endif
-		/*  When we find one, remove it from the issue queue. */
-		/* ++guenther: possible race with Falcon locking */
-		if (
+				if (prev != tmp)
+					printk("MAIN tmp=%p   target=%d   busy=%d lun=%d\n",
+					       tmp, tmp->device->id, hostdata->busy[tmp->device->id],
+					       tmp->device->lun);
+#endif
+				/*  When we find one, remove it from the issue queue. */
+				/* ++guenther: possible race with Falcon locking */
+				if (
@@ -1091 +1104 @@
-		    !is_lun_busy( tmp, tmp->cmnd[0] != REQUEST_SENSE)
+				    !is_lun_busy( tmp, tmp->cmnd[0] != REQUEST_SENSE)
@@ -1093 +1106 @@
-		    !(hostdata->busy[tmp->device->id] & (1 << tmp->device->lun))
+				    !(hostdata->busy[tmp->device->id] & (1 << tmp->device->lun))
@@ -1095,35 +1108,35 @@
-		    ) {
-		    /* ++guenther: just to be sure, this must be atomic */
-		    local_irq_disable();
-		    if (prev) {
-		        REMOVE(prev, NEXT(prev), tmp, NEXT(tmp));
-			NEXT(prev) = NEXT(tmp);
-		    } else {
-		        REMOVE(-1, hostdata->issue_queue, tmp, NEXT(tmp));
-			hostdata->issue_queue = NEXT(tmp);
-		    }
-		    NEXT(tmp) = NULL;
-		    falcon_dont_release++;
-		    
-		    /* reenable interrupts after finding one */
-		    local_irq_restore(flags);
-		    
-		    /* 
-		     * Attempt to establish an I_T_L nexus here. 
-		     * On success, instance->hostdata->connected is set.
-		     * On failure, we must add the command back to the
-		     *   issue queue so we can keep trying.	
-		     */
-		    MAIN_PRINTK("scsi%d: main(): command for target %d "
-				"lun %d removed from issue_queue\n",
-				HOSTNO, tmp->device->id, tmp->device->lun);
-		    /* 
-		     * REQUEST SENSE commands are issued without tagged
-		     * queueing, even on SCSI-II devices because the 
-		     * contingent allegiance condition exists for the 
-		     * entire unit.
-		     */
-		    /* ++roman: ...and the standard also requires that
-		     * REQUEST SENSE command are untagged.
-		     */
-		    
+				    ) {
+					/* ++guenther: just to be sure, this must be atomic */
+					local_irq_disable();
+					if (prev) {
+						REMOVE(prev, NEXT(prev), tmp, NEXT(tmp));
+						SET_NEXT(prev, NEXT(tmp));
+					} else {
+						REMOVE(-1, hostdata->issue_queue, tmp, NEXT(tmp));
+						hostdata->issue_queue = NEXT(tmp);
+					}
+					SET_NEXT(tmp, NULL);
+					falcon_dont_release++;
+
+					/* reenable interrupts after finding one */
+					local_irq_restore(flags);
+
+					/*
+					 * Attempt to establish an I_T_L nexus here.
+					 * On success, instance->hostdata->connected is set.
+					 * On failure, we must add the command back to the
+					 *   issue queue so we can keep trying.
+					 */
+					MAIN_PRINTK("scsi%d: main(): command for target %d "
+						    "lun %d removed from issue_queue\n",
+						    HOSTNO, tmp->device->id, tmp->device->lun);
+					/*
+					 * REQUEST SENSE commands are issued without tagged
+					 * queueing, even on SCSI-II devices because the
+					 * contingent allegiance condition exists for the
+					 * entire unit.
+					 */
+					/* ++roman: ...and the standard also requires that
+					 * REQUEST SENSE command are untagged.
+					 */
+
@@ -1131 +1144 @@
-		    cmd_get_tag( tmp, tmp->cmnd[0] != REQUEST_SENSE );
+					cmd_get_tag(tmp, tmp->cmnd[0] != REQUEST_SENSE);
@@ -1133,12 +1146,12 @@
-		    if (!NCR5380_select(instance, tmp, 
-			    (tmp->cmnd[0] == REQUEST_SENSE) ? TAG_NONE : 
-			    TAG_NEXT)) {
-			falcon_dont_release--;
-			/* release if target did not response! */
-			falcon_release_lock_if_possible( hostdata );
-			break;
-		    } else {
-			local_irq_disable();
-			LIST(tmp, hostdata->issue_queue);
-			NEXT(tmp) = hostdata->issue_queue;
-			hostdata->issue_queue = tmp;
+					if (!NCR5380_select(instance, tmp,
+					    (tmp->cmnd[0] == REQUEST_SENSE) ? TAG_NONE :
+					    TAG_NEXT)) {
+						falcon_dont_release--;
+						/* release if target did not response! */
+						falcon_release_lock_if_possible(hostdata);
+						break;
+					} else {
+						local_irq_disable();
+						LIST(tmp, hostdata->issue_queue);
+						SET_NEXT(tmp, hostdata->issue_queue);
+						hostdata->issue_queue = tmp;
@@ -1146 +1159 @@
-			cmd_free_tag( tmp );
+						cmd_free_tag(tmp);
@@ -1148,12 +1161,12 @@
-			falcon_dont_release--;
-			local_irq_restore(flags);
-			MAIN_PRINTK("scsi%d: main(): select() failed, "
-				    "returned to issue_queue\n", HOSTNO);
-			if (hostdata->connected)
-			    break;
-		    }
-		} /* if target/lun/target queue is not busy */
-	    } /* for issue_queue */
-	} /* if (!hostdata->connected) */
-		
-	if (hostdata->connected 
+						falcon_dont_release--;
+						local_irq_restore(flags);
+						MAIN_PRINTK("scsi%d: main(): select() failed, "
+							    "returned to issue_queue\n", HOSTNO);
+						if (hostdata->connected)
+							break;
+					}
+				} /* if target/lun/target queue is not busy */
+			} /* for issue_queue */
+		} /* if (!hostdata->connected) */
+
+		if (hostdata->connected
@@ -1161 +1174 @@
-	    && !hostdata->dma_len
+		    && !hostdata->dma_len
@@ -1163,15 +1176,15 @@
-	    ) {
-	    local_irq_restore(flags);
-	    MAIN_PRINTK("scsi%d: main: performing information transfer\n",
-			HOSTNO);
-	    NCR5380_information_transfer(instance);
-	    MAIN_PRINTK("scsi%d: main: done set false\n", HOSTNO);
-	    done = 0;
-	}
-    } while (!done);
-
-    /* Better allow ints _after_ 'main_running' has been cleared, else
-       an interrupt could believe we'll pick up the work it left for
-       us, but we won't see it anymore here... */
-    main_running = 0;
-    local_irq_restore(flags);
+		    ) {
+			local_irq_restore(flags);
+			MAIN_PRINTK("scsi%d: main: performing information transfer\n",
+				    HOSTNO);
+			NCR5380_information_transfer(instance);
+			MAIN_PRINTK("scsi%d: main: done set false\n", HOSTNO);
+			done = 0;
+		}
+	} while (!done);
+
+	/* Better allow ints _after_ 'main_running' has been cleared, else
+	   an interrupt could believe we'll pick up the work it left for
+	   us, but we won't see it anymore here... */
+	main_running = 0;
+	local_irq_restore(flags);
@@ -1186 +1199 @@
- *	mismatch occurs (which would finish the DMA transfer).  
+ *	mismatch occurs (which would finish the DMA transfer).
@@ -1192 +1205 @@
-static void NCR5380_dma_complete( struct Scsi_Host *instance )
+static void NCR5380_dma_complete(struct Scsi_Host *instance)
@@ -1194,54 +1207,55 @@
-    SETUP_HOSTDATA(instance);
-    int           transfered, saved_data = 0, overrun = 0, cnt, toPIO;
-    unsigned char **data, p;
-    volatile int  *count;
-
-    if (!hostdata->connected) {
-	printk(KERN_WARNING "scsi%d: received end of DMA interrupt with "
-	       "no connected cmd\n", HOSTNO);
-	return;
-    }
-    
-    if (atari_read_overruns) {
-	p = hostdata->connected->SCp.phase;
-	if (p & SR_IO) {
-	    udelay(10);
-	    if ((((NCR5380_read(BUS_AND_STATUS_REG)) &
-		  (BASR_PHASE_MATCH|BASR_ACK)) ==
-		 (BASR_PHASE_MATCH|BASR_ACK))) {
-		saved_data = NCR5380_read(INPUT_DATA_REG);
-		overrun = 1;
-		DMA_PRINTK("scsi%d: read overrun handled\n", HOSTNO);
-	    }
-	}
-    }
-
-    DMA_PRINTK("scsi%d: real DMA transfer complete, basr 0x%X, sr 0x%X\n",
-	       HOSTNO, NCR5380_read(BUS_AND_STATUS_REG),
-	       NCR5380_read(STATUS_REG));
-
-    (void) NCR5380_read(RESET_PARITY_INTERRUPT_REG);
-    NCR5380_write(MODE_REG, MR_BASE);
-    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-
-    transfered = hostdata->dma_len - NCR5380_dma_residual(instance);
-    hostdata->dma_len = 0;
-
-    data = (unsigned char **) &(hostdata->connected->SCp.ptr);
-    count = &(hostdata->connected->SCp.this_residual);
-    *data += transfered;
-    *count -= transfered;
-
-    if (atari_read_overruns) {
-	if ((NCR5380_read(STATUS_REG) & PHASE_MASK) == p && (p & SR_IO)) {
-	    cnt = toPIO = atari_read_overruns;
-	    if (overrun) {
-		DMA_PRINTK("Got an input overrun, using saved byte\n");
-		*(*data)++ = saved_data;
-		(*count)--;
-		cnt--;
-		toPIO--;
-	    }
-	    DMA_PRINTK("Doing %d-byte PIO to 0x%08lx\n", cnt, (long)*data);
-	    NCR5380_transfer_pio(instance, &p, &cnt, data);
-	    *count -= toPIO - cnt;
+	SETUP_HOSTDATA(instance);
+	int transfered, saved_data = 0, overrun = 0, cnt, toPIO;
+	unsigned char **data, p;
+	volatile int *count;
+
+	if (!hostdata->connected) {
+		printk(KERN_WARNING "scsi%d: received end of DMA interrupt with "
+		       "no connected cmd\n", HOSTNO);
+		return;
+	}
+
+	if (atari_read_overruns) {
+		p = hostdata->connected->SCp.phase;
+		if (p & SR_IO) {
+			udelay(10);
+			if ((NCR5380_read(BUS_AND_STATUS_REG) &
+			     (BASR_PHASE_MATCH|BASR_ACK)) ==
+			    (BASR_PHASE_MATCH|BASR_ACK)) {
+				saved_data = NCR5380_read(INPUT_DATA_REG);
+				overrun = 1;
+				DMA_PRINTK("scsi%d: read overrun handled\n", HOSTNO);
+			}
+		}
+	}
+
+	DMA_PRINTK("scsi%d: real DMA transfer complete, basr 0x%X, sr 0x%X\n",
+		   HOSTNO, NCR5380_read(BUS_AND_STATUS_REG),
+		   NCR5380_read(STATUS_REG));
+
+	(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);
+	NCR5380_write(MODE_REG, MR_BASE);
+	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+
+	transfered = hostdata->dma_len - NCR5380_dma_residual(instance);
+	hostdata->dma_len = 0;
+
+	data = (unsigned char **)&hostdata->connected->SCp.ptr;
+	count = &hostdata->connected->SCp.this_residual;
+	*data += transfered;
+	*count -= transfered;
+
+	if (atari_read_overruns) {
+		if ((NCR5380_read(STATUS_REG) & PHASE_MASK) == p && (p & SR_IO)) {
+			cnt = toPIO = atari_read_overruns;
+			if (overrun) {
+				DMA_PRINTK("Got an input overrun, using saved byte\n");
+				*(*data)++ = saved_data;
+				(*count)--;
+				cnt--;
+				toPIO--;
+			}
+			DMA_PRINTK("Doing %d-byte PIO to 0x%08lx\n", cnt, (long)*data);
+			NCR5380_transfer_pio(instance, &p, &cnt, data);
+			*count -= toPIO - cnt;
+		}
@@ -1249 +1262,0 @@
-    }
@@ -1256 +1269 @@
- * 
+ *
@@ -1258 +1271 @@
- *	from the disconnected queue, and restarting NCR5380_main() 
+ *	from the disconnected queue, and restarting NCR5380_main()
@@ -1265 +1278 @@
-static irqreturn_t NCR5380_intr (int irq, void *dev_id)
+static irqreturn_t NCR5380_intr(int irq, void *dev_id)
@@ -1267,32 +1280,29 @@
-    struct Scsi_Host *instance = first_instance;
-    int done = 1, handled = 0;
-    unsigned char basr;
-
-    INT_PRINTK("scsi%d: NCR5380 irq triggered\n", HOSTNO);
-
-    /* Look for pending interrupts */
-    basr = NCR5380_read(BUS_AND_STATUS_REG);
-    INT_PRINTK("scsi%d: BASR=%02x\n", HOSTNO, basr);
-    /* dispatch to appropriate routine if found and done=0 */
-    if (basr & BASR_IRQ) {
-	NCR_PRINT(NDEBUG_INTR);
-	if ((NCR5380_read(STATUS_REG) & (SR_SEL|SR_IO)) == (SR_SEL|SR_IO)) {
-	    done = 0;
-	    ENABLE_IRQ();
-	    INT_PRINTK("scsi%d: SEL interrupt\n", HOSTNO);
-	    NCR5380_reselect(instance);
-	    (void) NCR5380_read(RESET_PARITY_INTERRUPT_REG);
-	}
-	else if (basr & BASR_PARITY_ERROR) {
-	    INT_PRINTK("scsi%d: PARITY interrupt\n", HOSTNO);
-	    (void) NCR5380_read(RESET_PARITY_INTERRUPT_REG);
-	}
-	else if ((NCR5380_read(STATUS_REG) & SR_RST) == SR_RST) {
-	    INT_PRINTK("scsi%d: RESET interrupt\n", HOSTNO);
-	    (void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);
-	}
-	else {
-	    /*  
-	     * The rest of the interrupt conditions can occur only during a
-	     * DMA transfer
-	     */
+	struct Scsi_Host *instance = first_instance;
+	int done = 1, handled = 0;
+	unsigned char basr;
+
+	INT_PRINTK("scsi%d: NCR5380 irq triggered\n", HOSTNO);
+
+	/* Look for pending interrupts */
+	basr = NCR5380_read(BUS_AND_STATUS_REG);
+	INT_PRINTK("scsi%d: BASR=%02x\n", HOSTNO, basr);
+	/* dispatch to appropriate routine if found and done=0 */
+	if (basr & BASR_IRQ) {
+		NCR_PRINT(NDEBUG_INTR);
+		if ((NCR5380_read(STATUS_REG) & (SR_SEL|SR_IO)) == (SR_SEL|SR_IO)) {
+			done = 0;
+			ENABLE_IRQ();
+			INT_PRINTK("scsi%d: SEL interrupt\n", HOSTNO);
+			NCR5380_reselect(instance);
+			(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);
+		} else if (basr & BASR_PARITY_ERROR) {
+			INT_PRINTK("scsi%d: PARITY interrupt\n", HOSTNO);
+			(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);
+		} else if ((NCR5380_read(STATUS_REG) & SR_RST) == SR_RST) {
+			INT_PRINTK("scsi%d: RESET interrupt\n", HOSTNO);
+			(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);
+		} else {
+			/*
+			 * The rest of the interrupt conditions can occur only during a
+			 * DMA transfer
+			 */
@@ -1301,15 +1311,15 @@
-	    /*
-	     * We should only get PHASE MISMATCH and EOP interrupts if we have
-	     * DMA enabled, so do a sanity check based on the current setting
-	     * of the MODE register.
-	     */
-
-	    if ((NCR5380_read(MODE_REG) & MR_DMA_MODE) &&
-		((basr & BASR_END_DMA_TRANSFER) || 
-		 !(basr & BASR_PHASE_MATCH))) {
-		    
-		INT_PRINTK("scsi%d: PHASE MISM or EOP interrupt\n", HOSTNO);
-		NCR5380_dma_complete( instance );
-		done = 0;
-		ENABLE_IRQ();
-	    } else
+			/*
+			 * We should only get PHASE MISMATCH and EOP interrupts if we have
+			 * DMA enabled, so do a sanity check based on the current setting
+			 * of the MODE register.
+			 */
+
+			if ((NCR5380_read(MODE_REG) & MR_DMA_MODE) &&
+			    ((basr & BASR_END_DMA_TRANSFER) ||
+			     !(basr & BASR_PHASE_MATCH))) {
+
+				INT_PRINTK("scsi%d: PHASE MISM or EOP interrupt\n", HOSTNO);
+				NCR5380_dma_complete( instance );
+				done = 0;
+				ENABLE_IRQ();
+			} else
@@ -1317 +1327 @@
-	    {
+			{
@@ -1319,23 +1329,22 @@
-		if (basr & BASR_PHASE_MATCH)
-		    printk(KERN_NOTICE "scsi%d: unknown interrupt, "
-			   "BASR 0x%x, MR 0x%x, SR 0x%x\n",
-			   HOSTNO, basr, NCR5380_read(MODE_REG),
-			   NCR5380_read(STATUS_REG));
-		(void) NCR5380_read(RESET_PARITY_INTERRUPT_REG);
-	    }
-	} /* if !(SELECTION || PARITY) */
-	handled = 1;
-    } /* BASR & IRQ */
-    else {
-	printk(KERN_NOTICE "scsi%d: interrupt without IRQ bit set in BASR, "
-	       "BASR 0x%X, MR 0x%X, SR 0x%x\n", HOSTNO, basr,
-	       NCR5380_read(MODE_REG), NCR5380_read(STATUS_REG));
-	(void) NCR5380_read(RESET_PARITY_INTERRUPT_REG);
-    }
-    
-    if (!done) {
-	INT_PRINTK("scsi%d: in int routine, calling main\n", HOSTNO);
-	/* Put a call to NCR5380_main() on the queue... */
-	queue_main();
-    }
-    return IRQ_RETVAL(handled);
+				if (basr & BASR_PHASE_MATCH)
+					printk(KERN_NOTICE "scsi%d: unknown interrupt, "
+					       "BASR 0x%x, MR 0x%x, SR 0x%x\n",
+					       HOSTNO, basr, NCR5380_read(MODE_REG),
+					       NCR5380_read(STATUS_REG));
+				(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);
+			}
+		} /* if !(SELECTION || PARITY) */
+		handled = 1;
+	} /* BASR & IRQ */ else {
+		printk(KERN_NOTICE "scsi%d: interrupt without IRQ bit set in BASR, "
+		       "BASR 0x%X, MR 0x%X, SR 0x%x\n", HOSTNO, basr,
+		       NCR5380_read(MODE_REG), NCR5380_read(STATUS_REG));
+		(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);
+	}
+
+	if (!done) {
+		INT_PRINTK("scsi%d: in int routine, calling main\n", HOSTNO);
+		/* Put a call to NCR5380_main() on the queue... */
+		queue_main();
+	}
+	return IRQ_RETVAL(handled);
@@ -1345 +1354 @@
-static void collect_stats(struct NCR5380_hostdata* hostdata, Scsi_Cmnd* cmd)
+static void collect_stats(struct NCR5380_hostdata* hostdata, Scsi_Cmnd *cmd)
@@ -1348 +1357 @@
-    if (cmd->request_bufflen > NCR5380_STAT_LIMIT)
+	if (cmd->request_bufflen > NCR5380_STAT_LIMIT)
@@ -1350,17 +1359,16 @@
-	switch (cmd->cmnd[0])
-	{
-	    case WRITE:
-	    case WRITE_6:
-	    case WRITE_10:
-		hostdata->time_write[cmd->device->id] += (jiffies - hostdata->timebase);
-		/*hostdata->bytes_write[cmd->device->id] += cmd->request_bufflen;*/
-		hostdata->pendingw--;
-		break;
-	    case READ:
-	    case READ_6:
-	    case READ_10:
-		hostdata->time_read[cmd->device->id] += (jiffies - hostdata->timebase);
-		/*hostdata->bytes_read[cmd->device->id] += cmd->request_bufflen;*/
-		hostdata->pendingr--;
-		break;
-	}
+		switch (cmd->cmnd[0]) {
+		case WRITE:
+		case WRITE_6:
+		case WRITE_10:
+			hostdata->time_write[cmd->device->id] += (jiffies - hostdata->timebase);
+			/*hostdata->bytes_write[cmd->device->id] += cmd->request_bufflen;*/
+			hostdata->pendingw--;
+			break;
+		case READ:
+		case READ_6:
+		case READ_10:
+			hostdata->time_read[cmd->device->id] += (jiffies - hostdata->timebase);
+			/*hostdata->bytes_read[cmd->device->id] += cmd->request_bufflen;*/
+			hostdata->pendingr--;
+			break;
+		}
@@ -1370,2 +1378,2 @@
-/* 
- * Function : int NCR5380_select (struct Scsi_Host *instance, Scsi_Cmnd *cmd, 
+/*
+ * Function : int NCR5380_select (struct Scsi_Host *instance, Scsi_Cmnd *cmd,
@@ -1375,2 +1383,2 @@
- *	including ARBITRATION, SELECTION, and initial message out for 
- *	IDENTIFY and queue messages. 
+ *	including ARBITRATION, SELECTION, and initial message out for
+ *	IDENTIFY and queue messages.
@@ -1378,3 +1386,3 @@
- * Inputs : instance - instantiation of the 5380 driver on which this 
- * 	target lives, cmd - SCSI command to execute, tag - set to TAG_NEXT for 
- *	new tag, TAG_NONE for untagged queueing, otherwise set to the tag for 
+ * Inputs : instance - instantiation of the 5380 driver on which this
+ *	target lives, cmd - SCSI command to execute, tag - set to TAG_NEXT for
+ *	new tag, TAG_NONE for untagged queueing, otherwise set to the tag for
@@ -1382 +1390 @@
- * 
+ *
@@ -1384,2 +1392,2 @@
- *	0 if selection succeeded or failed because the target 
- * 	did not respond.
+ *	0 if selection succeeded or failed because the target
+ *	did not respond.
@@ -1387,2 +1395,2 @@
- * Side effects : 
- * 	If bus busy, arbitration failed, etc, NCR5380_select() will exit 
+ * Side effects :
+ *	If bus busy, arbitration failed, etc, NCR5380_select() will exit
@@ -1393,3 +1401,3 @@
- *	If successful : I_T_L or I_T_L_Q nexus will be established, 
- *		instance->connected will be set to cmd.  
- * 		SELECT interrupt will be disabled.
+ *	If successful : I_T_L or I_T_L_Q nexus will be established,
+ *		instance->connected will be set to cmd.
+ *		SELECT interrupt will be disabled.
@@ -1397 +1405 @@
- *	If failed (no target) : cmd->scsi_done() will be called, and the 
+ *	If failed (no target) : cmd->scsi_done() will be called, and the
@@ -1401 +1409 @@
-static int NCR5380_select (struct Scsi_Host *instance, Scsi_Cmnd *cmd, int tag)
+static int NCR5380_select(struct Scsi_Host *instance, Scsi_Cmnd *cmd, int tag)
@@ -1403,16 +1411,30 @@
-    SETUP_HOSTDATA(instance);
-    unsigned char tmp[3], phase;
-    unsigned char *data;
-    int len;
-    unsigned long timeout;
-    unsigned long flags;
-
-    hostdata->restart_select = 0;
-    NCR_PRINT(NDEBUG_ARBITRATION);
-    ARB_PRINTK("scsi%d: starting arbitration, id = %d\n", HOSTNO,
-	       instance->this_id);
-
-    /* 
-     * Set the phase bits to 0, otherwise the NCR5380 won't drive the 
-     * data bus during SELECTION.
-     */
+	SETUP_HOSTDATA(instance);
+	unsigned char tmp[3], phase;
+	unsigned char *data;
+	int len;
+	unsigned long timeout;
+	unsigned long flags;
+
+	hostdata->restart_select = 0;
+	NCR_PRINT(NDEBUG_ARBITRATION);
+	ARB_PRINTK("scsi%d: starting arbitration, id = %d\n", HOSTNO,
+		   instance->this_id);
+
+	/*
+	 * Set the phase bits to 0, otherwise the NCR5380 won't drive the
+	 * data bus during SELECTION.
+	 */
+
+	local_irq_save(flags);
+	if (hostdata->connected) {
+		local_irq_restore(flags);
+		return -1;
+	}
+	NCR5380_write(TARGET_COMMAND_REG, 0);
+
+	/*
+	 * Start arbitration.
+	 */
+
+	NCR5380_write(OUTPUT_DATA_REG, hostdata->id_mask);
+	NCR5380_write(MODE_REG, MR_ARBITRATE);
@@ -1420,2 +1441,0 @@
-    local_irq_save(flags);
-    if (hostdata->connected) {
@@ -1423,30 +1443,16 @@
-	return -1;
-    }
-    NCR5380_write(TARGET_COMMAND_REG, 0);
-
-
-    /* 
-     * Start arbitration.
-     */
-    
-    NCR5380_write(OUTPUT_DATA_REG, hostdata->id_mask);
-    NCR5380_write(MODE_REG, MR_ARBITRATE);
-
-    local_irq_restore(flags);
-
-    /* Wait for arbitration logic to complete */
-#if NCR_TIMEOUT
-    {
-      unsigned long timeout = jiffies + 2*NCR_TIMEOUT;
-
-      while (!(NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_PROGRESS)
-	   && time_before(jiffies, timeout) && !hostdata->connected)
-	;
-      if (time_after_eq(jiffies, timeout))
-      {
-	printk("scsi : arbitration timeout at %d\n", __LINE__);
-	NCR5380_write(MODE_REG, MR_BASE);
-	NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
-	return -1;
-      }
-    }
+
+	/* Wait for arbitration logic to complete */
+#if defined(NCR_TIMEOUT)
+	{
+		unsigned long timeout = jiffies + 2*NCR_TIMEOUT;
+
+		while (!(NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_PROGRESS) &&
+		       time_before(jiffies, timeout) && !hostdata->connected)
+			;
+		if (time_after_eq(jiffies, timeout)) {
+			printk("scsi : arbitration timeout at %d\n", __LINE__);
+			NCR5380_write(MODE_REG, MR_BASE);
+			NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+			return -1;
+		}
+	}
@@ -1454,2 +1460,3 @@
-    while (!(NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_PROGRESS)
-	 && !hostdata->connected);
+	while (!(NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_PROGRESS) &&
+	       !hostdata->connected)
+		;
@@ -1458 +1465 @@
-    ARB_PRINTK("scsi%d: arbitration complete\n", HOSTNO);
+	ARB_PRINTK("scsi%d: arbitration complete\n", HOSTNO);
@@ -1460,43 +1467,43 @@
-    if (hostdata->connected) {
-	NCR5380_write(MODE_REG, MR_BASE); 
-	return -1;
-    }
-    /* 
-     * The arbitration delay is 2.2us, but this is a minimum and there is 
-     * no maximum so we can safely sleep for ceil(2.2) usecs to accommodate
-     * the integral nature of udelay().
-     *
-     */
-
-    udelay(3);
-
-    /* Check for lost arbitration */
-    if ((NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST) ||
-	(NCR5380_read(CURRENT_SCSI_DATA_REG) & hostdata->id_higher_mask) ||
-	(NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST) ||
-	hostdata->connected) {
-	NCR5380_write(MODE_REG, MR_BASE); 
-	ARB_PRINTK("scsi%d: lost arbitration, deasserting MR_ARBITRATE\n",
-		   HOSTNO);
-	return -1;
-    }
-
-     /* after/during arbitration, BSY should be asserted.
-	IBM DPES-31080 Version S31Q works now */
-     /* Tnx to Thomas_Roesch@m2.maus.de for finding this! (Roman) */
-    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_SEL |
-					 ICR_ASSERT_BSY ) ;
-    
-    if ((NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST) ||
-	hostdata->connected) {
-	NCR5380_write(MODE_REG, MR_BASE);
-	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-	ARB_PRINTK("scsi%d: lost arbitration, deasserting ICR_ASSERT_SEL\n",
-		   HOSTNO);
-	return -1;
-    }
-
-    /* 
-     * Again, bus clear + bus settle time is 1.2us, however, this is 
-     * a minimum so we'll udelay ceil(1.2)
-     */
+	if (hostdata->connected) {
+		NCR5380_write(MODE_REG, MR_BASE);
+		return -1;
+	}
+	/*
+	 * The arbitration delay is 2.2us, but this is a minimum and there is
+	 * no maximum so we can safely sleep for ceil(2.2) usecs to accommodate
+	 * the integral nature of udelay().
+	 *
+	 */
+
+	udelay(3);
+
+	/* Check for lost arbitration */
+	if ((NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST) ||
+	    (NCR5380_read(CURRENT_SCSI_DATA_REG) & hostdata->id_higher_mask) ||
+	    (NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST) ||
+	    hostdata->connected) {
+		NCR5380_write(MODE_REG, MR_BASE);
+		ARB_PRINTK("scsi%d: lost arbitration, deasserting MR_ARBITRATE\n",
+			   HOSTNO);
+		return -1;
+	}
+
+	/* after/during arbitration, BSY should be asserted.
+	   IBM DPES-31080 Version S31Q works now */
+	/* Tnx to Thomas_Roesch@m2.maus.de for finding this! (Roman) */
+	NCR5380_write(INITIATOR_COMMAND_REG,
+		      ICR_BASE | ICR_ASSERT_SEL | ICR_ASSERT_BSY);
+
+	if ((NCR5380_read(INITIATOR_COMMAND_REG) & ICR_ARBITRATION_LOST) ||
+	    hostdata->connected) {
+		NCR5380_write(MODE_REG, MR_BASE);
+		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+		ARB_PRINTK("scsi%d: lost arbitration, deasserting ICR_ASSERT_SEL\n",
+			   HOSTNO);
+		return -1;
+	}
+
+	/*
+	 * Again, bus clear + bus settle time is 1.2us, however, this is
+	 * a minimum so we'll udelay ceil(1.2)
+	 */
@@ -1505,2 +1512,2 @@
-    /* ++roman: But some targets (see above :-) seem to need a bit more... */
-    udelay(15);
+	/* ++roman: But some targets (see above :-) seem to need a bit more... */
+	udelay(15);
@@ -1508 +1515 @@
-    udelay(2);
+	udelay(2);
@@ -1510,2 +1517,24 @@
-    
-    if (hostdata->connected) {
+
+	if (hostdata->connected) {
+		NCR5380_write(MODE_REG, MR_BASE);
+		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+		return -1;
+	}
+
+	ARB_PRINTK("scsi%d: won arbitration\n", HOSTNO);
+
+	/*
+	 * Now that we have won arbitration, start Selection process, asserting
+	 * the host and target ID's on the SCSI bus.
+	 */
+
+	NCR5380_write(OUTPUT_DATA_REG, (hostdata->id_mask | (1 << cmd->device->id)));
+
+	/*
+	 * Raise ATN while SEL is true before BSY goes false from arbitration,
+	 * since this is the only way to guarantee that we'll get a MESSAGE OUT
+	 * phase immediately after selection.
+	 */
+
+	NCR5380_write(INITIATOR_COMMAND_REG, (ICR_BASE | ICR_ASSERT_BSY |
+		      ICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_SEL ));
@@ -1513,3 +1541,0 @@
-	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-	return -1;
-    }
@@ -1517 +1543,4 @@
-    ARB_PRINTK("scsi%d: won arbitration\n", HOSTNO);
+	/*
+	 * Reselect interrupts must be turned off prior to the dropping of BSY,
+	 * otherwise we will trigger an interrupt.
+	 */
@@ -1519,21 +1548,4 @@
-    /* 
-     * Now that we have won arbitration, start Selection process, asserting 
-     * the host and target ID's on the SCSI bus.
-     */
-
-    NCR5380_write(OUTPUT_DATA_REG, (hostdata->id_mask | (1 << cmd->device->id)));
-
-    /* 
-     * Raise ATN while SEL is true before BSY goes false from arbitration,
-     * since this is the only way to guarantee that we'll get a MESSAGE OUT
-     * phase immediately after selection.
-     */
-
-    NCR5380_write(INITIATOR_COMMAND_REG, (ICR_BASE | ICR_ASSERT_BSY | 
-	ICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_SEL ));
-    NCR5380_write(MODE_REG, MR_BASE);
-
-    /* 
-     * Reselect interrupts must be turned off prior to the dropping of BSY,
-     * otherwise we will trigger an interrupt.
-     */
+	if (hostdata->connected) {
+		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+		return -1;
+	}
@@ -1541,4 +1553 @@
-    if (hostdata->connected) {
-	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-	return -1;
-    }
+	NCR5380_write(SELECT_ENABLE_REG, 0);
@@ -1546 +1555,28 @@
-    NCR5380_write(SELECT_ENABLE_REG, 0);
+	/*
+	 * The initiator shall then wait at least two deskew delays and release
+	 * the BSY signal.
+	 */
+	udelay(1);        /* wingel -- wait two bus deskew delay >2*45ns */
+
+	/* Reset BSY */
+	NCR5380_write(INITIATOR_COMMAND_REG, (ICR_BASE | ICR_ASSERT_DATA |
+		      ICR_ASSERT_ATN | ICR_ASSERT_SEL));
+
+	/*
+	 * Something weird happens when we cease to drive BSY - looks
+	 * like the board/chip is letting us do another read before the
+	 * appropriate propagation delay has expired, and we're confusing
+	 * a BSY signal from ourselves as the target's response to SELECTION.
+	 *
+	 * A small delay (the 'C++' frontend breaks the pipeline with an
+	 * unnecessary jump, making it work on my 386-33/Trantor T128, the
+	 * tighter 'C' code breaks and requires this) solves the problem -
+	 * the 1 us delay is arbitrary, and only used because this delay will
+	 * be the same on other platforms and since it works here, it should
+	 * work there.
+	 *
+	 * wingel suggests that this could be due to failing to wait
+	 * one deskew delay.
+	 */
+
+	udelay(1);
@@ -1548,43 +1584,14 @@
-    /*
-     * The initiator shall then wait at least two deskew delays and release 
-     * the BSY signal.
-     */
-    udelay(1);        /* wingel -- wait two bus deskew delay >2*45ns */
-
-    /* Reset BSY */
-    NCR5380_write(INITIATOR_COMMAND_REG, (ICR_BASE | ICR_ASSERT_DATA | 
-	ICR_ASSERT_ATN | ICR_ASSERT_SEL));
-
-    /* 
-     * Something weird happens when we cease to drive BSY - looks
-     * like the board/chip is letting us do another read before the 
-     * appropriate propagation delay has expired, and we're confusing
-     * a BSY signal from ourselves as the target's response to SELECTION.
-     *
-     * A small delay (the 'C++' frontend breaks the pipeline with an
-     * unnecessary jump, making it work on my 386-33/Trantor T128, the
-     * tighter 'C' code breaks and requires this) solves the problem - 
-     * the 1 us delay is arbitrary, and only used because this delay will 
-     * be the same on other platforms and since it works here, it should 
-     * work there.
-     *
-     * wingel suggests that this could be due to failing to wait
-     * one deskew delay.
-     */
-
-    udelay(1);
-
-    SEL_PRINTK("scsi%d: selecting target %d\n", HOSTNO, cmd->device->id);
-
-    /* 
-     * The SCSI specification calls for a 250 ms timeout for the actual 
-     * selection.
-     */
-
-    timeout = jiffies + 25; 
-
-    /* 
-     * XXX very interesting - we're seeing a bounce where the BSY we 
-     * asserted is being reflected / still asserted (propagation delay?)
-     * and it's detecting as true.  Sigh.
-     */
+	SEL_PRINTK("scsi%d: selecting target %d\n", HOSTNO, cmd->device->id);
+
+	/*
+	 * The SCSI specification calls for a 250 ms timeout for the actual
+	 * selection.
+	 */
+
+	timeout = jiffies + 25;
+
+	/*
+	 * XXX very interesting - we're seeing a bounce where the BSY we
+	 * asserted is being reflected / still asserted (propagation delay?)
+	 * and it's detecting as true.  Sigh.
+	 */
@@ -1593,19 +1600,19 @@
-    /* ++roman: If a target conformed to the SCSI standard, it wouldn't assert
-     * IO while SEL is true. But again, there are some disks out the in the
-     * world that do that nevertheless. (Somebody claimed that this announces
-     * reselection capability of the target.) So we better skip that test and
-     * only wait for BSY... (Famous german words: Der Klgere gibt nach :-)
-     */
-
-    while (time_before(jiffies, timeout) && !(NCR5380_read(STATUS_REG) & 
-	(SR_BSY | SR_IO)));
-
-    if ((NCR5380_read(STATUS_REG) & (SR_SEL | SR_IO)) == 
-	    (SR_SEL | SR_IO)) {
-	    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-	    NCR5380_reselect(instance);
-	    printk (KERN_ERR "scsi%d: reselection after won arbitration?\n",
-		    HOSTNO);
-	    NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
-	    return -1;
-    }
+	/* ++roman: If a target conformed to the SCSI standard, it wouldn't assert
+	 * IO while SEL is true. But again, there are some disks out the in the
+	 * world that do that nevertheless. (Somebody claimed that this announces
+	 * reselection capability of the target.) So we better skip that test and
+	 * only wait for BSY... (Famous german words: Der Klgere gibt nach :-)
+	 */
+
+	while (time_before(jiffies, timeout) &&
+	       !(NCR5380_read(STATUS_REG) & (SR_BSY | SR_IO)))
+		;
+
+	if ((NCR5380_read(STATUS_REG) & (SR_SEL | SR_IO)) == (SR_SEL | SR_IO)) {
+		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+		NCR5380_reselect(instance);
+		printk(KERN_ERR "scsi%d: reselection after won arbitration?\n",
+		       HOSTNO);
+		NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+		return -1;
+	}
@@ -1613 +1620,2 @@
-    while (time_before(jiffies, timeout) && !(NCR5380_read(STATUS_REG) & SR_BSY));
+	while (time_before(jiffies, timeout) && !(NCR5380_read(STATUS_REG) & SR_BSY))
+		;
@@ -1616,5 +1624,5 @@
-    /* 
-     * No less than two deskew delays after the initiator detects the 
-     * BSY signal is true, it shall release the SEL signal and may 
-     * change the DATA BUS.                                     -wingel
-     */
+	/*
+	 * No less than two deskew delays after the initiator detects the
+	 * BSY signal is true, it shall release the SEL signal and may
+	 * change the DATA BUS.                                     -wingel
+	 */
@@ -1622 +1630 @@
-    udelay(1);
+	udelay(1);
@@ -1624 +1632 @@
-    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);
+	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);
@@ -1626,11 +1634,11 @@
-    if (!(NCR5380_read(STATUS_REG) & SR_BSY)) {
-	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-	if (hostdata->targets_present & (1 << cmd->device->id)) {
-	    printk(KERN_ERR "scsi%d: weirdness\n", HOSTNO);
-	    if (hostdata->restart_select)
-		printk(KERN_NOTICE "\trestart select\n");
-	    NCR_PRINT(NDEBUG_ANY);
-	    NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
-	    return -1;
-	}
-	cmd->result = DID_BAD_TARGET << 16;
+	if (!(NCR5380_read(STATUS_REG) & SR_BSY)) {
+		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+		if (hostdata->targets_present & (1 << cmd->device->id)) {
+			printk(KERN_ERR "scsi%d: weirdness\n", HOSTNO);
+			if (hostdata->restart_select)
+				printk(KERN_NOTICE "\trestart select\n");
+			NCR_PRINT(NDEBUG_ANY);
+			NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+			return -1;
+		}
+		cmd->result = DID_BAD_TARGET << 16;
@@ -1638 +1646 @@
-	collect_stats(hostdata, cmd);
+		collect_stats(hostdata, cmd);
@@ -1641 +1649 @@
-	cmd_free_tag( cmd );
+		cmd_free_tag(cmd);
@@ -1643,6 +1651,6 @@
-	cmd->scsi_done(cmd);
-	NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
-	SEL_PRINTK("scsi%d: target did not respond within 250ms\n", HOSTNO);
-	NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
-	return 0;
-    } 
+		cmd->scsi_done(cmd);
+		NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+		SEL_PRINTK("scsi%d: target did not respond within 250ms\n", HOSTNO);
+		NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+		return 0;
+	}
@@ -1650 +1658 @@
-    hostdata->targets_present |= (1 << cmd->device->id);
+	hostdata->targets_present |= (1 << cmd->device->id);
@@ -1652,21 +1660,22 @@
-    /*
-     * Since we followed the SCSI spec, and raised ATN while SEL 
-     * was true but before BSY was false during selection, the information
-     * transfer phase should be a MESSAGE OUT phase so that we can send the
-     * IDENTIFY message.
-     * 
-     * If SCSI-II tagged queuing is enabled, we also send a SIMPLE_QUEUE_TAG
-     * message (2 bytes) with a tag ID that we increment with every command
-     * until it wraps back to 0.
-     *
-     * XXX - it turns out that there are some broken SCSI-II devices,
-     *	     which claim to support tagged queuing but fail when more than
-     *	     some number of commands are issued at once.
-     */
-
-    /* Wait for start of REQ/ACK handshake */
-    while (!(NCR5380_read(STATUS_REG) & SR_REQ));
-
-    SEL_PRINTK("scsi%d: target %d selected, going into MESSAGE OUT phase.\n",
-	       HOSTNO, cmd->device->id);
-    tmp[0] = IDENTIFY(1, cmd->device->lun);
+	/*
+	 * Since we followed the SCSI spec, and raised ATN while SEL
+	 * was true but before BSY was false during selection, the information
+	 * transfer phase should be a MESSAGE OUT phase so that we can send the
+	 * IDENTIFY message.
+	 *
+	 * If SCSI-II tagged queuing is enabled, we also send a SIMPLE_QUEUE_TAG
+	 * message (2 bytes) with a tag ID that we increment with every command
+	 * until it wraps back to 0.
+	 *
+	 * XXX - it turns out that there are some broken SCSI-II devices,
+	 *	     which claim to support tagged queuing but fail when more than
+	 *	     some number of commands are issued at once.
+	 */
+
+	/* Wait for start of REQ/ACK handshake */
+	while (!(NCR5380_read(STATUS_REG) & SR_REQ))
+		;
+
+	SEL_PRINTK("scsi%d: target %d selected, going into MESSAGE OUT phase.\n",
+		   HOSTNO, cmd->device->id);
+	tmp[0] = IDENTIFY(1, cmd->device->lun);
@@ -1675,6 +1684,6 @@
-    if (cmd->tag != TAG_NONE) {
-	tmp[1] = hostdata->last_message = SIMPLE_QUEUE_TAG;
-	tmp[2] = cmd->tag;
-	len = 3;
-    } else 
-	len = 1;
+	if (cmd->tag != TAG_NONE) {
+		tmp[1] = hostdata->last_message = SIMPLE_QUEUE_TAG;
+		tmp[2] = cmd->tag;
+		len = 3;
+	} else
+		len = 1;
@@ -1682,2 +1691,2 @@
-    len = 1;
-    cmd->tag=0;
+	len = 1;
+	cmd->tag = 0;
@@ -1686,7 +1695,7 @@
-    /* Send message(s) */
-    data = tmp;
-    phase = PHASE_MSGOUT;
-    NCR5380_transfer_pio(instance, &phase, &len, &data);
-    SEL_PRINTK("scsi%d: nexus established.\n", HOSTNO);
-    /* XXX need to handle errors here */
-    hostdata->connected = cmd;
+	/* Send message(s) */
+	data = tmp;
+	phase = PHASE_MSGOUT;
+	NCR5380_transfer_pio(instance, &phase, &len, &data);
+	SEL_PRINTK("scsi%d: nexus established.\n", HOSTNO);
+	/* XXX need to handle errors here */
+	hostdata->connected = cmd;
@@ -1694,4 +1703,2 @@
-    hostdata->busy[cmd->device->id] |= (1 << cmd->device->lun);
-#endif    
-
-    initialize_SCp(cmd);
+	hostdata->busy[cmd->device->id] |= (1 << cmd->device->lun);
+#endif
@@ -1698,0 +1706 @@
+	initialize_SCp(cmd);
@@ -1700 +1708 @@
-    return 0;
+	return 0;
@@ -1703,2 +1711,2 @@
-/* 
- * Function : int NCR5380_transfer_pio (struct Scsi_Host *instance, 
+/*
+ * Function : int NCR5380_transfer_pio (struct Scsi_Host *instance,
@@ -1709,2 +1717,2 @@
- * Inputs : instance - instance of driver, *phase - pointer to 
- *	what phase is expected, *count - pointer to number of 
+ * Inputs : instance - instance of driver, *phase - pointer to
+ *	what phase is expected, *count - pointer to number of
@@ -1712 +1720 @@
- * 
+ *
@@ -1717 +1725 @@
- * 	Also, *phase, *count, *data are modified in place.
+ *	Also, *phase, *count, *data are modified in place.
@@ -1723 +1731 @@
- * Note : this code is not as quick as it could be, however it 
+ * Note : this code is not as quick as it could be, however it
@@ -1728,65 +1736,13 @@
-static int NCR5380_transfer_pio( struct Scsi_Host *instance, 
-				 unsigned char *phase, int *count,
-				 unsigned char **data)
-{
-    register unsigned char p = *phase, tmp;
-    register int c = *count;
-    register unsigned char *d = *data;
-
-    /* 
-     * The NCR5380 chip will only drive the SCSI bus when the 
-     * phase specified in the appropriate bits of the TARGET COMMAND
-     * REGISTER match the STATUS REGISTER
-     */
-
-    NCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));
-
-    do {
-	/* 
-	 * Wait for assertion of REQ, after which the phase bits will be 
-	 * valid 
-	 */
-	while (!((tmp = NCR5380_read(STATUS_REG)) & SR_REQ));
-
-	HSH_PRINTK("scsi%d: REQ detected\n", HOSTNO);
-
-	/* Check for phase mismatch */	
-	if ((tmp & PHASE_MASK) != p) {
-	    PIO_PRINTK("scsi%d: phase mismatch\n", HOSTNO);
-	    NCR_PRINT_PHASE(NDEBUG_PIO);
-	    break;
-	}
-
-	/* Do actual transfer from SCSI bus to / from memory */
-	if (!(p & SR_IO)) 
-	    NCR5380_write(OUTPUT_DATA_REG, *d);
-	else 
-	    *d = NCR5380_read(CURRENT_SCSI_DATA_REG);
-
-	++d;
-
-	/* 
-	 * The SCSI standard suggests that in MSGOUT phase, the initiator
-	 * should drop ATN on the last byte of the message phase
-	 * after REQ has been asserted for the handshake but before
-	 * the initiator raises ACK.
-	 */
-
-	if (!(p & SR_IO)) {
-	    if (!((p & SR_MSG) && c > 1)) {
-		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | 
-		    ICR_ASSERT_DATA);
-		NCR_PRINT(NDEBUG_PIO);
-		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | 
-			ICR_ASSERT_DATA | ICR_ASSERT_ACK);
-	    } else {
-		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |
-		    ICR_ASSERT_DATA | ICR_ASSERT_ATN);
-		NCR_PRINT(NDEBUG_PIO);
-		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | 
-		    ICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_ACK);
-	    }
-	} else {
-	    NCR_PRINT(NDEBUG_PIO);
-	    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ACK);
-	}
+static int NCR5380_transfer_pio(struct Scsi_Host *instance,
+				unsigned char *phase, int *count,
+				unsigned char **data)
+{
+	register unsigned char p = *phase, tmp;
+	register int c = *count;
+	register unsigned char *d = *data;
+
+	/*
+	 * The NCR5380 chip will only drive the SCSI bus when the
+	 * phase specified in the appropriate bits of the TARGET COMMAND
+	 * REGISTER match the STATUS REGISTER
+	 */
@@ -1794 +1750 @@
-	while (NCR5380_read(STATUS_REG) & SR_REQ);
+	NCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));
@@ -1796 +1752,7 @@
-	HSH_PRINTK("scsi%d: req false, handshake complete\n", HOSTNO);
+	do {
+		/*
+		 * Wait for assertion of REQ, after which the phase bits will be
+		 * valid
+		 */
+		while (!((tmp = NCR5380_read(STATUS_REG)) & SR_REQ))
+			;
@@ -1798,18 +1760 @@
-/*
- * We have several special cases to consider during REQ/ACK handshaking : 
- * 1.  We were in MSGOUT phase, and we are on the last byte of the 
- *	message.  ATN must be dropped as ACK is dropped.
- *
- * 2.  We are in a MSGIN phase, and we are on the last byte of the  
- *	message.  We must exit with ACK asserted, so that the calling
- *	code may raise ATN before dropping ACK to reject the message.
- *
- * 3.  ACK and ATN are clear and the target may proceed as normal.
- */
-	if (!(p == PHASE_MSGIN && c == 1)) {  
-	    if (p == PHASE_MSGOUT && c > 1)
-		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);
-	    else
-		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-	} 
-    } while (--c);
+		HSH_PRINTK("scsi%d: REQ detected\n", HOSTNO);
@@ -1817 +1762,6 @@
-    PIO_PRINTK("scsi%d: residual %d\n", HOSTNO, c);
+		/* Check for phase mismatch */
+		if ((tmp & PHASE_MASK) != p) {
+			PIO_PRINTK("scsi%d: phase mismatch\n", HOSTNO);
+			NCR_PRINT_PHASE(NDEBUG_PIO);
+			break;
+		}
@@ -1819,10 +1769,5 @@
-    *count = c;
-    *data = d;
-    tmp = NCR5380_read(STATUS_REG);
-    /* The phase read from the bus is valid if either REQ is (already)
-     * asserted or if ACK hasn't been released yet. The latter is the case if
-     * we're in MSGIN and all wanted bytes have been received. */
-    if ((tmp & SR_REQ) || (p == PHASE_MSGIN && c == 0))
-	*phase = tmp & PHASE_MASK;
-    else 
-	*phase = PHASE_UNKNOWN;
+		/* Do actual transfer from SCSI bus to / from memory */
+		if (!(p & SR_IO))
+			NCR5380_write(OUTPUT_DATA_REG, *d);
+		else
+			*d = NCR5380_read(CURRENT_SCSI_DATA_REG);
@@ -1830,4 +1775,69 @@
-    if (!c || (*phase == p))
-	return 0;
-    else 
-	return -1;
+		++d;
+
+		/*
+		 * The SCSI standard suggests that in MSGOUT phase, the initiator
+		 * should drop ATN on the last byte of the message phase
+		 * after REQ has been asserted for the handshake but before
+		 * the initiator raises ACK.
+		 */
+
+		if (!(p & SR_IO)) {
+			if (!((p & SR_MSG) && c > 1)) {
+				NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);
+				NCR_PRINT(NDEBUG_PIO);
+				NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |
+					      ICR_ASSERT_DATA | ICR_ASSERT_ACK);
+			} else {
+				NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |
+					      ICR_ASSERT_DATA | ICR_ASSERT_ATN);
+				NCR_PRINT(NDEBUG_PIO);
+				NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |
+					      ICR_ASSERT_DATA | ICR_ASSERT_ATN | ICR_ASSERT_ACK);
+			}
+		} else {
+			NCR_PRINT(NDEBUG_PIO);
+			NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ACK);
+		}
+
+		while (NCR5380_read(STATUS_REG) & SR_REQ)
+			;
+
+		HSH_PRINTK("scsi%d: req false, handshake complete\n", HOSTNO);
+
+		/*
+		 * We have several special cases to consider during REQ/ACK handshaking :
+		 * 1.  We were in MSGOUT phase, and we are on the last byte of the
+		 *	message.  ATN must be dropped as ACK is dropped.
+		 *
+		 * 2.  We are in a MSGIN phase, and we are on the last byte of the
+		 *	message.  We must exit with ACK asserted, so that the calling
+		 *	code may raise ATN before dropping ACK to reject the message.
+		 *
+		 * 3.  ACK and ATN are clear and the target may proceed as normal.
+		 */
+		if (!(p == PHASE_MSGIN && c == 1)) {
+			if (p == PHASE_MSGOUT && c > 1)
+				NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);
+			else
+				NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+		}
+	} while (--c);
+
+	PIO_PRINTK("scsi%d: residual %d\n", HOSTNO, c);
+
+	*count = c;
+	*data = d;
+	tmp = NCR5380_read(STATUS_REG);
+	/* The phase read from the bus is valid if either REQ is (already)
+	 * asserted or if ACK hasn't been released yet. The latter is the case if
+	 * we're in MSGIN and all wanted bytes have been received.
+	 */
+	if ((tmp & SR_REQ) || (p == PHASE_MSGIN && c == 0))
+		*phase = tmp & PHASE_MASK;
+	else
+		*phase = PHASE_UNKNOWN;
+
+	if (!c || (*phase == p))
+		return 0;
+	else
+		return -1;
@@ -1838,4 +1848,4 @@
- * 
- * Purpose : abort the currently established nexus.  Should only be 
- * 	called from a routine which can drop into a 
- * 
+ *
+ * Purpose : abort the currently established nexus.  Should only be
+ *	called from a routine which can drop into a
+ *
@@ -1845 +1855 @@
-static int do_abort (struct Scsi_Host *host) 
+static int do_abort(struct Scsi_Host *host)
@@ -1847,5 +1857,2 @@
-    unsigned char tmp, *msgptr, phase;
-    int len;
-
-    /* Request message out phase */
-    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);
+	unsigned char tmp, *msgptr, phase;
+	int len;
@@ -1853,18 +1860 @@
-    /* 
-     * Wait for the target to indicate a valid phase by asserting 
-     * REQ.  Once this happens, we'll have either a MSGOUT phase 
-     * and can immediately send the ABORT message, or we'll have some 
-     * other phase and will have to source/sink data.
-     * 
-     * We really don't care what value was on the bus or what value
-     * the target sees, so we just handshake.
-     */
-    
-    while (!(tmp = NCR5380_read(STATUS_REG)) & SR_REQ);
-
-    NCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(tmp));
-
-    if ((tmp & PHASE_MASK) != PHASE_MSGOUT) {
-	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN | 
-		      ICR_ASSERT_ACK);
-	while (NCR5380_read(STATUS_REG) & SR_REQ);
+	/* Request message out phase */
@@ -1872,12 +1861,0 @@
-    }
-   
-    tmp = ABORT;
-    msgptr = &tmp;
-    len = 1;
-    phase = PHASE_MSGOUT;
-    NCR5380_transfer_pio (host, &phase, &len, &msgptr);
-
-    /*
-     * If we got here, and the command completed successfully,
-     * we're about to go into bus free state.
-     */
@@ -1885 +1863,35 @@
-    return len ? -1 : 0;
+	/*
+	 * Wait for the target to indicate a valid phase by asserting
+	 * REQ.  Once this happens, we'll have either a MSGOUT phase
+	 * and can immediately send the ABORT message, or we'll have some
+	 * other phase and will have to source/sink data.
+	 *
+	 * We really don't care what value was on the bus or what value
+	 * the target sees, so we just handshake.
+	 */
+
+	while (!(tmp = NCR5380_read(STATUS_REG)) & SR_REQ)
+		;
+
+	NCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(tmp));
+
+	if ((tmp & PHASE_MASK) != PHASE_MSGOUT) {
+		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN |
+			      ICR_ASSERT_ACK);
+		while (NCR5380_read(STATUS_REG) & SR_REQ)
+			;
+		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);
+	}
+
+	tmp = ABORT;
+	msgptr = &tmp;
+	len = 1;
+	phase = PHASE_MSGOUT;
+	NCR5380_transfer_pio(host, &phase, &len, &msgptr);
+
+	/*
+	 * If we got here, and the command completed successfully,
+	 * we're about to go into bus free state.
+	 */
+
+	return len ? -1 : 0;
@@ -1889,2 +1901,2 @@
-/* 
- * Function : int NCR5380_transfer_dma (struct Scsi_Host *instance, 
+/*
+ * Function : int NCR5380_transfer_dma (struct Scsi_Host *instance,
@@ -1896,2 +1908,2 @@
- * Inputs : instance - instance of driver, *phase - pointer to 
- *	what phase is expected, *count - pointer to number of 
+ * Inputs : instance - instance of driver, *phase - pointer to
+ *	what phase is expected, *count - pointer to number of
@@ -1899 +1911 @@
- * 
+ *
@@ -1904 +1916 @@
- * 	Also, *phase, *count, *data are modified in place.
+ *	Also, *phase, *count, *data are modified in place.
@@ -1909,3 +1921,3 @@
-static int NCR5380_transfer_dma( struct Scsi_Host *instance, 
-				 unsigned char *phase, int *count,
-				 unsigned char **data)
+static int NCR5380_transfer_dma(struct Scsi_Host *instance,
+				unsigned char *phase, int *count,
+				unsigned char **data)
@@ -1913,6 +1925,6 @@
-    SETUP_HOSTDATA(instance);
-    register int c = *count;
-    register unsigned char p = *phase;
-    register unsigned char *d = *data;
-    unsigned char tmp;
-    unsigned long flags;
+	SETUP_HOSTDATA(instance);
+	register int c = *count;
+	register unsigned char p = *phase;
+	register unsigned char *d = *data;
+	unsigned char tmp;
+	unsigned long flags;
@@ -1920,4 +1932,4 @@
-    if ((tmp = (NCR5380_read(STATUS_REG) & PHASE_MASK)) != p) {
-        *phase = tmp;
-        return -1;
-    }
+	if ((tmp = (NCR5380_read(STATUS_REG) & PHASE_MASK)) != p) {
+		*phase = tmp;
+		return -1;
+	}
@@ -1925,3 +1937,2 @@
-    if (atari_read_overruns && (p & SR_IO)) {
-	c -= atari_read_overruns;
-    }
+	if (atari_read_overruns && (p & SR_IO))
+		c -= atari_read_overruns;
@@ -1929,3 +1940,3 @@
-    DMA_PRINTK("scsi%d: initializing DMA for %s, %d bytes %s %p\n",
-	       HOSTNO, (p & SR_IO) ? "reading" : "writing",
-	       c, (p & SR_IO) ? "to" : "from", d);
+	DMA_PRINTK("scsi%d: initializing DMA for %s, %d bytes %s %p\n",
+		   HOSTNO, (p & SR_IO) ? "reading" : "writing",
+		   c, (p & SR_IO) ? "to" : "from", d);
@@ -1933 +1944 @@
-    NCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));
+	NCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(p));
@@ -1936 +1947 @@
-    NCR5380_write(MODE_REG, MR_BASE | MR_DMA_MODE | MR_ENABLE_EOP_INTR | MR_MONITOR_BSY);
+	NCR5380_write(MODE_REG, MR_BASE | MR_DMA_MODE | MR_ENABLE_EOP_INTR | MR_MONITOR_BSY);
@@ -1939,29 +1950,29 @@
-    if (IS_A_TT()) {
-	/* On the Medusa, it is a must to initialize the DMA before
-	 * starting the NCR. This is also the cleaner way for the TT.
-	 */
-	local_irq_save(flags);
-	hostdata->dma_len = (p & SR_IO) ?
-	    NCR5380_dma_read_setup(instance, d, c) : 
-	    NCR5380_dma_write_setup(instance, d, c);
-	local_irq_restore(flags);
-    }
-    
-    if (p & SR_IO)
-	NCR5380_write(START_DMA_INITIATOR_RECEIVE_REG, 0);
-    else {
-	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);
-	NCR5380_write(START_DMA_SEND_REG, 0);
-    }
-
-    if (!IS_A_TT()) {
-	/* On the Falcon, the DMA setup must be done after the last */
-	/* NCR access, else the DMA setup gets trashed!
-	 */
-	local_irq_save(flags);
-	hostdata->dma_len = (p & SR_IO) ?
-	    NCR5380_dma_read_setup(instance, d, c) : 
-	    NCR5380_dma_write_setup(instance, d, c);
-	local_irq_restore(flags);
-    }
-    return 0;
+	if (IS_A_TT()) {
+		/* On the Medusa, it is a must to initialize the DMA before
+		 * starting the NCR. This is also the cleaner way for the TT.
+		 */
+		local_irq_save(flags);
+		hostdata->dma_len = (p & SR_IO) ?
+			NCR5380_dma_read_setup(instance, d, c) :
+			NCR5380_dma_write_setup(instance, d, c);
+		local_irq_restore(flags);
+	}
+
+	if (p & SR_IO)
+		NCR5380_write(START_DMA_INITIATOR_RECEIVE_REG, 0);
+	else {
+		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_DATA);
+		NCR5380_write(START_DMA_SEND_REG, 0);
+	}
+
+	if (!IS_A_TT()) {
+		/* On the Falcon, the DMA setup must be done after the last */
+		/* NCR access, else the DMA setup gets trashed!
+		 */
+		local_irq_save(flags);
+		hostdata->dma_len = (p & SR_IO) ?
+			NCR5380_dma_read_setup(instance, d, c) :
+			NCR5380_dma_write_setup(instance, d, c);
+		local_irq_restore(flags);
+	}
+	return 0;
@@ -1974,2 +1985,2 @@
- * Purpose : run through the various SCSI phases and do as the target 
- * 	directs us to.  Operates on the currently connected command, 
+ * Purpose : run through the various SCSI phases and do as the target
+ *	directs us to.  Operates on the currently connected command,
@@ -1980 +1991 @@
- * Side effects : SCSI things happen, the disconnected queue will be 
+ * Side effects : SCSI things happen, the disconnected queue will be
@@ -1984,2 +1995,2 @@
- * XXX Note : we need to watch for bus free or a reset condition here 
- * 	to recover from an unexpected bus free condition.
+ * XXX Note : we need to watch for bus free or a reset condition here
+ *	to recover from an unexpected bus free condition.
@@ -1987,2 +1998,2 @@
- 
-static void NCR5380_information_transfer (struct Scsi_Host *instance)
+
+static void NCR5380_information_transfer(struct Scsi_Host *instance)
@@ -1990,5 +2001,5 @@
-    SETUP_HOSTDATA(instance);
-    unsigned long flags;
-    unsigned char msgout = NOP;
-    int sink = 0;
-    int len;
+	SETUP_HOSTDATA(instance);
+	unsigned long flags;
+	unsigned char msgout = NOP;
+	int sink = 0;
+	int len;
@@ -1996,38 +2007 @@
-    int transfersize;
-#endif
-    unsigned char *data;
-    unsigned char phase, tmp, extended_msg[10], old_phase=0xff;
-    Scsi_Cmnd *cmd = (Scsi_Cmnd *) hostdata->connected;
-
-    while (1) {
-	tmp = NCR5380_read(STATUS_REG);
-	/* We only have a valid SCSI phase when REQ is asserted */
-	if (tmp & SR_REQ) {
-	    phase = (tmp & PHASE_MASK); 
-	    if (phase != old_phase) {
-		old_phase = phase;
-		NCR_PRINT_PHASE(NDEBUG_INFORMATION);
-	    }
-	    
-	    if (sink && (phase != PHASE_MSGOUT)) {
-		NCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(tmp));
-
-		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN | 
-		    ICR_ASSERT_ACK);
-		while (NCR5380_read(STATUS_REG) & SR_REQ);
-		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | 
-		    ICR_ASSERT_ATN);
-		sink = 0;
-		continue;
-	    }
-
-	    switch (phase) {
-	    case PHASE_DATAOUT:
-#if (NDEBUG & NDEBUG_NO_DATAOUT)
-		printk("scsi%d: NDEBUG_NO_DATAOUT set, attempted DATAOUT "
-		       "aborted\n", HOSTNO);
-		sink = 1;
-		do_abort(instance);
-		cmd->result = DID_ERROR  << 16;
-		cmd->done(cmd);
-		return;
+	int transfersize;
@@ -2035,5 +2009,13 @@
-	    case PHASE_DATAIN:
-		/* 
-		 * If there is no room left in the current buffer in the
-		 * scatter-gather list, move onto the next one.
-		 */
+	unsigned char *data;
+	unsigned char phase, tmp, extended_msg[10], old_phase = 0xff;
+	Scsi_Cmnd *cmd = (Scsi_Cmnd *) hostdata->connected;
+
+	while (1) {
+		tmp = NCR5380_read(STATUS_REG);
+		/* We only have a valid SCSI phase when REQ is asserted */
+		if (tmp & SR_REQ) {
+			phase = (tmp & PHASE_MASK);
+			if (phase != old_phase) {
+				old_phase = phase;
+				NCR_PRINT_PHASE(NDEBUG_INFORMATION);
+			}
@@ -2041,14 +2023,2 @@
-		if (!cmd->SCp.this_residual && cmd->SCp.buffers_residual) {
-		    ++cmd->SCp.buffer;
-		    --cmd->SCp.buffers_residual;
-		    cmd->SCp.this_residual = cmd->SCp.buffer->length;
-		    cmd->SCp.ptr = page_address(cmd->SCp.buffer->page)+
-				   cmd->SCp.buffer->offset;
-		    /* ++roman: Try to merge some scatter-buffers if
-		     * they are at contiguous physical addresses.
-		     */
-		    merge_contiguous_buffers( cmd );
-		    INF_PRINTK("scsi%d: %d bytes and %d buffers left\n",
-			       HOSTNO, cmd->SCp.this_residual,
-			       cmd->SCp.buffers_residual);
-		}
+			if (sink && (phase != PHASE_MSGOUT)) {
+				NCR5380_write(TARGET_COMMAND_REG, PHASE_SR_TO_TCR(tmp));
@@ -2056,9 +2026,9 @@
-		/*
-		 * The preferred transfer method is going to be 
-		 * PSEUDO-DMA for systems that are strictly PIO,
-		 * since we can let the hardware do the handshaking.
-		 *
-		 * For this to work, we need to know the transfersize
-		 * ahead of time, since the pseudo-DMA code will sit
-		 * in an unconditional loop.
-		 */
+				NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN |
+					      ICR_ASSERT_ACK);
+				while (NCR5380_read(STATUS_REG) & SR_REQ)
+					;
+				NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |
+					      ICR_ASSERT_ATN);
+				sink = 0;
+				continue;
+			}
@@ -2066,4 +2036,46 @@
-/* ++roman: I suggest, this should be
- *   #if def(REAL_DMA)
- * instead of leaving REAL_DMA out.
- */
+			switch (phase) {
+			case PHASE_DATAOUT:
+#if (NDEBUG & NDEBUG_NO_DATAOUT)
+				printk("scsi%d: NDEBUG_NO_DATAOUT set, attempted DATAOUT "
+				       "aborted\n", HOSTNO);
+				sink = 1;
+				do_abort(instance);
+				cmd->result = DID_ERROR << 16;
+				cmd->done(cmd);
+				return;
+#endif
+			case PHASE_DATAIN:
+				/*
+				 * If there is no room left in the current buffer in the
+				 * scatter-gather list, move onto the next one.
+				 */
+
+				if (!cmd->SCp.this_residual && cmd->SCp.buffers_residual) {
+					++cmd->SCp.buffer;
+					--cmd->SCp.buffers_residual;
+					cmd->SCp.this_residual = cmd->SCp.buffer->length;
+					cmd->SCp.ptr = page_address(cmd->SCp.buffer->page) +
+						   cmd->SCp.buffer->offset;
+					/* ++roman: Try to merge some scatter-buffers if
+					 * they are at contiguous physical addresses.
+					 */
+					merge_contiguous_buffers(cmd);
+					INF_PRINTK("scsi%d: %d bytes and %d buffers left\n",
+						   HOSTNO, cmd->SCp.this_residual,
+						   cmd->SCp.buffers_residual);
+				}
+
+				/*
+				 * The preferred transfer method is going to be
+				 * PSEUDO-DMA for systems that are strictly PIO,
+				 * since we can let the hardware do the handshaking.
+				 *
+				 * For this to work, we need to know the transfersize
+				 * ahead of time, since the pseudo-DMA code will sit
+				 * in an unconditional loop.
+				 */
+
+				/* ++roman: I suggest, this should be
+				 *   #if def(REAL_DMA)
+				 * instead of leaving REAL_DMA out.
+				 */
@@ -2072,22 +2084,22 @@
-		if (!cmd->device->borken &&
-		    (transfersize = NCR5380_dma_xfer_len(instance,cmd,phase)) > 31) {
-		    len = transfersize;
-		    cmd->SCp.phase = phase;
-		    if (NCR5380_transfer_dma(instance, &phase,
-			&len, (unsigned char **) &cmd->SCp.ptr)) {
-			/*
-			 * If the watchdog timer fires, all future
-			 * accesses to this device will use the
-			 * polled-IO. */ 
-			printk(KERN_NOTICE "scsi%d: switching target %d "
-			       "lun %d to slow handshake\n", HOSTNO,
-			       cmd->device->id, cmd->device->lun);
-			cmd->device->borken = 1;
-			NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | 
-			    ICR_ASSERT_ATN);
-			sink = 1;
-			do_abort(instance);
-			cmd->result = DID_ERROR  << 16;
-			cmd->done(cmd);
-			/* XXX - need to source or sink data here, as appropriate */
-		    } else {
+				if (!cmd->device->borken &&
+				    (transfersize = NCR5380_dma_xfer_len(instance,cmd,phase)) > 31) {
+					len = transfersize;
+					cmd->SCp.phase = phase;
+					if (NCR5380_transfer_dma(instance, &phase,
+					    &len, (unsigned char **)&cmd->SCp.ptr)) {
+						/*
+						 * If the watchdog timer fires, all future
+						 * accesses to this device will use the
+						 * polled-IO. */
+						printk(KERN_NOTICE "scsi%d: switching target %d "
+							   "lun %d to slow handshake\n", HOSTNO,
+							   cmd->device->id, cmd->device->lun);
+						cmd->device->borken = 1;
+						NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE |
+							ICR_ASSERT_ATN);
+						sink = 1;
+						do_abort(instance);
+						cmd->result = DID_ERROR << 16;
+						cmd->done(cmd);
+						/* XXX - need to source or sink data here, as appropriate */
+					} else {
@@ -2095,8 +2107,8 @@
-			/* ++roman: When using real DMA,
-			 * information_transfer() should return after
-			 * starting DMA since it has nothing more to
-			 * do.
-			 */
-			return;
-#else			
-			cmd->SCp.this_residual -= transfersize - len;
+						/* ++roman: When using real DMA,
+						 * information_transfer() should return after
+						 * starting DMA since it has nothing more to
+						 * do.
+						 */
+						return;
+#else
+						cmd->SCp.this_residual -= transfersize - len;
@@ -2104,2 +2116,2 @@
-		    }
-		} else
+					}
+				} else
@@ -2107,22 +2119,22 @@
-		  NCR5380_transfer_pio(instance, &phase, 
-		    (int *) &cmd->SCp.this_residual, (unsigned char **)
-		    &cmd->SCp.ptr);
-		break;
-	    case PHASE_MSGIN:
-		len = 1;
-		data = &tmp;
-		NCR5380_write(SELECT_ENABLE_REG, 0); 	/* disable reselects */
-		NCR5380_transfer_pio(instance, &phase, &len, &data);
-		cmd->SCp.Message = tmp;
-
-		switch (tmp) {
-		/*
-		 * Linking lets us reduce the time required to get the 
-		 * next command out to the device, hopefully this will
-		 * mean we don't waste another revolution due to the delays
-		 * required by ARBITRATION and another SELECTION.
-		 *
-		 * In the current implementation proposal, low level drivers
-		 * merely have to start the next command, pointed to by 
-		 * next_link, done() is called as with unlinked commands.
-		 */
+					NCR5380_transfer_pio(instance, &phase,
+							     (int *)&cmd->SCp.this_residual,
+							     (unsigned char **)&cmd->SCp.ptr);
+				break;
+			case PHASE_MSGIN:
+				len = 1;
+				data = &tmp;
+				NCR5380_write(SELECT_ENABLE_REG, 0);	/* disable reselects */
+				NCR5380_transfer_pio(instance, &phase, &len, &data);
+				cmd->SCp.Message = tmp;
+
+				switch (tmp) {
+				/*
+				 * Linking lets us reduce the time required to get the
+				 * next command out to the device, hopefully this will
+				 * mean we don't waste another revolution due to the delays
+				 * required by ARBITRATION and another SELECTION.
+				 *
+				 * In the current implementation proposal, low level drivers
+				 * merely have to start the next command, pointed to by
+				 * next_link, done() is called as with unlinked commands.
+				 */
@@ -2130,33 +2142,33 @@
-		case LINKED_CMD_COMPLETE:
-		case LINKED_FLG_CMD_COMPLETE:
-		    /* Accept message by clearing ACK */
-		    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-		    
-		    LNK_PRINTK("scsi%d: target %d lun %d linked command "
-			       "complete.\n", HOSTNO, cmd->device->id, cmd->device->lun);
-
-		    /* Enable reselect interrupts */
-		    NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
-		    /*
-		     * Sanity check : A linked command should only terminate
-		     * with one of these messages if there are more linked
-		     * commands available.
-		     */
-
-		    if (!cmd->next_link) {
-			 printk(KERN_NOTICE "scsi%d: target %d lun %d "
-				"linked command complete, no next_link\n",
-				HOSTNO, cmd->device->id, cmd->device->lun);
-			    sink = 1;
-			    do_abort (instance);
-			    return;
-		    }
-
-		    initialize_SCp(cmd->next_link);
-		    /* The next command is still part of this process; copy it
-		     * and don't free it! */
-		    cmd->next_link->tag = cmd->tag;
-		    cmd->result = cmd->SCp.Status | (cmd->SCp.Message << 8); 
-		    LNK_PRINTK("scsi%d: target %d lun %d linked request "
-			       "done, calling scsi_done().\n",
-			       HOSTNO, cmd->device->id, cmd->device->lun);
+				case LINKED_CMD_COMPLETE:
+				case LINKED_FLG_CMD_COMPLETE:
+					/* Accept message by clearing ACK */
+					NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+
+					LNK_PRINTK("scsi%d: target %d lun %d linked command "
+						   "complete.\n", HOSTNO, cmd->device->id, cmd->device->lun);
+
+					/* Enable reselect interrupts */
+					NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+					/*
+					 * Sanity check : A linked command should only terminate
+					 * with one of these messages if there are more linked
+					 * commands available.
+					 */
+
+					if (!cmd->next_link) {
+						 printk(KERN_NOTICE "scsi%d: target %d lun %d "
+							"linked command complete, no next_link\n",
+							HOSTNO, cmd->device->id, cmd->device->lun);
+						sink = 1;
+						do_abort(instance);
+						return;
+					}
+
+					initialize_SCp(cmd->next_link);
+					/* The next command is still part of this process; copy it
+					 * and don't free it! */
+					cmd->next_link->tag = cmd->tag;
+					cmd->result = cmd->SCp.Status | (cmd->SCp.Message << 8);
+					LNK_PRINTK("scsi%d: target %d lun %d linked request "
+						   "done, calling scsi_done().\n",
+						   HOSTNO, cmd->device->id, cmd->device->lun);
@@ -2164 +2176 @@
-		    collect_stats(hostdata, cmd);
+					collect_stats(hostdata, cmd);
@@ -2166,3 +2178,3 @@
-		    cmd->scsi_done(cmd);
-		    cmd = hostdata->connected;
-		    break;
+					cmd->scsi_done(cmd);
+					cmd = hostdata->connected;
+					break;
@@ -2170,9 +2182,9 @@
-		case ABORT:
-		case COMMAND_COMPLETE: 
-		    /* Accept message by clearing ACK */
-		    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-		    /* ++guenther: possible race with Falcon locking */
-		    falcon_dont_release++;
-		    hostdata->connected = NULL;
-		    QU_PRINTK("scsi%d: command for target %d, lun %d "
-			      "completed\n", HOSTNO, cmd->device->id, cmd->device->lun);
+				case ABORT:
+				case COMMAND_COMPLETE:
+					/* Accept message by clearing ACK */
+					NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+					/* ++guenther: possible race with Falcon locking */
+					falcon_dont_release++;
+					hostdata->connected = NULL;
+					QU_PRINTK("scsi%d: command for target %d, lun %d "
+						  "completed\n", HOSTNO, cmd->device->id, cmd->device->lun);
@@ -2180,18 +2192,18 @@
-		    cmd_free_tag( cmd );
-		    if (status_byte(cmd->SCp.Status) == QUEUE_FULL) {
-			/* Turn a QUEUE FULL status into BUSY, I think the
-			 * mid level cannot handle QUEUE FULL :-( (The
-			 * command is retried after BUSY). Also update our
-			 * queue size to the number of currently issued
-			 * commands now.
-			 */
-			/* ++Andreas: the mid level code knows about
-			   QUEUE_FULL now. */
-			TAG_ALLOC *ta = &TagAlloc[cmd->device->id][cmd->device->lun];
-			TAG_PRINTK("scsi%d: target %d lun %d returned "
-				   "QUEUE_FULL after %d commands\n",
-				   HOSTNO, cmd->device->id, cmd->device->lun,
-				   ta->nr_allocated);
-			if (ta->queue_size > ta->nr_allocated)
-			    ta->nr_allocated = ta->queue_size;
-		    }
+					cmd_free_tag(cmd);
+					if (status_byte(cmd->SCp.Status) == QUEUE_FULL) {
+						/* Turn a QUEUE FULL status into BUSY, I think the
+						 * mid level cannot handle QUEUE FULL :-( (The
+						 * command is retried after BUSY). Also update our
+						 * queue size to the number of currently issued
+						 * commands now.
+						 */
+						/* ++Andreas: the mid level code knows about
+						   QUEUE_FULL now. */
+						TAG_ALLOC *ta = &TagAlloc[cmd->device->id][cmd->device->lun];
+						TAG_PRINTK("scsi%d: target %d lun %d returned "
+							   "QUEUE_FULL after %d commands\n",
+							   HOSTNO, cmd->device->id, cmd->device->lun,
+							   ta->nr_allocated);
+						if (ta->queue_size > ta->nr_allocated)
+							ta->nr_allocated = ta->queue_size;
+					}
@@ -2199 +2211 @@
-		    hostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);
+					hostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);
@@ -2201,2 +2213,2 @@
-		    /* Enable reselect interrupts */
-		    NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+					/* Enable reselect interrupts */
+					NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
@@ -2204,41 +2216,20 @@
-		    /* 
-		     * I'm not sure what the correct thing to do here is : 
-		     * 
-		     * If the command that just executed is NOT a request 
-		     * sense, the obvious thing to do is to set the result
-		     * code to the values of the stored parameters.
-		     * 
-		     * If it was a REQUEST SENSE command, we need some way to
-		     * differentiate between the failure code of the original
-		     * and the failure code of the REQUEST sense - the obvious
-		     * case is success, where we fall through and leave the
-		     * result code unchanged.
-		     * 
-		     * The non-obvious place is where the REQUEST SENSE failed
-		     */
-
-		    if (cmd->cmnd[0] != REQUEST_SENSE) 
-			cmd->result = cmd->SCp.Status | (cmd->SCp.Message << 8); 
-		    else if (status_byte(cmd->SCp.Status) != GOOD)
-			cmd->result = (cmd->result & 0x00ffff) | (DID_ERROR << 16);
-		    
-#ifdef AUTOSENSE
-		    if ((cmd->cmnd[0] != REQUEST_SENSE) && 
-			(status_byte(cmd->SCp.Status) == CHECK_CONDITION)) {
-			ASEN_PRINTK("scsi%d: performing request sense\n",
-				    HOSTNO);
-			cmd->cmnd[0] = REQUEST_SENSE;
-			cmd->cmnd[1] &= 0xe0;
-			cmd->cmnd[2] = 0;
-			cmd->cmnd[3] = 0;
-			cmd->cmnd[4] = sizeof(cmd->sense_buffer);
-			cmd->cmnd[5] = 0;
-			cmd->cmd_len = COMMAND_SIZE(cmd->cmnd[0]);
-
-			cmd->use_sg = 0;
-			/* this is initialized from initialize_SCp 
-			cmd->SCp.buffer = NULL;
-			cmd->SCp.buffers_residual = 0;
-			*/
-			cmd->request_buffer = (char *) cmd->sense_buffer;
-			cmd->request_bufflen = sizeof(cmd->sense_buffer);
+					/*
+					 * I'm not sure what the correct thing to do here is :
+					 *
+					 * If the command that just executed is NOT a request
+					 * sense, the obvious thing to do is to set the result
+					 * code to the values of the stored parameters.
+					 *
+					 * If it was a REQUEST SENSE command, we need some way to
+					 * differentiate between the failure code of the original
+					 * and the failure code of the REQUEST sense - the obvious
+					 * case is success, where we fall through and leave the
+					 * result code unchanged.
+					 *
+					 * The non-obvious place is where the REQUEST SENSE failed
+					 */
+
+					if (cmd->cmnd[0] != REQUEST_SENSE)
+						cmd->result = cmd->SCp.Status | (cmd->SCp.Message << 8);
+					else if (status_byte(cmd->SCp.Status) != GOOD)
+						cmd->result = (cmd->result & 0x00ffff) | (DID_ERROR << 16);
@@ -2246,8 +2237,28 @@
-			local_irq_save(flags);
-			LIST(cmd,hostdata->issue_queue);
-			NEXT(cmd) = hostdata->issue_queue;
-		        hostdata->issue_queue = (Scsi_Cmnd *) cmd;
-		        local_irq_restore(flags);
-			QU_PRINTK("scsi%d: REQUEST SENSE added to head of "
-				  "issue queue\n", H_NO(cmd));
-		   } else
+#ifdef AUTOSENSE
+					if ((cmd->cmnd[0] != REQUEST_SENSE) &&
+					    (status_byte(cmd->SCp.Status) == CHECK_CONDITION)) {
+						ASEN_PRINTK("scsi%d: performing request sense\n", HOSTNO);
+						cmd->cmnd[0] = REQUEST_SENSE;
+						cmd->cmnd[1] &= 0xe0;
+						cmd->cmnd[2] = 0;
+						cmd->cmnd[3] = 0;
+						cmd->cmnd[4] = sizeof(cmd->sense_buffer);
+						cmd->cmnd[5] = 0;
+						cmd->cmd_len = COMMAND_SIZE(cmd->cmnd[0]);
+
+						cmd->use_sg = 0;
+						/* this is initialized from initialize_SCp
+						cmd->SCp.buffer = NULL;
+						cmd->SCp.buffers_residual = 0;
+						*/
+						cmd->request_buffer = (char *) cmd->sense_buffer;
+						cmd->request_bufflen = sizeof(cmd->sense_buffer);
+
+						local_irq_save(flags);
+						LIST(cmd,hostdata->issue_queue);
+						SET_NEXT(cmd, hostdata->issue_queue);
+						hostdata->issue_queue = (Scsi_Cmnd *) cmd;
+						local_irq_restore(flags);
+						QU_PRINTK("scsi%d: REQUEST SENSE added to head of "
+							  "issue queue\n", H_NO(cmd));
+					} else
@@ -2255 +2266 @@
-		   {
+					{
@@ -2257 +2268 @@
-		       collect_stats(hostdata, cmd);
+						collect_stats(hostdata, cmd);
@@ -2259,2 +2270,2 @@
-		       cmd->scsi_done(cmd);
-		    }
+						cmd->scsi_done(cmd);
+					}
@@ -2262,175 +2273,174 @@
-		    NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
-		    /* 
-		     * Restore phase bits to 0 so an interrupted selection, 
-		     * arbitration can resume.
-		     */
-		    NCR5380_write(TARGET_COMMAND_REG, 0);
-		    
-		    while ((NCR5380_read(STATUS_REG) & SR_BSY) && !hostdata->connected)
-			barrier();
-
-		    falcon_dont_release--;
-		    /* ++roman: For Falcon SCSI, release the lock on the
-		     * ST-DMA here if no other commands are waiting on the
-		     * disconnected queue.
-		     */
-		    falcon_release_lock_if_possible( hostdata );
-		    return;
-		case MESSAGE_REJECT:
-		    /* Accept message by clearing ACK */
-		    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-		    /* Enable reselect interrupts */
-		    NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
-		    switch (hostdata->last_message) {
-		    case HEAD_OF_QUEUE_TAG:
-		    case ORDERED_QUEUE_TAG:
-		    case SIMPLE_QUEUE_TAG:
-			/* The target obviously doesn't support tagged
-			 * queuing, even though it announced this ability in
-			 * its INQUIRY data ?!? (maybe only this LUN?) Ok,
-			 * clear 'tagged_supported' and lock the LUN, since
-			 * the command is treated as untagged further on.
-			 */
-			cmd->device->tagged_supported = 0;
-			hostdata->busy[cmd->device->id] |= (1 << cmd->device->lun);
-			cmd->tag = TAG_NONE;
-			TAG_PRINTK("scsi%d: target %d lun %d rejected "
-				   "QUEUE_TAG message; tagged queuing "
-				   "disabled\n",
-				   HOSTNO, cmd->device->id, cmd->device->lun);
-			break;
-		    }
-		    break;
-		case DISCONNECT:
-		    /* Accept message by clearing ACK */
-		    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-		    local_irq_save(flags);
-		    cmd->device->disconnect = 1;
-		    LIST(cmd,hostdata->disconnected_queue);
-		    NEXT(cmd) = hostdata->disconnected_queue;
-		    hostdata->connected = NULL;
-		    hostdata->disconnected_queue = cmd;
-		    local_irq_restore(flags);
-		    QU_PRINTK("scsi%d: command for target %d lun %d was "
-			      "moved from connected to the "
-			      "disconnected_queue\n", HOSTNO, 
-			      cmd->device->id, cmd->device->lun);
-		    /* 
-		     * Restore phase bits to 0 so an interrupted selection, 
-		     * arbitration can resume.
-		     */
-		    NCR5380_write(TARGET_COMMAND_REG, 0);
-
-		    /* Enable reselect interrupts */
-		    NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
-		    /* Wait for bus free to avoid nasty timeouts */
-		    while ((NCR5380_read(STATUS_REG) & SR_BSY) && !hostdata->connected)
-		    	barrier();
-		    return;
-		/* 
-		 * The SCSI data pointer is *IMPLICITLY* saved on a disconnect
-		 * operation, in violation of the SCSI spec so we can safely 
-		 * ignore SAVE/RESTORE pointers calls.
-		 *
-		 * Unfortunately, some disks violate the SCSI spec and 
-		 * don't issue the required SAVE_POINTERS message before
-		 * disconnecting, and we have to break spec to remain 
-		 * compatible.
-		 */
-		case SAVE_POINTERS:
-		case RESTORE_POINTERS:
-		    /* Accept message by clearing ACK */
-		    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-		    /* Enable reselect interrupts */
-		    NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
-		    break;
-		case EXTENDED_MESSAGE:
-/* 
- * Extended messages are sent in the following format :
- * Byte 	
- * 0		EXTENDED_MESSAGE == 1
- * 1		length (includes one byte for code, doesn't 
- *		include first two bytes)
- * 2 		code
- * 3..length+1	arguments
- *
- * Start the extended message buffer with the EXTENDED_MESSAGE
- * byte, since spi_print_msg() wants the whole thing.  
- */
-		    extended_msg[0] = EXTENDED_MESSAGE;
-		    /* Accept first byte by clearing ACK */
-		    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-
-		    EXT_PRINTK("scsi%d: receiving extended message\n", HOSTNO);
-
-		    len = 2;
-		    data = extended_msg + 1;
-		    phase = PHASE_MSGIN;
-		    NCR5380_transfer_pio(instance, &phase, &len, &data);
-		    EXT_PRINTK("scsi%d: length=%d, code=0x%02x\n", HOSTNO,
-			       (int)extended_msg[1], (int)extended_msg[2]);
-
-		    if (!len && extended_msg[1] <= 
-			(sizeof (extended_msg) - 1)) {
-			/* Accept third byte by clearing ACK */
-			NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-			len = extended_msg[1] - 1;
-			data = extended_msg + 3;
-			phase = PHASE_MSGIN;
-
-			NCR5380_transfer_pio(instance, &phase, &len, &data);
-			EXT_PRINTK("scsi%d: message received, residual %d\n",
-				   HOSTNO, len);
-
-			switch (extended_msg[2]) {
-			case EXTENDED_SDTR:
-			case EXTENDED_WDTR:
-			case EXTENDED_MODIFY_DATA_POINTER:
-			case EXTENDED_EXTENDED_IDENTIFY:
-			    tmp = 0;
-			}
-		    } else if (len) {
-			printk(KERN_NOTICE "scsi%d: error receiving "
-			       "extended message\n", HOSTNO);
-			tmp = 0;
-		    } else {
-			printk(KERN_NOTICE "scsi%d: extended message "
-			       "code %02x length %d is too long\n",
-			       HOSTNO, extended_msg[2], extended_msg[1]);
-			tmp = 0;
-		    }
-		/* Fall through to reject message */
-
-		/* 
-  		 * If we get something weird that we aren't expecting, 
- 		 * reject it.
-		 */
-		default:
-		    if (!tmp) {
-			printk(KERN_DEBUG "scsi%d: rejecting message ", HOSTNO);
-			spi_print_msg(extended_msg);
-			printk("\n");
-		    } else if (tmp != EXTENDED_MESSAGE)
-			printk(KERN_DEBUG "scsi%d: rejecting unknown "
-			       "message %02x from target %d, lun %d\n",
-			       HOSTNO, tmp, cmd->device->id, cmd->device->lun);
-		    else
-			printk(KERN_DEBUG "scsi%d: rejecting unknown "
-			       "extended message "
-			       "code %02x, length %d from target %d, lun %d\n",
-			       HOSTNO, extended_msg[1], extended_msg[0],
-			       cmd->device->id, cmd->device->lun);
-   
-
-		    msgout = MESSAGE_REJECT;
-		    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | 
-			ICR_ASSERT_ATN);
-		    break;
-		} /* switch (tmp) */
-		break;
-	    case PHASE_MSGOUT:
-		len = 1;
-		data = &msgout;
-		hostdata->last_message = msgout;
-		NCR5380_transfer_pio(instance, &phase, &len, &data);
-		if (msgout == ABORT) {
+					NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+					/*
+					 * Restore phase bits to 0 so an interrupted selection,
+					 * arbitration can resume.
+					 */
+					NCR5380_write(TARGET_COMMAND_REG, 0);
+
+					while ((NCR5380_read(STATUS_REG) & SR_BSY) && !hostdata->connected)
+						barrier();
+
+					falcon_dont_release--;
+					/* ++roman: For Falcon SCSI, release the lock on the
+					 * ST-DMA here if no other commands are waiting on the
+					 * disconnected queue.
+					 */
+					falcon_release_lock_if_possible(hostdata);
+					return;
+				case MESSAGE_REJECT:
+					/* Accept message by clearing ACK */
+					NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+					/* Enable reselect interrupts */
+					NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+					switch (hostdata->last_message) {
+					case HEAD_OF_QUEUE_TAG:
+					case ORDERED_QUEUE_TAG:
+					case SIMPLE_QUEUE_TAG:
+						/* The target obviously doesn't support tagged
+						 * queuing, even though it announced this ability in
+						 * its INQUIRY data ?!? (maybe only this LUN?) Ok,
+						 * clear 'tagged_supported' and lock the LUN, since
+						 * the command is treated as untagged further on.
+						 */
+						cmd->device->tagged_supported = 0;
+						hostdata->busy[cmd->device->id] |= (1 << cmd->device->lun);
+						cmd->tag = TAG_NONE;
+						TAG_PRINTK("scsi%d: target %d lun %d rejected "
+							   "QUEUE_TAG message; tagged queuing "
+							   "disabled\n",
+							   HOSTNO, cmd->device->id, cmd->device->lun);
+						break;
+					}
+					break;
+				case DISCONNECT:
+					/* Accept message by clearing ACK */
+					NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+					local_irq_save(flags);
+					cmd->device->disconnect = 1;
+					LIST(cmd,hostdata->disconnected_queue);
+					SET_NEXT(cmd, hostdata->disconnected_queue);
+					hostdata->connected = NULL;
+					hostdata->disconnected_queue = cmd;
+					local_irq_restore(flags);
+					QU_PRINTK("scsi%d: command for target %d lun %d was "
+						  "moved from connected to the "
+						  "disconnected_queue\n", HOSTNO,
+						  cmd->device->id, cmd->device->lun);
+					/*
+					 * Restore phase bits to 0 so an interrupted selection,
+					 * arbitration can resume.
+					 */
+					NCR5380_write(TARGET_COMMAND_REG, 0);
+
+					/* Enable reselect interrupts */
+					NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+					/* Wait for bus free to avoid nasty timeouts */
+					while ((NCR5380_read(STATUS_REG) & SR_BSY) && !hostdata->connected)
+						barrier();
+					return;
+					/*
+					 * The SCSI data pointer is *IMPLICITLY* saved on a disconnect
+					 * operation, in violation of the SCSI spec so we can safely
+					 * ignore SAVE/RESTORE pointers calls.
+					 *
+					 * Unfortunately, some disks violate the SCSI spec and
+					 * don't issue the required SAVE_POINTERS message before
+					 * disconnecting, and we have to break spec to remain
+					 * compatible.
+					 */
+				case SAVE_POINTERS:
+				case RESTORE_POINTERS:
+					/* Accept message by clearing ACK */
+					NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+					/* Enable reselect interrupts */
+					NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+					break;
+				case EXTENDED_MESSAGE:
+					/*
+					 * Extended messages are sent in the following format :
+					 * Byte
+					 * 0		EXTENDED_MESSAGE == 1
+					 * 1		length (includes one byte for code, doesn't
+					 *		include first two bytes)
+					 * 2		code
+					 * 3..length+1	arguments
+					 *
+					 * Start the extended message buffer with the EXTENDED_MESSAGE
+					 * byte, since spi_print_msg() wants the whole thing.
+					 */
+					extended_msg[0] = EXTENDED_MESSAGE;
+					/* Accept first byte by clearing ACK */
+					NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+
+					EXT_PRINTK("scsi%d: receiving extended message\n", HOSTNO);
+
+					len = 2;
+					data = extended_msg + 1;
+					phase = PHASE_MSGIN;
+					NCR5380_transfer_pio(instance, &phase, &len, &data);
+					EXT_PRINTK("scsi%d: length=%d, code=0x%02x\n", HOSTNO,
+						   (int)extended_msg[1], (int)extended_msg[2]);
+
+					if (!len && extended_msg[1] <=
+					    (sizeof(extended_msg) - 1)) {
+						/* Accept third byte by clearing ACK */
+						NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+						len = extended_msg[1] - 1;
+						data = extended_msg + 3;
+						phase = PHASE_MSGIN;
+
+						NCR5380_transfer_pio(instance, &phase, &len, &data);
+						EXT_PRINTK("scsi%d: message received, residual %d\n",
+							   HOSTNO, len);
+
+						switch (extended_msg[2]) {
+						case EXTENDED_SDTR:
+						case EXTENDED_WDTR:
+						case EXTENDED_MODIFY_DATA_POINTER:
+						case EXTENDED_EXTENDED_IDENTIFY:
+							tmp = 0;
+						}
+					} else if (len) {
+						printk(KERN_NOTICE "scsi%d: error receiving "
+						       "extended message\n", HOSTNO);
+						tmp = 0;
+					} else {
+						printk(KERN_NOTICE "scsi%d: extended message "
+							   "code %02x length %d is too long\n",
+							   HOSTNO, extended_msg[2], extended_msg[1]);
+						tmp = 0;
+					}
+					/* Fall through to reject message */
+
+					/*
+					 * If we get something weird that we aren't expecting,
+					 * reject it.
+					 */
+				default:
+					if (!tmp) {
+						printk(KERN_DEBUG "scsi%d: rejecting message ", HOSTNO);
+						spi_print_msg(extended_msg);
+						printk("\n");
+					} else if (tmp != EXTENDED_MESSAGE)
+						printk(KERN_DEBUG "scsi%d: rejecting unknown "
+						       "message %02x from target %d, lun %d\n",
+						       HOSTNO, tmp, cmd->device->id, cmd->device->lun);
+					else
+						printk(KERN_DEBUG "scsi%d: rejecting unknown "
+						       "extended message "
+						       "code %02x, length %d from target %d, lun %d\n",
+						       HOSTNO, extended_msg[1], extended_msg[0],
+						       cmd->device->id, cmd->device->lun);
+
+
+					msgout = MESSAGE_REJECT;
+					NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_ATN);
+					break;
+				} /* switch (tmp) */
+				break;
+			case PHASE_MSGOUT:
+				len = 1;
+				data = &msgout;
+				hostdata->last_message = msgout;
+				NCR5380_transfer_pio(instance, &phase, &len, &data);
+				if (msgout == ABORT) {
@@ -2438 +2448 @@
-		    cmd_free_tag( cmd );
+					cmd_free_tag(cmd);
@@ -2440 +2450 @@
-		    hostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);
+					hostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);
@@ -2442,2 +2452,2 @@
-		    hostdata->connected = NULL;
-		    cmd->result = DID_ERROR << 16;
+					hostdata->connected = NULL;
+					cmd->result = DID_ERROR << 16;
@@ -2445 +2455 @@
-		    collect_stats(hostdata, cmd);
+					collect_stats(hostdata, cmd);
@@ -2447,30 +2457,29 @@
-		    cmd->scsi_done(cmd);
-		    NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
-		    falcon_release_lock_if_possible( hostdata );
-		    return;
-		}
-		msgout = NOP;
-		break;
-	    case PHASE_CMDOUT:
-		len = cmd->cmd_len;
-		data = cmd->cmnd;
-		/* 
-		 * XXX for performance reasons, on machines with a 
-		 * PSEUDO-DMA architecture we should probably 
-		 * use the dma transfer function.  
-		 */
-		NCR5380_transfer_pio(instance, &phase, &len, 
-		    &data);
-		break;
-	    case PHASE_STATIN:
-		len = 1;
-		data = &tmp;
-		NCR5380_transfer_pio(instance, &phase, &len, &data);
-		cmd->SCp.Status = tmp;
-		break;
-	    default:
-		printk("scsi%d: unknown phase\n", HOSTNO);
-		NCR_PRINT(NDEBUG_ANY);
-	    } /* switch(phase) */
-	} /* if (tmp * SR_REQ) */ 
-    } /* while (1) */
+					cmd->scsi_done(cmd);
+					NCR5380_write(SELECT_ENABLE_REG, hostdata->id_mask);
+					falcon_release_lock_if_possible(hostdata);
+					return;
+				}
+				msgout = NOP;
+				break;
+			case PHASE_CMDOUT:
+				len = cmd->cmd_len;
+				data = cmd->cmnd;
+				/*
+				 * XXX for performance reasons, on machines with a
+				 * PSEUDO-DMA architecture we should probably
+				 * use the dma transfer function.
+				 */
+				NCR5380_transfer_pio(instance, &phase, &len, &data);
+				break;
+			case PHASE_STATIN:
+				len = 1;
+				data = &tmp;
+				NCR5380_transfer_pio(instance, &phase, &len, &data);
+				cmd->SCp.Status = tmp;
+				break;
+			default:
+				printk("scsi%d: unknown phase\n", HOSTNO);
+				NCR_PRINT(NDEBUG_ANY);
+			} /* switch(phase) */
+		} /* if (tmp * SR_REQ) */
+	} /* while (1) */
@@ -2482,2 +2491,2 @@
- * Purpose : does reselection, initializing the instance->connected 
- *	field to point to the Scsi_Cmnd for which the I_T_L or I_T_L_Q 
+ * Purpose : does reselection, initializing the instance->connected
+ *	field to point to the Scsi_Cmnd for which the I_T_L or I_T_L_Q
@@ -2485 +2494 @@
- *	
+ *
@@ -2491 +2500 @@
-static void NCR5380_reselect (struct Scsi_Host *instance)
+static void NCR5380_reselect(struct Scsi_Host *instance)
@@ -2493,4 +2502,4 @@
-    SETUP_HOSTDATA(instance);
-    unsigned char target_mask;
-    unsigned char lun, phase;
-    int len;
+	SETUP_HOSTDATA(instance);
+	unsigned char target_mask;
+	unsigned char lun, phase;
+	int len;
@@ -2498 +2507 @@
-    unsigned char tag;
+	unsigned char tag;
@@ -2500,49 +2509,51 @@
-    unsigned char msg[3];
-    unsigned char *data;
-    Scsi_Cmnd *tmp = NULL, *prev;
-/*    unsigned long flags; */
-
-    /*
-     * Disable arbitration, etc. since the host adapter obviously
-     * lost, and tell an interrupted NCR5380_select() to restart.
-     */
-
-    NCR5380_write(MODE_REG, MR_BASE);
-    hostdata->restart_select = 1;
-
-    target_mask = NCR5380_read(CURRENT_SCSI_DATA_REG) & ~(hostdata->id_mask);
-
-    RSL_PRINTK("scsi%d: reselect\n", HOSTNO);
-
-    /* 
-     * At this point, we have detected that our SCSI ID is on the bus,
-     * SEL is true and BSY was false for at least one bus settle delay
-     * (400 ns).
-     *
-     * We must assert BSY ourselves, until the target drops the SEL
-     * signal.
-     */
-
-    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_BSY);
-    
-    while (NCR5380_read(STATUS_REG) & SR_SEL);
-    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-
-    /*
-     * Wait for target to go into MSGIN.
-     */
-
-    while (!(NCR5380_read(STATUS_REG) & SR_REQ));
-
-    len = 1;
-    data = msg;
-    phase = PHASE_MSGIN;
-    NCR5380_transfer_pio(instance, &phase, &len, &data);
-
-    if (!(msg[0] & 0x80)) {
-	printk(KERN_DEBUG "scsi%d: expecting IDENTIFY message, got ", HOSTNO);
-	spi_print_msg(msg);
-	do_abort(instance);
-	return;
-    }
-    lun = (msg[0] & 0x07);
+	unsigned char msg[3];
+	unsigned char *data;
+	Scsi_Cmnd *tmp = NULL, *prev;
+/*	unsigned long flags; */
+
+	/*
+	 * Disable arbitration, etc. since the host adapter obviously
+	 * lost, and tell an interrupted NCR5380_select() to restart.
+	 */
+
+	NCR5380_write(MODE_REG, MR_BASE);
+	hostdata->restart_select = 1;
+
+	target_mask = NCR5380_read(CURRENT_SCSI_DATA_REG) & ~(hostdata->id_mask);
+
+	RSL_PRINTK("scsi%d: reselect\n", HOSTNO);
+
+	/*
+	 * At this point, we have detected that our SCSI ID is on the bus,
+	 * SEL is true and BSY was false for at least one bus settle delay
+	 * (400 ns).
+	 *
+	 * We must assert BSY ourselves, until the target drops the SEL
+	 * signal.
+	 */
+
+	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_BSY);
+
+	while (NCR5380_read(STATUS_REG) & SR_SEL)
+		;
+	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+
+	/*
+	 * Wait for target to go into MSGIN.
+	 */
+
+	while (!(NCR5380_read(STATUS_REG) & SR_REQ))
+		;
+
+	len = 1;
+	data = msg;
+	phase = PHASE_MSGIN;
+	NCR5380_transfer_pio(instance, &phase, &len, &data);
+
+	if (!(msg[0] & 0x80)) {
+		printk(KERN_DEBUG "scsi%d: expecting IDENTIFY message, got ", HOSTNO);
+		spi_print_msg(msg);
+		do_abort(instance);
+		return;
+	}
+	lun = (msg[0] & 0x07);
@@ -2551,26 +2562,26 @@
-    /* If the phase is still MSGIN, the target wants to send some more
-     * messages. In case it supports tagged queuing, this is probably a
-     * SIMPLE_QUEUE_TAG for the I_T_L_Q nexus.
-     */
-    tag = TAG_NONE;
-    if (phase == PHASE_MSGIN && setup_use_tagged_queuing) {
-	/* Accept previous IDENTIFY message by clearing ACK */
-	NCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE );
-	len = 2;
-	data = msg+1;
-	if (!NCR5380_transfer_pio(instance, &phase, &len, &data) &&
-	    msg[1] == SIMPLE_QUEUE_TAG)
-	    tag = msg[2];
-	TAG_PRINTK("scsi%d: target mask %02x, lun %d sent tag %d at "
-		   "reselection\n", HOSTNO, target_mask, lun, tag);
-    }
-#endif
-    
-    /* 
-     * Find the command corresponding to the I_T_L or I_T_L_Q  nexus we 
-     * just reestablished, and remove it from the disconnected queue.
-     */
-
-    for (tmp = (Scsi_Cmnd *) hostdata->disconnected_queue, prev = NULL; 
-	 tmp; prev = tmp, tmp = NEXT(tmp) ) {
-	if ((target_mask == (1 << tmp->device->id)) && (lun == tmp->device->lun)
+	/* If the phase is still MSGIN, the target wants to send some more
+	 * messages. In case it supports tagged queuing, this is probably a
+	 * SIMPLE_QUEUE_TAG for the I_T_L_Q nexus.
+	 */
+	tag = TAG_NONE;
+	if (phase == PHASE_MSGIN && setup_use_tagged_queuing) {
+		/* Accept previous IDENTIFY message by clearing ACK */
+		NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+		len = 2;
+		data = msg + 1;
+		if (!NCR5380_transfer_pio(instance, &phase, &len, &data) &&
+		    msg[1] == SIMPLE_QUEUE_TAG)
+			tag = msg[2];
+		TAG_PRINTK("scsi%d: target mask %02x, lun %d sent tag %d at "
+			   "reselection\n", HOSTNO, target_mask, lun, tag);
+	}
+#endif
+
+	/*
+	 * Find the command corresponding to the I_T_L or I_T_L_Q  nexus we
+	 * just reestablished, and remove it from the disconnected queue.
+	 */
+
+	for (tmp = (Scsi_Cmnd *) hostdata->disconnected_queue, prev = NULL;
+	     tmp; prev = tmp, tmp = NEXT(tmp)) {
+		if ((target_mask == (1 << tmp->device->id)) && (lun == tmp->device->lun)
@@ -2578 +2589 @@
-	    && (tag == tmp->tag) 
+		    && (tag == tmp->tag)
@@ -2580,17 +2591,17 @@
-	    ) {
-	    /* ++guenther: prevent race with falcon_release_lock */
-	    falcon_dont_release++;
-	    if (prev) {
-		REMOVE(prev, NEXT(prev), tmp, NEXT(tmp));
-		NEXT(prev) = NEXT(tmp);
-	    } else {
-		REMOVE(-1, hostdata->disconnected_queue, tmp, NEXT(tmp));
-		hostdata->disconnected_queue = NEXT(tmp);
-	    }
-	    NEXT(tmp) = NULL;
-	    break;
-	}
-    }
-    
-    if (!tmp) {
-	printk(KERN_WARNING "scsi%d: warning: target bitmask %02x lun %d "
+		    ) {
+			/* ++guenther: prevent race with falcon_release_lock */
+			falcon_dont_release++;
+			if (prev) {
+				REMOVE(prev, NEXT(prev), tmp, NEXT(tmp));
+				SET_NEXT(prev, NEXT(tmp));
+			} else {
+				REMOVE(-1, hostdata->disconnected_queue, tmp, NEXT(tmp));
+				hostdata->disconnected_queue = NEXT(tmp);
+			}
+			SET_NEXT(tmp, NULL);
+			break;
+		}
+	}
+
+	if (!tmp) {
+		printk(KERN_WARNING "scsi%d: warning: target bitmask %02x lun %d "
@@ -2598 +2609 @@
-		"tag %d "
+		       "tag %d "
@@ -2600,2 +2611,2 @@
-		"not in disconnected_queue.\n",
-		HOSTNO, target_mask, lun
+		       "not in disconnected_queue.\n",
+		       HOSTNO, target_mask, lun
@@ -2603 +2614 @@
-		, tag
+		       , tag
@@ -2605,16 +2616,16 @@
-		);
-	/* 
-	 * Since we have an established nexus that we can't do anything
-	 * with, we must abort it.  
-	 */
-	do_abort(instance);
-	return;
-    }
-
-    /* Accept message by clearing ACK */
-    NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
-
-    hostdata->connected = tmp;
-    RSL_PRINTK("scsi%d: nexus established, target = %d, lun = %d, tag = %d\n",
-	       HOSTNO, tmp->device->id, tmp->device->lun, tmp->tag);
-    falcon_dont_release--;
+			);
+		/*
+		 * Since we have an established nexus that we can't do anything
+		 * with, we must abort it.
+		 */
+		do_abort(instance);
+		return;
+	}
+
+	/* Accept message by clearing ACK */
+	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+
+	hostdata->connected = tmp;
+	RSL_PRINTK("scsi%d: nexus established, target = %d, lun = %d, tag = %d\n",
+		   HOSTNO, tmp->device->id, tmp->device->lun, tmp->tag);
+	falcon_dont_release--;
@@ -2629,2 +2640,2 @@
- * Inputs : cmd - the Scsi_Cmnd to abort, code - code to set the 
- * 	host byte of the result field to, if zero DID_ABORTED is 
+ * Inputs : cmd - the Scsi_Cmnd to abort, code - code to set the
+ *	host byte of the result field to, if zero DID_ABORTED is
@@ -2635,2 +2646,2 @@
- * XXX - there is no way to abort the command that is currently 
- * 	 connected, you have to wait for it to complete.  If this is 
+ * XXX - there is no way to abort the command that is currently
+ *	 connected, you have to wait for it to complete.  If this is
@@ -2638 +2649 @@
- * 	 called where the loop started in NCR5380_main().
+ *	 called where the loop started in NCR5380_main().
@@ -2642 +2653 @@
-int NCR5380_abort (Scsi_Cmnd *cmd)
+int NCR5380_abort(Scsi_Cmnd *cmd)
@@ -2644,19 +2655,19 @@
-    struct Scsi_Host *instance = cmd->device->host;
-    SETUP_HOSTDATA(instance);
-    Scsi_Cmnd *tmp, **prev;
-    unsigned long flags;
-
-    printk(KERN_NOTICE "scsi%d: aborting command\n", HOSTNO);
-    scsi_print_command(cmd);
-
-    NCR5380_print_status (instance);
-
-    local_irq_save(flags);
-    
-    if (!IS_A_TT() && !falcon_got_lock)
-	printk(KERN_ERR "scsi%d: !!BINGO!! Falcon has no lock in NCR5380_abort\n",
-	       HOSTNO);
-
-    ABRT_PRINTK("scsi%d: abort called basr 0x%02x, sr 0x%02x\n", HOSTNO,
-		NCR5380_read(BUS_AND_STATUS_REG),
-		NCR5380_read(STATUS_REG));
+	struct Scsi_Host *instance = cmd->device->host;
+	SETUP_HOSTDATA(instance);
+	Scsi_Cmnd *tmp, **prev;
+	unsigned long flags;
+
+	printk(KERN_NOTICE "scsi%d: aborting command\n", HOSTNO);
+	scsi_print_command(cmd);
+
+	NCR5380_print_status(instance);
+
+	local_irq_save(flags);
+
+	if (!IS_A_TT() && !falcon_got_lock)
+		printk(KERN_ERR "scsi%d: !!BINGO!! Falcon has no lock in NCR5380_abort\n",
+		       HOSTNO);
+
+	ABRT_PRINTK("scsi%d: abort called basr 0x%02x, sr 0x%02x\n", HOSTNO,
+		    NCR5380_read(BUS_AND_STATUS_REG),
+		    NCR5380_read(STATUS_REG));
@@ -2665,5 +2676,5 @@
-/* 
- * Case 1 : If the command is the currently executing command, 
- * we'll set the aborted flag and return control so that 
- * information transfer routine can exit cleanly.
- */
+	/*
+	 * Case 1 : If the command is the currently executing command,
+	 * we'll set the aborted flag and return control so that
+	 * information transfer routine can exit cleanly.
+	 */
@@ -2671 +2682 @@
-    if (hostdata->connected == cmd) {
+	if (hostdata->connected == cmd) {
@@ -2673,5 +2684,5 @@
-	ABRT_PRINTK("scsi%d: aborting connected command\n", HOSTNO);
-/*
- * We should perform BSY checking, and make sure we haven't slipped
- * into BUS FREE.
- */
+		ABRT_PRINTK("scsi%d: aborting connected command\n", HOSTNO);
+		/*
+		 * We should perform BSY checking, and make sure we haven't slipped
+		 * into BUS FREE.
+		 */
@@ -2679,6 +2690,6 @@
-/*	NCR5380_write(INITIATOR_COMMAND_REG, ICR_ASSERT_ATN); */
-/* 
- * Since we can't change phases until we've completed the current 
- * handshake, we have to source or sink a byte of data if the current
- * phase is not MSGOUT.
- */
+		/*	NCR5380_write(INITIATOR_COMMAND_REG, ICR_ASSERT_ATN); */
+		/*
+		 * Since we can't change phases until we've completed the current
+		 * handshake, we have to source or sink a byte of data if the current
+		 * phase is not MSGOUT.
+		 */
@@ -2686,4 +2697,4 @@
-/* 
- * Return control to the executing NCR drive so we can clear the
- * aborted flag and get back into our main loop.
- */ 
+		/*
+		 * Return control to the executing NCR drive so we can clear the
+		 * aborted flag and get back into our main loop.
+		 */
@@ -2691,4 +2702,4 @@
-	if (do_abort(instance) == 0) {
-	  hostdata->aborted = 1;
-	  hostdata->connected = NULL;
-	  cmd->result = DID_ABORT << 16;
+		if (do_abort(instance) == 0) {
+			hostdata->aborted = 1;
+			hostdata->connected = NULL;
+			cmd->result = DID_ABORT << 16;
@@ -2696 +2707 @@
-	  cmd_free_tag( cmd );
+			cmd_free_tag(cmd);
@@ -2698 +2709,12 @@
-	  hostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);
+			hostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);
+#endif
+			local_irq_restore(flags);
+			cmd->scsi_done(cmd);
+			falcon_release_lock_if_possible(hostdata);
+			return SCSI_ABORT_SUCCESS;
+		} else {
+/*			local_irq_restore(flags); */
+			printk("scsi%d: abort of connected command failed!\n", HOSTNO);
+			return SCSI_ABORT_ERROR;
+		}
+	}
@@ -2700,44 +2721,0 @@
-	  local_irq_restore(flags);
-	  cmd->scsi_done(cmd);
-	  falcon_release_lock_if_possible( hostdata );
-	  return SCSI_ABORT_SUCCESS;
-	} else {
-/*	  local_irq_restore(flags); */
-	  printk("scsi%d: abort of connected command failed!\n", HOSTNO);
-	  return SCSI_ABORT_ERROR;
-	} 
-   }
-#endif
-
-/* 
- * Case 2 : If the command hasn't been issued yet, we simply remove it 
- * 	    from the issue queue.
- */
-    for (prev = (Scsi_Cmnd **) &(hostdata->issue_queue), 
-	tmp = (Scsi_Cmnd *) hostdata->issue_queue;
-	tmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp) )
-	if (cmd == tmp) {
-	    REMOVE(5, *prev, tmp, NEXT(tmp));
-	    (*prev) = NEXT(tmp);
-	    NEXT(tmp) = NULL;
-	    tmp->result = DID_ABORT << 16;
-	    local_irq_restore(flags);
-	    ABRT_PRINTK("scsi%d: abort removed command from issue queue.\n",
-			HOSTNO);
-	    /* Tagged queuing note: no tag to free here, hasn't been assigned
-	     * yet... */
-	    tmp->scsi_done(tmp);
-	    falcon_release_lock_if_possible( hostdata );
-	    return SCSI_ABORT_SUCCESS;
-	}
-
-/* 
- * Case 3 : If any commands are connected, we're going to fail the abort
- *	    and let the high level SCSI driver retry at a later time or 
- *	    issue a reset.
- *
- *	    Timeouts, and therefore aborted commands, will be highly unlikely
- *          and handling them cleanly in this situation would make the common
- *	    case of noresets less efficient, and would pollute our code.  So,
- *	    we fail.
- */
@@ -2745,57 +2723,91 @@
-    if (hostdata->connected) {
-	local_irq_restore(flags);
-	ABRT_PRINTK("scsi%d: abort failed, command connected.\n", HOSTNO);
-        return SCSI_ABORT_SNOOZE;
-    }
-
-/*
- * Case 4: If the command is currently disconnected from the bus, and 
- * 	there are no connected commands, we reconnect the I_T_L or 
- *	I_T_L_Q nexus associated with it, go into message out, and send 
- *      an abort message.
- *
- * This case is especially ugly. In order to reestablish the nexus, we
- * need to call NCR5380_select().  The easiest way to implement this 
- * function was to abort if the bus was busy, and let the interrupt
- * handler triggered on the SEL for reselect take care of lost arbitrations
- * where necessary, meaning interrupts need to be enabled.
- *
- * When interrupts are enabled, the queues may change - so we 
- * can't remove it from the disconnected queue before selecting it
- * because that could cause a failure in hashing the nexus if that 
- * device reselected.
- * 
- * Since the queues may change, we can't use the pointers from when we
- * first locate it.
- *
- * So, we must first locate the command, and if NCR5380_select()
- * succeeds, then issue the abort, relocate the command and remove
- * it from the disconnected queue.
- */
-
-    for (tmp = (Scsi_Cmnd *) hostdata->disconnected_queue; tmp;
-	 tmp = NEXT(tmp)) 
-        if (cmd == tmp) {
-            local_irq_restore(flags);
-	    ABRT_PRINTK("scsi%d: aborting disconnected command.\n", HOSTNO);
-  
-            if (NCR5380_select (instance, cmd, (int) cmd->tag)) 
-		return SCSI_ABORT_BUSY;
-
-	    ABRT_PRINTK("scsi%d: nexus reestablished.\n", HOSTNO);
-
-	    do_abort (instance);
-
-	    local_irq_save(flags);
-	    for (prev = (Scsi_Cmnd **) &(hostdata->disconnected_queue), 
-		tmp = (Scsi_Cmnd *) hostdata->disconnected_queue;
-		tmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp) )
-		    if (cmd == tmp) {
-		    REMOVE(5, *prev, tmp, NEXT(tmp));
-		    *prev = NEXT(tmp);
-		    NEXT(tmp) = NULL;
-		    tmp->result = DID_ABORT << 16;
-		    /* We must unlock the tag/LUN immediately here, since the
-		     * target goes to BUS FREE and doesn't send us another
-		     * message (COMMAND_COMPLETE or the like)
-		     */
+	/*
+	 * Case 2 : If the command hasn't been issued yet, we simply remove it
+	 *	    from the issue queue.
+	 */
+	for (prev = (Scsi_Cmnd **)&(hostdata->issue_queue),
+	     tmp = (Scsi_Cmnd *)hostdata->issue_queue;
+	     tmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp)) {
+		if (cmd == tmp) {
+			REMOVE(5, *prev, tmp, NEXT(tmp));
+			(*prev) = NEXT(tmp);
+			SET_NEXT(tmp, NULL);
+			tmp->result = DID_ABORT << 16;
+			local_irq_restore(flags);
+			ABRT_PRINTK("scsi%d: abort removed command from issue queue.\n",
+				    HOSTNO);
+			/* Tagged queuing note: no tag to free here, hasn't been assigned
+			 * yet... */
+			tmp->scsi_done(tmp);
+			falcon_release_lock_if_possible(hostdata);
+			return SCSI_ABORT_SUCCESS;
+		}
+	}
+
+	/*
+	 * Case 3 : If any commands are connected, we're going to fail the abort
+	 *	    and let the high level SCSI driver retry at a later time or
+	 *	    issue a reset.
+	 *
+	 *	    Timeouts, and therefore aborted commands, will be highly unlikely
+	 *          and handling them cleanly in this situation would make the common
+	 *	    case of noresets less efficient, and would pollute our code.  So,
+	 *	    we fail.
+	 */
+
+	if (hostdata->connected) {
+		local_irq_restore(flags);
+		ABRT_PRINTK("scsi%d: abort failed, command connected.\n", HOSTNO);
+		return SCSI_ABORT_SNOOZE;
+	}
+
+	/*
+	 * Case 4: If the command is currently disconnected from the bus, and
+	 *	there are no connected commands, we reconnect the I_T_L or
+	 *	I_T_L_Q nexus associated with it, go into message out, and send
+	 *      an abort message.
+	 *
+	 * This case is especially ugly. In order to reestablish the nexus, we
+	 * need to call NCR5380_select().  The easiest way to implement this
+	 * function was to abort if the bus was busy, and let the interrupt
+	 * handler triggered on the SEL for reselect take care of lost arbitrations
+	 * where necessary, meaning interrupts need to be enabled.
+	 *
+	 * When interrupts are enabled, the queues may change - so we
+	 * can't remove it from the disconnected queue before selecting it
+	 * because that could cause a failure in hashing the nexus if that
+	 * device reselected.
+	 *
+	 * Since the queues may change, we can't use the pointers from when we
+	 * first locate it.
+	 *
+	 * So, we must first locate the command, and if NCR5380_select()
+	 * succeeds, then issue the abort, relocate the command and remove
+	 * it from the disconnected queue.
+	 */
+
+	for (tmp = (Scsi_Cmnd *) hostdata->disconnected_queue; tmp;
+	     tmp = NEXT(tmp)) {
+		if (cmd == tmp) {
+			local_irq_restore(flags);
+			ABRT_PRINTK("scsi%d: aborting disconnected command.\n", HOSTNO);
+
+			if (NCR5380_select(instance, cmd, (int)cmd->tag))
+				return SCSI_ABORT_BUSY;
+
+			ABRT_PRINTK("scsi%d: nexus reestablished.\n", HOSTNO);
+
+			do_abort(instance);
+
+			local_irq_save(flags);
+			for (prev = (Scsi_Cmnd **)&(hostdata->disconnected_queue),
+			     tmp = (Scsi_Cmnd *)hostdata->disconnected_queue;
+			     tmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp)) {
+				if (cmd == tmp) {
+					REMOVE(5, *prev, tmp, NEXT(tmp));
+					*prev = NEXT(tmp);
+					SET_NEXT(tmp, NULL);
+					tmp->result = DID_ABORT << 16;
+					/* We must unlock the tag/LUN immediately here, since the
+					 * target goes to BUS FREE and doesn't send us another
+					 * message (COMMAND_COMPLETE or the like)
+					 */
@@ -2803 +2815 @@
-		    cmd_free_tag( tmp );
+					cmd_free_tag(tmp);
@@ -2805 +2817 @@
-		    hostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);
+					hostdata->busy[cmd->device->id] &= ~(1 << cmd->device->lun);
@@ -2807,4 +2819,6 @@
-		    local_irq_restore(flags);
-		    tmp->scsi_done(tmp);
-		    falcon_release_lock_if_possible( hostdata );
-		    return SCSI_ABORT_SUCCESS;
+					local_irq_restore(flags);
+					tmp->scsi_done(tmp);
+					falcon_release_lock_if_possible(hostdata);
+					return SCSI_ABORT_SUCCESS;
+				}
+			}
@@ -2814,9 +2828,9 @@
-/*
- * Case 5 : If we reached this point, the command was not found in any of 
- *	    the queues.
- *
- * We probably reached this point because of an unlikely race condition
- * between the command completing successfully and the abortion code,
- * so we won't panic, but we will notify the user in case something really
- * broke.
- */
+	/*
+	 * Case 5 : If we reached this point, the command was not found in any of
+	 *	    the queues.
+	 *
+	 * We probably reached this point because of an unlikely race condition
+	 * between the command completing successfully and the abortion code,
+	 * so we won't panic, but we will notify the user in case something really
+	 * broke.
+	 */
@@ -2824,3 +2838,3 @@
-    local_irq_restore(flags);
-    printk(KERN_INFO "scsi%d: warning : SCSI command probably completed successfully\n"
-           KERN_INFO "        before abortion\n", HOSTNO); 
+	local_irq_restore(flags);
+	printk(KERN_INFO "scsi%d: warning : SCSI command probably completed successfully\n"
+	       KERN_INFO "        before abortion\n", HOSTNO);
@@ -2828,5 +2842,5 @@
-/* Maybe it is sufficient just to release the ST-DMA lock... (if
- * possible at all) At least, we should check if the lock could be
- * released after the abort, in case it is kept due to some bug.
- */
-    falcon_release_lock_if_possible( hostdata );
+	/* Maybe it is sufficient just to release the ST-DMA lock... (if
+	 * possible at all) At least, we should check if the lock could be
+	 * released after the abort, in case it is kept due to some bug.
+	 */
+	falcon_release_lock_if_possible(hostdata);
@@ -2834 +2848 @@
-    return SCSI_ABORT_NOT_RUNNING;
+	return SCSI_ABORT_NOT_RUNNING;
@@ -2838 +2852 @@
-/* 
+/*
@@ -2840 +2854 @@
- * 
+ *
@@ -2845 +2859 @@
- */ 
+ */
@@ -2847 +2861 @@
-static int NCR5380_bus_reset( Scsi_Cmnd *cmd)
+static int NCR5380_bus_reset(Scsi_Cmnd *cmd)
@@ -2849,3 +2863,3 @@
-    SETUP_HOSTDATA(cmd->device->host);
-    int           i;
-    unsigned long flags;
+	SETUP_HOSTDATA(cmd->device->host);
+	int i;
+	unsigned long flags;
@@ -2853 +2867 @@
-    Scsi_Cmnd *connected, *disconnected_queue;
+	Scsi_Cmnd *connected, *disconnected_queue;
@@ -2856,36 +2870,36 @@
-    if (!IS_A_TT() && !falcon_got_lock)
-	printk(KERN_ERR "scsi%d: !!BINGO!! Falcon has no lock in NCR5380_reset\n",
-	       H_NO(cmd) );
-
-    NCR5380_print_status (cmd->device->host);
-
-    /* get in phase */
-    NCR5380_write( TARGET_COMMAND_REG,
-		   PHASE_SR_TO_TCR( NCR5380_read(STATUS_REG) ));
-    /* assert RST */
-    NCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST );
-    udelay (40);
-    /* reset NCR registers */
-    NCR5380_write( INITIATOR_COMMAND_REG, ICR_BASE );
-    NCR5380_write( MODE_REG, MR_BASE );
-    NCR5380_write( TARGET_COMMAND_REG, 0 );
-    NCR5380_write( SELECT_ENABLE_REG, 0 );
-    /* ++roman: reset interrupt condition! otherwise no interrupts don't get
-     * through anymore ... */
-    (void)NCR5380_read( RESET_PARITY_INTERRUPT_REG );
-
-#if 1 /* XXX Should now be done by midlevel code, but it's broken XXX */
-      /* XXX see below                                            XXX */
-
-    /* MSch: old-style reset: actually abort all command processing here */
-
-    /* After the reset, there are no more connected or disconnected commands
-     * and no busy units; to avoid problems with re-inserting the commands
-     * into the issue_queue (via scsi_done()), the aborted commands are
-     * remembered in local variables first.
-     */
-    local_irq_save(flags);
-    connected = (Scsi_Cmnd *)hostdata->connected;
-    hostdata->connected = NULL;
-    disconnected_queue = (Scsi_Cmnd *)hostdata->disconnected_queue;
-    hostdata->disconnected_queue = NULL;
+	if (!IS_A_TT() && !falcon_got_lock)
+		printk(KERN_ERR "scsi%d: !!BINGO!! Falcon has no lock in NCR5380_reset\n",
+		       H_NO(cmd));
+
+	NCR5380_print_status(cmd->device->host);
+
+	/* get in phase */
+	NCR5380_write(TARGET_COMMAND_REG,
+		      PHASE_SR_TO_TCR(NCR5380_read(STATUS_REG)));
+	/* assert RST */
+	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE | ICR_ASSERT_RST);
+	udelay(40);
+	/* reset NCR registers */
+	NCR5380_write(INITIATOR_COMMAND_REG, ICR_BASE);
+	NCR5380_write(MODE_REG, MR_BASE);
+	NCR5380_write(TARGET_COMMAND_REG, 0);
+	NCR5380_write(SELECT_ENABLE_REG, 0);
+	/* ++roman: reset interrupt condition! otherwise no interrupts don't get
+	 * through anymore ... */
+	(void)NCR5380_read(RESET_PARITY_INTERRUPT_REG);
+
+#if 1	/* XXX Should now be done by midlevel code, but it's broken XXX */
+	/* XXX see below                                            XXX */
+
+	/* MSch: old-style reset: actually abort all command processing here */
+
+	/* After the reset, there are no more connected or disconnected commands
+	 * and no busy units; to avoid problems with re-inserting the commands
+	 * into the issue_queue (via scsi_done()), the aborted commands are
+	 * remembered in local variables first.
+	 */
+	local_irq_save(flags);
+	connected = (Scsi_Cmnd *)hostdata->connected;
+	hostdata->connected = NULL;
+	disconnected_queue = (Scsi_Cmnd *)hostdata->disconnected_queue;
+	hostdata->disconnected_queue = NULL;
@@ -2893 +2907 @@
-    free_all_tags();
+	free_all_tags();
@@ -2895,2 +2909,2 @@
-    for( i = 0; i < 8; ++i )
-	hostdata->busy[i] = 0;
+	for (i = 0; i < 8; ++i)
+		hostdata->busy[i] = 0;
@@ -2898 +2912 @@
-    hostdata->dma_len = 0;
+	hostdata->dma_len = 0;
@@ -2900 +2914,12 @@
-    local_irq_restore(flags);
+	local_irq_restore(flags);
+
+	/* In order to tell the mid-level code which commands were aborted,
+	 * set the command status to DID_RESET and call scsi_done() !!!
+	 * This ultimately aborts processing of these commands in the mid-level.
+	 */
+
+	if ((cmd = connected)) {
+		ABRT_PRINTK("scsi%d: reset aborted a connected command\n", H_NO(cmd));
+		cmd->result = (cmd->result & 0xffff) | (DID_RESET << 16);
+		cmd->scsi_done(cmd);
+	}
@@ -2902,32 +2927,21 @@
-    /* In order to tell the mid-level code which commands were aborted, 
-     * set the command status to DID_RESET and call scsi_done() !!!
-     * This ultimately aborts processing of these commands in the mid-level.
-     */
-
-    if ((cmd = connected)) {
-	ABRT_PRINTK("scsi%d: reset aborted a connected command\n", H_NO(cmd));
-	cmd->result = (cmd->result & 0xffff) | (DID_RESET << 16);
-	cmd->scsi_done( cmd );
-    }
-
-    for (i = 0; (cmd = disconnected_queue); ++i) {
-	disconnected_queue = NEXT(cmd);
-	NEXT(cmd) = NULL;
-	cmd->result = (cmd->result & 0xffff) | (DID_RESET << 16);
-	cmd->scsi_done( cmd );
-    }
-    if (i > 0)
-	ABRT_PRINTK("scsi: reset aborted %d disconnected command(s)\n", i);
-
-/* The Falcon lock should be released after a reset...
- */
-/* ++guenther: moved to atari_scsi_reset(), to prevent a race between
- * unlocking and enabling dma interrupt.
- */
-/*    falcon_release_lock_if_possible( hostdata );*/
-
-    /* since all commands have been explicitly terminated, we need to tell
-     * the midlevel code that the reset was SUCCESSFUL, and there is no 
-     * need to 'wake up' the commands by a request_sense
-     */
-    return SCSI_RESET_SUCCESS | SCSI_RESET_BUS_RESET;
+	for (i = 0; (cmd = disconnected_queue); ++i) {
+		disconnected_queue = NEXT(cmd);
+		SET_NEXT(cmd, NULL);
+		cmd->result = (cmd->result & 0xffff) | (DID_RESET << 16);
+		cmd->scsi_done(cmd);
+	}
+	if (i > 0)
+		ABRT_PRINTK("scsi: reset aborted %d disconnected command(s)\n", i);
+
+	/* The Falcon lock should be released after a reset...
+	 */
+	/* ++guenther: moved to atari_scsi_reset(), to prevent a race between
+	 * unlocking and enabling dma interrupt.
+	 */
+/*	falcon_release_lock_if_possible( hostdata );*/
+
+	/* since all commands have been explicitly terminated, we need to tell
+	 * the midlevel code that the reset was SUCCESSFUL, and there is no
+	 * need to 'wake up' the commands by a request_sense
+	 */
+	return SCSI_RESET_SUCCESS | SCSI_RESET_BUS_RESET;
@@ -2936 +2950,29 @@
-    /* MSch: new-style reset handling: let the mid-level do what it can */
+	/* MSch: new-style reset handling: let the mid-level do what it can */
+
+	/* ++guenther: MID-LEVEL IS STILL BROKEN.
+	 * Mid-level is supposed to requeue all commands that were active on the
+	 * various low-level queues. In fact it does this, but that's not enough
+	 * because all these commands are subject to timeout. And if a timeout
+	 * happens for any removed command, *_abort() is called but all queues
+	 * are now empty. Abort then gives up the falcon lock, which is fatal,
+	 * since the mid-level will queue more commands and must have the lock
+	 * (it's all happening inside timer interrupt handler!!).
+	 * Even worse, abort will return NOT_RUNNING for all those commands not
+	 * on any queue, so they won't be retried ...
+	 *
+	 * Conclusion: either scsi.c disables timeout for all resetted commands
+	 * immediately, or we lose!  As of linux-2.0.20 it doesn't.
+	 */
+
+	/* After the reset, there are no more connected or disconnected commands
+	 * and no busy units; so clear the low-level status here to avoid
+	 * conflicts when the mid-level code tries to wake up the affected
+	 * commands!
+	 */
+
+	if (hostdata->issue_queue)
+		ABRT_PRINTK("scsi%d: reset aborted issued command(s)\n", H_NO(cmd));
+	if (hostdata->connected)
+		ABRT_PRINTK("scsi%d: reset aborted a connected command\n", H_NO(cmd));
+	if (hostdata->disconnected_queue)
+		ABRT_PRINTK("scsi%d: reset aborted disconnected command(s)\n", H_NO(cmd));
@@ -2938,32 +2980,4 @@
-    /* ++guenther: MID-LEVEL IS STILL BROKEN.
-     * Mid-level is supposed to requeue all commands that were active on the
-     * various low-level queues. In fact it does this, but that's not enough
-     * because all these commands are subject to timeout. And if a timeout
-     * happens for any removed command, *_abort() is called but all queues
-     * are now empty. Abort then gives up the falcon lock, which is fatal,
-     * since the mid-level will queue more commands and must have the lock
-     * (it's all happening inside timer interrupt handler!!).
-     * Even worse, abort will return NOT_RUNNING for all those commands not
-     * on any queue, so they won't be retried ...
-     *
-     * Conclusion: either scsi.c disables timeout for all resetted commands
-     * immediately, or we lose!  As of linux-2.0.20 it doesn't.
-     */
-
-    /* After the reset, there are no more connected or disconnected commands
-     * and no busy units; so clear the low-level status here to avoid 
-     * conflicts when the mid-level code tries to wake up the affected 
-     * commands!
-     */
-
-    if (hostdata->issue_queue)
-	ABRT_PRINTK("scsi%d: reset aborted issued command(s)\n", H_NO(cmd));
-    if (hostdata->connected) 
-	ABRT_PRINTK("scsi%d: reset aborted a connected command\n", H_NO(cmd));
-    if (hostdata->disconnected_queue)
-	ABRT_PRINTK("scsi%d: reset aborted disconnected command(s)\n", H_NO(cmd));
-
-    local_irq_save(flags);
-    hostdata->issue_queue = NULL;
-    hostdata->connected = NULL;
-    hostdata->disconnected_queue = NULL;
+	local_irq_save(flags);
+	hostdata->issue_queue = NULL;
+	hostdata->connected = NULL;
+	hostdata->disconnected_queue = NULL;
@@ -2971 +2985 @@
-    free_all_tags();
+	free_all_tags();
@@ -2973,2 +2987,2 @@
-    for( i = 0; i < 8; ++i )
-	hostdata->busy[i] = 0;
+	for (i = 0; i < 8; ++i)
+		hostdata->busy[i] = 0;
@@ -2976 +2990 @@
-    hostdata->dma_len = 0;
+	hostdata->dma_len = 0;
@@ -2978 +2992 @@
-    local_irq_restore(flags);
+	local_irq_restore(flags);
@@ -2980,2 +2994,2 @@
-    /* we did no complete reset of all commands, so a wakeup is required */
-    return SCSI_RESET_WAKEUP | SCSI_RESET_BUS_RESET;
+	/* we did no complete reset of all commands, so a wakeup is required */
+	return SCSI_RESET_WAKEUP | SCSI_RESET_BUS_RESET;
@@ -2984,4 +2997,0 @@
-
-/* Local Variables: */
-/* tab-width: 8     */
-/* End:             */
--- ./projects/linux/linux-2.6.23/drivers/scsi/atari_NCR5380.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/scsi/atari_NCR5380.c	2008-01-24 23:58:37.000000000 +0100
@@ -480,2 +480 @@
-	     virt_to_phys(page_address(cmd->SCp.buffer[1].page) +
-			  cmd->SCp.buffer[1].offset) == endaddr;) {
+	     virt_to_phys(sg_virt(&cmd->SCp.buffer[1])) == endaddr;) {
@@ -483 +482 @@
-			   page_address(cmd->SCp.buffer[1].page), endaddr);
+			   page_address(sg_page(&cmd->SCp.buffer[1])), endaddr);
@@ -518,2 +517 @@
-		cmd->SCp.ptr = (char *)page_address(cmd->SCp.buffer->page) +
-			       cmd->SCp.buffer->offset;
+		cmd->SCp.ptr = sg_virt(cmd->SCp.buffer);
@@ -2044 +2042 @@
-				cmd->done(cmd);
+				cmd->scsi_done(cmd);
@@ -2057,2 +2055 @@
-					cmd->SCp.ptr = page_address(cmd->SCp.buffer->page) +
-						   cmd->SCp.buffer->offset;
+					cmd->SCp.ptr = sg_virt(cmd->SCp.buffer);
@@ -2103 +2100 @@
-						cmd->done(cmd);
+						cmd->scsi_done(cmd);
@@ -2237,0 +2235,6 @@
+					if ((cmd->cmnd[0] == REQUEST_SENSE) &&
+						hostdata->ses.cmd_len) {
+						scsi_eh_restore_cmnd(cmd, &hostdata->ses);
+						hostdata->ses.cmd_len = 0 ;
+					}
+
@@ -2239,0 +2243,2 @@
+						scsi_eh_prep_cmnd(cmd, &hostdata->ses, NULL, 0, ~0);
+
@@ -2241,15 +2245,0 @@
-						cmd->cmnd[0] = REQUEST_SENSE;
-						cmd->cmnd[1] &= 0xe0;
-						cmd->cmnd[2] = 0;
-						cmd->cmnd[3] = 0;
-						cmd->cmnd[4] = sizeof(cmd->sense_buffer);
-						cmd->cmnd[5] = 0;
-						cmd->cmd_len = COMMAND_SIZE(cmd->cmnd[0]);
-
-						cmd->use_sg = 0;
-						/* this is initialized from initialize_SCp
-						cmd->SCp.buffer = NULL;
-						cmd->SCp.buffers_residual = 0;
-						*/
-						cmd->request_buffer = (char *) cmd->sense_buffer;
-						cmd->request_bufflen = sizeof(cmd->sense_buffer);
--- ./projects/linux/linux-2.6.24/drivers/scsi/atari_NCR5380.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/scsi/atari_NCR5380.c	2008-04-17 04:49:44.000000000 +0200
@@ -514,3 +514,3 @@
-	if (cmd->use_sg) {
-		cmd->SCp.buffer = (struct scatterlist *)cmd->request_buffer;
-		cmd->SCp.buffers_residual = cmd->use_sg - 1;
+	if (scsi_bufflen(cmd)) {
+		cmd->SCp.buffer = scsi_sglist(cmd);
+		cmd->SCp.buffers_residual = scsi_sg_count(cmd) - 1;
@@ -526,2 +526,2 @@
-		cmd->SCp.ptr = (char *)cmd->request_buffer;
-		cmd->SCp.this_residual = cmd->request_bufflen;
+		cmd->SCp.ptr = NULL;
+		cmd->SCp.this_residual = 0;
@@ -939 +939 @@
-	if (cmd->request_bufflen > NCR5380_STAT_LIMIT)
+	if (scsi_bufflen(cmd) > NCR5380_STAT_LIMIT)
@@ -946 +946 @@
-			hostdata->bytes_write[cmd->device->id] += cmd->request_bufflen;
+			hostdata->bytes_write[cmd->device->id] += scsi_bufflen(cmd);
@@ -953 +953 @@
-			hostdata->bytes_read[cmd->device->id] += cmd->request_bufflen;
+			hostdata->bytes_read[cmd->device->id] += scsi_bufflen(cmd);
@@ -1355 +1355 @@
-	if (cmd->request_bufflen > NCR5380_STAT_LIMIT)
+	if (scsi_bufflen(cmd) > NCR5380_STAT_LIMIT)
@@ -1362 +1362 @@
-			/*hostdata->bytes_write[cmd->device->id] += cmd->request_bufflen;*/
+			/*hostdata->bytes_write[cmd->device->id] += scsi_bufflen(cmd);*/
@@ -1369 +1369 @@
-			/*hostdata->bytes_read[cmd->device->id] += cmd->request_bufflen;*/
+			/*hostdata->bytes_read[cmd->device->id] += scsi_bufflen(cmd);*/
@@ -1871 +1871 @@
-	while (!(tmp = NCR5380_read(STATUS_REG)) & SR_REQ)
+	while (!((tmp = NCR5380_read(STATUS_REG)) & SR_REQ))
--- ./projects/linux/linux-2.6.29/drivers/scsi/atari_NCR5380.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/scsi/atari_NCR5380.c	2009-06-27 11:32:32.000000000 +0200
@@ -847 +847 @@
-static int NCR5380_init(struct Scsi_Host *instance, int flags)
+static int __init NCR5380_init(struct Scsi_Host *instance, int flags)
--- ./projects/linux/linux-2.6.14/drivers/scsi/sun3_NCR5380.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/scsi/sun3_NCR5380.c	2006-01-03 04:21:10.000000000 +0100
@@ -260 +260 @@
-static Scsi_Host_Template *the_template = NULL;
+static struct scsi_host_template *the_template = NULL;
--- ./projects/linux/linux-2.6.15/drivers/scsi/sun3_NCR5380.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/scsi/sun3_NCR5380.c	2006-03-20 06:53:29.000000000 +0100
@@ -72,0 +73 @@
+#include <scsi/scsi_transport_spi.h>
@@ -2381 +2382 @@
- * byte, since scsi_print_msg() wants the whole thing.  
+ * byte, since spi_print_msg() wants the whole thing.  
@@ -2434 +2435 @@
-			scsi_print_msg (extended_msg);
+			spi_print_msg(extended_msg);
@@ -2569 +2570 @@
-	scsi_print_msg(msg);
+	spi_print_msg(msg);
--- ./projects/linux/linux-2.6.17/drivers/scsi/sun3_NCR5380.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/scsi/sun3_NCR5380.c	2006-09-20 05:42:06.000000000 +0200
@@ -520 +520 @@
-	cmd->SCp.buffer = (struct scatterlist *) cmd->buffer;
+	cmd->SCp.buffer = (struct scatterlist *) cmd->request_buffer;
@@ -538 +537,0 @@
-#include <linux/config.h>
--- ./projects/linux/linux-2.6.18/drivers/scsi/sun3_NCR5380.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/scsi/sun3_NCR5380.c	2006-11-29 22:57:37.000000000 +0100
@@ -269,2 +269,2 @@
-#define	NEXT(cmd)	((Scsi_Cmnd *)((cmd)->host_scribble))
-#define	NEXTADDR(cmd)	((Scsi_Cmnd **)&((cmd)->host_scribble))
+#define	NEXT(cmd)	((struct scsi_cmnd *)((cmd)->host_scribble))
+#define	NEXTADDR(cmd)	((struct scsi_cmnd **)&((cmd)->host_scribble))
@@ -363 +363 @@
-static int is_lun_busy( Scsi_Cmnd *cmd, int should_be_tagged )
+static int is_lun_busy(struct scsi_cmnd *cmd, int should_be_tagged)
@@ -387 +387 @@
-static void cmd_get_tag( Scsi_Cmnd *cmd, int should_be_tagged )
+static void cmd_get_tag(struct scsi_cmnd *cmd, int should_be_tagged)
@@ -419 +419 @@
-static void cmd_free_tag( Scsi_Cmnd *cmd )
+static void cmd_free_tag(struct scsi_cmnd *cmd)
@@ -463 +463 @@
- * Function: void merge_contiguous_buffers( Scsi_Cmnd *cmd )
+ * Function: void merge_contiguous_buffers(struct scsi_cmnd *cmd)
@@ -469 +469 @@
- * Parameters: Scsi_Cmnd *cmd
+ * Parameters: struct scsi_cmnd *cmd
@@ -474 +474 @@
-static void merge_contiguous_buffers( Scsi_Cmnd *cmd )
+static void merge_contiguous_buffers(struct scsi_cmnd *cmd)
@@ -504 +504 @@
- * Function : void initialize_SCp(Scsi_Cmnd *cmd)
+ * Function : void initialize_SCp(struct scsi_cmnd *cmd)
@@ -509 +509 @@
- * Inputs : cmd - Scsi_Cmnd structure to have pointers reset.
+ * Inputs : cmd - struct scsi_cmnd structure to have pointers reset.
@@ -512 +512 @@
-static __inline__ void initialize_SCp(Scsi_Cmnd *cmd)
+static __inline__ void initialize_SCp(struct scsi_cmnd *cmd)
@@ -756 +756,2 @@
-char *lprint_Scsi_Cmnd (Scsi_Cmnd *cmd, char *pos, char *buffer, int length);
+char *lprint_Scsi_Cmnd(struct scsi_cmnd *cmd, char *pos, char *buffer,
+		       int length);
@@ -758,2 +759,2 @@
-static int NCR5380_proc_info (struct Scsi_Host *instance, char *buffer, char **start,
-		       off_t offset, int length, int inout)
+static int NCR5380_proc_info(struct Scsi_Host *instance, char *buffer,
+			     char **start, off_t offset, int length, int inout)
@@ -763 +764 @@
-    Scsi_Cmnd *ptr;
+    struct scsi_cmnd *ptr;
@@ -787 +788 @@
-	pos = lprint_Scsi_Cmnd ((Scsi_Cmnd *) hostdata->connected,
+	pos = lprint_Scsi_Cmnd ((struct scsi_cmnd *) hostdata->connected,
@@ -791 +792,2 @@
-    for (ptr = (Scsi_Cmnd *) hostdata->issue_queue; ptr; ptr = NEXT(ptr)) {
+    for (ptr = (struct scsi_cmnd *) hostdata->issue_queue; ptr; ptr = NEXT(ptr))
+    {
@@ -798 +800 @@
-    for (ptr = (Scsi_Cmnd *) hostdata->disconnected_queue; ptr;
+    for (ptr = (struct scsi_cmnd *) hostdata->disconnected_queue; ptr;
@@ -813,2 +815,2 @@
-static char *
-lprint_Scsi_Cmnd (Scsi_Cmnd *cmd, char *pos, char *buffer, int length)
+static char *lprint_Scsi_Cmnd(struct scsi_cmnd *cmd, char *pos, char *buffer,
+			      int length)
@@ -891,2 +893,2 @@
- * Function : int NCR5380_queue_command (Scsi_Cmnd *cmd, 
- *	void (*done)(Scsi_Cmnd *)) 
+ * Function : int NCR5380_queue_command (struct scsi_cmnd *cmd,
+ *	void (*done)(struct scsi_cmnd *))
@@ -909 +911,2 @@
-static int NCR5380_queue_command (Scsi_Cmnd *cmd, void (*done)(Scsi_Cmnd *))
+static int NCR5380_queue_command(struct scsi_cmnd *cmd,
+				 void (*done)(struct scsi_cmnd *))
@@ -912 +915 @@
-    Scsi_Cmnd *tmp;
+    struct scsi_cmnd *tmp;
@@ -993 +996 @@
-	for (tmp = (Scsi_Cmnd *)hostdata->issue_queue;
+	for (tmp = (struct scsi_cmnd *)hostdata->issue_queue;
@@ -1033 +1036 @@
-    Scsi_Cmnd *tmp, *prev;
+    struct scsi_cmnd *tmp, *prev;
@@ -1076 +1079 @@
-	    for (tmp = (Scsi_Cmnd *) hostdata->issue_queue, prev = NULL;
+	    for (tmp = (struct scsi_cmnd *) hostdata->issue_queue, prev = NULL;
@@ -1081 +1084 @@
-	    for (tmp = (Scsi_Cmnd *) hostdata->issue_queue, 
+	    for (tmp = (struct scsi_cmnd *) hostdata->issue_queue,
@@ -1255 +1258 @@
-static irqreturn_t NCR5380_intr (int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t NCR5380_intr (int irq, void *dev_id)
@@ -1342 +1345,2 @@
-static void collect_stats(struct NCR5380_hostdata* hostdata, Scsi_Cmnd* cmd)
+static void collect_stats(struct NCR5380_hostdata *hostdata,
+			  struct scsi_cmnd *cmd)
@@ -1368,2 +1372,2 @@
- * Function : int NCR5380_select (struct Scsi_Host *instance, Scsi_Cmnd *cmd, 
- *	int tag);
+ * Function : int NCR5380_select(struct Scsi_Host *instance,
+ * 				 struct scsi_cmnd *cmd,	int tag);
@@ -1398 +1402,2 @@
-static int NCR5380_select (struct Scsi_Host *instance, Scsi_Cmnd *cmd, int tag)
+static int NCR5380_select(struct Scsi_Host *instance, struct scsi_cmnd *cmd,
+			  int tag)
@@ -1988 +1993 @@
-    Scsi_Cmnd *cmd = (Scsi_Cmnd *) hostdata->connected;
+    struct scsi_cmnd *cmd = (struct scsi_cmnd *) hostdata->connected;
@@ -2020 +2025 @@
-			if(cmd->request->flags & REQ_CMD) {
+			if(blk_fs_request(cmd->request)) {
@@ -2275 +2280 @@
-		        hostdata->issue_queue = (Scsi_Cmnd *) cmd;
+		        hostdata->issue_queue = (struct scsi_cmnd *) cmd;
@@ -2505 +2510 @@
- *	field to point to the Scsi_Cmnd for which the I_T_L or I_T_L_Q 
+ *	field to point to the struct scsi_cmnd for which the I_T_L or I_T_L_Q
@@ -2524 +2529 @@
-    Scsi_Cmnd *tmp = NULL, *prev;
+    struct scsi_cmnd *tmp = NULL, *prev;
@@ -2580 +2585 @@
-    for (tmp = (Scsi_Cmnd *) hostdata->disconnected_queue, prev = NULL; 
+    for (tmp = (struct scsi_cmnd *) hostdata->disconnected_queue, prev = NULL;
@@ -2671 +2676 @@
- * Function : int NCR5380_abort (Scsi_Cmnd *cmd)
+ * Function : int NCR5380_abort(struct scsi_cmnd *cmd)
@@ -2675 +2680 @@
- * Inputs : cmd - the Scsi_Cmnd to abort, code - code to set the 
+ * Inputs : cmd - the struct scsi_cmnd to abort, code - code to set the
@@ -2687 +2692 @@
-static int NCR5380_abort (Scsi_Cmnd *cmd)
+static int NCR5380_abort(struct scsi_cmnd *cmd)
@@ -2691 +2696 @@
-    Scsi_Cmnd *tmp, **prev;
+    struct scsi_cmnd *tmp, **prev;
@@ -2756,3 +2761,3 @@
-    for (prev = (Scsi_Cmnd **) &(hostdata->issue_queue), 
-	tmp = (Scsi_Cmnd *) hostdata->issue_queue;
-	tmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp) )
+    for (prev = (struct scsi_cmnd **) &(hostdata->issue_queue),
+	tmp = (struct scsi_cmnd *) hostdata->issue_queue;
+	tmp; prev = NEXTADDR(tmp), tmp = NEXT(tmp))
@@ -2815 +2820 @@
-    for (tmp = (Scsi_Cmnd *) hostdata->disconnected_queue; tmp;
+    for (tmp = (struct scsi_cmnd *) hostdata->disconnected_queue; tmp;
@@ -2829,2 +2834,2 @@
-	    for (prev = (Scsi_Cmnd **) &(hostdata->disconnected_queue), 
-		tmp = (Scsi_Cmnd *) hostdata->disconnected_queue;
+	    for (prev = (struct scsi_cmnd **) &(hostdata->disconnected_queue),
+		tmp = (struct scsi_cmnd *) hostdata->disconnected_queue;
@@ -2871 +2876 @@
- * Function : int NCR5380_bus_reset (Scsi_Cmnd *cmd)
+ * Function : int NCR5380_bus_reset(struct scsi_cmnd *cmd)
@@ -2879 +2884 @@
-static int NCR5380_bus_reset( Scsi_Cmnd *cmd)
+static int NCR5380_bus_reset(struct scsi_cmnd *cmd)
@@ -2885 +2890 @@
-    Scsi_Cmnd *connected, *disconnected_queue;
+    struct scsi_cmnd *connected, *disconnected_queue;
@@ -2917 +2922 @@
-    connected = (Scsi_Cmnd *)hostdata->connected;
+    connected = (struct scsi_cmnd *)hostdata->connected;
@@ -2919 +2924 @@
-    disconnected_queue = (Scsi_Cmnd *)hostdata->disconnected_queue;
+    disconnected_queue = (struct scsi_cmnd *)hostdata->disconnected_queue;
--- ./projects/linux/linux-2.6.19/drivers/scsi/sun3_NCR5380.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/scsi/sun3_NCR5380.c	2007-02-04 19:44:54.000000000 +0100
@@ -269 +269 @@
-#define	NEXT(cmd)	((struct scsi_cmnd *)((cmd)->host_scribble))
+#define	NEXT(cmd)	(*(struct scsi_cmnd **)&((cmd)->host_scribble))
@@ -653 +653 @@
-static DECLARE_WORK(NCR5380_tqueue, (void (*)(void*))NCR5380_main, NULL);
+static DECLARE_WORK(NCR5380_tqueue, NCR5380_main);
@@ -1034 +1034 @@
-static void NCR5380_main (void *bl)
+static void NCR5380_main (struct work_struct *bl)
@@ -1274 +1274 @@
-	    ENABLE_IRQ();
+//	    ENABLE_IRQ();
@@ -1307 +1307 @@
-		ENABLE_IRQ();
+//		ENABLE_IRQ();
--- ./projects/linux/linux-2.6.23/drivers/scsi/sun3_NCR5380.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/scsi/sun3_NCR5380.c	2008-01-24 23:58:37.000000000 +0100
@@ -275,2 +275 @@
-#define SGADDR(buffer) (void *)(((unsigned long)page_address((buffer)->page)) + \
-			(buffer)->offset)
+#define SGADDR(buffer) (void *)(((unsigned long)sg_virt(((buffer)))))
@@ -1599 +1598 @@
-     * only wait for BSY... (Famous german words: Der Klgere gibt nach :-)
+     * only wait for BSY... (Famous german words: Der Klgere gibt nach :-)
@@ -2058 +2057 @@
-		cmd->done(cmd);
+		cmd->scsi_done(cmd);
@@ -2118 +2117 @@
-			cmd->done(cmd);
+			cmd->scsi_done(cmd);
@@ -2256,0 +2256,6 @@
+		    if ((cmd->cmnd[0] == REQUEST_SENSE) &&
+			                        hostdata->ses.cmd_len) {
+			scsi_eh_restore_cmnd(cmd, &hostdata->ses);
+			hostdata->ses.cmd_len = 0 ;
+		    }
+
@@ -2258,0 +2264 @@
+			scsi_eh_prep_cmnd(cmd, &hostdata->ses, NULL, 0, ~0);
@@ -2261,9 +2266,0 @@
-			cmd->cmnd[0] = REQUEST_SENSE;
-			cmd->cmnd[1] &= 0xe0;
-			cmd->cmnd[2] = 0;
-			cmd->cmnd[3] = 0;
-			cmd->cmnd[4] = sizeof(cmd->sense_buffer);
-			cmd->cmnd[5] = 0;
-			cmd->cmd_len = COMMAND_SIZE(cmd->cmnd[0]);
-
-			cmd->use_sg = 0;
@@ -2274,2 +2270,0 @@
-			cmd->request_buffer = (char *) cmd->sense_buffer;
-			cmd->request_bufflen = sizeof(cmd->sense_buffer);
--- ./projects/linux/linux-2.6.24/drivers/scsi/sun3_NCR5380.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/scsi/sun3_NCR5380.c	2008-04-17 04:49:44.000000000 +0200
@@ -518,3 +518,3 @@
-    if (cmd->use_sg) {
-	cmd->SCp.buffer = (struct scatterlist *) cmd->request_buffer;
-	cmd->SCp.buffers_residual = cmd->use_sg - 1;
+    if (scsi_bufflen(cmd)) {
+	cmd->SCp.buffer = scsi_sglist(cmd);
+	cmd->SCp.buffers_residual = scsi_sg_count(cmd) - 1;
@@ -531,2 +531,2 @@
-	cmd->SCp.ptr = (char *) cmd->request_buffer;
-	cmd->SCp.this_residual = cmd->request_bufflen;
+	cmd->SCp.ptr = NULL;
+	cmd->SCp.this_residual = 0;
@@ -938 +938 @@
-    if (cmd->request_bufflen > NCR5380_STAT_LIMIT)
+    if (scsi_bufflen(cmd) > NCR5380_STAT_LIMIT)
@@ -946 +946 @@
-		hostdata->bytes_write[cmd->device->id] += cmd->request_bufflen;
+		hostdata->bytes_write[cmd->device->id] += scsi_bufflen(cmd);
@@ -953 +953 @@
-		hostdata->bytes_read[cmd->device->id] += cmd->request_bufflen;
+		hostdata->bytes_read[cmd->device->id] += scsi_bufflen(cmd);
@@ -1348 +1348 @@
-    if (cmd->request_bufflen > NCR5380_STAT_LIMIT)
+    if (scsi_bufflen(cmd) > NCR5380_STAT_LIMIT)
@@ -1356 +1356 @@
-		/*hostdata->bytes_write[cmd->device->id] += cmd->request_bufflen;*/
+		/*hostdata->bytes_write[cmd->device->id] += scsi_bufflen(cmd);*/
@@ -1363 +1363 @@
-		/*hostdata->bytes_read[cmd->device->id] += cmd->request_bufflen;*/
+		/*hostdata->bytes_read[cmd->device->id] += scsi_bufflen(cmd);*/
@@ -1866 +1866 @@
-    while (!(tmp = NCR5380_read(STATUS_REG)) & SR_REQ);
+    while (!((tmp = NCR5380_read(STATUS_REG)) & SR_REQ));
--- ./projects/linux/linux-2.6.13/drivers/serial/m32r_sio.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/serial/m32r_sio.c	2005-10-28 02:02:08.000000000 +0200
@@ -278 +278 @@
-static void m32r_sio_stop_tx(struct uart_port *port, unsigned int tty_stop)
+static void m32r_sio_stop_tx(struct uart_port *port)
@@ -288 +288 @@
-static void m32r_sio_start_tx(struct uart_port *port, unsigned int tty_start)
+static void m32r_sio_start_tx(struct uart_port *port)
@@ -428 +428 @@
-		m32r_sio_stop_tx(&up->port, 0);
+		m32r_sio_stop_tx(&up->port);
@@ -449 +449 @@
-		m32r_sio_stop_tx(&up->port, 0);
+		m32r_sio_stop_tx(&up->port);
--- ./projects/linux/linux-2.6.15/drivers/serial/m32r_sio.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/serial/m32r_sio.c	2006-03-20 06:53:29.000000000 +0100
@@ -83 +83 @@
-#define STD_COM_FLAGS (ASYNC_BOOT_AUTOCONF | ASYNC_SKIP_TEST)
+#define STD_COM_FLAGS (UPF_BOOT_AUTOCONF | UPF_SKIP_TEST)
@@ -333,0 +334 @@
+	unsigned char flag;
@@ -337,5 +337,0 @@
-		if (unlikely(tty->flip.count >= TTY_FLIPBUF_SIZE)) {
-			tty->flip.work.func((void *)tty);
-			if (tty->flip.count >= TTY_FLIPBUF_SIZE)
-				return; // if TTY_DONT_FLIP is set
-		}
@@ -343,2 +339 @@
-		*tty->flip.char_buf_ptr = ch;
-		*tty->flip.flag_buf_ptr = TTY_NORMAL;
+		flag = TTY_NORMAL;
@@ -383 +378 @@
-				*tty->flip.flag_buf_ptr = TTY_BREAK;
+				flag = TTY_BREAK;
@@ -385 +380 @@
-				*tty->flip.flag_buf_ptr = TTY_PARITY;
+				flag = TTY_PARITY;
@@ -387 +382 @@
-				*tty->flip.flag_buf_ptr = TTY_FRAME;
+				flag = TTY_FRAME;
@@ -391,7 +386,4 @@
-		if ((*status & up->port.ignore_status_mask) == 0) {
-			tty->flip.flag_buf_ptr++;
-			tty->flip.char_buf_ptr++;
-			tty->flip.count++;
-		}
-		if ((*status & UART_LSR_OE) &&
-		    tty->flip.count < TTY_FLIPBUF_SIZE) {
+		if ((*status & up->port.ignore_status_mask) == 0)
+			tty_insert_flip_char(tty, ch, flag);
+
+		if (*status & UART_LSR_OE) {
@@ -403,4 +395 @@
-			*tty->flip.flag_buf_ptr = TTY_OVERRUN;
-			tty->flip.flag_buf_ptr++;
-			tty->flip.char_buf_ptr++;
-			tty->flip.count++;
+			tty_insert_flip_char(tty, 0, TTY_OVERRUN);
--- ./projects/linux/linux-2.6.16/drivers/serial/m32r_sio.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/serial/m32r_sio.c	2006-06-18 03:49:35.000000000 +0200
@@ -251 +251 @@
-static _INLINE_ unsigned int sio_in(struct uart_sio_port *up, int offset)
+static unsigned int sio_in(struct uart_sio_port *up, int offset)
@@ -256 +256 @@
-static _INLINE_ void sio_out(struct uart_sio_port *up, int offset, int value)
+static void sio_out(struct uart_sio_port *up, int offset, int value)
@@ -261 +261 @@
-static _INLINE_ unsigned int serial_in(struct uart_sio_port *up, int offset)
+static unsigned int serial_in(struct uart_sio_port *up, int offset)
@@ -269,2 +269 @@
-static _INLINE_ void
-serial_out(struct uart_sio_port *up, int offset, int value)
+static void serial_out(struct uart_sio_port *up, int offset, int value)
@@ -329,2 +328,2 @@
-static _INLINE_ void receive_chars(struct uart_sio_port *up, int *status,
-	struct pt_regs *regs)
+static void receive_chars(struct uart_sio_port *up, int *status,
+			  struct pt_regs *regs)
@@ -403 +402 @@
-static _INLINE_ void transmit_chars(struct uart_sio_port *up)
+static void transmit_chars(struct uart_sio_port *up)
@@ -1041,0 +1041,8 @@
+static void m32r_sio_console_putchar(struct uart_port *port, int ch)
+{
+	struct uart_sio_port *up = (struct uart_sio_port *)port;
+
+	wait_for_xmitr(up);
+	sio_out(up, SIOTXB, ch);
+}
+
@@ -1053 +1059,0 @@
-	int i;
@@ -1061,17 +1067 @@
-	/*
-	 *	Now, do each character
-	 */
-	for (i = 0; i < count; i++, s++) {
-		wait_for_xmitr(up);
-
-		/*
-		 *	Send the character out.
-		 *	If a LF, also do CR...
-		 */
-		sio_out(up, SIOTXB, *s);
-
-		if (*s == 10) {
-			wait_for_xmitr(up);
-			sio_out(up, SIOTXB, 13);
-		}
-	}
+	uart_console_write(&up->port, s, count, m32r_sio_console_putchar);
--- ./projects/linux/linux-2.6.17/drivers/serial/m32r_sio.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/serial/m32r_sio.c	2006-09-20 05:42:06.000000000 +0200
@@ -28 +27,0 @@
-#include <linux/config.h>
@@ -546 +545 @@
-	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? SA_SHIRQ : 0;
+	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
@@ -1134 +1132,0 @@
-	.devfs_name		= "tts/",
--- ./projects/linux/linux-2.6.18/drivers/serial/m32r_sio.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/serial/m32r_sio.c	2006-11-29 22:57:37.000000000 +0100
@@ -79 +79 @@
-#include <asm/serial.h>
+#define BASE_BAUD	115200
@@ -89 +88,0 @@
-#undef SERIAL_PORT_DFNS
@@ -112 +111 @@
-	SERIAL_PORT_DFNS	/* defined in asm/serial.h */
+	SERIAL_PORT_DFNS
@@ -327,2 +326 @@
-static void receive_chars(struct uart_sio_port *up, int *status,
-			  struct pt_regs *regs)
+static void receive_chars(struct uart_sio_port *up, int *status)
@@ -382 +380 @@
-		if (uart_handle_sysrq_char(&up->port, ch, regs))
+		if (uart_handle_sysrq_char(&up->port, ch))
@@ -443 +441 @@
-	unsigned int status, struct pt_regs *regs)
+	unsigned int status)
@@ -448 +446 @@
-		receive_chars(up, &status, regs);
+		receive_chars(up, &status);
@@ -467,2 +465 @@
-static irqreturn_t m32r_sio_interrupt(int irq, void *dev_id,
-	struct pt_regs *regs)
+static irqreturn_t m32r_sio_interrupt(int irq, void *dev_id)
@@ -496 +493 @@
-			m32r_sio_handle_port(up, sts, regs);
+			m32r_sio_handle_port(up, sts);
@@ -596 +593 @@
-		m32r_sio_handle_port(up, sts, NULL);
+		m32r_sio_handle_port(up, sts);
--- ./projects/linux/linux-2.6.19/drivers/serial/m32r_sio.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/drivers/serial/m32r_sio.c	2007-02-04 19:44:54.000000000 +0100
@@ -702 +702 @@
-	struct termios *termios, struct termios *old)
+	struct ktermios *termios, struct ktermios *old)
--- ./projects/linux/linux-2.6.23/drivers/serial/m32r_sio.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/serial/m32r_sio.c	2008-01-24 23:58:37.000000000 +0100
@@ -542 +542 @@
-	int ret, irq_flags = up->port.flags & UPF_SHARE_IRQ ? IRQF_SHARED : 0;
+	int ret, irq_flags = 0;
--- ./projects/linux/linux-2.6.24/drivers/serial/m32r_sio.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/serial/m32r_sio.c	2008-04-17 04:49:44.000000000 +0200
@@ -424 +424 @@
-		while (!serial_in(up, UART_LSR) & UART_LSR_THRE);
+		while (!(serial_in(up, UART_LSR) & UART_LSR_THRE));
--- ./projects/linux/linux-2.6.26/drivers/serial/m32r_sio.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/serial/m32r_sio.c	2008-10-10 00:13:53.000000000 +0200
@@ -328 +328 @@
-	struct tty_struct *tty = up->port.info->tty;
+	struct tty_struct *tty = up->port.info->port.tty;
@@ -1163 +1163 @@
-	printk(KERN_INFO "Serial: M32R SIO driver $Revision: 1.11 $ ");
+	printk(KERN_INFO "Serial: M32R SIO driver\n");
@@ -1192 +1192 @@
-MODULE_DESCRIPTION("Generic M32R SIO serial driver $Revision: 1.11 $");
+MODULE_DESCRIPTION("Generic M32R SIO serial driver");
--- ./projects/linux/linux-2.6.27/drivers/serial/m32r_sio.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/drivers/serial/m32r_sio.c	2008-12-25 00:26:37.000000000 +0100
@@ -925 +925 @@
-	if (ser->irq >= NR_IRQS || ser->irq < 0 ||
+	if (ser->irq >= nr_irqs || ser->irq < 0 ||
@@ -1165 +1165 @@
-	for (i = 0; i < NR_IRQS; i++)
+	for (i = 0; i < nr_irqs; i++)
--- ./projects/linux/linux-2.6.28/drivers/staging/me4000/me4000.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/staging/me4000/me4000.c	2009-03-24 00:12:14.000000000 +0100
@@ -539,4 +539,2 @@
-	struct list_head *board_p;
-	struct list_head *dac_p;
-	struct me4000_info *board_info;
-	struct me4000_ao_context *ao_context;
+	struct me4000_info *board_info, *board_info_safe;
+	struct me4000_ao_context *ao_context, *ao_context_safe;
@@ -545,3 +543 @@
-	for (board_p = me4000_board_info_list.next;
-	     board_p != &me4000_board_info_list; board_p = board_p->next) {
-		board_info = list_entry(board_p, struct me4000_info, list);
+	list_for_each_entry(board_info, &me4000_board_info_list, list) {
@@ -549,4 +545,2 @@
-		while (!list_empty(&board_info->ao_context_list)) {
-			dac_p = board_info->ao_context_list.next;
-			ao_context =
-			    list_entry(dac_p, struct me4000_ao_context, list);
+		list_for_each_entry_safe(ao_context, ao_context_safe,
+				&board_info->ao_context_list, list) {
@@ -557 +551 @@
-			list_del(dac_p);
+			list_del(&ao_context->list);
@@ -577,3 +571,2 @@
-	while (!list_empty(&me4000_board_info_list)) {
-		board_p = me4000_board_info_list.next;
-		board_info = list_entry(board_p, struct me4000_info, list);
+	list_for_each_entry_safe(board_info, board_info_safe,
+			&me4000_board_info_list, list) {
@@ -581 +574 @@
-		list_del(board_p);
+		list_del(&board_info->list);
@@ -666,2 +659,2 @@
-	for (board_p = me4000_board_info_list.next, i = 0;
-	     board_p != &me4000_board_info_list; board_p = board_p->next, i++) {
+	i = 0;
+	list_for_each(board_p, &me4000_board_info_list) {
@@ -671,0 +665 @@
+		i++;
@@ -675 +669 @@
-		       "ME4000:init_board_info():Cannot get index of baord\n");
+		       "ME4000:init_board_info():Cannot get index of board\n");
@@ -866,2 +860 @@
-	struct list_head *dac_p;
-	struct me4000_ao_context *ao_context;
+	struct me4000_ao_context *ao_context, *ao_context_safe;
@@ -870,3 +863,2 @@
-	while (!list_empty(&board_info->ao_context_list)) {
-		dac_p = board_info->ao_context_list.next;
-		ao_context = list_entry(dac_p, struct me4000_ao_context, list);
+	list_for_each_entry_safe(ao_context, ao_context_safe,
+			&board_info->ao_context_list, list) {
@@ -875 +867 @@
-		list_del(dac_p);
+		list_del(&ao_context->list);
@@ -1183 +1175 @@
-	if (!inl(info->plx_regbase + PLX_INTCSR) & 0x20) {
+	if (!(inl(info->plx_regbase + PLX_INTCSR) & 0x20)) {
@@ -1306,3 +1298,2 @@
-		for (ptr = me4000_board_info_list.next, i = 0;
-		     ptr != &me4000_board_info_list; ptr = ptr->next, i++) {
-			board_info = list_entry(ptr, struct me4000_info, list);
+		i = 0;
+		list_for_each(ptr, &me4000_board_info_list) {
@@ -1310,0 +1302 @@
+			i++;
@@ -1311,0 +1304 @@
+		board_info = list_entry(ptr, struct me4000_info, list);
@@ -1321,5 +1314,2 @@
-		for (ptr = board_info->ao_context_list.next, i = 0;
-		     ptr != &board_info->ao_context_list;
-		     ptr = ptr->next, i++) {
-			ao_context = list_entry(ptr, struct me4000_ao_context,
-									list);
+		i = 0;
+		list_for_each(ptr, &board_info->ao_context_list) {
@@ -1327,0 +1318 @@
+			i++;
@@ -1328,0 +1320 @@
+		ao_context = list_entry(ptr, struct me4000_ao_context, list);
@@ -1387,3 +1379,2 @@
-		for (ptr = me4000_board_info_list.next, i = 0;
-		     ptr != &me4000_board_info_list; ptr = ptr->next, i++) {
-			board_info = list_entry(ptr, struct me4000_info, list);
+		i = 0;
+		list_for_each(ptr, &me4000_board_info_list) {
@@ -1391,0 +1383 @@
+			i++;
@@ -1392,0 +1385 @@
+		board_info = list_entry(ptr, struct me4000_info, list);
@@ -1441,3 +1434 @@
-		for (ptr = me4000_board_info_list.next;
-		     ptr != &me4000_board_info_list; ptr = ptr->next) {
-			board_info = list_entry(ptr, struct me4000_info, list);
+		list_for_each_entry(board_info, &me4000_board_info_list, list) {
@@ -1448 +1439 @@
-		if (ptr == &me4000_board_info_list) {
+		if (&board_info->list == &me4000_board_info_list) {
@@ -1486,3 +1477 @@
-		for (ptr = me4000_board_info_list.next;
-		     ptr != &me4000_board_info_list; ptr = ptr->next) {
-			board_info = list_entry(ptr, struct me4000_info, list);
+		list_for_each_entry(board_info, &me4000_board_info_list, list) {
@@ -1493 +1482 @@
-		if (ptr == &me4000_board_info_list) {
+		if (&board_info->list == &me4000_board_info_list) {
@@ -1529,3 +1518 @@
-		for (ptr = me4000_board_info_list.next;
-		     ptr != &me4000_board_info_list; ptr = ptr->next) {
-			board_info = list_entry(ptr, struct me4000_info, list);
+		list_for_each_entry(board_info, &me4000_board_info_list, list) {
@@ -1536 +1523 @@
-		if (ptr == &me4000_board_info_list) {
+		if (&board_info->list == &me4000_board_info_list) {
@@ -5958 +5944,0 @@
-	struct list_head *board_p;
@@ -5978,3 +5964 @@
-	for (board_p = me4000_board_info_list.next;
-	     board_p != &me4000_board_info_list; board_p = board_p->next) {
-		board_info = list_entry(board_p, struct me4000_info, list);
+	list_for_each_entry(board_info, &me4000_board_info_list, list) {
@@ -5995 +5978,0 @@
-	struct list_head *ptr;
@@ -6003,5 +5986 @@
-	for (ptr = me4000_board_info_list.next;
-	     (ptr != &me4000_board_info_list) && (len < limit);
-	     ptr = ptr->next) {
-		board_info = list_entry(ptr, struct me4000_info, list);
-
+	list_for_each_entry(board_info, &me4000_board_info_list, list) {
@@ -6112,0 +6092,2 @@
+		if (len >= limit)
+			break;
--- ./projects/linux/linux-2.6.29/drivers/staging/me4000/me4000.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/staging/me4000/me4000.c	2009-06-27 11:32:32.000000000 +0200
@@ -39,2 +39,2 @@
-#include <asm/uaccess.h>
-#include <asm/io.h>
+#include <linux/uaccess.h>
+#include <linux/io.h>
@@ -249 +249 @@
-static int inline me4000_buf_count(struct me4000_circ_buf buf, int size)
+static inline int me4000_buf_count(struct me4000_circ_buf buf, int size)
@@ -251 +251 @@
-	return ((buf.head - buf.tail) & (size - 1));
+	return (buf.head - buf.tail) & (size - 1);
@@ -254 +254 @@
-static int inline me4000_buf_space(struct me4000_circ_buf buf, int size)
+static inline int me4000_buf_space(struct me4000_circ_buf buf, int size)
@@ -256 +256 @@
-	return ((buf.tail - (buf.head + 1)) & (size - 1));
+	return (buf.tail - (buf.head + 1)) & (size - 1);
@@ -259 +259 @@
-static int inline me4000_values_to_end(struct me4000_circ_buf buf, int size)
+static inline int me4000_values_to_end(struct me4000_circ_buf buf, int size)
@@ -268 +268 @@
-static int inline me4000_space_to_end(struct me4000_circ_buf buf, int size)
+static inline int me4000_space_to_end(struct me4000_circ_buf buf, int size)
@@ -278 +278 @@
-static void inline me4000_outb(unsigned char value, unsigned long port)
+static inline void me4000_outb(unsigned char value, unsigned long port)
@@ -284 +284 @@
-static void inline me4000_outl(unsigned long value, unsigned long port)
+static inline void me4000_outl(unsigned long value, unsigned long port)
@@ -290 +290 @@
-static unsigned long inline me4000_inl(unsigned long port)
+static inline unsigned long me4000_inl(unsigned long port)
@@ -298 +298 @@
-static unsigned char inline me4000_inb(unsigned long port)
+static inline unsigned char me4000_inb(unsigned long port)
@@ -312 +312 @@
-static struct file_operations me4000_ao_fops_sing = {
+static const struct file_operations me4000_ao_fops_sing = {
@@ -320 +320 @@
-static struct file_operations me4000_ao_fops_wrap = {
+static const struct file_operations me4000_ao_fops_wrap = {
@@ -328 +328 @@
-static struct file_operations me4000_ao_fops_cont = {
+static const struct file_operations me4000_ao_fops_cont = {
@@ -338 +338 @@
-static struct file_operations me4000_ai_fops_sing = {
+static const struct file_operations me4000_ai_fops_sing = {
@@ -345 +345 @@
-static struct file_operations me4000_ai_fops_cont_sw = {
+static const struct file_operations me4000_ai_fops_cont_sw = {
@@ -355 +355 @@
-static struct file_operations me4000_ai_fops_cont_et = {
+static const struct file_operations me4000_ai_fops_cont_et = {
@@ -364 +364 @@
-static struct file_operations me4000_ai_fops_cont_et_value = {
+static const struct file_operations me4000_ai_fops_cont_et_value = {
@@ -373 +373 @@
-static struct file_operations me4000_ai_fops_cont_et_chanlist = {
+static const struct file_operations me4000_ai_fops_cont_et_chanlist = {
@@ -382 +382 @@
-static struct file_operations me4000_dio_fops = {
+static const struct file_operations me4000_dio_fops = {
@@ -389 +389 @@
-static struct file_operations me4000_cnt_fops = {
+static const struct file_operations me4000_cnt_fops = {
@@ -396 +396 @@
-static struct file_operations me4000_ext_int_fops = {
+static const struct file_operations me4000_ext_int_fops = {
@@ -404,4 +404,7 @@
-static struct file_operations *me4000_ao_fops_array[] = {
-	&me4000_ao_fops_sing,	// single operations
-	&me4000_ao_fops_wrap,	// wraparound operations
-	&me4000_ao_fops_cont,	// continous operations
+static const struct file_operations *me4000_ao_fops_array[] = {
+	/* single operations */
+	&me4000_ao_fops_sing,
+	/* wraparound operations */
+	&me4000_ao_fops_wrap,
+	/* continuous operations */
+	&me4000_ao_fops_cont,
@@ -410,6 +413,11 @@
-static struct file_operations *me4000_ai_fops_array[] = {
-	&me4000_ai_fops_sing,	// single operations
-	&me4000_ai_fops_cont_sw,	// continuous operations with software start
-	&me4000_ai_fops_cont_et,	// continous operations with external trigger
-	&me4000_ai_fops_cont_et_value,	// sample values by external trigger
-	&me4000_ai_fops_cont_et_chanlist,	// work through one channel list by external trigger
+static const struct file_operations *me4000_ai_fops_array[] = {
+	/* single operations */
+	&me4000_ai_fops_sing,
+	/* continuous operations with software start */
+	&me4000_ai_fops_cont_sw,
+	/* continuous operations with external trigger */
+	&me4000_ai_fops_cont_et,
+	/* sample values by external trigger */
+	&me4000_ai_fops_cont_et_value,
+	/* work through one channel list by external trigger */
+	&me4000_ai_fops_cont_et_chanlist,
@@ -549,2 +557 @@
-			if (ao_context->circ_buf.buf)
-				kfree(ao_context->circ_buf.buf);
+			kfree(ao_context->circ_buf.buf);
@@ -556,2 +563 @@
-		if (board_info->ai_context->circ_buf.buf)
-			kfree(board_info->ai_context->circ_buf.buf);
+		kfree(board_info->ai_context->circ_buf.buf);
@@ -1266 +1272 @@
-	if (!(me4000_inl(info->me4000_regbase + ME4000_DIO_DIR_REG) & 0x1)) {
+	if (!(me4000_inl(info->me4000_regbase + ME4000_DIO_DIR_REG) & 0x1))
@@ -1268 +1273,0 @@
-	}
@@ -1466 +1471 @@
-		//me4000_dio_reset(dio_context);
+		/* me4000_dio_reset(dio_context); */
@@ -2061 +2066 @@
-				return (2 * ret);
+				return 2 * ret;
@@ -2107 +2112 @@
-	if (filep->f_flags & O_NONBLOCK) {
+	if (filep->f_flags & O_NONBLOCK)
@@ -2109 +2113,0 @@
-	}
@@ -2204 +2208 @@
-		    		(struct me4000_ao_channel_list *)arg,
+				(struct me4000_ao_channel_list *)arg,
@@ -2364 +2368,3 @@
-				if (((jiffies - ref) > (timeout * HZ / USER_HZ))) {	// 2.6 has diffrent definitions for HZ in user and kernel space
+				/* kernel 2.6 has different definitions for HZ
+				 * in user and kernel space */
+				if ((jiffies - ref) > (timeout * HZ / USER_HZ)) {
@@ -2405,2 +2411,2 @@
-	//tmp &= ~ME4000_AO_CTRL_BIT_STOP;
-	//me4000_outl(tmp, ao_context->ctrl_reg);
+	/* tmp &= ~ME4000_AO_CTRL_BIT_STOP; */
+	/* me4000_outl(tmp, ao_context->ctrl_reg); */
@@ -2437,2 +2443,2 @@
-	//tmp &= ~(ME4000_AO_CTRL_BIT_STOP | ME4000_AO_CTRL_BIT_IMMEDIATE_STOP);
-	//me4000_outl(tmp, ao_context->ctrl_reg);
+	/* tmp &= ~(ME4000_AO_CTRL_BIT_STOP | ME4000_AO_CTRL_BIT_IMMEDIATE_STOP); */
+	/* me4000_outl(tmp, ao_context->ctrl_reg); */
@@ -2601,2 +2607,4 @@
-	tmp &= ~(0x1 << ao_context->index);	// Disable preload bit
-	tmp &= ~(0x1 << (ao_context->index + 16));	// Disable hw simultaneous bit
+	/* Disable preload bit */
+	tmp &= ~(0x1 << ao_context->index);
+	/* Disable hw simultaneous bit */
+	tmp &= ~(0x1 << (ao_context->index + 16));
@@ -2617,2 +2625,4 @@
-	tmp |= (0x1 << ao_context->index);	// Enable preload bit
-	tmp |= (0x1 << (ao_context->index + 16));	// Enable hw simultaneous bit
+	/* Enable preload bit */
+	tmp |= (0x1 << ao_context->index);
+	/* Enable hw simulatenous bit */
+	tmp |= (0x1 << (ao_context->index + 16));
@@ -2633,2 +2643,4 @@
-	tmp |= (0x1 << ao_context->index);	// Enable preload bit
-	tmp &= ~(0x1 << (ao_context->index + 16));	// Disable hw simultaneous bit
+	/* Enable preload bit */
+	tmp |= (0x1 << ao_context->index);
+	/* Enable hw simulatenous bit */
+	tmp &= ~(0x1 << (ao_context->index + 16));
@@ -2672 +2684 @@
-			      					      + 16)))) {
+								      + 16)))) {
@@ -2676 +2688 @@
-				      					index));
+									index));
@@ -2735,2 +2747,4 @@
-		tmp &= ~(0x1 << channels.list[i]);	// Clear the preload bit
-		tmp &= ~(0x1 << (channels.list[i] + 16));	// Clear the hw simultaneous bit
+		/* Clear the preload bit */
+		tmp &= ~(0x1 << channels.list[i]);
+		/* Clear the hw simultaneous bit */
+		tmp &= ~(0x1 << (channels.list[i] + 16));
@@ -2762,2 +2776,4 @@
-	tmp &= ~(0x1 << ao_context->index);	// Disable synchronous sw bit
-	tmp |= 0x1 << (ao_context->index + 16);	// Enable synchronous hw bit
+	/* Disable synchronous sw bit */
+	tmp &= ~(0x1 << ao_context->index);
+	/* Enable synchronous hw bit */
+	tmp |= 0x1 << (ao_context->index + 16);
@@ -2797,2 +2813,4 @@
-	tmp |= 0x1 << ao_context->index;	// Enable synchronous sw bit
-	tmp &= ~(0x1 << (ao_context->index + 16));	// Disable synchronous hw bit
+	/* Enable synchronous sw bit */
+	tmp |= 0x1 << ao_context->index;
+	/* Disable synchronous hw bit */
+	tmp &= ~(0x1 << (ao_context->index + 16));
@@ -2870 +2888,3 @@
-				if (((jiffies - ref) > (timeout * HZ / USER_HZ))) {	// 2.6 has diffrent definitions for HZ in user and kernel space
+				/* kernel 2.6 has different definitions for HZ
+				 * in user and kernel space */
+				if ((jiffies - ref) > (timeout * HZ / USER_HZ)) {
@@ -3246 +3266,2 @@
-			if (((jiffies - jiffy) > (cmd.timeout * HZ / USER_HZ)) && cmd.timeout) {	// 2.6 has diffrent definitions for HZ in user and kernel space
+			/* 2.6 has different definitions for HZ in user and kernel space */
+			if (((jiffies - jiffy) > (cmd.timeout * HZ / USER_HZ)) && cmd.timeout) {
@@ -3625 +3646 @@
-	for (i = 0; i < cmd.channel_list.count; i++) {
+	for (i = 0; i < cmd.channel_list.count; i++)
@@ -3627 +3647,0 @@
-	}
@@ -3666,2 +3686 @@
-	if (list)
-		kfree(list);
+	kfree(list);
@@ -3777,3 +3796 @@
-		while (!
-		       (inl(ai_context->status_reg) & ME4000_AI_STATUS_BIT_FSM))
-		{
+		while (!(inl(ai_context->status_reg) & ME4000_AI_STATUS_BIT_FSM)) {
@@ -3786 +3803,2 @@
-			if (((jiffies - ref) > (timeout * HZ / USER_HZ))) {	// 2.6 has diffrent definitions for HZ in user and kernel space
+			/* 2.6 has different definitions for HZ in user and kernel space */
+			if ((jiffies - ref) > (timeout * HZ / USER_HZ)) {
@@ -3793,3 +3811 @@
-		while (!
-		       (inl(ai_context->status_reg) & ME4000_AI_STATUS_BIT_FSM))
-		{
+		while (!(inl(ai_context->status_reg) & ME4000_AI_STATUS_BIT_FSM)) {
@@ -4116 +4132 @@
-	if (filep->f_flags & O_NONBLOCK) {
+	if (filep->f_flags & O_NONBLOCK)
@@ -4118 +4133,0 @@
-	}
@@ -4257 +4272 @@
-		if (cmd & ((0x1 << (length - 1)) >> i)) {
+		if (cmd & ((0x1 << (length - 1)) >> i))
@@ -4259 +4274 @@
-		} else {
+		else
@@ -4261 +4275,0 @@
-		}
@@ -4317 +4331 @@
-		if (cmd & ((0x1 << (length - 1)) >> i)) {
+		if (cmd & ((0x1 << (length - 1)) >> i))
@@ -4319 +4333 @@
-		} else {
+		else
@@ -4321 +4335 @@
-		}
+
@@ -5443,2 +5456,0 @@
-	//unsigned long before;
-	//unsigned long after;
@@ -5496 +5507,0 @@
-		//rdtscl(before);
@@ -5512,2 +5522,0 @@
-		//rdtscl(after);
-		//printk(KERN_ERR"ME4000:me4000_ao_isr():Time lapse = %lu\n", after - before);
@@ -5545,2 +5554,4 @@
-		ao_context->pipe_flag = 1;	// Set flag in order to inform write routine
-		tmp &= ~ME4000_AO_CTRL_BIT_ENABLE_IRQ;	// Disable interrupt
+		/* Set flag in order to inform write routine */
+		ao_context->pipe_flag = 1;
+		/* Disable interrupt */
+		tmp &= ~ME4000_AO_CTRL_BIT_ENABLE_IRQ;
--- ./projects/linux/linux-2.6.28/drivers/staging/wlan-ng/p80211wext.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/staging/wlan-ng/p80211wext.c	2009-03-24 00:12:14.000000000 +0100
@@ -41 +40,0 @@
-#include <linux/version.h>
@@ -50 +48,0 @@
-#if WIRELESS_EXT > 12
@@ -52 +49,0 @@
-#endif
@@ -61 +57,0 @@
-#include "version.h"
@@ -81,2 +76,0 @@
-/* compatibility to wireless extensions */
-#ifdef WIRELESS_EXT
@@ -84 +78 @@
-static UINT8 p80211_mhz_to_channel(UINT16 mhz)
+static u8 p80211_mhz_to_channel(u16 mhz)
@@ -100 +94 @@
-static UINT16 p80211_channel_to_mhz(UINT8 ch, int dot11a)
+static u16 p80211_channel_to_mhz(u8 ch, int dot11a)
@@ -131 +125 @@
-#define NUM_CHANNELS (sizeof(p80211wext_channel_freq) / sizeof(p80211wext_channel_freq[0]))
+#define NUM_CHANNELS ARRAY_SIZE(p80211wext_channel_freq)
@@ -150 +144 @@
-static int p80211wext_dorequest(wlandevice_t *wlandev, UINT32 did, UINT32 data)
+static int p80211wext_dorequest(wlandevice_t *wlandev, u32 did, u32 data)
@@ -162 +156 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -203 +197 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -221 +215 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -248 +241,0 @@
-#if WIRELESS_EXT > 18
@@ -250,3 +242,0 @@
-#else
-	wstats->qual.updated = 7;
-#endif
@@ -257 +246,0 @@
-#if WIRELESS_EXT > 11
@@ -261 +249,0 @@
-#endif
@@ -304 +292 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -315 +303 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -342 +330 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -365 +353 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -377,2 +364,0 @@
-#if WIRELESS_EXT > 8
-
@@ -383 +369 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -410 +396 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -450,3 +435,0 @@
-
-#warning "get rid of p2mib here"
-
@@ -457 +440 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -482 +464,0 @@
-#if WIRELESS_EXT > 9
@@ -485 +466,0 @@
-#endif
@@ -487 +467,0 @@
-#if WIRELESS_EXT > 10
@@ -495 +474,0 @@
-#endif /* WIRELESS_EXT > 10 */
@@ -497 +475,0 @@
-#if WIRELESS_EXT > 16
@@ -504 +481,0 @@
-#endif
@@ -546 +522,0 @@
-#endif
@@ -553 +529 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -564 +539,0 @@
-#if WIRELESS_EXT > 8
@@ -569 +544 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -574,0 +550,3 @@
+	i = (erq->flags & IW_ENCODE_INDEX) - 1;
+	erq->flags = 0;
+
@@ -576 +554 @@
-		erq->flags = IW_ENCODE_ENABLED;
+		erq->flags |= IW_ENCODE_ENABLED;
@@ -578 +556 @@
-		erq->flags = IW_ENCODE_DISABLED;
+		erq->flags |= IW_ENCODE_DISABLED;
@@ -610 +588 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -616 +593,0 @@
-	int enable = 0;
@@ -635 +612,3 @@
-		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID, i);
+		/* Set current key number only if no keys are given */
+		if (erq->flags & IW_ENCODE_NOKEY) {
+			result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID, i);
@@ -637,6 +616,4 @@
-		if (result) {
-			err = -EFAULT;
-			goto exit;
-		}
-		else {
-			enable = 1;
+			if (result) {
+				err = -EFAULT;
+				goto exit;
+			}
@@ -645,3 +622,3 @@
-	}
-	else {
-		// Do not thing when no Key Index
+	} else {
+		// Use defaultkey if no Key Index
+		i = wlandev->hostwep & HOSTWEP_DEFAULTKEY_MASK;
@@ -651 +628 @@
-	if((erq->flags & IW_ENCODE_NOKEY) == 0 && enable == 1) {
+	if((erq->flags & IW_ENCODE_NOKEY) == 0 ) {
@@ -693 +670 @@
-			result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+			result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -706,2 +683 @@
-	}
-	else if((erq->flags & IW_ENCODE_ENABLED) || enable == 1) {
+	} else {
@@ -716 +692,7 @@
-	/* Check the ExcludeUnencrypted flag */
+	/*  The  security  mode  may  be open or restricted, and its meaning
+	    depends on the card used. With  most  cards,  in  open  mode  no
+	    authentication  is  used  and  the  card  may  also  accept non-
+	    encrypted sessions, whereas in restricted  mode  only  encrypted
+	    sessions  are  accepted  and the card will use authentication if
+	    available.
+	*/
@@ -739 +721 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -765 +747 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -801 +783 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -819 +801 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -842 +824 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -853 +835 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -866,4 +848,4 @@
-#define		HFA384x_RATEBIT_1			((UINT16)1)
-#define		HFA384x_RATEBIT_2			((UINT16)2)
-#define		HFA384x_RATEBIT_5dot5			((UINT16)4)
-#define		HFA384x_RATEBIT_11			((UINT16)8)
+#define		HFA384x_RATEBIT_1			((u16)1)
+#define		HFA384x_RATEBIT_2			((u16)2)
+#define		HFA384x_RATEBIT_5dot5			((u16)4)
+#define		HFA384x_RATEBIT_11			((u16)8)
@@ -896 +878 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -907 +889 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -930 +912 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -951 +933 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -967 +949 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -978 +960 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -1000 +982 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -1022 +1004 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -1034,4 +1015,0 @@
-#endif  /* WIRELESS_EXT > 8 */
-
-#if WIRELESS_EXT > 10
-
@@ -1050 +1028 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -1055 +1033 @@
-	UINT16 shortretry, longretry, lifetime;
+	u16 shortretry, longretry, lifetime;
@@ -1063 +1041 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -1077 +1055 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -1091 +1069 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -1129 +1107 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -1154 +1132 @@
-		result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+		result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -1166 +1144 @@
-			result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+			result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -1179 +1157 @@
-			result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+			result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -1194,3 +1171,0 @@
-#endif /* WIRELESS_EXT > 10 */
-
-#if WIRELESS_EXT > 9
@@ -1201 +1176 @@
-        wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -1215,14 +1190,5 @@
-
-        switch (rrq->value) {
-
-          case 1 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel1; break;
-          case 2 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel2; break;
-          case 3 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel3; break;
-          case 4 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel4; break;
-          case 5 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel5; break;
-          case 6 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel6; break;
-          case 7 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel7; break;
-          case 8 : mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel8; break;
-          default: mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11TxPowerLevel8; break;
-	}
-
+	mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel;
+	if (rrq->fixed == 0)
+	  mibitem.data = 30;
+	else
+	  mibitem.data = rrq->value;
@@ -1230 +1196 @@
-        result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+        result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -1246 +1212 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -1258 +1224 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -1278 +1243,0 @@
-#endif /* WIRELESS_EXT > 9 */
@@ -1284 +1249 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -1320 +1285 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -1376 +1340,0 @@
-#if WIRELESS_EXT > 13
@@ -1381 +1345 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -1412 +1376 @@
-	result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -1504 +1468 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -1523 +1487 @@
-		result = p80211req_dorequest(wlandev, (UINT8*)&msg);
+		result = p80211req_dorequest(wlandev, (u8*)&msg);
@@ -1543 +1506,0 @@
-#endif
@@ -1548 +1510,0 @@
-#if WIRELESS_EXT > 17
@@ -1554 +1516 @@
-  wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+  wlandevice_t *wlandev = dev->ml_priv;
@@ -1583 +1545 @@
-    if ( ! ext->alg & IW_ENCODE_ALG_WEP) {
+    if (!(ext->alg & IW_ENCODE_ALG_WEP)) {
@@ -1618 +1580 @@
-    result = p80211req_dorequest(wlandev,(UINT8*)&msg);
+    result = p80211req_dorequest(wlandev,(u8*)&msg);
@@ -1630 +1592 @@
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+	wlandevice_t *wlandev = dev->ml_priv;
@@ -1685 +1647 @@
-  wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+  wlandevice_t *wlandev = dev->ml_priv;
@@ -1737 +1699 @@
-  wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
+  wlandevice_t *wlandev = dev->ml_priv;
@@ -1766,20 +1727,0 @@
-
-#endif
-
-
-
-
-
-
-/*****************************************************/
-
-
-
-
-
-/*
-typedef int (*iw_handler)(netdevice_t *dev, struct iw_request_info *info,
-                          union iwreq_data *wrqu, char *extra);
-*/
-
-#if WIRELESS_EXT > 12
@@ -1811,7 +1753,2 @@
-#if WIRELESS_EXT > 13
-	(iw_handler) p80211wext_siwscan,			/* SIOCSIWSCAN */
-	(iw_handler) p80211wext_giwscan,			/* SIOCGIWSCAN */
-#else /* WIRELESS_EXT > 13 */
-	(iw_handler) NULL,	/* null */		/* SIOCSIWSCAN */
-	(iw_handler) NULL,	/* null */		/* SIOCGIWSCAN */
-#endif /* WIRELESS_EXT > 13 */
+	(iw_handler) p80211wext_siwscan,		/* SIOCSIWSCAN */
+	(iw_handler) p80211wext_giwscan,		/* SIOCGIWSCAN */
@@ -1838 +1774,0 @@
-#if WIRELESS_EXT > 17
@@ -1840 +1775,0 @@
-
@@ -1851 +1785,0 @@
-#endif
@@ -1855 +1789 @@
-	.num_standard = sizeof(p80211wext_handlers) / sizeof(iw_handler),
+	.num_standard = ARRAY_SIZE(p80211wext_handlers),
@@ -1861 +1794,0 @@
-#if WIRELESS_EXT > 16
@@ -1863 +1795,0 @@
-#endif
@@ -1866,149 +1797,0 @@
-#endif
-
-/* wireless extensions' ioctls */
-int p80211wext_support_ioctl(netdevice_t *dev, struct ifreq *ifr, int cmd)
-{
-	wlandevice_t *wlandev = (wlandevice_t*)dev->priv;
-
-#if WIRELESS_EXT < 13
-	struct iwreq *iwr = (struct iwreq*)ifr;
-#endif
-
-	p80211item_uint32_t             mibitem;
-	int err = 0;
-
-	DBFENTER;
-
-	mibitem.status = P80211ENUM_msgitem_status_data_ok;
-
-	if ( wlandev->msdstate != WLAN_MSD_RUNNING ) {
-		err = -ENODEV;
-		goto exit;
-	}
-
-	WLAN_LOG_DEBUG(1, "Received wireless extension ioctl #%d.\n", cmd);
-
-	switch (cmd) {
-#if WIRELESS_EXT < 13
-	case SIOCSIWNAME:  /* unused  */
-		err = (-EOPNOTSUPP);
-		break;
-	case SIOCGIWNAME: /* get name == wireless protocol */
-                err = p80211wext_giwname(dev, NULL, (char *) &iwr->u, NULL);
-		break;
-	case SIOCSIWNWID:
-	case SIOCGIWNWID:
-		err = (-EOPNOTSUPP);
-		break;
-	case SIOCSIWFREQ: /* set channel */
-                err = p80211wext_siwfreq(dev, NULL, &(iwr->u.freq), NULL);
-		break;
-	case SIOCGIWFREQ: /* get channel */
-                err = p80211wext_giwfreq(dev, NULL, &(iwr->u.freq), NULL);
-		break;
-	case SIOCSIWRANGE:
-	case SIOCSIWPRIV:
-	case SIOCSIWAP: /* set access point MAC addresses (BSSID) */
-		err = (-EOPNOTSUPP);
-		break;
-
-	case SIOCGIWAP:	/* get access point MAC addresses (BSSID) */
-                err = p80211wext_giwap(dev, NULL, &(iwr->u.ap_addr), NULL);
-		break;
-
-#if WIRELESS_EXT > 8
-	case SIOCSIWMODE: /* set operation mode */
-	case SIOCSIWESSID: /* set SSID (network name) */
-	case SIOCSIWRATE: /* set default bit rate (bps) */
-		err = (-EOPNOTSUPP);
-		break;
-
-	case SIOCGIWMODE: /* get operation mode */
-		err = p80211wext_giwmode(dev, NULL, &iwr->u.mode, NULL);
-
-		break;
-	case SIOCGIWNICKN: /* get node name/nickname */
-	case SIOCGIWESSID: /* get SSID */
-		if(iwr->u.essid.pointer) {
-                        char ssid[IW_ESSID_MAX_SIZE+1];
-			memset(ssid, 0, sizeof(ssid));
-
-			err = p80211wext_giwessid(dev, NULL, &iwr->u.essid, ssid);
-			if(copy_to_user(iwr->u.essid.pointer, ssid, sizeof(ssid)))
-				err = (-EFAULT);
-		}
-		break;
-	case SIOCGIWRATE:
-                err = p80211wext_giwrate(dev, NULL, &iwr->u.bitrate, NULL);
-		break;
-	case SIOCGIWRTS:
-		err = p80211wext_giwrts(dev, NULL, &iwr->u.rts, NULL);
-		break;
-	case SIOCGIWFRAG:
-		err = p80211wext_giwfrag(dev, NULL, &iwr->u.rts, NULL);
-		break;
-	case SIOCGIWENCODE:
-		if (!capable(CAP_NET_ADMIN))
-			err = -EPERM;
-		else if (iwr->u.encoding.pointer) {
-			char keybuf[MAX_KEYLEN];
-			err = p80211wext_giwencode(dev, NULL,
-						     &iwr->u.encoding, keybuf);
-			if (copy_to_user(iwr->u.encoding.pointer, keybuf,
-					 iwr->u.encoding.length))
-				err = -EFAULT;
-		}
-		break;
-	case SIOCGIWAPLIST:
-	case SIOCSIWRTS:
-	case SIOCSIWFRAG:
-	case SIOCSIWSENS:
-	case SIOCGIWSENS:
-	case SIOCSIWNICKN: /* set node name/nickname */
-	case SIOCSIWENCODE: /* set encoding token & mode */
-	case SIOCSIWSPY:
-	case SIOCGIWSPY:
-	case SIOCSIWPOWER:
-	case SIOCGIWPOWER:
-	case SIOCGIWPRIV:
-		err = (-EOPNOTSUPP);
-		break;
-	case SIOCGIWRANGE:
-		if(iwr->u.data.pointer != NULL) {
-                        struct iw_range range;
-                        err = p80211wext_giwrange(dev, NULL, &iwr->u.data,
-						  (char *) &range);
-			/* Push that up to the caller */
-			if (copy_to_user(iwr->u.data.pointer, &range, sizeof(range)))
-				err = -EFAULT;
-		}
-		break;
-#endif /* WIRELESS_EXT > 8 */
-#if WIRELESS_EXT > 9
-	case SIOCSIWTXPOW:
-		err = (-EOPNOTSUPP);
-		break;
-	case SIOCGIWTXPOW:
-		err = p80211wext_giwtxpow(dev, NULL, &iwr->u.txpower, NULL);
-		break;
-#endif /* WIRELESS_EXT > 9 */
-#if WIRELESS_EXT > 10
-	case SIOCSIWRETRY:
-		err = (-EOPNOTSUPP);
-		break;
-	case SIOCGIWRETRY:
-		err = p80211wext_giwretry(dev, NULL, &iwr->u.retry, NULL);
-		break;
-#endif /* WIRELESS_EXT > 10 */
-
-#endif /* WIRELESS_EXT <= 12 */
-
-	default:
-		err = (-EOPNOTSUPP);
-		break;
-	}
-
- exit:
-	DBFEXIT;
-	return (err);
-}
@@ -2022 +1804,0 @@
-#if WIRELESS_EXT > 13
@@ -2037 +1819 @@
-#endif
+
@@ -2044,3 +1825,0 @@
-#endif /* compatibility to wireless extensions */
-
-
--- ./projects/linux/linux-2.6.29/drivers/staging/wlan-ng/p80211wext.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/staging/wlan-ng/p80211wext.c	2009-06-27 11:32:32.000000000 +0200
@@ -53,0 +54,2 @@
+#include <linux/if_ether.h>
+#include <linux/bitops.h>
@@ -58,2 +59,0 @@
-#include "wlan_compat.h"
-
@@ -80,3 +80,2 @@
-	if (mhz >= 5000) {
-		return ((mhz - 5000) / 5);
-	}
+	if (mhz >= 5000)
+		return (mhz - 5000) / 5;
@@ -87,3 +86,2 @@
-	if (mhz >= 2407) {
-		return ((mhz - 2407) / 5);
-	}
+	if (mhz >= 2407)
+		return (mhz - 2407) / 5;
@@ -103,4 +101,2 @@
-
-	if (dot11a) {
-		return (5000 + (5 * ch));
-	}
+	if (dot11a)
+		return 5000 + (5 * ch);
@@ -109 +104,0 @@
-
@@ -113,3 +108,2 @@
-	if ((ch < 14) && (ch > 0)) {
-		return (2407 + (5 * ch));
-	}
+	if ((ch < 14) && (ch > 0))
+		return 2407 + (5 * ch);
@@ -125,4 +118,0 @@
-#define NUM_CHANNELS ARRAY_SIZE(p80211wext_channel_freq)
-
-/* steal a spare bit to store the shared/opensystems state. should default to open if not set */
-#define HOSTWEP_SHAREDKEY BIT3
@@ -129,0 +120 @@
+#define NUM_CHANNELS ARRAY_SIZE(p80211wext_channel_freq)
@@ -131 +122,3 @@
-/** function declarations =============== */
+/* steal a spare bit to store the shared/opensystems state.
+   should default to open if not set */
+#define HOSTWEP_SHAREDKEY BIT(3)
@@ -133,6 +126,7 @@
-static int qual_as_percent(int snr ) {
-  if ( snr <= 0 )
-    return 0;
-  if ( snr <= 40 )
-    return snr*5/2;
-  return 100;
+static int qual_as_percent(int snr)
+{
+	if (snr <= 0)
+		return 0;
+	if (snr <= 40)
+		return snr * 5 / 2;
+	return 100;
@@ -141,3 +134,0 @@
-
-
-
@@ -146,5 +137,3 @@
-	p80211msg_dot11req_mibset_t	msg;
-	p80211item_uint32_t		mibitem;
-	int	result;
-
-	DBFENTER;
+	p80211msg_dot11req_mibset_t msg;
+	p80211item_uint32_t mibitem;
+	int result;
@@ -156 +145 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -158 +146,0 @@
-	DBFEXIT;
@@ -164,2 +152,2 @@
-	p80211msg_lnxreq_autojoin_t     msg;
-	struct iw_point			data;
+	p80211msg_lnxreq_autojoin_t msg;
+	struct iw_point data;
@@ -171,2 +158,0 @@
-	DBFENTER;
-
@@ -181,2 +167,2 @@
-	if ( wlandev->hostwep & HOSTWEP_SHAREDKEY )
-	  msg.authtype.data = P80211ENUM_authalg_sharedkey;
+	if (wlandev->hostwep & HOSTWEP_SHAREDKEY)
+		msg.authtype.data = P80211ENUM_authalg_sharedkey;
@@ -184 +170 @@
-	  msg.authtype.data = P80211ENUM_authalg_opensystem;
+		msg.authtype.data = P80211ENUM_authalg_opensystem;
@@ -190 +176 @@
-	if (data.length && ssid[data.length-1] == '\0') {
+	if (data.length && ssid[data.length - 1] == '\0')
@@ -192 +177,0 @@
-	}
@@ -197 +182 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -206 +190,0 @@
-	DBFEXIT;
@@ -212 +196 @@
-struct iw_statistics* p80211wext_get_wireless_stats (netdevice_t *dev)
+struct iw_statistics *p80211wext_get_wireless_stats(netdevice_t * dev)
@@ -214 +198 @@
-	p80211msg_lnxreq_commsquality_t  quality;
+	p80211msg_lnxreq_commsquality_t quality;
@@ -216 +200 @@
-	struct iw_statistics* wstats = &wlandev->wstats;
+	struct iw_statistics *wstats = &wlandev->wstats;
@@ -219 +202,0 @@
-	DBFENTER;
@@ -221 +204 @@
-	if ( (wlandev == NULL) || (wlandev->msdstate != WLAN_MSD_RUNNING) )
+	if ((wlandev == NULL) || (wlandev->msdstate != WLAN_MSD_RUNNING))
@@ -233 +216 @@
-	if ( wlandev->mlmerequest == NULL )
+	if (wlandev->mlmerequest == NULL)
@@ -236 +219 @@
-	retval = wlandev->mlmerequest(wlandev, (p80211msg_t*) &quality);
+	retval = wlandev->mlmerequest(wlandev, (p80211msg_t *)&quality);
@@ -238,3 +221,3 @@
-	wstats->qual.qual = qual_as_percent(quality.link.data);    /* overall link quality */
-	wstats->qual.level = quality.level.data;  /* instant signal level */
-	wstats->qual.noise = quality.noise.data;  /* instant noise level */
+	wstats->qual.qual = qual_as_percent(quality.link.data);	/* overall link quality */
+	wstats->qual.level = quality.level.data;	/* instant signal level */
+	wstats->qual.noise = quality.noise.data;	/* instant noise level */
@@ -247,2 +230,2 @@
-	wstats->discard.fragment = 0;  // incomplete fragments
-	wstats->discard.retries = 0;   // tx retries.
+	wstats->discard.fragment = 0;	/* incomplete fragments */
+	wstats->discard.retries = 0;	/* tx retries. */
@@ -251,2 +233,0 @@
-	DBFEXIT;
-
@@ -264,2 +244,0 @@
-	DBFENTER;
-
@@ -284 +262,0 @@
-	DBFEXIT;
@@ -293,2 +271,2 @@
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
@@ -298,2 +275,0 @@
-	DBFENTER;
-
@@ -303 +279 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -321,2 +297 @@
- exit:
-	DBFEXIT;
+exit:
@@ -331,2 +306,2 @@
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
@@ -336,2 +310,0 @@
-	DBFENTER;
-
@@ -347 +320 @@
-	if ( (freq->e == 0) && (freq->m <= 1000) )
+	if ((freq->e == 0) && (freq->m <= 1000))
@@ -353 +326 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -360,2 +333 @@
- exit:
-	DBFEXIT;
+exit:
@@ -371,2 +342,0 @@
-	DBFENTER;
-
@@ -388 +357,0 @@
-	DBFEXIT;
@@ -397,6 +366,4 @@
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
-	int 	result;
-	int     err = 0;
-
-	DBFENTER;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
+	int result;
+	int err = 0;
@@ -431 +398 @@
-		WLAN_LOG_INFO("Operation mode: %d not support\n", *mode);
+		printk(KERN_INFO "Operation mode: %d not support\n", *mode);
@@ -440 +407 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -445,3 +412 @@
- exit:
-	DBFEXIT;
-
+exit:
@@ -451 +415,0 @@
-
@@ -456 +420 @@
-        struct iw_range *range = (struct iw_range *) extra;
+	struct iw_range *range = (struct iw_range *)extra;
@@ -459,3 +423 @@
-	DBFENTER;
-
-	// for backward compatability set size & zero everything we don't understand
+	/* for backward compatability set size and zero everything we don't understand */
@@ -463 +425 @@
-	memset(range,0,sizeof(*range));
+	memset(range, 0, sizeof(*range));
@@ -466 +428 @@
-	// XXX what about min/max_pmp, min/max_pmt, etc.
+	/* XXX what about min/max_pmp, min/max_pmt, etc. */
@@ -476,6 +438,6 @@
-        range->event_capa[0] = (IW_EVENT_CAPA_K_0 |  //mode/freq/ssid
-                                IW_EVENT_CAPA_MASK(SIOCGIWAP) |
-                                IW_EVENT_CAPA_MASK(SIOCGIWSCAN));
-        range->event_capa[1] = IW_EVENT_CAPA_K_1;  //encode
-        range->event_capa[4] = (IW_EVENT_CAPA_MASK(IWEVQUAL) |
-                                IW_EVENT_CAPA_MASK(IWEVCUSTOM) );
+	range->event_capa[0] = (IW_EVENT_CAPA_K_0 |	/* mode/freq/ssid */
+				IW_EVENT_CAPA_MASK(SIOCGIWAP) |
+				IW_EVENT_CAPA_MASK(SIOCGIWSCAN));
+	range->event_capa[1] = IW_EVENT_CAPA_K_1;	/* encode */
+	range->event_capa[4] = (IW_EVENT_CAPA_MASK(IWEVQUAL) |
+				IW_EVENT_CAPA_MASK(IWEVCUSTOM));
@@ -487 +449 @@
-	for (i = 0; i < NUM_CHANNELS ; i++) {
+	for (i = 0; i < NUM_CHANNELS; i++) {
@@ -501 +463 @@
-	// XXX these need to be nsd-specific!
+	/* XXX these need to be nsd-specific! */
@@ -513 +475 @@
-	// XXX what about num_bitrates/throughput?
+	/* XXX what about num_bitrates/throughput? */
@@ -517 +479 @@
-	// XXX need to cap it if we're running at ~2Mbps..
+	/* XXX need to cap it if we're running at ~2Mbps.. */
@@ -520 +481,0 @@
-	DBFEXIT;
@@ -531,2 +491,0 @@
-	DBFENTER;
-
@@ -536 +494,0 @@
-	DBFEXIT;
@@ -548,2 +505,0 @@
-	DBFENTER;
-
@@ -579,2 +535 @@
- exit:
-	DBFEXIT;
+exit:
@@ -589,2 +544,2 @@
-	p80211msg_dot11req_mibset_t	msg;
-	p80211item_pstr32_t		pstr;
+	p80211msg_dot11req_mibset_t msg;
+	p80211item_pstr32_t pstr;
@@ -596 +550,0 @@
-	DBFENTER;
@@ -603 +557 @@
-	if((i = (erq->flags & IW_ENCODE_INDEX))) {
+	if ((i = (erq->flags & IW_ENCODE_INDEX))) {
@@ -608,2 +562 @@
-		}
-		else
+		} else
@@ -614 +567,4 @@
-			result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID, i);
+			result =
+			    p80211wext_dorequest(wlandev,
+						 DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID,
+						 i);
@@ -623 +579 @@
-		// Use defaultkey if no Key Index
+		/* Use defaultkey if no Key Index */
@@ -628 +584 @@
-	if((erq->flags & IW_ENCODE_NOKEY) == 0 ) {
+	if ((erq->flags & IW_ENCODE_NOKEY) == 0) {
@@ -645,21 +601,24 @@
-			switch(i)
-			{
-				case 0:
-					pstr.did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0;
-					break;
-
-				case 1:
-					pstr.did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1;
-					break;
-
-				case 2:
-					pstr.did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2;
-					break;
-
-				case 3:
-					pstr.did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3;
-					break;
-
-				default:
-					err = -EINVAL;
-					goto exit;
+			switch (i) {
+			case 0:
+				pstr.did =
+				    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0;
+				break;
+
+			case 1:
+				pstr.did =
+				    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1;
+				break;
+
+			case 2:
+				pstr.did =
+				    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2;
+				break;
+
+			case 3:
+				pstr.did =
+				    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3;
+				break;
+
+			default:
+				err = -EINVAL;
+				goto exit;
@@ -670 +629 @@
-			result = p80211req_dorequest(wlandev, (u8*)&msg);
+			result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -682 +641,4 @@
-		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked, P80211ENUM_truth_false);
+		result =
+		    p80211wext_dorequest(wlandev,
+					 DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked,
+					 P80211ENUM_truth_false);
@@ -684 +646,4 @@
-		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked, P80211ENUM_truth_true);
+		result =
+		    p80211wext_dorequest(wlandev,
+					 DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked,
+					 P80211ENUM_truth_true);
@@ -693,6 +658,6 @@
-	    depends on the card used. With  most  cards,  in  open  mode  no
-	    authentication  is  used  and  the  card  may  also  accept non-
-	    encrypted sessions, whereas in restricted  mode  only  encrypted
-	    sessions  are  accepted  and the card will use authentication if
-	    available.
-	*/
+	   depends on the card used. With  most  cards,  in  open  mode  no
+	   authentication  is  used  and  the  card  may  also  accept non-
+	   encrypted sessions, whereas in restricted  mode  only  encrypted
+	   sessions  are  accepted  and the card will use authentication if
+	   available.
+	 */
@@ -700,4 +665,9 @@
-		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted, P80211ENUM_truth_true);
-	}
-	else if (erq->flags & IW_ENCODE_OPEN) {
-		result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted, P80211ENUM_truth_false);
+		result =
+		    p80211wext_dorequest(wlandev,
+					 DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted,
+					 P80211ENUM_truth_true);
+	} else if (erq->flags & IW_ENCODE_OPEN) {
+		result =
+		    p80211wext_dorequest(wlandev,
+					 DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted,
+					 P80211ENUM_truth_false);
@@ -711 +681 @@
- exit:
+exit:
@@ -713 +682,0 @@
-	DBFEXIT;
@@ -723,2 +691,0 @@
-	DBFENTER;
-
@@ -734 +701 @@
-	  	memset(essid, 0, sizeof(wlandev->ssid.data));
+		memset(essid, 0, sizeof(wlandev->ssid.data));
@@ -739 +705,0 @@
-	DBFEXIT;
@@ -748 +714 @@
-	p80211msg_lnxreq_autojoin_t     msg;
+	p80211msg_lnxreq_autojoin_t msg;
@@ -754,2 +719,0 @@
-	DBFENTER;
-
@@ -761,3 +725,2 @@
-
-	if ( wlandev->hostwep & HOSTWEP_SHAREDKEY )
-	  msg.authtype.data = P80211ENUM_authalg_sharedkey;
+	if (wlandev->hostwep & HOSTWEP_SHAREDKEY)
+		msg.authtype.data = P80211ENUM_authalg_sharedkey;
@@ -765 +728 @@
-	  msg.authtype.data = P80211ENUM_authalg_opensystem;
+		msg.authtype.data = P80211ENUM_authalg_opensystem;
@@ -770 +733,2 @@
-	if (length) length--;
+	if (length)
+		length--;
@@ -774,4 +738,2 @@
-
-	if (length && essid[length-1] == '\0') {
-	  length--;
-	}
+	if (length && essid[length - 1] == '\0')
+		length--;
@@ -782,3 +744,3 @@
-	WLAN_LOG_DEBUG(1,"autojoin_ssid for %s \n",essid);
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
-        WLAN_LOG_DEBUG(1,"autojoin_ssid %d\n",result);
+	pr_debug("autojoin_ssid for %s \n", essid);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+	pr_debug("autojoin_ssid %d\n", result);
@@ -791,2 +753 @@
- exit:
-	DBFEXIT;
+exit:
@@ -796 +756,0 @@
-
@@ -804,2 +763,0 @@
-	DBFENTER;
-
@@ -814,2 +772 @@
- exit:
- 	DBFEXIT;
+exit:
@@ -819 +775,0 @@
-
@@ -825,2 +781,2 @@
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
@@ -830,2 +785,0 @@
-	DBFENTER;
-
@@ -835 +789 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -844 +798 @@
-	rrq->fixed = 0;   /* can it change? */
+	rrq->fixed = 0;		/* can it change? */
@@ -869,2 +823 @@
- exit:
-	DBFEXIT;
+exit:
@@ -879,2 +832,2 @@
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
@@ -884,2 +836,0 @@
-	DBFENTER;
-
@@ -889 +840 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -902,2 +853 @@
- exit:
-	DBFEXIT;
+exit:
@@ -907 +856,0 @@
-
@@ -913,2 +862,2 @@
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
@@ -918,2 +866,0 @@
-	DBFENTER;
-
@@ -933 +880 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -940,2 +887 @@
- exit:
-	DBFEXIT;
+exit:
@@ -950,2 +896,2 @@
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
@@ -955,2 +900,0 @@
-	DBFENTER;
-
@@ -958 +902,2 @@
-	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold;
+	mibitem.did =
+	    DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold;
@@ -960 +905 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -973,2 +918 @@
- exit:
-	DBFEXIT;
+exit:
@@ -983,2 +927,2 @@
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
@@ -988,2 +931,0 @@
-	DBFENTER;
-
@@ -996 +938,2 @@
-	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold;
+	mibitem.did =
+	    DIDmib_dot11mac_dot11OperationTable_dot11FragmentationThreshold;
@@ -1004 +947 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -1011,2 +954 @@
- exit:
-	DBFEXIT;
+exit:
@@ -1029,2 +971,2 @@
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
@@ -1035,2 +976,0 @@
-	DBFENTER;
-
@@ -1041 +981 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -1055 +995 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -1066 +1006,2 @@
-	mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11MaxTransmitMSDULifetime;
+	mibitem.did =
+	    DIDmib_dot11mac_dot11OperationTable_dot11MaxTransmitMSDULifetime;
@@ -1069 +1010 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -1097,2 +1038 @@
- exit:
-	DBFEXIT;
+exit:
@@ -1108,2 +1048,2 @@
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
@@ -1113,2 +1052,0 @@
-	DBFENTER;
-
@@ -1128,2 +1066,3 @@
-		mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11MaxTransmitMSDULifetime;
-		mibitem.data =  rrq->value /= 1024;
+		mibitem.did =
+		    DIDmib_dot11mac_dot11OperationTable_dot11MaxTransmitMSDULifetime;
+		mibitem.data = rrq->value /= 1024;
@@ -1132 +1071 @@
-		result = p80211req_dorequest(wlandev, (u8*)&msg);
+		result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -1140 +1079,2 @@
-			mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11LongRetryLimit;
+			mibitem.did =
+			    DIDmib_dot11mac_dot11OperationTable_dot11LongRetryLimit;
@@ -1143,2 +1083,3 @@
-			memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-			result = p80211req_dorequest(wlandev, (u8*)&msg);
+			memcpy(&msg.mibattribute.data, &mibitem,
+			       sizeof(mibitem));
+			result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -1153 +1094,2 @@
-			mibitem.did = DIDmib_dot11mac_dot11OperationTable_dot11ShortRetryLimit;
+			mibitem.did =
+			    DIDmib_dot11mac_dot11OperationTable_dot11ShortRetryLimit;
@@ -1156,2 +1098,3 @@
-			memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-			result = p80211req_dorequest(wlandev, (u8*)&msg);
+			memcpy(&msg.mibattribute.data, &mibitem,
+			       sizeof(mibitem));
+			result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -1166,2 +1109 @@
- exit:
-	DBFEXIT;
+exit:
@@ -1173,2 +1115,2 @@
-                               struct iw_request_info *info,
-                               struct iw_param *rrq, char *extra)
+			       struct iw_request_info *info,
+			       struct iw_param *rrq, char *extra)
@@ -1177,6 +1119,4 @@
-        p80211item_uint32_t             mibitem;
-        p80211msg_dot11req_mibset_t     msg;
-        int result;
-        int err = 0;
-
-        DBFENTER;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
+	int result;
+	int err = 0;
@@ -1184,4 +1124,4 @@
-       if (!wlan_wext_write) {
-                err = (-EOPNOTSUPP);
-                goto exit;
-        }
+	if (!wlan_wext_write) {
+		err = (-EOPNOTSUPP);
+		goto exit;
+	}
@@ -1189,2 +1129,3 @@
-        msg.msgcode = DIDmsg_dot11req_mibset;
-	mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel;
+	msg.msgcode = DIDmsg_dot11req_mibset;
+	mibitem.did =
+	    DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel;
@@ -1192 +1133 @@
-	  mibitem.data = 30;
+		mibitem.data = 30;
@@ -1194,12 +1135,11 @@
-	  mibitem.data = rrq->value;
-        memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
-        result = p80211req_dorequest(wlandev, (u8*)&msg);
-
-        if (result) {
-                err = -EFAULT;
-                goto exit;
-        }
-
- exit:
-        DBFEXIT;
-        return err;
+		mibitem.data = rrq->value;
+	memcpy(&msg.mibattribute.data, &mibitem, sizeof(mibitem));
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
+
+	if (result) {
+		err = -EFAULT;
+		goto exit;
+	}
+
+exit:
+	return err;
@@ -1213,2 +1153,2 @@
-	p80211item_uint32_t             mibitem;
-	p80211msg_dot11req_mibset_t     msg;
+	p80211item_uint32_t mibitem;
+	p80211msg_dot11req_mibset_t msg;
@@ -1218,2 +1157,0 @@
-	DBFENTER;
-
@@ -1221 +1159,2 @@
-	mibitem.did = DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel;
+	mibitem.did =
+	    DIDmib_dot11phy_dot11PhyTxPowerTable_dot11CurrentTxPowerLevel;
@@ -1224 +1163 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -1233 +1172 @@
-	// XXX handle OFF by setting disabled = 1;
+	/* XXX handle OFF by setting disabled = 1; */
@@ -1235 +1174 @@
-	rrq->flags = 0; // IW_TXPOW_DBM;
+	rrq->flags = 0;		/* IW_TXPOW_DBM; */
@@ -1240,2 +1179 @@
- exit:
-	DBFEXIT;
+exit:
@@ -1250,5 +1188,3 @@
-        struct sockaddr address[IW_MAX_SPY];
-        int number = srq->length;
-        int i;
-
-	DBFENTER;
+	struct sockaddr address[IW_MAX_SPY];
+	int number = srq->length;
+	int i;
@@ -1257 +1193 @@
-	memcpy(address, extra, sizeof(struct sockaddr)*number);
+	memcpy(address, extra, sizeof(struct sockaddr) * number);
@@ -1259 +1195 @@
-        wlandev->spy_number = 0;
+	wlandev->spy_number = 0;
@@ -1261 +1197 @@
-        if (number > 0) {
+	if (number > 0) {
@@ -1263,2 +1199,2 @@
-                /* extract the addresses */
-                for (i = 0; i < number; i++) {
+		/* extract the addresses */
+		for (i = 0; i < number; i++) {
@@ -1266 +1202,2 @@
-                        memcpy(wlandev->spy_address[i], address[i].sa_data, ETH_ALEN);
+			memcpy(wlandev->spy_address[i], address[i].sa_data,
+			       ETH_ALEN);
@@ -1269,2 +1206,3 @@
-                /* reset stats */
-                memset(wlandev->spy_stat, 0, sizeof(struct iw_quality) * IW_MAX_SPY);
+		/* reset stats */
+		memset(wlandev->spy_stat, 0,
+		       sizeof(struct iw_quality) * IW_MAX_SPY);
@@ -1272,3 +1210,3 @@
-                /* set number of addresses */
-                wlandev->spy_number = number;
-        }
+		/* set number of addresses */
+		wlandev->spy_number = number;
+	}
@@ -1276 +1213,0 @@
-	DBFEXIT;
@@ -1287,17 +1224,17 @@
-        struct sockaddr address[IW_MAX_SPY];
-        struct iw_quality spy_stat[IW_MAX_SPY];
-        int number;
-        int i;
-
-	DBFENTER;
-
-        number = wlandev->spy_number;
-
-        if (number > 0) {
-
-                /* populate address and spy struct's */
-                for (i = 0; i < number; i++) {
-                        memcpy(address[i].sa_data, wlandev->spy_address[i], ETH_ALEN);
-                        address[i].sa_family = AF_UNIX;
-                	memcpy(&spy_stat[i], &wlandev->spy_stat[i], sizeof(struct iw_quality));
-                }
+	struct sockaddr address[IW_MAX_SPY];
+	struct iw_quality spy_stat[IW_MAX_SPY];
+	int number;
+	int i;
+
+	number = wlandev->spy_number;
+
+	if (number > 0) {
+
+		/* populate address and spy struct's */
+		for (i = 0; i < number; i++) {
+			memcpy(address[i].sa_data, wlandev->spy_address[i],
+			       ETH_ALEN);
+			address[i].sa_family = AF_UNIX;
+			memcpy(&spy_stat[i], &wlandev->spy_stat[i],
+			       sizeof(struct iw_quality));
+		}
@@ -1306,8 +1243,9 @@
-                for (i=0; i < number; i++)
-                        wlandev->spy_stat[i].updated = 0;
-        }
-
-        /* push stuff to user space */
-        srq->length = number;
-	memcpy(extra, address, sizeof(struct sockaddr)*number);
-	memcpy(extra+sizeof(struct sockaddr)*number, spy_stat, sizeof(struct iw_quality)*number);
+		for (i = 0; i < number; i++)
+			wlandev->spy_stat[i].updated = 0;
+	}
+
+	/* push stuff to user space */
+	srq->length = number;
+	memcpy(extra, address, sizeof(struct sockaddr) * number);
+	memcpy(extra + sizeof(struct sockaddr) * number, spy_stat,
+	       sizeof(struct iw_quality) * number);
@@ -1315 +1252,0 @@
-	DBFEXIT;
@@ -1319 +1256 @@
-static int prism2_result2err (int prism2_result)
+static int prism2_result2err(int prism2_result)
@@ -1324,12 +1261,12 @@
-		case P80211ENUM_resultcode_invalid_parameters:
-			err = -EINVAL;
-			break;
-		case P80211ENUM_resultcode_implementation_failure:
-			err = -EIO;
-			break;
-		case P80211ENUM_resultcode_not_supported:
-			err = -EOPNOTSUPP;
-			break;
-		default:
-			err = 0;
-			break;
+	case P80211ENUM_resultcode_invalid_parameters:
+		err = -EINVAL;
+		break;
+	case P80211ENUM_resultcode_implementation_failure:
+		err = -EIO;
+		break;
+	case P80211ENUM_resultcode_not_supported:
+		err = -EOPNOTSUPP;
+		break;
+	default:
+		err = 0;
+		break;
@@ -1342,2 +1279,2 @@
-			     struct iw_request_info *info,
-			     struct iw_point *srq, char *extra)
+			      struct iw_request_info *info,
+			      struct iw_point *srq, char *extra)
@@ -1346 +1283 @@
-	p80211msg_dot11req_scan_t	msg;
+	p80211msg_dot11req_scan_t msg;
@@ -1351,2 +1287,0 @@
-	DBFENTER;
-
@@ -1354 +1289 @@
-		WLAN_LOG_ERROR("Can't scan in AP mode\n");
+		printk(KERN_ERR "Can't scan in AP mode\n");
@@ -1363 +1298 @@
-	memset(&(msg.bssid.data), 0xFF, sizeof (p80211item_pstr6_t));
+	memset(&(msg.bssid.data), 0xFF, sizeof(p80211item_pstr6_t));
@@ -1370 +1305 @@
-		msg.channellist.data.data[i-1] = i;
+		msg.channellist.data.data[i - 1] = i;
@@ -1376 +1311 @@
-	result = p80211req_dorequest(wlandev, (u8*)&msg);
+	result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -1378 +1313 @@
-		err = prism2_result2err (msg.resultcode.data);
+		err = prism2_result2err(msg.resultcode.data);
@@ -1380,2 +1315 @@
- exit:
-	DBFEXIT;
+exit:
@@ -1385 +1318,0 @@
-
@@ -1390,3 +1323,3 @@
-static char *
-wext_translate_bss(struct iw_request_info *info, char *current_ev,
-		   char *end_buf, p80211msg_dot11req_scan_results_t *bss)
+static char *wext_translate_bss(struct iw_request_info *info, char *current_ev,
+				char *end_buf,
+				p80211msg_dot11req_scan_results_t *bss)
@@ -1400 +1333,3 @@
-	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_ADDR_LEN);
+	current_ev =
+	    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+				 IW_EV_ADDR_LEN);
@@ -1409,2 +1344,4 @@
-		size = wlan_min(IW_ESSID_MAX_SIZE, bss->ssid.data.len);
-		memset(&essid, 0, sizeof (essid));
+		size =
+		    min_t(unsigned short, IW_ESSID_MAX_SIZE,
+			  bss->ssid.data.len);
+		memset(&essid, 0, sizeof(essid));
@@ -1412 +1349 @@
-		WLAN_LOG_DEBUG(1, " essid size = %d\n", size);
+		pr_debug(" essid size = %d\n", size);
@@ -1416,2 +1353,4 @@
-		current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, &essid[0]);
-		WLAN_LOG_DEBUG(1, " essid size OK.\n");
+		current_ev =
+		    iwe_stream_add_point(info, current_ev, end_buf, &iwe,
+					 &essid[0]);
+		pr_debug(" essid size OK.\n");
@@ -1421,3 +1360,3 @@
-		case P80211ENUM_bsstype_infrastructure:
-			iwe.u.mode = IW_MODE_MASTER;
-			break;
+	case P80211ENUM_bsstype_infrastructure:
+		iwe.u.mode = IW_MODE_MASTER;
+		break;
@@ -1425,3 +1364,3 @@
-		case P80211ENUM_bsstype_independent:
-			iwe.u.mode = IW_MODE_ADHOC;
-			break;
+	case P80211ENUM_bsstype_independent:
+		iwe.u.mode = IW_MODE_ADHOC;
+		break;
@@ -1429,3 +1368,3 @@
-		default:
-			iwe.u.mode = 0;
-			break;
+	default:
+		iwe.u.mode = 0;
+		break;
@@ -1435 +1374,3 @@
-		current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_UINT_LEN);
+		current_ev =
+		    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+					 IW_EV_UINT_LEN);
@@ -1444 +1385,2 @@
-	current_ev = iwe_stream_add_point(info, current_ev, end_buf, &iwe, NULL);
+	current_ev =
+	    iwe_stream_add_point(info, current_ev, end_buf, &iwe, NULL);
@@ -1450 +1392,3 @@
-	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_FREQ_LEN);
+	current_ev =
+	    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+				 IW_EV_FREQ_LEN);
@@ -1458 +1402,3 @@
-	current_ev = iwe_stream_add_event(info, current_ev, end_buf, &iwe, IW_EV_QUAL_LEN);
+	current_ev =
+	    iwe_stream_add_event(info, current_ev, end_buf, &iwe,
+				 IW_EV_QUAL_LEN);
@@ -1463 +1408,0 @@
-
@@ -1465,2 +1410,2 @@
-			     struct iw_request_info *info,
-			     struct iw_point *srq, char *extra)
+			      struct iw_request_info *info,
+			      struct iw_point *srq, char *extra)
@@ -1469 +1414 @@
-	p80211msg_dot11req_scan_results_t	msg;
+	p80211msg_dot11req_scan_results_t msg;
@@ -1476,2 +1420,0 @@
-	DBFENTER;
-
@@ -1487 +1430 @@
-		result = p80211req_dorequest(wlandev, (u8*)&msg);
+		result = p80211req_dorequest(wlandev, (u8 *)&msg);
@@ -1493 +1436,3 @@
-		current_ev = wext_translate_bss(info, current_ev, extra + IW_SCAN_MAX_DATA, &msg);
+		current_ev =
+		    wext_translate_bss(info, current_ev,
+				       extra + IW_SCAN_MAX_DATA, &msg);
@@ -1499 +1444 @@
-	srq->flags = 0;	/* todo */
+	srq->flags = 0;		/* todo */
@@ -1502 +1447 @@
-		err = prism2_result2err (msg.resultcode.data);
+		err = prism2_result2err(msg.resultcode.data);
@@ -1504 +1448,0 @@
-	DBFEXIT;
@@ -1508,2 +1452 @@
-/*****************************************************/
-//extra wireless extensions stuff to support NetworkManager (I hope)
+/* extra wireless extensions stuff to support NetworkManager (I hope) */
@@ -1513,2 +1456,2 @@
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
+				    struct iw_request_info *info,
+				    union iwreq_data *wrqu, char *extra)
@@ -1516,68 +1459,74 @@
-  wlandevice_t *wlandev = dev->ml_priv;
-  struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
-	p80211msg_dot11req_mibset_t	msg;
-	p80211item_pstr32_t		*pstr;
-
-  int result = 0;
-  struct iw_point *encoding = &wrqu->encoding;
-  int idx = encoding->flags & IW_ENCODE_INDEX;
-
-  WLAN_LOG_DEBUG(1,"set_encode_ext flags[%d] alg[%d] keylen[%d]\n",ext->ext_flags,(int)ext->alg,(int)ext->key_len);
-
-
-  if ( ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY ) {
-    // set default key ? I'm not sure if this the the correct thing to do here
-
-    if ( idx ) {
-      if (idx < 1 || idx > NUM_WEPKEYS) {
-	return -EINVAL;
-      } else
-	idx--;
-    }
-    WLAN_LOG_DEBUG(1,"setting default key (%d)\n",idx);
-    result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID, idx);
-    if ( result )
-      return -EFAULT;
-  }
-
-
-  if ( ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY ) {
-    if (!(ext->alg & IW_ENCODE_ALG_WEP)) {
-      WLAN_LOG_DEBUG(1,"asked to set a non wep key :(");
-      return -EINVAL;
-    }
-    if (idx) {
-      if (idx <1 || idx > NUM_WEPKEYS)
-	return -EINVAL;
-      else
-	idx--;
-    }
-    WLAN_LOG_DEBUG(1,"Set WEP key (%d)\n",idx);
-    wlandev->wep_keylens[idx] = ext->key_len;
-    memcpy(wlandev->wep_keys[idx], ext->key, ext->key_len);
-
-    memset( &msg,0,sizeof(msg));
-    pstr = (p80211item_pstr32_t*)&msg.mibattribute.data;
-    memcpy(pstr->data.data, ext->key,ext->key_len);
-    pstr->data.len = ext->key_len;
-    switch (idx) {
-    case 0:
-      pstr->did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0;
-      break;
-    case 1:
-      pstr->did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1;
-      break;
-    case 2:
-      pstr->did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2;
-      break;
-    case 3:
-      pstr->did = DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3;
-      break;
-    default:
-      break;
-    }
-    msg.msgcode = DIDmsg_dot11req_mibset;
-    result = p80211req_dorequest(wlandev,(u8*)&msg);
-    WLAN_LOG_DEBUG(1,"result (%d)\n",result);
-  }
-  return result;
+	wlandevice_t *wlandev = dev->ml_priv;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	p80211msg_dot11req_mibset_t msg;
+	p80211item_pstr32_t *pstr;
+
+	int result = 0;
+	struct iw_point *encoding = &wrqu->encoding;
+	int idx = encoding->flags & IW_ENCODE_INDEX;
+
+	pr_debug("set_encode_ext flags[%d] alg[%d] keylen[%d]\n",
+	       ext->ext_flags, (int)ext->alg, (int)ext->key_len);
+
+	if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+		/* set default key ? I'm not sure if this the the correct thing to do here */
+
+		if (idx) {
+			if (idx < 1 || idx > NUM_WEPKEYS)
+				return -EINVAL;
+			else
+				idx--;
+		}
+		pr_debug("setting default key (%d)\n", idx);
+		result =
+		    p80211wext_dorequest(wlandev,
+					 DIDmib_dot11smt_dot11PrivacyTable_dot11WEPDefaultKeyID,
+					 idx);
+		if (result)
+			return -EFAULT;
+	}
+
+	if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+		if (!(ext->alg & IW_ENCODE_ALG_WEP)) {
+			pr_debug("asked to set a non wep key :(");
+			return -EINVAL;
+		}
+		if (idx) {
+			if (idx < 1 || idx > NUM_WEPKEYS)
+				return -EINVAL;
+			else
+				idx--;
+		}
+		pr_debug("Set WEP key (%d)\n", idx);
+		wlandev->wep_keylens[idx] = ext->key_len;
+		memcpy(wlandev->wep_keys[idx], ext->key, ext->key_len);
+
+		memset(&msg, 0, sizeof(msg));
+		pstr = (p80211item_pstr32_t *)&msg.mibattribute.data;
+		memcpy(pstr->data.data, ext->key, ext->key_len);
+		pstr->data.len = ext->key_len;
+		switch (idx) {
+		case 0:
+			pstr->did =
+			    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey0;
+			break;
+		case 1:
+			pstr->did =
+			    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey1;
+			break;
+		case 2:
+			pstr->did =
+			    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey2;
+			break;
+		case 3:
+			pstr->did =
+			    DIDmib_dot11smt_dot11WEPDefaultKeysTable_dot11WEPDefaultKey3;
+			break;
+		default:
+			break;
+		}
+		msg.msgcode = DIDmsg_dot11req_mibset;
+		result = p80211req_dorequest(wlandev, (u8 *)&msg);
+		pr_debug("result (%d)\n", result);
+	}
+	return result;
@@ -1588,3 +1537,2 @@
-				struct iw_request_info *info,
-				union iwreq_data *wrqu, char *extra)
-
+				    struct iw_request_info *info,
+				    union iwreq_data *wrqu, char *extra)
@@ -1600,4 +1548,2 @@
-	DBFENTER;
-
-	WLAN_LOG_DEBUG(1,"get_encode_ext flags[%d] alg[%d] keylen[%d]\n",ext->ext_flags,(int)ext->alg,(int)ext->key_len);
-
+	pr_debug("get_encode_ext flags[%d] alg[%d] keylen[%d]\n",
+	       ext->ext_flags, (int)ext->alg, (int)ext->key_len);
@@ -1606,2 +1552,3 @@
-	if ( max_len <= 0) {
-		WLAN_LOG_DEBUG(1,"get_encodeext max_len [%d] invalid\n",max_len);
+	if (max_len <= 0) {
+		pr_debug("get_encodeext max_len [%d] invalid\n",
+		       max_len);
@@ -1613 +1560 @@
-	WLAN_LOG_DEBUG(1,"get_encode_ext index [%d]\n",idx);
+	pr_debug("get_encode_ext index [%d]\n", idx);
@@ -1616,2 +1563,3 @@
-		if (idx < 1 || idx > NUM_WEPKEYS ) {
-			WLAN_LOG_DEBUG(1,"get_encode_ext invalid key index [%d]\n",idx);
+		if (idx < 1 || idx > NUM_WEPKEYS) {
+			printk(KERN_DEBUG
+			       "get_encode_ext invalid key index [%d]\n", idx);
@@ -1628 +1576 @@
-	memset(ext,0,sizeof(*ext));
+	memset(ext, 0, sizeof(*ext));
@@ -1632 +1580 @@
-	memcpy( ext->key, wlandev->wep_keys[idx] , ext->key_len );
+	memcpy(ext->key, wlandev->wep_keys[idx], ext->key_len);
@@ -1636,2 +1583,0 @@
-	DBFEXIT;
-
@@ -1641 +1586,0 @@
-
@@ -1643,45 +1588,25 @@
-static int p80211_wext_set_iwauth (struct net_device *dev,
-				   struct iw_request_info *info,
-				   union iwreq_data *wrqu, char *extra)
-{
-  wlandevice_t *wlandev = dev->ml_priv;
-  struct iw_param *param = &wrqu->param;
-  int result =0;
-
-  WLAN_LOG_DEBUG(1,"set_iwauth flags[%d]\n",(int)param->flags & IW_AUTH_INDEX );
-
-  switch (param->flags & IW_AUTH_INDEX) {
-  case IW_AUTH_DROP_UNENCRYPTED:
-    WLAN_LOG_DEBUG(1,"drop_unencrypted %d\n",param->value);
-    if (param->value)
-      result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted, P80211ENUM_truth_true);
-    else
-      result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted, P80211ENUM_truth_false);
-    break;
-
-  case IW_AUTH_PRIVACY_INVOKED:
-    WLAN_LOG_DEBUG(1,"privacy invoked %d\n",param->value);
-    if ( param->value)
-      result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked, P80211ENUM_truth_true);
-    else
-      result = p80211wext_dorequest(wlandev, DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked, P80211ENUM_truth_false);
-
-    break;
-
-  case IW_AUTH_80211_AUTH_ALG:
-    if ( param->value & IW_AUTH_ALG_OPEN_SYSTEM ) {
-      WLAN_LOG_DEBUG(1,"set open_system\n");
-      wlandev->hostwep &= ~HOSTWEP_SHAREDKEY;
-    } else if ( param->value & IW_AUTH_ALG_SHARED_KEY) {
-      WLAN_LOG_DEBUG(1,"set shared key\n");
-      wlandev->hostwep |= HOSTWEP_SHAREDKEY;
-    } else {
-      /* don't know what to do know :( */
-      WLAN_LOG_DEBUG(1,"unknown AUTH_ALG (%d)\n",param->value);
-      result = -EINVAL;
-    }
-    break;
-
-  default:
-    break;
-  }
+static int p80211_wext_set_iwauth(struct net_device *dev,
+				  struct iw_request_info *info,
+				  union iwreq_data *wrqu, char *extra)
+{
+	wlandevice_t *wlandev = dev->ml_priv;
+	struct iw_param *param = &wrqu->param;
+	int result = 0;
+
+	pr_debug("set_iwauth flags[%d]\n",
+	       (int)param->flags & IW_AUTH_INDEX);
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_DROP_UNENCRYPTED:
+		pr_debug("drop_unencrypted %d\n", param->value);
+		if (param->value)
+			result =
+			    p80211wext_dorequest(wlandev,
+						 DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted,
+						 P80211ENUM_truth_true);
+		else
+			result =
+			    p80211wext_dorequest(wlandev,
+						 DIDmib_dot11smt_dot11PrivacyTable_dot11ExcludeUnencrypted,
+						 P80211ENUM_truth_false);
+		break;
@@ -1688,0 +1614,14 @@
+	case IW_AUTH_PRIVACY_INVOKED:
+		pr_debug("privacy invoked %d\n", param->value);
+		if (param->value)
+			result =
+			    p80211wext_dorequest(wlandev,
+						 DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked,
+						 P80211ENUM_truth_true);
+		else
+			result =
+			    p80211wext_dorequest(wlandev,
+						 DIDmib_dot11smt_dot11PrivacyTable_dot11PrivacyInvoked,
+						 P80211ENUM_truth_false);
+
+		break;
@@ -1689,0 +1629,14 @@
+	case IW_AUTH_80211_AUTH_ALG:
+		if (param->value & IW_AUTH_ALG_OPEN_SYSTEM) {
+			pr_debug("set open_system\n");
+			wlandev->hostwep &= ~HOSTWEP_SHAREDKEY;
+		} else if (param->value & IW_AUTH_ALG_SHARED_KEY) {
+			pr_debug("set shared key\n");
+			wlandev->hostwep |= HOSTWEP_SHAREDKEY;
+		} else {
+			/* don't know what to do know  */
+			pr_debug("unknown AUTH_ALG (%d)\n",
+			       param->value);
+			result = -EINVAL;
+		}
+		break;
@@ -1691 +1644,5 @@
-  return result;
+	default:
+		break;
+	}
+
+	return result;
@@ -1695,80 +1652,83 @@
-static int p80211_wext_get_iwauth (struct net_device *dev,
-				   struct iw_request_info *info,
-				   union iwreq_data *wrqu, char *extra)
-{
-  wlandevice_t *wlandev = dev->ml_priv;
-  struct iw_param *param = &wrqu->param;
-  int result =0;
-
-  WLAN_LOG_DEBUG(1,"get_iwauth flags[%d]\n",(int)param->flags & IW_AUTH_INDEX );
-
-  switch (param->flags & IW_AUTH_INDEX) {
-  case IW_AUTH_DROP_UNENCRYPTED:
-    param->value = wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED?1:0;
-    break;
-
-  case IW_AUTH_PRIVACY_INVOKED:
-    param->value = wlandev->hostwep & HOSTWEP_PRIVACYINVOKED?1:0;
-    break;
-
-  case IW_AUTH_80211_AUTH_ALG:
-    param->value = wlandev->hostwep & HOSTWEP_SHAREDKEY?IW_AUTH_ALG_SHARED_KEY:IW_AUTH_ALG_OPEN_SYSTEM;
-    break;
-
-
-  default:
-    break;
-  }
-
-
-
-  return result;
-}
-
-static iw_handler p80211wext_handlers[] =  {
-	(iw_handler) p80211wext_siwcommit,		/* SIOCSIWCOMMIT */
-	(iw_handler) p80211wext_giwname,		/* SIOCGIWNAME */
-	(iw_handler) NULL,				/* SIOCSIWNWID */
-	(iw_handler) NULL,				/* SIOCGIWNWID */
-	(iw_handler) p80211wext_siwfreq,  		/* SIOCSIWFREQ */
-	(iw_handler) p80211wext_giwfreq,  		/* SIOCGIWFREQ */
-	(iw_handler) p80211wext_siwmode,       		/* SIOCSIWMODE */
-	(iw_handler) p80211wext_giwmode,       		/* SIOCGIWMODE */
-	(iw_handler) NULL,                 		/* SIOCSIWSENS */
-	(iw_handler) NULL,                		/* SIOCGIWSENS */
-	(iw_handler) NULL, /* not used */     		/* SIOCSIWRANGE */
-	(iw_handler) p80211wext_giwrange,      		/* SIOCGIWRANGE */
-	(iw_handler) NULL, /* not used */     		/* SIOCSIWPRIV */
-	(iw_handler) NULL, /* kernel code */   		/* SIOCGIWPRIV */
-	(iw_handler) NULL, /* not used */     		/* SIOCSIWSTATS */
-	(iw_handler) NULL, /* kernel code */   		/* SIOCGIWSTATS */
-	(iw_handler) p80211wext_siwspy,			/* SIOCSIWSPY */
-	(iw_handler) p80211wext_giwspy,			/* SIOCGIWSPY */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL,              		/* SIOCSIWAP */
-	(iw_handler) p80211wext_giwap,         		/* SIOCGIWAP */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL,                  		/* SIOCGIWAPLIST */
-	(iw_handler) p80211wext_siwscan,		/* SIOCSIWSCAN */
-	(iw_handler) p80211wext_giwscan,		/* SIOCGIWSCAN */
-	(iw_handler) p80211wext_siwessid,  		/* SIOCSIWESSID */
-	(iw_handler) p80211wext_giwessid,      		/* SIOCGIWESSID */
-	(iw_handler) NULL,                 		/* SIOCSIWNICKN */
-	(iw_handler) p80211wext_giwessid,      		/* SIOCGIWNICKN */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL,                		/* SIOCSIWRATE */
-	(iw_handler) p80211wext_giwrate,      		/* SIOCGIWRATE */
-	(iw_handler) p80211wext_siwrts,  		/* SIOCSIWRTS */
-	(iw_handler) p80211wext_giwrts,        		/* SIOCGIWRTS */
-	(iw_handler) p80211wext_siwfrag,      		/* SIOCSIWFRAG */
-	(iw_handler) p80211wext_giwfrag,   		/* SIOCGIWFRAG */
-	(iw_handler) p80211wext_siwtxpow,           	/* SIOCSIWTXPOW */
-	(iw_handler) p80211wext_giwtxpow,  		/* SIOCGIWTXPOW */
-	(iw_handler) p80211wext_siwretry,     		/* SIOCSIWRETRY */
-	(iw_handler) p80211wext_giwretry,  		/* SIOCGIWRETRY */
-	(iw_handler) p80211wext_siwencode,     		/* SIOCSIWENCODE */
-	(iw_handler) p80211wext_giwencode,  		/* SIOCGIWENCODE */
-	(iw_handler) NULL,                 		/* SIOCSIWPOWER */
-	(iw_handler) NULL,                  		/* SIOCGIWPOWER */
+static int p80211_wext_get_iwauth(struct net_device *dev,
+				  struct iw_request_info *info,
+				  union iwreq_data *wrqu, char *extra)
+{
+	wlandevice_t *wlandev = dev->ml_priv;
+	struct iw_param *param = &wrqu->param;
+	int result = 0;
+
+	pr_debug("get_iwauth flags[%d]\n",
+	       (int)param->flags & IW_AUTH_INDEX);
+
+	switch (param->flags & IW_AUTH_INDEX) {
+	case IW_AUTH_DROP_UNENCRYPTED:
+		param->value =
+		    wlandev->hostwep & HOSTWEP_EXCLUDEUNENCRYPTED ? 1 : 0;
+		break;
+
+	case IW_AUTH_PRIVACY_INVOKED:
+		param->value =
+		    wlandev->hostwep & HOSTWEP_PRIVACYINVOKED ? 1 : 0;
+		break;
+
+	case IW_AUTH_80211_AUTH_ALG:
+		param->value =
+		    wlandev->
+		    hostwep & HOSTWEP_SHAREDKEY ? IW_AUTH_ALG_SHARED_KEY :
+		    IW_AUTH_ALG_OPEN_SYSTEM;
+		break;
+
+	default:
+		break;
+	}
+
+	return result;
+}
+
+static iw_handler p80211wext_handlers[] = {
+	(iw_handler) p80211wext_siwcommit,	/* SIOCSIWCOMMIT */
+	(iw_handler) p80211wext_giwname,	/* SIOCGIWNAME */
+	(iw_handler) NULL,	/* SIOCSIWNWID */
+	(iw_handler) NULL,	/* SIOCGIWNWID */
+	(iw_handler) p80211wext_siwfreq,	/* SIOCSIWFREQ */
+	(iw_handler) p80211wext_giwfreq,	/* SIOCGIWFREQ */
+	(iw_handler) p80211wext_siwmode,	/* SIOCSIWMODE */
+	(iw_handler) p80211wext_giwmode,	/* SIOCGIWMODE */
+	(iw_handler) NULL,	/* SIOCSIWSENS */
+	(iw_handler) NULL,	/* SIOCGIWSENS */
+	(iw_handler) NULL,	/* not used *//* SIOCSIWRANGE */
+	(iw_handler) p80211wext_giwrange,	/* SIOCGIWRANGE */
+	(iw_handler) NULL,	/* not used *//* SIOCSIWPRIV */
+	(iw_handler) NULL,	/* kernel code *//* SIOCGIWPRIV */
+	(iw_handler) NULL,	/* not used *//* SIOCSIWSTATS */
+	(iw_handler) NULL,	/* kernel code *//* SIOCGIWSTATS */
+	(iw_handler) p80211wext_siwspy,	/* SIOCSIWSPY */
+	(iw_handler) p80211wext_giwspy,	/* SIOCGIWSPY */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* SIOCSIWAP */
+	(iw_handler) p80211wext_giwap,	/* SIOCGIWAP */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* SIOCGIWAPLIST */
+	(iw_handler) p80211wext_siwscan,	/* SIOCSIWSCAN */
+	(iw_handler) p80211wext_giwscan,	/* SIOCGIWSCAN */
+	(iw_handler) p80211wext_siwessid,	/* SIOCSIWESSID */
+	(iw_handler) p80211wext_giwessid,	/* SIOCGIWESSID */
+	(iw_handler) NULL,	/* SIOCSIWNICKN */
+	(iw_handler) p80211wext_giwessid,	/* SIOCGIWNICKN */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* SIOCSIWRATE */
+	(iw_handler) p80211wext_giwrate,	/* SIOCGIWRATE */
+	(iw_handler) p80211wext_siwrts,	/* SIOCSIWRTS */
+	(iw_handler) p80211wext_giwrts,	/* SIOCGIWRTS */
+	(iw_handler) p80211wext_siwfrag,	/* SIOCSIWFRAG */
+	(iw_handler) p80211wext_giwfrag,	/* SIOCGIWFRAG */
+	(iw_handler) p80211wext_siwtxpow,	/* SIOCSIWTXPOW */
+	(iw_handler) p80211wext_giwtxpow,	/* SIOCGIWTXPOW */
+	(iw_handler) p80211wext_siwretry,	/* SIOCSIWRETRY */
+	(iw_handler) p80211wext_giwretry,	/* SIOCGIWRETRY */
+	(iw_handler) p80211wext_siwencode,	/* SIOCSIWENCODE */
+	(iw_handler) p80211wext_giwencode,	/* SIOCGIWENCODE */
+	(iw_handler) NULL,	/* SIOCSIWPOWER */
+	(iw_handler) NULL,	/* SIOCGIWPOWER */
@@ -1776,10 +1736,10 @@
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL,				/* -- hole -- */
-	(iw_handler) NULL, /* SIOCSIWGENIE	set generic IE */
-	(iw_handler) NULL, /* SIOCGIWGENIE	get generic IE */
-	(iw_handler) p80211_wext_set_iwauth, /* SIOCSIWAUTH	set authentication mode params */
-	(iw_handler) p80211_wext_get_iwauth, /* SIOCGIWAUTH	get authentication mode params */
-
-	(iw_handler) p80211wext_set_encodeext, /* SIOCSIWENCODEEXT  set encoding token & mode */
-	(iw_handler) p80211wext_get_encodeext, /* SIOCGIWENCODEEXT  get encoding token & mode */
-	(iw_handler) NULL, /* SIOCSIWPMKSA	PMKSA cache operation */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* -- hole -- */
+	(iw_handler) NULL,	/* SIOCSIWGENIE      set generic IE */
+	(iw_handler) NULL,	/* SIOCGIWGENIE      get generic IE */
+	(iw_handler) p80211_wext_set_iwauth,	/* SIOCSIWAUTH     set authentication mode params */
+	(iw_handler) p80211_wext_get_iwauth,	/* SIOCGIWAUTH     get authentication mode params */
+
+	(iw_handler) p80211wext_set_encodeext,	/* SIOCSIWENCODEEXT  set encoding token & mode */
+	(iw_handler) p80211wext_get_encodeext,	/* SIOCGIWENCODEEXT  get encoding token & mode */
+	(iw_handler) NULL,	/* SIOCSIWPMKSA      PMKSA cache operation */
@@ -1792 +1752 @@
-        .standard = p80211wext_handlers,
+	.standard = p80211wext_handlers,
@@ -1798 +1757,0 @@
-
@@ -1801,3 +1760 @@
-        union iwreq_data data;
-
-        DBFENTER;
+	union iwreq_data data;
@@ -1805,7 +1762,6 @@
-        /* Send the association state first */
-        data.ap_addr.sa_family = ARPHRD_ETHER;
-        if (assoc) {
-                memcpy(data.ap_addr.sa_data, wlandev->bssid, WLAN_ADDR_LEN);
-        } else {
-                memset(data.ap_addr.sa_data, 0, WLAN_ADDR_LEN);
-        }
+	/* Send the association state first */
+	data.ap_addr.sa_family = ARPHRD_ETHER;
+	if (assoc)
+		memcpy(data.ap_addr.sa_data, wlandev->bssid, ETH_ALEN);
+	else
+		memset(data.ap_addr.sa_data, 0, ETH_ALEN);
@@ -1813,2 +1769,2 @@
-        if (wlan_wext_write)
-                wireless_send_event(wlandev->netdev, SIOCGIWAP, &data, NULL);
+	if (wlan_wext_write)
+		wireless_send_event(wlandev->netdev, SIOCGIWAP, &data, NULL);
@@ -1816 +1772,2 @@
-        if (!assoc) goto done;
+	if (!assoc)
+		goto done;
@@ -1818 +1775 @@
-        // XXX send association data, like IEs, etc etc.
+	/* XXX send association data, like IEs, etc etc. */
@@ -1820,3 +1777,2 @@
- done:
-        DBFEXIT;
-        return 0;
+done:
+	return 0;
@@ -1824,4 +1779,0 @@
-
-
-
-
--- ./projects/linux/linux-2.6.13/drivers/video/i810/i810_main.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/video/i810/i810_main.c	2005-10-28 02:02:08.000000000 +0200
@@ -95,14 +95,15 @@
-static int vram       __initdata = 4;
-static int bpp        __initdata = 8;
-static int mtrr       __initdata = 0;
-static int accel      __initdata = 0;
-static int hsync1     __initdata = 0;
-static int hsync2     __initdata = 0;
-static int vsync1     __initdata = 0;
-static int vsync2     __initdata = 0;
-static int xres       __initdata = 640;
-static int yres       __initdata = 480;
-static int vyres      __initdata = 0;
-static int sync       __initdata = 0;
-static int ext_vga    __initdata = 0;
-static int dcolor     __initdata = 0;
+static char *mode_option __devinitdata = NULL;
+static int vram       __devinitdata = 4;
+static int bpp        __devinitdata = 8;
+static int mtrr       __devinitdata;
+static int accel      __devinitdata;
+static int hsync1     __devinitdata;
+static int hsync2     __devinitdata;
+static int vsync1     __devinitdata;
+static int vsync2     __devinitdata;
+static int xres       __devinitdata;
+static int yres       __devinitdata;
+static int vyres      __devinitdata;
+static int sync       __devinitdata;
+static int extvga     __devinitdata;
+static int dcolor     __devinitdata;
@@ -312,0 +314,2 @@
+	/* Stop LCD displays from flickering */
+	i810_writel(MEM_MODE, mmio, i810_readl(MEM_MODE, mmio) | 4);
@@ -950,8 +953,2 @@
-	int line_length, vidmem;
-	u32 xres, yres, vxres, vyres;
-
-	xres = var->xres;
-	yres = var->yres;
-	vxres = var->xres_virtual;
-	vyres = var->yres_virtual;
-
+	int line_length, vidmem, mode_valid = 0, retval = 0;
+	u32 vyres = var->yres_virtual, vxres = var->xres_virtual;
@@ -961,3 +958 @@
-	line_length = get_line_length(par, vxres, 
-				      var->bits_per_pixel);
-
+	line_length = get_line_length(par, vxres, var->bits_per_pixel);
@@ -964,0 +960 @@
+
@@ -967 +963 @@
-		if (vyres < yres) {
+		if (vyres < var->yres) {
@@ -974 +970 @@
-			if (vxres < xres) {
+			if (vxres < var->xres) {
@@ -983,0 +980,4 @@
+
+	var->xres_virtual = vxres;
+	var->yres_virtual = vyres;
+
@@ -998,0 +999 @@
+
@@ -1001 +1002,19 @@
-	if (fb_validate_mode(var, info)) {
+	if (!fb_validate_mode(var, info))
+		mode_valid = 1;
+
+#ifdef CONFIG_FB_I810_I2C
+	if (!mode_valid && info->monspecs.gtf &&
+	    !fb_get_mode(FB_MAXTIMINGS, 0, var, info))
+		mode_valid = 1;
+
+	if (!mode_valid && info->monspecs.modedb_len) {
+		struct fb_videomode *mode;
+
+		mode = fb_find_best_mode(var, &info->modelist);
+		if (mode) {
+			fb_videomode_to_var(var, mode);
+			mode_valid = 1;
+		}
+	}
+#endif
+	if (!mode_valid && info->monspecs.modedb_len == 0) {
@@ -1004,3 +1023,3 @@
-						|(info->monspecs.hfmax-HFMAX)
-						|(info->monspecs.vfmin-VFMIN)
-						|(info->monspecs.vfmax-VFMAX);
+				|(info->monspecs.hfmax-HFMAX)
+				|(info->monspecs.vfmin-VFMIN)
+				|(info->monspecs.vfmax-VFMAX);
@@ -1008,3 +1027,3 @@
-			    default_sync ? "" :
-			    ". Specifying vsyncN/hsyncN parameters may help");
-			return -EINVAL;
+			       default_sync ? "" : ". Specifying "
+			       "vsyncN/hsyncN parameters may help");
+			retval = -EINVAL;
@@ -1013,6 +1032,2 @@
-	
-	var->xres = xres;
-	var->yres = yres;
-	var->xres_virtual = vxres;
-	var->yres_virtual = vyres;
-	return 0;
+
+	return retval;
@@ -1378 +1392,0 @@
-
@@ -1421,3 +1435,2 @@
-	if (!(par->dev_flags & USE_HWCUR) || !info->var.accel_flags ||
-	    par->dev_flags & LOCKUP)
-		return soft_cursor(info, cursor);
+	if (!par->dev_flags & LOCKUP)
+		return -ENXIO;
@@ -1509 +1522 @@
-	if (state == prev_state)
+	if (state.event == prev_state)
@@ -1512 +1525 @@
-	par->cur_state = state;
+	par->cur_state = state.event;
@@ -1514 +1527 @@
-	switch (state) {
+	switch (state.event) {
@@ -1714,0 +1728,12 @@
+	par->i810fb_ops = i810fb_ops;
+
+	if (xres)
+		info->var.xres = xres;
+	else
+		info->var.xres = 640;
+
+	if (yres)
+		info->var.yres = yres;
+	else
+		info->var.yres = 480;
+
@@ -1716 +1741 @@
-		vyres = (vram << 20)/(xres*bpp >> 3);
+		vyres = (vram << 20)/(info->var.xres*bpp >> 3);
@@ -1718,3 +1742,0 @@
-	par->i810fb_ops = i810fb_ops;
-	info->var.xres = xres;
-	info->var.yres = yres;
@@ -1747 +1769 @@
-	if (ext_vga) {
+	if (extvga) {
@@ -1816,0 +1839,72 @@
+static void __devinit i810fb_find_init_mode(struct fb_info *info)
+{
+	struct fb_videomode mode;
+	struct fb_var_screeninfo var;
+	struct fb_monspecs *specs = &info->monspecs;
+	int found = 0;
+#ifdef CONFIG_FB_I810_I2C
+	int i;
+	int err;
+	struct i810fb_par *par = info->par;
+#endif
+
+	INIT_LIST_HEAD(&info->modelist);
+	memset(&mode, 0, sizeof(struct fb_videomode));
+	var = info->var;
+#ifdef CONFIG_FB_I810_I2C
+	i810_create_i2c_busses(par);
+
+	for (i = 0; i < 3; i++) {
+		err = i810_probe_i2c_connector(info, &par->edid, i+1);
+		if (!err)
+			break;
+	}
+
+	if (!err)
+		printk("i810fb_init_pci: DDC probe successful\n");
+
+	fb_edid_to_monspecs(par->edid, specs);
+
+	if (specs->modedb == NULL)
+		printk("i810fb_init_pci: Unable to get Mode Database\n");
+
+	fb_videomode_to_modelist(specs->modedb, specs->modedb_len,
+				 &info->modelist);
+	if (specs->modedb != NULL) {
+		if (xres && yres) {
+			struct fb_videomode *m;
+
+			if ((m = fb_find_best_mode(&var, &info->modelist))) {
+				mode = *m;
+				found  = 1;
+			}
+		}
+
+		if (!found && specs->misc & FB_MISC_1ST_DETAIL) {
+			for (i = 0; i < specs->modedb_len; i++) {
+				if (specs->modedb[i].flag & FB_MODE_IS_FIRST) {
+					mode = specs->modedb[i];
+					found = 1;
+					break;
+				}
+			}
+		}
+
+		if (!found) {
+			mode = specs->modedb[0];
+			found = 1;
+		}
+
+		fb_videomode_to_var(&var, &mode);
+	}
+#endif
+	if (mode_option)
+		fb_find_mode(&var, info, mode_option, specs->modedb,
+			     specs->modedb_len, (found) ? &mode : NULL,
+			     info->var.bits_per_pixel);
+
+	info->var = var;
+	fb_destroy_modedb(specs->modedb);
+	specs->modedb = NULL;
+}
+
@@ -1818 +1912 @@
-static int __init i810fb_setup(char *options)
+static int __devinit i810fb_setup(char *options)
@@ -1830,2 +1924,2 @@
-		else if (!strncmp(this_opt, "ext_vga", 7))
-			ext_vga = 1;
+		else if (!strncmp(this_opt, "extvga", 6))
+			extvga = 1;
@@ -1859,0 +1954,2 @@
+		else
+			mode_option = this_opt;
@@ -1869,0 +1966 @@
+	struct fb_videomode mode;
@@ -1878 +1975 @@
-	par = (struct i810fb_par *) info->par;
+	par = info->par;
@@ -1908,0 +2006 @@
+	i810fb_find_init_mode(info);
@@ -1913,0 +2012,3 @@
+
+	fb_var_to_videomode(&mode, &info->var);
+	fb_add_videomode(&mode, &info->modelist);
@@ -1917,0 +2019 @@
+
@@ -1955,0 +2058,2 @@
+	i810_delete_i2c_busses(par);
+
@@ -1965 +2069,2 @@
-
+	if (par->edid)
+		kfree(par->edid);
@@ -1991 +2096 @@
-static int __init i810fb_init(void)
+static int __devinit i810fb_init(void)
@@ -2009 +2114 @@
-static int __init i810fb_init(void)
+static int __devinit i810fb_init(void)
@@ -2049,2 +2154,2 @@
-module_param(ext_vga, bool, 0);
-MODULE_PARM_DESC(ext_vga, "Enable external VGA connector (default = 0)");
+module_param(extvga, bool, 0);
+MODULE_PARM_DESC(extvga, "Enable external VGA connector (default = 0)");
@@ -2056,0 +2162,2 @@
+module_param(mode_option, charp, 0);
+MODULE_PARM_DESC(mode_option, "Specify initial video mode");
--- ./projects/linux/linux-2.6.14/drivers/video/i810/i810_main.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/video/i810/i810_main.c	2006-01-03 04:21:10.000000000 +0100
@@ -1857 +1857 @@
-	for (i = 0; i < 3; i++) {
+	for (i = 0; i < 4; i++) {
@@ -1874,2 +1874 @@
-		if (xres && yres) {
-			struct fb_videomode *m;
+		struct fb_videomode *m;
@@ -1876,0 +1876 @@
+		if (xres && yres) {
@@ -1883,10 +1882,0 @@
-		if (!found && specs->misc & FB_MISC_1ST_DETAIL) {
-			for (i = 0; i < specs->modedb_len; i++) {
-				if (specs->modedb[i].flag & FB_MODE_IS_FIRST) {
-					mode = specs->modedb[i];
-					found = 1;
-					break;
-				}
-			}
-		}
-
@@ -1894 +1884,2 @@
-			mode = specs->modedb[0];
+			m = fb_find_best_display(&info->monspecs, &info->modelist);
+			mode = *m;
@@ -2069,2 +2060 @@
-	if (par->edid)
-		kfree(par->edid);
+	kfree(par->edid);
--- ./projects/linux/linux-2.6.15/drivers/video/i810/i810_main.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/video/i810/i810_main.c	2006-03-20 06:53:29.000000000 +0100
@@ -44,0 +45 @@
+#include <linux/console.h>
@@ -48,5 +48,0 @@
-
-#ifdef CONFIG_MTRR
-#include <asm/mtrr.h>
-#endif 
-
@@ -58,0 +55,46 @@
+/*
+ * voffset - framebuffer offset in MiB from aperture start address.  In order for
+ * the driver to work with X, we must try to use memory holes left untouched by X. The
+ * following table lists where X's different surfaces start at.
+ *
+ * ---------------------------------------------
+ * :                :  64 MiB     : 32 MiB      :
+ * ----------------------------------------------
+ * : FrontBuffer    :   0         :  0          :
+ * : DepthBuffer    :   48        :  16         :
+ * : BackBuffer     :   56        :  24         :
+ * ----------------------------------------------
+ *
+ * So for chipsets with 64 MiB Aperture sizes, 32 MiB for v_offset is okay, allowing up to
+ * 15 + 1 MiB of Framebuffer memory.  For 32 MiB Aperture sizes, a v_offset of 8 MiB should
+ * work, allowing 7 + 1 MiB of Framebuffer memory.
+ * Note, the size of the hole may change depending on how much memory you allocate to X,
+ * and how the memory is split up between these surfaces.
+ *
+ * Note: Anytime the DepthBuffer or FrontBuffer is overlapped, X would still run but with
+ * DRI disabled.  But if the Frontbuffer is overlapped, X will fail to load.
+ *
+ * Experiment with v_offset to find out which works best for you.
+ */
+static u32 v_offset_default __initdata; /* For 32 MiB Aper size, 8 should be the default */
+static u32 voffset          __initdata = 0;
+
+static int i810fb_cursor(struct fb_info *info, struct fb_cursor *cursor);
+static int  __devinit i810fb_init_pci (struct pci_dev *dev,
+				       const struct pci_device_id *entry);
+static void __exit i810fb_remove_pci(struct pci_dev *dev);
+static int i810fb_resume(struct pci_dev *dev);
+static int i810fb_suspend(struct pci_dev *dev, pm_message_t state);
+
+/* Chipset Specific Functions */
+static int i810fb_set_par    (struct fb_info *info);
+static int i810fb_getcolreg  (u8 regno, u8 *red, u8 *green, u8 *blue,
+			      u8 *transp, struct fb_info *info);
+static int i810fb_setcolreg  (unsigned regno, unsigned red, unsigned green, unsigned blue,
+			      unsigned transp, struct fb_info *info);
+static int i810fb_pan_display(struct fb_var_screeninfo *var, struct fb_info *info);
+static int i810fb_blank      (int blank_mode, struct fb_info *info);
+
+/* Initialization */
+static void i810fb_release_resource       (struct fb_info *info, struct i810fb_par *par);
+
@@ -109,0 +152 @@
+static int ddc3       __devinitdata = 2;
@@ -779 +822 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
@@ -952 +995 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
@@ -1046 +1089 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
@@ -1157 +1200 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
@@ -1196 +1239 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
@@ -1215 +1258 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
@@ -1237 +1280 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
@@ -1331 +1374 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
@@ -1343 +1386 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
@@ -1388 +1431 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
@@ -1432 +1475 @@
-	struct i810fb_par *par = (struct i810fb_par *)info->par;
+	struct i810fb_par *par = info->par;
@@ -1519,5 +1562 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
-	int blank = 0, prev_state = par->cur_state;
-
-	if (state.event == prev_state)
-		return 0;
+	struct i810fb_par *par = info->par;
@@ -1527,12 +1566,3 @@
-	switch (state.event) {
-	case 1:
-		blank = VESA_VSYNC_SUSPEND;
-		break;
-	case 2:
-		blank = VESA_HSYNC_SUSPEND;
-		break;
-	case 3:
-		blank = VESA_POWERDOWN;
-		break;
-	default:
-		return -EINVAL;
+	if (state.event == PM_EVENT_FREEZE) {
+		dev->dev.power.power_state = state;
+		return 0;
@@ -1540 +1569,0 @@
-	info->fbops->fb_blank(blank, info);
@@ -1542,5 +1571,10 @@
-	if (!prev_state) { 
-		agp_unbind_memory(par->i810_gtt.i810_fb_memory);
-		agp_unbind_memory(par->i810_gtt.i810_cursor_memory);
-		pci_disable_device(dev);
-	}
+	acquire_console_sem();
+	fb_set_suspend(info, 1);
+
+	if (info->fbops->fb_sync)
+		info->fbops->fb_sync(info);
+
+	i810fb_blank(FB_BLANK_POWERDOWN, info);
+	agp_unbind_memory(par->i810_gtt.i810_fb_memory);
+	agp_unbind_memory(par->i810_gtt.i810_cursor_memory);
+
@@ -1547,0 +1582 @@
+	pci_disable_device(dev);
@@ -1548,0 +1584 @@
+	release_console_sem();
@@ -1556 +1592,2 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
+	int cur_state = par->cur_state;
@@ -1558 +1595,4 @@
-	if (par->cur_state == 0)
+	par->cur_state = PM_EVENT_ON;
+
+	if (cur_state == PM_EVENT_FREEZE) {
+		pci_set_power_state(dev, PCI_D0);
@@ -1559,0 +1600 @@
+	}
@@ -1561 +1602 @@
-	pci_restore_state(dev);
+	acquire_console_sem();
@@ -1562,0 +1604 @@
+	pci_restore_state(dev);
@@ -1563,0 +1606 @@
+	pci_set_master(dev);
@@ -1568 +1611,2 @@
-
+	i810fb_set_par(info);
+	fb_set_suspend (info, 0);
@@ -1570,3 +1614 @@
-
-	par->cur_state = 0;
-
+	release_console_sem();
@@ -1613 +1655 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
@@ -1724,0 +1767,2 @@
+	par->ddc_num = ddc3;
+
@@ -1847 +1891 @@
-	int err;
+	int err = 1;
@@ -1857,2 +1901,2 @@
-	for (i = 0; i < 4; i++) {
-		err = i810_probe_i2c_connector(info, &par->edid, i+1);
+	for (i = 0; i < par->ddc_num + 1; i++) {
+		err = i810_probe_i2c_connector(info, &par->edid, i);
@@ -1944,0 +1989,2 @@
+		else if (!strncmp(this_opt, "ddc3", 4))
+			ddc3 = 3;
@@ -2077 +2123 @@
-	struct i810fb_par *par = (struct i810fb_par *) info->par;
+	struct i810fb_par *par = info->par;
@@ -2151,0 +2198,2 @@
+module_param(ddc3, bool, 0);
+MODULE_PARM_DESC(ddc3, "Probe DDC bus 3 (default = 0 = no)");
--- ./projects/linux/linux-2.6.16/drivers/video/i810/i810_main.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/drivers/video/i810/i810_main.c	2006-06-18 03:49:35.000000000 +0200
@@ -79,2 +79,2 @@
-static u32 v_offset_default __initdata; /* For 32 MiB Aper size, 8 should be the default */
-static u32 voffset          __initdata = 0;
+static u32 v_offset_default __devinitdata; /* For 32 MiB Aper size, 8 should be the default */
+static u32 voffset          __devinitdata;
@@ -1511 +1511 @@
-		u8 *data = kmalloc(64 * 8, GFP_KERNEL);
+		u8 *data = kmalloc(64 * 8, GFP_ATOMIC);
--- ./projects/linux/linux-2.6.17/drivers/video/i810/i810_main.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/video/i810/i810_main.c	2006-09-20 05:42:06.000000000 +0200
@@ -32 +31,0 @@
-#include <linux/config.h>
@@ -37 +35,0 @@
-#include <linux/tty.h>
@@ -2113,3 +2110,0 @@
-	if (par->res_flags & PCI_DEVICE_ENABLED)
-		pci_disable_device(par->dev);
-
--- ./projects/linux/linux-2.6.18/drivers/video/i810/i810_main.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/video/i810/i810_main.c	2006-11-29 22:57:37.000000000 +0100
@@ -1557 +1557 @@
-static int i810fb_suspend(struct pci_dev *dev, pm_message_t state)
+static int i810fb_suspend(struct pci_dev *dev, pm_message_t mesg)
@@ -1562 +1562 @@
-	par->cur_state = state.event;
+	par->cur_state = mesg.event;
@@ -1564,2 +1564,4 @@
-	if (state.event == PM_EVENT_FREEZE) {
-		dev->dev.power.power_state = state;
+	switch (mesg.event) {
+	case PM_EVENT_FREEZE:
+	case PM_EVENT_PRETHAW:
+		dev->dev.power.power_state = mesg;
@@ -1581 +1583 @@
-	pci_set_power_state(dev, pci_choose_state(dev, state));
+	pci_set_power_state(dev, pci_choose_state(dev, mesg));
@@ -1603 +1605,4 @@
-	pci_enable_device(dev);
+
+	if (pci_enable_device(dev))
+		goto fail;
+
@@ -1611,0 +1617 @@
+fail:
--- ./projects/linux/linux-2.6.20/drivers/video/i810/i810_main.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/video/i810/i810_main.c	2007-04-26 05:08:32.000000000 +0200
@@ -145 +145 @@
-static int yres       __devinitdata;
+static int yres;
@@ -1052 +1052 @@
-		struct fb_videomode *mode;
+		const struct fb_videomode *mode;
@@ -1238,3 +1238,3 @@
-	u32 count = atomic_read(&par->use_count);
-	
-	if (count == 0) {
+
+	mutex_lock(&par->open_lock);
+	if (par->use_count == 0) {
@@ -1249 +1249,2 @@
-	atomic_inc(&par->use_count);
+	par->use_count++;
+	mutex_unlock(&par->open_lock);
@@ -1257,4 +1258,4 @@
-	u32 count;
-	
-	count = atomic_read(&par->use_count);
-	if (count == 0)
+
+	mutex_lock(&par->open_lock);
+	if (par->use_count == 0) {
+		mutex_unlock(&par->open_lock);
@@ -1261,0 +1263 @@
+	}
@@ -1263 +1265 @@
-	if (count == 1) {
+	if (par->use_count == 1) {
@@ -1268 +1270,2 @@
-	atomic_dec(&par->use_count);
+	par->use_count--;
+	mutex_unlock(&par->open_lock);
@@ -1754,0 +1758,2 @@
+	mutex_init(&par->open_lock);
+
@@ -1922 +1927 @@
-		struct fb_videomode *m;
+		const struct fb_videomode *m;
@@ -2019 +2024 @@
-	if (!(info->pixmap.addr = kmalloc(8*1024, GFP_KERNEL))) {
+	if (!(info->pixmap.addr = kzalloc(8*1024, GFP_KERNEL))) {
@@ -2023 +2027,0 @@
-	memset(info->pixmap.addr, 0, 8*1024);
--- ./projects/linux/linux-2.6.21/drivers/video/i810/i810_main.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/video/i810/i810_main.c	2007-07-09 01:32:17.000000000 +0200
@@ -1720 +1720 @@
- * Sets the the user monitor's horizontal and vertical
+ * Sets the user monitor's horizontal and vertical
--- ./projects/linux/linux-2.6.24/drivers/video/i810/i810_main.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/video/i810/i810_main.c	2008-04-17 04:49:44.000000000 +0200
@@ -1479 +1479 @@
-	if (!par->dev_flags & LOCKUP)
+	if (par->dev_flags & LOCKUP)
--- ./projects/linux/linux-2.6.28/drivers/video/i810/i810_main.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/drivers/video/i810/i810_main.c	2009-03-24 00:12:14.000000000 +0100
@@ -995,0 +996 @@
+
@@ -1005 +1006 @@
-			vyres = yres;
+			vyres = info->var.yres;
@@ -1010 +1011 @@
-			vidmem = line_length * yres;
+			vidmem = line_length * info->var.yres;
--- ./projects/linux/linux-2.6.13/drivers/video/sis/sis_main.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/drivers/video/sis/sis_main.c	2005-10-28 02:02:08.000000000 +0200
@@ -2,2 +2,3 @@
- * SiS 300/305/540/630(S)/730(S)
- * SiS 315(H/PRO)/55x/(M)65x/(M)661(F/M)X/740/741(GX)/330/(M)760
+ * SiS 300/540/630[S]/730[S],
+ * SiS 315[E|PRO]/550/[M]65x/[M]66x[F|M|G]X/[M]74x[GX]/330/[M]76x[GX],
+ * XGI V3XT/V5/V8, Z7
@@ -6 +7 @@
- * Copyright (C) 2001-2004 Thomas Winischhofer, Vienna, Austria.
+ * Copyright (C) 2001-2005 Thomas Winischhofer, Vienna, Austria.
@@ -22 +23 @@
- * Author:   	Thomas Winischhofer <thomas@winischhofer.net>
+ * Author:	Thomas Winischhofer <thomas@winischhofer.net>
@@ -26 +27 @@
- *	 	Copyright (C) 1999 Silicon Integrated Systems, Inc.
+ *		Copyright (C) 1999 Silicon Integrated Systems, Inc.
@@ -49 +49,0 @@
-#include <linux/delay.h>
@@ -51 +50,0 @@
-#include <linux/console.h>
@@ -53 +51,0 @@
-#include <linux/smp_lock.h>
@@ -57,0 +56 @@
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
@@ -58,0 +58 @@
+#endif
@@ -96,0 +97,3 @@
+static void sisfb_handle_command(struct sis_video_info *ivideo,
+				 struct sisfb_cmd *sisfb_command);
+
@@ -102,7 +105,7 @@
-	sisfb_off 		= 0;
-	sisfb_parm_mem 		= 0;
-	sisfb_accel 		= -1;
-	sisfb_ypan      	= -1;
-	sisfb_max 		= -1;
-	sisfb_userom    	= -1;
-        sisfb_useoem    	= -1;
+	sisfb_off		= 0;
+	sisfb_parm_mem		= 0;
+	sisfb_accel		= -1;
+	sisfb_ypan		= -1;
+	sisfb_max		= -1;
+	sisfb_userom		= -1;
+	sisfb_useoem		= -1;
@@ -112 +115 @@
-	sisfb_mode_idx 		= -1;
+	sisfb_mode_idx		= -1;
@@ -114 +117 @@
-	sisfb_mode_idx  	= MODE_INDEX_NONE;
+	sisfb_mode_idx		= MODE_INDEX_NONE;
@@ -118 +121 @@
-	sisfb_mode_idx  	= -1;
+	sisfb_mode_idx		= -1;
@@ -120,8 +123,8 @@
-	sisfb_parm_rate 	= -1;
-	sisfb_crt1off 		= 0;
-	sisfb_forcecrt1 	= -1;
-	sisfb_crt2type  	= -1;
-	sisfb_crt2flags 	= 0;
-	sisfb_pdc 		= 0xff;
-	sisfb_pdca 		= 0xff;
-	sisfb_scalelcd  	= -1;
+	sisfb_parm_rate		= -1;
+	sisfb_crt1off		= 0;
+	sisfb_forcecrt1		= -1;
+	sisfb_crt2type		= -1;
+	sisfb_crt2flags		= 0;
+	sisfb_pdc		= 0xff;
+	sisfb_pdca		= 0xff;
+	sisfb_scalelcd		= -1;
@@ -129,9 +132,8 @@
-	sisfb_lvdshl 		= -1;
-	sisfb_dstn     		= 0;
-	sisfb_fstn 		= 0;
-	sisfb_tvplug    	= -1;
-	sisfb_tvstd     	= -1;
-	sisfb_tvxposoffset 	= 0;
-	sisfb_tvyposoffset 	= 0;
-	sisfb_filter 		= -1;
-	sisfb_nocrt2rate 	= 0;
+	sisfb_lvdshl		= -1;
+	sisfb_dstn		= 0;
+	sisfb_fstn		= 0;
+	sisfb_tvplug		= -1;
+	sisfb_tvstd		= -1;
+	sisfb_tvxposoffset	= 0;
+	sisfb_tvyposoffset	= 0;
+	sisfb_nocrt2rate	= 0;
@@ -139,2 +141,2 @@
-	sisfb_inverse   	= 0;
-	sisfb_fontname[0] 	= 0;
+	sisfb_inverse		= 0;
+	sisfb_fontname[0]	= 0;
@@ -143,2 +145,2 @@
-	sisfb_resetcard 	= 0;
-	sisfb_videoram  	= 0;
+	sisfb_resetcard		= 0;
+	sisfb_videoram		= 0;
@@ -147,0 +150,2 @@
+/* ------------- Parameter parsing -------------- */
+
@@ -153 +157 @@
-	/* BEWARE: We don't know the hardware specs yet and there is no ivideo */
+	/* We don't know the hardware specs yet and there is no ivideo */
@@ -159,3 +163,3 @@
-		if(!quiet) {
-		   printk(KERN_ERR "sisfb: Invalid mode. Using default.\n");
-		}
+		if(!quiet)
+			printk(KERN_ERR "sisfb: Invalid mode. Using default.\n");
+
@@ -172,11 +176,13 @@
-		    if(sisfb_fstn) {
-		       if(sisbios_mode[i-1].mode_no[1] == 0x50 ||
-		          sisbios_mode[i-1].mode_no[1] == 0x56 ||
-		          sisbios_mode[i-1].mode_no[1] == 0x53) continue;
-	            } else {
-		       if(sisbios_mode[i-1].mode_no[1] == 0x5a ||
-		          sisbios_mode[i-1].mode_no[1] == 0x5b) continue;
-		    }
-		    sisfb_mode_idx = i - 1;
-		    j = 1;
-		    break;
+			if(sisfb_fstn) {
+				if(sisbios_mode[i-1].mode_no[1] == 0x50 ||
+				   sisbios_mode[i-1].mode_no[1] == 0x56 ||
+				   sisbios_mode[i-1].mode_no[1] == 0x53)
+					continue;
+			} else {
+				if(sisbios_mode[i-1].mode_no[1] == 0x5a ||
+				   sisbios_mode[i-1].mode_no[1] == 0x5b)
+					continue;
+			}
+			sisfb_mode_idx = i - 1;
+			j = 1;
+			break;
@@ -185 +191,2 @@
-	if((!j) && !quiet) printk(KERN_ERR "sisfb: Invalid VESA mode 0x%x'\n", vesamode);
+	if((!j) && !quiet)
+		printk(KERN_ERR "sisfb: Invalid VESA mode 0x%x'\n", vesamode);
@@ -188 +195 @@
-static void
+static void __devinit
@@ -191 +197,0 @@
-	int i = 0;
@@ -192,0 +199 @@
+	int i = 0;
@@ -196 +203 @@
-	/* BEWARE: We don't know the hardware specs yet and there is no ivideo */
+	/* We don't know the hardware specs yet and there is no ivideo */
@@ -199,5 +206,5 @@
-	   if(!quiet) {
-	      printk(KERN_ERR "sisfb: Internal error, using default mode.\n");
-	   }
-	   sisfb_mode_idx = DEFAULT_MODE;
-	   return;
+		if(!quiet)
+			printk(KERN_ERR "sisfb: Internal error, using default mode.\n");
+
+		sisfb_mode_idx = DEFAULT_MODE;
+		return;
@@ -207,6 +214,6 @@
-        if(!strnicmp(name, sisbios_mode[MODE_INDEX_NONE].name, strlen(name))) {
-	   if(!quiet) {
-	      printk(KERN_ERR "sisfb: Mode 'none' not supported anymore. Using default.\n");
-	   }
-	   sisfb_mode_idx = DEFAULT_MODE;
-	   return;
+	if(!strnicmp(name, sisbios_mode[MODE_INDEX_NONE].name, strlen(name))) {
+		if(!quiet)
+			printk(KERN_ERR "sisfb: Mode 'none' not supported anymore. Using default.\n");
+
+		sisfb_mode_idx = DEFAULT_MODE;
+		return;
@@ -216,4 +223,4 @@
-	   strcpy(strbuf1, name);
-	   for(i=0; i<strlen(strbuf1); i++) {
-	      if(strbuf1[i] < '0' || strbuf1[i] > '9') strbuf1[i] = ' ';
-	   }
+		strcpy(strbuf1, name);
+		for(i = 0; i < strlen(strbuf1); i++) {
+			if(strbuf1[i] < '0' || strbuf1[i] > '9') strbuf1[i] = ' ';
+		}
@@ -221,21 +228,21 @@
-	   /* This does some fuzzy mode naming detection */
-	   if(sscanf(strbuf1, "%u %u %u %u", &xres, &yres, &depth, &rate) == 4) {
-	      if((rate <= 32) || (depth > 32)) {
-	         j = rate; rate = depth; depth = j;
-	      }
-	      sprintf(strbuf, "%ux%ux%u", xres, yres, depth);
-	      nameptr = strbuf;
-	      sisfb_parm_rate = rate;
-	   } else if(sscanf(strbuf1, "%u %u %u", &xres, &yres, &depth) == 3) {
-	      sprintf(strbuf, "%ux%ux%u", xres, yres, depth);
-	      nameptr = strbuf;
-	   } else {
-	      xres = 0;
-	      if((sscanf(strbuf1, "%u %u", &xres, &yres) == 2) && (xres != 0)) {
-	         sprintf(strbuf, "%ux%ux8", xres, yres);
-	         nameptr = strbuf;
-	      } else {
-	         sisfb_search_vesamode(simple_strtoul(name, NULL, 0), quiet);
-	         return;
-	      }
-	   }
+		/* This does some fuzzy mode naming detection */
+		if(sscanf(strbuf1, "%u %u %u %u", &xres, &yres, &depth, &rate) == 4) {
+			if((rate <= 32) || (depth > 32)) {
+				j = rate; rate = depth; depth = j;
+			}
+			sprintf(strbuf, "%ux%ux%u", xres, yres, depth);
+			nameptr = strbuf;
+			sisfb_parm_rate = rate;
+		} else if(sscanf(strbuf1, "%u %u %u", &xres, &yres, &depth) == 3) {
+			sprintf(strbuf, "%ux%ux%u", xres, yres, depth);
+			nameptr = strbuf;
+		} else {
+			xres = 0;
+			if((sscanf(strbuf1, "%u %u", &xres, &yres) == 2) && (xres != 0)) {
+				sprintf(strbuf, "%ux%ux8", xres, yres);
+				nameptr = strbuf;
+			} else {
+				sisfb_search_vesamode(simple_strtoul(name, NULL, 0), quiet);
+				return;
+			}
+		}
@@ -247,11 +254,13 @@
-		   	if(sisfb_fstn) {
-		      		if(sisbios_mode[i-1].mode_no[1] == 0x50 ||
-		         	   sisbios_mode[i-1].mode_no[1] == 0x56 ||
-		         	   sisbios_mode[i-1].mode_no[1] == 0x53) continue;
-	           	} else {
-		      		if(sisbios_mode[i-1].mode_no[1] == 0x5a ||
-		         	   sisbios_mode[i-1].mode_no[1] == 0x5b) continue;
-		   	}
-		   	sisfb_mode_idx = i - 1;
-		   	j = 1;
-		   	break;
+			if(sisfb_fstn) {
+				if(sisbios_mode[i-1].mode_no[1] == 0x50 ||
+				   sisbios_mode[i-1].mode_no[1] == 0x56 ||
+				   sisbios_mode[i-1].mode_no[1] == 0x53)
+					continue;
+			} else {
+				if(sisbios_mode[i-1].mode_no[1] == 0x5a ||
+				   sisbios_mode[i-1].mode_no[1] == 0x5b)
+					continue;
+			}
+			sisfb_mode_idx = i - 1;
+			j = 1;
+			break;
@@ -260 +269,3 @@
-	if((!j) && !quiet) printk(KERN_ERR "sisfb: Invalid mode '%s'\n", nameptr);
+
+	if((!j) && !quiet)
+		printk(KERN_ERR "sisfb: Invalid mode '%s'\n", nameptr);
@@ -268 +279 @@
-   	char mymode[32];
+	char mymode[32];
@@ -277 +288 @@
-	    if(mydepth == 24) mydepth = 32;
+		if(mydepth == 24) mydepth = 32;
@@ -279,2 +290,2 @@
-	    sprintf(mymode, "%ux%ux%u", screen_info.lfb_width,
-	    				screen_info.lfb_height,
+		sprintf(mymode, "%ux%ux%u", screen_info.lfb_width,
+					screen_info.lfb_height,
@@ -283 +294,3 @@
-	    printk(KERN_DEBUG "sisfb: Using vga mode %s pre-set by kernel as default\n", mymode);
+		printk(KERN_DEBUG
+			"sisfb: Using vga mode %s pre-set by kernel as default\n",
+			mymode);
@@ -285 +298 @@
-	    sisfb_search_mode(mymode, TRUE);
+		sisfb_search_mode(mymode, TRUE);
@@ -297 +310 @@
-	/* BEWARE: We don't know the hardware specs yet and there is no ivideo */
+	/* We don't know the hardware specs yet and there is no ivideo */
@@ -302,7 +315,7 @@
-	   	if(!strnicmp(name, sis_crt2type[i].name, strlen(sis_crt2type[i].name))) {
-	      		sisfb_crt2type = sis_crt2type[i].type_no;
-	      		sisfb_tvplug = sis_crt2type[i].tvplug_no;
-	      		sisfb_crt2flags = sis_crt2type[i].flags;
-	      		break;
-	   	}
-	   	i++;
+		if(!strnicmp(name, sis_crt2type[i].name, strlen(sis_crt2type[i].name))) {
+			sisfb_crt2type = sis_crt2type[i].type_no;
+			sisfb_tvplug = sis_crt2type[i].tvplug_no;
+			sisfb_crt2flags = sis_crt2type[i].flags;
+			break;
+		}
+		i++;
@@ -314 +327 @@
-	if(sisfb_crt2type < 0) {
+	if(sisfb_crt2type < 0)
@@ -316 +328,0 @@
-	}
@@ -324 +336 @@
-	/* BEWARE: We don't know the hardware specs yet and there is no ivideo */
+	/* We don't know the hardware specs yet and there is no ivideo */
@@ -326 +338,2 @@
-	if(name == NULL) return;
+	if(name == NULL)
+		return;
@@ -329,5 +342,5 @@
-	   	if(!strnicmp(name, sis_tvtype[i].name, strlen(sis_tvtype[i].name))) {
-	      		sisfb_tvstd = sis_tvtype[i].type_no;
-	      		break;
-	   	}
-	   	i++;
+		if(!strnicmp(name, sis_tvtype[i].name, strlen(sis_tvtype[i].name))) {
+			sisfb_tvstd = sis_tvtype[i].type_no;
+			break;
+		}
+		i++;
@@ -343 +356 @@
-	/* BEWARE: We don't know the hardware specs yet and there is no ivideo */
+	/* We don't know the hardware specs yet and there is no ivideo */
@@ -345 +358,2 @@
-	if(name == NULL) return;
+	if(name == NULL)
+		return;
@@ -348 +362 @@
-	        sisfb_specialtiming = CUT_FORCENONE;
+		sisfb_specialtiming = CUT_FORCENONE;
@@ -351,24 +365,86 @@
-	   while(mycustomttable[i].chipID != 0) {
-	      if(!strnicmp(name,mycustomttable[i].optionName, strlen(mycustomttable[i].optionName))) {
-		 sisfb_specialtiming = mycustomttable[i].SpecialID;
-		 found = TRUE;
-		 printk(KERN_INFO "sisfb: Special timing for %s %s forced (\"%s\")\n",
-		 	mycustomttable[i].vendorName, mycustomttable[i].cardName,
-		 	mycustomttable[i].optionName);
-		 break;
-	      }
-	      i++;
-	   }
-	   if(!found) {
-	      printk(KERN_WARNING "sisfb: Invalid SpecialTiming parameter, valid are:");
-	      printk(KERN_WARNING "\t\"none\" (to disable special timings)\n");
-	      i = 0;
-	      while(mycustomttable[i].chipID != 0) {
-		 printk(KERN_WARNING "\t\"%s\" (for %s %s)\n",
-		     mycustomttable[i].optionName,
-		     mycustomttable[i].vendorName,
-		     mycustomttable[i].cardName);
-		 i++;
-	      }
-           }
- 	}
+		while(mycustomttable[i].chipID != 0) {
+			if(!strnicmp(name,mycustomttable[i].optionName,
+			   strlen(mycustomttable[i].optionName))) {
+				sisfb_specialtiming = mycustomttable[i].SpecialID;
+				found = TRUE;
+				printk(KERN_INFO "sisfb: Special timing for %s %s forced (\"%s\")\n",
+					mycustomttable[i].vendorName,
+					mycustomttable[i].cardName,
+					mycustomttable[i].optionName);
+				break;
+			}
+			i++;
+		}
+		if(!found) {
+			printk(KERN_WARNING "sisfb: Invalid SpecialTiming parameter, valid are:");
+			printk(KERN_WARNING "\t\"none\" (to disable special timings)\n");
+			i = 0;
+			while(mycustomttable[i].chipID != 0) {
+				printk(KERN_WARNING "\t\"%s\" (for %s %s)\n",
+					mycustomttable[i].optionName,
+					mycustomttable[i].vendorName,
+					mycustomttable[i].cardName);
+				i++;
+			}
+		}
+	}
+}
+
+/* ----------- Various detection routines ----------- */
+
+static void __devinit
+sisfb_detect_custom_timing(struct sis_video_info *ivideo)
+{
+	unsigned char *biosver = NULL;
+	unsigned char *biosdate = NULL;
+	BOOLEAN footprint;
+	u32 chksum = 0;
+	int i, j;
+
+	if(ivideo->SiS_Pr.UseROM) {
+		biosver = ivideo->SiS_Pr.VirtualRomBase + 0x06;
+		biosdate = ivideo->SiS_Pr.VirtualRomBase + 0x2c;
+		for(i = 0; i < 32768; i++)
+			chksum += ivideo->SiS_Pr.VirtualRomBase[i];
+	}
+
+	i = 0;
+	do {
+		if( (mycustomttable[i].chipID == ivideo->chip)			&&
+		    ((!strlen(mycustomttable[i].biosversion)) ||
+		     (ivideo->SiS_Pr.UseROM &&
+		      (!strncmp(mycustomttable[i].biosversion, biosver,
+				strlen(mycustomttable[i].biosversion)))))	&&
+		    ((!strlen(mycustomttable[i].biosdate)) ||
+		     (ivideo->SiS_Pr.UseROM &&
+		      (!strncmp(mycustomttable[i].biosdate, biosdate,
+				strlen(mycustomttable[i].biosdate)))))		&&
+		    ((!mycustomttable[i].bioschksum) ||
+		     (ivideo->SiS_Pr.UseROM &&
+		      (mycustomttable[i].bioschksum == chksum)))		&&
+		    (mycustomttable[i].pcisubsysvendor == ivideo->subsysvendor) &&
+		    (mycustomttable[i].pcisubsyscard == ivideo->subsysdevice) ) {
+			footprint = TRUE;
+			for(j = 0; j < 5; j++) {
+				if(mycustomttable[i].biosFootprintAddr[j]) {
+					if(ivideo->SiS_Pr.UseROM) {
+						if(ivideo->SiS_Pr.VirtualRomBase[mycustomttable[i].biosFootprintAddr[j]] !=
+							mycustomttable[i].biosFootprintData[j]) {
+							footprint = FALSE;
+						}
+					} else
+						footprint = FALSE;
+				}
+			}
+			if(footprint) {
+				ivideo->SiS_Pr.SiS_CustomT = mycustomttable[i].SpecialID;
+				printk(KERN_DEBUG "sisfb: Identified [%s %s], special timing applies\n",
+					mycustomttable[i].vendorName,
+				mycustomttable[i].cardName);
+				printk(KERN_DEBUG "sisfb: [specialtiming parameter name: %s]\n",
+					mycustomttable[i].optionName);
+				break;
+			}
+		}
+		i++;
+	} while(mycustomttable[i].chipID);
@@ -387,2 +463,2 @@
-	   printk(KERN_DEBUG "sisfb: Bad EDID header\n");
-	   return FALSE;
+		printk(KERN_DEBUG "sisfb: Bad EDID header\n");
+		return FALSE;
@@ -392,3 +468,3 @@
-	   printk(KERN_INFO "sisfb: EDID version %d not supported\n",
-	   	buffer[0x12]);
-	   return FALSE;
+		printk(KERN_INFO "sisfb: EDID version %d not supported\n",
+			buffer[0x12]);
+		return FALSE;
@@ -400,3 +476,4 @@
-	   if(!(buffer[0x14] & 0x08)) {
-	      printk(KERN_INFO "sisfb: WARNING: Monitor does not support separate syncs\n");
-	   }
+		if(!(buffer[0x14] & 0x08)) {
+			printk(KERN_INFO
+				"sisfb: WARNING: Monitor does not support separate syncs\n");
+		}
@@ -412 +489 @@
-	          buffer[j + 2] == 0x00 && buffer[j + 3] == 0xfd &&
+		  buffer[j + 2] == 0x00 && buffer[j + 3] == 0xfd &&
@@ -438 +515 @@
-	         if(monitor->hmin > sisfb_ddcsmodes[i].h) monitor->hmin = sisfb_ddcsmodes[i].h;
+		 if(monitor->hmin > sisfb_ddcsmodes[i].h) monitor->hmin = sisfb_ddcsmodes[i].h;
@@ -449,4 +526,4 @@
-	         case 0xc0: yres = (xres * 9) / 16; break;
-	         case 0x80: yres = (xres * 4) /  5; break;
-	         case 0x40: yres = (xres * 3) /  4; break;
-	         default:   yres = xres;	    break;
+		 case 0xc0: yres = (xres * 9) / 16; break;
+		 case 0x80: yres = (xres * 4) /  5; break;
+		 case 0x40: yres = (xres * 3) /  4; break;
+		 default:   yres = xres;	    break;
@@ -456,3 +533,3 @@
-                 for(j = 0; j < 8; j++) {
-	            if((xres == sisfb_ddcfmodes[j].x) &&
-	               (yres == sisfb_ddcfmodes[j].y) &&
+		 for(j = 0; j < 8; j++) {
+		    if((xres == sisfb_ddcfmodes[j].x) &&
+		       (yres == sisfb_ddcfmodes[j].y) &&
@@ -464,3 +541,3 @@
-		      if(monitor->dclockmax < sisfb_ddcsmodes[j].d) monitor->dclockmax = sisfb_ddcsmodes[i].d;
-	            }
-	         }
+		      if(monitor->dclockmax < sisfb_ddcsmodes[j].d) monitor->dclockmax = sisfb_ddcsmodes[j].d;
+		    }
+		 }
@@ -469 +546 @@
-           }
+	   }
@@ -475 +552 @@
- 	return(monitor->datavalid);
+	return monitor->datavalid;
@@ -481,2 +558,2 @@
-	USHORT  temp, i, realcrtno = crtno;
-   	u8      buffer[256];
+	unsigned short temp, i, realcrtno = crtno;
+	unsigned char  buffer[256];
@@ -487,11 +564,12 @@
-       	   if(ivideo->vbflags & CRT2_LCD)      realcrtno = 1;
-      	   else if(ivideo->vbflags & CRT2_VGA) realcrtno = 2;
-      	   else return;
-   	}
-
-	if((ivideo->sisfb_crt1off) && (!crtno)) return;
-
-    	temp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags, ivideo->sisvga_engine,
-				realcrtno, 0, &buffer[0]);
-   	if((!temp) || (temp == 0xffff)) {
-      	   printk(KERN_INFO "sisfb: CRT%d DDC probing failed\n", crtno + 1);
+	   if(ivideo->vbflags & CRT2_LCD)      realcrtno = 1;
+	   else if(ivideo->vbflags & CRT2_VGA) realcrtno = 2;
+	   else return;
+	}
+
+	if((ivideo->sisfb_crt1off) && (!crtno))
+		return;
+
+	temp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags, ivideo->sisvga_engine,
+				realcrtno, 0, &buffer[0], ivideo->vbflags2);
+	if((!temp) || (temp == 0xffff)) {
+	   printk(KERN_INFO "sisfb: CRT%d DDC probing failed\n", crtno + 1);
@@ -499,9 +577,9 @@
-   	} else {
-      	   printk(KERN_INFO "sisfb: CRT%d DDC supported\n", crtno + 1);
-      	   printk(KERN_INFO "sisfb: CRT%d DDC level: %s%s%s%s\n",
-	   	crtno + 1,
-	   	(temp & 0x1a) ? "" : "[none of the supported]",
-	   	(temp & 0x02) ? "2 " : "",
-	   	(temp & 0x08) ? "D&P" : "",
-           	(temp & 0x10) ? "FPDI-2" : "");
-      	   if(temp & 0x02) {
+	} else {
+	   printk(KERN_INFO "sisfb: CRT%d DDC supported\n", crtno + 1);
+	   printk(KERN_INFO "sisfb: CRT%d DDC level: %s%s%s%s\n",
+		crtno + 1,
+		(temp & 0x1a) ? "" : "[none of the supported]",
+		(temp & 0x02) ? "2 " : "",
+		(temp & 0x08) ? "D&P" : "",
+		(temp & 0x10) ? "FPDI-2" : "");
+	   if(temp & 0x02) {
@@ -510,2 +588,2 @@
-	    	 temp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags, ivideo->sisvga_engine,
-				     realcrtno, 1, &buffer[0]);
+		 temp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags, ivideo->sisvga_engine,
+				     realcrtno, 1, &buffer[0], ivideo->vbflags2);
@@ -513,2 +591,2 @@
-              if(!temp) {
-	    	 if(sisfb_interpret_edid(monitor, &buffer[0])) {
+	      if(!temp) {
+		 if(sisfb_interpret_edid(monitor, &buffer[0])) {
@@ -516 +594 @@
-		    	monitor->hmin, monitor->hmax, monitor->vmin, monitor->vmax,
+			monitor->hmin, monitor->hmax, monitor->vmin, monitor->vmax,
@@ -519,2 +597,2 @@
-	       	    printk(KERN_INFO "sisfb: CRT%d DDC EDID corrupt\n", crtno + 1);
-	    	 }
+		    printk(KERN_INFO "sisfb: CRT%d DDC EDID corrupt\n", crtno + 1);
+		 }
@@ -522 +600 @@
-            	 printk(KERN_INFO "sisfb: CRT%d DDC reading failed\n", crtno + 1);
+		 printk(KERN_INFO "sisfb: CRT%d DDC reading failed\n", crtno + 1);
@@ -529,0 +608,2 @@
+/* -------------- Mode validation --------------- */
+
@@ -537 +617,2 @@
-	if(!monitor->datavalid) return TRUE;
+	if(!monitor->datavalid)
+		return TRUE;
@@ -539 +620,2 @@
-	if(mode_idx < 0) return FALSE;
+	if(mode_idx < 0)
+		return FALSE;
@@ -542,11 +624,11 @@
-    	switch(sisbios_mode[mode_idx].mode_no[ivideo->mni]) {
-    	case 0x59:
-    	case 0x41:
-    	case 0x4f:
-    	case 0x50:
-    	case 0x56:
-    	case 0x53:
-    	case 0x2f:
-    	case 0x5d:
-    	case 0x5e:
-    		return TRUE;
+	switch(sisbios_mode[mode_idx].mode_no[ivideo->mni]) {
+	case 0x59:
+	case 0x41:
+	case 0x4f:
+	case 0x50:
+	case 0x56:
+	case 0x53:
+	case 0x2f:
+	case 0x5d:
+	case 0x5e:
+		return TRUE;
@@ -558 +640 @@
-    	}
+	}
@@ -560,2 +642,4 @@
-	if(rate < (monitor->vmin - 1)) return FALSE;
-	if(rate > (monitor->vmax + 1)) return FALSE;
+	if(rate < (monitor->vmin - 1))
+		return FALSE;
+	if(rate > (monitor->vmax + 1))
+		return FALSE;
@@ -563 +647 @@
-	if(sisfb_gettotalfrommode(&ivideo->SiS_Pr, &ivideo->sishw_ext,
+	if(sisfb_gettotalfrommode(&ivideo->SiS_Pr,
@@ -565 +649 @@
-	                          &htotal, &vtotal, rate_idx)) {
+				  &htotal, &vtotal, rate_idx)) {
@@ -567 +651,2 @@
-		if(dclock > (monitor->dclockmax + 1000)) return FALSE;
+		if(dclock > (monitor->dclockmax + 1000))
+			return FALSE;
@@ -569,2 +654,4 @@
-		if(hsync < (monitor->hmin - 1)) return FALSE;
-		if(hsync > (monitor->hmax + 1)) return FALSE;
+		if(hsync < (monitor->hmin - 1))
+			return FALSE;
+		if(hsync > (monitor->hmax + 1))
+			return FALSE;
@@ -572 +659 @@
-	  	return FALSE;
+		return FALSE;
@@ -580 +667 @@
-   u16 xres=0, yres, myres;
+	u16 xres=0, yres, myres;
@@ -583,3 +670,4 @@
-   if(ivideo->sisvga_engine == SIS_300_VGA) {
-      if(!(sisbios_mode[myindex].chipset & MD_SIS300)) return(-1);
-   }
+	if(ivideo->sisvga_engine == SIS_300_VGA) {
+		if(!(sisbios_mode[myindex].chipset & MD_SIS300))
+			return -1 ;
+	}
@@ -588,3 +676,4 @@
-   if(ivideo->sisvga_engine == SIS_315_VGA) {
-      if(!(sisbios_mode[myindex].chipset & MD_SIS315)) return(-1);
-   }
+	if(ivideo->sisvga_engine == SIS_315_VGA) {
+		if(!(sisbios_mode[myindex].chipset & MD_SIS315))
+			return -1;
+	}
@@ -593,3 +682 @@
-   myres = sisbios_mode[myindex].yres;
-
-   switch(vbflags & VB_DISPTYPE_DISP2) {
+	myres = sisbios_mode[myindex].yres;
@@ -597 +684 @@
-     case CRT2_LCD:
+	switch(vbflags & VB_DISPTYPE_DISP2) {
@@ -599 +686,2 @@
-        xres = ivideo->lcdxres; yres = ivideo->lcdyres;
+	case CRT2_LCD:
+		xres = ivideo->lcdxres; yres = ivideo->lcdyres;
@@ -601,4 +689,7 @@
-	if(ivideo->SiS_Pr.SiS_CustomT != CUT_PANEL848) {
-	   	if(sisbios_mode[myindex].xres > xres) return(-1);
-           	if(myres > yres) return(-1);
-	}
+		if((ivideo->SiS_Pr.SiS_CustomT != CUT_PANEL848) &&
+		   (ivideo->SiS_Pr.SiS_CustomT != CUT_PANEL856)) {
+			if(sisbios_mode[myindex].xres > xres)
+				return -1;
+			if(myres > yres)
+				return -1;
+		}
@@ -606,16 +697,11 @@
-	if(vbflags & (VB_LVDS | VB_30xBDH)) {
-	   if(sisbios_mode[myindex].xres == 320) {
-	      if((myres == 240) || (myres == 480)) {
-		 if(!ivideo->sisfb_fstn) {
-		    if(sisbios_mode[myindex].mode_no[1] == 0x5a ||
-		       sisbios_mode[myindex].mode_no[1] == 0x5b)
-		       return(-1);
-		 } else {
-		    if(sisbios_mode[myindex].mode_no[1] == 0x50 ||
-		       sisbios_mode[myindex].mode_no[1] == 0x56 ||
-		       sisbios_mode[myindex].mode_no[1] == 0x53)
-		       return(-1);
-		 }
-	      }
-	   }
-	}
+		if(ivideo->sisfb_fstn) {
+			if(sisbios_mode[myindex].xres == 320) {
+				if(myres == 240) {
+					switch(sisbios_mode[myindex].mode_no[1]) {
+						case 0x50: myindex = MODE_FSTN_8;  break;
+						case 0x56: myindex = MODE_FSTN_16; break;
+						case 0x53: return -1;
+					}
+				}
+			}
+		}
@@ -623,6 +709,6 @@
-	if(SiS_GetModeID_LCD(ivideo->sisvga_engine, vbflags, sisbios_mode[myindex].xres,
-			     sisbios_mode[myindex].yres, 0, ivideo->sisfb_fstn,
-			     ivideo->SiS_Pr.SiS_CustomT, xres, yres) < 0x14) {
-	   	return(-1);
-	}
-	break;
+		if(SiS_GetModeID_LCD(ivideo->sisvga_engine, vbflags, sisbios_mode[myindex].xres,
+			 	sisbios_mode[myindex].yres, 0, ivideo->sisfb_fstn,
+			 	ivideo->SiS_Pr.SiS_CustomT, xres, yres, ivideo->vbflags2) < 0x14) {
+			return -1;
+		}
+		break;
@@ -630,6 +716,6 @@
-     case CRT2_TV:
-	if(SiS_GetModeID_TV(ivideo->sisvga_engine, vbflags, sisbios_mode[myindex].xres,
-	                    sisbios_mode[myindex].yres, 0) < 0x14) {
-	   	return(-1);
-	}
-	break;
+	case CRT2_TV:
+		if(SiS_GetModeID_TV(ivideo->sisvga_engine, vbflags, sisbios_mode[myindex].xres,
+				sisbios_mode[myindex].yres, 0, ivideo->vbflags2) < 0x14) {
+			return -1;
+		}
+		break;
@@ -637,4 +723,6 @@
-     case CRT2_VGA:
-        if(SiS_GetModeID_VGA2(ivideo->sisvga_engine, vbflags, sisbios_mode[myindex].xres,
-	                      sisbios_mode[myindex].yres, 0) < 0x14) {
-	   	return(-1);
+	case CRT2_VGA:
+		if(SiS_GetModeID_VGA2(ivideo->sisvga_engine, vbflags, sisbios_mode[myindex].xres,
+				sisbios_mode[myindex].yres, 0, ivideo->vbflags2) < 0x14) {
+			return -1;
+		}
+		break;
@@ -642,2 +729,0 @@
-	break;
-     }
@@ -645 +731 @@
-     return(myindex);
+	return myindex;
@@ -651 +736,0 @@
-	u16 xres, yres;
@@ -653,3 +738,2 @@
-
-	xres = sisbios_mode[mode_idx].xres;
-	yres = sisbios_mode[mode_idx].yres;
+	u16 xres = sisbios_mode[mode_idx].xres;
+	u16 yres = sisbios_mode[mode_idx].yres;
@@ -675 +759 @@
-				} 
+				}
@@ -680,3 +764,3 @@
-	           		ivideo->rate_idx = sisfb_vrate[i].idx;
-		   		break;
-	       		}
+				ivideo->rate_idx = sisfb_vrate[i].idx;
+				break;
+			}
@@ -698 +782 @@
-   unsigned char P1_00;
+	unsigned char P1_00;
@@ -700 +784,2 @@
-   if(!(ivideo->vbflags & VB_VIDEOBRIDGE)) return FALSE;
+	if(!(ivideo->vbflags2 & VB2_VIDEOBRIDGE))
+		return FALSE;
@@ -702,7 +787,7 @@
-   inSISIDXREG(SISPART1,0x00,P1_00);
-   if( ((ivideo->sisvga_engine == SIS_300_VGA) && (P1_00 & 0xa0) == 0x20) ||
-       ((ivideo->sisvga_engine == SIS_315_VGA) && (P1_00 & 0x50) == 0x10) ) {
-	   return TRUE;
-   } else {
-           return FALSE;
-   }
+	inSISIDXREG(SISPART1,0x00,P1_00);
+	if( ((ivideo->sisvga_engine == SIS_300_VGA) && (P1_00 & 0xa0) == 0x20) ||
+	    ((ivideo->sisvga_engine == SIS_315_VGA) && (P1_00 & 0x50) == 0x10) ) {
+		return TRUE;
+	} else {
+		return FALSE;
+	}
@@ -714 +799 @@
-   u8 temp;
+	u8 temp;
@@ -716,2 +801,7 @@
-   inSISIDXREG(SISCR,0x17,temp);
-   if(!(temp & 0x80)) return FALSE;
+	inSISIDXREG(SISCR,0x17,temp);
+	if(!(temp & 0x80))
+		return FALSE;
+
+	inSISIDXREG(SISSR,0x1f,temp);
+	if(temp & 0xc0)
+		return FALSE;
@@ -719,4 +809 @@
-   inSISIDXREG(SISSR,0x1f,temp);
-   if(temp & 0xc0) return FALSE;
-
-   return TRUE;
+	return TRUE;
@@ -728 +815,2 @@
-   if(!sisfballowretracecrt1(ivideo)) return FALSE;
+	if(!sisfballowretracecrt1(ivideo))
+		return FALSE;
@@ -730,2 +818,4 @@
-   if(inSISREG(SISINPSTAT) & 0x08) return TRUE;
-   else 			   return FALSE;
+	if(inSISREG(SISINPSTAT) & 0x08)
+		return TRUE;
+	else
+		return FALSE;
@@ -737 +827 @@
-   int watchdog;
+	int watchdog;
@@ -739 +829,2 @@
-   if(!sisfballowretracecrt1(ivideo)) return;
+	if(!sisfballowretracecrt1(ivideo))
+		return;
@@ -741,4 +832,4 @@
-   watchdog = 65536;
-   while((!(inSISREG(SISINPSTAT) & 0x08)) && --watchdog);
-   watchdog = 65536;
-   while((inSISREG(SISINPSTAT) & 0x08) && --watchdog);
+	watchdog = 65536;
+	while((!(inSISREG(SISINPSTAT) & 0x08)) && --watchdog);
+	watchdog = 65536;
+	while((inSISREG(SISINPSTAT) & 0x08) && --watchdog);
@@ -750 +841,7 @@
-   unsigned char temp, reg;
+	unsigned char temp, reg;
+
+	switch(ivideo->sisvga_engine) {
+	case SIS_300_VGA: reg = 0x25; break;
+	case SIS_315_VGA: reg = 0x30; break;
+	default:	  return FALSE;
+	}
@@ -752,9 +849,5 @@
-   switch(ivideo->sisvga_engine) {
-   case SIS_300_VGA: reg = 0x25; break;
-   case SIS_315_VGA: reg = 0x30; break;
-   default:          return FALSE;
-   }
-
-   inSISIDXREG(SISPART1, reg, temp);
-   if(temp & 0x02) return TRUE;
-   else 	   return FALSE;
+	inSISIDXREG(SISPART1, reg, temp);
+	if(temp & 0x02)
+		return TRUE;
+	else
+		return FALSE;
@@ -766,8 +859,6 @@
-   if(ivideo->currentvbflags & VB_DISPTYPE_DISP2) {
-      if(sisfb_bridgeisslave(ivideo)) {
-         return(sisfbcheckvretracecrt1(ivideo));
-      } else {
-         return(sisfbcheckvretracecrt2(ivideo));
-      }
-   } 
-   return(sisfbcheckvretracecrt1(ivideo));
+	if(ivideo->currentvbflags & VB_DISPTYPE_DISP2) {
+		if(!sisfb_bridgeisslave(ivideo)) {
+			return sisfbcheckvretracecrt2(ivideo);
+		}
+	}
+	return sisfbcheckvretracecrt1(ivideo);
@@ -779,2 +870,4 @@
-   u8 idx, reg1, reg2, reg3, reg4;
-   u32 ret = 0;
+	u8 idx, reg1, reg2, reg3, reg4;
+	u32 ret = 0;
+
+	(*vcount) = (*hcount) = 0;
@@ -782 +875 @@
-   (*vcount) = (*hcount) = 0;
+	if((ivideo->currentvbflags & VB_DISPTYPE_DISP2) && (!(sisfb_bridgeisslave(ivideo)))) {
@@ -784,36 +877,38 @@
-   if((ivideo->currentvbflags & VB_DISPTYPE_DISP2) && (!(sisfb_bridgeisslave(ivideo)))) {
-      ret |= (FB_VBLANK_HAVE_VSYNC  |
-      	      FB_VBLANK_HAVE_HBLANK |
-              FB_VBLANK_HAVE_VBLANK |
-	      FB_VBLANK_HAVE_VCOUNT |
-	      FB_VBLANK_HAVE_HCOUNT);
-      switch(ivideo->sisvga_engine) {
-         case SIS_300_VGA: idx = 0x25; break;
-	 default:
-         case SIS_315_VGA: idx = 0x30; break;
-      }
-      inSISIDXREG(SISPART1,(idx+0),reg1); /* 30 */
-      inSISIDXREG(SISPART1,(idx+1),reg2); /* 31 */
-      inSISIDXREG(SISPART1,(idx+2),reg3); /* 32 */
-      inSISIDXREG(SISPART1,(idx+3),reg4); /* 33 */
-      if(reg1 & 0x01) ret |= FB_VBLANK_VBLANKING;
-      if(reg1 & 0x02) ret |= FB_VBLANK_VSYNCING;
-      if(reg4 & 0x80) ret |= FB_VBLANK_HBLANKING;
-      (*vcount) = reg3 | ((reg4 & 0x70) << 4);
-      (*hcount) = reg2 | ((reg4 & 0x0f) << 8);
-   } else if(sisfballowretracecrt1(ivideo)) {
-      ret |= (FB_VBLANK_HAVE_VSYNC  |
-              FB_VBLANK_HAVE_VBLANK |
-	      FB_VBLANK_HAVE_VCOUNT |
-	      FB_VBLANK_HAVE_HCOUNT);
-      reg1 = inSISREG(SISINPSTAT);
-      if(reg1 & 0x08) ret |= FB_VBLANK_VSYNCING;
-      if(reg1 & 0x01) ret |= FB_VBLANK_VBLANKING;
-      inSISIDXREG(SISCR,0x20,reg1);
-      inSISIDXREG(SISCR,0x1b,reg1);
-      inSISIDXREG(SISCR,0x1c,reg2);
-      inSISIDXREG(SISCR,0x1d,reg3);
-      (*vcount) = reg2 | ((reg3 & 0x07) << 8);
-      (*hcount) = (reg1 | ((reg3 & 0x10) << 4)) << 3;
-   }
-   return ret;
+		ret |= (FB_VBLANK_HAVE_VSYNC  |
+			FB_VBLANK_HAVE_HBLANK |
+			FB_VBLANK_HAVE_VBLANK |
+			FB_VBLANK_HAVE_VCOUNT |
+			FB_VBLANK_HAVE_HCOUNT);
+		switch(ivideo->sisvga_engine) {
+			case SIS_300_VGA: idx = 0x25; break;
+			default:
+			case SIS_315_VGA: idx = 0x30; break;
+		}
+		inSISIDXREG(SISPART1,(idx+0),reg1); /* 30 */
+		inSISIDXREG(SISPART1,(idx+1),reg2); /* 31 */
+		inSISIDXREG(SISPART1,(idx+2),reg3); /* 32 */
+		inSISIDXREG(SISPART1,(idx+3),reg4); /* 33 */
+		if(reg1 & 0x01) ret |= FB_VBLANK_VBLANKING;
+		if(reg1 & 0x02) ret |= FB_VBLANK_VSYNCING;
+		if(reg4 & 0x80) ret |= FB_VBLANK_HBLANKING;
+		(*vcount) = reg3 | ((reg4 & 0x70) << 4);
+		(*hcount) = reg2 | ((reg4 & 0x0f) << 8);
+
+	} else if(sisfballowretracecrt1(ivideo)) {
+
+		ret |= (FB_VBLANK_HAVE_VSYNC  |
+			FB_VBLANK_HAVE_VBLANK |
+			FB_VBLANK_HAVE_VCOUNT |
+			FB_VBLANK_HAVE_HCOUNT);
+		reg1 = inSISREG(SISINPSTAT);
+		if(reg1 & 0x08) ret |= FB_VBLANK_VSYNCING;
+		if(reg1 & 0x01) ret |= FB_VBLANK_VBLANKING;
+		inSISIDXREG(SISCR,0x20,reg1);
+		inSISIDXREG(SISCR,0x1b,reg1);
+		inSISIDXREG(SISCR,0x1c,reg2);
+		inSISIDXREG(SISCR,0x1d,reg3);
+		(*vcount) = reg2 | ((reg3 & 0x07) << 8);
+		(*hcount) = (reg1 | ((reg3 & 0x10) << 4)) << 3;
+	}
+
+	return ret;
@@ -825,2 +920,2 @@
-   u8 sr01, sr11, sr1f, cr63=0, p2_0, p1_13;
-   BOOLEAN backlight = TRUE;
+	u8 sr01, sr11, sr1f, cr63=0, p2_0, p1_13;
+	BOOLEAN backlight = TRUE;
@@ -828,85 +923,157 @@
-   switch(blank) {
-   case FB_BLANK_UNBLANK:	/* on */
-      sr01  = 0x00;
-      sr11  = 0x00;
-      sr1f  = 0x00;
-      cr63  = 0x00;
-      p2_0  = 0x20;
-      p1_13 = 0x00;
-      backlight = TRUE;
-      break;
-   case FB_BLANK_NORMAL:	/* blank */
-      sr01  = 0x20;
-      sr11  = 0x00;
-      sr1f  = 0x00;
-      cr63  = 0x00;
-      p2_0  = 0x20;
-      p1_13 = 0x00;
-      backlight = TRUE;
-      break;
-   case FB_BLANK_VSYNC_SUSPEND:	/* no vsync */
-      sr01  = 0x20;
-      sr11  = 0x08;
-      sr1f  = 0x80;
-      cr63  = 0x40;
-      p2_0  = 0x40;
-      p1_13 = 0x80;
-      backlight = FALSE;
-      break;
-   case FB_BLANK_HSYNC_SUSPEND:	/* no hsync */
-      sr01  = 0x20;
-      sr11  = 0x08;
-      sr1f  = 0x40;
-      cr63  = 0x40;
-      p2_0  = 0x80;
-      p1_13 = 0x40;
-      backlight = FALSE;
-      break;
-   case FB_BLANK_POWERDOWN:	/* off */
-      sr01  = 0x20;
-      sr11  = 0x08;
-      sr1f  = 0xc0;
-      cr63  = 0x40;
-      p2_0  = 0xc0;
-      p1_13 = 0xc0;
-      backlight = FALSE;
-      break;
-   default:
-      return 1;
-   }
-
-   if(ivideo->currentvbflags & VB_DISPTYPE_CRT1) {
-
-      if( (!ivideo->sisfb_thismonitor.datavalid) ||
-          ((ivideo->sisfb_thismonitor.datavalid) &&
-           (ivideo->sisfb_thismonitor.feature & 0xe0))) {
-
-	 if(ivideo->sisvga_engine == SIS_315_VGA) {
-	    setSISIDXREG(SISCR, ivideo->SiS_Pr.SiS_MyCR63, 0xbf, cr63);
-	 }
-
-	 if(!(sisfb_bridgeisslave(ivideo))) {
-	    setSISIDXREG(SISSR, 0x01, ~0x20, sr01);
-	    setSISIDXREG(SISSR, 0x1f, 0x3f, sr1f);
-	 }
-      }
-
-   }
-
-   if(ivideo->currentvbflags & CRT2_LCD) {
-
-      if(ivideo->vbflags & (VB_301LV|VB_302LV|VB_302ELV)) {
-	 if(backlight) {
-	    SiS_SiS30xBLOn(&ivideo->SiS_Pr, &ivideo->sishw_ext);
-	 } else {
-	    SiS_SiS30xBLOff(&ivideo->SiS_Pr, &ivideo->sishw_ext);
-	 }
-      } else if(ivideo->sisvga_engine == SIS_315_VGA) {
-	 if(ivideo->vbflags & VB_CHRONTEL) {
-	    if(backlight) {
-	       SiS_Chrontel701xBLOn(&ivideo->SiS_Pr,&ivideo->sishw_ext);
-	    } else {
-	       SiS_Chrontel701xBLOff(&ivideo->SiS_Pr);
-	    }
-	 }
-      }
+	switch(blank) {
+		case FB_BLANK_UNBLANK:	/* on */
+			sr01  = 0x00;
+			sr11  = 0x00;
+			sr1f  = 0x00;
+			cr63  = 0x00;
+			p2_0  = 0x20;
+			p1_13 = 0x00;
+			backlight = TRUE;
+			break;
+		case FB_BLANK_NORMAL:	/* blank */
+			sr01  = 0x20;
+			sr11  = 0x00;
+			sr1f  = 0x00;
+			cr63  = 0x00;
+			p2_0  = 0x20;
+			p1_13 = 0x00;
+			backlight = TRUE;
+			break;
+		case FB_BLANK_VSYNC_SUSPEND:	/* no vsync */
+			sr01  = 0x20;
+			sr11  = 0x08;
+			sr1f  = 0x80;
+			cr63  = 0x40;
+			p2_0  = 0x40;
+			p1_13 = 0x80;
+			backlight = FALSE;
+			break;
+		case FB_BLANK_HSYNC_SUSPEND:	/* no hsync */
+			sr01  = 0x20;
+			sr11  = 0x08;
+			sr1f  = 0x40;
+			cr63  = 0x40;
+			p2_0  = 0x80;
+			p1_13 = 0x40;
+			backlight = FALSE;
+			break;
+		case FB_BLANK_POWERDOWN:	/* off */
+			sr01  = 0x20;
+			sr11  = 0x08;
+			sr1f  = 0xc0;
+			cr63  = 0x40;
+			p2_0  = 0xc0;
+			p1_13 = 0xc0;
+			backlight = FALSE;
+			break;
+		default:
+			return 1;
+	}
+
+	if(ivideo->currentvbflags & VB_DISPTYPE_CRT1) {
+
+		if( (!ivideo->sisfb_thismonitor.datavalid) ||
+		    ((ivideo->sisfb_thismonitor.datavalid) &&
+		     (ivideo->sisfb_thismonitor.feature & 0xe0))) {
+
+			if(ivideo->sisvga_engine == SIS_315_VGA) {
+				setSISIDXREG(SISCR, ivideo->SiS_Pr.SiS_MyCR63, 0xbf, cr63);
+			}
+
+			if(!(sisfb_bridgeisslave(ivideo))) {
+				setSISIDXREG(SISSR, 0x01, ~0x20, sr01);
+				setSISIDXREG(SISSR, 0x1f, 0x3f, sr1f);
+			}
+		}
+
+	}
+
+	if(ivideo->currentvbflags & CRT2_LCD) {
+
+		if(ivideo->vbflags2 & VB2_SISLVDSBRIDGE) {
+			if(backlight) {
+				SiS_SiS30xBLOn(&ivideo->SiS_Pr);
+			} else {
+				SiS_SiS30xBLOff(&ivideo->SiS_Pr);
+			}
+		} else if(ivideo->sisvga_engine == SIS_315_VGA) {
+#ifdef CONFIG_FB_SIS_315
+			if(ivideo->vbflags2 & VB2_CHRONTEL) {
+				if(backlight) {
+					SiS_Chrontel701xBLOn(&ivideo->SiS_Pr);
+				} else {
+					SiS_Chrontel701xBLOff(&ivideo->SiS_Pr);
+				}
+			}
+#endif
+		}
+
+		if(((ivideo->sisvga_engine == SIS_300_VGA) &&
+		    (ivideo->vbflags2 & (VB2_301|VB2_30xBDH|VB2_LVDS))) ||
+		   ((ivideo->sisvga_engine == SIS_315_VGA) &&
+		    ((ivideo->vbflags2 & (VB2_LVDS | VB2_CHRONTEL)) == VB2_LVDS))) {
+			setSISIDXREG(SISSR, 0x11, ~0x0c, sr11);
+		}
+
+		if(ivideo->sisvga_engine == SIS_300_VGA) {
+			if((ivideo->vbflags2 & VB2_30xB) &&
+			   (!(ivideo->vbflags2 & VB2_30xBDH))) {
+				setSISIDXREG(SISPART1, 0x13, 0x3f, p1_13);
+			}
+		} else if(ivideo->sisvga_engine == SIS_315_VGA) {
+			if((ivideo->vbflags2 & VB2_30xB) &&
+			   (!(ivideo->vbflags2 & VB2_30xBDH))) {
+				setSISIDXREG(SISPART2, 0x00, 0x1f, p2_0);
+			}
+		}
+
+	} else if(ivideo->currentvbflags & CRT2_VGA) {
+
+		if(ivideo->vbflags2 & VB2_30xB) {
+			setSISIDXREG(SISPART2, 0x00, 0x1f, p2_0);
+		}
+
+	}
+
+	return 0;
+}
+
+/* ------------- Callbacks from init.c/init301.c  -------------- */
+
+#ifdef CONFIG_FB_SIS_300
+unsigned int
+sisfb_read_nbridge_pci_dword(struct SiS_Private *SiS_Pr, int reg)
+{
+   struct sis_video_info *ivideo = (struct sis_video_info *)SiS_Pr->ivideo;
+   u32 val = 0;
+
+   pci_read_config_dword(ivideo->nbridge, reg, &val);
+   return (unsigned int)val;
+}
+
+void
+sisfb_write_nbridge_pci_dword(struct SiS_Private *SiS_Pr, int reg, unsigned int val)
+{
+   struct sis_video_info *ivideo = (struct sis_video_info *)SiS_Pr->ivideo;
+
+   pci_write_config_dword(ivideo->nbridge, reg, (u32)val);
+}
+
+unsigned int
+sisfb_read_lpc_pci_dword(struct SiS_Private *SiS_Pr, int reg)
+{
+   struct sis_video_info *ivideo = (struct sis_video_info *)SiS_Pr->ivideo;
+   u32 val = 0;
+
+   if(!ivideo->lpcdev) return 0;
+
+   pci_read_config_dword(ivideo->lpcdev, reg, &val);
+   return (unsigned int)val;
+}
+#endif
+
+#ifdef CONFIG_FB_SIS_315
+void
+sisfb_write_nbridge_pci_byte(struct SiS_Private *SiS_Pr, int reg, unsigned char val)
+{
+   struct sis_video_info *ivideo = (struct sis_video_info *)SiS_Pr->ivideo;
@@ -914,24 +1081,8 @@
-      if(((ivideo->sisvga_engine == SIS_300_VGA) &&
-          (ivideo->vbflags & (VB_301|VB_30xBDH|VB_LVDS))) ||
-         ((ivideo->sisvga_engine == SIS_315_VGA) &&
-          ((ivideo->vbflags & (VB_LVDS | VB_CHRONTEL)) == VB_LVDS))) {
-          setSISIDXREG(SISSR, 0x11, ~0x0c, sr11);
-      }
-
-      if(ivideo->sisvga_engine == SIS_300_VGA) {
-         if((ivideo->vbflags & (VB_301B|VB_301C|VB_302B)) &&
-            (!(ivideo->vbflags & VB_30xBDH))) {
-	    setSISIDXREG(SISPART1, 0x13, 0x3f, p1_13);
-	 }
-      } else if(ivideo->sisvga_engine == SIS_315_VGA) {
-         if((ivideo->vbflags & (VB_301B|VB_301C|VB_302B)) &&
-            (!(ivideo->vbflags & VB_30xBDH))) {
-	    setSISIDXREG(SISPART2, 0x00, 0x1f, p2_0);
-	 }
-      }
-
-   } else if(ivideo->currentvbflags & CRT2_VGA) {
-
-      if(ivideo->vbflags & (VB_301B|VB_301C|VB_302B)) {
-         setSISIDXREG(SISPART2, 0x00, 0x1f, p2_0);
-      }
+   pci_write_config_byte(ivideo->nbridge, reg, (u8)val);
+}
+
+unsigned int
+sisfb_read_mio_pci_word(struct SiS_Private *SiS_Pr, int reg)
+{
+   struct sis_video_info *ivideo = (struct sis_video_info *)SiS_Pr->ivideo;
+   u16 val = 0;
@@ -939 +1090 @@
-   }
+   if(!ivideo->lpcdev) return 0;
@@ -941 +1092,2 @@
-   return(0);
+   pci_read_config_word(ivideo->lpcdev, reg, &val);
+   return (unsigned int)val;
@@ -942,0 +1095 @@
+#endif
@@ -955 +1108 @@
-   	switch(ivideo->video_bpp) {
+	switch(ivideo->video_bpp) {
@@ -975,2 +1128 @@
-		break;
-   	}
+	}
@@ -982 +1134 @@
-	int maxyres = ivideo->heapstart / (var->xres_virtual * (var->bits_per_pixel >> 3));
+	int maxyres = ivideo->sisfb_mem / (var->xres_virtual * (var->bits_per_pixel >> 3));
@@ -999 +1150,0 @@
-
@@ -1005 +1156 @@
-   	BOOLEAN isslavemode = FALSE;
+	BOOLEAN isslavemode = FALSE;
@@ -1009 +1160 @@
-   	if(sisfb_bridgeisslave(ivideo)) isslavemode = TRUE;
+	if(sisfb_bridgeisslave(ivideo)) isslavemode = TRUE;
@@ -1011,4 +1162,4 @@
-   	/* We need to set pitch for CRT1 if bridge is in slave mode, too */
-   	if((ivideo->currentvbflags & VB_DISPTYPE_DISP1) || (isslavemode)) {
-   		outSISIDXREG(SISCR,0x13,(HDisplay1 & 0xFF));
-   		setSISIDXREG(SISSR,0x0E,0xF0,(HDisplay1 >> 8));
+	/* We need to set pitch for CRT1 if bridge is in slave mode, too */
+	if((ivideo->currentvbflags & VB_DISPTYPE_DISP1) || (isslavemode)) {
+		outSISIDXREG(SISCR,0x13,(HDisplay1 & 0xFF));
+		setSISIDXREG(SISSR,0x0E,0xF0,(HDisplay1 >> 8));
@@ -1017,2 +1168,2 @@
-   	/* We must not set the pitch for CRT2 if bridge is in slave mode */
-   	if((ivideo->currentvbflags & VB_DISPTYPE_DISP2) && (!isslavemode)) {
+	/* We must not set the pitch for CRT2 if bridge is in slave mode */
+	if((ivideo->currentvbflags & VB_DISPTYPE_DISP2) && (!isslavemode)) {
@@ -1020,3 +1171,3 @@
-   		outSISIDXREG(SISPART1,0x07,(HDisplay2 & 0xFF));
-   		setSISIDXREG(SISPART1,0x09,0xF0,(HDisplay2 >> 8));
-   	}
+		outSISIDXREG(SISPART1,0x07,(HDisplay2 & 0xFF));
+		setSISIDXREG(SISPART1,0x09,0xF0,(HDisplay2 >> 8));
+	}
@@ -1058,0 +1210,29 @@
+sisfb_set_mode(struct sis_video_info *ivideo, int clrscrn)
+{
+	unsigned short modeno = ivideo->mode_no;
+
+	/* >=2.6.12's fbcon clears the screen anyway */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
+	if(!clrscrn) modeno |= 0x80;
+#else
+	modeno |= 0x80;
+#endif
+
+	outSISIDXREG(SISSR, IND_SIS_PASSWORD, SIS_PASSWORD);
+
+	sisfb_pre_setmode(ivideo);
+
+	if(SiSSetMode(&ivideo->SiS_Pr, modeno) == 0) {
+		printk(KERN_ERR "sisfb: Setting mode[0x%x] failed\n", ivideo->mode_no);
+		return -EINVAL;
+	}
+
+	outSISIDXREG(SISSR, IND_SIS_PASSWORD, SIS_PASSWORD);
+
+	sisfb_post_setmode(ivideo);
+
+	return 0;
+}
+
+
+static int
@@ -1064 +1244 @@
-	int found_mode = 0;
+	int found_mode = 0, ret;
@@ -1091,3 +1271,3 @@
-	   	drate = 1000000000 / pixclock;
-	   	hrate = (drate * 1000) / htotal;
-	   	ivideo->refresh_rate = (unsigned int) (hrate * 2 / vtotal);
+		drate = 1000000000 / pixclock;
+		hrate = (drate * 1000) / htotal;
+		ivideo->refresh_rate = (unsigned int) (hrate * 2 / vtotal);
@@ -1095 +1275 @@
-	   	ivideo->refresh_rate = 60;
+		ivideo->refresh_rate = 60;
@@ -1115,0 +1296 @@
+		ivideo->mode_no = sisbios_mode[ivideo->sisfb_mode_idx].mode_no[ivideo->mni];
@@ -1134 +1315 @@
-	   if(!sisfb_verify_rate(ivideo, &ivideo->sisfb_thismonitor, ivideo->sisfb_mode_idx,
+		if(!sisfb_verify_rate(ivideo, &ivideo->sisfb_thismonitor, ivideo->sisfb_mode_idx,
@@ -1136,2 +1317,2 @@
-	      printk(KERN_INFO "sisfb: WARNING: Refresh rate exceeds monitor specs!\n");
-	   }
+			printk(KERN_INFO "sisfb: WARNING: Refresh rate exceeds monitor specs!\n");
+		}
@@ -1146,18 +1327,3 @@
-		sisfb_pre_setmode(ivideo);
-
-		if(SiSSetMode(&ivideo->SiS_Pr, &ivideo->sishw_ext, ivideo->mode_no) == 0) {
-			printk(KERN_ERR "sisfb: Setting mode[0x%x] failed\n", ivideo->mode_no);
-			return -EINVAL;
-		}
-
-		outSISIDXREG(SISSR, IND_SIS_PASSWORD, SIS_PASSWORD);
-
-		sisfb_post_setmode(ivideo);
-
-		ivideo->video_bpp    = sisbios_mode[ivideo->sisfb_mode_idx].bpp;
-		ivideo->video_width  = sisbios_mode[ivideo->sisfb_mode_idx].xres;
-		ivideo->video_height = sisbios_mode[ivideo->sisfb_mode_idx].yres;
-
-		sisfb_calc_pitch(ivideo, var);
-		sisfb_set_pitch(ivideo);
-
+		/* If acceleration to be used? Need to know
+		 * before pre/post_set_mode()
+		 */
@@ -1177,0 +1344,11 @@
+		if((ret = sisfb_set_mode(ivideo, 1))) {
+			return ret;
+		}
+
+		ivideo->video_bpp    = sisbios_mode[ivideo->sisfb_mode_idx].bpp;
+		ivideo->video_width  = sisbios_mode[ivideo->sisfb_mode_idx].xres;
+		ivideo->video_height = sisbios_mode[ivideo->sisfb_mode_idx].yres;
+
+		sisfb_calc_pitch(ivideo, var);
+		sisfb_set_pitch(ivideo);
+
@@ -1189 +1366 @@
-                ivideo->sisfb_lastrates[ivideo->mode_no] = ivideo->refresh_rate;
+		ivideo->sisfb_lastrates[ivideo->mode_no] = ivideo->refresh_rate;
@@ -1196,2 +1373,2 @@
-static int
-sisfb_pan_var(struct sis_video_info *ivideo, struct fb_var_screeninfo *var)
+static void
+sisfb_set_base_CRT1(struct sis_video_info *ivideo, unsigned int base)
@@ -1199 +1376 @@
-	unsigned int base;
+	outSISIDXREG(SISSR, IND_SIS_PASSWORD, SIS_PASSWORD);
@@ -1201,25 +1378 @@
-	if(var->xoffset > (var->xres_virtual - var->xres)) {
-		return -EINVAL;
-	}
-	if(var->yoffset > (var->yres_virtual - var->yres)) {
-		return -EINVAL;
-	}
-
-	base = (var->yoffset * var->xres_virtual) + var->xoffset;
-
-        /* calculate base bpp dep. */
-        switch(var->bits_per_pixel) {
-	case 32:
-            	break;
-        case 16:
-        	base >>= 1;
-        	break;
-	case 8:
-        default:
-        	base >>= 2;
-            	break;
-        }
-	
-	outSISIDXREG(SISSR, IND_SIS_PASSWORD, SIS_PASSWORD);
-
-        outSISIDXREG(SISCR, 0x0D, base & 0xFF);
+	outSISIDXREG(SISCR, 0x0D, base & 0xFF);
@@ -1231,10 +1383,0 @@
-        if(ivideo->currentvbflags & VB_DISPTYPE_DISP2) {
-		orSISIDXREG(SISPART1, ivideo->CRT2_write_enable, 0x01);
-        	outSISIDXREG(SISPART1, 0x06, (base & 0xFF));
-        	outSISIDXREG(SISPART1, 0x05, ((base >> 8) & 0xFF));
-        	outSISIDXREG(SISPART1, 0x04, ((base >> 16) & 0xFF));
-		if(ivideo->sisvga_engine == SIS_315_VGA) {
-			setSISIDXREG(SISPART1, 0x02, 0x7F, ((base >> 24) & 0x01) << 7);
-		}
-        }
-	return 0;
@@ -1243,4 +1385,0 @@
-/* ------------ FBDev related routines for 2.4 series ----------- */
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-
@@ -1248,214 +1387 @@
-sisfb_crtc_to_var(struct sis_video_info *ivideo, struct fb_var_screeninfo *var)
-{
-	u16 VRE, VBE, VRS, VBS, VDE, VT;
-	u16 HRE, HBE, HRS, HBS, HDE, HT;
-	u8  sr_data, cr_data, cr_data2, cr_data3, mr_data;
-	int A, B, C, D, E, F, temp;
-	unsigned int hrate, drate, maxyres;
-
-	inSISIDXREG(SISSR, IND_SIS_COLOR_MODE, sr_data);
-
-	if(sr_data & SIS_INTERLACED_MODE)
-	   var->vmode = FB_VMODE_INTERLACED;
-	else
-	   var->vmode = FB_VMODE_NONINTERLACED;
-
-	switch((sr_data & 0x1C) >> 2) {
-	case SIS_8BPP_COLOR_MODE:
-		var->bits_per_pixel = 8;
-		break;
-	case SIS_16BPP_COLOR_MODE:
-		var->bits_per_pixel = 16;
-		break;
-	case SIS_32BPP_COLOR_MODE:
-		var->bits_per_pixel = 32;
-		break;
-	}
-
-	sisfb_bpp_to_var(ivideo, var);
-	
-	inSISIDXREG(SISSR, 0x0A, sr_data);
-        inSISIDXREG(SISCR, 0x06, cr_data);
-        inSISIDXREG(SISCR, 0x07, cr_data2);
-
-	VT = (cr_data & 0xFF) |
-	     ((u16) (cr_data2 & 0x01) << 8) |
-	     ((u16) (cr_data2 & 0x20) << 4) |
-	     ((u16) (sr_data  & 0x01) << 10);
-	A = VT + 2;
-
-	inSISIDXREG(SISCR, 0x12, cr_data);
-
-	VDE = (cr_data & 0xff) |
-	      ((u16) (cr_data2 & 0x02) << 7) |
-	      ((u16) (cr_data2 & 0x40) << 3) |
-	      ((u16) (sr_data  & 0x02) << 9);
-	E = VDE + 1;
-
-	inSISIDXREG(SISCR, 0x10, cr_data);
-
-	VRS = (cr_data & 0xff) |
-	      ((u16) (cr_data2 & 0x04) << 6) |
-	      ((u16) (cr_data2 & 0x80) << 2) |
-	      ((u16) (sr_data  & 0x08) << 7);
-	F = VRS + 1 - E;
-
-	inSISIDXREG(SISCR, 0x15, cr_data);
-	inSISIDXREG(SISCR, 0x09, cr_data3);
-
-	if(cr_data3 & 0x80) var->vmode = FB_VMODE_DOUBLE;
-
-	VBS = (cr_data & 0xff) |
-	      ((u16) (cr_data2 & 0x08) << 5) |
-	      ((u16) (cr_data3 & 0x20) << 4) |
-	      ((u16) (sr_data & 0x04) << 8);
-
-	inSISIDXREG(SISCR, 0x16, cr_data);
-
-	VBE = (cr_data & 0xff) | ((u16) (sr_data & 0x10) << 4);
-	temp = VBE - ((E - 1) & 511);
-	B = (temp > 0) ? temp : (temp + 512);
-
-	inSISIDXREG(SISCR, 0x11, cr_data);
-
-	VRE = (cr_data & 0x0f) | ((sr_data & 0x20) >> 1);
-	temp = VRE - ((E + F - 1) & 31);
-	C = (temp > 0) ? temp : (temp + 32);
-
-	D = B - F - C;
-
-        var->yres = E;
-	var->upper_margin = D;
-	var->lower_margin = F;
-	var->vsync_len = C;
-
-	if((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {
-	   var->yres <<= 1;
-	   var->upper_margin <<= 1;
-	   var->lower_margin <<= 1;
-	   var->vsync_len <<= 1;
-	} else if((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {
-	   var->yres >>= 1;
-	   var->upper_margin >>= 1;
-	   var->lower_margin >>= 1;
-	   var->vsync_len >>= 1;
-	}
-
-	inSISIDXREG(SISSR, 0x0b, sr_data);
-	inSISIDXREG(SISCR, 0x00, cr_data);
-
-	HT = (cr_data & 0xff) | ((u16) (sr_data & 0x03) << 8);
-	A = HT + 5;
-
-	inSISIDXREG(SISCR, 0x01, cr_data);
-
-	HDE = (cr_data & 0xff) | ((u16) (sr_data & 0x0C) << 6);
-	E = HDE + 1;
-
-	inSISIDXREG(SISCR, 0x04, cr_data);
-
-	HRS = (cr_data & 0xff) | ((u16) (sr_data & 0xC0) << 2);
-	F = HRS - E - 3;
-
-	inSISIDXREG(SISCR, 0x02, cr_data);
-
-	HBS = (cr_data & 0xff) | ((u16) (sr_data & 0x30) << 4);
-
-	inSISIDXREG(SISSR, 0x0c, sr_data);
-	inSISIDXREG(SISCR, 0x03, cr_data);
-	inSISIDXREG(SISCR, 0x05, cr_data2);
-
-	HBE = (cr_data & 0x1f) |
-	      ((u16) (cr_data2 & 0x80) >> 2) |
-	      ((u16) (sr_data  & 0x03) << 6);
-	HRE = (cr_data2 & 0x1f) | ((sr_data & 0x04) << 3);
-
-	temp = HBE - ((E - 1) & 255);
-	B = (temp > 0) ? temp : (temp + 256);
-
-	temp = HRE - ((E + F + 3) & 63);
-	C = (temp > 0) ? temp : (temp + 64);
-
-	D = B - F - C;
-
-	var->xres = E * 8;
-	if(var->xres_virtual < var->xres) {
-		var->xres_virtual = var->xres;
-	}
-
-	if((var->xres == 320) &&
-	   (var->yres == 200 || var->yres == 240)) {
-		/* Terrible hack, but the correct CRTC data for
-	  	 * these modes only produces a black screen...
-	  	 */
-       		var->left_margin = (400 - 376);
-       		var->right_margin = (328 - 320);
-       		var->hsync_len = (376 - 328);
-	} else {
-	   	var->left_margin = D * 8;
-	   	var->right_margin = F * 8;
-	   	var->hsync_len = C * 8;
-	}
-	var->activate = FB_ACTIVATE_NOW;
-
-	var->sync = 0;
-
-	mr_data = inSISREG(SISMISCR);
-	if(mr_data & 0x80)
-	   var->sync &= ~FB_SYNC_VERT_HIGH_ACT;
-	else
-	   var->sync |= FB_SYNC_VERT_HIGH_ACT;
-
-	if(mr_data & 0x40)
-	   var->sync &= ~FB_SYNC_HOR_HIGH_ACT;
-	else
-	   var->sync |= FB_SYNC_HOR_HIGH_ACT;
-
-	VT += 2;
-	VT <<= 1;
-	HT = (HT + 5) * 8;
-
-	if((var->vmode & FB_VMODE_MASK) == FB_VMODE_INTERLACED) {
-	   VT <<= 1;
-	}
-	hrate = ivideo->refresh_rate * VT / 2;
-	drate = (hrate * HT) / 1000;
-	var->pixclock = (u32) (1000000000 / drate);
-
-	if(ivideo->sisfb_ypan) {
-	   maxyres = sisfb_calc_maxyres(ivideo, var);
-	   if(ivideo->sisfb_max) {
-	      var->yres_virtual = maxyres;
-	   } else {
-	      if(var->yres_virtual > maxyres) {
-	         var->yres_virtual = maxyres;
-	      }
-	   }
-	   if(var->yres_virtual <= var->yres) {
-	      var->yres_virtual = var->yres;
-	   }
-	} else {
-	   var->yres_virtual = var->yres;
-	}
-
-}
-
-static int
-sis_getcolreg(unsigned regno, unsigned *red, unsigned *green, unsigned *blue,
-			 unsigned *transp, struct fb_info *info)
-{
-	struct sis_video_info *ivideo = (struct sis_video_info *)info->par;
-
-	if(regno >= ivideo->video_cmap_len) return 1;
-
-	*red   = ivideo->sis_palette[regno].red;
-	*green = ivideo->sis_palette[regno].green;
-	*blue  = ivideo->sis_palette[regno].blue;
-	*transp = 0;
-
-	return 0;
-}
-
-static int
-sisfb_setcolreg(unsigned regno, unsigned red, unsigned green, unsigned blue,
-                           unsigned transp, struct fb_info *info)
+sisfb_set_base_CRT2(struct sis_video_info *ivideo, unsigned int base)
@@ -1463,20 +1389,7 @@
-	struct sis_video_info *ivideo = (struct sis_video_info *)info->par;
-
-	if(regno >= ivideo->video_cmap_len) return 1;
-
-	ivideo->sis_palette[regno].red   = red;
-	ivideo->sis_palette[regno].green = green;
-	ivideo->sis_palette[regno].blue  = blue;
-
-	switch(ivideo->video_bpp) {
-#ifdef FBCON_HAS_CFB8
-	case 8:
-	        outSISREG(SISDACA, regno);
-		outSISREG(SISDACD, (red >> 10));
-		outSISREG(SISDACD, (green >> 10));
-		outSISREG(SISDACD, (blue >> 10));
-		if(ivideo->currentvbflags & VB_DISPTYPE_DISP2) {
-		        outSISREG(SISDAC2A, regno);
-			outSISREG(SISDAC2D, (red >> 8));
-			outSISREG(SISDAC2D, (green >> 8));
-			outSISREG(SISDAC2D, (blue >> 8));
+	if(ivideo->currentvbflags & VB_DISPTYPE_DISP2) {
+		orSISIDXREG(SISPART1, ivideo->CRT2_write_enable, 0x01);
+		outSISIDXREG(SISPART1, 0x06, (base & 0xFF));
+		outSISIDXREG(SISPART1, 0x05, ((base >> 8) & 0xFF));
+		outSISIDXREG(SISPART1, 0x04, ((base >> 16) & 0xFF));
+		if(ivideo->sisvga_engine == SIS_315_VGA) {
+			setSISIDXREG(SISPART1, 0x02, 0x7F, ((base >> 24) & 0x01) << 7);
@@ -1484,103 +1396,0 @@
-		break;
-#endif
-#ifdef FBCON_HAS_CFB16
-	case 16:
-		ivideo->sis_fbcon_cmap.cfb16[regno] =
-		    ((red & 0xf800)) | ((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);
-		break;
-#endif
-#ifdef FBCON_HAS_CFB32
-	case 32:
-		red   >>= 8;
-		green >>= 8;
-		blue  >>= 8;
-		ivideo->sis_fbcon_cmap.cfb32[regno] = (red << 16) | (green << 8) | (blue);
-		break;
-#endif
-	}
-
-	return 0;
-}
-
-static void
-sisfb_set_disp(int con, struct fb_var_screeninfo *var, struct fb_info *info)
-{
-	struct sis_video_info    *ivideo = (struct sis_video_info *)info->par;
-	struct display           *display;
-	struct display_switch    *sw;
-	struct fb_fix_screeninfo fix;
-	long   flags;
-
-	display = (con >= 0) ? &fb_display[con] : &ivideo->sis_disp;
-
-	sisfb_get_fix(&fix, con, info);
-
-	display->var = *var;
-	display->screen_base = (char *)ivideo->video_vbase;
-	display->visual = fix.visual;
-	display->type = fix.type;
-	display->type_aux = fix.type_aux;
-	display->ypanstep = fix.ypanstep;
-	display->ywrapstep = fix.ywrapstep;
-	display->line_length = fix.line_length;
-	display->can_soft_blank = 1;
-	display->inverse = ivideo->sisfb_inverse;
-	display->next_line = fix.line_length;
-
-	save_flags(flags);
-
-	switch(ivideo->video_bpp) {
-#ifdef FBCON_HAS_CFB8
-	case 8:	sw = ivideo->accel ? &fbcon_sis8 : &fbcon_cfb8;
-		break;
-#endif
-#ifdef FBCON_HAS_CFB16
-	case 16:sw = ivideo->accel ? &fbcon_sis16 : &fbcon_cfb16;
-		display->dispsw_data = &ivideo->sis_fbcon_cmap.cfb16;
-		break;
-#endif
-#ifdef FBCON_HAS_CFB32
-	case 32:sw = ivideo->accel ? &fbcon_sis32 : &fbcon_cfb32;
-		display->dispsw_data = &ivideo->sis_fbcon_cmap.cfb32;
-		break;
-#endif
-	default:sw = &fbcon_dummy;
-		break;
-	}
-	memcpy(&ivideo->sisfb_sw, sw, sizeof(*sw));
-	display->dispsw = &ivideo->sisfb_sw;
-
-	restore_flags(flags);
-
-        if(ivideo->sisfb_ypan) {
-  	    /* display->scrollmode = 0;  */
-	} else {
-	    display->scrollmode = SCROLL_YREDRAW;
-	    ivideo->sisfb_sw.bmove = fbcon_redraw_bmove;
-	}
-}
-
-static void
-sisfb_do_install_cmap(int con, struct fb_info *info)
-{
-	struct sis_video_info *ivideo = (struct sis_video_info *)info->par;
-
-        if(con != ivideo->currcon) return;
-
-        if(fb_display[con].cmap.len) {
-		fb_set_cmap(&fb_display[con].cmap, 1, sisfb_setcolreg, info);
-        } else {
-		int size = sisfb_get_cmap_len(&fb_display[con].var);
-		fb_set_cmap(fb_default_cmap(size), 1, sisfb_setcolreg, info);
-	}
-}
-
-static int
-sisfb_get_var(struct fb_var_screeninfo *var, int con, struct fb_info *info)
-{
-	struct sis_video_info *ivideo = (struct sis_video_info *)info->par;
-
-	if(con == -1) {
-		memcpy(var, &ivideo->default_var, sizeof(struct fb_var_screeninfo));
-	} else {
-		*var = fb_display[con].var;
@@ -1588,6 +1397,0 @@
-
-	if(ivideo->sisfb_fstn) {
-	   	if(var->xres == 320 && var->yres == 480) var->yres = 240;
-        }
-
-	return 0;
@@ -1597 +1401 @@
-sisfb_set_var(struct fb_var_screeninfo *var, int con, struct fb_info *info)
+sisfb_pan_var(struct sis_video_info *ivideo, struct fb_var_screeninfo *var)
@@ -1599,7 +1403 @@
-	struct sis_video_info *ivideo = (struct sis_video_info *)info->par;
-	int err;
-
-	fb_display[con].var.activate = FB_ACTIVATE_NOW;
-
-        if(sisfb_do_set_var(var, con == ivideo->currcon, info)) {
-		sisfb_crtc_to_var(ivideo, var);
+	if(var->xoffset > (var->xres_virtual - var->xres)) {
@@ -1608,69 +1406,2 @@
-
-	sisfb_crtc_to_var(ivideo, var);
-
-	sisfb_set_disp(con, var, info);
-
-	if(info->changevar) {
-		(*info->changevar)(con);
-	}
-
-	if((err = fb_alloc_cmap(&fb_display[con].cmap, 0, 0))) {
-		return err;
-	}
-
-	sisfb_do_install_cmap(con, info);
-
-#if 0	/* Why was this called here? */
-	unsigned int cols, rows;
-	cols = sisbios_mode[ivideo->sisfb_mode_idx].cols;
-	rows = sisbios_mode[ivideo->sisfb_mode_idx].rows;
- 	vc_resize_con(rows, cols, fb_display[con].conp->vc_num);
-#endif
-	return 0;
-}
-
-static int
-sisfb_get_cmap(struct fb_cmap *cmap, int kspc, int con, struct fb_info *info)
-{
-	struct sis_video_info *ivideo = (struct sis_video_info *)info->par;
-	struct display *display;
-
-	display = (con >= 0) ? &fb_display[con] : &ivideo->sis_disp;
-
-        if(con == ivideo->currcon) {
-
-		return fb_get_cmap(cmap, kspc, sis_getcolreg, info);
-
-	} else if(display->cmap.len) {
-
-		fb_copy_cmap(&display->cmap, cmap, kspc ? 0 : 2);
-
-	} else {
-
-		int size = sisfb_get_cmap_len(&display->var);
-		fb_copy_cmap(fb_default_cmap(size), cmap, kspc ? 0 : 2);
-
-	}
-
-	return 0;
-}
-
-static int
-sisfb_set_cmap(struct fb_cmap *cmap, int kspc, int con, struct fb_info *info)
-{
-	struct sis_video_info *ivideo = (struct sis_video_info *)info->par;
-	struct display *display;
-	int err, size;
-
-	display = (con >= 0) ? &fb_display[con] : &ivideo->sis_disp;
-
-	size = sisfb_get_cmap_len(&display->var);
-	if(display->cmap.len != size) {
-		err = fb_alloc_cmap(&display->cmap, size, 0);
-		if(err)	return err;
-	}
-        
-	if(con == ivideo->currcon) {
-		return fb_set_cmap(cmap, kspc, sisfb_setcolreg, info);
-	} else {
-		fb_copy_cmap(cmap, &display->cmap, kspc ? 0 : 1);
+	if(var->yoffset > (var->yres_virtual - var->yres)) {
+		return -EINVAL;
@@ -1679,10 +1410 @@
-	return 0;
-}
-
-static int
-sisfb_pan_display(struct fb_var_screeninfo *var, int con, struct fb_info* info)
-{
-	struct sis_video_info *ivideo = (struct sis_video_info *)info->par;
-	int err;
-
-	if(var->vmode & FB_VMODE_YWRAP) return -EINVAL;
+	ivideo->current_base = (var->yoffset * var->xres_virtual) + var->xoffset;
@@ -1690,3 +1412,11 @@
-	if((var->xoffset+fb_display[con].var.xres > fb_display[con].var.xres_virtual) ||
-	   (var->yoffset+fb_display[con].var.yres > fb_display[con].var.yres_virtual)) {
-		return -EINVAL;
+	/* calculate base bpp dep. */
+	switch(var->bits_per_pixel) {
+	case 32:
+		break;
+	case 16:
+		ivideo->current_base >>= 1;
+		break;
+	case 8:
+	default:
+		ivideo->current_base >>= 2;
+		break;
@@ -1695,3 +1425 @@
-        if(con == ivideo->currcon) {
-	   	if((err = sisfb_pan_var(ivideo, var)) < 0) return err;
-	}
+	ivideo->current_base += (ivideo->video_offset >> 2);
@@ -1699,2 +1427,2 @@
-	fb_display[con].var.xoffset = var->xoffset;
-	fb_display[con].var.yoffset = var->yoffset;
+	sisfb_set_base_CRT1(ivideo, ivideo->current_base);
+	sisfb_set_base_CRT2(ivideo, ivideo->current_base);
@@ -1705,39 +1433 @@
-static int
-sisfb_update_var(int con, struct fb_info *info)
-{
-	struct sis_video_info *ivideo = (struct sis_video_info *)info->par;
-
-        return(sisfb_pan_var(ivideo, &fb_display[con].var));
-}
-
-static int
-sisfb_switch(int con, struct fb_info *info)
-{
-	struct sis_video_info *ivideo = (struct sis_video_info *)info->par;
-	int cols, rows;
-
-        if(fb_display[ivideo->currcon].cmap.len) {
-		fb_get_cmap(&fb_display[ivideo->currcon].cmap, 1, sis_getcolreg, info);
-	}
-
-	fb_display[con].var.activate = FB_ACTIVATE_NOW;
-
-	if(!memcmp(&fb_display[con].var, &fb_display[ivideo->currcon].var,
-	                           	sizeof(struct fb_var_screeninfo))) {
-		ivideo->currcon = con;
-		return 1;
-	}
-
-	ivideo->currcon = con;
-
-	sisfb_do_set_var(&fb_display[con].var, 1, info);
-
-	sisfb_set_disp(con, &fb_display[con].var, info);
-
-	sisfb_do_install_cmap(con, info);
-
-	cols = sisbios_mode[ivideo->sisfb_mode_idx].cols;
-	rows = sisbios_mode[ivideo->sisfb_mode_idx].rows;
-	vc_resize_con(rows, cols, fb_display[con].conp->vc_num);
-
-	sisfb_update_var(con, info);
+/* ------------ FBDev related routines for 2.4 series ----------- */
@@ -1745,2 +1435 @@
-	return 1;
-}
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
@@ -1748,4 +1437 @@
-static void
-sisfb_blank(int blank, struct fb_info *info)
-{
-	struct sis_video_info *ivideo = (struct sis_video_info *)info->par;
+#include "sisfb_fbdev_2_4.h"
@@ -1753,2 +1438,0 @@
-	sisfb_myblank(ivideo, blank);
-}
@@ -1764 +1448 @@
-    	return 0;
+	return 0;
@@ -1770 +1454 @@
-    	return 0;
+	return 0;
@@ -1779 +1463,2 @@
-	if(regno >= sisfb_get_cmap_len(&info->var)) return 1;
+	if(regno >= sisfb_get_cmap_len(&info->var))
+		return 1;
@@ -1783 +1468 @@
-	        outSISREG(SISDACA, regno);
+		outSISREG(SISDACA, regno);
@@ -1788 +1473 @@
-		        outSISREG(SISDAC2A, regno);
+			outSISREG(SISDAC2A, regno);
@@ -1796 +1481,3 @@
-		    ((red & 0xf800)) | ((green & 0xfc00) >> 5) | ((blue & 0xf800) >> 11);
+				(red & 0xf800)          |
+				((green & 0xfc00) >> 5) |
+				((blue & 0xf800) >> 11);
@@ -1814 +1501 @@
-        if((err = sisfb_do_set_var(&info->var, 1, info))) {
+	if((err = sisfb_do_set_var(&info->var, 1, info)))
@@ -1816 +1503 @@
-	}
+
@@ -1820 +1507 @@
-      	sisfb_get_fix(&info->fix, -1, info);
+	sisfb_get_fix(&info->fix, -1, info);
@@ -1832 +1519 @@
-	int refresh_rate, search_idx;
+	int refresh_rate, search_idx, tidx;
@@ -1851 +1538,2 @@
-	} else 	vtotal += var->yres;
+	} else
+		vtotal += var->yres;
@@ -1863,3 +1551,5 @@
-		        if(sisfb_validate_mode(ivideo, search_idx, ivideo->currentvbflags) > 0) {
-			   found_mode = 1;
-			   break;
+			if((tidx = sisfb_validate_mode(ivideo, search_idx,
+						ivideo->currentvbflags)) > 0) {
+				found_mode = 1;
+				search_idx = tidx;
+				break;
@@ -1872 +1562 @@
-                search_idx = 0;
+		search_idx = 0;
@@ -1877,5 +1567,7 @@
-		          if(sisfb_validate_mode(ivideo,search_idx, ivideo->currentvbflags) > 0) {
-			     found_mode = 1;
-			     break;
-			  }
-		   }
+			if((tidx = sisfb_validate_mode(ivideo,search_idx,
+						ivideo->currentvbflags)) > 0) {
+				found_mode = 1;
+				search_idx = tidx;
+				break;
+			}
+		   }
@@ -1883 +1575 @@
-	        }
+		}
@@ -1885,2 +1577,3 @@
-			printk(KERN_DEBUG "sisfb: Adapted from %dx%dx%d to %dx%dx%d\n",
-		   		var->xres, var->yres, var->bits_per_pixel,
+			printk(KERN_DEBUG
+				"sisfb: Adapted from %dx%dx%d to %dx%dx%d\n",
+				var->xres, var->yres, var->bits_per_pixel,
@@ -1891,3 +1584 @@
-		      	var->yres = sisbios_mode[search_idx].yres;
-
-
+			var->yres = sisbios_mode[search_idx].yres;
@@ -1895 +1586,2 @@
-		   	printk(KERN_ERR "sisfb: Failed to find supported mode near %dx%dx%d\n",
+			printk(KERN_ERR
+				"sisfb: Failed to find supported mode near %dx%dx%d\n",
@@ -1897 +1589 @@
-		   	return -EINVAL;
+			return -EINVAL;
@@ -1901,2 +1593,2 @@
-	if( ((ivideo->vbflags & VB_LVDS) ||			/* Slave modes on LVDS and 301B-DH */
-	     ((ivideo->vbflags & VB_30xBDH) && (ivideo->currentvbflags & CRT2_LCD))) &&
+	if( ((ivideo->vbflags2 & VB2_LVDS) ||
+	     ((ivideo->vbflags2 & VB2_30xBDH) && (ivideo->currentvbflags & CRT2_LCD))) &&
@@ -1904 +1596,2 @@
-	    	refresh_rate = 60;
+		/* Slave modes on LVDS and 301B-DH */
+		refresh_rate = 60;
@@ -1906,3 +1599,4 @@
-	} else if( (ivideo->current_htotal == htotal) &&	/* x=x & y=y & c=c -> assume depth change */
-	    	   (ivideo->current_vtotal == vtotal) &&
-	    	   (ivideo->current_pixclock == pixclock) ) {
+	} else if( (ivideo->current_htotal == htotal) &&
+		   (ivideo->current_vtotal == vtotal) &&
+		   (ivideo->current_pixclock == pixclock) ) {
+		/* x=x & y=y & c=c -> assume depth change */
@@ -1910,5 +1604,6 @@
-	        hrate = (drate * 1000) / htotal;
-	        refresh_rate = (unsigned int) (hrate * 2 / vtotal);
-	} else if( ( (ivideo->current_htotal != htotal) ||	/* x!=x | y!=y & c=c -> invalid pixclock */
-	    	     (ivideo->current_vtotal != vtotal) ) &&
-	    	   (ivideo->current_pixclock == var->pixclock) ) {
+		hrate = (drate * 1000) / htotal;
+		refresh_rate = (unsigned int) (hrate * 2 / vtotal);
+	} else if( ( (ivideo->current_htotal != htotal) ||
+		     (ivideo->current_vtotal != vtotal) ) &&
+		   (ivideo->current_pixclock == var->pixclock) ) {
+		/* x!=x | y!=y & c=c -> invalid pixclock */
@@ -1916 +1611,2 @@
-			refresh_rate = ivideo->sisfb_lastrates[sisbios_mode[search_idx].mode_no[ivideo->mni]];
+			refresh_rate =
+				ivideo->sisfb_lastrates[sisbios_mode[search_idx].mode_no[ivideo->mni]];
@@ -1926,2 +1622,2 @@
-	   	hrate = (drate * 1000) / htotal;
-	   	refresh_rate = (unsigned int) (hrate * 2 / vtotal);
+		hrate = (drate * 1000) / htotal;
+		refresh_rate = (unsigned int) (hrate * 2 / vtotal);
@@ -1940,3 +1636,2 @@
-	   if(!myrateindex) myrateindex = sisbios_mode[search_idx].rate_idx;
-	   var->pixclock = (u32) (1000000000 / sisfb_mode_rate_to_dclock(&ivideo->SiS_Pr,
-	   					&ivideo->sishw_ext,
+		if(!myrateindex) myrateindex = sisbios_mode[search_idx].rate_idx;
+		var->pixclock = (u32) (1000000000 / sisfb_mode_rate_to_dclock(&ivideo->SiS_Pr,
@@ -1945,5 +1640,6 @@
-	   sisfb_mode_rate_to_ddata(&ivideo->SiS_Pr, &ivideo->sishw_ext,
-		 		    sisbios_mode[search_idx].mode_no[ivideo->mni], myrateindex,	var);
-	   if((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {
-	      var->pixclock <<= 1;
-	   }
+		sisfb_mode_rate_to_ddata(&ivideo->SiS_Pr,
+					sisbios_mode[search_idx].mode_no[ivideo->mni],
+					myrateindex, var);
+		if((var->vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {
+			var->pixclock <<= 1;
+		}
@@ -1953,4 +1649,5 @@
-	   if(!sisfb_verify_rate(ivideo, &ivideo->sisfb_thismonitor, search_idx,
-	                         myrateindex, refresh_rate)) {
-	      printk(KERN_INFO "sisfb: WARNING: Refresh rate exceeds monitor specs!\n");
-	   }
+		if(!sisfb_verify_rate(ivideo, &ivideo->sisfb_thismonitor, search_idx,
+				myrateindex, refresh_rate)) {
+			printk(KERN_INFO
+				"sisfb: WARNING: Refresh rate exceeds monitor specs!\n");
+		}
@@ -1961 +1658 @@
-	
+
@@ -1966,3 +1663,2 @@
-	if(var->xres > var->xres_virtual) {
-	   var->xres_virtual = var->xres;
-	}
+	if(var->xres > var->xres_virtual)
+		var->xres_virtual = var->xres;
@@ -1971,11 +1667,11 @@
-	   maxyres = sisfb_calc_maxyres(ivideo, var);
-	   if(ivideo->sisfb_max) {
-	      var->yres_virtual = maxyres;
-	   } else {
-	      if(var->yres_virtual > maxyres) {
-	         var->yres_virtual = maxyres;
-	      }
-	   }
-	   if(var->yres_virtual <= var->yres) {
-	      var->yres_virtual = var->yres;
-	   }
+		maxyres = sisfb_calc_maxyres(ivideo, var);
+		if(ivideo->sisfb_max) {
+			var->yres_virtual = maxyres;
+		} else {
+			if(var->yres_virtual > maxyres) {
+				var->yres_virtual = maxyres;
+			}
+		}
+		if(var->yres_virtual <= var->yres) {
+			var->yres_virtual = var->yres;
+		}
@@ -1983,5 +1679,5 @@
-	   if(var->yres != var->yres_virtual) {
-	      var->yres_virtual = var->yres;
-	   }
-	   var->xoffset = 0;
-	   var->yoffset = 0;
+		if(var->yres != var->yres_virtual) {
+			var->yres_virtual = var->yres;
+		}
+		var->xoffset = 0;
+		var->yoffset = 0;
@@ -1989 +1685 @@
-	
+
@@ -1992 +1688 @@
-	   var->xoffset = var->xres_virtual - var->xres - 1;
+		var->xoffset = var->xres_virtual - var->xres - 1;
@@ -1996 +1692 @@
-	   var->yoffset = var->yres_virtual - var->yres - 1;
+		var->yoffset = var->yres_virtual - var->yres - 1;
@@ -1998 +1694 @@
-	
+
@@ -2000,6 +1696,6 @@
-	var->red.msb_right = 
-	var->green.msb_right =
-	var->blue.msb_right =
-	var->transp.offset =
-	var->transp.length =
-	var->transp.msb_right = 0;
+	var->red.msb_right =
+		var->green.msb_right =
+		var->blue.msb_right =
+		var->transp.offset =
+		var->transp.length =
+		var->transp.msb_right = 0;
@@ -2016 +1712 @@
-	if(var->xoffset > (var->xres_virtual - var->xres)) {
+	if(var->xoffset > (var->xres_virtual - var->xres))
@@ -2018,2 +1714,2 @@
-	}
-	if(var->yoffset > (var->yres_virtual - var->yres)) {
+
+	if(var->yoffset > (var->yres_virtual - var->yres))
@@ -2021 +1716,0 @@
-	}
@@ -2023 +1718,2 @@
-	if(var->vmode & FB_VMODE_YWRAP) return -EINVAL;
+	if(var->vmode & FB_VMODE_YWRAP)
+		return -EINVAL;
@@ -2026 +1722 @@
-	   var->yoffset + info->var.yres > info->var.yres_virtual) {
+	   var->yoffset + info->var.yres > info->var.yres_virtual)
@@ -2028 +1723,0 @@
-	}
@@ -2030 +1725,2 @@
-	if((err = sisfb_pan_var(ivideo, var)) < 0) return err;
+	if((err = sisfb_pan_var(ivideo, var)) < 0)
+		return err;
@@ -2043 +1739 @@
-	return(sisfb_myblank(ivideo, blank));
+	return sisfb_myblank(ivideo, blank);
@@ -2059,3 +1755,2 @@
-	struct sis_memreq 	sismemreq;
-	struct fb_vblank  	sisvbblank;
-	sisfb_info        	x;
+	struct sis_memreq	sismemreq;
+	struct fb_vblank	sisvbblank;
@@ -2068 +1763 @@
-	switch (cmd) {
+	switch(cmd) {
@@ -2070 +1765 @@
-		if(!capable(CAP_SYS_RAWIO)) {
+		if(!capable(CAP_SYS_RAWIO))
@@ -2072,4 +1767,4 @@
-		}
-		if(copy_from_user(&sismemreq, (void __user *)arg, sizeof(sismemreq))) {
-		   	return -EFAULT;
-		}
+
+		if(copy_from_user(&sismemreq, (void __user *)arg, sizeof(sismemreq)))
+			return -EFAULT;
+
@@ -2076,0 +1772 @@
+
@@ -2079 +1775 @@
-		    	return -EFAULT;
+			return -EFAULT;
@@ -2084 +1780 @@
-		if(!capable(CAP_SYS_RAWIO)) {
+		if(!capable(CAP_SYS_RAWIO))
@@ -2086,2 +1782,2 @@
-		}
-		if(get_user(gpu32, argp)) {
+
+		if(get_user(gpu32, argp))
@@ -2089 +1785 @@
-		}
+
@@ -2096 +1792,2 @@
-		if(copy_to_user((void __user *)arg, &sisvbblank, sizeof(sisvbblank))) {
+
+		if(copy_to_user((void __user *)arg, &sisvbblank, sizeof(sisvbblank)))
@@ -2098 +1795 @@
-		}
+
@@ -2102 +1799 @@
-	        return put_user(sizeof(sisfb_info), argp);
+		return put_user(sizeof(struct sisfb_info), argp);
@@ -2105,3 +1802,3 @@
-	        if(ivideo->warncount++ < 50) {
-	           printk(KERN_INFO "sisfb: Deprecated ioctl call received - update your application!\n");
-		}
+		if(ivideo->warncount++ < 10)
+			printk(KERN_INFO
+				"sisfb: Deprecated ioctl call received - update your application!\n");
@@ -2109,7 +1806,8 @@
-		x.sisfb_id         = SISFB_ID;
-		x.sisfb_version    = VER_MAJOR;
-		x.sisfb_revision   = VER_MINOR;
-		x.sisfb_patchlevel = VER_LEVEL;
-		x.chip_id = ivideo->chip_id;
-		x.memory = ivideo->video_size / 1024;
-		x.heapstart = ivideo->heapstart / 1024;
+		ivideo->sisfb_infoblock.sisfb_id         = SISFB_ID;
+		ivideo->sisfb_infoblock.sisfb_version    = VER_MAJOR;
+		ivideo->sisfb_infoblock.sisfb_revision   = VER_MINOR;
+		ivideo->sisfb_infoblock.sisfb_patchlevel = VER_LEVEL;
+		ivideo->sisfb_infoblock.chip_id = ivideo->chip_id;
+		ivideo->sisfb_infoblock.sisfb_pci_vendor = ivideo->chip_vendor;
+		ivideo->sisfb_infoblock.memory = ivideo->video_size / 1024;
+		ivideo->sisfb_infoblock.heapstart = ivideo->heapstart / 1024;
@@ -2117 +1815 @@
-		   x.fbvidmode = ivideo->mode_no;
+			ivideo->sisfb_infoblock.fbvidmode = ivideo->mode_no;
@@ -2119 +1817 @@
-		   x.fbvidmode = ivideo->modeprechange;
+			ivideo->sisfb_infoblock.fbvidmode = ivideo->modeprechange;
@@ -2121,20 +1819,28 @@
-		x.sisfb_caps = ivideo->caps;
-		x.sisfb_tqlen = 512; /* yet fixed */
-		x.sisfb_pcibus = ivideo->pcibus;
-		x.sisfb_pcislot = ivideo->pcislot;
-		x.sisfb_pcifunc = ivideo->pcifunc;
-		x.sisfb_lcdpdc = ivideo->detectedpdc;
-		x.sisfb_lcdpdca = ivideo->detectedpdca;
-		x.sisfb_lcda = ivideo->detectedlcda;
-		x.sisfb_vbflags = ivideo->vbflags;
-		x.sisfb_currentvbflags = ivideo->currentvbflags;
-		x.sisfb_scalelcd = ivideo->SiS_Pr.UsePanelScaler;
-		x.sisfb_specialtiming = ivideo->SiS_Pr.SiS_CustomT;
-		x.sisfb_haveemi = ivideo->SiS_Pr.HaveEMI ? 1 : 0;
-		x.sisfb_haveemilcd = ivideo->SiS_Pr.HaveEMILCD ? 1 : 0;
-		x.sisfb_emi30 = ivideo->SiS_Pr.EMI_30;
-		x.sisfb_emi31 = ivideo->SiS_Pr.EMI_31;
-		x.sisfb_emi32 = ivideo->SiS_Pr.EMI_32;
-		x.sisfb_emi33 = ivideo->SiS_Pr.EMI_33;
-		x.sisfb_tvxpos = (u16)(ivideo->tvxpos + 32);
-		x.sisfb_tvypos = (u16)(ivideo->tvypos + 32);
+		ivideo->sisfb_infoblock.sisfb_caps = ivideo->caps;
+		ivideo->sisfb_infoblock.sisfb_tqlen = ivideo->cmdQueueSize / 1024;
+		ivideo->sisfb_infoblock.sisfb_pcibus = ivideo->pcibus;
+		ivideo->sisfb_infoblock.sisfb_pcislot = ivideo->pcislot;
+		ivideo->sisfb_infoblock.sisfb_pcifunc = ivideo->pcifunc;
+		ivideo->sisfb_infoblock.sisfb_lcdpdc = ivideo->detectedpdc;
+		ivideo->sisfb_infoblock.sisfb_lcdpdca = ivideo->detectedpdca;
+		ivideo->sisfb_infoblock.sisfb_lcda = ivideo->detectedlcda;
+		ivideo->sisfb_infoblock.sisfb_vbflags = ivideo->vbflags;
+		ivideo->sisfb_infoblock.sisfb_currentvbflags = ivideo->currentvbflags;
+		ivideo->sisfb_infoblock.sisfb_scalelcd = ivideo->SiS_Pr.UsePanelScaler;
+		ivideo->sisfb_infoblock.sisfb_specialtiming = ivideo->SiS_Pr.SiS_CustomT;
+		ivideo->sisfb_infoblock.sisfb_haveemi = ivideo->SiS_Pr.HaveEMI ? 1 : 0;
+		ivideo->sisfb_infoblock.sisfb_haveemilcd = ivideo->SiS_Pr.HaveEMILCD ? 1 : 0;
+		ivideo->sisfb_infoblock.sisfb_emi30 = ivideo->SiS_Pr.EMI_30;
+		ivideo->sisfb_infoblock.sisfb_emi31 = ivideo->SiS_Pr.EMI_31;
+		ivideo->sisfb_infoblock.sisfb_emi32 = ivideo->SiS_Pr.EMI_32;
+		ivideo->sisfb_infoblock.sisfb_emi33 = ivideo->SiS_Pr.EMI_33;
+		ivideo->sisfb_infoblock.sisfb_tvxpos = (u16)(ivideo->tvxpos + 32);
+		ivideo->sisfb_infoblock.sisfb_tvypos = (u16)(ivideo->tvypos + 32);
+		ivideo->sisfb_infoblock.sisfb_heapsize = ivideo->sisfb_heap_size / 1024;
+		ivideo->sisfb_infoblock.sisfb_videooffset = ivideo->video_offset;
+		ivideo->sisfb_infoblock.sisfb_curfstn = ivideo->curFSTN;
+		ivideo->sisfb_infoblock.sisfb_curdstn = ivideo->curDSTN;
+		ivideo->sisfb_infoblock.sisfb_vbflags2 = ivideo->vbflags2;
+		ivideo->sisfb_infoblock.sisfb_can_post = ivideo->sisfb_can_post ? 1 : 0;
+		ivideo->sisfb_infoblock.sisfb_card_posted = ivideo->sisfb_card_posted ? 1 : 0;
+		ivideo->sisfb_infoblock.sisfb_was_boot_device = ivideo->sisfb_was_boot_device ? 1 : 0;
@@ -2142 +1848,2 @@
-		if(copy_to_user((void __user *)arg, &x, sizeof(x))) {
+		if(copy_to_user((void __user *)arg, &ivideo->sisfb_infoblock,
+						sizeof(ivideo->sisfb_infoblock)))
@@ -2144 +1851 @@
-		}
+
@@ -2148,3 +1855,3 @@
-	   	if(ivideo->warncount++ < 50) {
-	           printk(KERN_INFO "sisfb: Deprecated ioctl call received - update your application!\n");
-		}
+		if(ivideo->warncount++ < 10)
+			printk(KERN_INFO
+				"sisfb: Deprecated ioctl call received - update your application!\n");
@@ -2152 +1859 @@
-	        if(sisfb_CheckVBRetrace(ivideo)) {
+		if(sisfb_CheckVBRetrace(ivideo))
@@ -2154 +1861 @@
-		} else {
+		else
@@ -2156 +1862,0 @@
-		}
@@ -2159,3 +1865,3 @@
-	   	if(ivideo->warncount++ < 50) {
-	           printk(KERN_INFO "sisfb: Deprecated ioctl call received - update your application!\n");
-		}
+		if(ivideo->warncount++ < 10)
+			printk(KERN_INFO
+				"sisfb: Deprecated ioctl call received - update your application!\n");
@@ -2163,2 +1869,4 @@
-	        if(ivideo->sisfb_max)	return put_user((u32)1, argp);
-		else			return put_user((u32)0, argp);
+		if(ivideo->sisfb_max)
+			return put_user((u32)1, argp);
+		else
+			return put_user((u32)0, argp);
@@ -2167,3 +1875,3 @@
-	   	if(ivideo->warncount++ < 50) {
-		   printk(KERN_INFO "sisfb: Deprecated ioctl call received - update your application!\n");
-		}
+		if(ivideo->warncount++ < 10)
+			printk(KERN_INFO
+				"sisfb: Deprecated ioctl call received - update your application!\n");
@@ -2171 +1879 @@
-		if(copy_from_user(&gpu32, argp, sizeof(gpu32))) {
+		if(get_user(gpu32, argp))
@@ -2173 +1881 @@
-		}
+
@@ -2178 +1886 @@
-		if(copy_from_user(&gpu32, argp, sizeof(gpu32))) {
+		if(get_user(gpu32, argp))
@@ -2180 +1888 @@
-		}
+
@@ -2186,2 +1894,15 @@
-	        return put_user((u32)(((ivideo->tvxpos+32)<<16)|((ivideo->tvypos+32)&0xffff)),
-				argp);
+		return put_user((u32)(((ivideo->tvxpos+32)<<16)|((ivideo->tvypos+32)&0xffff)),
+							argp);
+
+	   case SISFB_COMMAND:
+		if(copy_from_user(&ivideo->sisfb_command, (void __user *)arg,
+							sizeof(struct sisfb_cmd)))
+			return -EFAULT;
+
+		sisfb_handle_command(ivideo, &ivideo->sisfb_command);
+
+		if(copy_to_user((void __user *)arg, &ivideo->sisfb_command,
+							sizeof(struct sisfb_cmd)))
+			return -EFAULT;
+
+		break;
@@ -2190 +1911 @@
-		if(copy_from_user(&gpu32, argp, sizeof(gpu32))) {
+		if(get_user(gpu32, argp))
@@ -2192 +1913 @@
-		}
+
@@ -2196,0 +1918 @@
+#ifdef SIS_NEW_CONFIG_COMPAT
@@ -2197,0 +1920,3 @@
+#else
+		return -EINVAL;
+#endif
@@ -2202,2 +1927,3 @@
-#ifdef CONFIG_COMPAT
-static long sisfb_compat_ioctl(struct file *f, unsigned cmd, unsigned long arg, struct fb_info *info)
+#ifdef SIS_NEW_CONFIG_COMPAT
+static long
+sisfb_compat_ioctl(struct file *f, unsigned int cmd, unsigned long arg, struct fb_info *info)
@@ -2205,0 +1932 @@
+
@@ -2222 +1949 @@
-	fix->smem_start  = ivideo->video_base;
+	fix->smem_start  = ivideo->video_base + ivideo->video_offset;
@@ -2234,3 +1961,9 @@
-	   fix->accel    = FB_ACCEL_SIS_GLAMOUR;
-	} else if((ivideo->chip == SIS_330) || (ivideo->chip == SIS_760)) {
-	   fix->accel    = FB_ACCEL_SIS_XABRE;
+		fix->accel = FB_ACCEL_SIS_GLAMOUR;
+	} else if((ivideo->chip == SIS_330) ||
+		  (ivideo->chip == SIS_760) ||
+		  (ivideo->chip == SIS_761)) {
+		fix->accel = FB_ACCEL_SIS_XABRE;
+	} else if(ivideo->chip == XGI_20) {
+		fix->accel = FB_ACCEL_XGI_VOLARI_Z;
+	} else if(ivideo->chip >= XGI_40) {
+		fix->accel = FB_ACCEL_XGI_VOLARI_V;
@@ -2238 +1971 @@
-	   fix->accel    = FB_ACCEL_SIS_GLAMOUR_2;
+		fix->accel = FB_ACCEL_SIS_GLAMOUR_2;
@@ -2254 +1987 @@
-        .fb_pan_display = sisfb_pan_display,
+	.fb_pan_display = sisfb_pan_display,
@@ -2261,16 +1994,15 @@
-	.owner          = THIS_MODULE,
-	.fb_open        = sisfb_open,
-	.fb_release     = sisfb_release,
-	.fb_check_var   = sisfb_check_var,
-	.fb_set_par     = sisfb_set_par,
-	.fb_setcolreg   = sisfb_setcolreg,
-        .fb_pan_display = sisfb_pan_display,
-        .fb_blank       = sisfb_blank,
-	.fb_fillrect    = fbcon_sis_fillrect,
-	.fb_copyarea    = fbcon_sis_copyarea,
-	.fb_imageblit   = cfb_imageblit,
-	.fb_cursor      = soft_cursor,
-	.fb_sync        = fbcon_sis_sync,
-	.fb_ioctl       = sisfb_ioctl,
-#ifdef CONFIG_COMPAT
-	.fb_compat_ioctl = sisfb_compat_ioctl,
+	.owner		= THIS_MODULE,
+	.fb_open	= sisfb_open,
+	.fb_release	= sisfb_release,
+	.fb_check_var	= sisfb_check_var,
+	.fb_set_par	= sisfb_set_par,
+	.fb_setcolreg	= sisfb_setcolreg,
+	.fb_pan_display	= sisfb_pan_display,
+	.fb_blank	= sisfb_blank,
+	.fb_fillrect	= fbcon_sis_fillrect,
+	.fb_copyarea	= fbcon_sis_copyarea,
+	.fb_imageblit	= cfb_imageblit,
+	.fb_cursor	= soft_cursor,
+	.fb_sync	= fbcon_sis_sync,
+#ifdef SIS_NEW_CONFIG_COMPAT
+	.fb_compat_ioctl= sisfb_compat_ioctl,
@@ -2277,0 +2010 @@
+	.fb_ioctl	= sisfb_ioctl
@@ -2283 +2016,2 @@
-static struct pci_dev * sisfb_get_northbridge(int basechipid)
+static struct pci_dev * __devinit
+sisfb_get_northbridge(int basechipid)
@@ -2287 +2021 @@
-	const unsigned short nbridgeids[] = {
+	static const unsigned short nbridgeids[] = {
@@ -2295 +2029 @@
-		PCI_DEVICE_ID_SI_661,	/* for SiS 661/741/660/760 VGA */
+		PCI_DEVICE_ID_SI_661,	/* for SiS 661/741/660/760/761 VGA */
@@ -2298 +2032,2 @@
-		PCI_DEVICE_ID_SI_760
+		PCI_DEVICE_ID_SI_760,
+		PCI_DEVICE_ID_SI_761
@@ -2301 +2036 @@
-    	switch(basechipid) {
+	switch(basechipid) {
@@ -2309 +2044 @@
-	case SIS_660:	nbridgeidx = 7; nbridgenum = 4; break;
+	case SIS_660:	nbridgeidx = 7; nbridgenum = 5; break;
@@ -2314 +2049,3 @@
-		if((pdev = pci_find_device(PCI_VENDOR_ID_SI, nbridgeids[nbridgeidx+i], NULL))) break;
+		if((pdev = SIS_PCI_GET_DEVICE(PCI_VENDOR_ID_SI,
+				nbridgeids[nbridgeidx+i], NULL)))
+			break;
@@ -2319 +2056,2 @@
-static int __devinit sisfb_get_dram_size(struct sis_video_info *ivideo)
+static int __devinit
+sisfb_get_dram_size(struct sis_video_info *ivideo)
@@ -2325,0 +2064 @@
+	ivideo->UMAsize = ivideo->LFBsize = 0;
@@ -2330 +2069 @@
-	        inSISIDXREG(SISSR, 0x14, reg);
+		inSISIDXREG(SISSR, 0x14, reg);
@@ -2336,2 +2075,3 @@
-	   	if(!ivideo->nbridge) return -1;
-	   	pci_read_config_byte(ivideo->nbridge, 0x63, &reg);
+		if(!ivideo->nbridge)
+			return -1;
+		pci_read_config_byte(ivideo->nbridge, 0x63, &reg);
@@ -2345 +2085 @@
-	   	inSISIDXREG(SISSR, 0x14, reg);
+		inSISIDXREG(SISSR, 0x14, reg);
@@ -2350,2 +2090,2 @@
-		   ivideo->video_size <<= 1;
-		   break;
+			ivideo->video_size <<= 1;
+			break;
@@ -2353 +2093 @@
-		   ivideo->video_size += (ivideo->video_size/2);
+			ivideo->video_size += (ivideo->video_size/2);
@@ -2355 +2095 @@
-	   	break;
+		break;
@@ -2357 +2097 @@
-	   	inSISIDXREG(SISSR, 0x14, reg);
+		inSISIDXREG(SISSR, 0x14, reg);
@@ -2360 +2100 @@
-	   	break;
+		break;
@@ -2364 +2104 @@
-	    	inSISIDXREG(SISSR, 0x14, reg);
+		inSISIDXREG(SISSR, 0x14, reg);
@@ -2369 +2109 @@
-	     	inSISIDXREG(SISCR, 0x79, reg);
+		inSISIDXREG(SISCR, 0x79, reg);
@@ -2371 +2111 @@
-	   	break;
+		break;
@@ -2373,0 +2114 @@
+	case SIS_761:
@@ -2376 +2117,4 @@
-		if(reg)	ivideo->video_size = (1 << reg) << 20;
+		if(reg)	{
+			ivideo->video_size = (1 << reg) << 20;
+			ivideo->UMAsize = ivideo->video_size;
+		}
@@ -2380,2 +2124,6 @@
-		   if(reg == 0x10) ivideo->video_size += (32 << 20);
-		   else		   ivideo->video_size += (64 << 20);
+			if(reg == 0x10) {
+				ivideo->LFBsize = (32 << 20);
+			} else {
+				ivideo->LFBsize = (64 << 20);
+			}
+			ivideo->video_size += ivideo->LFBsize;
@@ -2383 +2131,16 @@
-	   	break;
+		break;
+	case SIS_340:
+	case XGI_20:
+	case XGI_40:
+		inSISIDXREG(SISSR, 0x14, reg);
+		ivideo->video_size = (1 << ((reg & 0xf0) >> 4)) << 20;
+		if(ivideo->chip != XGI_20) {
+			reg = (reg & 0x0c) >> 2;
+			if(ivideo->revision_id == 2) {
+				if(reg & 0x01) reg = 0x02;
+				else	       reg = 0x00;
+			}
+			if(reg == 0x02)		ivideo->video_size <<= 1;
+			else if(reg == 0x03)	ivideo->video_size <<= 2;
+		}
+		break;
@@ -2393 +2156,2 @@
-static void __devinit sisfb_detect_VB_connect(struct sis_video_info *ivideo)
+static void __devinit
+sisfb_detect_VB_connect(struct sis_video_info *ivideo)
@@ -2396,0 +2161,6 @@
+	/* No CRT2 on XGI Z7 */
+	if(ivideo->chip == XGI_20) {
+		ivideo->sisfb_crt1off = 0;
+		return;
+	}
+
@@ -2403 +2173 @@
-		   		inSISIDXREG(SISSR, 0x16, temp);
+				inSISIDXREG(SISSR, 0x16, temp);
@@ -2438 +2208 @@
-	       (!(ivideo->vbflags & (VB_301C|VB_301LV|VB_302LV))) ) {
+	       (!(ivideo->vbflags2 & VB2_SISYPBPRBRIDGE)) ) {
@@ -2440 +2210 @@
-	         ivideo->sisfb_tvplug = -1;
+		 ivideo->sisfb_tvplug = -1;
@@ -2447 +2217 @@
-	       (!(ivideo->vbflags & (VB_301|VB_301B|VB_302B))) ) {
+	       (!(ivideo->vbflags2 & VB2_SISHIVISIONBRIDGE)) ) {
@@ -2449 +2219 @@
-	         ivideo->sisfb_tvplug = -1;
+		 ivideo->sisfb_tvplug = -1;
@@ -2455,2 +2225,3 @@
-	   if( (!(ivideo->vbflags & VB_SISBRIDGE)) &&
-	       (!((ivideo->sisvga_engine == SIS_315_VGA) && (ivideo->vbflags & VB_CHRONTEL))) ) {
+	   if( (!(ivideo->vbflags2 & VB2_SISBRIDGE)) &&
+	       (!((ivideo->sisvga_engine == SIS_315_VGA) &&
+			(ivideo->vbflags2 & VB2_CHRONTEL))) ) {
@@ -2458,2 +2229,2 @@
-	         ivideo->sisfb_tvstd = -1;
-	         printk(KERN_ERR "sisfb: PALM/PALN/NTSCJ not supported\n");
+		 ivideo->sisfb_tvstd = -1;
+		 printk(KERN_ERR "sisfb: PALM/PALN/NTSCJ not supported\n");
@@ -2471 +2242 @@
-	 	else {
+		else {
@@ -2488 +2259 @@
-	        	inSISIDXREG(SISSR, 0x38, temp);
+			inSISIDXREG(SISSR, 0x38, temp);
@@ -2492 +2263 @@
-                	inSISIDXREG(SISSR, 0x38, temp);
+			inSISIDXREG(SISSR, 0x38, temp);
@@ -2495,2 +2266,2 @@
-	    	} else {
-	        	inSISIDXREG(SISCR, 0x79, temp);
+		} else {
+			inSISIDXREG(SISCR, 0x79, temp);
@@ -2499 +2270 @@
-	    	}
+		}
@@ -2504,125 +2275,2 @@
-    	if(ivideo->sisfb_forcecrt1 != -1) {
-    	   ivideo->sisfb_crt1off = (ivideo->sisfb_forcecrt1) ? 0 : 1;
-    	}
-}
-
-static void __devinit sisfb_get_VB_type(struct sis_video_info *ivideo)
-{
-	char stdstr[]    = "sisfb: Detected";
-	char bridgestr[] = "video bridge";
-	u8 vb_chipid;
-	u8 reg;
-
-	inSISIDXREG(SISPART4, 0x00, vb_chipid);
-	switch(vb_chipid) {
-	case 0x01:
-		inSISIDXREG(SISPART4, 0x01, reg);
-		if(reg < 0xb0) {
-			ivideo->vbflags |= VB_301;
-			printk(KERN_INFO "%s SiS301 %s\n", stdstr, bridgestr);
-		} else if(reg < 0xc0) {
-		 	ivideo->vbflags |= VB_301B;
-			inSISIDXREG(SISPART4,0x23,reg);
-			if(!(reg & 0x02)) {
-			   ivideo->vbflags |= VB_30xBDH;
-			   printk(KERN_INFO "%s SiS301B-DH %s\n", stdstr, bridgestr);
-			} else {
-			   printk(KERN_INFO "%s SiS301B %s\n", stdstr, bridgestr);
-			}
-		} else if(reg < 0xd0) {
-		 	ivideo->vbflags |= VB_301C;
-			printk(KERN_INFO "%s SiS301C %s\n", stdstr, bridgestr);
-		} else if(reg < 0xe0) {
-			ivideo->vbflags |= VB_301LV;
-			printk(KERN_INFO "%s SiS301LV %s\n", stdstr, bridgestr);
-		} else if(reg <= 0xe1) {
-		        inSISIDXREG(SISPART4,0x39,reg);
-			if(reg == 0xff) {
-			   ivideo->vbflags |= VB_302LV;
-			   printk(KERN_INFO "%s SiS302LV %s\n", stdstr, bridgestr);
-			} else {
-			   ivideo->vbflags |= VB_301C;
-			   printk(KERN_INFO "%s SiS301C(P4) %s\n", stdstr, bridgestr);
-#if 0
-			   ivideo->vbflags |= VB_302ELV;
-			   printk(KERN_INFO "%s SiS302ELV %s\n", stdstr, bridgestr);
-#endif
-			}
-		}
-		break;
-	case 0x02:
-		ivideo->vbflags |= VB_302B;
-		printk(KERN_INFO "%s SiS302B %s\n", stdstr, bridgestr);
-		break;
-	}
-
-	if((!(ivideo->vbflags & VB_VIDEOBRIDGE)) && (ivideo->chip != SIS_300)) {
-		inSISIDXREG(SISCR, 0x37, reg);
-		reg &= SIS_EXTERNAL_CHIP_MASK;
-		reg >>= 1;
-		if(ivideo->sisvga_engine == SIS_300_VGA) {
-#ifdef CONFIG_FB_SIS_300
-			switch(reg) {
-			   case SIS_EXTERNAL_CHIP_LVDS:
-				ivideo->vbflags |= VB_LVDS;
-				break;
-			   case SIS_EXTERNAL_CHIP_TRUMPION:
-				ivideo->vbflags |= VB_TRUMPION;
-				break;
-			   case SIS_EXTERNAL_CHIP_CHRONTEL:
-				ivideo->vbflags |= VB_CHRONTEL;
-				break;
-			   case SIS_EXTERNAL_CHIP_LVDS_CHRONTEL:
-				ivideo->vbflags |= (VB_LVDS | VB_CHRONTEL);
-				break;
-			}
-			if(ivideo->vbflags & VB_CHRONTEL) ivideo->chronteltype = 1;
-#endif
-		} else if(ivideo->chip < SIS_661) {
-#ifdef CONFIG_FB_SIS_315
-			switch (reg) {
-	 	   	   case SIS310_EXTERNAL_CHIP_LVDS:
-				ivideo->vbflags |= VB_LVDS;
-				break;
-		   	   case SIS310_EXTERNAL_CHIP_LVDS_CHRONTEL:
-				ivideo->vbflags |= (VB_LVDS | VB_CHRONTEL);
-				break;
-			}
-			if(ivideo->vbflags & VB_CHRONTEL) ivideo->chronteltype = 2;
-#endif
-		} else if(ivideo->chip >= SIS_661) {
-#ifdef CONFIG_FB_SIS_315
-			inSISIDXREG(SISCR, 0x38, reg);
-			reg >>= 5;
-			switch(reg) {
-			   case 0x02:
-				ivideo->vbflags |= VB_LVDS;
-				break;
-			   case 0x03:
-				ivideo->vbflags |= (VB_LVDS | VB_CHRONTEL);
-				break;
-			   case 0x04:
-				ivideo->vbflags |= (VB_LVDS | VB_CONEXANT);
-				break;
-			}
-			if(ivideo->vbflags & VB_CHRONTEL) ivideo->chronteltype = 2;
-#endif
-		}
-		if(ivideo->vbflags & VB_LVDS) {
-		   printk(KERN_INFO "%s LVDS transmitter\n", stdstr);
-		}
-		if(ivideo->vbflags & VB_TRUMPION) {
-		   printk(KERN_INFO "%s Trumpion Zurac LCD scaler\n", stdstr);
-		}
-		if(ivideo->vbflags & VB_CHRONTEL) {
-		   printk(KERN_INFO "%s Chrontel TV encoder\n", stdstr);
-		}
-		if(ivideo->vbflags & VB_CONEXANT) {
-		   printk(KERN_INFO "%s Conexant external device\n", stdstr);
-		}
-	}
-
-	if(ivideo->vbflags & VB_SISBRIDGE) {
-		SiS_Sense30x(ivideo);
-	} else if(ivideo->vbflags & VB_CHRONTEL) {
-		SiS_SenseCh(ivideo);
+	if(ivideo->sisfb_forcecrt1 != -1) {
+	   ivideo->sisfb_crt1off = (ivideo->sisfb_forcecrt1) ? 0 : 1;
@@ -2634 +2282,2 @@
-static BOOLEAN __devinit sisfb_test_DDC1(struct sis_video_info *ivideo)
+static BOOLEAN __devinit
+sisfb_test_DDC1(struct sis_video_info *ivideo)
@@ -2641 +2290 @@
-       	if(old != SiS_ReadDDC1Bit(&ivideo->SiS_Pr)) break;
+	if(old != SiS_ReadDDC1Bit(&ivideo->SiS_Pr)) break;
@@ -2646 +2295,2 @@
-static void __devinit sisfb_sense_crt1(struct sis_video_info *ivideo)
+static void __devinit
+sisfb_sense_crt1(struct sis_video_info *ivideo)
@@ -2702 +2352,2 @@
-          temp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags, ivideo->sisvga_engine, 0, 0, NULL);
+	  temp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags,
+		ivideo->sisvga_engine, 0, 0, NULL, ivideo->vbflags2);
@@ -2726 +2377,90 @@
-static int __devinit SISDoSense(struct sis_video_info *ivideo, u16 type, u16 test)
+static void __devinit
+SiS_SenseLCD(struct sis_video_info *ivideo)
+{
+	unsigned char buffer[256];
+	unsigned short temp, realcrtno, i;
+	u8 reg, cr37 = 0, paneltype = 0;
+	u16 xres, yres;
+
+	ivideo->SiS_Pr.PanelSelfDetected = FALSE;
+
+	/* LCD detection only for TMDS bridges */
+	if(!(ivideo->vbflags2 & VB2_SISTMDSBRIDGE))
+		return;
+	if(ivideo->vbflags2 & VB2_30xBDH)
+		return;
+
+	/* If LCD already set up by BIOS, skip it */
+	inSISIDXREG(SISCR, 0x32, reg);
+	if(reg & 0x08)
+		return;
+
+	realcrtno = 1;
+	if(ivideo->SiS_Pr.DDCPortMixup)
+		realcrtno = 0;
+
+	/* Check DDC capabilities */
+	temp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags, ivideo->sisvga_engine,
+				realcrtno, 0, &buffer[0], ivideo->vbflags2);
+
+	if((!temp) || (temp == 0xffff) || (!(temp & 0x02)))
+		return;
+
+	/* Read DDC data */
+	i = 3;  /* Number of retrys */
+	do {
+		temp = SiS_HandleDDC(&ivideo->SiS_Pr, ivideo->vbflags,
+				ivideo->sisvga_engine, realcrtno, 1,
+				&buffer[0], ivideo->vbflags2);
+	} while((temp) && i--);
+
+	if(temp)
+		return;
+
+	/* No digital device */
+	if(!(buffer[0x14] & 0x80))
+		return;
+
+	/* First detailed timing preferred timing? */
+	if(!(buffer[0x18] & 0x02))
+		return;
+
+	xres = buffer[0x38] | ((buffer[0x3a] & 0xf0) << 4);
+	yres = buffer[0x3b] | ((buffer[0x3d] & 0xf0) << 4);
+
+	switch(xres) {
+		case 1024:
+			if(yres == 768)
+				paneltype = 0x02;
+			break;
+		case 1280:
+			if(yres == 1024)
+				paneltype = 0x03;
+			break;
+		case 1600:
+			if((yres == 1200) && (ivideo->vbflags2 & VB2_30xC))
+				paneltype = 0x0b;
+			break;
+	}
+
+	if(!paneltype)
+		return;
+
+	if(buffer[0x23])
+		cr37 |= 0x10;
+
+	if((buffer[0x47] & 0x18) == 0x18)
+		cr37 |= ((((buffer[0x47] & 0x06) ^ 0x06) << 5) | 0x20);
+	else
+		cr37 |= 0xc0;
+
+	outSISIDXREG(SISCR, 0x36, paneltype);
+	cr37 &= 0xf1;
+	setSISIDXREG(SISCR, 0x37, 0x0c, cr37);
+	orSISIDXREG(SISCR, 0x32, 0x08);
+
+	ivideo->SiS_Pr.PanelSelfDetected = TRUE;
+}
+
+static int __devinit
+SISDoSense(struct sis_video_info *ivideo, u16 type, u16 test)
@@ -2752 +2492 @@
-    return(result);
+    return result;
@@ -2755 +2495,2 @@
-static void __devinit SiS_Sense30x(struct sis_video_info *ivideo)
+static void __devinit
+SiS_Sense30x(struct sis_video_info *ivideo)
@@ -2765 +2506 @@
-    if(ivideo->vbflags & VB_301) {
+    if(ivideo->vbflags2 & VB2_301) {
@@ -2771 +2512 @@
-    } else if(ivideo->vbflags & (VB_301B | VB_302B)) {
+    } else if(ivideo->vbflags2 & (VB2_301B | VB2_302B)) {
@@ -2773 +2514 @@
-    } else if(ivideo->vbflags & (VB_301LV | VB_302LV)) {
+    } else if(ivideo->vbflags2 & (VB2_301LV | VB2_302LV)) {
@@ -2775 +2516 @@
-    } else if(ivideo->vbflags & (VB_301C | VB_302ELV)) {
+    } else if(ivideo->vbflags2 & (VB2_301C | VB2_302ELV | VB2_307T | VB2_307LV)) {
@@ -2777 +2518,2 @@
-    } else return;
+    } else
+       return;
@@ -2780 +2522 @@
-    if(ivideo->vbflags & (VB_301LV|VB_302LV|VB_302ELV)) {
+    if(ivideo->vbflags & (VB2_301LV|VB2_302LV|VB2_302ELV|VB2_307LV)) {
@@ -2782,0 +2525 @@
+
@@ -2783,0 +2527,9 @@
+    if(ivideo->haveXGIROM) {
+       biosflag = ivideo->bios_abase[0x58] & 0x03;
+    } else if(ivideo->newrom) {
+       if(ivideo->bios_abase[0x5d] & 0x04) biosflag |= 0x01;
+    } else if(ivideo->sisvga_engine == SIS_300_VGA) {
+       if(ivideo->bios_abase) {
+          biosflag = ivideo->bios_abase[0xfe] & 0x03;
+       }
+    }
@@ -2789,0 +2542,4 @@
+    if(!(ivideo->vbflags2 & VB2_SISVGA2BRIDGE)) {
+       vga2 = vga2_c = 0;
+    }
+
@@ -2794 +2550 @@
-    if(ivideo->vbflags & VB_301C) {
+    if(ivideo->vbflags2 & VB2_30xC) {
@@ -2805 +2561 @@
-    if(ivideo->vbflags & (VB_301C|VB_301LV|VB_302LV|VB_302ELV)) {
+    if(ivideo->vbflags2 & VB2_SISYPBPRBRIDGE) {
@@ -2809 +2565 @@
-    if(!(ivideo->vbflags & VB_301C)) {
+    if(!(ivideo->vbflags2 & VB2_30xCLV)) {
@@ -2829 +2585 @@
-    if(ivideo->vbflags & VB_301C) {
+    if(ivideo->vbflags2 & VB2_30xCLV) {
@@ -2833,2 +2589 @@
-    if((ivideo->sisvga_engine == SIS_315_VGA) &&
-       (ivideo->vbflags & (VB_301C|VB_301LV|VB_302LV|VB_302ELV))) {
+    if((ivideo->sisvga_engine == SIS_315_VGA) && (ivideo->vbflags2 & VB2_SISYPBPRBRIDGE)) {
@@ -2867 +2622 @@
-    if(ivideo->vbflags & VB_301C) {
+    if(ivideo->vbflags2 & VB2_30xCLV) {
@@ -2881 +2636,2 @@
-static void __devinit SiS_SenseCh(struct sis_video_info *ivideo)
+static void __devinit
+SiS_SenseCh(struct sis_video_info *ivideo)
@@ -2902 +2658 @@
-	  SiS_SetCH700x(&ivideo->SiS_Pr, 0x0b0e);
+	  SiS_SetCH700x(&ivideo->SiS_Pr, 0x0e, 0x0b);
@@ -2912,2 +2668,2 @@
-     	        /* Power all outputs */
-		SiS_SetCH700x(&ivideo->SiS_Pr, 0x0B0E);
+		/* Power all outputs */
+		SiS_SetCH700x(&ivideo->SiS_Pr, 0x0e,0x0b);
@@ -2918 +2674 @@
-	       SiS_SetCH700x(&ivideo->SiS_Pr, 0x0110);
+	       SiS_SetCH700x(&ivideo->SiS_Pr, 0x10, 0x01);
@@ -2920 +2676 @@
-	       SiS_SetCH700x(&ivideo->SiS_Pr, 0x0010);
+	       SiS_SetCH700x(&ivideo->SiS_Pr, 0x10, 0x00);
@@ -2933 +2689 @@
-	   	printk(KERN_INFO
+		printk(KERN_INFO
@@ -2948 +2704 @@
- 		SiS_SetCH70xxANDOR(&ivideo->SiS_Pr, 0x010E,0xF8);
+		SiS_SetCH70xxANDOR(&ivideo->SiS_Pr, 0x0e, 0x01, 0xF8);
@@ -2952 +2708 @@
-	  SiS_SetCH70xxANDOR(&ivideo->SiS_Pr, 0x010E,0xF8);
+	  SiS_SetCH70xxANDOR(&ivideo->SiS_Pr, 0x0e, 0x01, 0xF8);
@@ -2963,2 +2719,2 @@
-        temp1 = SiS_GetCH701x(&ivideo->SiS_Pr, 0x49);
-	SiS_SetCH701x(&ivideo->SiS_Pr, 0x2049);
+	temp1 = SiS_GetCH701x(&ivideo->SiS_Pr, 0x49);
+	SiS_SetCH701x(&ivideo->SiS_Pr, 0x49, 0x20);
@@ -2968 +2724 @@
-	SiS_SetCH701x(&ivideo->SiS_Pr, (temp2 << 8) | 0x20);
+	SiS_SetCH701x(&ivideo->SiS_Pr, 0x20, temp2);
@@ -2971 +2727 @@
-	SiS_SetCH701x(&ivideo->SiS_Pr, (temp2 << 8) | 0x20);
+	SiS_SetCH701x(&ivideo->SiS_Pr, 0x20, temp2);
@@ -2974,2 +2730,2 @@
-	SiS_SetCH701x(&ivideo->SiS_Pr, (temp1 << 8) | 0x49);
-        temp1 = 0;
+	SiS_SetCH701x(&ivideo->SiS_Pr, 0x49, temp1);
+	temp1 = 0;
@@ -2986 +2742 @@
-             break;
+	     break;
@@ -2992 +2748 @@
-             break;
+	     break;
@@ -2997 +2753 @@
-             break;
+	     break;
@@ -3005,4 +2761,2 @@
-/* ------------------------ Heap routines -------------------------- */
-
-static u32 __devinit
-sisfb_getheapstart(struct sis_video_info *ivideo)
+static void __devinit
+sisfb_get_VB_type(struct sis_video_info *ivideo)
@@ -3010,3 +2764,4 @@
-	u32 ret = ivideo->sisfb_parm_mem * 1024;
-	u32 max = ivideo->video_size - ivideo->hwcursor_size;
-	u32 def;
+	char stdstr[]    = "sisfb: Detected";
+	char bridgestr[] = "video bridge";
+	u8 vb_chipid;
+	u8 reg;
@@ -3014,12 +2769,3 @@
-	/* Calculate heap start = end of memory for console
-	 *
-	 * CCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDHHHHQQQQQQQQQQ
-	 * C = console, D = heap, H = HWCursor, Q = cmd-queue
-	 *
-	 * Basically given by "mem" parameter
-	 *
-	 * maximum = videosize - cmd_queue - hwcursor
-	 *           (results in a heap of size 0)
-	 * default = SiS 300: depends on videosize
-	 *           SiS 315/330: 32k below max
-	 */
+	/* No CRT2 on XGI Z7 */
+	if(ivideo->chip == XGI_20)
+		return;
@@ -3027,12 +2773,50 @@
-	if(ivideo->sisvga_engine == SIS_300_VGA) {
-	   max -= TURBO_QUEUE_AREA_SIZE;
-	   if(ivideo->video_size > 0x1000000) {
-	      def = 0xc00000;
-	   } else if(ivideo->video_size > 0x800000) {
-	      def = 0x800000;
-	   } else {
-	      def = 0x400000;
-	   }
-	} else {
-	   max -= COMMAND_QUEUE_AREA_SIZE;
-	   def = max - 0x8000;
+	inSISIDXREG(SISPART4, 0x00, vb_chipid);
+	switch(vb_chipid) {
+	case 0x01:
+		inSISIDXREG(SISPART4, 0x01, reg);
+		if(reg < 0xb0) {
+			ivideo->vbflags |= VB_301;	/* Deprecated */
+			ivideo->vbflags2 |= VB2_301;
+			printk(KERN_INFO "%s SiS301 %s\n", stdstr, bridgestr);
+		} else if(reg < 0xc0) {
+			ivideo->vbflags |= VB_301B;	/* Deprecated */
+			ivideo->vbflags2 |= VB2_301B;
+			inSISIDXREG(SISPART4,0x23,reg);
+			if(!(reg & 0x02)) {
+			   ivideo->vbflags |= VB_30xBDH;	/* Deprecated */
+			   ivideo->vbflags2 |= VB2_30xBDH;
+			   printk(KERN_INFO "%s SiS301B-DH %s\n", stdstr, bridgestr);
+			} else {
+			   printk(KERN_INFO "%s SiS301B %s\n", stdstr, bridgestr);
+			}
+		} else if(reg < 0xd0) {
+			ivideo->vbflags |= VB_301C;	/* Deprecated */
+			ivideo->vbflags2 |= VB2_301C;
+			printk(KERN_INFO "%s SiS301C %s\n", stdstr, bridgestr);
+		} else if(reg < 0xe0) {
+			ivideo->vbflags |= VB_301LV;	/* Deprecated */
+			ivideo->vbflags2 |= VB2_301LV;
+			printk(KERN_INFO "%s SiS301LV %s\n", stdstr, bridgestr);
+		} else if(reg <= 0xe1) {
+			inSISIDXREG(SISPART4,0x39,reg);
+			if(reg == 0xff) {
+			   ivideo->vbflags |= VB_302LV;	/* Deprecated */
+			   ivideo->vbflags2 |= VB2_302LV;
+			   printk(KERN_INFO "%s SiS302LV %s\n", stdstr, bridgestr);
+			} else {
+			   ivideo->vbflags |= VB_301C;	/* Deprecated */
+			   ivideo->vbflags2 |= VB2_301C;
+			   printk(KERN_INFO "%s SiS301C(P4) %s\n", stdstr, bridgestr);
+#if 0
+			   ivideo->vbflags |= VB_302ELV;	/* Deprecated */
+			   ivideo->vbflags2 |= VB2_302ELV;
+			   printk(KERN_INFO "%s SiS302ELV %s\n", stdstr, bridgestr);
+#endif
+			}
+		}
+		break;
+	case 0x02:
+		ivideo->vbflags |= VB_302B;	/* Deprecated */
+		ivideo->vbflags2 |= VB2_302B;
+		printk(KERN_INFO "%s SiS302B %s\n", stdstr, bridgestr);
+		break;
@@ -3041,3 +2825,74 @@
-        if((!ret) || (ret > max) || (ivideo->cardnumber != 0)) {
-	   ret = def;
-        }
+	if((!(ivideo->vbflags2 & VB2_VIDEOBRIDGE)) && (ivideo->chip != SIS_300)) {
+		inSISIDXREG(SISCR, 0x37, reg);
+		reg &= SIS_EXTERNAL_CHIP_MASK;
+		reg >>= 1;
+		if(ivideo->sisvga_engine == SIS_300_VGA) {
+#ifdef CONFIG_FB_SIS_300
+			switch(reg) {
+			   case SIS_EXTERNAL_CHIP_LVDS:
+				ivideo->vbflags |= VB_LVDS;	/* Deprecated */
+				ivideo->vbflags2 |= VB2_LVDS;
+				break;
+			   case SIS_EXTERNAL_CHIP_TRUMPION:
+				ivideo->vbflags |= (VB_LVDS | VB_TRUMPION);	/* Deprecated */
+				ivideo->vbflags2 |= (VB2_LVDS | VB2_TRUMPION);
+				break;
+			   case SIS_EXTERNAL_CHIP_CHRONTEL:
+				ivideo->vbflags |= VB_CHRONTEL;	/* Deprecated */
+				ivideo->vbflags2 |= VB2_CHRONTEL;
+				break;
+			   case SIS_EXTERNAL_CHIP_LVDS_CHRONTEL:
+				ivideo->vbflags |= (VB_LVDS | VB_CHRONTEL);	/* Deprecated */
+				ivideo->vbflags2 |= (VB2_LVDS | VB2_CHRONTEL);
+				break;
+			}
+			if(ivideo->vbflags2 & VB2_CHRONTEL) ivideo->chronteltype = 1;
+#endif
+		} else if(ivideo->chip < SIS_661) {
+#ifdef CONFIG_FB_SIS_315
+			switch (reg) {
+			   case SIS310_EXTERNAL_CHIP_LVDS:
+				ivideo->vbflags |= VB_LVDS;	/* Deprecated */
+				ivideo->vbflags2 |= VB2_LVDS;
+				break;
+			   case SIS310_EXTERNAL_CHIP_LVDS_CHRONTEL:
+				ivideo->vbflags |= (VB_LVDS | VB_CHRONTEL);	/* Deprecated */
+				ivideo->vbflags2 |= (VB2_LVDS | VB2_CHRONTEL);
+				break;
+			}
+			if(ivideo->vbflags2 & VB2_CHRONTEL) ivideo->chronteltype = 2;
+#endif
+		} else if(ivideo->chip >= SIS_661) {
+#ifdef CONFIG_FB_SIS_315
+			inSISIDXREG(SISCR, 0x38, reg);
+			reg >>= 5;
+			switch(reg) {
+			   case 0x02:
+				ivideo->vbflags |= VB_LVDS;	/* Deprecated */
+				ivideo->vbflags2 |= VB2_LVDS;
+				break;
+			   case 0x03:
+				ivideo->vbflags |= (VB_LVDS | VB_CHRONTEL);	/* Deprecated */
+				ivideo->vbflags2 |= (VB2_LVDS | VB2_CHRONTEL);
+				break;
+			   case 0x04:
+				ivideo->vbflags |= (VB_LVDS | VB_CONEXANT);	/* Deprecated */
+				ivideo->vbflags2 |= (VB2_LVDS | VB2_CONEXANT);
+				break;
+			}
+			if(ivideo->vbflags2 & VB2_CHRONTEL) ivideo->chronteltype = 2;
+#endif
+		}
+		if(ivideo->vbflags2 & VB2_LVDS) {
+		   printk(KERN_INFO "%s LVDS transmitter\n", stdstr);
+		}
+		if((ivideo->sisvga_engine == SIS_300_VGA) && (ivideo->vbflags2 & VB2_TRUMPION)) {
+		   printk(KERN_INFO "%s Trumpion Zurac LCD scaler\n", stdstr);
+		}
+		if(ivideo->vbflags2 & VB2_CHRONTEL) {
+		   printk(KERN_INFO "%s Chrontel TV encoder\n", stdstr);
+		}
+		if((ivideo->chip >= SIS_661) && (ivideo->vbflags2 & VB2_CONEXANT)) {
+		   printk(KERN_INFO "%s Conexant external device\n", stdstr);
+		}
+	}
@@ -3045 +2900,6 @@
-	return ret;
+	if(ivideo->vbflags2 & VB2_SISBRIDGE) {
+		SiS_SenseLCD(ivideo);
+		SiS_Sense30x(ivideo);
+	} else if(ivideo->vbflags2 & VB2_CHRONTEL) {
+		SiS_SenseCh(ivideo);
+	}
@@ -3048,2 +2908,4 @@
-static int __devinit
-sisfb_heap_init(struct sis_video_info *ivideo)
+/* ---------- Engine initialization routines ------------ */
+
+static void
+sisfb_engine_init(struct sis_video_info *ivideo)
@@ -3051 +2912,0 @@
-     SIS_OH *poh;
@@ -3053 +2914,21 @@
-     ivideo->heapstart = ivideo->sisfb_mem = sisfb_getheapstart(ivideo);
+	/* Initialize command queue (we use MMIO only) */
+
+	/* BEFORE THIS IS CALLED, THE ENGINES *MUST* BE SYNC'ED */
+
+	ivideo->caps &= ~(TURBO_QUEUE_CAP    |
+			  MMIO_CMD_QUEUE_CAP |
+			  VM_CMD_QUEUE_CAP   |
+			  AGP_CMD_QUEUE_CAP);
+
+#ifdef CONFIG_FB_SIS_300
+	if(ivideo->sisvga_engine == SIS_300_VGA) {
+		u32 tqueue_pos;
+		u8 tq_state;
+
+		tqueue_pos = (ivideo->video_size - ivideo->cmdQueueSize) / (64 * 1024);
+
+		inSISIDXREG(SISSR, IND_SIS_TURBOQUEUE_SET, tq_state);
+		tq_state |= 0xf0;
+		tq_state &= 0xfc;
+		tq_state |= (u8)(tqueue_pos >> 8);
+		outSISIDXREG(SISSR, IND_SIS_TURBOQUEUE_SET, tq_state);
@@ -3055,2 +2936 @@
-     ivideo->sisfb_heap_start = ivideo->video_vbase + ivideo->heapstart;
-     ivideo->sisfb_heap_end   = ivideo->video_vbase + ivideo->video_size;
+		outSISIDXREG(SISSR, IND_SIS_TURBOQUEUE_ADR, (u8)(tqueue_pos & 0xff));
@@ -3058 +2938,3 @@
-     /* Initialize command queue (We use MMIO only) */
+		ivideo->caps |= TURBO_QUEUE_CAP;
+	}
+#endif
@@ -3061,3 +2943,73 @@
-     if(ivideo->sisvga_engine == SIS_315_VGA) {
-        u32 tempq = 0;
-	u8  temp = 0;
+	if(ivideo->sisvga_engine == SIS_315_VGA) {
+		u32 tempq = 0, templ;
+		u8  temp;
+
+		if(ivideo->chip == XGI_20) {
+			switch(ivideo->cmdQueueSize) {
+			case (64 * 1024):
+				temp = SIS_CMD_QUEUE_SIZE_Z7_64k;
+				break;
+			case (128 * 1024):
+			default:
+				temp = SIS_CMD_QUEUE_SIZE_Z7_128k;
+			}
+		} else {
+			switch(ivideo->cmdQueueSize) {
+			case (4 * 1024 * 1024):
+				temp = SIS_CMD_QUEUE_SIZE_4M;
+				break;
+			case (2 * 1024 * 1024):
+				temp = SIS_CMD_QUEUE_SIZE_2M;
+				break;
+			case (1 * 1024 * 1024):
+				temp = SIS_CMD_QUEUE_SIZE_1M;
+				break;
+			default:
+			case (512 * 1024):
+				temp = SIS_CMD_QUEUE_SIZE_512k;
+			}
+		}
+
+		outSISIDXREG(SISSR, IND_SIS_CMDQUEUE_THRESHOLD, COMMAND_QUEUE_THRESHOLD);
+		outSISIDXREG(SISSR, IND_SIS_CMDQUEUE_SET, SIS_CMD_QUEUE_RESET);
+
+		if((ivideo->chip >= XGI_40) && ivideo->modechanged) {
+			/* Must disable dual pipe on XGI_40. Can't do
+			 * this in MMIO mode, because it requires
+			 * setting/clearing a bit in the MMIO fire trigger
+			 * register.
+			 */
+			if(!((templ = MMIO_IN32(ivideo->mmio_vbase, 0x8240)) & (1 << 10))) {
+
+				MMIO_OUT32(ivideo->mmio_vbase, Q_WRITE_PTR, 0);
+
+				outSISIDXREG(SISSR, IND_SIS_CMDQUEUE_SET, (temp | SIS_VRAM_CMDQUEUE_ENABLE));
+
+				tempq = MMIO_IN32(ivideo->mmio_vbase, Q_READ_PTR);
+				MMIO_OUT32(ivideo->mmio_vbase, Q_WRITE_PTR, tempq);
+
+				tempq = (u32)(ivideo->video_size - ivideo->cmdQueueSize);
+				MMIO_OUT32(ivideo->mmio_vbase, Q_BASE_ADDR, tempq);
+
+				writel(0x16800000 + 0x8240, ivideo->video_vbase + tempq);
+				writel(templ | (1 << 10), ivideo->video_vbase + tempq + 4);
+				writel(0x168F0000, ivideo->video_vbase + tempq + 8);
+				writel(0x168F0000, ivideo->video_vbase + tempq + 12);
+
+				MMIO_OUT32(ivideo->mmio_vbase, Q_WRITE_PTR, (tempq + 16));
+
+				sisfb_syncaccel(ivideo);
+
+				outSISIDXREG(SISSR, IND_SIS_CMDQUEUE_SET, SIS_CMD_QUEUE_RESET);
+
+			}
+		}
+
+		tempq = MMIO_IN32(ivideo->mmio_vbase, MMIO_QUEUE_READPORT);
+		MMIO_OUT32(ivideo->mmio_vbase, MMIO_QUEUE_WRITEPORT, tempq);
+
+		temp |= (SIS_MMIO_CMD_ENABLE | SIS_CMD_AUTO_CORR);
+		outSISIDXREG(SISSR, IND_SIS_CMDQUEUE_SET, temp);
+
+		tempq = (u32)(ivideo->video_size - ivideo->cmdQueueSize);
+		MMIO_OUT32(ivideo->mmio_vbase, MMIO_QUEUE_PHYBASE, tempq);
@@ -3065 +3017,6 @@
-        ivideo->sisfb_heap_end -= COMMAND_QUEUE_AREA_SIZE;
+		ivideo->caps |= MMIO_CMD_QUEUE_CAP;
+	}
+#endif
+
+	ivideo->engineok = 1;
+}
@@ -3067,2 +3024,5 @@
-	outSISIDXREG(SISSR, IND_SIS_CMDQUEUE_THRESHOLD, COMMAND_QUEUE_THRESHOLD);
-	outSISIDXREG(SISSR, IND_SIS_CMDQUEUE_SET, SIS_CMD_QUEUE_RESET);
+static void __devinit
+sisfb_detect_lcd_type(struct sis_video_info *ivideo)
+{
+	u8 reg;
+	int i;
@@ -3070,2 +3030,15 @@
-	tempq = MMIO_IN32(ivideo->mmio_vbase, MMIO_QUEUE_READPORT);
-	MMIO_OUT32(ivideo->mmio_vbase, MMIO_QUEUE_WRITEPORT, tempq);
+	inSISIDXREG(SISCR, 0x36, reg);
+	reg &= 0x0f;
+	if(ivideo->sisvga_engine == SIS_300_VGA) {
+		ivideo->CRT2LCDType = sis300paneltype[reg];
+	} else if(ivideo->chip >= SIS_661) {
+		ivideo->CRT2LCDType = sis661paneltype[reg];
+	} else {
+		ivideo->CRT2LCDType = sis310paneltype[reg];
+		if((ivideo->chip == SIS_550) && (sisfb_fstn)) {
+			if((ivideo->CRT2LCDType != LCD_320x240_2) &&
+			   (ivideo->CRT2LCDType != LCD_320x240_3)) {
+				ivideo->CRT2LCDType = LCD_320x240;
+			}
+		}
+	}
@@ -3073,3 +3046,7 @@
-	temp = SIS_CMD_QUEUE_SIZE_512k;
-	temp |= (SIS_MMIO_CMD_ENABLE | SIS_CMD_AUTO_CORR);
-	outSISIDXREG(SISSR, IND_SIS_CMDQUEUE_SET, temp);
+	if(ivideo->CRT2LCDType == LCD_UNKNOWN) {
+		/* For broken BIOSes: Assume 1024x768, RGB18 */
+		ivideo->CRT2LCDType = LCD_1024x768;
+		setSISIDXREG(SISCR,0x36,0xf0,0x02);
+		setSISIDXREG(SISCR,0x37,0xee,0x01);
+		printk(KERN_DEBUG "sisfb: Invalid panel ID (%02x), assuming 1024x768, RGB18\n", reg);
+	}
@@ -3077,2 +3054,8 @@
-	tempq = (u32)(ivideo->video_size - COMMAND_QUEUE_AREA_SIZE);
-	MMIO_OUT32(ivideo->mmio_vbase, MMIO_QUEUE_PHYBASE, tempq);
+	for(i = 0; i < SIS_LCD_NUMBER; i++) {
+		if(ivideo->CRT2LCDType == sis_lcd_data[i].lcdtype) {
+			ivideo->lcdxres = sis_lcd_data[i].xres;
+			ivideo->lcdyres = sis_lcd_data[i].yres;
+			ivideo->lcddefmodeidx = sis_lcd_data[i].default_mode_idx;
+			break;
+		}
+	}
@@ -3080,2 +3063,11 @@
-	ivideo->caps |= MMIO_CMD_QUEUE_CAP;
-     }
+#ifdef CONFIG_FB_SIS_300
+	if(ivideo->SiS_Pr.SiS_CustomT == CUT_BARCO1366) {
+		ivideo->lcdxres = 1360; ivideo->lcdyres = 1024;
+		ivideo->lcddefmodeidx = DEFAULT_MODE_1360;
+	} else if(ivideo->SiS_Pr.SiS_CustomT == CUT_PANEL848) {
+		ivideo->lcdxres =  848; ivideo->lcdyres =  480;
+		ivideo->lcddefmodeidx = DEFAULT_MODE_848;
+	} else if(ivideo->SiS_Pr.SiS_CustomT == CUT_PANEL856) {
+		ivideo->lcdxres =  856; ivideo->lcdyres =  480;
+		ivideo->lcddefmodeidx = DEFAULT_MODE_856;
+	}
@@ -3083,0 +3076,7 @@
+	printk(KERN_DEBUG "sisfb: Detected %dx%d flat panel\n",
+			ivideo->lcdxres, ivideo->lcdyres);
+}
+
+static void __devinit
+sisfb_save_pdc_emi(struct sis_video_info *ivideo)
+{
@@ -3085,3 +3084,27 @@
-     if(ivideo->sisvga_engine == SIS_300_VGA) {
-     	unsigned long tqueue_pos;
-	u8 tq_state;
+	/* Save the current PanelDelayCompensation if the LCD is currently used */
+	if(ivideo->sisvga_engine == SIS_300_VGA) {
+		if(ivideo->vbflags2 & (VB2_LVDS | VB2_30xBDH)) {
+			int tmp;
+			inSISIDXREG(SISCR,0x30,tmp);
+			if(tmp & 0x20) {
+				/* Currently on LCD? If yes, read current pdc */
+				inSISIDXREG(SISPART1,0x13,ivideo->detectedpdc);
+				ivideo->detectedpdc &= 0x3c;
+				if(ivideo->SiS_Pr.PDC == -1) {
+					/* Let option override detection */
+					ivideo->SiS_Pr.PDC = ivideo->detectedpdc;
+				}
+				printk(KERN_INFO "sisfb: Detected LCD PDC 0x%02x\n",
+					ivideo->detectedpdc);
+			}
+			if((ivideo->SiS_Pr.PDC != -1) &&
+			   (ivideo->SiS_Pr.PDC != ivideo->detectedpdc)) {
+				printk(KERN_INFO "sisfb: Using LCD PDC 0x%02x\n",
+					ivideo->SiS_Pr.PDC);
+			}
+		}
+	}
+#endif
+
+#ifdef CONFIG_FB_SIS_315
+	if(ivideo->sisvga_engine == SIS_315_VGA) {
@@ -3089 +3112,9 @@
-	ivideo->sisfb_heap_end -= TURBO_QUEUE_AREA_SIZE;
+		/* Try to find about LCDA */
+		if(ivideo->vbflags2 & VB2_SISLCDABRIDGE) {
+			int tmp;
+			inSISIDXREG(SISPART1,0x13,tmp);
+			if(tmp & 0x04) {
+				ivideo->SiS_Pr.SiS_UseLCDA = TRUE;
+				ivideo->detectedlcda = 0x03;
+			}
+		}
@@ -3091 +3122,43 @@
-	tqueue_pos = (ivideo->video_size - TURBO_QUEUE_AREA_SIZE) / (64 * 1024);
+		/* Save PDC */
+		if(ivideo->vbflags2 & VB2_SISLVDSBRIDGE) {
+			int tmp;
+			inSISIDXREG(SISCR,0x30,tmp);
+			if((tmp & 0x20) || (ivideo->detectedlcda != 0xff)) {
+				/* Currently on LCD? If yes, read current pdc */
+				u8 pdc;
+				inSISIDXREG(SISPART1,0x2D,pdc);
+				ivideo->detectedpdc  = (pdc & 0x0f) << 1;
+				ivideo->detectedpdca = (pdc & 0xf0) >> 3;
+				inSISIDXREG(SISPART1,0x35,pdc);
+				ivideo->detectedpdc |= ((pdc >> 7) & 0x01);
+				inSISIDXREG(SISPART1,0x20,pdc);
+				ivideo->detectedpdca |= ((pdc >> 6) & 0x01);
+				if(ivideo->newrom) {
+					/* New ROM invalidates other PDC resp. */
+					if(ivideo->detectedlcda != 0xff) {
+						ivideo->detectedpdc = 0xff;
+					} else {
+						ivideo->detectedpdca = 0xff;
+					}
+				}
+				if(ivideo->SiS_Pr.PDC == -1) {
+					if(ivideo->detectedpdc != 0xff) {
+						ivideo->SiS_Pr.PDC = ivideo->detectedpdc;
+					}
+				}
+				if(ivideo->SiS_Pr.PDCA == -1) {
+					if(ivideo->detectedpdca != 0xff) {
+						ivideo->SiS_Pr.PDCA = ivideo->detectedpdca;
+					}
+				}
+				if(ivideo->detectedpdc != 0xff) {
+					printk(KERN_INFO
+						"sisfb: Detected LCD PDC 0x%02x (for LCD=CRT2)\n",
+						ivideo->detectedpdc);
+				}
+				if(ivideo->detectedpdca != 0xff) {
+					printk(KERN_INFO
+						"sisfb: Detected LCD PDC1 0x%02x (for LCD=CRT1)\n",
+						ivideo->detectedpdca);
+				}
+			}
@@ -3093,5 +3166,12 @@
-	inSISIDXREG(SISSR, IND_SIS_TURBOQUEUE_SET, tq_state);
-	tq_state |= 0xf0;
-	tq_state &= 0xfc;
-	tq_state |= (u8)(tqueue_pos >> 8);
-	outSISIDXREG(SISSR, IND_SIS_TURBOQUEUE_SET, tq_state);
+			/* Save EMI */
+			if(ivideo->vbflags2 & VB2_SISEMIBRIDGE) {
+				inSISIDXREG(SISPART4,0x30,ivideo->SiS_Pr.EMI_30);
+				inSISIDXREG(SISPART4,0x31,ivideo->SiS_Pr.EMI_31);
+				inSISIDXREG(SISPART4,0x32,ivideo->SiS_Pr.EMI_32);
+				inSISIDXREG(SISPART4,0x33,ivideo->SiS_Pr.EMI_33);
+				ivideo->SiS_Pr.HaveEMI = TRUE;
+				if((tmp & 0x20) || (ivideo->detectedlcda != 0xff)) {
+					ivideo->SiS_Pr.HaveEMILCD = TRUE;
+				}
+			}
+		}
@@ -3099 +3179,13 @@
-	outSISIDXREG(SISSR, IND_SIS_TURBOQUEUE_ADR, (u8)(tqueue_pos & 0xff));
+		/* Let user override detected PDCs (all bridges) */
+		if(ivideo->vbflags2 & VB2_30xBLV) {
+			if((ivideo->SiS_Pr.PDC != -1) &&
+			   (ivideo->SiS_Pr.PDC != ivideo->detectedpdc)) {
+				printk(KERN_INFO "sisfb: Using LCD PDC 0x%02x (for LCD=CRT2)\n",
+					ivideo->SiS_Pr.PDC);
+			}
+			if((ivideo->SiS_Pr.PDCA != -1) &&
+			   (ivideo->SiS_Pr.PDCA != ivideo->detectedpdca)) {
+				printk(KERN_INFO "sisfb: Using LCD PDC1 0x%02x (for LCD=CRT1)\n",
+				 ivideo->SiS_Pr.PDCA);
+			}
+		}
@@ -3101,2 +3193 @@
-	ivideo->caps |= TURBO_QUEUE_CAP;
-     }
+	}
@@ -3103,0 +3195,43 @@
+}
+
+/* -------------------- Memory manager routines ---------------------- */
+
+static u32 __devinit
+sisfb_getheapstart(struct sis_video_info *ivideo)
+{
+	u32 ret = ivideo->sisfb_parm_mem * 1024;
+	u32 maxoffs = ivideo->video_size - ivideo->hwcursor_size - ivideo->cmdQueueSize;
+	u32 def;
+
+	/* Calculate heap start = end of memory for console
+	 *
+	 * CCCCCCCCDDDDDDDDDDDDDDDDDDDDDDDDDDDDHHHHQQQQQQQQQQ
+	 * C = console, D = heap, H = HWCursor, Q = cmd-queue
+	 *
+	 * On 76x in UMA+LFB mode, the layout is as follows:
+	 * DDDDDDDDDDDCCCCCCCCCCCCCCCCCCCCCCCCHHHHQQQQQQQQQQQ
+	 * where the heap is the entire UMA area, eventually
+	 * into the LFB area if the given mem parameter is
+	 * higher than the size of the UMA memory.
+	 *
+	 * Basically given by "mem" parameter
+	 *
+	 * maximum = videosize - cmd_queue - hwcursor
+	 *           (results in a heap of size 0)
+	 * default = SiS 300: depends on videosize
+	 *           SiS 315/330/340/XGI: 32k below max
+	 */
+
+	if(ivideo->sisvga_engine == SIS_300_VGA) {
+		if(ivideo->video_size > 0x1000000) {
+			def = 0xc00000;
+		} else if(ivideo->video_size > 0x800000) {
+			def = 0x800000;
+		} else {
+			def = 0x400000;
+		}
+	} else if(ivideo->UMAsize && ivideo->LFBsize) {
+		ret = def = 0;
+	} else {
+		def = maxoffs - 0x8000;
+	}
@@ -3105,4 +3239,3 @@
-     /* Reserve memory for the HWCursor */
-     ivideo->sisfb_heap_end -= ivideo->hwcursor_size;
-     ivideo->hwcursor_vbase = ivideo->sisfb_heap_end;
-     ivideo->caps |= HW_CURSOR_CAP;
+	/* Use default for secondary card for now (FIXME) */
+	if((!ret) || (ret > maxoffs) || (ivideo->cardnumber != 0))
+		ret = def;
@@ -3110 +3243,8 @@
-     ivideo->sisfb_heap_size = ivideo->sisfb_heap_end - ivideo->sisfb_heap_start;
+	return ret;
+}
+
+static u32 __devinit
+sisfb_getheapsize(struct sis_video_info *ivideo)
+{
+	u32 max = ivideo->video_size - ivideo->hwcursor_size - ivideo->cmdQueueSize;
+	u32 ret = 0;
@@ -3112 +3252,16 @@
-     if(ivideo->cardnumber == 0) {
+	if(ivideo->UMAsize && ivideo->LFBsize) {
+		if( (!ivideo->sisfb_parm_mem)			||
+		    ((ivideo->sisfb_parm_mem * 1024) > max)	||
+		    ((max - (ivideo->sisfb_parm_mem * 1024)) < ivideo->UMAsize) ) {
+			ret = ivideo->UMAsize;
+			max -= ivideo->UMAsize;
+		} else {
+			ret = max - (ivideo->sisfb_parm_mem * 1024);
+			max = ivideo->sisfb_parm_mem * 1024;
+		}
+		ivideo->video_offset = ret;
+		ivideo->sisfb_mem = max;
+	} else {
+		ret = max - ivideo->heapstart;
+		ivideo->sisfb_mem = ivideo->heapstart;
+	}
@@ -3114,2 +3269,2 @@
-     	printk(KERN_INFO "sisfb: Memory heap starting at %dK, size %dK\n",
-     		(int)(ivideo->heapstart / 1024), (int)(ivideo->sisfb_heap_size / 1024));
+	return ret;
+}
@@ -3117 +3272,4 @@
-	sisfb_heap.vinfo = ivideo;
+static int __devinit
+sisfb_heap_init(struct sis_video_info *ivideo)
+{
+	struct SIS_OH *poh;
@@ -3119,2 +3277,7 @@
-     	sisfb_heap.poha_chain = NULL;
-     	sisfb_heap.poh_freelist = NULL;
+	ivideo->video_offset = 0;
+	if(ivideo->sisfb_parm_mem) {
+		if( (ivideo->sisfb_parm_mem < (2 * 1024 * 1024)) ||
+		    (ivideo->sisfb_parm_mem > ivideo->video_size) ) {
+			ivideo->sisfb_parm_mem = 0;
+		}
+	}
@@ -3122,2 +3285,2 @@
-     	poh = sisfb_poh_new_node();
-     	if(poh == NULL) return 1;
+	ivideo->heapstart = sisfb_getheapstart(ivideo);
+	ivideo->sisfb_heap_size = sisfb_getheapsize(ivideo);
@@ -3125,4 +3288,2 @@
-     	poh->poh_next = &sisfb_heap.oh_free;
-     	poh->poh_prev = &sisfb_heap.oh_free;
-     	poh->size = ivideo->sisfb_heap_size;
-     	poh->offset = ivideo->heapstart;
+	ivideo->sisfb_heap_start = ivideo->video_vbase + ivideo->heapstart;
+	ivideo->sisfb_heap_end   = ivideo->sisfb_heap_start + ivideo->sisfb_heap_size;
@@ -3130,4 +3291,2 @@
-     	sisfb_heap.oh_free.poh_next = poh;
-     	sisfb_heap.oh_free.poh_prev = poh;
-     	sisfb_heap.oh_free.size = 0;
-     	sisfb_heap.max_freesize = poh->size;
+	printk(KERN_INFO "sisfb: Memory heap starting at %dK, size %dK\n",
+		(int)(ivideo->heapstart / 1024), (int)(ivideo->sisfb_heap_size / 1024));
@@ -3135,3 +3294 @@
-     	sisfb_heap.oh_used.poh_next = &sisfb_heap.oh_used;
-     	sisfb_heap.oh_used.poh_prev = &sisfb_heap.oh_used;
-     	sisfb_heap.oh_used.size = SENTINEL;
+	ivideo->sisfb_heap.vinfo = ivideo;
@@ -3139 +3296,2 @@
-     } else {
+	ivideo->sisfb_heap.poha_chain = NULL;
+	ivideo->sisfb_heap.poh_freelist = NULL;
@@ -3141 +3299,3 @@
-        printk(KERN_INFO "Skipped heap initialization for secondary cards\n");
+	poh = sisfb_poh_new_node(&ivideo->sisfb_heap);
+	if(poh == NULL)
+		return 1;
@@ -3143 +3303,20 @@
-     }
+	poh->poh_next = &ivideo->sisfb_heap.oh_free;
+	poh->poh_prev = &ivideo->sisfb_heap.oh_free;
+	poh->size = ivideo->sisfb_heap_size;
+	poh->offset = ivideo->heapstart;
+
+	ivideo->sisfb_heap.oh_free.poh_next = poh;
+	ivideo->sisfb_heap.oh_free.poh_prev = poh;
+	ivideo->sisfb_heap.oh_free.size = 0;
+	ivideo->sisfb_heap.max_freesize = poh->size;
+
+	ivideo->sisfb_heap.oh_used.poh_next = &ivideo->sisfb_heap.oh_used;
+	ivideo->sisfb_heap.oh_used.poh_prev = &ivideo->sisfb_heap.oh_used;
+	ivideo->sisfb_heap.oh_used.size = SENTINEL;
+
+	if(ivideo->cardnumber == 0) {
+		/* For the first card, make this heap the "global" one
+		 * for old DRM (which could handle only one card)
+		 */
+		sisfb_heap = &ivideo->sisfb_heap;
+	}
@@ -3145 +3324 @@
-     return 0;
+	return 0;
@@ -3148,2 +3327,2 @@
-static SIS_OH *
-sisfb_poh_new_node(void)
+static struct SIS_OH *
+sisfb_poh_new_node(struct SIS_HEAP *memheap)
@@ -3151,4 +3330,4 @@
-	int           i;
-	unsigned long cOhs;
-	SIS_OHALLOC   *poha;
-	SIS_OH        *poh;
+	struct SIS_OHALLOC	*poha;
+	struct SIS_OH		*poh;
+	unsigned long		cOhs;
+	int			i;
@@ -3156 +3335 @@
-	if(sisfb_heap.poh_freelist == NULL) {
+	if(memheap->poh_freelist == NULL) {
@@ -3158 +3337,2 @@
-		if(!poha) return NULL;
+		if(!poha)
+			return NULL;
@@ -3160,2 +3340,2 @@
-		poha->poha_next = sisfb_heap.poha_chain;
-		sisfb_heap.poha_chain = poha;
+		poha->poha_next = memheap->poha_chain;
+		memheap->poha_chain = poha;
@@ -3163 +3343 @@
-		cOhs = (SIS_OH_ALLOC_SIZE - sizeof(SIS_OHALLOC)) / sizeof(SIS_OH) + 1;
+		cOhs = (SIS_OH_ALLOC_SIZE - sizeof(struct SIS_OHALLOC)) / sizeof(struct SIS_OH) + 1;
@@ -3172 +3352 @@
-		sisfb_heap.poh_freelist = &poha->aoh[0];
+		memheap->poh_freelist = &poha->aoh[0];
@@ -3175,2 +3355,2 @@
-	poh = sisfb_heap.poh_freelist;
-	sisfb_heap.poh_freelist = poh->poh_next;
+	poh = memheap->poh_freelist;
+	memheap->poh_freelist = poh->poh_next;
@@ -3178 +3358 @@
-	return (poh);
+	return poh;
@@ -3181,2 +3361,2 @@
-static SIS_OH *
-sisfb_poh_allocate(u32 size)
+static struct SIS_OH *
+sisfb_poh_allocate(struct SIS_HEAP *memheap, u32 size)
@@ -3184,3 +3364,3 @@
-	SIS_OH *pohThis;
-	SIS_OH *pohRoot;
-	int     bAllocated = 0;
+	struct SIS_OH	*pohThis;
+	struct SIS_OH	*pohRoot;
+	int		bAllocated = 0;
@@ -3188 +3368 @@
-	if(size > sisfb_heap.max_freesize) {
+	if(size > memheap->max_freesize) {
@@ -3191 +3371 @@
-		return (NULL);
+		return NULL;
@@ -3194 +3374 @@
-	pohThis = sisfb_heap.oh_free.poh_next;
+	pohThis = memheap->oh_free.poh_next;
@@ -3196,2 +3376,2 @@
-	while(pohThis != &sisfb_heap.oh_free) {
-		if (size <= pohThis->size) {
+	while(pohThis != &memheap->oh_free) {
+		if(size <= pohThis->size) {
@@ -3207 +3387 @@
-		return (NULL);
+		return NULL;
@@ -3214,5 +3394,3 @@
-		pohRoot = sisfb_poh_new_node();
-
-		if(pohRoot == NULL) {
-			return (NULL);
-		}
+		pohRoot = sisfb_poh_new_node(memheap);
+		if(pohRoot == NULL)
+			return NULL;
@@ -3227 +3405 @@
-	sisfb_heap.max_freesize -= size;
+	memheap->max_freesize -= size;
@@ -3229 +3407 @@
-	pohThis = &sisfb_heap.oh_used;
+	pohThis = &memheap->oh_used;
@@ -3232 +3410 @@
-	return (pohRoot);
+	return pohRoot;
@@ -3236 +3414 @@
-sisfb_delete_node(SIS_OH *poh)
+sisfb_delete_node(struct SIS_OH *poh)
@@ -3238,8 +3416,2 @@
-	SIS_OH *poh_prev;
-	SIS_OH *poh_next;
-
-	poh_prev = poh->poh_prev;
-	poh_next = poh->poh_next;
-
-	poh_prev->poh_next = poh_next;
-	poh_next->poh_prev = poh_prev;
+	poh->poh_prev->poh_next = poh->poh_next;
+	poh->poh_next->poh_prev = poh->poh_prev;
@@ -3249 +3421 @@
-sisfb_insert_node(SIS_OH *pohList, SIS_OH *poh)
+sisfb_insert_node(struct SIS_OH *pohList, struct SIS_OH *poh)
@@ -3251,3 +3423 @@
-	SIS_OH *pohTemp;
-
-	pohTemp = pohList->poh_next;
+	struct SIS_OH *pohTemp = pohList->poh_next;
@@ -3262,2 +3432,2 @@
-static SIS_OH *
-sisfb_poh_free(u32 base)
+static struct SIS_OH *
+sisfb_poh_free(struct SIS_HEAP *memheap, u32 base)
@@ -3265,7 +3435,7 @@
-	SIS_OH *pohThis;
-	SIS_OH *poh_freed;
-	SIS_OH *poh_prev;
-	SIS_OH *poh_next;
-	u32     ulUpper;
-	u32     ulLower;
-	int     foundNode = 0;
+	struct SIS_OH *pohThis;
+	struct SIS_OH *poh_freed;
+	struct SIS_OH *poh_prev;
+	struct SIS_OH *poh_next;
+	u32    ulUpper;
+	u32    ulLower;
+	int    foundNode = 0;
@@ -3273 +3443 @@
-	poh_freed = sisfb_heap.oh_used.poh_next;
+	poh_freed = memheap->oh_used.poh_next;
@@ -3275 +3445 @@
-	while(poh_freed != &sisfb_heap.oh_used) {
+	while(poh_freed != &memheap->oh_used) {
@@ -3284 +3454,2 @@
-	if(!foundNode) return(NULL);
+	if(!foundNode)
+		return NULL;
@@ -3286 +3457 @@
-	sisfb_heap.max_freesize += poh_freed->size;
+	memheap->max_freesize += poh_freed->size;
@@ -3292 +3463 @@
-	pohThis = sisfb_heap.oh_free.poh_next;
+	pohThis = memheap->oh_free.poh_next;
@@ -3294 +3465 @@
-	while(pohThis != &sisfb_heap.oh_free) {
+	while(pohThis != &memheap->oh_free) {
@@ -3308,3 +3479,3 @@
-		sisfb_free_node(poh_freed);
-		sisfb_free_node(poh_next);
-		return(poh_prev);
+		sisfb_free_node(memheap, poh_freed);
+		sisfb_free_node(memheap, poh_next);
+		return poh_prev;
@@ -3315,2 +3486,2 @@
-		sisfb_free_node(poh_freed);
-		return(poh_prev);
+		sisfb_free_node(memheap, poh_freed);
+		return poh_prev;
@@ -3322,2 +3493,2 @@
-		sisfb_free_node(poh_freed);
-		return(poh_next);
+		sisfb_free_node(memheap, poh_freed);
+		return poh_next;
@@ -3326 +3497 @@
-	sisfb_insert_node(&sisfb_heap.oh_free, poh_freed);
+	sisfb_insert_node(&memheap->oh_free, poh_freed);
@@ -3328 +3499 @@
-	return(poh_freed);
+	return poh_freed;
@@ -3332 +3503 @@
-sisfb_free_node(SIS_OH *poh)
+sisfb_free_node(struct SIS_HEAP *memheap, struct SIS_OH *poh)
@@ -3334 +3505,2 @@
-	if(poh == NULL) return;
+	if(poh == NULL)
+		return;
@@ -3336,2 +3508,2 @@
-	poh->poh_next = sisfb_heap.poh_freelist;
-	sisfb_heap.poh_freelist = poh;
+	poh->poh_next = memheap->poh_freelist;
+	memheap->poh_freelist = poh;
@@ -3340,2 +3512,2 @@
-void
-sis_malloc(struct sis_memreq *req)
+static void
+sis_int_malloc(struct sis_video_info *ivideo, struct sis_memreq *req)
@@ -3343,2 +3515 @@
-	struct sis_video_info *ivideo = sisfb_heap.vinfo;
-	SIS_OH *poh = NULL;
+	struct SIS_OH *poh = NULL;
@@ -3346,3 +3517,2 @@
-	if((ivideo) && (!ivideo->havenoheap)) {
-	   poh = sisfb_poh_allocate((u32)req->size);
-	}
+	if((ivideo) && (ivideo->sisfb_id == SISFB_ID) && (!ivideo->havenoheap))
+		poh = sisfb_poh_allocate(&ivideo->sisfb_heap, (u32)req->size);
@@ -3351,2 +3521,2 @@
-	   req->offset = req->size = 0;
-	   DPRINTK("sisfb: Video RAM allocation failed\n");
+		req->offset = req->size = 0;
+		DPRINTK("sisfb: Video RAM allocation failed\n");
@@ -3354,4 +3524,4 @@
-	   req->offset = poh->offset;
-	   req->size = poh->size;
-	   DPRINTK("sisfb: Video RAM allocation succeeded: 0x%lx\n",
-	   	    (poh->offset + ivideo->video_vbase));
+		req->offset = poh->offset;
+		req->size = poh->size;
+		DPRINTK("sisfb: Video RAM allocation succeeded: 0x%lx\n",
+			(poh->offset + ivideo->video_vbase));
@@ -3361,2 +3530,0 @@
-/* sis_free: u32 because "base" is offset inside video ram, can never be >4GB */
-
@@ -3364 +3532 @@
-sis_free(u32 base)
+sis_malloc(struct sis_memreq *req)
@@ -3366,2 +3534 @@
-	struct sis_video_info *ivideo = sisfb_heap.vinfo;
-	SIS_OH *poh;
+	struct sis_video_info *ivideo = sisfb_heap->vinfo;
@@ -3369 +3536,5 @@
-	if((!ivideo) || (ivideo->havenoheap)) return;
+	if(&ivideo->sisfb_heap == sisfb_heap)
+		sis_int_malloc(ivideo, req);
+	else
+		req->offset = req->size = 0;
+}
@@ -3371 +3542,4 @@
-	poh = sisfb_poh_free((u32)base);
+void
+sis_malloc_new(struct pci_dev *pdev, struct sis_memreq *req)
+{
+	struct sis_video_info *ivideo = pci_get_drvdata(pdev);
@@ -3373,4 +3547 @@
-	if(poh == NULL) {
-		DPRINTK("sisfb: sisfb_poh_free() failed at base 0x%x\n",
-			(unsigned int) base);
-	}
+	sis_int_malloc(ivideo, req);
@@ -3379 +3550 @@
-/* --------------------- SetMode routines ------------------------- */
+/* sis_free: u32 because "base" is offset inside video ram, can never be >4GB */
@@ -3382 +3553 @@
-sisfb_pre_setmode(struct sis_video_info *ivideo)
+sis_int_free(struct sis_video_info *ivideo, u32 base)
@@ -3384,2 +3555 @@
-	u8 cr30 = 0, cr31 = 0, cr33 = 0, cr35 = 0, cr38 = 0;
-	int tvregnum = 0;
+	struct SIS_OH *poh;
@@ -3387 +3557,2 @@
-	ivideo->currentvbflags &= (VB_VIDEOBRIDGE | VB_DISPTYPE_DISP2);
+	if((!ivideo) || (ivideo->sisfb_id != SISFB_ID) || (ivideo->havenoheap))
+		return;
@@ -3389,3 +3560,77 @@
-	inSISIDXREG(SISCR, 0x31, cr31);
-	cr31 &= ~0x60;
-	cr31 |= 0x04;
+	poh = sisfb_poh_free(&ivideo->sisfb_heap, base);
+
+	if(poh == NULL) {
+		DPRINTK("sisfb: sisfb_poh_free() failed at base 0x%x\n",
+			(unsigned int) base);
+	}
+}
+
+void
+sis_free(u32 base)
+{
+	struct sis_video_info *ivideo = sisfb_heap->vinfo;
+
+	sis_int_free(ivideo, base);
+}
+
+void
+sis_free_new(struct pci_dev *pdev, u32 base)
+{
+	struct sis_video_info *ivideo = pci_get_drvdata(pdev);
+
+	sis_int_free(ivideo, base);
+}
+
+/* --------------------- SetMode routines ------------------------- */
+
+static void
+sisfb_check_engine_and_sync(struct sis_video_info *ivideo)
+{
+	u8 cr30, cr31;
+
+	/* Check if MMIO and engines are enabled,
+	 * and sync in case they are. Can't use
+	 * ivideo->accel here, as this might have
+	 * been changed before this is called.
+	 */
+	inSISIDXREG(SISSR, IND_SIS_PCI_ADDRESS_SET, cr30);
+	inSISIDXREG(SISSR, IND_SIS_MODULE_ENABLE, cr31);
+	/* MMIO and 2D/3D engine enabled? */
+	if((cr30 & SIS_MEM_MAP_IO_ENABLE) && (cr31 & 0x42)) {
+#ifdef CONFIG_FB_SIS_300
+		if(ivideo->sisvga_engine == SIS_300_VGA) {
+			/* Don't care about TurboQueue. It's
+			 * enough to know that the engines
+			 * are enabled
+			 */
+			sisfb_syncaccel(ivideo);
+		}
+#endif
+#ifdef CONFIG_FB_SIS_315
+		if(ivideo->sisvga_engine == SIS_315_VGA) {
+			/* Check that any queue mode is
+			 * enabled, and that the queue
+			 * is not in the state of "reset"
+			 */
+			inSISIDXREG(SISSR, 0x26, cr30);
+			if((cr30 & 0xe0) && (!(cr30 & 0x01))) {
+				sisfb_syncaccel(ivideo);
+			}
+		}
+#endif
+	}
+}
+
+static void
+sisfb_pre_setmode(struct sis_video_info *ivideo)
+{
+	u8 cr30 = 0, cr31 = 0, cr33 = 0, cr35 = 0, cr38 = 0;
+	int tvregnum = 0;
+
+	ivideo->currentvbflags &= (VB_VIDEOBRIDGE | VB_DISPTYPE_DISP2);
+
+	outSISIDXREG(SISSR, 0x05, 0x86);
+
+	inSISIDXREG(SISCR, 0x31, cr31);
+	cr31 &= ~0x60;
+	cr31 |= 0x04;
@@ -3415,0 +3661 @@
+	ivideo->curFSTN = ivideo->curDSTN = 0;
@@ -3421 +3667 @@
-	      if((ivideo->vbflags & TV_YPBPR) && (ivideo->vbflags & (VB_301C|VB_301LV|VB_302LV))) {
+	      if((ivideo->vbflags & TV_YPBPR) && (ivideo->vbflags2 & VB2_SISYPBPRBRIDGE)) {
@@ -3423,3 +3669,3 @@
-	         if(ivideo->chip >= SIS_661) {
-	            cr38 |= 0x04;
-	            if(ivideo->vbflags & TV_YPBPR525P)       cr35 |= 0x20;
+		 if(ivideo->chip >= SIS_661) {
+		    cr38 |= 0x04;
+		    if(ivideo->vbflags & TV_YPBPR525P)       cr35 |= 0x20;
@@ -3431,2 +3677,2 @@
-	         } else if(ivideo->sisvga_engine == SIS_315_VGA) {
-	            cr30 |= (0x80 | SIS_SIMULTANEOUS_VIEW_ENABLE);
+		 } else if(ivideo->sisvga_engine == SIS_315_VGA) {
+		    cr30 |= (0x80 | SIS_SIMULTANEOUS_VIEW_ENABLE);
@@ -3434 +3680 @@
-	            if(ivideo->vbflags & TV_YPBPR525P)       cr38 |= 0x10;
+		    if(ivideo->vbflags & TV_YPBPR525P)       cr38 |= 0x10;
@@ -3439 +3685 @@
-	         }
+		 }
@@ -3441,7 +3687,8 @@
-	      } else if((ivideo->vbflags & TV_HIVISION) && (ivideo->vbflags & (VB_301|VB_301B|VB_302B))) {
-	         if(ivideo->chip >= SIS_661) {
-	            cr38 |= 0x04;
-	            cr35 |= 0x60;
-	         } else {
-	            cr30 |= 0x80;
-	         }
+	      } else if((ivideo->vbflags & TV_HIVISION) &&
+				(ivideo->vbflags2 & VB2_SISHIVISIONBRIDGE)) {
+		 if(ivideo->chip >= SIS_661) {
+		    cr38 |= 0x04;
+		    cr35 |= 0x60;
+		 } else {
+		    cr30 |= 0x80;
+		 }
@@ -3449,2 +3696,2 @@
-	         cr31 |= 0x01;
-	         cr35 |= 0x01;
+		 cr31 |= 0x01;
+		 cr35 |= 0x01;
@@ -3469,2 +3716,2 @@
-	      if(ivideo->vbflags & (TV_AVIDEO|TV_SVIDEO)) {
-	         if(ivideo->vbflags & TV_PAL) {
+	      if(ivideo->vbflags & (TV_AVIDEO | TV_SVIDEO)) {
+		 if(ivideo->vbflags & TV_PAL) {
@@ -3479,2 +3726,2 @@
-	  	    }
-                 } else {
+		    }
+		 } else {
@@ -3486 +3733 @@
-	 	    }
+		    }
@@ -3495,0 +3743,2 @@
+	      ivideo->curFSTN = ivideo->sisfb_fstn;
+	      ivideo->curDSTN = ivideo->sisfb_dstn;
@@ -3528,2 +3776,0 @@
-	if(ivideo->accel) sisfb_syncaccel(ivideo);
-
@@ -3530,0 +3778,2 @@
+
+	sisfb_check_engine_and_sync(ivideo);
@@ -3538 +3787 @@
-    u8  tmpreg;
+	u8  tmpreg;
@@ -3540,12 +3789,12 @@
-    if(ivideo->chip >= SIS_661) {
-       inSISIDXREG(SISSR,0x11,tmpreg);
-       if(tmpreg & 0x20) {
-          inSISIDXREG(SISSR,0x3e,tmpreg);
-	  tmpreg = (tmpreg + 1) & 0xff;
-	  outSISIDXREG(SISSR,0x3e,tmpreg);
-	  inSISIDXREG(SISSR,0x11,tmpreg);
-       }
-       if(tmpreg & 0xf0) {
-          andSISIDXREG(SISSR,0x11,0x0f);
-       }
-    }
+	if(ivideo->chip >= SIS_661) {
+		inSISIDXREG(SISSR,0x11,tmpreg);
+		if(tmpreg & 0x20) {
+			inSISIDXREG(SISSR,0x3e,tmpreg);
+			tmpreg = (tmpreg + 1) & 0xff;
+			outSISIDXREG(SISSR,0x3e,tmpreg);
+			inSISIDXREG(SISSR,0x11,tmpreg);
+		}
+		if(tmpreg & 0xf0) {
+			andSISIDXREG(SISSR,0x11,0x0f);
+		}
+	}
@@ -3555 +3804,2 @@
-static void sisfb_set_TVxposoffset(struct sis_video_info *ivideo, int val)
+static void
+sisfb_set_TVxposoffset(struct sis_video_info *ivideo, int val)
@@ -3557,3 +3807,3 @@
-   if(val > 32) val = 32;
-   if(val < -32) val = -32;
-   ivideo->tvxpos = val;
+	if(val > 32) val = 32;
+	if(val < -32) val = -32;
+	ivideo->tvxpos = val;
@@ -3561,2 +3811,2 @@
-   if(ivideo->sisfblocked) return;
-   if(!ivideo->modechanged) return;
+	if(ivideo->sisfblocked) return;
+	if(!ivideo->modechanged) return;
@@ -3564 +3814 @@
-   if(ivideo->currentvbflags & CRT2_TV) {
+	if(ivideo->currentvbflags & CRT2_TV) {
@@ -3566 +3816 @@
-      if(ivideo->vbflags & VB_CHRONTEL) {
+		if(ivideo->vbflags2 & VB2_CHRONTEL) {
@@ -3568 +3818 @@
-	 int x = ivideo->tvx;
+			int x = ivideo->tvx;
@@ -3570,12 +3820,12 @@
-	 switch(ivideo->chronteltype) {
-	 case 1:
-	     x += val;
-	     if(x < 0) x = 0;
-	     outSISIDXREG(SISSR,0x05,0x86);
-	     SiS_SetCH700x(&ivideo->SiS_Pr, (((x & 0xff) << 8) | 0x0a));
-	     SiS_SetCH70xxANDOR(&ivideo->SiS_Pr, (((x & 0x0100) << 1) | 0x08),0xFD);
-	     break;
-	 case 2:
-	     /* Not supported by hardware */
-	     break;
-	 }
+			switch(ivideo->chronteltype) {
+			case 1:
+				x += val;
+				if(x < 0) x = 0;
+				outSISIDXREG(SISSR,0x05,0x86);
+				SiS_SetCH700x(&ivideo->SiS_Pr, 0x0a, (x & 0xff));
+				SiS_SetCH70xxANDOR(&ivideo->SiS_Pr, 0x08, ((x & 0x0100) >> 7), 0xFD);
+				break;
+			case 2:
+				/* Not supported by hardware */
+				break;
+			}
@@ -3583 +3833 @@
-      } else if(ivideo->vbflags & VB_SISBRIDGE) {
+		} else if(ivideo->vbflags2 & VB2_SISBRIDGE) {
@@ -3585,2 +3835,2 @@
-	 u8 p2_1f,p2_20,p2_2b,p2_42,p2_43;
-	 unsigned short temp;
+			u8 p2_1f,p2_20,p2_2b,p2_42,p2_43;
+			unsigned short temp;
@@ -3588,69 +3838,72 @@
-	 p2_1f = ivideo->p2_1f;
-	 p2_20 = ivideo->p2_20;
-	 p2_2b = ivideo->p2_2b;
-	 p2_42 = ivideo->p2_42;
-	 p2_43 = ivideo->p2_43;
-
-	 temp = p2_1f | ((p2_20 & 0xf0) << 4);
-	 temp += (val * 2);
-	 p2_1f = temp & 0xff;
-	 p2_20 = (temp & 0xf00) >> 4;
-	 p2_2b = ((p2_2b & 0x0f) + (val * 2)) & 0x0f;
-	 temp = p2_43 | ((p2_42 & 0xf0) << 4);
-	 temp += (val * 2);
-	 p2_43 = temp & 0xff;
-	 p2_42 = (temp & 0xf00) >> 4;
-	 outSISIDXREG(SISPART2,0x1f,p2_1f);
-	 setSISIDXREG(SISPART2,0x20,0x0F,p2_20);
-	 setSISIDXREG(SISPART2,0x2b,0xF0,p2_2b);
-	 setSISIDXREG(SISPART2,0x42,0x0F,p2_42);
-	 outSISIDXREG(SISPART2,0x43,p2_43);
-      }
-   }
-}
-
-static void sisfb_set_TVyposoffset(struct sis_video_info *ivideo, int val)
-{
-   if(val > 32) val = 32;
-   if(val < -32) val = -32;
-   ivideo->tvypos = val;
-
-   if(ivideo->sisfblocked) return;
-   if(!ivideo->modechanged) return;
-
-   if(ivideo->currentvbflags & CRT2_TV) {
-
-      if(ivideo->vbflags & VB_CHRONTEL) {
-
-	 int y = ivideo->tvy;
-
-	 switch(ivideo->chronteltype) {
-	 case 1:
-	    y -= val;
-	    if(y < 0) y = 0;
-	    outSISIDXREG(SISSR,0x05,0x86);
-	    SiS_SetCH700x(&ivideo->SiS_Pr, (((y & 0xff) << 8) | 0x0b));
-	    SiS_SetCH70xxANDOR(&ivideo->SiS_Pr, ((y & 0x0100) | 0x08),0xFE);
-	    break;
-	 case 2:
-	    /* Not supported by hardware */
-	    break;
-	 }
-
-      } else if(ivideo->vbflags & VB_SISBRIDGE) {
-
-	 char p2_01, p2_02;
-	 val /= 2;
-	 p2_01 = ivideo->p2_01;
-	 p2_02 = ivideo->p2_02;
-
-	 p2_01 += val;
-	 p2_02 += val;
-	 while((p2_01 <= 0) || (p2_02 <= 0)) {
-	    p2_01 += 2;
-	    p2_02 += 2;
-	 }
-	 outSISIDXREG(SISPART2,0x01,p2_01);
-	 outSISIDXREG(SISPART2,0x02,p2_02);
-      }
-   }
+			p2_1f = ivideo->p2_1f;
+			p2_20 = ivideo->p2_20;
+			p2_2b = ivideo->p2_2b;
+			p2_42 = ivideo->p2_42;
+			p2_43 = ivideo->p2_43;
+
+			temp = p2_1f | ((p2_20 & 0xf0) << 4);
+			temp += (val * 2);
+			p2_1f = temp & 0xff;
+			p2_20 = (temp & 0xf00) >> 4;
+			p2_2b = ((p2_2b & 0x0f) + (val * 2)) & 0x0f;
+			temp = p2_43 | ((p2_42 & 0xf0) << 4);
+			temp += (val * 2);
+			p2_43 = temp & 0xff;
+			p2_42 = (temp & 0xf00) >> 4;
+			outSISIDXREG(SISPART2,0x1f,p2_1f);
+			setSISIDXREG(SISPART2,0x20,0x0F,p2_20);
+			setSISIDXREG(SISPART2,0x2b,0xF0,p2_2b);
+			setSISIDXREG(SISPART2,0x42,0x0F,p2_42);
+			outSISIDXREG(SISPART2,0x43,p2_43);
+		}
+	}
+}
+
+static void
+sisfb_set_TVyposoffset(struct sis_video_info *ivideo, int val)
+{
+	if(val > 32) val = 32;
+	if(val < -32) val = -32;
+	ivideo->tvypos = val;
+
+	if(ivideo->sisfblocked) return;
+	if(!ivideo->modechanged) return;
+
+	if(ivideo->currentvbflags & CRT2_TV) {
+
+		if(ivideo->vbflags2 & VB2_CHRONTEL) {
+
+			int y = ivideo->tvy;
+
+			switch(ivideo->chronteltype) {
+			case 1:
+				y -= val;
+				if(y < 0) y = 0;
+				outSISIDXREG(SISSR,0x05,0x86);
+				SiS_SetCH700x(&ivideo->SiS_Pr, 0x0b, (y & 0xff));
+				SiS_SetCH70xxANDOR(&ivideo->SiS_Pr, 0x08, ((y & 0x0100) >> 8), 0xFE);
+				break;
+			case 2:
+				/* Not supported by hardware */
+				break;
+			}
+
+		} else if(ivideo->vbflags2 & VB2_SISBRIDGE) {
+
+			char p2_01, p2_02;
+			val /= 2;
+			p2_01 = ivideo->p2_01;
+			p2_02 = ivideo->p2_02;
+
+			p2_01 += val;
+			p2_02 += val;
+			if(!(ivideo->currentvbflags & (TV_HIVISION | TV_YPBPR))) {
+				while((p2_01 <= 0) || (p2_02 <= 0)) {
+					p2_01 += 2;
+					p2_02 += 2;
+				}
+			}
+			outSISIDXREG(SISPART2,0x01,p2_01);
+			outSISIDXREG(SISPART2,0x02,p2_02);
+		}
+	}
@@ -3671 +3924 @@
-	outSISIDXREG(SISSR,0x05,0x86);
+	outSISIDXREG(SISSR, 0x05, 0x86);
@@ -3678 +3931 @@
-        ivideo->modechanged = 1;
+	ivideo->modechanged = 1;
@@ -3681 +3934 @@
-	if(ivideo->vbflags & VB_VIDEOBRIDGE) {
+	if(ivideo->vbflags2 & VB2_VIDEOBRIDGE) {
@@ -3683 +3936,2 @@
-	} else ivideo->sisfb_crt1off = 0;
+	} else
+		ivideo->sisfb_crt1off = 0;
@@ -3687,8 +3941,8 @@
-	   if((ivideo->sisfb_crt1off) && (doit)) {
-	        crt1isoff = TRUE;
-		reg = 0x00;
-	   } else {
-	        crt1isoff = FALSE;
-		reg = 0x80;
-	   }
-	   setSISIDXREG(SISCR, 0x17, 0x7f, reg);
+		if((ivideo->sisfb_crt1off) && (doit)) {
+			crt1isoff = TRUE;
+			reg = 0x00;
+		} else {
+			crt1isoff = FALSE;
+			reg = 0x80;
+		}
+		setSISIDXREG(SISCR, 0x17, 0x7f, reg);
@@ -3699,12 +3953,11 @@
-	   if((ivideo->sisfb_crt1off) && (doit)) {
-	        crt1isoff = TRUE;
-		reg  = 0x40;
-		reg1 = 0xc0;
-	   } else {
-	        crt1isoff = FALSE;
-		reg  = 0x00;
-		reg1 = 0x00;
-
-	   }
-	   setSISIDXREG(SISCR, ivideo->SiS_Pr.SiS_MyCR63, ~0x40, reg);
-	   setSISIDXREG(SISSR, 0x1f, ~0xc0, reg1);
+		if((ivideo->sisfb_crt1off) && (doit)) {
+			crt1isoff = TRUE;
+			reg  = 0x40;
+			reg1 = 0xc0;
+		} else {
+			crt1isoff = FALSE;
+			reg  = 0x00;
+			reg1 = 0x00;
+		}
+		setSISIDXREG(SISCR, ivideo->SiS_Pr.SiS_MyCR63, ~0x40, reg);
+		setSISIDXREG(SISSR, 0x1f, ~0xc0, reg1);
@@ -3715,2 +3968,2 @@
-	   ivideo->currentvbflags &= ~VB_DISPTYPE_CRT1;
-	   ivideo->currentvbflags |= VB_SINGLE_MODE;
+		ivideo->currentvbflags &= ~VB_DISPTYPE_CRT1;
+		ivideo->currentvbflags |= VB_SINGLE_MODE;
@@ -3718,6 +3971,6 @@
-	   ivideo->currentvbflags |= VB_DISPTYPE_CRT1;
-	   if(ivideo->currentvbflags & VB_DISPTYPE_CRT2) {
-	  	ivideo->currentvbflags |= VB_MIRROR_MODE;
-	   } else {
-	 	ivideo->currentvbflags |= VB_SINGLE_MODE;
-	   }
+		ivideo->currentvbflags |= VB_DISPTYPE_CRT1;
+		if(ivideo->currentvbflags & VB_DISPTYPE_CRT2) {
+			ivideo->currentvbflags |= VB_MIRROR_MODE;
+		} else {
+			ivideo->currentvbflags |= VB_SINGLE_MODE;
+		}
@@ -3726 +3979 @@
-        andSISIDXREG(SISSR, IND_SIS_RAMDAC_CONTROL, ~0x04);
+	andSISIDXREG(SISSR, IND_SIS_RAMDAC_CONTROL, ~0x04);
@@ -3729,16 +3982,16 @@
-	   if(ivideo->vbflags & VB_SISBRIDGE) {
-	      inSISIDXREG(SISPART2,0x1f,ivideo->p2_1f);
-	      inSISIDXREG(SISPART2,0x20,ivideo->p2_20);
-	      inSISIDXREG(SISPART2,0x2b,ivideo->p2_2b);
-	      inSISIDXREG(SISPART2,0x42,ivideo->p2_42);
-	      inSISIDXREG(SISPART2,0x43,ivideo->p2_43);
-	      inSISIDXREG(SISPART2,0x01,ivideo->p2_01);
-	      inSISIDXREG(SISPART2,0x02,ivideo->p2_02);
-	   } else if(ivideo->vbflags & VB_CHRONTEL) {
-	      if(ivideo->chronteltype == 1) {
-	         ivideo->tvx = SiS_GetCH700x(&ivideo->SiS_Pr, 0x0a);
-	         ivideo->tvx |= (((SiS_GetCH700x(&ivideo->SiS_Pr, 0x08) & 0x02) >> 1) << 8);
-	         ivideo->tvy = SiS_GetCH700x(&ivideo->SiS_Pr, 0x0b);
-	         ivideo->tvy |= ((SiS_GetCH700x(&ivideo->SiS_Pr, 0x08) & 0x01) << 8);
- 	      }
-	   }
+		if(ivideo->vbflags2 & VB2_SISBRIDGE) {
+			inSISIDXREG(SISPART2,0x1f,ivideo->p2_1f);
+			inSISIDXREG(SISPART2,0x20,ivideo->p2_20);
+			inSISIDXREG(SISPART2,0x2b,ivideo->p2_2b);
+			inSISIDXREG(SISPART2,0x42,ivideo->p2_42);
+			inSISIDXREG(SISPART2,0x43,ivideo->p2_43);
+			inSISIDXREG(SISPART2,0x01,ivideo->p2_01);
+			inSISIDXREG(SISPART2,0x02,ivideo->p2_02);
+		} else if(ivideo->vbflags2 & VB2_CHRONTEL) {
+			if(ivideo->chronteltype == 1) {
+				ivideo->tvx = SiS_GetCH700x(&ivideo->SiS_Pr, 0x0a);
+				ivideo->tvx |= (((SiS_GetCH700x(&ivideo->SiS_Pr, 0x08) & 0x02) >> 1) << 8);
+				ivideo->tvy = SiS_GetCH700x(&ivideo->SiS_Pr, 0x0b);
+				ivideo->tvy |= ((SiS_GetCH700x(&ivideo->SiS_Pr, 0x08) & 0x01) << 8);
+			}
+		}
@@ -3748 +4001 @@
-   	   sisfb_set_TVxposoffset(ivideo, ivideo->tvxpos);
+		sisfb_set_TVxposoffset(ivideo, ivideo->tvxpos);
@@ -3751 +4004 @@
-   	   sisfb_set_TVyposoffset(ivideo, ivideo->tvypos);
+		sisfb_set_TVyposoffset(ivideo, ivideo->tvypos);
@@ -3754,30 +4007,2 @@
-	if((ivideo->currentvbflags & CRT2_TV) && (ivideo->vbflags & VB_301)) {  /* Set filter for SiS301 */
-
-	   	unsigned char filter_tb = 0;
-
-		switch (ivideo->video_width) {
-		   case 320:
-			filter_tb = (ivideo->vbflags & TV_NTSC) ? 4 : 12;
-			break;
-		   case 640:
-			filter_tb = (ivideo->vbflags & TV_NTSC) ? 5 : 13;
-			break;
-		   case 720:
-			filter_tb = (ivideo->vbflags & TV_NTSC) ? 6 : 14;
-			break;
-		   case 400:
-		   case 800:
-			filter_tb = (ivideo->vbflags & TV_NTSC) ? 7 : 15;
-			break;
-		   default:
-			ivideo->sisfb_filter = -1;
-			break;
-		}
-
-		orSISIDXREG(SISPART1, ivideo->CRT2_write_enable, 0x01);
-
-		if(ivideo->vbflags & TV_NTSC) {
-
-		        andSISIDXREG(SISPART2, 0x3a, 0x1f);
-
-			if (ivideo->vbflags & TV_SVIDEO) {
+	/* Eventually sync engines */
+	sisfb_check_engine_and_sync(ivideo);
@@ -3785,28 +4010,7 @@
-			        andSISIDXREG(SISPART2, 0x30, 0xdf);
-
-			} else if (ivideo->vbflags & TV_AVIDEO) {
-
-			        orSISIDXREG(SISPART2, 0x30, 0x20);
-
-				switch (ivideo->video_width) {
-				case 640:
-				        outSISIDXREG(SISPART2, 0x35, 0xEB);
-					outSISIDXREG(SISPART2, 0x36, 0x04);
-					outSISIDXREG(SISPART2, 0x37, 0x25);
-					outSISIDXREG(SISPART2, 0x38, 0x18);
-					break;
-				case 720:
-					outSISIDXREG(SISPART2, 0x35, 0xEE);
-					outSISIDXREG(SISPART2, 0x36, 0x0C);
-					outSISIDXREG(SISPART2, 0x37, 0x22);
-					outSISIDXREG(SISPART2, 0x38, 0x08);
-					break;
-				case 400:
-				case 800:
-					outSISIDXREG(SISPART2, 0x35, 0xEB);
-					outSISIDXREG(SISPART2, 0x36, 0x15);
-					outSISIDXREG(SISPART2, 0x37, 0x25);
-					outSISIDXREG(SISPART2, 0x38, 0xF6);
-					break;
-				}
-			}
+	/* (Re-)Initialize chip engines */
+	if(ivideo->accel) {
+		sisfb_engine_init(ivideo);
+	} else {
+		ivideo->engineok = 0;
+	}
+}
@@ -3814 +4018,5 @@
-		} else if(ivideo->vbflags & TV_PAL) {
+static int
+sisfb_reset_mode(struct sis_video_info *ivideo)
+{
+	if(sisfb_set_mode(ivideo, 0))
+		return 1;
@@ -3816 +4024,3 @@
-			andSISIDXREG(SISPART2, 0x3A, 0x1F);
+	sisfb_set_pitch(ivideo);
+	sisfb_set_base_CRT1(ivideo, ivideo->current_base);
+	sisfb_set_base_CRT2(ivideo, ivideo->current_base);
@@ -3818 +4028,2 @@
-			if (ivideo->vbflags & TV_SVIDEO) {
+	return 0;
+}
@@ -3820 +4031,4 @@
-			        andSISIDXREG(SISPART2, 0x30, 0xDF);
+static void
+sisfb_handle_command(struct sis_video_info *ivideo, struct sisfb_cmd *sisfb_command)
+{
+	int mycrt1off;
@@ -3822,24 +4036,31 @@
-			} else if (ivideo->vbflags & TV_AVIDEO) {
-
-			        orSISIDXREG(SISPART2, 0x30, 0x20);
-
-				switch (ivideo->video_width) {
-				case 640:
-					outSISIDXREG(SISPART2, 0x35, 0xF1);
-					outSISIDXREG(SISPART2, 0x36, 0xF7);
-					outSISIDXREG(SISPART2, 0x37, 0x1F);
-					outSISIDXREG(SISPART2, 0x38, 0x32);
-					break;
-				case 720:
-					outSISIDXREG(SISPART2, 0x35, 0xF3);
-					outSISIDXREG(SISPART2, 0x36, 0x00);
-					outSISIDXREG(SISPART2, 0x37, 0x1D);
-					outSISIDXREG(SISPART2, 0x38, 0x20);
-					break;
-				case 400:
-				case 800:
-					outSISIDXREG(SISPART2, 0x35, 0xFC);
-					outSISIDXREG(SISPART2, 0x36, 0xFB);
-					outSISIDXREG(SISPART2, 0x37, 0x14);
-					outSISIDXREG(SISPART2, 0x38, 0x2A);
-					break;
+	switch(sisfb_command->sisfb_cmd) {
+	case SISFB_CMD_GETVBFLAGS:
+		if(!ivideo->modechanged) {
+			sisfb_command->sisfb_result[0] = SISFB_CMD_ERR_EARLY;
+		} else {
+			sisfb_command->sisfb_result[0] = SISFB_CMD_ERR_OK;
+			sisfb_command->sisfb_result[1] = ivideo->currentvbflags;
+			sisfb_command->sisfb_result[2] = ivideo->vbflags2;
+		}
+		break;
+	case SISFB_CMD_SWITCHCRT1:
+		/* arg[0]: 0 = off, 1 = on, 99 = query */
+		if(!ivideo->modechanged) {
+			sisfb_command->sisfb_result[0] = SISFB_CMD_ERR_EARLY;
+		} else if(sisfb_command->sisfb_arg[0] == 99) {
+			/* Query */
+			sisfb_command->sisfb_result[1] = ivideo->sisfb_crt1off ? 0 : 1;
+			sisfb_command->sisfb_result[0] = SISFB_CMD_ERR_OK;
+		} else if(ivideo->sisfblocked) {
+			sisfb_command->sisfb_result[0] = SISFB_CMD_ERR_LOCKED;
+		} else if((!(ivideo->currentvbflags & CRT2_ENABLE)) &&
+					(sisfb_command->sisfb_arg[0] == 0)) {
+			sisfb_command->sisfb_result[0] = SISFB_CMD_ERR_NOCRT2;
+		} else {
+			sisfb_command->sisfb_result[0] = SISFB_CMD_ERR_OK;
+			mycrt1off = sisfb_command->sisfb_arg[0] ? 0 : 1;
+			if( ((ivideo->currentvbflags & VB_DISPTYPE_CRT1) && mycrt1off) ||
+			    ((!(ivideo->currentvbflags & VB_DISPTYPE_CRT1)) && !mycrt1off) ) {
+				ivideo->sisfb_crt1off = mycrt1off;
+				if(sisfb_reset_mode(ivideo)) {
+					sisfb_command->sisfb_result[0] = SISFB_CMD_ERR_OTHER;
@@ -3847,0 +4069 @@
+			sisfb_command->sisfb_result[1] = ivideo->sisfb_crt1off ? 0 : 1;
@@ -3849,8 +4071,6 @@
-
-		if((ivideo->sisfb_filter >= 0) && (ivideo->sisfb_filter <= 7)) {
-		   outSISIDXREG(SISPART2,0x35,(sis_TV_filter[filter_tb].filter[ivideo->sisfb_filter][0]));
-		   outSISIDXREG(SISPART2,0x36,(sis_TV_filter[filter_tb].filter[ivideo->sisfb_filter][1]));
-		   outSISIDXREG(SISPART2,0x37,(sis_TV_filter[filter_tb].filter[ivideo->sisfb_filter][2]));
-		   outSISIDXREG(SISPART2,0x38,(sis_TV_filter[filter_tb].filter[ivideo->sisfb_filter][3]));
-		}
-	  
+		break;
+	/* more to come */
+	default:
+		sisfb_command->sisfb_result[0] = SISFB_CMD_ERR_UNKNOWN;
+		printk(KERN_ERR "sisfb: Unknown command 0x%x\n",
+			sisfb_command->sisfb_cmd);
@@ -3861 +4081,2 @@
-SISINITSTATIC int __init sisfb_setup(char *options)
+SISINITSTATIC int __init
+sisfb_setup(char *options)
@@ -3864,2 +4084,0 @@
-	
-	sisfb_setdefaultparms();
@@ -3867 +4086 @@
-        printk(KERN_DEBUG "sisfb: Options %s\n", options);
+	sisfb_setdefaultparms();
@@ -3869 +4088 @@
-	if(!options || !(*options)) {
+	if(!options || !(*options))
@@ -3871 +4089,0 @@
-	}
@@ -3883,2 +4100,0 @@
-		        sisfb_search_tvstd(this_opt + 7);
-                } else if(!strnicmp(this_opt, "tvstandard:",11)) {
@@ -3885,0 +4102,2 @@
+		} else if(!strnicmp(this_opt, "tvstandard:",11)) {
+			sisfb_search_tvstd(this_opt + 11);
@@ -3895 +4113 @@
-		        if(strlen(this_opt + 5) < 40) {
+			if(strlen(this_opt + 5) < 40) {
@@ -3902,2 +4119,0 @@
-		} else if(!strnicmp(this_opt, "filter:", 7)) {
-			sisfb_filter = (int)simple_strtoul(this_opt + 7, NULL, 0);
@@ -3906,2 +4122,2 @@
-                } else if(!strnicmp(this_opt, "mem:",4)) {
-		        sisfb_parm_mem = simple_strtoul(this_opt + 4, NULL, 0);
+		} else if(!strnicmp(this_opt, "mem:",4)) {
+			sisfb_parm_mem = simple_strtoul(this_opt + 4, NULL, 0);
@@ -3909 +4125 @@
-		        sisfb_pdc = simple_strtoul(this_opt + 4, NULL, 0);
+			sisfb_pdc = simple_strtoul(this_opt + 4, NULL, 0);
@@ -3911 +4127 @@
-		        sisfb_pdca = simple_strtoul(this_opt + 5, NULL, 0);
+			sisfb_pdca = simple_strtoul(this_opt + 5, NULL, 0);
@@ -3917 +4133 @@
-		        sisfb_ypan = 0;
+			sisfb_ypan = 0;
@@ -3919 +4135 @@
-		        sisfb_ypan = -1;
+			sisfb_ypan = -1;
@@ -3921 +4137 @@
-		        sisfb_max = 0;
+			sisfb_max = 0;
@@ -3923 +4139 @@
-		        sisfb_max = -1;
+			sisfb_max = -1;
@@ -3930,4 +4146,4 @@
-	 	} else if(!strnicmp(this_opt, "scalelcd:", 9)) {
-		        unsigned long temp = 2;
-		        temp = simple_strtoul(this_opt + 9, NULL, 0);
-		        if((temp == 0) || (temp == 1)) {
+		} else if(!strnicmp(this_opt, "scalelcd:", 9)) {
+			unsigned long temp = 2;
+			temp = simple_strtoul(this_opt + 9, NULL, 0);
+			if((temp == 0) || (temp == 1)) {
@@ -3935 +4151 @@
-		        }
+			}
@@ -3937,3 +4153,3 @@
-		        int temp = 0;
-		        temp = (int)simple_strtol(this_opt + 13, NULL, 0);
-		        if((temp >= -32) && (temp <= 32)) {
+			int temp = 0;
+			temp = (int)simple_strtol(this_opt + 13, NULL, 0);
+			if((temp >= -32) && (temp <= 32)) {
@@ -3941 +4157 @@
-		        }
+			}
@@ -3943,3 +4159,3 @@
-		        int temp = 0;
-		        temp = (int)simple_strtol(this_opt + 13, NULL, 0);
-		        if((temp >= -32) && (temp <= 32)) {
+			int temp = 0;
+			temp = (int)simple_strtol(this_opt + 13, NULL, 0);
+			if((temp >= -32) && (temp <= 32)) {
@@ -3947 +4163 @@
-		        }
+			}
@@ -3951,3 +4167,3 @@
-		        int temp = 4;
-		        temp = simple_strtoul(this_opt + 7, NULL, 0);
-		        if((temp >= 0) && (temp <= 3)) {
+			int temp = 4;
+			temp = simple_strtoul(this_opt + 7, NULL, 0);
+			if((temp >= 0) && (temp <= 3)) {
@@ -3955 +4171 @@
-		        }
+			}
@@ -3959,2 +4175,2 @@
-	        } else if(!strnicmp(this_opt, "resetcard", 9)) {
-		  	sisfb_resetcard = 1;
+		} else if(!strnicmp(this_opt, "resetcard", 9)) {
+			sisfb_resetcard = 1;
@@ -3962 +4178 @@
-		  	sisfb_videoram = simple_strtoul(this_opt + 9, NULL, 0);
+			sisfb_videoram = simple_strtoul(this_opt + 9, NULL, 0);
@@ -3969,0 +4186,608 @@
+	return 0;
+}
+#endif
+
+static int __devinit
+sisfb_check_rom(SIS_IOTYPE1 *rom_base, struct sis_video_info *ivideo)
+{
+	SIS_IOTYPE1 *rom;
+	int romptr;
+
+	if((readb(rom_base) != 0x55) || (readb(rom_base + 1) != 0xaa))
+		return 0;
+
+	romptr = (readb(rom_base + 0x18) | (readb(rom_base + 0x19) << 8));
+	if(romptr > (0x10000 - 8))
+		return 0;
+
+	rom = rom_base + romptr;
+
+	if((readb(rom)     != 'P') || (readb(rom + 1) != 'C') ||
+	   (readb(rom + 2) != 'I') || (readb(rom + 3) != 'R'))
+		return 0;
+
+	if((readb(rom + 4) | (readb(rom + 5) << 8)) != ivideo->chip_vendor)
+		return 0;
+
+	if((readb(rom + 6) | (readb(rom + 7) << 8)) != ivideo->chip_id)
+		return 0;
+
+	return 1;
+}
+
+static unsigned char * __devinit
+sisfb_find_rom(struct pci_dev *pdev)
+{
+	struct sis_video_info *ivideo = pci_get_drvdata(pdev);
+	SIS_IOTYPE1 *rom_base;
+	unsigned char *myrombase = NULL;
+	u32 temp;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
+	size_t romsize;
+
+	/* First, try the official pci ROM functions (except
+	 * on integrated chipsets which have no ROM).
+	 */
+
+	if(!ivideo->nbridge) {
+
+		if((rom_base = pci_map_rom(pdev, &romsize))) {
+
+			if(sisfb_check_rom(rom_base, ivideo)) {
+
+				if((myrombase = vmalloc(65536))) {
+
+					/* Work around bug in pci/rom.c: Folks forgot to check
+					 * whether the size retrieved from the BIOS image eventually
+					 * is larger than the mapped size
+					 */
+					if(pci_resource_len(pdev, PCI_ROM_RESOURCE) < romsize)
+						romsize = pci_resource_len(pdev, PCI_ROM_RESOURCE);
+
+					memcpy_fromio(myrombase, rom_base,
+							(romsize > 65536) ? 65536 : romsize);
+				}
+			}
+			pci_unmap_rom(pdev, rom_base);
+		}
+	}
+
+	if(myrombase) return myrombase;
+#endif
+
+	/* Otherwise do it the conventional way. */
+
+#if defined(__i386__) || defined(__x86_64__)
+
+	for(temp = 0x000c0000; temp < 0x000f0000; temp += 0x00001000) {
+
+		rom_base = ioremap(temp, 65536);
+		if(!rom_base)
+			continue;
+
+		if(!sisfb_check_rom(rom_base, ivideo)) {
+			iounmap(rom_base);
+			continue;
+		}
+
+		if((myrombase = vmalloc(65536)))
+			memcpy_fromio(myrombase, rom_base, 65536);
+
+		iounmap(rom_base);
+		break;
+
+        }
+
+#else
+
+	pci_read_config_dword(pdev, PCI_ROM_ADDRESS, &temp);
+	pci_write_config_dword(pdev, PCI_ROM_ADDRESS,
+			(ivideo->video_base & PCI_ROM_ADDRESS_MASK) | PCI_ROM_ADDRESS_ENABLE);
+
+	rom_base = ioremap(ivideo->video_base, 65536);
+	if(rom_base) {
+		if(sisfb_check_rom(rom_base, ivideo)) {
+			if((myrombase = vmalloc(65536)))
+				memcpy_fromio(myrombase, rom_base, 65536);
+		}
+		iounmap(rom_base);
+	}
+
+	pci_write_config_dword(pdev, PCI_ROM_ADDRESS, temp);
+
+#endif
+
+	return myrombase;
+}
+
+static void __devinit
+sisfb_post_map_vram(struct sis_video_info *ivideo, unsigned int *mapsize,
+			unsigned int min)
+{
+	ivideo->video_vbase = ioremap(ivideo->video_base, (*mapsize));
+
+	if(!ivideo->video_vbase) {
+		printk(KERN_ERR
+			"sisfb: Unable to map maximum video RAM for size detection\n");
+		(*mapsize) >>= 1;
+		while((!(ivideo->video_vbase = ioremap(ivideo->video_base, (*mapsize))))) {
+			(*mapsize) >>= 1;
+			if((*mapsize) < (min << 20))
+				break;
+		}
+		if(ivideo->video_vbase) {
+			printk(KERN_ERR
+				"sisfb: Video RAM size detection limited to %dMB\n",
+				(int)((*mapsize) >> 20));
+		}
+	}
+}
+
+#ifdef CONFIG_FB_SIS_300
+static int __devinit
+sisfb_post_300_buswidth(struct sis_video_info *ivideo)
+{
+	SIS_IOTYPE1 *FBAddress = ivideo->video_vbase;
+	unsigned short temp;
+	unsigned char reg;
+	int i, j;
+
+	andSISIDXREG(SISSR, 0x15, 0xFB);
+	orSISIDXREG(SISSR, 0x15, 0x04);
+	outSISIDXREG(SISSR, 0x13, 0x00);
+	outSISIDXREG(SISSR, 0x14, 0xBF);
+
+	for(i = 0; i < 2; i++) {
+		temp = 0x1234;
+		for(j = 0; j < 4; j++) {
+			writew(temp, FBAddress);
+			if(readw(FBAddress) == temp)
+				break;
+			orSISIDXREG(SISSR, 0x3c, 0x01);
+			inSISIDXREG(SISSR, 0x05, reg);
+			inSISIDXREG(SISSR, 0x05, reg);
+			andSISIDXREG(SISSR, 0x3c, 0xfe);
+			inSISIDXREG(SISSR, 0x05, reg);
+			inSISIDXREG(SISSR, 0x05, reg);
+			temp++;
+		}
+	}
+
+	writel(0x01234567L, FBAddress);
+	writel(0x456789ABL, (FBAddress + 4));
+	writel(0x89ABCDEFL, (FBAddress + 8));
+	writel(0xCDEF0123L, (FBAddress + 12));
+
+	inSISIDXREG(SISSR, 0x3b, reg);
+	if(reg & 0x01) {
+		if(readl((FBAddress + 12)) == 0xCDEF0123L)
+			return 4;	/* Channel A 128bit */
+	}
+
+	if(readl((FBAddress + 4)) == 0x456789ABL)
+		return 2;		/* Channel B 64bit */
+
+	return 1;			/* 32bit */
+}
+
+static int __devinit
+sisfb_post_300_rwtest(struct sis_video_info *ivideo, int iteration, int buswidth,
+			int PseudoRankCapacity, int PseudoAdrPinCount,
+			unsigned int mapsize)
+{
+	SIS_IOTYPE1 *FBAddr = ivideo->video_vbase;
+	unsigned short sr14;
+	unsigned int k, RankCapacity, PageCapacity, BankNumHigh, BankNumMid;
+	unsigned int PhysicalAdrOtherPage, PhysicalAdrHigh, PhysicalAdrHalfPage;
+	static const unsigned short SiS_DRAMType[17][5] = {
+		{0x0C,0x0A,0x02,0x40,0x39},
+		{0x0D,0x0A,0x01,0x40,0x48},
+		{0x0C,0x09,0x02,0x20,0x35},
+		{0x0D,0x09,0x01,0x20,0x44},
+		{0x0C,0x08,0x02,0x10,0x31},
+		{0x0D,0x08,0x01,0x10,0x40},
+		{0x0C,0x0A,0x01,0x20,0x34},
+		{0x0C,0x09,0x01,0x08,0x32},
+		{0x0B,0x08,0x02,0x08,0x21},
+		{0x0C,0x08,0x01,0x08,0x30},
+		{0x0A,0x08,0x02,0x04,0x11},
+		{0x0B,0x0A,0x01,0x10,0x28},
+		{0x09,0x08,0x02,0x02,0x01},
+		{0x0B,0x09,0x01,0x08,0x24},
+		{0x0B,0x08,0x01,0x04,0x20},
+		{0x0A,0x08,0x01,0x02,0x10},
+		{0x09,0x08,0x01,0x01,0x00}
+	};
+
+	 for(k = 0; k <= 16; k++) {
+
+		RankCapacity = buswidth * SiS_DRAMType[k][3];
+
+		if(RankCapacity != PseudoRankCapacity)
+			continue;
+
+		if((SiS_DRAMType[k][2] + SiS_DRAMType[k][0]) > PseudoAdrPinCount)
+			continue;
+
+		BankNumHigh = RankCapacity * 16 * iteration - 1;
+		if(iteration == 3) {             /* Rank No */
+			BankNumMid  = RankCapacity * 16 - 1;
+		} else {
+			BankNumMid  = RankCapacity * 16 * iteration / 2 - 1;
+		}
+
+		PageCapacity = (1 << SiS_DRAMType[k][1]) * buswidth * 4;
+		PhysicalAdrHigh = BankNumHigh;
+		PhysicalAdrHalfPage = (PageCapacity / 2 + PhysicalAdrHigh) % PageCapacity;
+		PhysicalAdrOtherPage = PageCapacity * SiS_DRAMType[k][2] + PhysicalAdrHigh;
+
+		andSISIDXREG(SISSR, 0x15, 0xFB); /* Test */
+		orSISIDXREG(SISSR, 0x15, 0x04);  /* Test */
+		sr14 = (SiS_DRAMType[k][3] * buswidth) - 1;
+		if(buswidth == 4)      sr14 |= 0x80;
+		else if(buswidth == 2) sr14 |= 0x40;
+		outSISIDXREG(SISSR, 0x13, SiS_DRAMType[k][4]);
+		outSISIDXREG(SISSR, 0x14, sr14);
+
+		BankNumHigh <<= 16;
+		BankNumMid <<= 16;
+
+		if((BankNumHigh + PhysicalAdrHigh      >= mapsize) ||
+		   (BankNumMid  + PhysicalAdrHigh      >= mapsize) ||
+		   (BankNumHigh + PhysicalAdrHalfPage  >= mapsize) ||
+		   (BankNumHigh + PhysicalAdrOtherPage >= mapsize))
+			continue;
+
+		/* Write data */
+		writew(((unsigned short)PhysicalAdrHigh),
+				(FBAddr + BankNumHigh + PhysicalAdrHigh));
+		writew(((unsigned short)BankNumMid),
+				(FBAddr + BankNumMid  + PhysicalAdrHigh));
+		writew(((unsigned short)PhysicalAdrHalfPage),
+				(FBAddr + BankNumHigh + PhysicalAdrHalfPage));
+		writew(((unsigned short)PhysicalAdrOtherPage),
+				(FBAddr + BankNumHigh + PhysicalAdrOtherPage));
+
+		/* Read data */
+		if(readw(FBAddr + BankNumHigh + PhysicalAdrHigh) == PhysicalAdrHigh)
+			return 1;
+	}
+
+	return 0;
+}
+
+static void __devinit
+sisfb_post_300_ramsize(struct pci_dev *pdev, unsigned int mapsize)
+{
+	struct	sis_video_info *ivideo = pci_get_drvdata(pdev);
+	int	i, j, buswidth;
+	int	PseudoRankCapacity, PseudoAdrPinCount;
+
+	buswidth = sisfb_post_300_buswidth(ivideo);
+
+	for(i = 6; i >= 0; i--) {
+		PseudoRankCapacity = 1 << i;
+		for(j = 4; j >= 1; j--) {
+			PseudoAdrPinCount = 15 - j;
+			if((PseudoRankCapacity * j) <= 64) {
+				if(sisfb_post_300_rwtest(ivideo,
+						j,
+						buswidth,
+						PseudoRankCapacity,
+						PseudoAdrPinCount,
+						mapsize))
+					return;
+			}
+		}
+	}
+}
+
+static void __devinit
+sisfb_post_sis300(struct pci_dev *pdev)
+{
+	struct sis_video_info *ivideo = pci_get_drvdata(pdev);
+	unsigned char *bios = ivideo->SiS_Pr.VirtualRomBase;
+	u8  reg, v1, v2, v3, v4, v5, v6, v7, v8;
+	u16 index, rindex, memtype = 0;
+	unsigned int mapsize;
+
+	if(!ivideo->SiS_Pr.UseROM)
+		bios = NULL;
+
+	outSISIDXREG(SISSR, 0x05, 0x86);
+
+	if(bios) {
+		if(bios[0x52] & 0x80) {
+			memtype = bios[0x52];
+		} else {
+			inSISIDXREG(SISSR, 0x3a, memtype);
+		}
+		memtype &= 0x07;
+	}
+
+	v3 = 0x80; v6 = 0x80;
+	if(ivideo->revision_id <= 0x13) {
+		v1 = 0x44; v2 = 0x42;
+		v4 = 0x44; v5 = 0x42;
+	} else {
+		v1 = 0x68; v2 = 0x43; /* Assume 125Mhz MCLK */
+		v4 = 0x68; v5 = 0x43; /* Assume 125Mhz ECLK */
+		if(bios) {
+			index = memtype * 5;
+			rindex = index + 0x54;
+			v1 = bios[rindex++];
+			v2 = bios[rindex++];
+			v3 = bios[rindex++];
+			rindex = index + 0x7c;
+			v4 = bios[rindex++];
+			v5 = bios[rindex++];
+			v6 = bios[rindex++];
+		}
+	}
+	outSISIDXREG(SISSR, 0x28, v1);
+	outSISIDXREG(SISSR, 0x29, v2);
+	outSISIDXREG(SISSR, 0x2a, v3);
+	outSISIDXREG(SISSR, 0x2e, v4);
+	outSISIDXREG(SISSR, 0x2f, v5);
+	outSISIDXREG(SISSR, 0x30, v6);
+
+	v1 = 0x10;
+	if(bios)
+		v1 = bios[0xa4];
+	outSISIDXREG(SISSR, 0x07, v1);       /* DAC speed */
+
+	outSISIDXREG(SISSR, 0x11, 0x0f);     /* DDC, power save */
+
+	v1 = 0x01; v2 = 0x43; v3 = 0x1e; v4 = 0x2a;
+	v5 = 0x06; v6 = 0x00; v7 = 0x00; v8 = 0x00;
+	if(bios) {
+		memtype += 0xa5;
+		v1 = bios[memtype];
+		v2 = bios[memtype + 8];
+		v3 = bios[memtype + 16];
+		v4 = bios[memtype + 24];
+		v5 = bios[memtype + 32];
+		v6 = bios[memtype + 40];
+		v7 = bios[memtype + 48];
+		v8 = bios[memtype + 56];
+	}
+	if(ivideo->revision_id >= 0x80)
+		v3 &= 0xfd;
+	outSISIDXREG(SISSR, 0x15, v1);       /* Ram type (assuming 0, BIOS 0xa5 step 8) */
+	outSISIDXREG(SISSR, 0x16, v2);
+	outSISIDXREG(SISSR, 0x17, v3);
+	outSISIDXREG(SISSR, 0x18, v4);
+	outSISIDXREG(SISSR, 0x19, v5);
+	outSISIDXREG(SISSR, 0x1a, v6);
+	outSISIDXREG(SISSR, 0x1b, v7);
+	outSISIDXREG(SISSR, 0x1c, v8);	   /* ---- */
+	andSISIDXREG(SISSR, 0x15 ,0xfb);
+	orSISIDXREG(SISSR, 0x15, 0x04);
+	if(bios) {
+		if(bios[0x53] & 0x02) {
+			orSISIDXREG(SISSR, 0x19, 0x20);
+		}
+	}
+	v1 = 0x04;			   /* DAC pedestal (BIOS 0xe5) */
+	if(ivideo->revision_id >= 0x80)
+		v1 |= 0x01;
+	outSISIDXREG(SISSR, 0x1f, v1);
+	outSISIDXREG(SISSR, 0x20, 0xa4);     /* linear & relocated io & disable a0000 */
+	v1 = 0xf6; v2 = 0x0d; v3 = 0x00;
+	if(bios) {
+		v1 = bios[0xe8];
+		v2 = bios[0xe9];
+		v3 = bios[0xea];
+	}
+	outSISIDXREG(SISSR, 0x23, v1);
+	outSISIDXREG(SISSR, 0x24, v2);
+	outSISIDXREG(SISSR, 0x25, v3);
+	outSISIDXREG(SISSR, 0x21, 0x84);
+	outSISIDXREG(SISSR, 0x22, 0x00);
+	outSISIDXREG(SISCR, 0x37, 0x00);
+	orSISIDXREG(SISPART1, 0x24, 0x01);   /* unlock crt2 */
+	outSISIDXREG(SISPART1, 0x00, 0x00);
+	v1 = 0x40; v2 = 0x11;
+	if(bios) {
+		v1 = bios[0xec];
+		v2 = bios[0xeb];
+	}
+	outSISIDXREG(SISPART1, 0x02, v1);
+
+	if(ivideo->revision_id >= 0x80)
+		v2 &= ~0x01;
+
+	inSISIDXREG(SISPART4, 0x00, reg);
+	if((reg == 1) || (reg == 2)) {
+		outSISIDXREG(SISCR, 0x37, 0x02);
+		outSISIDXREG(SISPART2, 0x00, 0x1c);
+		v4 = 0x00; v5 = 0x00; v6 = 0x10;
+		if(ivideo->SiS_Pr.UseROM) {
+			v4 = bios[0xf5];
+			v5 = bios[0xf6];
+			v6 = bios[0xf7];
+		}
+		outSISIDXREG(SISPART4, 0x0d, v4);
+		outSISIDXREG(SISPART4, 0x0e, v5);
+		outSISIDXREG(SISPART4, 0x10, v6);
+		outSISIDXREG(SISPART4, 0x0f, 0x3f);
+		inSISIDXREG(SISPART4, 0x01, reg);
+		if(reg >= 0xb0) {
+			inSISIDXREG(SISPART4, 0x23, reg);
+			reg &= 0x20;
+			reg <<= 1;
+			outSISIDXREG(SISPART4, 0x23, reg);
+		}
+	} else {
+		v2 &= ~0x10;
+	}
+	outSISIDXREG(SISSR, 0x32, v2);
+
+	andSISIDXREG(SISPART1, 0x24, 0xfe);  /* Lock CRT2 */
+
+	inSISIDXREG(SISSR, 0x16, reg);
+	reg &= 0xc3;
+	outSISIDXREG(SISCR, 0x35, reg);
+	outSISIDXREG(SISCR, 0x83, 0x00);
+#if !defined(__i386__) && !defined(__x86_64__)
+	if(sisfb_videoram) {
+		outSISIDXREG(SISSR, 0x13, 0x28);  /* ? */
+		reg = ((sisfb_videoram >> 10) - 1) | 0x40;
+		outSISIDXREG(SISSR, 0x14, reg);
+	} else {
+#endif
+		/* Need to map max FB size for finding out about RAM size */
+		mapsize = 64 << 20;
+		sisfb_post_map_vram(ivideo, &mapsize, 4);
+
+		if(ivideo->video_vbase) {
+			sisfb_post_300_ramsize(pdev, mapsize);
+			iounmap(ivideo->video_vbase);
+		} else {
+			printk(KERN_DEBUG
+				"sisfb: Failed to map memory for size detection, assuming 8MB\n");
+			outSISIDXREG(SISSR, 0x13, 0x28);  /* ? */
+			outSISIDXREG(SISSR, 0x14, 0x47);  /* 8MB, 64bit default */
+		}
+#if !defined(__i386__) && !defined(__x86_64__)
+	}
+#endif
+	if(bios) {
+		v1 = bios[0xe6];
+		v2 = bios[0xe7];
+	} else {
+		inSISIDXREG(SISSR, 0x3a, reg);
+		if((reg & 0x30) == 0x30) {
+			v1 = 0x04; /* PCI */
+			v2 = 0x92;
+		} else {
+			v1 = 0x14; /* AGP */
+			v2 = 0xb2;
+		}
+	}
+	outSISIDXREG(SISSR, 0x21, v1);
+	outSISIDXREG(SISSR, 0x22, v2);
+
+	/* Sense CRT1 */
+	sisfb_sense_crt1(ivideo);
+
+	/* Set default mode, don't clear screen */
+	ivideo->SiS_Pr.SiS_UseOEM = FALSE;
+	SiS_SetEnableDstn(&ivideo->SiS_Pr, FALSE);
+	SiS_SetEnableFstn(&ivideo->SiS_Pr, FALSE);
+	ivideo->curFSTN = ivideo->curDSTN = 0;
+	ivideo->SiS_Pr.VideoMemorySize = 8 << 20;
+	SiSSetMode(&ivideo->SiS_Pr, 0x2e | 0x80);
+
+	outSISIDXREG(SISSR, 0x05, 0x86);
+
+	/* Display off */
+	orSISIDXREG(SISSR, 0x01, 0x20);
+
+	/* Save mode number in CR34 */
+	outSISIDXREG(SISCR, 0x34, 0x2e);
+
+	/* Let everyone know what the current mode is */
+	ivideo->modeprechange = 0x2e;
+}
+#endif
+
+#ifdef CONFIG_FB_SIS_315
+#if 0
+static void __devinit
+sisfb_post_sis315330(struct pci_dev *pdev)
+{
+	/* TODO */
+}
+#endif
+
+static void __devinit
+sisfb_post_xgi_delay(struct sis_video_info *ivideo, int delay)
+{
+	unsigned int i;
+	u8 reg;
+
+	for(i = 0; i <= (delay * 10 * 36); i++) {
+		inSISIDXREG(SISSR, 0x05, reg);
+		reg++;
+	}
+}
+
+static int __devinit
+sisfb_find_host_bridge(struct sis_video_info *ivideo, struct pci_dev *mypdev,
+				unsigned short pcivendor)
+{
+	struct pci_dev *pdev = NULL;
+	unsigned short temp;
+	int ret = 0;
+
+	while((pdev = SIS_PCI_GET_CLASS(PCI_CLASS_BRIDGE_HOST, pdev))) {
+		temp = pdev->vendor;
+		SIS_PCI_PUT_DEVICE(pdev);
+		if(temp == pcivendor) {
+			ret = 1;
+			break;
+		}
+	}
+
+	return ret;
+}
+
+static int __devinit
+sisfb_post_xgi_rwtest(struct sis_video_info *ivideo, int starta,
+			unsigned int enda, unsigned int mapsize)
+{
+	unsigned int pos;
+	int i;
+
+	writel(0, ivideo->video_vbase);
+
+	for(i = starta; i <= enda; i++) {
+		pos = 1 << i;
+		if(pos < mapsize)
+			writel(pos, ivideo->video_vbase + pos);
+	}
+
+	sisfb_post_xgi_delay(ivideo, 150);
+
+	if(readl(ivideo->video_vbase) != 0)
+		return 0;
+
+	for(i = starta; i <= enda; i++) {
+		pos = 1 << i;
+		if(pos < mapsize) {
+			if(readl(ivideo->video_vbase + pos) != pos)
+				return 0;
+		} else
+			return 0;
+	}
+
+	return 1;
+}
+
+static void __devinit
+sisfb_post_xgi_ramsize(struct sis_video_info *ivideo)
+{
+	unsigned int buswidth, ranksize, channelab, mapsize;
+	int i, j, k, l;
+	u8 reg, sr14;
+	static const u8 dramsr13[12 * 5] = {
+		0x02, 0x0e, 0x0b, 0x80, 0x5d,
+		0x02, 0x0e, 0x0a, 0x40, 0x59,
+		0x02, 0x0d, 0x0b, 0x40, 0x4d,
+		0x02, 0x0e, 0x09, 0x20, 0x55,
+		0x02, 0x0d, 0x0a, 0x20, 0x49,
+		0x02, 0x0c, 0x0b, 0x20, 0x3d,
+		0x02, 0x0e, 0x08, 0x10, 0x51,
+		0x02, 0x0d, 0x09, 0x10, 0x45,
+		0x02, 0x0c, 0x0a, 0x10, 0x39,
+		0x02, 0x0d, 0x08, 0x08, 0x41,
+		0x02, 0x0c, 0x09, 0x08, 0x35,
+		0x02, 0x0c, 0x08, 0x04, 0x31
+	};
+	static const u8 dramsr13_4[4 * 5] = {
+		0x02, 0x0d, 0x09, 0x40, 0x45,
+		0x02, 0x0c, 0x09, 0x20, 0x35,
+		0x02, 0x0c, 0x08, 0x10, 0x31,
+		0x02, 0x0b, 0x08, 0x08, 0x21
+	};
@@ -3970,0 +4795,9 @@
+	/* Enable linear mode, disable 0xa0000 address decoding */
+	/* We disable a0000 address decoding, because
+	 * - if running on x86, if the card is disabled, it means
+	 *   that another card is in the system. We don't want
+	 *   to interphere with that primary card's textmode.
+	 * - if running on non-x86, there usually is no VGA window
+	 *   at a0000.
+	 */
+	orSISIDXREG(SISSR, 0x20, (0x80 | 0x04));
@@ -3972,3 +4805,3 @@
-	return 0;
-}
-#endif
+	/* Need to map max FB size for finding out about RAM size */
+	mapsize = 256 << 20;
+	sisfb_post_map_vram(ivideo, &mapsize, 32);
@@ -3976,8 +4809,7 @@
-static UCHAR * __devinit sis_find_rom(struct pci_dev *pdev)
-{
-	struct sis_video_info *ivideo = pci_get_drvdata(pdev);
-	USHORT pciid;
-	int    romptr;
-	UCHAR  *myrombase;
-	u32    temp;
-	SIS_IOTYPE1 *rom_base, *rom;
+	if(!ivideo->video_vbase) {
+		printk(KERN_ERR "sisfb: Unable to detect RAM size. Setting default.\n");
+		outSISIDXREG(SISSR, 0x13, 0x35);
+		outSISIDXREG(SISSR, 0x14, 0x41);
+		/* TODO */
+		return;
+	}
@@ -3985 +4817,89 @@
-	if(!(myrombase = vmalloc(65536))) return NULL;
+	/* Non-interleaving */
+	outSISIDXREG(SISSR, 0x15, 0x00);
+	/* No tiling */
+	outSISIDXREG(SISSR, 0x1c, 0x00);
+
+	if(ivideo->chip == XGI_20) {
+
+		channelab = 1;
+		inSISIDXREG(SISCR, 0x97, reg);
+		if(!(reg & 0x01)) {	/* Single 32/16 */
+			buswidth = 32;
+			outSISIDXREG(SISSR, 0x13, 0xb1);
+			outSISIDXREG(SISSR, 0x14, 0x52);
+			sisfb_post_xgi_delay(ivideo, 1);
+			sr14 = 0x02;
+			if(sisfb_post_xgi_rwtest(ivideo, 23, 24, mapsize))
+				goto bail_out;
+
+			outSISIDXREG(SISSR, 0x13, 0x31);
+			outSISIDXREG(SISSR, 0x14, 0x42);
+			sisfb_post_xgi_delay(ivideo, 1);
+			if(sisfb_post_xgi_rwtest(ivideo, 23, 23, mapsize))
+				goto bail_out;
+
+			buswidth = 16;
+			outSISIDXREG(SISSR, 0x13, 0xb1);
+			outSISIDXREG(SISSR, 0x14, 0x41);
+			sisfb_post_xgi_delay(ivideo, 1);
+			sr14 = 0x01;
+			if(sisfb_post_xgi_rwtest(ivideo, 22, 23, mapsize))
+				goto bail_out;
+			else
+				outSISIDXREG(SISSR, 0x13, 0x31);
+		} else {		/* Dual 16/8 */
+			buswidth = 16;
+			outSISIDXREG(SISSR, 0x13, 0xb1);
+			outSISIDXREG(SISSR, 0x14, 0x41);
+			sisfb_post_xgi_delay(ivideo, 1);
+			sr14 = 0x01;
+			if(sisfb_post_xgi_rwtest(ivideo, 22, 23, mapsize))
+				goto bail_out;
+
+			outSISIDXREG(SISSR, 0x13, 0x31);
+			outSISIDXREG(SISSR, 0x14, 0x31);
+			sisfb_post_xgi_delay(ivideo, 1);
+			if(sisfb_post_xgi_rwtest(ivideo, 22, 22, mapsize))
+				goto bail_out;
+
+			buswidth = 8;
+			outSISIDXREG(SISSR, 0x13, 0xb1);
+			outSISIDXREG(SISSR, 0x14, 0x30);
+			sisfb_post_xgi_delay(ivideo, 1);
+			sr14 = 0x00;
+			if(sisfb_post_xgi_rwtest(ivideo, 21, 22, mapsize))
+				goto bail_out;
+			else
+				outSISIDXREG(SISSR, 0x13, 0x31);
+		}
+
+	} else {	/* XGI_40 */
+
+		inSISIDXREG(SISCR, 0x97, reg);
+		if(!(reg & 0x10)) {
+			inSISIDXREG(SISSR, 0x39, reg);
+			reg >>= 1;
+		}
+
+		if(reg & 0x01) {	/* DDRII */
+			buswidth = 32;
+			if(ivideo->revision_id == 2) {
+				channelab = 2;
+				outSISIDXREG(SISSR, 0x13, 0xa1);
+				outSISIDXREG(SISSR, 0x14, 0x44);
+				sr14 = 0x04;
+				sisfb_post_xgi_delay(ivideo, 1);
+				if(sisfb_post_xgi_rwtest(ivideo, 23, 24, mapsize))
+					goto bail_out;
+
+				outSISIDXREG(SISSR, 0x13, 0x21);
+				outSISIDXREG(SISSR, 0x14, 0x34);
+				if(sisfb_post_xgi_rwtest(ivideo, 22, 23, mapsize))
+					goto bail_out;
+
+				channelab = 1;
+				outSISIDXREG(SISSR, 0x13, 0xa1);
+				outSISIDXREG(SISSR, 0x14, 0x40);
+				sr14 = 0x00;
+				if(sisfb_post_xgi_rwtest(ivideo, 22, 23, mapsize))
+					goto bail_out;
@@ -3987 +4907,31 @@
-#if defined(__i386__) || defined(__x86_64__)
+				outSISIDXREG(SISSR, 0x13, 0x21);
+				outSISIDXREG(SISSR, 0x14, 0x30);
+			} else {
+				channelab = 3;
+				outSISIDXREG(SISSR, 0x13, 0xa1);
+				outSISIDXREG(SISSR, 0x14, 0x4c);
+				sr14 = 0x0c;
+				sisfb_post_xgi_delay(ivideo, 1);
+				if(sisfb_post_xgi_rwtest(ivideo, 23, 25, mapsize))
+					goto bail_out;
+
+				channelab = 2;
+				outSISIDXREG(SISSR, 0x14, 0x48);
+				sisfb_post_xgi_delay(ivideo, 1);
+				sr14 = 0x08;
+				if(sisfb_post_xgi_rwtest(ivideo, 23, 24, mapsize))
+					goto bail_out;
+
+				outSISIDXREG(SISSR, 0x13, 0x21);
+				outSISIDXREG(SISSR, 0x14, 0x3c);
+				sr14 = 0x0c;
+
+				if(sisfb_post_xgi_rwtest(ivideo, 23, 24, mapsize)) {
+					channelab = 3;
+				} else {
+					channelab = 2;
+					outSISIDXREG(SISSR, 0x14, 0x38);
+					sr14 = 0x08;
+				}
+			}
+			sisfb_post_xgi_delay(ivideo, 1);
@@ -3989 +4939 @@
-        for(temp = 0x000c0000; temp < 0x000f0000; temp += 0x00001000) {
+		} else {	/* DDR */
@@ -3991,2 +4941,9 @@
-            rom_base = ioremap(temp, 0x10000);
-	    if(!rom_base) continue;
+			buswidth = 64;
+			if(ivideo->revision_id == 2) {
+				channelab = 1;
+				outSISIDXREG(SISSR, 0x13, 0xa1);
+				outSISIDXREG(SISSR, 0x14, 0x52);
+				sisfb_post_xgi_delay(ivideo, 1);
+				sr14 = 0x02;
+				if(sisfb_post_xgi_rwtest(ivideo, 23, 24, mapsize))
+					goto bail_out;
@@ -3994,4 +4951,10 @@
-	    if((readb(rom_base) != 0x55) || (readb(rom_base + 1) != 0xaa)) {
-	       iounmap(rom_base);
-               continue;
-	    }
+				outSISIDXREG(SISSR, 0x13, 0x21);
+				outSISIDXREG(SISSR, 0x14, 0x42);
+			} else {
+				channelab = 2;
+				outSISIDXREG(SISSR, 0x13, 0xa1);
+				outSISIDXREG(SISSR, 0x14, 0x5a);
+				sisfb_post_xgi_delay(ivideo, 1);
+				sr14 = 0x0a;
+				if(sisfb_post_xgi_rwtest(ivideo, 24, 25, mapsize))
+					goto bail_out;
@@ -3999,5 +4962,4 @@
-	    romptr = (unsigned short)(readb(rom_base + 0x18) | (readb(rom_base + 0x19) << 8));
-	    if(romptr > (0x10000 - 8)) {
-	       iounmap(rom_base);
-	       continue;
-	    }
+				outSISIDXREG(SISSR, 0x13, 0x21);
+				outSISIDXREG(SISSR, 0x14, 0x4a);
+			}
+			sisfb_post_xgi_delay(ivideo, 1);
@@ -4005 +4967,2 @@
-	    rom = rom_base + romptr;
+		}
+	}
@@ -4007,5 +4970,3 @@
-	    if((readb(rom)     != 'P') || (readb(rom + 1) != 'C') ||
-	       (readb(rom + 2) != 'I') || (readb(rom + 3) != 'R')) {
-	       iounmap(rom_base);
-	       continue;
-	    }
+bail_out:
+	setSISIDXREG(SISSR, 0x14, 0xf0, sr14);
+	sisfb_post_xgi_delay(ivideo, 1);
@@ -4013,5 +4974,2 @@
-	    pciid = readb(rom + 4) | (readb(rom + 5) << 8);
-	    if(pciid != 0x1039) {
-	       iounmap(rom_base);
-	       continue;
-	    }
+	j = (ivideo->chip == XGI_20) ? 5 : 9;
+	k = (ivideo->chip == XGI_20) ? 12 : 4;
@@ -4019,6 +4977 @@
-	    pciid = readb(rom + 6) | (readb(rom + 7) << 8);
-	    if(pciid == ivideo->chip_id) {
-	       memcpy_fromio(myrombase, rom_base, 65536);
-	       iounmap(rom_base);
-	       return myrombase;
-	    }
+	for(i = 0; i < k; i++) {
@@ -4026,2 +4979,4 @@
-	    iounmap(rom_base);
-        }
+		reg = (ivideo->chip == XGI_20) ?
+				dramsr13[(i * 5) + 4] : dramsr13_4[(i * 5) + 4];
+		setSISIDXREG(SISSR, 0x13, 0x80, reg);
+		sisfb_post_xgi_delay(ivideo, 50);
@@ -4029 +4984,2 @@
-#else
+		ranksize = (ivideo->chip == XGI_20) ?
+				dramsr13[(i * 5) + 3] : dramsr13_4[(i * 5) + 3];
@@ -4031,3 +4987,2 @@
-	pci_read_config_dword(pdev, PCI_ROM_ADDRESS, &temp);
-	pci_write_config_dword(pdev, PCI_ROM_ADDRESS,
-			(ivideo->video_base & PCI_ROM_ADDRESS_MASK) | PCI_ROM_ADDRESS_ENABLE);
+		inSISIDXREG(SISSR, 0x13, reg);
+		if(reg & 0x80) ranksize <<= 1;
@@ -4035,24 +4990,6 @@
-	rom_base = ioremap(ivideo->video_base, 65536);
-	if(rom_base) {
-	   if((readb(rom_base) == 0x55) && (readb(rom_base + 1) == 0xaa)) {
-	      romptr = (u16)(readb(rom_base + 0x18) | (readb(rom_base + 0x19) << 8));
-	      if(romptr <= (0x10000 - 8)) {
-	         rom = rom_base + romptr;
-		 if((readb(rom)     == 'P') && (readb(rom + 1) == 'C') &&
-		    (readb(rom + 2) == 'I') && (readb(rom + 3) == 'R')) {
-		    pciid = readb(rom + 4) | (readb(rom + 5) << 8);
-		    if(pciid == 0x1039) {
-		       pciid = readb(rom + 6) | (readb(rom + 7) << 8);
-		       if(pciid == ivideo->chip_id) {
-			  memcpy_fromio(myrombase, rom_base, 65536);
-			  iounmap(rom_base);
-			  pci_write_config_dword(pdev, PCI_ROM_ADDRESS, temp);
-			  return myrombase;
-		       }
-		    }
-		 }
-	      }
-	   }
-	   iounmap(rom_base);
-	}
-        pci_write_config_dword(pdev, PCI_ROM_ADDRESS, temp);
+		if(ivideo->chip == XGI_20) {
+			if(buswidth == 16)      ranksize <<= 1;
+			else if(buswidth == 32) ranksize <<= 2;
+		} else {
+			if(buswidth == 64)      ranksize <<= 1;
+		}
@@ -4060 +4997,6 @@
-#endif
+		reg = 0;
+		l = channelab;
+		if(l == 3) l = 4;
+		if((ranksize * l) <= 256) {
+			while((ranksize >>= 1)) reg += 0x10;
+		}
@@ -4062,3 +5004 @@
-       	vfree(myrombase);
-        return NULL;
-}
+		if(!reg) continue;
@@ -4066,8 +5006,2 @@
-#ifdef CONFIG_FB_SIS_300
-static int __devinit
-sisfb_chkbuswidth300(struct pci_dev *pdev, SIS_IOTYPE1 *FBAddress)
-{
-	struct sis_video_info *ivideo = pci_get_drvdata(pdev);
-	int i, j;
-	USHORT temp;
-	UCHAR reg;
+		setSISIDXREG(SISSR, 0x14, 0x0f, (reg & 0xf0));
+		sisfb_post_xgi_delay(ivideo, 1);
@@ -4075,18 +5009,2 @@
-	andSISIDXREG(SISSR,0x15,0xFB);
-	orSISIDXREG(SISSR,0x15,0x04);
-   	outSISIDXREG(SISSR,0x13,0x00);
-   	outSISIDXREG(SISSR,0x14,0xBF);
-
-	for(i=0; i<2; i++) {
-	   temp = 0x1234;
-	   for(j=0; j<4; j++) {
-	      writew(temp, FBAddress);
-	      if(readw(FBAddress) == temp) break;
-	      orSISIDXREG(SISSR,0x3c,0x01);
-	      inSISIDXREG(SISSR,0x05,reg);
-	      inSISIDXREG(SISSR,0x05,reg);
-	      andSISIDXREG(SISSR,0x3c,0xfe);
-	      inSISIDXREG(SISSR,0x05,reg);
-	      inSISIDXREG(SISSR,0x05,reg);
-	      temp++;
-	   }
+		if(sisfb_post_xgi_rwtest(ivideo, j, ((reg >> 4) + channelab - 2 + 20), mapsize))
+			break;
@@ -4095,10 +5013 @@
-	writel(0x01234567L, FBAddress);
-	writel(0x456789ABL, (FBAddress+4));
-	writel(0x89ABCDEFL, (FBAddress+8));
-	writel(0xCDEF0123L, (FBAddress+12));
-	inSISIDXREG(SISSR,0x3b,reg);
-	if(reg & 0x01) {
-	   if(readl((FBAddress+12)) == 0xCDEF0123L) return(4);  /* Channel A 128bit */
-	}
-	if(readl((FBAddress+4)) == 0x456789ABL)     return(2);  /* Channel B 64bit */
-	return(1);						/* 32bit */
+	iounmap(ivideo->video_vbase);
@@ -4108 +5017 @@
-sisfb_setramsize300(struct pci_dev *pdev)
+sisfb_post_xgi_setclocks(struct sis_video_info *ivideo, u8 regb)
@@ -4110,87 +5019,51 @@
-	struct  sis_video_info *ivideo = pci_get_drvdata(pdev);
-  	SIS_IOTYPE1 *FBAddr = ivideo->video_vbase;
-	SIS_IOTYPE1 *Addr;
-	USHORT 	sr13, sr14=0, buswidth, Done, data, TotalCapacity, PhysicalAdrOtherPage=0;
-	int     PseudoRankCapacity, PseudoTotalCapacity, PseudoAdrPinCount;
-   	int     RankCapacity, AdrPinCount, BankNumHigh, BankNumMid, MB2Bank;
-   	int     PageCapacity, PhysicalAdrHigh, PhysicalAdrHalfPage, i, j, k;
-	const 	USHORT SiS_DRAMType[17][5] = {
-			{0x0C,0x0A,0x02,0x40,0x39},
-			{0x0D,0x0A,0x01,0x40,0x48},
-			{0x0C,0x09,0x02,0x20,0x35},
-			{0x0D,0x09,0x01,0x20,0x44},
-			{0x0C,0x08,0x02,0x10,0x31},
-			{0x0D,0x08,0x01,0x10,0x40},
-			{0x0C,0x0A,0x01,0x20,0x34},
-			{0x0C,0x09,0x01,0x08,0x32},
-			{0x0B,0x08,0x02,0x08,0x21},
-			{0x0C,0x08,0x01,0x08,0x30},
-			{0x0A,0x08,0x02,0x04,0x11},
-			{0x0B,0x0A,0x01,0x10,0x28},
-			{0x09,0x08,0x02,0x02,0x01},
-			{0x0B,0x09,0x01,0x08,0x24},
-			{0x0B,0x08,0x01,0x04,0x20},
-			{0x0A,0x08,0x01,0x02,0x10},
-			{0x09,0x08,0x01,0x01,0x00}
-		};
-
-        buswidth = sisfb_chkbuswidth300(pdev, FBAddr);
-
-   	MB2Bank = 16;
-   	Done = 0;
-   	for(i = 6; i >= 0; i--) {
-      	   if(Done) break;
-      	   PseudoRankCapacity = 1 << i;
-      	   for(j = 4; j >= 1; j--) {
-              if(Done) break;
-              PseudoTotalCapacity = PseudoRankCapacity * j;
-              PseudoAdrPinCount = 15 - j;
-              if(PseudoTotalCapacity <= 64) {
-                 for(k = 0; k <= 16; k++) {
-                    if(Done) break;
-                    RankCapacity = buswidth * SiS_DRAMType[k][3];
-                    AdrPinCount = SiS_DRAMType[k][2] + SiS_DRAMType[k][0];
-                    if(RankCapacity == PseudoRankCapacity)
-                       if(AdrPinCount <= PseudoAdrPinCount) {
-                          if(j == 3) {             /* Rank No */
-                             BankNumHigh = RankCapacity * MB2Bank * 3 - 1;
-                             BankNumMid  = RankCapacity * MB2Bank * 1 - 1;
-                          } else {
-                             BankNumHigh = RankCapacity * MB2Bank * j - 1;
-                             BankNumMid  = RankCapacity * MB2Bank * j / 2 - 1;
-                          }
-                          PageCapacity = (1 << SiS_DRAMType[k][1]) * buswidth * 4;
-                          PhysicalAdrHigh = BankNumHigh;
-                          PhysicalAdrHalfPage = (PageCapacity / 2 + PhysicalAdrHigh) % PageCapacity;
-                          PhysicalAdrOtherPage = PageCapacity * SiS_DRAMType[k][2] + PhysicalAdrHigh;
-                          /* Write data */
-                          andSISIDXREG(SISSR,0x15,0xFB); /* Test */
-                          orSISIDXREG(SISSR,0x15,0x04);  /* Test */
-                          TotalCapacity = SiS_DRAMType[k][3] * buswidth;
-                          sr13 = SiS_DRAMType[k][4];
-                          if(buswidth == 4) sr14 = (TotalCapacity - 1) | 0x80;
-                          if(buswidth == 2) sr14 = (TotalCapacity - 1) | 0x40;
-                          if(buswidth == 1) sr14 = (TotalCapacity - 1) | 0x00;
-                          outSISIDXREG(SISSR,0x13,sr13);
-                          outSISIDXREG(SISSR,0x14,sr14);
-                          Addr = FBAddr + BankNumHigh * 64 * 1024 + PhysicalAdrHigh;
-                          /* *((USHORT *)(Addr)) = (USHORT)PhysicalAdrHigh; */
-			  writew(((USHORT)PhysicalAdrHigh), Addr);
-                          Addr = FBAddr + BankNumMid * 64 * 1024 + PhysicalAdrHigh;
-                          /* *((USHORT *)(Addr)) = (USHORT)BankNumMid; */
-			  writew(((USHORT)BankNumMid), Addr);
-                          Addr = FBAddr + BankNumHigh * 64 * 1024 + PhysicalAdrHalfPage;
-                          /* *((USHORT *)(Addr)) = (USHORT)PhysicalAdrHalfPage; */
-			  writew(((USHORT)PhysicalAdrHalfPage), Addr);
-                          Addr = FBAddr + BankNumHigh * 64 * 1024 + PhysicalAdrOtherPage;
-                          /* *((USHORT *)(Addr)) = PhysicalAdrOtherPage; */
-			  writew(((USHORT)PhysicalAdrOtherPage), Addr);
-                          /* Read data */
-                          Addr = FBAddr + BankNumHigh * 64 * 1024 + PhysicalAdrHigh;
-                          data = readw(Addr); /* *((USHORT *)(Addr)); */
-                          if(data == PhysicalAdrHigh) Done = 1;
-                       }  /* if */
-                 }  /* for k */
-              }  /* if */
-      	   }  /* for j */
-   	}  /* for i */
+	u8 v1, v2, v3;
+	int index;
+	static const u8 cs90[8 * 3] = {
+		0x16, 0x01, 0x01,
+		0x3e, 0x03, 0x01,
+		0x7c, 0x08, 0x01,
+		0x79, 0x06, 0x01,
+		0x29, 0x01, 0x81,
+		0x5c, 0x23, 0x01,
+		0x5c, 0x23, 0x01,
+		0x5c, 0x23, 0x01
+	};
+	static const u8 csb8[8 * 3] = {
+		0x5c, 0x23, 0x01,
+		0x29, 0x01, 0x01,
+		0x7c, 0x08, 0x01,
+		0x79, 0x06, 0x01,
+		0x29, 0x01, 0x81,
+		0x5c, 0x23, 0x01,
+		0x5c, 0x23, 0x01,
+		0x5c, 0x23, 0x01
+	};
+
+	regb = 0;  /* ! */
+
+	index = regb * 3;
+	v1 = cs90[index]; v2 = cs90[index + 1]; v3 = cs90[index + 2];
+	if(ivideo->haveXGIROM) {
+		v1 = ivideo->bios_abase[0x90 + index];
+		v2 = ivideo->bios_abase[0x90 + index + 1];
+		v3 = ivideo->bios_abase[0x90 + index + 2];
+	}
+	outSISIDXREG(SISSR, 0x28, v1);
+	outSISIDXREG(SISSR, 0x29, v2);
+	outSISIDXREG(SISSR, 0x2a, v3);
+	sisfb_post_xgi_delay(ivideo, 0x43);
+	sisfb_post_xgi_delay(ivideo, 0x43);
+	sisfb_post_xgi_delay(ivideo, 0x43);
+	index = regb * 3;
+	v1 = csb8[index]; v2 = csb8[index + 1]; v3 = csb8[index + 2];
+	if(ivideo->haveXGIROM) {
+		v1 = ivideo->bios_abase[0xb8 + index];
+		v2 = ivideo->bios_abase[0xb8 + index + 1];
+		v3 = ivideo->bios_abase[0xb8 + index + 2];
+	}
+	outSISIDXREG(SISSR, 0x2e, v1);
+	outSISIDXREG(SISSR, 0x2f, v2);
+	outSISIDXREG(SISSR, 0x30, v3);
+	sisfb_post_xgi_delay(ivideo, 0x43);
+	sisfb_post_xgi_delay(ivideo, 0x43);
+	sisfb_post_xgi_delay(ivideo, 0x43);
@@ -4199 +5072,2 @@
-static void __devinit sisfb_post_sis300(struct pci_dev *pdev)
+static int __devinit
+sisfb_post_xgi(struct pci_dev *pdev)
@@ -4202,2 +5076,61 @@
-	u8  reg, v1, v2, v3, v4, v5, v6, v7, v8;
-	u16 index, rindex, memtype = 0;
+	unsigned char *bios = ivideo->bios_abase;
+	struct pci_dev *mypdev = NULL;
+	const u8 *ptr, *ptr2;
+	u8 v1, v2, v3, v4, v5, reg, ramtype;
+	u32 rega, regb, regd;
+	int i, j, k, index;
+	static const u8 cs78[3] = { 0xf6, 0x0d, 0x00 };
+	static const u8 cs76[2] = { 0xa3, 0xfb };
+	static const u8 cs7b[3] = { 0xc0, 0x11, 0x00 };
+	static const u8 cs158[8] = {
+		0x88, 0xaa, 0x48, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+	static const u8 cs160[8] = {
+		0x44, 0x77, 0x77, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+	static const u8 cs168[8] = {
+		0x48, 0x78, 0x88, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+	static const u8 cs128[3 * 8] = {
+		0x90, 0x28, 0x24, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x77, 0x44, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x77, 0x44, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+	static const u8 cs148[2 * 8] = {
+		0x55, 0x55, 0x55, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+	static const u8 cs31a[8 * 4] = {
+		0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa, 0xaa,
+		0xaa, 0xaa, 0xaa, 0xaa, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+	static const u8 cs33a[8 * 4] = {
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+	static const u8 cs45a[8 * 2] = {
+		0x00, 0x00, 0xa0, 0x00, 0xa0, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+	static const u8 cs170[7 * 8] = {
+		0x54, 0x32, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x54, 0x43, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x0a, 0x05, 0x07, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x44, 0x34, 0x44, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x10, 0x0a, 0x0a, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x11, 0x0c, 0x0c, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x05, 0x05, 0x05, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+	static const u8 cs1a8[3 * 8] = {
+		0xf0, 0xf0, 0xf0, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x05, 0x02, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
+	static const u8 cs100[2 * 8] = {
+		0xc4, 0x04, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00,
+		0xc4, 0x04, 0x84, 0x00, 0x00, 0x00, 0x00, 0x00
+	};
@@ -4205 +5138,13 @@
-	outSISIDXREG(SISSR,0x05,0x86);
+	/* VGA enable */
+	reg = inSISREG(SISVGAENABLE) | 0x01;
+	outSISREG(SISVGAENABLE, reg);
+
+	/* Misc */
+	reg = inSISREG(SISMISCR) | 0x01;
+	outSISREG(SISMISCW, reg);
+
+	/* Unlock SR */
+	outSISIDXREG(SISSR, 0x05, 0x86);
+	inSISIDXREG(SISSR, 0x05, reg);
+	if(reg != 0xa1)
+		return 0;
@@ -4207,7 +5152,10 @@
-	if(ivideo->sishw_ext.UseROM) {
-	   if(ivideo->sishw_ext.pjVirtualRomBase[0x52] & 0x80) {
-	      memtype = ivideo->sishw_ext.pjVirtualRomBase[0x52];
- 	   } else {
-	      inSISIDXREG(SISSR,0x3a,memtype);
-	   }
-	   memtype &= 0x07;
+	/* Clear some regs */
+	for(i = 0; i < 0x22; i++) {
+		if(0x06 + i == 0x20) continue;
+		outSISIDXREG(SISSR, 0x06 + i, 0x00);
+	}
+	for(i = 0; i < 0x0b; i++) {
+		outSISIDXREG(SISSR, 0x31 + i, 0x00);
+	}
+	for(i = 0; i < 0x10; i++) {
+		outSISIDXREG(SISCR, 0x30 + i, 0x00);
@@ -4216,17 +5164,3 @@
-	if(ivideo->revision_id <= 0x13) {
-	   v1 = 0x44; v2 = 0x42; v3 = 0x80;
-	   v4 = 0x44; v5 = 0x42; v6 = 0x80;
-	} else {
-	   v1 = 0x68; v2 = 0x43; v3 = 0x80;  /* Assume 125Mhz MCLK */
-	   v4 = 0x68; v5 = 0x43; v6 = 0x80;  /* Assume 125Mhz ECLK */
-	   if(ivideo->sishw_ext.UseROM) {
-	      index = memtype * 5;
-	      rindex = index + 0x54;
-	      v1 = ivideo->sishw_ext.pjVirtualRomBase[rindex++];
-	      v2 = ivideo->sishw_ext.pjVirtualRomBase[rindex++];
-	      v3 = ivideo->sishw_ext.pjVirtualRomBase[rindex++];
-	      rindex = index + 0x7c;
-	      v4 = ivideo->sishw_ext.pjVirtualRomBase[rindex++];
-	      v5 = ivideo->sishw_ext.pjVirtualRomBase[rindex++];
-	      v6 = ivideo->sishw_ext.pjVirtualRomBase[rindex++];
-	   }
+	ptr = cs78;
+	if(ivideo->haveXGIROM) {
+		ptr = (const u8 *)&bios[0x78];
@@ -4234,38 +5168,2 @@
-	outSISIDXREG(SISSR,0x28,v1);
-	outSISIDXREG(SISSR,0x29,v2);
-	outSISIDXREG(SISSR,0x2a,v3);
-	outSISIDXREG(SISSR,0x2e,v4);
-	outSISIDXREG(SISSR,0x2f,v5);
-	outSISIDXREG(SISSR,0x30,v6);
-	v1 = 0x10;
-	if(ivideo->sishw_ext.UseROM) v1 = ivideo->sishw_ext.pjVirtualRomBase[0xa4];
-	outSISIDXREG(SISSR,0x07,v1);       /* DAC speed */
-	outSISIDXREG(SISSR,0x11,0x0f);     /* DDC, power save */
-	v1 = 0x01; v2 = 0x43; v3 = 0x1e; v4 = 0x2a;
-	v5 = 0x06; v6 = 0x00; v7 = 0x00; v8 = 0x00;
-	if(ivideo->sishw_ext.UseROM) {
-	   memtype += 0xa5;
-	   v1 = ivideo->sishw_ext.pjVirtualRomBase[memtype];
-	   v2 = ivideo->sishw_ext.pjVirtualRomBase[memtype + 8];
-	   v3 = ivideo->sishw_ext.pjVirtualRomBase[memtype + 16];
-	   v4 = ivideo->sishw_ext.pjVirtualRomBase[memtype + 24];
-	   v5 = ivideo->sishw_ext.pjVirtualRomBase[memtype + 32];
-	   v6 = ivideo->sishw_ext.pjVirtualRomBase[memtype + 40];
-	   v7 = ivideo->sishw_ext.pjVirtualRomBase[memtype + 48];
-	   v8 = ivideo->sishw_ext.pjVirtualRomBase[memtype + 56];
-	}
-	if(ivideo->revision_id >= 0x80) v3 &= 0xfd;
-	outSISIDXREG(SISSR,0x15,v1);       /* Ram type (assuming 0, BIOS 0xa5 step 8) */
-	outSISIDXREG(SISSR,0x16,v2);
-	outSISIDXREG(SISSR,0x17,v3);
-	outSISIDXREG(SISSR,0x18,v4);
-	outSISIDXREG(SISSR,0x19,v5);
-	outSISIDXREG(SISSR,0x1a,v6);
-	outSISIDXREG(SISSR,0x1b,v7);
-	outSISIDXREG(SISSR,0x1c,v8);	   /* ---- */
-	andSISIDXREG(SISSR,0x15,0xfb);
-	orSISIDXREG(SISSR,0x15,0x04);
-	if(ivideo->sishw_ext.UseROM) {
-	   if(ivideo->sishw_ext.pjVirtualRomBase[0x53] & 0x02) {
-	      orSISIDXREG(SISSR,0x19,0x20);
-	   }
+	for(i = 0; i < 3; i++) {
+		outSISIDXREG(SISSR, 0x23 + i, ptr[i]);
@@ -4273,48 +5171,4 @@
-	v1 = 0x04;			   /* DAC pedestal (BIOS 0xe5) */
-	if(ivideo->revision_id >= 0x80) v1 |= 0x01;
-	outSISIDXREG(SISSR,0x1f,v1);
-	outSISIDXREG(SISSR,0x20,0xa0);     /* linear & relocated io */
-	v1 = 0xf6; v2 = 0x0d; v3 = 0x00;
-	if(ivideo->sishw_ext.UseROM) {
-	   v1 = ivideo->sishw_ext.pjVirtualRomBase[0xe8];
-	   v2 = ivideo->sishw_ext.pjVirtualRomBase[0xe9];
-	   v3 = ivideo->sishw_ext.pjVirtualRomBase[0xea];
-	}
-	outSISIDXREG(SISSR,0x23,v1);
-	outSISIDXREG(SISSR,0x24,v2);
-	outSISIDXREG(SISSR,0x25,v3);
-	outSISIDXREG(SISSR,0x21,0x84);
-	outSISIDXREG(SISSR,0x22,0x00);
-	outSISIDXREG(SISCR,0x37,0x00);
-	orSISIDXREG(SISPART1,0x24,0x01);   /* unlock crt2 */
-	outSISIDXREG(SISPART1,0x00,0x00);
-	v1 = 0x40; v2 = 0x11;
-	if(ivideo->sishw_ext.UseROM) {
-	   v1 = ivideo->sishw_ext.pjVirtualRomBase[0xec];
-	   v2 = ivideo->sishw_ext.pjVirtualRomBase[0xeb];
-	}
-	outSISIDXREG(SISPART1,0x02,v1);
-	if(ivideo->revision_id >= 0x80) v2 &= ~0x01;
-	inSISIDXREG(SISPART4,0x00,reg);
-	if((reg == 1) || (reg == 2)) {
-	   outSISIDXREG(SISCR,0x37,0x02);
-	   outSISIDXREG(SISPART2,0x00,0x1c);
-	   v4 = 0x00; v5 = 0x00; v6 = 0x10;
-	   if(ivideo->sishw_ext.UseROM) {
-	      v4 = ivideo->sishw_ext.pjVirtualRomBase[0xf5];
-	      v5 = ivideo->sishw_ext.pjVirtualRomBase[0xf6];
-	      v6 = ivideo->sishw_ext.pjVirtualRomBase[0xf7];
-	   }
-	   outSISIDXREG(SISPART4,0x0d,v4);
-	   outSISIDXREG(SISPART4,0x0e,v5);
-	   outSISIDXREG(SISPART4,0x10,v6);
-	   outSISIDXREG(SISPART4,0x0f,0x3f);
-	   inSISIDXREG(SISPART4,0x01,reg);
-	   if(reg >= 0xb0) {
-	      inSISIDXREG(SISPART4,0x23,reg);
-	      reg &= 0x20;
-	      reg <<= 1;
-	      outSISIDXREG(SISPART4,0x23,reg);
-	   }
-	} else {
-	   v2 &= ~0x10;
+
+	ptr = cs76;
+	if(ivideo->haveXGIROM) {
+		ptr = (const u8 *)&bios[0x76];
@@ -4322,24 +5176,2 @@
-	outSISIDXREG(SISSR,0x32,v2);
-	andSISIDXREG(SISPART1,0x24,0xfe);  /* Lock CRT2 */
-	inSISIDXREG(SISSR,0x16,reg);
-	reg &= 0xc3;
-	outSISIDXREG(SISCR,0x35,reg);
-	outSISIDXREG(SISCR,0x83,0x00);
-#if !defined(__i386__) && !defined(__x86_64__)
-	if(sisfb_videoram) {
-	   outSISIDXREG(SISSR,0x13,0x28);  /* ? */
-	   reg = ((sisfb_videoram >> 10) - 1) | 0x40;
-	   outSISIDXREG(SISSR,0x14,reg);
-	} else {
-#endif
-	   /* Need to map max FB size for finding out about RAM size */
-	   ivideo->video_vbase = ioremap(ivideo->video_base, 0x4000000);
-	   if(ivideo->video_vbase) {
-	      sisfb_setramsize300(pdev);
-	      iounmap(ivideo->video_vbase);
-	   } else {
-	      printk(KERN_DEBUG "sisfb: Failed to map memory for size detection, assuming 8MB\n");
-	      outSISIDXREG(SISSR,0x13,0x28);  /* ? */
-	      outSISIDXREG(SISSR,0x14,0x47);  /* 8MB, 64bit default */
-	   }
-#if !defined(__i386__) && !defined(__x86_64__)
+	for(i = 0; i < 2; i++) {
+		outSISIDXREG(SISSR, 0x21 + i, ptr[i]);
@@ -4347,13 +5179,5 @@
-#endif
-	if(ivideo->sishw_ext.UseROM) {
-	   v1 = ivideo->sishw_ext.pjVirtualRomBase[0xe6];
-	   v2 = ivideo->sishw_ext.pjVirtualRomBase[0xe7];
-	} else {
-	   inSISIDXREG(SISSR,0x3a,reg);
-	   if((reg & 0x30) == 0x30) {
-	      v1 = 0x04; /* PCI */
-	      v2 = 0x92;
-	   } else {
-	      v1 = 0x14; /* AGP */
-	      v2 = 0xb2;
-	   }
+
+	v1 = 0x18; v2 = 0x00;
+	if(ivideo->haveXGIROM) {
+		v1 = bios[0x74];
+		v2 = bios[0x75];
@@ -4361,4 +5185,6 @@
-	outSISIDXREG(SISSR,0x21,v1);
-	outSISIDXREG(SISSR,0x22,v2);
-}
-#endif
+	outSISIDXREG(SISSR, 0x07, v1);
+	outSISIDXREG(SISSR, 0x11, 0x0f);
+	outSISIDXREG(SISSR, 0x1f, v2);
+	/* PCI linear mode, RelIO enabled, A0000 decoding disabled */
+	outSISIDXREG(SISSR, 0x20, 0x80 | 0x20 | 0x04);
+	outSISIDXREG(SISSR, 0x27, 0x74);
@@ -4366,9 +5192,22 @@
-#ifdef CONFIG_FB_SIS_315
-static void __devinit sisfb_post_sis315330(struct pci_dev *pdev)
-{
-#ifdef YET_TO_BE_DONE
-	struct sis_video_info *ivideo = pci_get_drvdata(pdev);
-	u8  reg, v1, v2, v3, v4, v5, v6, v7, v8;
-	u16 index, rindex, memtype = 0;
-	u32 reg1_32, reg2_32, reg3_32;
-	int i;
+	ptr = cs7b;
+	if(ivideo->haveXGIROM) {
+		ptr = (const u8 *)&bios[0x7b];
+	}
+	for(i = 0; i < 3; i++) {
+		outSISIDXREG(SISSR, 0x31 + i, ptr[i]);
+	}
+
+	if(ivideo->chip == XGI_40) {
+		if(ivideo->revision_id == 2) {
+			setSISIDXREG(SISSR, 0x3b, 0x3f, 0xc0);
+		}
+		outSISIDXREG(SISCR, 0x7d, 0xfe);
+		outSISIDXREG(SISCR, 0x7e, 0x0f);
+	}
+	if(ivideo->revision_id == 0) {	/* 40 *and* 20? */
+		andSISIDXREG(SISCR, 0x58, 0xd7);
+		inSISIDXREG(SISCR, 0xcb, reg);
+		if(reg & 0x20) {
+			setSISIDXREG(SISCR, 0x58, 0xd7, (reg & 0x10) ? 0x08 : 0x20); /* =0x28 Z7 ? */
+		}
+	}
@@ -4376,7 +5215,2 @@
-	/* Unlock */
-	/* outSISIDXREG(0x3c4,0x05,0x86); */
-	outSISIDXREG(SISSR,0x05,0x86);
-
-	/* Enable relocated i/o ports */
-	/* setSISIDXREG(0x3c4,0x20,~0x10,0x20); */
-	setSISIDXREG(SISSR,0x20,~0x10,0x20);
+	reg = (ivideo->chip == XGI_40) ? 0x20 : 0x00;
+	setSISIDXREG(SISCR, 0x38, 0x1f, reg);
@@ -4384,3 +5218,180 @@
-	/* Clear regs */
-	for(i = 0; i < 0x22; i++) {
-	   outSISIDXREG(SISSR,(0x06 + i),0x00);
+	if(ivideo->chip == XGI_20) {
+		outSISIDXREG(SISSR, 0x36, 0x70);
+	} else {
+		outSISIDXREG(SISVID, 0x00, 0x86);
+		outSISIDXREG(SISVID, 0x32, 0x00);
+		outSISIDXREG(SISVID, 0x30, 0x00);
+		outSISIDXREG(SISVID, 0x32, 0x01);
+		outSISIDXREG(SISVID, 0x30, 0x00);
+		andSISIDXREG(SISVID, 0x2f, 0xdf);
+		andSISIDXREG(SISCAP, 0x00, 0x3f);
+
+		outSISIDXREG(SISPART1, 0x2f, 0x01);
+		outSISIDXREG(SISPART1, 0x00, 0x00);
+		outSISIDXREG(SISPART1, 0x02, bios[0x7e]);
+		outSISIDXREG(SISPART1, 0x2e, 0x08);
+		andSISIDXREG(SISPART1, 0x35, 0x7f);
+		andSISIDXREG(SISPART1, 0x50, 0xfe);
+
+		inSISIDXREG(SISPART4, 0x00, reg);
+		if(reg == 1 || reg == 2) {
+			outSISIDXREG(SISPART2, 0x00, 0x1c);
+			outSISIDXREG(SISPART4, 0x0d, bios[0x7f]);
+			outSISIDXREG(SISPART4, 0x0e, bios[0x80]);
+			outSISIDXREG(SISPART4, 0x10, bios[0x81]);
+			andSISIDXREG(SISPART4, 0x0f, 0x3f);
+
+			inSISIDXREG(SISPART4, 0x01, reg);
+			if((reg & 0xf0) >= 0xb0) {
+				inSISIDXREG(SISPART4, 0x23, reg);
+				if(reg & 0x20) reg |= 0x40;
+				outSISIDXREG(SISPART4, 0x23, reg);
+				reg = (reg & 0x20) ? 0x02 : 0x00;
+				setSISIDXREG(SISPART1, 0x1e, 0xfd, reg);
+			}
+		}
+
+		v1 = bios[0x77];
+
+		inSISIDXREG(SISSR, 0x3b, reg);
+		if(reg & 0x02) {
+			inSISIDXREG(SISSR, 0x3a, reg);
+			v2 = (reg & 0x30) >> 3;
+			if(!(v2 & 0x04)) v2 ^= 0x02;
+			inSISIDXREG(SISSR, 0x39, reg);
+			if(reg & 0x80) v2 |= 0x80;
+			v2 |= 0x01;
+
+			if((mypdev = SIS_PCI_GET_DEVICE(PCI_VENDOR_ID_SI, 0x0730, NULL))) {
+				SIS_PCI_PUT_DEVICE(mypdev);
+				if(((v2 & 0x06) == 2) || ((v2 & 0x06) == 4))
+					v2 &= 0xf9;
+				v2 |= 0x08;
+				v1 &= 0xfe;
+			} else {
+				mypdev = SIS_PCI_GET_DEVICE(PCI_VENDOR_ID_SI, 0x0735, NULL);
+				if(!mypdev)
+					mypdev = SIS_PCI_GET_DEVICE(PCI_VENDOR_ID_SI, 0x0645, NULL);
+				if(!mypdev)
+					mypdev = SIS_PCI_GET_DEVICE(PCI_VENDOR_ID_SI, 0x0650, NULL);
+				if(mypdev) {
+					pci_read_config_dword(mypdev, 0x94, &regd);
+					regd &= 0xfffffeff;
+					pci_write_config_dword(mypdev, 0x94, regd);
+					v1 &= 0xfe;
+					SIS_PCI_PUT_DEVICE(mypdev);
+				} else if(sisfb_find_host_bridge(ivideo, pdev, PCI_VENDOR_ID_SI)) {
+					v1 &= 0xfe;
+				} else if(sisfb_find_host_bridge(ivideo, pdev, 0x1106) ||
+					  sisfb_find_host_bridge(ivideo, pdev, 0x1022) ||
+					  sisfb_find_host_bridge(ivideo, pdev, 0x700e) ||
+					  sisfb_find_host_bridge(ivideo, pdev, 0x10de)) {
+					if((v2 & 0x06) == 4)
+						v2 ^= 0x06;
+					v2 |= 0x08;
+				}
+			}
+			setSISIDXREG(SISCR, 0x5f, 0xf0, v2);
+		}
+		outSISIDXREG(SISSR, 0x22, v1);
+
+		if(ivideo->revision_id == 2) {
+			inSISIDXREG(SISSR, 0x3b, v1);
+			inSISIDXREG(SISSR, 0x3a, v2);
+			regd = bios[0x90 + 3] | (bios[0x90 + 4] << 8);
+			if( (!(v1 & 0x02)) && (v2 & 0x30) && (regd < 0xcf) )
+				setSISIDXREG(SISCR, 0x5f, 0xf1, 0x01);
+
+			if((mypdev = SIS_PCI_GET_DEVICE(0x10de, 0x01e0, NULL))) {
+				/* TODO: set CR5f &0xf1 | 0x01 for version 6570
+				 * of nforce 2 ROM
+				 */
+				if(0)
+					setSISIDXREG(SISCR, 0x5f, 0xf1, 0x01);
+				SIS_PCI_PUT_DEVICE(mypdev);
+			}
+		}
+
+		v1 = 0x30;
+		inSISIDXREG(SISSR, 0x3b, reg);
+		inSISIDXREG(SISCR, 0x5f, v2);
+		if((!(reg & 0x02)) && (v2 & 0x0e))
+			v1 |= 0x08;
+		outSISIDXREG(SISSR, 0x27, v1);
+
+		if(bios[0x64] & 0x01) {
+			setSISIDXREG(SISCR, 0x5f, 0xf0, bios[0x64]);
+		}
+
+		v1 = bios[0x4f7];
+		pci_read_config_dword(pdev, 0x50, &regd);
+		regd = (regd >> 20) & 0x0f;
+		if(regd == 1) {
+			v1 &= 0xfc;
+			orSISIDXREG(SISCR, 0x5f, 0x08);
+		}
+		outSISIDXREG(SISCR, 0x48, v1);
+
+		setSISIDXREG(SISCR, 0x47, 0x04, bios[0x4f6] & 0xfb);
+		setSISIDXREG(SISCR, 0x49, 0xf0, bios[0x4f8] & 0x0f);
+		setSISIDXREG(SISCR, 0x4a, 0x60, bios[0x4f9] & 0x9f);
+		setSISIDXREG(SISCR, 0x4b, 0x08, bios[0x4fa] & 0xf7);
+		setSISIDXREG(SISCR, 0x4c, 0x80, bios[0x4fb] & 0x7f);
+		outSISIDXREG(SISCR, 0x70, bios[0x4fc]);
+		setSISIDXREG(SISCR, 0x71, 0xf0, bios[0x4fd] & 0x0f);
+		outSISIDXREG(SISCR, 0x74, 0xd0);
+		setSISIDXREG(SISCR, 0x74, 0xcf, bios[0x4fe] & 0x30);
+		setSISIDXREG(SISCR, 0x75, 0xe0, bios[0x4ff] & 0x1f);
+		setSISIDXREG(SISCR, 0x76, 0xe0, bios[0x500] & 0x1f);
+		v1 = bios[0x501];
+		if((mypdev = SIS_PCI_GET_DEVICE(0x8086, 0x2530, NULL))) {
+			v1 = 0xf0;
+			SIS_PCI_PUT_DEVICE(mypdev);
+		}
+		outSISIDXREG(SISCR, 0x77, v1);
+	}
+
+	/* RAM type */
+
+	regb = 0;	/* ! */
+
+	v1 = 0xff;
+	if(ivideo->haveXGIROM) {
+		v1 = bios[0x140 + regb];
+	}
+	outSISIDXREG(SISCR, 0x6d, v1);
+
+	ptr = cs128;
+	if(ivideo->haveXGIROM) {
+		ptr = (const u8 *)&bios[0x128];
+	}
+	for(i = 0, j = 0; i < 3; i++, j += 8) {
+		outSISIDXREG(SISCR, 0x68 + i, ptr[j + regb]);
+	}
+
+	ptr  = cs31a;
+	ptr2 = cs33a;
+	if(ivideo->haveXGIROM) {
+		index = (ivideo->chip == XGI_20) ? 0x31a : 0x3a6;
+		ptr  = (const u8 *)&bios[index];
+		ptr2 = (const u8 *)&bios[index + 0x20];
+	}
+	for(i = 0; i < 2; i++) {
+		if(i == 0) {
+			regd = le32_to_cpu(((u32 *)ptr)[regb]);
+			rega = 0x6b;
+		} else {
+			regd = le32_to_cpu(((u32 *)ptr2)[regb]);
+			rega = 0x6e;
+		}
+		reg = 0x00;
+		for(j = 0; j < 16; j++) {
+			reg &= 0xf3;
+			if(regd & 0x01) reg |= 0x04;
+			if(regd & 0x02) reg |= 0x08;
+			regd >>= 2;
+			outSISIDXREG(SISCR, rega, reg);
+			inSISIDXREG(SISCR, rega, reg);
+			inSISIDXREG(SISCR, rega, reg);
+			reg += 0x10;
+		}
@@ -4388,4 +5399,7 @@
-	v1 = 0x0d;
-	if( is 330) v1 = 0x0b;
-	for(i = 0; i < v1; i++) {
-	   outSISIDXREG(SISSR,(0x31 + i),0x00);
+
+	andSISIDXREG(SISCR, 0x6e, 0xfc);
+
+	ptr  = NULL;
+	if(ivideo->haveXGIROM) {
+		index = (ivideo->chip == XGI_20) ? 0x35a : 0x3e6;
+		ptr  = (const u8 *)&bios[index];
@@ -4393,2 +5407,21 @@
-	for(i = 0; i < 0x10; i++) {
-	   outSISIDXREG(SISCR,(0x30 + i),0x00);
+	for(i = 0; i < 4; i++) {
+		setSISIDXREG(SISCR, 0x6e, 0xfc, i);
+		reg = 0x00;
+		for(j = 0; j < 2; j++) {
+			regd = 0;
+			if(ptr) {
+				regd = le32_to_cpu(((u32 *)ptr)[regb * 8]);
+				ptr += 4;
+			}
+			/* reg = 0x00; */
+			for(k = 0; k < 16; k++) {
+				reg &= 0xfc;
+				if(regd & 0x01) reg |= 0x01;
+				if(regd & 0x02) reg |= 0x02;
+				regd >>= 2;
+				outSISIDXREG(SISCR, 0x6f, reg);
+				inSISIDXREG(SISCR, 0x6f, reg);
+				inSISIDXREG(SISCR, 0x6f, reg);
+				reg += 0x08;
+			}
+		}
@@ -4397,36 +5430,6 @@
-	/* Reset clocks */
-	reg = inSISREG(SISMISCR);
-	outSISIDXREG(SISSR,0x28,0x81);
-	outSISIDXREG(SISSR,0x2A,0x00);
-	outSISIDXREG(SISSR,0x29,0xE1);
-	outSISREG(SISMISCW,(reg | 0x0c));
-	outSISIDXREG(SISSR,0x2B,0x81);
-	outSISIDXREG(SISSR,0x2D,0x00);
-	outSISIDXREG(SISSR,0x2C,0xE1);
-	outSISIDXREG(SISSR,0x2E,0x81);
-	outSISIDXREG(SISSR,0x30,0x00);
-	outSISIDXREG(SISSR,0x2F,0xE1);
-	SiS_DDC2Delay(....);
-	outSISREG(SISMISCW,reg);
-
-	/* Get memory type */
-	if(ivideo->sishw_ext.UseROM) {
-	   if(ivideo->sishw_ext.pjVirtualRomBase[0x52] & 0x80)) {
-	      memtype = ivideo->sishw_ext.pjVirtualRomBase[0x52];
- 	   } else {
-	      inSISIDXREG(SISSR,0x3a,memtype);
-	   }
-	   memtype &= 0x03;
-	   if( is 330 ) {
-	      if(memtype <= 1) memtype = 0;
-	      else {
-	         inSISIDXREG(SISCR,0x5F,reg);
-		 reg &= 0x30;
-		 switch(reg) {
-		 case 0x00: memtype = 1; break;
-		 case 0x10: memtype = 3; break;
-		 case 0x20: memtype = 3; break;
-		 default:   memtype = 2;
-		 }
-	      }
-	   }
+	ptr  = cs148;
+	if(ivideo->haveXGIROM) {
+		ptr  = (const u8 *)&bios[0x148];
+	}
+	for(i = 0, j = 0; i < 2; i++, j += 8) {
+		outSISIDXREG(SISCR, 0x80 + i, ptr[j + regb]);
@@ -4435,23 +5438,18 @@
-	/* Set clocks */
-	v1 = 0x3b; v2 = 0x22; v3 = 0x01;  /* Assume 143Mhz MCLK */
-	v4 = 0x5c; v5 = 0x23; v6 = 0x01;  /* Assume 166Mhz ECLK */
-	if(ivideo->sishw_ext.UseROM) {
-	   index = memtype * 5;
-	   rindex = index + 0x54;
-	   v1 = ivideo->sishw_ext.pjVirtualRomBase[rindex++];
-	   v2 = ivideo->sishw_ext.pjVirtualRomBase[rindex++];
-	   v3 = ivideo->sishw_ext.pjVirtualRomBase[rindex++];
-	   rindex = index + 0x68;
-	   v4 = ivideo->sishw_ext.pjVirtualRomBase[rindex++];
-	   v5 = ivideo->sishw_ext.pjVirtualRomBase[rindex++];
-	   v6 = ivideo->sishw_ext.pjVirtualRomBase[rindex++];
-	}
-	outSISIDXREG(SISSR,0x28,v1);
-	outSISIDXREG(SISSR,0x29,v2);
-	outSISIDXREG(SISSR,0x2a,v3);
-	if( is 330 ) {
-	   inSISIDXREG(SISSR,0x3a,reg);
-	   reg &= 0x03;
-	   if(reg >= 2) {
-	      ...
-	   }
+	andSISIDXREG(SISCR, 0x89, 0x8f);
+
+	ptr  = cs45a;
+	if(ivideo->haveXGIROM) {
+		index = (ivideo->chip == XGI_20) ? 0x45a : 0x4e6;
+		ptr  = (const u8 *)&bios[index];
+	}
+	regd = le16_to_cpu(((const u16 *)ptr)[regb]);
+	reg = 0x80;
+	for(i = 0; i < 5; i++) {
+		reg &= 0xfc;
+		if(regd & 0x01) reg |= 0x01;
+		if(regd & 0x02) reg |= 0x02;
+		regd >>= 2;
+		outSISIDXREG(SISCR, 0x89, reg);
+		inSISIDXREG(SISCR, 0x89, reg);
+		inSISIDXREG(SISCR, 0x89, reg);
+		reg += 0x10;
@@ -4459,54 +5456,0 @@
-	outSISIDXREG(SISSR,0x2e,v4);
-	outSISIDXREG(SISSR,0x2f,v5);
-	outSISIDXREG(SISSR,0x30,v6);
-
-	/* End of comp with 330 */
-
-	v1 = 0x18;
-	if(ivideo->sishw_ext.UseROM) v1 = ivideo->sishw_ext.pjVirtualRomBase[0x7c];
-	outSISIDXREG(SISSR,0x07,v1);
-	outSISIDXREG(SISSR,0x11,0x0f);
-
-	v1 = 0x00; v2 = 0x0f; v3 = 0xba; v4 = 0xa9;
-	v5 = 0xa0; v6 = 0x00; v7 = 0x30;
-	if(ivideo->sishw_ext.UseROM) {
-	   index = memtype + 0x7d;
-	   v1 = ivideo->sishw_ext.pjVirtualRomBase[index];
-	   v2 = ivideo->sishw_ext.pjVirtualRomBase[index + 4];
-	   v3 = ivideo->sishw_ext.pjVirtualRomBase[index + 8];
-	   v4 = ivideo->sishw_ext.pjVirtualRomBase[index + 12];
-	   v5 = ivideo->sishw_ext.pjVirtualRomBase[index + 16];
-	   v6 = ivideo->sishw_ext.pjVirtualRomBase[index + 20];
-	   v7 = ivideo->sishw_ext.pjVirtualRomBase[index + 24];
-	}
-	outSISIDXREG(SISSR,0x15,v1);       /* Ram type (assuming 0, BIOS 0x7d step 4) */
-	outSISIDXREG(SISSR,0x16,v2);
-	outSISIDXREG(SISSR,0x17,v3);
-	outSISIDXREG(SISSR,0x18,v4);
-	outSISIDXREG(SISSR,0x19,v5);
-	outSISIDXREG(SISSR,0x1a,v6);
-	outSISIDXREG(SISSR,0x1b,v7);
-	outSISIDXREG(SISSR,0x1c,v8);	   /* ---- */
-
-	v1 = 0x77; v2 = 0x77; v3 = 0x00; v4 = 0x5b; v5 = 0x00;
-	if(ivideo->sishw_ext.UseROM) {
-	   index = memtype + 0xa2;
-	   v1 = ivideo->sishw_ext.pjVirtualRomBase[index];
-	   v2 = ivideo->sishw_ext.pjVirtualRomBase[index + 4];
-	   v3 = ivideo->sishw_ext.pjVirtualRomBase[index + 8];
-	   v4 = ivideo->sishw_ext.pjVirtualRomBase[index + 12];
-	   v5 = ivideo->sishw_ext.pjVirtualRomBase[index + 16];
-	}
-	outSISIDXREG(SISCR,0x40,v1);
-	outSISIDXREG(SISCR,0x41,v2);
-	outSISIDXREG(SISCR,0x42,v3);
-	outSISIDXREG(SISCR,0x43,v4);
-	outSISIDXREG(SISCR,0x44,v5);
-
-	if( is 330 ) {
-
-	   v1 = 0x;
-	   if(ivideo->sishw_ext.UseROM) {
-	      v1 = ivideo->sishw_ext.pjVirtualRomBase[0xBA];
-	   }
-	   outSISIDXREG(SISCR,0x59,v1);
@@ -4514,32 +5458,11 @@
-	   v1 = 0x; v2 = 0x; v3 = 0x; v4 = 0x;
-	   v5 = 0x; v6 = 0x; v7 = 0x; v8 = 0x;
-	   if(ivideo->sishw_ext.UseROM) {
-	      index = memtype + 0xbe;
-	      v1 = ivideo->sishw_ext.pjVirtualRomBase[index];
-	      v2 = ivideo->sishw_ext.pjVirtualRomBase[index + 4];
-	      v3 = ivideo->sishw_ext.pjVirtualRomBase[index + 8];
-	      v4 = ivideo->sishw_ext.pjVirtualRomBase[index + 12];
-	      v5 = ivideo->sishw_ext.pjVirtualRomBase[index + 16];
-	      v6 = ivideo->sishw_ext.pjVirtualRomBase[index + 20];
-	      v7 = ivideo->sishw_ext.pjVirtualRomBase[index + 24];
-	      v8 = ivideo->sishw_ext.pjVirtualRomBase[index + 28];
-	   }
-	   outSISIDXREG(SISCR,0x68,v1);
-	   outSISIDXREG(SISCR,0x69,v2);
-	   outSISIDXREG(SISCR,0x6a,v3);
-	   outSISIDXREG(SISCR,0x6b,v4);
-	   outSISIDXREG(SISCR,0x6c,v5);
-	   outSISIDXREG(SISCR,0x6d,v6);
-	   outSISIDXREG(SISCR,0x6e,v7);
-	   outSISIDXREG(SISCR,0x6f,v8);
-
-	   v1 = 0x20;
-	   inSISIDXREG(SISSR,0x3b,reg);
-
-	   if(!(reg & 0x04)) {
-	      inSISIDXREG(SISCR,0x5F,reg);
-	      reg &= 0x30;
-	      if(reg) v1 = 0x23;
-	   }
-	   outSISIDXREG(SISCR,0x48,v1);
-	   outSISIDXREG(SISCR,0x4c,0x20);
+	v1 = 0xb5; v2 = 0x20; v3 = 0xf0; v4 = 0x13;
+	if(ivideo->haveXGIROM) {
+		v1 = bios[0x118 + regb];
+		v2 = bios[0xf8 + regb];
+		v3 = bios[0x120 + regb];
+		v4 = bios[0x1ca];
+	}
+	outSISIDXREG(SISCR, 0x45, v1 & 0x0f);
+	outSISIDXREG(SISCR, 0x99, (v1 >> 4) & 0x07);
+	orSISIDXREG(SISCR, 0x40, v1 & 0x80);
+	outSISIDXREG(SISCR, 0x41, v2);
@@ -4547,8 +5470,7 @@
-	   xx= xxx();
-	   if(xx >= 1) {
-	      v1 = 0x;
-	      if(ivideo->sishw_ext.UseROM) {
-	         v1 = ivideo->sishw_ext.pjVirtualRomBase[0xBA];
-	      }
-	      outSISIDXREG(SISCR,0x59,v1);
-	   }
+	ptr  = cs170;
+	if(ivideo->haveXGIROM) {
+		ptr  = (const u8 *)&bios[0x170];
+	}
+	for(i = 0, j = 0; i < 7; i++, j += 8) {
+		outSISIDXREG(SISCR, 0x90 + i, ptr[j + regb]);
+	}
@@ -4555,0 +5478 @@
+	outSISIDXREG(SISCR, 0x59, v3);
@@ -4556,0 +5480,7 @@
+	ptr  = cs1a8;
+	if(ivideo->haveXGIROM) {
+		ptr  = (const u8 *)&bios[0x1a8];
+	}
+	for(i = 0, j = 0; i < 3; i++, j += 8) {
+		outSISIDXREG(SISCR, 0xc3 + i, ptr[j + regb]);
+	}
@@ -4558 +5488,7 @@
-	} else {
+	ptr  = cs100;
+	if(ivideo->haveXGIROM) {
+		ptr  = (const u8 *)&bios[0x100];
+	}
+	for(i = 0, j = 0; i < 2; i++, j += 8) {
+		outSISIDXREG(SISCR, 0x8a + i, ptr[j + regb]);
+	}
@@ -4560 +5496 @@
-	   outSISIDXREG(SISCR,0x48,0x23);
+	outSISIDXREG(SISCR, 0xcf, v4);
@@ -4562,47 +5498,2 @@
-	   andSISIDXREG(SISSR,0x16,0x0f);
-	   if(memtype <= 1) {
-	      orSISIDXREG(SISSR,0x16,0x80);
-	   } else {
-	      v1 = 0x0f;
-	      if(ivideo->sishw_ext.UseROM) {
-	         v1 = ivideo->sishw_ext.pjVirtualRomBase[0x81 + memtype];
-	      }
-	      if(!(v1 & 0x10)) v2 = 0xc0;
-	      else             v2 = 0xd0;
-	      orSISIDXREG(SISSR,0x16,v2);
-	      andSISIDXREG(SISSR,0x16,0x0f);
-	      if(!(v1 & 0x10)) v2 = 0x80;
-	      else             v2 = 0xA0;
-	      orSISIDXREG(SISSR,0x16,v2);
- 	   }
-
-	   if(memtype >= 2) {
-	      const u8 sr3cseq1[] = { 0xc0,0xe0,0xf0,0xe0,0xf0,0xa0,0xb0,0xa0,0xb0,0x90,0xd0 };
-	      const u8 sr3cseq2[] = { 0xc0,0xa0,0xb0,0xa0,0xb0,0xe0,0xf0,0xa0,0xb0,0x90,0xd0 };
-	      for(i = 0; i < 11; i++) {
-	         outSISIDXREG(SISSR,0x3c,sr3cseq1[i]);
-	      }
-	      outSISIDXREG(SISSR,0x3d,0x00);
-	      outSISIDXREG(SISSR,0x3d,0x04);
-	      SiS_DDC2Delay(0x200);
-	      v1 = inSISIDXREG(SISCR,0xEC);
-	      v2 = inSISIDXREG(SISCR,0xED);
-	      reg1_32 = (v2 << 8) | v1;
-	      outSISIDXREG(SISSR,0x3D,0x00);
-	      for(i = 0; i < 11; i++) {
-	         outSISIDXREG(SISSR,0x3c,sr3cseq2[i]);
-	      }
-	      outSISIDXREG(SISSR,0x3d,0x00);
-	      outSISIDXREG(SISSR,0x3d,0x04);
-	      SiS_DDC2Delay(0x200);
-	      v1 = inSISIDXREG(SISCR,0xEC);
-	      v2 = inSISIDXREG(SISCR,0xED);
-	      reg2_32 = (v2 << 8) | v1;
-	      outSISIDXREG(SISSR,0x3D,0x00);
-	      reg3_32 = reg2_32 << 1;
-	      reg2_32 >>= 1;
-	      reg3_32 += reg2_32;
-	      v1 = 0x40;
-	      if(reg3_32 > reg1_32) v1 = 0x10;
-	         outSISIDXREG(SISCR,0x59,v1);
-	   }
+	outSISIDXREG(SISCR, 0x83, 0x09);
+	outSISIDXREG(SISCR, 0x87, 0x00);
@@ -4609,0 +5501,5 @@
+	if(ivideo->chip == XGI_40) {
+		if( (ivideo->revision_id == 1) ||
+		    (ivideo->revision_id == 2) ) {
+			outSISIDXREG(SISCR, 0x8c, 0x87);
+		}
@@ -4612,21 +5508,2 @@
-	v1 = 0x00;
-	if(ivideo->sishw_ext.UseROM) {
-	   v1 = ivideo->sishw_ext.pjVirtualRomBase[0x99];
-	}
-	outSISIDXREG(SISSR,0x1f,v1);
-
-	outSISIDXREG(SISSR,0x20,0x20);
-
-	v1 = 0xf6; v2 = 0x0d; v3 = 0x33;
-	if(ivideo->sishw_ext.UseROM) {
-	   v1 = ivideo->sishw_ext.pjVirtualRomBase[0x9c];
-	   v2 = ivideo->sishw_ext.pjVirtualRomBase[0x9d];
-	   v3 = ivideo->sishw_ext.pjVirtualRomBase[0x9e];
-	}
-	outSISIDXREG(SISSR,0x23,v1);
-	outSISIDXREG(SISSR,0x24,v2);
-	outSISIDXREG(SISSR,0x25,v3);
-
-	outSISIDXREG(SISSR,0x21,0x84);
-	outSISIDXREG(SISSR,0x22,0x00);
-	outSISIDXREG(SISSR,0x27,0x1f);
+	outSISIDXREG(SISSR, 0x17, 0x00);
+	outSISIDXREG(SISSR, 0x1a, 0x87);
@@ -4634,32 +5511,3 @@
-	v1 = 0x00; v2 = 0x00;
-	if(ivideo->sishw_ext.UseROM) {
-	   v1 = ivideo->sishw_ext.pjVirtualRomBase[0x9F];
-	   v2 = ivideo->sishw_ext.pjVirtualRomBase[0xA1];
-	}
-	outSISIDXREG(SISSR,0x31,v1);
-	outSISIDXREG(SISSR,0x33,v2);
-
-	v1 = 0x11;
-	if(ivideo->sishw_ext.UseROM) {
-	   v1 = ivideo->sishw_ext.pjVirtualRomBase[0xA0];
-	}
-	v2 = inSISIDXREG(SISPART4,0x00);
-	if((v2 != 1) && (v2 != 2)) v1 &= 0xef;
-	outSISIDXREG(SISSR,0x32,v1);
-
-	/* AGP */
-	pci_read_config_long(pdev, 0x50, &reg1_32);
-	reg1_32 >>= 20;
-	reg1_32 &= 0x0f;
-	if(reg1_32 == 1) {
-	   v1 = 0xAA; v2 = 0x33;
-	   if(ivideo->sishw_ext.UseROM) {
-	      v1 = ivideo->sishw_ext.pjVirtualRomBase[0xF7];
-	      v2 = ivideo->sishw_ext.pjVirtualRomBase[0x9E];
-	   }
-	} else {
-	   v1 = 0x88; v2 = 0x03;
-	   if(ivideo->sishw_ext.UseROM) {
-	      v1 = ivideo->sishw_ext.pjVirtualRomBase[0xF8];
-	      v2 = ivideo->sishw_ext.pjVirtualRomBase[0xF6];
-	   }
+	if(ivideo->chip == XGI_20) {
+		outSISIDXREG(SISSR, 0x15, 0x00);
+		outSISIDXREG(SISSR, 0x1c, 0x00);
@@ -4667,2 +5514,0 @@
-	outSISIDXREG(SISCR,0x49,v1);
-	outSISIDXREG(SISSR,0x25,v2);
@@ -4670,29 +5516,20 @@
-	v1 = inSISIDXREG(SISPART4,0x00);
-	if((v1 == 1) || (v1 == 2)) {
-	   orSISIDXREG(SISPART1,0x2F,0x01);  /* Unlock CRT2 */
-	   outSISIDXREG(SISPART1,0x00,0x00);
-	   v1 = 0x00;
-	   if(ivideo->sishw_ext.UseROM) {
-	      v1 = ivideo->sishw_ext.pjVirtualRomBase[0xb6];
-	   }
-	   outSISIDXREG(SISPART1,0x02,v1);
-	   outSISIDXREG(SISPART1,0x2E,0x08);
-	   outSISIDXREG(SISPART2,0x00,0x1c);
-	   v1 = 0x40; v2 = 0x00; v3 = 0x80;
-	   if(ivideo->sishw_ext.UseROM) {
-	      v1 = ivideo->sishw_ext.pjVirtualRomBase[0xb7];
-	      v2 = ivideo->sishw_ext.pjVirtualRomBase[0xb8];
-	      v3 = ivideo->sishw_ext.pjVirtualRomBase[0xbb];
-	   }
-	   outSISIDXREG(SISPART4,0x0d,v1);
-	   outSISIDXREG(SISPART4,0x0e,v2);
-	   outSISIDXREG(SISPART4,0x10,v3);
-	   outSISIDXREG(SISPART4,0x0F,0x3F);
-
-	   inSISIDXREG(SISPART4,0x01,reg);
-	   if(reg >= 0xb0) {
-	      inSISIDXREG(SISPART4,0x23,reg);
-	      reg &= 0x20;
-	      reg <<= 1;
-	      outSISIDXREG(SISPART4,0x23,reg);
-	   }
+	ramtype = 0x00; v1 = 0x10;
+	if(ivideo->haveXGIROM) {
+		ramtype = bios[0x62];
+		v1 = bios[0x1d2];
+	}
+	if(!(ramtype & 0x80)) {
+		if(ivideo->chip == XGI_20) {
+			outSISIDXREG(SISCR, 0x97, v1);
+			inSISIDXREG(SISCR, 0x97, reg);
+			if(reg & 0x10) {
+				ramtype = (reg & 0x01) << 1;
+			}
+		} else {
+			inSISIDXREG(SISSR, 0x39, reg);
+			ramtype = reg & 0x02;
+			if(!(ramtype)) {
+				inSISIDXREG(SISSR, 0x3a, reg);
+				ramtype = (reg >> 1) & 0x01;
+			}
+		}
@@ -4700 +5537 @@
-	outSISIDXREG(SISCR,0x37,0x02); /* Why? */
+	ramtype &= 0x07;
@@ -4702,21 +5539 @@
-	outSISIDXREG(SISCR,0x83,0x00);
-	outSISIDXREG(SISCR,0x90,0x00);
-	andSISIDXREG(SISSR,0x5B,0xDF);
-	outSISIDXREG(SISVID,0x00,0x86);
-	outSISIDXREG(SISVID,0x32,0x00);
-	outSISIDXREG(SISVID,0x30,0x00);
-	outSISIDXREG(SISVID,0x32,0x01);
-	outSISIDXREG(SISVID,0x30,0x00);
-	orSISIDXREG(SISCR,0x63,0x80);
-	/* End of Init1 */
-
-	/* Set Mode 0x2e */
-
-	/* Ramsize */
-	orSISIDXREG(SISSR,0x16,0x0f);
-	orSISIDXREG(SISSR,0x18,0xA9);
-	orSISIDXREG(SISSR,0x19,0xA0);
-	orSISIDXREG(SISSR,0x1B,0x30);
-	andSISIDXREG(SISSR,0x17,0xF8);
-	orSISIDXREG(SISSR,0x19,0x03);
-	andSIDIDXREG(SISSR,0x13,0x00);
+	regb = 0;	/* ! */
@@ -4724,8 +5541,226 @@
-	/* Need to map max FB size for finding out about RAM size */
-	ivideo->video_vbase = ioremap(ivideo->video_base, 0x4000000);
-	if(ivideo->video_vbase) {
-	   /* Find out about bus width */
-	   if(memtype <= 1) {
-	      outSISIDXREG(SISSR,0x14,0x02);
-	      andSISIDXREG(SISSR,0x16,0x0F);
-	      orSISIDXREG(SISSR,0x16,0x80);
+	switch(ramtype) {
+	case 0:
+		sisfb_post_xgi_setclocks(ivideo, regb);
+		if((ivideo->chip == XGI_20) ||
+		   (ivideo->revision_id == 1)   ||
+		   (ivideo->revision_id == 2)) {
+			v1 = cs158[regb]; v2 = cs160[regb]; v3 = cs168[regb];
+			if(ivideo->haveXGIROM) {
+				v1 = bios[regb + 0x158];
+				v2 = bios[regb + 0x160];
+				v3 = bios[regb + 0x168];
+			}
+			outSISIDXREG(SISCR, 0x82, v1);
+			outSISIDXREG(SISCR, 0x85, v2);
+			outSISIDXREG(SISCR, 0x86, v3);
+		} else {
+			outSISIDXREG(SISCR, 0x82, 0x88);
+			outSISIDXREG(SISCR, 0x86, 0x00);
+			inSISIDXREG(SISCR, 0x86, reg);
+			outSISIDXREG(SISCR, 0x86, 0x88);
+			inSISIDXREG(SISCR, 0x86, reg);
+			outSISIDXREG(SISCR, 0x86, bios[regb + 0x168]);
+			outSISIDXREG(SISCR, 0x82, 0x77);
+			outSISIDXREG(SISCR, 0x85, 0x00);
+			inSISIDXREG(SISCR, 0x85, reg);
+			outSISIDXREG(SISCR, 0x85, 0x88);
+			inSISIDXREG(SISCR, 0x85, reg);
+			outSISIDXREG(SISCR, 0x85, bios[regb + 0x160]);
+			outSISIDXREG(SISCR, 0x82, bios[regb + 0x158]);
+		}
+		if(ivideo->chip == XGI_40) {
+			outSISIDXREG(SISCR, 0x97, 0x00);
+		}
+		outSISIDXREG(SISCR, 0x98, 0x01);
+		outSISIDXREG(SISCR, 0x9a, 0x02);
+
+		outSISIDXREG(SISSR, 0x18, 0x01);
+		if((ivideo->chip == XGI_20) ||
+		   (ivideo->revision_id == 2)) {
+			outSISIDXREG(SISSR, 0x19, 0x40);
+		} else {
+			outSISIDXREG(SISSR, 0x19, 0x20);
+		}
+		outSISIDXREG(SISSR, 0x16, 0x00);
+		outSISIDXREG(SISSR, 0x16, 0x80);
+		if((ivideo->chip == XGI_20) || (bios[0x1cb] != 0x0c)) {
+			sisfb_post_xgi_delay(ivideo, 0x43);
+			sisfb_post_xgi_delay(ivideo, 0x43);
+			sisfb_post_xgi_delay(ivideo, 0x43);
+			outSISIDXREG(SISSR, 0x18, 0x00);
+			if((ivideo->chip == XGI_20) ||
+			   (ivideo->revision_id == 2)) {
+				outSISIDXREG(SISSR, 0x19, 0x40);
+			} else {
+				outSISIDXREG(SISSR, 0x19, 0x20);
+			}
+		} else if((ivideo->chip == XGI_40) && (bios[0x1cb] == 0x0c)) {
+			/* outSISIDXREG(SISSR, 0x16, 0x0c); */ /* ? */
+		}
+		outSISIDXREG(SISSR, 0x16, 0x00);
+		outSISIDXREG(SISSR, 0x16, 0x80);
+		sisfb_post_xgi_delay(ivideo, 4);
+		v1 = 0x31; v2 = 0x03; v3 = 0x83; v4 = 0x03; v5 = 0x83;
+		if(ivideo->haveXGIROM) {
+			v1 = bios[0xf0];
+			index = (ivideo->chip == XGI_20) ? 0x4b2 : 0x53e;
+			v2 = bios[index];
+			v3 = bios[index + 1];
+			v4 = bios[index + 2];
+			v5 = bios[index + 3];
+		}
+		outSISIDXREG(SISSR, 0x18, v1);
+		outSISIDXREG(SISSR, 0x19, ((ivideo->chip == XGI_20) ? 0x02 : 0x01));
+		outSISIDXREG(SISSR, 0x16, v2);
+		outSISIDXREG(SISSR, 0x16, v3);
+		sisfb_post_xgi_delay(ivideo, 0x43);
+		outSISIDXREG(SISSR, 0x1b, 0x03);
+		sisfb_post_xgi_delay(ivideo, 0x22);
+		outSISIDXREG(SISSR, 0x18, v1);
+		outSISIDXREG(SISSR, 0x19, 0x00);
+		outSISIDXREG(SISSR, 0x16, v4);
+		outSISIDXREG(SISSR, 0x16, v5);
+		outSISIDXREG(SISSR, 0x1b, 0x00);
+		break;
+	case 1:
+		outSISIDXREG(SISCR, 0x82, 0x77);
+		outSISIDXREG(SISCR, 0x86, 0x00);
+		inSISIDXREG(SISCR, 0x86, reg);
+		outSISIDXREG(SISCR, 0x86, 0x88);
+		inSISIDXREG(SISCR, 0x86, reg);
+		v1 = cs168[regb]; v2 = cs160[regb]; v3 = cs158[regb];
+		if(ivideo->haveXGIROM) {
+			v1 = bios[regb + 0x168];
+			v2 = bios[regb + 0x160];
+			v3 = bios[regb + 0x158];
+		}
+		outSISIDXREG(SISCR, 0x86, v1);
+		outSISIDXREG(SISCR, 0x82, 0x77);
+		outSISIDXREG(SISCR, 0x85, 0x00);
+		inSISIDXREG(SISCR, 0x85, reg);
+		outSISIDXREG(SISCR, 0x85, 0x88);
+		inSISIDXREG(SISCR, 0x85, reg);
+		outSISIDXREG(SISCR, 0x85, v2);
+		outSISIDXREG(SISCR, 0x82, v3);
+		outSISIDXREG(SISCR, 0x98, 0x01);
+		outSISIDXREG(SISCR, 0x9a, 0x02);
+
+		outSISIDXREG(SISSR, 0x28, 0x64);
+		outSISIDXREG(SISSR, 0x29, 0x63);
+		sisfb_post_xgi_delay(ivideo, 15);
+		outSISIDXREG(SISSR, 0x18, 0x00);
+		outSISIDXREG(SISSR, 0x19, 0x20);
+		outSISIDXREG(SISSR, 0x16, 0x00);
+		outSISIDXREG(SISSR, 0x16, 0x80);
+		outSISIDXREG(SISSR, 0x18, 0xc5);
+		outSISIDXREG(SISSR, 0x19, 0x23);
+		outSISIDXREG(SISSR, 0x16, 0x00);
+		outSISIDXREG(SISSR, 0x16, 0x80);
+		sisfb_post_xgi_delay(ivideo, 1);
+		outSISIDXREG(SISCR, 0x97,0x11);
+		sisfb_post_xgi_setclocks(ivideo, regb);
+		sisfb_post_xgi_delay(ivideo, 0x46);
+		outSISIDXREG(SISSR, 0x18, 0xc5);
+		outSISIDXREG(SISSR, 0x19, 0x23);
+		outSISIDXREG(SISSR, 0x16, 0x00);
+		outSISIDXREG(SISSR, 0x16, 0x80);
+		sisfb_post_xgi_delay(ivideo, 1);
+		outSISIDXREG(SISSR, 0x1b, 0x04);
+		sisfb_post_xgi_delay(ivideo, 1);
+		outSISIDXREG(SISSR, 0x1b, 0x00);
+		sisfb_post_xgi_delay(ivideo, 1);
+		v1 = 0x31;
+		if(ivideo->haveXGIROM) {
+			v1 = bios[0xf0];
+		}
+		outSISIDXREG(SISSR, 0x18, v1);
+		outSISIDXREG(SISSR, 0x19, 0x06);
+		outSISIDXREG(SISSR, 0x16, 0x04);
+		outSISIDXREG(SISSR, 0x16, 0x84);
+		sisfb_post_xgi_delay(ivideo, 1);
+		break;
+	default:
+		sisfb_post_xgi_setclocks(ivideo, regb);
+		if((ivideo->chip == XGI_40) &&
+		   ((ivideo->revision_id == 1) ||
+		    (ivideo->revision_id == 2))) {
+			outSISIDXREG(SISCR, 0x82, bios[regb + 0x158]);
+			outSISIDXREG(SISCR, 0x85, bios[regb + 0x160]);
+			outSISIDXREG(SISCR, 0x86, bios[regb + 0x168]);
+		} else {
+			outSISIDXREG(SISCR, 0x82, 0x88);
+			outSISIDXREG(SISCR, 0x86, 0x00);
+			inSISIDXREG(SISCR, 0x86, reg);
+			outSISIDXREG(SISCR, 0x86, 0x88);
+			outSISIDXREG(SISCR, 0x82, 0x77);
+			outSISIDXREG(SISCR, 0x85, 0x00);
+			inSISIDXREG(SISCR, 0x85, reg);
+			outSISIDXREG(SISCR, 0x85, 0x88);
+			inSISIDXREG(SISCR, 0x85, reg);
+			v1 = cs160[regb]; v2 = cs158[regb];
+			if(ivideo->haveXGIROM) {
+				v1 = bios[regb + 0x160];
+				v2 = bios[regb + 0x158];
+			}
+			outSISIDXREG(SISCR, 0x85, v1);
+			outSISIDXREG(SISCR, 0x82, v2);
+		}
+		if(ivideo->chip == XGI_40) {
+			outSISIDXREG(SISCR, 0x97, 0x11);
+		}
+		if((ivideo->chip == XGI_40) && (ivideo->revision_id == 2)) {
+			outSISIDXREG(SISCR, 0x98, 0x01);
+		} else {
+			outSISIDXREG(SISCR, 0x98, 0x03);
+		}
+		outSISIDXREG(SISCR, 0x9a, 0x02);
+
+		if(ivideo->chip == XGI_40) {
+			outSISIDXREG(SISSR, 0x18, 0x01);
+		} else {
+			outSISIDXREG(SISSR, 0x18, 0x00);
+		}
+		outSISIDXREG(SISSR, 0x19, 0x40);
+		outSISIDXREG(SISSR, 0x16, 0x00);
+		outSISIDXREG(SISSR, 0x16, 0x80);
+		if((ivideo->chip == XGI_40) && (bios[0x1cb] != 0x0c)) {
+			sisfb_post_xgi_delay(ivideo, 0x43);
+			sisfb_post_xgi_delay(ivideo, 0x43);
+			sisfb_post_xgi_delay(ivideo, 0x43);
+			outSISIDXREG(SISSR, 0x18, 0x00);
+			outSISIDXREG(SISSR, 0x19, 0x40);
+			outSISIDXREG(SISSR, 0x16, 0x00);
+			outSISIDXREG(SISSR, 0x16, 0x80);
+		}
+		sisfb_post_xgi_delay(ivideo, 4);
+		v1 = 0x31;
+		if(ivideo->haveXGIROM) {
+			v1 = bios[0xf0];
+		}
+		outSISIDXREG(SISSR, 0x18, v1);
+		outSISIDXREG(SISSR, 0x19, 0x01);
+		if(ivideo->chip == XGI_40) {
+			outSISIDXREG(SISSR, 0x16, bios[0x53e]);
+			outSISIDXREG(SISSR, 0x16, bios[0x53f]);
+		} else {
+			outSISIDXREG(SISSR, 0x16, 0x05);
+			outSISIDXREG(SISSR, 0x16, 0x85);
+		}
+		sisfb_post_xgi_delay(ivideo, 0x43);
+		if(ivideo->chip == XGI_40) {
+			outSISIDXREG(SISSR, 0x1b, 0x01);
+		} else {
+			outSISIDXREG(SISSR, 0x1b, 0x03);
+		}
+		sisfb_post_xgi_delay(ivideo, 0x22);
+		outSISIDXREG(SISSR, 0x18, v1);
+		outSISIDXREG(SISSR, 0x19, 0x00);
+		if(ivideo->chip == XGI_40) {
+			outSISIDXREG(SISSR, 0x16, bios[0x540]);
+			outSISIDXREG(SISSR, 0x16, bios[0x541]);
+		} else {
+			outSISIDXREG(SISSR, 0x16, 0x05);
+			outSISIDXREG(SISSR, 0x16, 0x85);
+		}
+		outSISIDXREG(SISSR, 0x1b, 0x00);
+	}
@@ -4733 +5768,6 @@
-	      ...
+	regb = 0;	/* ! */
+	v1 = 0x03;
+	if(ivideo->haveXGIROM) {
+		v1 = bios[0x110 + regb];
+	}
+	outSISIDXREG(SISSR, 0x1b, v1);
@@ -4735 +5775,9 @@
-	   } else {
+	/* RAM size */
+	v1 = 0x00; v2 = 0x00;
+	if(ivideo->haveXGIROM) {
+		v1 = bios[0x62];
+		v2 = bios[0x63];
+	}
+	regb = 0;	/* ! */
+	regd = 1 << regb;
+	if((v1 & 0x40) && (v2 & regd) && ivideo->haveXGIROM) {
@@ -4737 +5785,2 @@
-	      ...
+		outSISIDXREG(SISSR, 0x13, bios[regb + 0xe0]);
+		outSISIDXREG(SISSR, 0x14, bios[regb + 0xe0 + 8]);
@@ -4739 +5788,17 @@
-	   }
+	} else {
+
+		/* Set default mode, don't clear screen */
+		ivideo->SiS_Pr.SiS_UseOEM = FALSE;
+		SiS_SetEnableDstn(&ivideo->SiS_Pr, FALSE);
+		SiS_SetEnableFstn(&ivideo->SiS_Pr, FALSE);
+		ivideo->curFSTN = ivideo->curDSTN = 0;
+		ivideo->SiS_Pr.VideoMemorySize = 8 << 20;
+		SiSSetMode(&ivideo->SiS_Pr, 0x2e | 0x80);
+
+		outSISIDXREG(SISSR, 0x05, 0x86);
+
+		/* Disable read-cache */
+		andSISIDXREG(SISSR, 0x21, 0xdf);
+		sisfb_post_xgi_ramsize(ivideo);
+		/* Enable read-cache */
+		orSISIDXREG(SISSR, 0x21, 0x20);
@@ -4741 +5806 @@
-	   /* Find out about size */
+	}
@@ -4742,0 +5808,12 @@
+#if 0
+	printk(KERN_DEBUG "-----------------\n");
+	for(i = 0; i < 0xff; i++) {
+		inSISIDXREG(SISCR, i, reg);
+		printk(KERN_DEBUG "CR%02x(%x) = 0x%02x\n", i, SISCR, reg);
+	}
+	for(i = 0; i < 0x40; i++) {
+		inSISIDXREG(SISSR, i, reg);
+		printk(KERN_DEBUG "SR%02x(%x) = 0x%02x\n", i, SISSR, reg);
+	}
+	printk(KERN_DEBUG "-----------------\n");
+#endif
@@ -4744 +5821,3 @@
-	   iounmap(ivideo->video_vbase);
+	/* Sense CRT1 */
+	if(ivideo->chip == XGI_20) {
+		orSISIDXREG(SISCR, 0x32, 0x20);
@@ -4746,2 +5825,6 @@
-	   printk(KERN_DEBUG "sisfb: Failed to map memory for size detection, assuming 8MB\n");
-	   outSISIDXREG(SISSR,0x14,0x??);  /* 8MB, 64bit default */
+		inSISIDXREG(SISPART4, 0x00, reg);
+		if((reg == 1) || (reg == 2)) {
+			sisfb_sense_crt1(ivideo);
+		} else {
+			orSISIDXREG(SISCR, 0x32, 0x20);
+		}
@@ -4750,5 +5833,26 @@
-	/* AGP (Missing: Checks for VIA and AMD hosts) */
-	v1 = 0xA5; v2 = 0xFB;
-	if(ivideo->sishw_ext.UseROM) {
-	   v1 = ivideo->sishw_ext.pjVirtualRomBase[0x9A];
-	   v2 = ivideo->sishw_ext.pjVirtualRomBase[0x9B];
+	/* Set default mode, don't clear screen */
+	ivideo->SiS_Pr.SiS_UseOEM = FALSE;
+	SiS_SetEnableDstn(&ivideo->SiS_Pr, FALSE);
+	SiS_SetEnableFstn(&ivideo->SiS_Pr, FALSE);
+	ivideo->curFSTN = ivideo->curDSTN = 0;
+	SiSSetMode(&ivideo->SiS_Pr, 0x2e | 0x80);
+
+	outSISIDXREG(SISSR, 0x05, 0x86);
+
+	/* Display off */
+	orSISIDXREG(SISSR, 0x01, 0x20);
+
+	/* Save mode number in CR34 */
+	outSISIDXREG(SISCR, 0x34, 0x2e);
+
+	/* Let everyone know what the current mode is */
+	ivideo->modeprechange = 0x2e;
+
+	if(ivideo->chip == XGI_40) {
+		inSISIDXREG(SISCR, 0xca, reg);
+		inSISIDXREG(SISCR, 0xcc, v1);
+		if((reg & 0x10) && (!(v1 & 0x04))) {
+			printk(KERN_ERR
+				"sisfb: Please connect power to the card.\n");
+			return 0;
+		}
@@ -4756,2 +5859,0 @@
-	outSISIDXREG(SISSR,0x21,v1);
-	outSISIDXREG(SISSR,0x22,v2);
@@ -4759,2 +5861 @@
-#endif
-	return;
+	return 1;
@@ -4764,3 +5865,2 @@
-
-static int __devinit sisfb_probe(struct pci_dev *pdev,
-				 const struct pci_device_id *ent)
+static int __devinit
+sisfb_probe(struct pci_dev *pdev, const struct pci_device_id *ent)
@@ -4768,3 +5868,3 @@
-	struct sisfb_chip_info 	*chipinfo = &sisfb_chip_info[ent->driver_data];
-	struct sis_video_info 	*ivideo = NULL;
-	struct fb_info 		*sis_fb_info = NULL;
+	struct sisfb_chip_info	*chipinfo = &sisfb_chip_info[ent->driver_data];
+	struct sis_video_info	*ivideo = NULL;
+	struct fb_info		*sis_fb_info = NULL;
@@ -4773 +5873 @@
-	int sisvga_enabled = 0, i;
+	int i, ret;
@@ -4775 +5875,2 @@
-	if(sisfb_off) return -ENXIO;
+	if(sisfb_off)
+		return -ENXIO;
@@ -4779 +5880,2 @@
-	if(!sis_fb_info) return -ENOMEM;
+	if(!sis_fb_info)
+		return -ENOMEM;
@@ -4782 +5884,2 @@
-	if(!sis_fb_info) return -ENOMEM;
+	if(!sis_fb_info)
+		return -ENOMEM;
@@ -4789,0 +5893,2 @@
+	ivideo->sisfb_id = SISFB_ID;
+
@@ -4791 +5896 @@
-	   ivideo->cardnumber = 0;
+		ivideo->cardnumber = 0;
@@ -4793,3 +5898,4 @@
-	   struct sis_video_info *countvideo = card_list;
-	   ivideo->cardnumber = 1;
-	   while((countvideo = countvideo->next) != NULL) ivideo->cardnumber++;
+		struct sis_video_info *countvideo = card_list;
+		ivideo->cardnumber = 1;
+		while((countvideo = countvideo->next) != 0)
+			ivideo->cardnumber++;
@@ -4801,0 +5908 @@
+	ivideo->chip_vendor = pdev->vendor;
@@ -4803 +5910 @@
-	ivideo->sishw_ext.jChipRevision = ivideo->revision_id;
+	ivideo->SiS_Pr.ChipRevision = ivideo->revision_id;
@@ -4805 +5912 @@
-	sisvga_enabled = reg16 & 0x01;
+	ivideo->sisvga_enabled = reg16 & 0x01;
@@ -4810,0 +5918,3 @@
+#ifdef SIS_OLD_CONFIG_COMPAT
+	ivideo->ioctl32registered = 0;
+#endif
@@ -4829,0 +5940,18 @@
+	ivideo->current_base = 0;
+
+	ivideo->engineok = 0;
+
+	ivideo->sisfb_was_boot_device = 0;
+#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
+	if(pdev->resource[PCI_ROM_RESOURCE].flags & IORESOURCE_ROM_SHADOW) {
+		if(ivideo->sisvga_enabled)
+			ivideo->sisfb_was_boot_device = 1;
+		else {
+			printk(KERN_DEBUG "sisfb: PCI device is disabled, "
+				"but marked as boot video device ???\n");
+			printk(KERN_DEBUG "sisfb: I will not accept this "
+				"as the primary VGA device\n");
+		}
+	}
+#endif
+
@@ -4849 +5976,0 @@
-	ivideo->sisfb_filter = sisfb_filter;
@@ -4857 +5984 @@
-	   ivideo->refresh_rate = ivideo->sisfb_parm_rate;
+		ivideo->refresh_rate = ivideo->sisfb_parm_rate;
@@ -4866,2 +5993,2 @@
-        ivideo->SiS_Pr.SiS_CHOverScan = -1;
-        ivideo->SiS_Pr.SiS_ChSW = FALSE;
+	ivideo->SiS_Pr.SiS_CHOverScan = -1;
+	ivideo->SiS_Pr.SiS_ChSW = FALSE;
@@ -4875,0 +6003 @@
+	ivideo->SiS_Pr.DDCPortMixup = FALSE;
@@ -4878,4 +6006,4 @@
-	   ivideo->SiS_Pr.SiS_MyCR63 = 0x53;
-	   if(ivideo->chip >= SIS_661) {
-	      ivideo->SiS_Pr.SiS_SensibleSR11 = TRUE;
-	   }
+		ivideo->SiS_Pr.SiS_MyCR63 = 0x53;
+		if(ivideo->chip >= SIS_661) {
+			ivideo->SiS_Pr.SiS_SensibleSR11 = TRUE;
+		}
@@ -4894 +6022 @@
-		   	ivideo->chip = SIS_730;
+			ivideo->chip = SIS_730;
@@ -4896 +6024 @@
-		   	break;
+			break;
@@ -4904 +6032 @@
-		   	ivideo->chip = SIS_740;
+			ivideo->chip = SIS_740;
@@ -4908 +6036 @@
-		   	ivideo->chip = SIS_661;
+			ivideo->chip = SIS_661;
@@ -4912 +6040 @@
-		   	ivideo->chip = SIS_741;
+			ivideo->chip = SIS_741;
@@ -4916 +6044 @@
-		   	ivideo->chip = SIS_760;
+			ivideo->chip = SIS_760;
@@ -4918,0 +6047,4 @@
+		case PCI_DEVICE_ID_SI_761:
+			ivideo->chip = SIS_761;
+			strcpy(ivideo->myid, "SiS 761");
+			break;
@@ -4919,0 +6052,2 @@
+		default:
+			break;
@@ -4927 +6061,3 @@
-	ivideo->sishw_ext.jChipType = ivideo->chip;
+	ivideo->SiS_Pr.ChipType = ivideo->chip;
+
+	ivideo->SiS_Pr.ivideo = (void *)ivideo;
@@ -4930,3 +6066,3 @@
-	if((ivideo->sishw_ext.jChipType == SIS_315PRO) ||
-	   (ivideo->sishw_ext.jChipType == SIS_315)) {
-		ivideo->sishw_ext.jChipType = SIS_315H;
+	if((ivideo->SiS_Pr.ChipType == SIS_315PRO) ||
+	   (ivideo->SiS_Pr.ChipType == SIS_315)) {
+		ivideo->SiS_Pr.ChipType = SIS_315H;
@@ -4935,0 +6072,9 @@
+	if(!ivideo->sisvga_enabled) {
+		if(pci_enable_device(pdev)) {
+			if(ivideo->nbridge) SIS_PCI_PUT_DEVICE(ivideo->nbridge);
+			pci_set_drvdata(pdev, NULL);
+			kfree(sis_fb_info);
+			return -EIO;
+		}
+	}
+
@@ -4940 +6085 @@
-	ivideo->sishw_ext.ulIOAddress = ivideo->vga_base = ivideo->SiS_Pr.RelIO;
+	ivideo->SiS_Pr.IOAddress = ivideo->vga_base = ivideo->SiS_Pr.RelIO;
@@ -4942,9 +6087 @@
-	if(!sisvga_enabled) {
-	   	if(pci_enable_device(pdev)) {
-	      		pci_set_drvdata(pdev, NULL);
-	      		kfree(sis_fb_info);
-	      		return -EIO;
-	   	}
-	}
-
-	SiSRegInit(&ivideo->SiS_Pr, ivideo->sishw_ext.ulIOAddress);
+	SiSRegInit(&ivideo->SiS_Pr, ivideo->SiS_Pr.IOAddress);
@@ -4955,11 +6092,20 @@
-	   i=0;
-           do {
-	      if(mychswtable[i].subsysVendor == ivideo->subsysvendor &&
-	         mychswtable[i].subsysCard   == ivideo->subsysdevice) {
-		 ivideo->SiS_Pr.SiS_ChSW = TRUE;
-		 printk(KERN_DEBUG "sisfb: Identified [%s %s] requiring Chrontel/GPIO setup\n",
-		        mychswtable[i].vendorName, mychswtable[i].cardName);
-		 break;
-              }
-              i++;
-           } while(mychswtable[i].subsysVendor != 0);
+		i = 0;
+        	do {
+			if(mychswtable[i].subsysVendor == ivideo->subsysvendor &&
+			   mychswtable[i].subsysCard   == ivideo->subsysdevice) {
+				ivideo->SiS_Pr.SiS_ChSW = TRUE;
+				printk(KERN_DEBUG "sisfb: Identified [%s %s] "
+					"requiring Chrontel/GPIO setup\n",
+					mychswtable[i].vendorName,
+					mychswtable[i].cardName);
+				ivideo->lpcdev = SIS_PCI_GET_DEVICE(PCI_VENDOR_ID_SI, 0x0008, NULL);
+				break;
+			}
+			i++;
+		} while(mychswtable[i].subsysVendor != 0);
+	}
+#endif
+
+#ifdef CONFIG_FB_SIS_315
+	if((ivideo->chip == SIS_760) && (ivideo->nbridge)) {
+		ivideo->lpcdev = SIS_PCI_GET_SLOT(ivideo->nbridge->bus, (2 << 3));
@@ -4969 +6115 @@
-        outSISIDXREG(SISSR, 0x05, 0x86);
+	outSISIDXREG(SISSR, 0x05, 0x86);
@@ -4971 +6117 @@
-	if( (!sisvga_enabled)
+	if( (!ivideo->sisvga_enabled)
@@ -4973 +6119 @@
-		  	      || (sisfb_resetcard)
+			      || (sisfb_resetcard)
@@ -4975,4 +6121,4 @@
-			      			   ) {
-	   	for(i = 0x30; i <= 0x3f; i++) {
-	      		outSISIDXREG(SISCR,i,0x00);
-	   	}
+						   ) {
+		for(i = 0x30; i <= 0x3f; i++) {
+			outSISIDXREG(SISCR, i, 0x00);
+		}
@@ -4983 +6129 @@
-	inSISIDXREG(SISCR,0x34,reg);
+	inSISIDXREG(SISCR, 0x34, reg);
@@ -4986 +6132 @@
-	} else if(sisvga_enabled) {
+	} else if(ivideo->sisvga_enabled) {
@@ -4988 +6134 @@
-		unsigned char SIS_IOTYPE2 *tt = ioremap(0, 0x1000);
+		unsigned char SIS_IOTYPE2 *tt = ioremap(0x400, 0x100);
@@ -4990,2 +6136,2 @@
-		   	ivideo->modeprechange = readb(tt + 0x449);
-		   	iounmap(tt);
+			ivideo->modeprechange = readb(tt + 0x49);
+			iounmap(tt);
@@ -4999,6 +6145,7 @@
-	   if((sisbios_mode[ivideo->sisfb_mode_idx].mode_no[ivideo->mni]) != 0xFF) {
-	      printk(KERN_INFO "sisfb: Cannot initialize display mode, X server is active\n");
-	      pci_set_drvdata(pdev, NULL);
-	      kfree(sis_fb_info);
-	      return -EBUSY;
-	   }
+		if((sisbios_mode[ivideo->sisfb_mode_idx].mode_no[ivideo->mni])
+									!= 0xFF) {
+			printk(KERN_INFO "sisfb: Cannot initialize display mode, "
+					 "X server is active\n");
+			ret = -EBUSY;
+			goto error_4;
+		}
@@ -5006 +6152,0 @@
-#endif	
@@ -5008,11 +6153,0 @@
-
-	ivideo->sishw_ext.bIntegratedMMEnabled = TRUE;
-#ifdef CONFIG_FB_SIS_300
-	if(ivideo->sisvga_engine == SIS_300_VGA) {
-	   if(ivideo->chip != SIS_300) {
-	      inSISIDXREG(SISSR, 0x1a, reg);
-	      if(!(reg & 0x10)) {
-		 ivideo->sishw_ext.bIntegratedMMEnabled = FALSE;
-	      }
-	   }
-	}
@@ -5020,0 +6156 @@
+	/* Search and copy ROM image */
@@ -5021,0 +6158,3 @@
+	ivideo->SiS_Pr.VirtualRomBase = NULL;
+	ivideo->SiS_Pr.UseROM = FALSE;
+	ivideo->haveXGIROM = ivideo->SiS_Pr.SiS_XGIROM = FALSE;
@@ -5023,9 +6162,13 @@
-	    ivideo->sishw_ext.pjVirtualRomBase = sis_find_rom(pdev);
-	    ivideo->bios_abase = ivideo->sishw_ext.pjVirtualRomBase;
-	    if(ivideo->sishw_ext.pjVirtualRomBase) {
-		printk(KERN_INFO "sisfb: Video ROM found and copied\n");
-		ivideo->sishw_ext.UseROM = TRUE;
-	    } else {
-	        ivideo->sishw_ext.UseROM = FALSE;
-	        printk(KERN_INFO "sisfb: Video ROM not found\n");
-	    }
+		ivideo->SiS_Pr.VirtualRomBase = sisfb_find_rom(pdev);
+		ivideo->bios_abase = ivideo->SiS_Pr.VirtualRomBase;
+		ivideo->SiS_Pr.UseROM = (ivideo->SiS_Pr.VirtualRomBase) ? TRUE : FALSE;
+		printk(KERN_INFO "sisfb: Video ROM %sfound\n",
+			ivideo->SiS_Pr.UseROM ? "" : "not ");
+		if((ivideo->SiS_Pr.UseROM) && (ivideo->chip >= XGI_20)) {
+		   ivideo->SiS_Pr.UseROM = FALSE;
+		   ivideo->haveXGIROM = ivideo->SiS_Pr.SiS_XGIROM = TRUE;
+		   if( (ivideo->revision_id == 2) &&
+		       (!(ivideo->bios_abase[0x1d1] & 0x01)) ) {
+			ivideo->SiS_Pr.DDCPortMixup = TRUE;
+		   }
+		}
@@ -5033,3 +6176 @@
-	    ivideo->sishw_ext.pjVirtualRomBase = NULL;
-	    ivideo->sishw_ext.UseROM = FALSE;
-	    printk(KERN_INFO "sisfb: Video ROM usage disabled\n");
+		printk(KERN_INFO "sisfb: Video ROM usage disabled\n");
@@ -5038 +6179 @@
-        /* Find systems for special custom timing */
+	/* Find systems for special custom timing */
@@ -5040,49 +6181 @@
-	   int j;
-	   unsigned char *biosver = NULL;
-           unsigned char *biosdate = NULL;
-	   BOOLEAN footprint;
-	   u32 chksum = 0;
-
-	   if(ivideo->sishw_ext.UseROM) {
-	      biosver = ivideo->sishw_ext.pjVirtualRomBase + 0x06;
-	      biosdate = ivideo->sishw_ext.pjVirtualRomBase + 0x2c;
-              for(i=0; i<32768; i++) chksum += ivideo->sishw_ext.pjVirtualRomBase[i];
-	   }
-
-	   i=0;
-           do {
-	      if( (mycustomttable[i].chipID == ivideo->chip) &&
-	          ((!strlen(mycustomttable[i].biosversion)) ||
-		   (ivideo->sishw_ext.UseROM &&
-		   (!strncmp(mycustomttable[i].biosversion, biosver, strlen(mycustomttable[i].biosversion))))) &&
-	          ((!strlen(mycustomttable[i].biosdate)) ||
-		   (ivideo->sishw_ext.UseROM &&
-		   (!strncmp(mycustomttable[i].biosdate, biosdate, strlen(mycustomttable[i].biosdate))))) &&
-		  ((!mycustomttable[i].bioschksum) ||
-		   (ivideo->sishw_ext.UseROM &&
-	           (mycustomttable[i].bioschksum == chksum)))	&&
-		  (mycustomttable[i].pcisubsysvendor == ivideo->subsysvendor) &&
-		  (mycustomttable[i].pcisubsyscard == ivideo->subsysdevice) ) {
-		 footprint = TRUE;
-	         for(j = 0; j < 5; j++) {
-	            if(mycustomttable[i].biosFootprintAddr[j]) {
-		       if(ivideo->sishw_ext.UseROM) {
-	                  if(ivideo->sishw_ext.pjVirtualRomBase[mycustomttable[i].biosFootprintAddr[j]] !=
-		      		mycustomttable[i].biosFootprintData[j]) {
-		             footprint = FALSE;
-			  }
-		       } else footprint = FALSE;
-		    }
-	         }
-	         if(footprint) {
-	 	    ivideo->SiS_Pr.SiS_CustomT = mycustomttable[i].SpecialID;
-		    printk(KERN_DEBUG "sisfb: Identified [%s %s], special timing applies\n",
-		        mycustomttable[i].vendorName,
-			mycustomttable[i].cardName);
-		    printk(KERN_DEBUG "sisfb: [specialtiming parameter name: %s]\n",
-		    	mycustomttable[i].optionName);
-	            break;
-                 }
-	      }
-              i++;
-           } while(mycustomttable[i].chipID);
+		sisfb_detect_custom_timing(ivideo);
@@ -5091,3 +6184,2 @@
-#ifdef CONFIG_FB_SIS_300
-	if(ivideo->sisvga_engine == SIS_300_VGA) {
-		if( (!sisvga_enabled)
+	/* POST card in case this has not been done by the BIOS */
+	if( (!ivideo->sisvga_enabled)
@@ -5095 +6187 @@
-		    		      || (sisfb_resetcard)
+			     || (sisfb_resetcard)
@@ -5097 +6189,3 @@
-		  					   ) {
+						 ) {
+#ifdef CONFIG_FB_SIS_300
+		if(ivideo->sisvga_engine == SIS_300_VGA) {
@@ -5099,0 +6194 @@
+				ivideo->sisfb_can_post = 1;
@@ -5102 +6196,0 @@
-	}
@@ -5106,7 +6200,3 @@
-	if(ivideo->sisvga_engine == SIS_315_VGA) {
-		if( (!sisvga_enabled)
-#if !defined(__i386__) && !defined(__x86_64__)
-		    		     || (sisfb_resetcard)
-#endif
-		  					  ) {
-			if((ivideo->chip == SIS_315H)   ||
+		if(ivideo->sisvga_engine == SIS_315_VGA) {
+			int result = 1;
+		/*	if((ivideo->chip == SIS_315H)   ||
@@ -5116,0 +6207,14 @@
+			} else */ if(ivideo->chip == XGI_20) {
+				result = sisfb_post_xgi(pdev);
+				ivideo->sisfb_can_post = 1;
+			} else if((ivideo->chip == XGI_40) && ivideo->haveXGIROM) {
+				result = sisfb_post_xgi(pdev);
+				ivideo->sisfb_can_post = 1;
+			} else {
+				printk(KERN_INFO "sisfb: Card is not "
+					"POSTed and sisfb can't do this either.\n");
+			}
+			if(!result) {
+				printk(KERN_ERR "sisfb: Failed to POST card\n");
+				ret = -ENODEV;
+				goto error_3;
@@ -5119 +6222,0 @@
-	}
@@ -5120,0 +6224,3 @@
+	}
+
+	ivideo->sisfb_card_posted = 1;
@@ -5121,0 +6228 @@
+	/* Find out about RAM size */
@@ -5123,5 +6230,3 @@
-		printk(KERN_INFO "sisfb: Fatal error: Unable to determine RAM size.\n");
-		if(ivideo->bios_abase) vfree(ivideo->bios_abase);
-		pci_set_drvdata(pdev, NULL);
-		kfree(sis_fb_info);
-		return -ENODEV;
+		printk(KERN_INFO "sisfb: Fatal error: Unable to determine VRAM size.\n");
+		ret = -ENODEV;
+		goto error_3;
@@ -5129,0 +6235,2 @@
+
+	/* Enable PCI addressing and MMIO */
@@ -5132,4 +6239,4 @@
-	        /* Enable PCI_LINEAR_ADDRESSING and MMIO_ENABLE  */
-	        orSISIDXREG(SISSR, IND_SIS_PCI_ADDRESS_SET, (SIS_PCI_ADDR_ENABLE | SIS_MEM_MAP_IO_ENABLE));
-                /* Enable 2D accelerator engine */
-	        orSISIDXREG(SISSR, IND_SIS_MODULE_ENABLE, SIS_ENABLE_2D);
+		/* Enable PCI_LINEAR_ADDRESSING and MMIO_ENABLE  */
+		orSISIDXREG(SISSR, IND_SIS_PCI_ADDRESS_SET, (SIS_PCI_ADDR_ENABLE | SIS_MEM_MAP_IO_ENABLE));
+		/* Enable 2D accelerator engine */
+		orSISIDXREG(SISSR, IND_SIS_MODULE_ENABLE, SIS_ENABLE_2D);
@@ -5139,3 +6246,5 @@
-	   if(ivideo->sisvga_engine == SIS_300_VGA) sisfb_pdc &= 0x3c;
-	   else				            sisfb_pdc &= 0x1f;
-	   ivideo->SiS_Pr.PDC = sisfb_pdc;
+		if(ivideo->sisvga_engine == SIS_300_VGA)
+			sisfb_pdc &= 0x3c;
+		else
+			sisfb_pdc &= 0x1f;
+		ivideo->SiS_Pr.PDC = sisfb_pdc;
@@ -5145 +6254,2 @@
-	   if(sisfb_pdca != 0xff) ivideo->SiS_Pr.PDCA = sisfb_pdca & 0x1f;
+		if(sisfb_pdca != 0xff)
+			ivideo->SiS_Pr.PDCA = sisfb_pdca & 0x1f;
@@ -5150 +6260,2 @@
-		printk(KERN_ERR "sisfb: Fatal error: Unable to reserve frame buffer memory\n");
+		printk(KERN_ERR "sisfb: Fatal error: Unable to reserve %dMB framebuffer memory\n",
+				(int)(ivideo->video_size >> 20));
@@ -5152,4 +6263,2 @@
-		if(ivideo->bios_abase) vfree(ivideo->bios_abase);
-		pci_set_drvdata(pdev, NULL);
-		kfree(sis_fb_info);
-		return -ENODEV;
+		ret = -ENODEV;
+		goto error_3;
@@ -5160,5 +6269,2 @@
-		release_mem_region(ivideo->video_base, ivideo->video_size);
-		if(ivideo->bios_abase) vfree(ivideo->bios_abase);
-		pci_set_drvdata(pdev, NULL);
-		kfree(sis_fb_info);
-		return -ENODEV;
+		ret = -ENODEV;
+		goto error_2;
@@ -5168 +6274 @@
-	ivideo->sishw_ext.pjVideoMemoryAddress = ivideo->video_vbase;
+	ivideo->SiS_Pr.VideoMemoryAddress = ivideo->video_vbase;
@@ -5170,7 +6276,3 @@
-	   	printk(KERN_ERR "sisfb: Fatal error: Unable to map frame buffer memory\n");
-	   	release_mem_region(ivideo->video_base, ivideo->video_size);
-	   	release_mem_region(ivideo->mmio_base, ivideo->mmio_size);
-		if(ivideo->bios_abase) vfree(ivideo->bios_abase);
-		pci_set_drvdata(pdev, NULL);
-	   	kfree(sis_fb_info);
-	   	return -ENODEV;
+		printk(KERN_ERR "sisfb: Fatal error: Unable to map framebuffer memory\n");
+		ret = -ENODEV;
+		goto error_1;
@@ -5181,5 +6283,13 @@
-	   	printk(KERN_ERR "sisfb: Fatal error: Unable to map MMIO region\n");
-	   	iounmap(ivideo->video_vbase);
-	   	release_mem_region(ivideo->video_base, ivideo->video_size);
-	   	release_mem_region(ivideo->mmio_base, ivideo->mmio_size);
-		if(ivideo->bios_abase) vfree(ivideo->bios_abase);
+		printk(KERN_ERR "sisfb: Fatal error: Unable to map MMIO region\n");
+		ret = -ENODEV;
+error_0:	iounmap(ivideo->video_vbase);
+error_1:	release_mem_region(ivideo->video_base, ivideo->video_size);
+error_2:	release_mem_region(ivideo->mmio_base, ivideo->mmio_size);
+error_3:	vfree(ivideo->bios_abase);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+error_4:
+#endif
+		if(ivideo->lpcdev)
+			SIS_PCI_PUT_DEVICE(ivideo->lpcdev);
+		if(ivideo->nbridge)
+			SIS_PCI_PUT_DEVICE(ivideo->nbridge);
@@ -5187,2 +6297,4 @@
-	   	kfree(sis_fb_info);
-	   	return -ENODEV;
+		if(!ivideo->sisvga_enabled)
+			pci_disable_device(pdev);
+		kfree(sis_fb_info);
+		return ret;
@@ -5191,2 +6303,7 @@
-	printk(KERN_INFO "sisfb: Framebuffer at 0x%lx, mapped to 0x%lx, size %ldk\n",
-	       	ivideo->video_base, (ULONG)ivideo->video_vbase, ivideo->video_size / 1024);
+	printk(KERN_INFO "sisfb: Video RAM at 0x%lx, mapped to 0x%lx, size %ldk\n",
+		ivideo->video_base, (unsigned long)ivideo->video_vbase, ivideo->video_size / 1024);
+
+	if(ivideo->video_offset) {
+		printk(KERN_INFO "sisfb: Viewport offset %ldk\n",
+			ivideo->video_offset / 1024);
+	}
@@ -5195 +6312,25 @@
-	       	ivideo->mmio_base, (ULONG)ivideo->mmio_vbase, ivideo->mmio_size / 1024);
+		ivideo->mmio_base, (unsigned long)ivideo->mmio_vbase, ivideo->mmio_size / 1024);
+
+
+	/* Determine the size of the command queue */
+	if(ivideo->sisvga_engine == SIS_300_VGA) {
+		ivideo->cmdQueueSize = TURBO_QUEUE_AREA_SIZE;
+	} else {
+		if(ivideo->chip == XGI_20) {
+			ivideo->cmdQueueSize = COMMAND_QUEUE_AREA_SIZE_Z7;
+		} else {
+			ivideo->cmdQueueSize = COMMAND_QUEUE_AREA_SIZE;
+		}
+	}
+
+	/* Engines are no longer initialized here; this is
+	 * now done after the first mode-switch (if the
+	 * submitted var has its acceleration flags set).
+	 */
+
+	/* Calculate the base of the (unused) hw cursor */
+	ivideo->hwcursor_vbase = ivideo->video_vbase
+				 + ivideo->video_size
+				 - ivideo->cmdQueueSize
+				 - ivideo->hwcursor_size;
+	ivideo->caps |= HW_CURSOR_CAP;
@@ -5196,0 +6338 @@
+	/* Initialize offscreen memory manager */
@@ -5202 +6344,2 @@
-	ivideo->sishw_ext.ulVideoMemorySize = ivideo->sisfb_mem;
+	ivideo->SiS_Pr.VideoMemoryAddress += ivideo->video_offset;
+	ivideo->SiS_Pr.VideoMemorySize = ivideo->sisfb_mem;
@@ -5204 +6347 @@
-	ivideo->mtrr = 0;
+	ivideo->mtrr = -1;
@@ -5211 +6354,6 @@
-	ivideo->newrom = SiSDetermineROMLayout661(&ivideo->SiS_Pr, &ivideo->sishw_ext);
+	ivideo->newrom = 0;
+	if(ivideo->chip < XGI_20) {
+		if(ivideo->bios_abase) {
+			ivideo->newrom = SiSDetermineROMLayout661(&ivideo->SiS_Pr);
+		}
+	}
@@ -5220 +6368 @@
-		if(ivideo->vbflags & VB_VIDEOBRIDGE) {
+		if(ivideo->vbflags2 & VB2_VIDEOBRIDGE) {
@@ -5226,21 +6374,30 @@
-		if(ivideo->vbflags & VB_VIDEOBRIDGE) {
-		   if(ivideo->sisfb_crt2type != -1) {
-		      if((ivideo->sisfb_crt2type == CRT2_LCD) && (ivideo->vbflags & CRT2_LCD)) {
-		         ivideo->currentvbflags |= CRT2_LCD;
-		      } else if(ivideo->sisfb_crt2type != CRT2_LCD) {
-		         ivideo->currentvbflags |= ivideo->sisfb_crt2type;
-		      }
-		   } else {
-		      /* Chrontel 700x TV detection often unreliable, therefore use a
-		       * different default order on such machines
-		       */
-		      if((ivideo->sisvga_engine == SIS_300_VGA) && (ivideo->vbflags & VB_CHRONTEL)) {
-		         if(ivideo->vbflags & CRT2_LCD)      ivideo->currentvbflags |= CRT2_LCD;
-		         else if(ivideo->vbflags & CRT2_TV)  ivideo->currentvbflags |= CRT2_TV;
-		         else if(ivideo->vbflags & CRT2_VGA) ivideo->currentvbflags |= CRT2_VGA;
-		      } else {
-		         if(ivideo->vbflags & CRT2_TV)       ivideo->currentvbflags |= CRT2_TV;
-		         else if(ivideo->vbflags & CRT2_LCD) ivideo->currentvbflags |= CRT2_LCD;
-		         else if(ivideo->vbflags & CRT2_VGA) ivideo->currentvbflags |= CRT2_VGA;
-		      }
-		   }
+		/* Decide on which CRT2 device to use */
+		if(ivideo->vbflags2 & VB2_VIDEOBRIDGE) {
+			if(ivideo->sisfb_crt2type != -1) {
+				if((ivideo->sisfb_crt2type == CRT2_LCD) &&
+				   (ivideo->vbflags & CRT2_LCD)) {
+					ivideo->currentvbflags |= CRT2_LCD;
+				} else if(ivideo->sisfb_crt2type != CRT2_LCD) {
+					ivideo->currentvbflags |= ivideo->sisfb_crt2type;
+				}
+			} else {
+				/* Chrontel 700x TV detection often unreliable, therefore
+				 * use a different default order on such machines
+				 */
+				if((ivideo->sisvga_engine == SIS_300_VGA) &&
+				   (ivideo->vbflags2 & VB2_CHRONTEL)) {
+					if(ivideo->vbflags & CRT2_LCD)
+						ivideo->currentvbflags |= CRT2_LCD;
+					else if(ivideo->vbflags & CRT2_TV)
+						ivideo->currentvbflags |= CRT2_TV;
+					else if(ivideo->vbflags & CRT2_VGA)
+						ivideo->currentvbflags |= CRT2_VGA;
+				} else {
+					if(ivideo->vbflags & CRT2_TV)
+						ivideo->currentvbflags |= CRT2_TV;
+					else if(ivideo->vbflags & CRT2_LCD)
+						ivideo->currentvbflags |= CRT2_LCD;
+					else if(ivideo->vbflags & CRT2_VGA)
+						ivideo->currentvbflags |= CRT2_VGA;
+				}
+			}
@@ -5250,61 +6407 @@
-		   inSISIDXREG(SISCR, 0x36, reg);
-		   reg &= 0x0f;
-		   if(ivideo->sisvga_engine == SIS_300_VGA) {
-		      ivideo->CRT2LCDType = sis300paneltype[reg];
-		   } else if(ivideo->chip >= SIS_661) {
-		      ivideo->CRT2LCDType = sis661paneltype[reg];
-		   } else {
-		      ivideo->CRT2LCDType = sis310paneltype[reg];
-		      if((ivideo->chip == SIS_550) && (sisfb_fstn)) {
-		         if((ivideo->CRT2LCDType != LCD_640x480_2) &&
-			    (ivideo->CRT2LCDType != LCD_640x480_3)) {
-		      	    ivideo->CRT2LCDType = LCD_320x480;
-			 }
-		      }
-		   }
-		   if(ivideo->CRT2LCDType == LCD_UNKNOWN) {
-		      /* For broken BIOSes: Assume 1024x768, RGB18 */
-		      ivideo->CRT2LCDType = LCD_1024x768;
-		      setSISIDXREG(SISCR,0x36,0xf0,0x02);
-		      setSISIDXREG(SISCR,0x37,0xee,0x01);
-		      printk(KERN_DEBUG "sisfb: Invalid panel ID (%02x), assuming 1024x768, RGB18\n", reg);
-		   }
-		   for(i = 0; i < SIS_LCD_NUMBER; i++) {
-		      if(ivideo->CRT2LCDType == sis_lcd_data[i].lcdtype) {
-		         ivideo->lcdxres = sis_lcd_data[i].xres;
-			 ivideo->lcdyres = sis_lcd_data[i].yres;
-			 ivideo->lcddefmodeidx = sis_lcd_data[i].default_mode_idx;
-			 break;
-		      }
-		   }
-		   if(ivideo->SiS_Pr.SiS_CustomT == CUT_BARCO1366) {
-	   		ivideo->lcdxres = 1360; ivideo->lcdyres = 1024; ivideo->lcddefmodeidx = 99;
-		   } else if(ivideo->SiS_Pr.SiS_CustomT == CUT_PANEL848) {
-	   		ivideo->lcdxres =  848; ivideo->lcdyres =  480; ivideo->lcddefmodeidx = 47;
-		   }
-		   printk(KERN_DEBUG "sisfb: Detected %dx%d flat panel\n",
-		   		ivideo->lcdxres, ivideo->lcdyres);
-		}
-
-#ifdef CONFIG_FB_SIS_300
-                /* Save the current PanelDelayCompensation if the LCD is currently used */
-		if(ivideo->sisvga_engine == SIS_300_VGA) {
-	           if(ivideo->vbflags & (VB_LVDS | VB_30xBDH)) {
-		       int tmp;
-		       inSISIDXREG(SISCR,0x30,tmp);
-		       if(tmp & 0x20) {
-		          /* Currently on LCD? If yes, read current pdc */
-		          inSISIDXREG(SISPART1,0x13,ivideo->detectedpdc);
-			  ivideo->detectedpdc &= 0x3c;
-			  if(ivideo->SiS_Pr.PDC == -1) {
-			     /* Let option override detection */
-			     ivideo->SiS_Pr.PDC = ivideo->detectedpdc;
-			  }
-			  printk(KERN_INFO "sisfb: Detected LCD PDC 0x%02x\n",
-  			         ivideo->detectedpdc);
-		       }
-		       if((ivideo->SiS_Pr.PDC != -1) && (ivideo->SiS_Pr.PDC != ivideo->detectedpdc)) {
-		          printk(KERN_INFO "sisfb: Using LCD PDC 0x%02x\n",
-				 ivideo->SiS_Pr.PDC);
-		       }
-	           }
+			sisfb_detect_lcd_type(ivideo);
@@ -5312 +6408,0 @@
-#endif
@@ -5314,84 +6410 @@
-#ifdef CONFIG_FB_SIS_315
-		if(ivideo->sisvga_engine == SIS_315_VGA) {
-
-		   /* Try to find about LCDA */
-		   if(ivideo->vbflags & (VB_301C | VB_302B | VB_301LV | VB_302LV | VB_302ELV)) {
-		      int tmp;
-		      inSISIDXREG(SISPART1,0x13,tmp);
-		      if(tmp & 0x04) {
-		         ivideo->SiS_Pr.SiS_UseLCDA = TRUE;
-		         ivideo->detectedlcda = 0x03;
-		      }
-	           }
-
-		   /* Save PDC */
-		   if(ivideo->vbflags & (VB_301LV | VB_302LV | VB_302ELV)) {
-		      int tmp;
-		      inSISIDXREG(SISCR,0x30,tmp);
-		      if((tmp & 0x20) || (ivideo->detectedlcda != 0xff)) {
-		         /* Currently on LCD? If yes, read current pdc */
-			 u8 pdc;
-		         inSISIDXREG(SISPART1,0x2D,pdc);
-			 ivideo->detectedpdc  = (pdc & 0x0f) << 1;
-			 ivideo->detectedpdca = (pdc & 0xf0) >> 3;
-			 inSISIDXREG(SISPART1,0x35,pdc);
-			 ivideo->detectedpdc |= ((pdc >> 7) & 0x01);
-			 inSISIDXREG(SISPART1,0x20,pdc);
-			 ivideo->detectedpdca |= ((pdc >> 6) & 0x01);
-			 if(ivideo->newrom) {
-			    /* New ROM invalidates other PDC resp. */
-			    if(ivideo->detectedlcda != 0xff) {
-			       ivideo->detectedpdc = 0xff;
-			    } else {
-			       ivideo->detectedpdca = 0xff;
-			    }
-			 }
-			 if(ivideo->SiS_Pr.PDC == -1) {
-			    if(ivideo->detectedpdc != 0xff) {
-			       ivideo->SiS_Pr.PDC = ivideo->detectedpdc;
-			    }
-			 }
-			 if(ivideo->SiS_Pr.PDCA == -1) {
-			    if(ivideo->detectedpdca != 0xff) {
-			       ivideo->SiS_Pr.PDCA = ivideo->detectedpdca;
-			    }
-			 }
-			 if(ivideo->detectedpdc != 0xff) {
-			    printk(KERN_INFO
-			         "sisfb: Detected LCD PDC 0x%02x (for LCD=CRT2)\n",
-  			          ivideo->detectedpdc);
-			 }
-			 if(ivideo->detectedpdca != 0xff) {
-			    printk(KERN_INFO
-			         "sisfb: Detected LCD PDC1 0x%02x (for LCD=CRT1)\n",
-  			          ivideo->detectedpdca);
-			 }
-		      }
-
-		      /* Save EMI */
-		      if(ivideo->vbflags & (VB_302LV | VB_302ELV)) {
-		         inSISIDXREG(SISPART4,0x30,ivideo->SiS_Pr.EMI_30);
-			 inSISIDXREG(SISPART4,0x31,ivideo->SiS_Pr.EMI_31);
-			 inSISIDXREG(SISPART4,0x32,ivideo->SiS_Pr.EMI_32);
-			 inSISIDXREG(SISPART4,0x33,ivideo->SiS_Pr.EMI_33);
-			 ivideo->SiS_Pr.HaveEMI = TRUE;
-			 if((tmp & 0x20) || (ivideo->detectedlcda != 0xff)) {
-			  	ivideo->SiS_Pr.HaveEMILCD = TRUE;
-			 }
-		      }
-		   }
-
-		   /* Let user override detected PDCs (all bridges) */
-		   if(ivideo->vbflags & (VB_301B | VB_301C | VB_301LV | VB_302LV | VB_302ELV)) {
-		      if((ivideo->SiS_Pr.PDC != -1) && (ivideo->SiS_Pr.PDC != ivideo->detectedpdc)) {
-		         printk(KERN_INFO "sisfb: Using LCD PDC 0x%02x (for LCD=CRT2)\n",
-				 ivideo->SiS_Pr.PDC);
-		      }
-		      if((ivideo->SiS_Pr.PDCA != -1) && (ivideo->SiS_Pr.PDCA != ivideo->detectedpdca)) {
-		         printk(KERN_INFO "sisfb: Using LCD PDC1 0x%02x (for LCD=CRT1)\n",
-				 ivideo->SiS_Pr.PDCA);
-		      }
-		   }
-
-		}
-#endif
+		sisfb_save_pdc_emi(ivideo);
@@ -5400 +6413 @@
-		   	sisfb_handle_ddc(ivideo, &ivideo->sisfb_thismonitor, 0);
+			sisfb_handle_ddc(ivideo, &ivideo->sisfb_thismonitor, 0);
@@ -5402,4 +6415,4 @@
-		   	if((ivideo->vbflags & (VB_301|VB_301B|VB_301C|VB_302B)) &&
-		      	   (ivideo->vbflags & (CRT2_VGA | CRT2_LCD))) {
-		      		sisfb_handle_ddc(ivideo, &ivideo->sisfb_thismonitor, 1);
-		   	}
+			if((ivideo->vbflags2 & VB2_SISTMDSBRIDGE) &&
+			   (ivideo->vbflags & (CRT2_VGA | CRT2_LCD))) {
+				sisfb_handle_ddc(ivideo, &ivideo->sisfb_thismonitor, 1);
+			}
@@ -5437 +6450,2 @@
-			sisfb_search_refresh_rate(ivideo, ivideo->refresh_rate, ivideo->sisfb_mode_idx);
+			sisfb_search_refresh_rate(ivideo, ivideo->refresh_rate,
+						ivideo->sisfb_mode_idx);
@@ -5446,3 +6460,6 @@
-			if(!sisfb_verify_rate(ivideo, &ivideo->sisfb_thismonitor, ivideo->sisfb_mode_idx,
-			                      ivideo->rate_idx, ivideo->refresh_rate)) {
-				printk(KERN_INFO "sisfb: WARNING: Refresh rate exceeds monitor specs!\n");
+			if(!sisfb_verify_rate(ivideo, &ivideo->sisfb_thismonitor,
+						ivideo->sisfb_mode_idx,
+						ivideo->rate_idx,
+						ivideo->refresh_rate)) {
+				printk(KERN_INFO "sisfb: WARNING: Refresh rate "
+							"exceeds monitor specs!\n");
@@ -5457,2 +6473,0 @@
-		
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)	
@@ -5460,4 +6475,6 @@
-		/* ---------------- For 2.4: Now switch the mode ------------------ */		
-		
-		printk(KERN_INFO "sisfb: Mode is %dx%dx%d (%dHz)\n",
-	       		ivideo->video_width, ivideo->video_height, ivideo->video_bpp,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+
+		/* ---------------- For 2.4: Now switch the mode ------------------ */
+
+		printk(KERN_INFO "sisfb: Setting mode %dx%dx%d (%dHz)\n",
+			ivideo->video_width, ivideo->video_height, ivideo->video_bpp,
@@ -5465,0 +6483,11 @@
+		/* Determine whether or not acceleration is to be
+		 * used. Need to know before pre/post_set_mode()
+		 */
+		ivideo->accel = 0;
+		ivideo->default_var.accel_flags &= ~FB_ACCELF_TEXT;
+		if(ivideo->sisfb_accel) {
+			ivideo->accel = -1;
+			ivideo->default_var.accel_flags |= FB_ACCELF_TEXT;
+		}
+
+		/* Now switch the mode */
@@ -5468 +6496 @@
-		if(SiSSetMode(&ivideo->SiS_Pr, &ivideo->sishw_ext, ivideo->mode_no) == 0) {
+		if(SiSSetMode(&ivideo->SiS_Pr, ivideo->mode_no) == 0) {
@@ -5471 +6499 @@
-			iounmap(ivideo->video_vbase);
+			ret = -EINVAL;
@@ -5473,6 +6501 @@
-			release_mem_region(ivideo->video_base, ivideo->video_size);
-			release_mem_region(ivideo->mmio_base, ivideo->mmio_size);
-			if(ivideo->bios_abase) vfree(ivideo->bios_abase);
-			pci_set_drvdata(pdev, NULL);
-			kfree(sis_fb_info);
-			return -EINVAL;
+			goto error_0;
@@ -5490,0 +6514 @@
+		/* Copy mode timing to var */
@@ -5492,0 +6517 @@
+		/* Find out about screen pitch */
@@ -5496,5 +6521 @@
-		ivideo->accel = 0;
-		if(ivideo->sisfb_accel) {
-		   ivideo->accel = -1;
-		   ivideo->default_var.accel_flags |= FB_ACCELF_TEXT;
-		}
+		/* Init the accelerator (does nothing currently) */
@@ -5502 +6523,2 @@
-		
+
+		/* Init some fbinfo entries */
@@ -5518 +6540 @@
-	       		ivideo->video_width, ivideo->video_height, ivideo->video_bpp,
+			ivideo->video_width, ivideo->video_height, ivideo->video_bpp,
@@ -5520,0 +6543 @@
+		/* Set up the default var according to chosen default display mode */
@@ -5526 +6549 @@
-		
+
@@ -5528,9 +6551,8 @@
-				sisfb_mode_rate_to_dclock(&ivideo->SiS_Pr, &ivideo->sishw_ext,
-						ivideo->mode_no, ivideo->rate_idx));
-						
-		if(sisfb_mode_rate_to_ddata(&ivideo->SiS_Pr, &ivideo->sishw_ext,
-			 	ivideo->mode_no, ivideo->rate_idx, &ivideo->default_var)) {
-		   if((ivideo->default_var.vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {
-		      ivideo->default_var.pixclock <<= 1;
-	   	   }
-	        }
+			sisfb_mode_rate_to_dclock(&ivideo->SiS_Pr, ivideo->mode_no, ivideo->rate_idx));
+
+		if(sisfb_mode_rate_to_ddata(&ivideo->SiS_Pr, ivideo->mode_no,
+						ivideo->rate_idx, &ivideo->default_var)) {
+			if((ivideo->default_var.vmode & FB_VMODE_MASK) == FB_VMODE_DOUBLE) {
+				ivideo->default_var.pixclock <<= 1;
+			}
+		}
@@ -5539,5 +6561,6 @@
-		   /* Maximize regardless of sisfb_max at startup */
-	    	   ivideo->default_var.yres_virtual = sisfb_calc_maxyres(ivideo, &ivideo->default_var);
-	    	   if(ivideo->default_var.yres_virtual < ivideo->default_var.yres) {
-	              ivideo->default_var.yres_virtual = ivideo->default_var.yres;
-	    	   }
+			/* Maximize regardless of sisfb_max at startup */
+			ivideo->default_var.yres_virtual =
+				sisfb_calc_maxyres(ivideo, &ivideo->default_var);
+			if(ivideo->default_var.yres_virtual < ivideo->default_var.yres) {
+				ivideo->default_var.yres_virtual = ivideo->default_var.yres;
+			}
@@ -5550 +6573 @@
-		   ivideo->accel = -1;
+			ivideo->accel = -1;
@@ -5552 +6575 @@
-		   ivideo->default_var.accel_flags |= FB_ACCELF_TEXT;
+			ivideo->default_var.accel_flags |= FB_ACCELF_TEXT;
@@ -5569 +6592 @@
-		sis_fb_info->screen_base = ivideo->video_vbase;
+		sis_fb_info->screen_base = ivideo->video_vbase + ivideo->video_offset;
@@ -5574 +6597 @@
-		
+
@@ -5578 +6601 @@
-		printk(KERN_DEBUG "sisfb: Initial vbflags 0x%lx\n", (unsigned long)ivideo->vbflags);
+		printk(KERN_DEBUG "sisfb: Initial vbflags 0x%x\n", (int)ivideo->vbflags);
@@ -5583 +6606 @@
-		if(!ivideo->mtrr) {
+		if(ivideo->mtrr < 0) {
@@ -5594 +6617 @@
-			iounmap(ivideo->video_vbase);
+			ret = -EINVAL;
@@ -5596,6 +6619 @@
-			release_mem_region(ivideo->video_base, ivideo->video_size);
-			release_mem_region(ivideo->mmio_base, ivideo->mmio_size);
-			if(ivideo->bios_abase) vfree(ivideo->bios_abase);
-			pci_set_drvdata(pdev, NULL);
-			kfree(sis_fb_info);
-			return -EINVAL;
+			goto error_0;
@@ -5609,0 +6628,24 @@
+#ifdef SIS_OLD_CONFIG_COMPAT
+		{
+		int ret;
+		/* Our ioctls are all "32/64bit compatible" */
+		ret =  register_ioctl32_conversion(FBIO_ALLOC,             NULL);
+		ret |= register_ioctl32_conversion(FBIO_FREE,              NULL);
+		ret |= register_ioctl32_conversion(FBIOGET_VBLANK,         NULL);
+		ret |= register_ioctl32_conversion(SISFB_GET_INFO_SIZE,    NULL);
+		ret |= register_ioctl32_conversion(SISFB_GET_INFO,         NULL);
+		ret |= register_ioctl32_conversion(SISFB_GET_TVPOSOFFSET,  NULL);
+		ret |= register_ioctl32_conversion(SISFB_SET_TVPOSOFFSET,  NULL);
+		ret |= register_ioctl32_conversion(SISFB_SET_LOCK,         NULL);
+		ret |= register_ioctl32_conversion(SISFB_GET_VBRSTATUS,    NULL);
+		ret |= register_ioctl32_conversion(SISFB_GET_AUTOMAXIMIZE, NULL);
+		ret |= register_ioctl32_conversion(SISFB_SET_AUTOMAXIMIZE, NULL);
+		ret |= register_ioctl32_conversion(SISFB_COMMAND,          NULL);
+		if(ret)
+			printk(KERN_ERR
+				"sisfb: Error registering ioctl32 translations\n");
+		else
+			ivideo->ioctl32registered = 1;
+		}
+#endif
+
@@ -5611,3 +6653,5 @@
-		     ivideo->sisfb_accel ? "enabled" : "disabled",
-		     ivideo->sisfb_ypan  ?
-		     	(ivideo->sisfb_max ? "enabled (auto-max)" : "enabled (no auto-max)") : "disabled");
+			ivideo->sisfb_accel ? "enabled" : "disabled",
+			ivideo->sisfb_ypan  ?
+				(ivideo->sisfb_max ? "enabled (auto-max)" :
+						"enabled (no auto-max)") :
+									"disabled");
@@ -5616 +6660 @@
-		printk(KERN_INFO "fb%d: %s frame buffer device, Version %d.%d.%d\n",
+		printk(KERN_INFO "fb%d: %s frame buffer device version %d.%d.%d\n",
@@ -5618 +6662 @@
-	       		GET_FB_IDX(sis_fb_info->node),
+			GET_FB_IDX(sis_fb_info->node),
@@ -5620 +6664 @@
-	       		sis_fb_info->node,
+			sis_fb_info->node,
@@ -5624 +6668 @@
-		printk(KERN_INFO "sisfb: (C) 2001-2004 Thomas Winischhofer.\n");
+		printk(KERN_INFO "sisfb: Copyright (C) 2001-2005 Thomas Winischhofer\n");
@@ -5637,3 +6681,25 @@
-	struct sis_video_info *ivideo = pci_get_drvdata(pdev);
-	struct fb_info        *sis_fb_info = ivideo->memyselfandi;
-	int                   registered = ivideo->registered;
+	struct sis_video_info	*ivideo = pci_get_drvdata(pdev);
+	struct fb_info		*sis_fb_info = ivideo->memyselfandi;
+	int			registered = ivideo->registered;
+	int			modechanged = ivideo->modechanged;
+
+#ifdef SIS_OLD_CONFIG_COMPAT
+	if(ivideo->ioctl32registered) {
+		int ret;
+		ret =  unregister_ioctl32_conversion(FBIO_ALLOC);
+		ret |= unregister_ioctl32_conversion(FBIO_FREE);
+		ret |= unregister_ioctl32_conversion(FBIOGET_VBLANK);
+		ret |= unregister_ioctl32_conversion(SISFB_GET_INFO_SIZE);
+		ret |= unregister_ioctl32_conversion(SISFB_GET_INFO);
+		ret |= unregister_ioctl32_conversion(SISFB_GET_TVPOSOFFSET);
+		ret |= unregister_ioctl32_conversion(SISFB_SET_TVPOSOFFSET);
+		ret |= unregister_ioctl32_conversion(SISFB_SET_LOCK);
+		ret |= unregister_ioctl32_conversion(SISFB_GET_VBRSTATUS);
+		ret |= unregister_ioctl32_conversion(SISFB_GET_AUTOMAXIMIZE);
+		ret |= unregister_ioctl32_conversion(SISFB_SET_AUTOMAXIMIZE);
+		ret |= unregister_ioctl32_conversion(SISFB_COMMAND);
+		if(ret)
+			printk(KERN_ERR
+			     "sisfb: Error unregistering ioctl32 translations\n");
+	}
+#endif
@@ -5642 +6707,0 @@
-	iounmap(ivideo->video_vbase);
@@ -5644 +6709 @@
-	vfree(ivideo->bios_abase);
+	iounmap(ivideo->video_vbase);
@@ -5649,0 +6715,8 @@
+	vfree(ivideo->bios_abase);
+
+	if(ivideo->lpcdev)
+		SIS_PCI_PUT_DEVICE(ivideo->lpcdev);
+
+	if(ivideo->nbridge)
+		SIS_PCI_PUT_DEVICE(ivideo->nbridge);
+
@@ -5652 +6725 @@
-	if(ivideo->mtrr) {
+	if(ivideo->mtrr >= 0)
@@ -5654 +6726,0 @@
-	}
@@ -5656,0 +6729,8 @@
+	pci_set_drvdata(pdev, NULL);
+
+	/* If device was disabled when starting, disable
+	 * it when quitting.
+	 */
+	if(!ivideo->sisvga_enabled)
+		pci_disable_device(pdev);
+
@@ -5667 +6747 @@
-	pci_set_drvdata(pdev, NULL);
+	/* OK, our ivideo is gone for good from here. */
@@ -5676,3 +6756,3 @@
-	if(registered) {
-	   printk(KERN_INFO "sisfb: Restoring of text mode not supported yet\n");
-	}
+	if(registered && modechanged)
+		printk(KERN_INFO
+			"sisfb: Restoring of text mode not supported yet\n");
@@ -5684 +6764 @@
-	.probe 		= sisfb_probe,
+	.probe		= sisfb_probe,
@@ -5695,0 +6776 @@
+
@@ -5699 +6780 @@
-	return(pci_register_driver(&sisfb_driver));
+	return pci_register_driver(&sisfb_driver);
@@ -5714,12 +6795,74 @@
-static char         *mode = NULL;
-static int          vesa = -1;
-static unsigned int rate = 0;
-static unsigned int crt1off = 1;
-static unsigned int mem = 0;
-static char         *forcecrt2type = NULL;
-static int          forcecrt1 = -1;
-static int          pdc = -1;
-static int          pdc1 = -1;
-static int          noaccel = -1;
-static int          noypan  = -1;
-static int	    nomax = -1;
+static char		*mode = NULL;
+static int		vesa = -1;
+static unsigned int	rate = 0;
+static unsigned int	crt1off = 1;
+static unsigned int	mem = 0;
+static char		*forcecrt2type = NULL;
+static int		forcecrt1 = -1;
+static int		pdc = -1;
+static int		pdc1 = -1;
+static int		noaccel = -1;
+static int		noypan  = -1;
+static int		nomax = -1;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
+static int		inverse = 0;
+#endif
+static int		userom = -1;
+static int		useoem = -1;
+static char		*tvstandard = NULL;
+static int		nocrt2rate = 0;
+static int		scalelcd = -1;
+static char		*specialtiming = NULL;
+static int		lvdshl = -1;
+static int		tvxposoffset = 0, tvyposoffset = 0;
+#if !defined(__i386__) && !defined(__x86_64__)
+static int		resetcard = 0;
+static int		videoram = 0;
+#endif
+
+static int __init sisfb_init_module(void)
+{
+	sisfb_setdefaultparms();
+
+	if(rate)
+		sisfb_parm_rate = rate;
+
+	if((scalelcd == 0) || (scalelcd == 1))
+		sisfb_scalelcd = scalelcd ^ 1;
+
+	/* Need to check crt2 type first for fstn/dstn */
+
+	if(forcecrt2type)
+		sisfb_search_crt2type(forcecrt2type);
+
+	if(tvstandard)
+		sisfb_search_tvstd(tvstandard);
+
+	if(mode)
+		sisfb_search_mode(mode, FALSE);
+	else if(vesa != -1)
+		sisfb_search_vesamode(vesa, FALSE);
+
+	sisfb_crt1off = (crt1off == 0) ? 1 : 0;
+
+	sisfb_forcecrt1 = forcecrt1;
+	if(forcecrt1 == 1)
+		sisfb_crt1off = 0;
+	else if(forcecrt1 == 0)
+		sisfb_crt1off = 1;
+
+	if(noaccel == 1)
+		sisfb_accel = 0;
+	else if(noaccel == 0)
+		sisfb_accel = 1;
+
+	if(noypan == 1)
+		sisfb_ypan = 0;
+	else if(noypan == 0)
+		sisfb_ypan = 1;
+
+	if(nomax == 1)
+		sisfb_max = 0;
+	else if(nomax == 0)
+		sisfb_max = 1;
+
@@ -5727 +6870 @@
-static int          inverse = 0;
+	if(inverse) sisfb_inverse = 1;
@@ -5729,9 +6872,27 @@
-static int          userom = -1;
-static int          useoem = -1;
-static char         *tvstandard = NULL;
-static int	    nocrt2rate = 0;
-static int          scalelcd = -1;
-static char	    *specialtiming = NULL;
-static int	    lvdshl = -1;
-static int	    tvxposoffset = 0, tvyposoffset = 0;
-static int	    filter = -1;
+
+	if(mem)
+		sisfb_parm_mem = mem;
+
+	if(userom != -1)
+		sisfb_userom = userom;
+
+	if(useoem != -1)
+		sisfb_useoem = useoem;
+
+        if(pdc != -1)
+		sisfb_pdc  = (pdc  & 0x7f);
+
+	if(pdc1 != -1)
+		sisfb_pdca = (pdc1 & 0x1f);
+
+	sisfb_nocrt2rate = nocrt2rate;
+
+	if(specialtiming)
+		sisfb_search_specialtiming(specialtiming);
+
+	if((lvdshl >= 0) && (lvdshl <= 3))
+		sisfb_lvdshl = lvdshl;
+
+	sisfb_tvxposoffset = tvxposoffset;
+	sisfb_tvyposoffset = tvyposoffset;
+
@@ -5739,2 +6900,3 @@
-static int	    resetcard = 0;
-static int	    videoram = 0;
+	sisfb_resetcard = (resetcard) ? 1 : 0;
+	if(videoram)
+		sisfb_videoram = videoram;
@@ -5743 +6905,13 @@
-MODULE_DESCRIPTION("SiS 300/540/630/730/315/550/65x/661/74x/330/760 framebuffer device driver");
+	return sisfb_init();
+}
+
+static void __exit sisfb_remove_module(void)
+{
+	pci_unregister_driver(&sisfb_driver);
+	printk(KERN_DEBUG "sisfb: Module unloaded\n");
+}
+
+module_init(sisfb_init_module);
+module_exit(sisfb_remove_module);
+
+MODULE_DESCRIPTION("SiS 300/540/630/730/315/55x/65x/661/74x/330/76x/34x, XGI V3XT/V5/V8/Z7 framebuffer device driver");
@@ -5767 +6940,0 @@
-MODULE_PARM(filter, "i");
@@ -5796 +6968,0 @@
-module_param(filter, int, 0);
@@ -5803,0 +6976 @@
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
@@ -5809 +6982 @@
-	  "otherwise at 12288KB. On 315 and Xabre series, the heap size is 32KB by default.\n"
+	  "otherwise at 12288KB. On 315/330/340 series, the heap size is 32KB by default.\n"
@@ -5811,0 +6985,9 @@
+#else
+MODULE_PARM_DESC(mem,
+	"\nDetermines the beginning of the video memory heap in KB. This heap is used\n"
+	  "for video RAM management for eg. DRM/DRI. On 300 series, the default depends\n"
+	  "on the amount of video RAM available. If 8MB of video RAM or less is available,\n"
+	  "the heap starts at 4096KB, if between 8 and 16MB are available at 8192KB,\n"
+	  "otherwise at 12288KB. On 315/330/340 series, the heap size is 32KB by default.\n"
+	  "The value is to be specified without 'KB'.\n");
+#endif
@@ -5814 +6996 @@
-        "\nIf set to anything other than 0, 2D acceleration will be disabled.\n"
+	"\nIf set to anything other than 0, 2D acceleration will be disabled.\n"
@@ -5818,2 +7000,2 @@
-        "\nIf set to anything other than 0, y-panning will be disabled and scrolling\n"
- 	  "will be performed by redrawing the screen. (default: 0)\n");
+	"\nIf set to anything other than 0, y-panning will be disabled and scrolling\n"
+	  "will be performed by redrawing the screen. (default: 0)\n");
@@ -5822 +7004 @@
-        "\nIf y-panning is enabled, sisfb will by default use the entire available video\n"
+	"\nIf y-panning is enabled, sisfb will by default use the entire available video\n"
@@ -5830,3 +7012,3 @@
-        "\nSelects the desired display mode in the format [X]x[Y]x[Depth], eg.\n"
-          "1024x768x16. Other formats supported include XxY-Depth and\n"
- 	  "XxY-Depth@Rate. If the parameter is only one (decimal or hexadecimal)\n"
+	"\nSelects the desired display mode in the format [X]x[Y]x[Depth], eg.\n"
+	  "1024x768x16. Other formats supported include XxY-Depth and\n"
+	  "XxY-Depth@Rate. If the parameter is only one (decimal or hexadecimal)\n"
@@ -5838,2 +7020,2 @@
-        "\nSelects the desired display mode by VESA defined mode number, eg. 0x117\n"
-          "(default: 0x0000 if sisfb is a module; this leaves the console untouched\n"
+	"\nSelects the desired display mode by VESA defined mode number, eg. 0x117\n"
+	  "(default: 0x0000 if sisfb is a module; this leaves the console untouched\n"
@@ -5846,2 +7028,2 @@
-       "\nSelects the desired default display mode in the format XxYxDepth,\n"
-         "eg. 1024x768x16. Other formats supported include XxY-Depth and\n"
+	"\nSelects the desired default display mode in the format XxYxDepth,\n"
+	 "eg. 1024x768x16. Other formats supported include XxY-Depth and\n"
@@ -5852,2 +7034,2 @@
-       "\nSelects the desired default display mode by VESA defined mode number, eg.\n"
-         "0x117 (default: 0x0103)\n");
+	"\nSelects the desired default display mode by VESA defined mode number, eg.\n"
+	 "0x117 (default: 0x0103)\n");
@@ -5883 +7065 @@
-        "\nThis is for manually selecting the LCD panel delay compensation. The driver\n"
+	"\nThis is for manually selecting the LCD panel delay compensation. The driver\n"
@@ -5886,3 +7068,3 @@
-	  "on a 300 series chipset; 6 on a 315 series chipset. If the problem persists,\n"
-	  "try other values (on 300 series: between 4 and 60 in steps of 4; on 315 series:\n"
-	  "any value from 0 to 31). (default: autodetected, if LCD is active during start)\n");
+	  "on a 300 series chipset; 6 on other chipsets. If the problem persists, try\n"
+	  "other values (on 300 series: between 4 and 60 in steps of 4; otherwise: any\n"
+	  "value from 0 to 31). (default: autodetected, if LCD is active during start)\n");
@@ -5892 +7074 @@
-        "\nThis is same as pdc, but for LCD-via CRT1. Hence, this is for the 315/330\n"
+	"\nThis is same as pdc, but for LCD-via CRT1. Hence, this is for the 315/330/340\n"
@@ -5916,4 +7097,0 @@
-MODULE_PARM_DESC(filter,
-	"\nSelects TV flicker filter type (only for systems with a SiS301 video bridge).\n"
-	  "(Possible values 0-7, default: [no filter])\n");
-
@@ -5926 +7104 @@
-        "\nSetting this to anything but 0 should invert the display colors, but this\n"
+	"\nSetting this to anything but 0 should invert the display colors, but this\n"
@@ -5934,2 +7112,2 @@
-	  "the BIOS did not POST the card (only supported for SiS 300/305 currently).\n"
-	  "Default: 0\n");
+	  "the BIOS did not POST the card (only supported for SiS 300/305 and XGI cards\n"
+	  "currently). Default: 0\n");
@@ -5940,44 +7118 @@
-	  "relevant if resetcard is set, too. Default: [auto-detect]\n");
-#endif
-#endif
-
-static int __devinit sisfb_init_module(void)
-{
-	sisfb_setdefaultparms();
-
-	if(rate) sisfb_parm_rate = rate;
-
-	if((scalelcd == 0) || (scalelcd == 1)) {
-	   sisfb_scalelcd = scalelcd ^ 1;
-	}
-
-	/* Need to check crt2 type first for fstn/dstn */
-
-	if(forcecrt2type)
-		sisfb_search_crt2type(forcecrt2type);
-
-	if(tvstandard)
-		sisfb_search_tvstd(tvstandard);
-
-	if(mode)
-		sisfb_search_mode(mode, FALSE);
-	else if(vesa != -1)
-		sisfb_search_vesamode(vesa, FALSE);
-
-	sisfb_crt1off = (crt1off == 0) ? 1 : 0;
-
-	sisfb_forcecrt1 = forcecrt1;
-	if(forcecrt1 == 1)      sisfb_crt1off = 0;
-	else if(forcecrt1 == 0) sisfb_crt1off = 1;
-
-	if(noaccel == 1)      sisfb_accel = 0;
-	else if(noaccel == 0) sisfb_accel = 1;
-
-	if(noypan == 1)       sisfb_ypan = 0;
-	else if(noypan == 0)  sisfb_ypan = 1;
-
-	if(nomax == 1)        sisfb_max = 0;
-	else if(nomax == 0)   sisfb_max = 1;
-	
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	if(inverse)           sisfb_inverse = 1;
+	  "relevant if resetcard is set, too. SiS300/305 only. Default: [auto-detect]\n");
@@ -5985,24 +7119,0 @@
-
-	if(mem)		      sisfb_parm_mem = mem;
-
-	if(userom != -1)      sisfb_userom = userom;
-	if(useoem != -1)      sisfb_useoem = useoem;
-
-        if(pdc != -1)  sisfb_pdc  = (pdc  & 0x7f);
-	if(pdc1 != -1) sisfb_pdca = (pdc1 & 0x1f);
-
-	sisfb_nocrt2rate = nocrt2rate;
-
-	if(specialtiming)
-		sisfb_search_specialtiming(specialtiming);
-
-	if((lvdshl >= 0) && (lvdshl <= 3))  sisfb_lvdshl = lvdshl;
-
-	if(filter != -1) sisfb_filter = filter;
-
-	sisfb_tvxposoffset = tvxposoffset;
-	sisfb_tvyposoffset = tvyposoffset;
-
-#if !defined(__i386__) && !defined(__x86_64__)
- 	sisfb_resetcard = (resetcard) ? 1 : 0;
-	if(videoram)    sisfb_videoram = videoram;
@@ -6011,12 +7121,0 @@
-        return(sisfb_init());
-}
-
-static void __exit sisfb_remove_module(void)
-{
-	pci_unregister_driver(&sisfb_driver);
-	printk(KERN_DEBUG "sisfb: Module unloaded\n");
-}
-
-module_init(sisfb_init_module);
-module_exit(sisfb_remove_module);
-
@@ -6024,0 +7124 @@
+/* _GPL only for new symbols. */
@@ -6026,0 +7127,3 @@
+EXPORT_SYMBOL_GPL(sis_malloc_new);
+EXPORT_SYMBOL_GPL(sis_free_new);
+
--- ./projects/linux/linux-2.6.14/drivers/video/sis/sis_main.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/video/sis/sis_main.c	2006-01-03 04:21:10.000000000 +0100
@@ -2004,0 +2005 @@
+#ifdef CONFIG_FB_SOFT_CURSOR
@@ -2005,0 +2007 @@
+#endif
--- ./projects/linux/linux-2.6.15/drivers/video/sis/sis_main.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/drivers/video/sis/sis_main.c	2006-03-20 06:53:29.000000000 +0100
@@ -1746,5 +1746,7 @@
-static int
-sisfb_ioctl(struct inode *inode, struct file *file,
-            unsigned int cmd, unsigned long arg,
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	    int con,
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
+static int	sisfb_ioctl(struct fb_info *info, unsigned int cmd,
+			    unsigned long arg)
+#else
+static int	sisfb_ioctl(struct inode *inode, struct file *file,
+				unsigned int cmd, unsigned long arg,
+				struct fb_info *info)
@@ -1752 +1753,0 @@
-	    struct fb_info *info)
@@ -1927,13 +1927,0 @@
-#ifdef SIS_NEW_CONFIG_COMPAT
-static long
-sisfb_compat_ioctl(struct file *f, unsigned int cmd, unsigned long arg, struct fb_info *info)
-{
-	int ret;
-
-	lock_kernel();
-	ret = sisfb_ioctl(NULL, f, cmd, arg, info);
-	unlock_kernel();
-	return ret;
-}
-#endif
-
@@ -2010 +1998 @@
-	.fb_compat_ioctl= sisfb_compat_ioctl,
+	.fb_compat_ioctl= sisfb_ioctl,
--- ./projects/linux/linux-2.6.17/drivers/video/sis/sis_main.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/drivers/video/sis/sis_main.c	2006-09-20 05:42:06.000000000 +0200
@@ -36 +35,0 @@
-#include <linux/config.h>
@@ -47,0 +47,2 @@
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17)
@@ -48,0 +50,4 @@
+#else
+#include <linux/screen_info.h>
+#endif
+
@@ -278 +283 @@
-#if (defined(__i386__) || defined(__x86_64__)) && defined(CONFIG_VIDEO_SELECT)
+#ifdef CONFIG_X86
--- ./projects/linux/linux-2.6.18/drivers/video/sis/sis_main.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/drivers/video/sis/sis_main.c	2006-11-29 22:57:37.000000000 +0100
@@ -38 +37,0 @@
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
@@ -40 +38,0 @@
-#endif
@@ -61,3 +58,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#include <linux/vt_kern.h>
-#endif
@@ -73,8 +67,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#include <video/fbcon.h>
-#include <video/fbcon-cfb8.h>
-#include <video/fbcon-cfb16.h>
-#include <video/fbcon-cfb24.h>
-#include <video/fbcon-cfb32.h>
-#endif
-
@@ -84,18 +70,0 @@
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,3)
-#error "This version of sisfb requires at least 2.6.3"
-#endif
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#ifdef FBCON_HAS_CFB8
-extern struct display_switch fbcon_sis8;
-#endif
-#ifdef FBCON_HAS_CFB16
-extern struct display_switch fbcon_sis16;
-#endif
-#ifdef FBCON_HAS_CFB32
-extern struct display_switch fbcon_sis32;
-#endif
-#endif
-
@@ -117,9 +85,0 @@
-#ifdef MODULE
-	/* Module: "None" for 2.4, default mode for 2.5+ */
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-	sisfb_mode_idx		= -1;
-#else
-	sisfb_mode_idx		= MODE_INDEX_NONE;
-#endif
-#else
-	/* Static: Default mode */
@@ -127 +86,0 @@
-#endif
@@ -145,4 +103,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	sisfb_inverse		= 0;
-	sisfb_fontname[0]	= 0;
-#endif
@@ -165,3 +119,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-		sisfb_mode_idx = MODE_INDEX_NONE;
-#else
@@ -172 +124 @@
-#endif
+
@@ -218 +169,0 @@
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
@@ -226 +177 @@
-#endif
+
@@ -1318,12 +1268,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	if(ivideo->sisfb_thismonitor.datavalid) {
-		if(!sisfb_verify_rate(ivideo, &ivideo->sisfb_thismonitor, ivideo->sisfb_mode_idx,
-	                         ivideo->rate_idx, ivideo->refresh_rate)) {
-			printk(KERN_INFO "sisfb: WARNING: Refresh rate exceeds monitor specs!\n");
-		}
-	}
-#endif
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	if(((var->activate & FB_ACTIVATE_MASK) == FB_ACTIVATE_NOW) && isactive) {
-#else
@@ -1331 +1269,0 @@
-#endif
@@ -1370 +1307,0 @@
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
@@ -1372 +1308,0 @@
-#endif
@@ -1438,12 +1373,0 @@
-/* ------------ FBDev related routines for 2.4 series ----------- */
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-
-#include "sisfb_fbdev_2_4.h"
-
-#endif
-
-/* ------------ FBDev related routines for 2.6 series ----------- */
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
-
@@ -1747,2 +1670,0 @@
-#endif
-
@@ -1972,14 +1893,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-static struct fb_ops sisfb_ops = {
-	.owner		= THIS_MODULE,
-	.fb_get_fix	= sisfb_get_fix,
-	.fb_get_var	= sisfb_get_var,
-	.fb_set_var	= sisfb_set_var,
-	.fb_get_cmap	= sisfb_get_cmap,
-	.fb_set_cmap	= sisfb_set_cmap,
-	.fb_pan_display = sisfb_pan_display,
-	.fb_ioctl	= sisfb_ioctl
-};
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
@@ -2007 +1914,0 @@
-#endif
@@ -4103,10 +4009,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-		} else if(!strnicmp(this_opt, "inverse", 7)) {
-			sisfb_inverse = 1;
-			/* fb_invert_cmaps(); */
-		} else if(!strnicmp(this_opt, "font:", 5)) {
-			if(strlen(this_opt + 5) < 40) {
-			   strncpy(sisfb_fontname, this_opt + 5, sizeof(sisfb_fontname) - 1);
-			   sisfb_fontname[sizeof(sisfb_fontname) - 1] = '\0';
-			}
-#endif
@@ -5873 +5769,0 @@
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,3))
@@ -5877,7 +5772,0 @@
-#else
-	sis_fb_info = kmalloc(sizeof(*sis_fb_info) + sizeof(*ivideo), GFP_KERNEL);
-	if(!sis_fb_info)
-		return -ENOMEM;
-	memset(sis_fb_info, 0, sizeof(*sis_fb_info) + sizeof(*ivideo));
-	sis_fb_info->par = ((char *)sis_fb_info + sizeof(*sis_fb_info));
-#endif
@@ -5973,4 +5861,0 @@
-#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,5,0)
-	ivideo->sisfb_inverse = sisfb_inverse;
-#endif
-
@@ -6052,4 +5936,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	strcpy(sis_fb_info->modename, ivideo->myid);
-#endif
-
@@ -6137,14 +6017,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-#ifdef MODULE
-	if((reg & 0x80) && (reg != 0xff)) {
-		if((sisbios_mode[ivideo->sisfb_mode_idx].mode_no[ivideo->mni])
-									!= 0xFF) {
-			printk(KERN_INFO "sisfb: Cannot initialize display mode, "
-					 "X server is active\n");
-			ret = -EBUSY;
-			goto error_4;
-		}
-	}
-#endif
-#endif
-
@@ -6284,3 +6150,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-error_4:
-#endif
@@ -6589 +6452,0 @@
-
@@ -6606,4 +6468,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-		vc_resize_con(1, 1, 0);
-#endif
-
@@ -6656,6 +6515 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-			GET_FB_IDX(sis_fb_info->node),
-#else
-			sis_fb_info->node,
-#endif
-			ivideo->myid, VER_MAJOR, VER_MINOR, VER_LEVEL);
+			sis_fb_info->node, ivideo->myid, VER_MAJOR, VER_MINOR, VER_LEVEL);
@@ -6735 +6588,0 @@
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,3))
@@ -6737,3 +6589,0 @@
-#else
-		kfree(sis_fb_info);
-#endif
@@ -6765 +6614,0 @@
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
@@ -6774 +6622,0 @@
-#endif
@@ -6778 +6625,0 @@
-#if LINUX_VERSION_CODE > KERNEL_VERSION(2,6,8)
@@ -6782 +6628,0 @@
-#endif
@@ -6802,3 +6647,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-static int		inverse = 0;
-#endif
@@ -6864,4 +6706,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-	if(inverse) sisfb_inverse = 1;
-#endif
-
@@ -6916,29 +6754,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-MODULE_PARM(mem, "i");
-MODULE_PARM(noaccel, "i");
-MODULE_PARM(noypan, "i");
-MODULE_PARM(nomax, "i");
-MODULE_PARM(userom, "i");
-MODULE_PARM(useoem, "i");
-MODULE_PARM(mode, "s");
-MODULE_PARM(vesa, "i");
-MODULE_PARM(rate, "i");
-MODULE_PARM(forcecrt1, "i");
-MODULE_PARM(forcecrt2type, "s");
-MODULE_PARM(scalelcd, "i");
-MODULE_PARM(pdc, "i");
-MODULE_PARM(pdc1, "i");
-MODULE_PARM(specialtiming, "s");
-MODULE_PARM(lvdshl, "i");
-MODULE_PARM(tvstandard, "s");
-MODULE_PARM(tvxposoffset, "i");
-MODULE_PARM(tvyposoffset, "i");
-MODULE_PARM(nocrt2rate, "i");
-MODULE_PARM(inverse, "i");
-#if !defined(__i386__) && !defined(__x86_64__)
-MODULE_PARM(resetcard, "i");
-MODULE_PARM(videoram, "i");
-#endif
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
@@ -6969 +6778,0 @@
-#endif
@@ -6971,10 +6779,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-MODULE_PARM_DESC(mem,
-	"\nDetermines the beginning of the video memory heap in KB. This heap is used\n"
-	  "for video RAM management for eg. DRM/DRI. On 300 series, the default depends\n"
-	  "on the amount of video RAM available. If 8MB of video RAM or less is available,\n"
-	  "the heap starts at 4096KB, if between 8 and 16MB are available at 8192KB,\n"
-	  "otherwise at 12288KB. On 315/330/340 series, the heap size is 32KB by default.\n"
-	  "The value is to be specified without 'KB' and must match the MaxXFBMem setting\n"
-	  "for XFree86 4.x/X.org 6.7 and later.\n");
-#else
@@ -6988 +6786,0 @@
-#endif
@@ -7005,17 +6802,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-MODULE_PARM_DESC(mode,
-	"\nSelects the desired display mode in the format [X]x[Y]x[Depth], eg.\n"
-	  "1024x768x16. Other formats supported include XxY-Depth and\n"
-	  "XxY-Depth@Rate. If the parameter is only one (decimal or hexadecimal)\n"
-	  "number, it will be interpreted as a VESA mode number. (default: none if\n"
-	  "sisfb is a module; this leaves the console untouched and the driver will\n"
-	  "only do the video memory management for eg. DRM/DRI; 800x600x8 if sisfb\n"
-	  "is in the kernel)\n");
-MODULE_PARM_DESC(vesa,
-	"\nSelects the desired display mode by VESA defined mode number, eg. 0x117\n"
-	  "(default: 0x0000 if sisfb is a module; this leaves the console untouched\n"
-	  "and the driver will only do the video memory management for eg. DRM/DRI;\n"
-	  "0x0103 if sisfb is in the kernel)\n");
-#endif
-
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,5,0)
@@ -7031 +6811,0 @@
-#endif
@@ -7097,6 +6876,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-MODULE_PARM_DESC(inverse,
-	"\nSetting this to anything but 0 should invert the display colors, but this\n"
-	  "does not seem to work. (default: 0)\n");
-#endif
-
--- ./projects/linux/linux-2.6.20/drivers/video/sis/sis_main.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/drivers/video/sis/sis_main.c	2007-04-26 05:08:32.000000000 +0200
@@ -113 +113 @@
-sisfb_search_vesamode(unsigned int vesamode, BOOLEAN quiet)
+sisfb_search_vesamode(unsigned int vesamode, bool quiet)
@@ -153 +153 @@
-sisfb_search_mode(char *name, BOOLEAN quiet)
+sisfb_search_mode(char *name, bool quiet)
@@ -254 +254 @@
-		sisfb_search_mode(mymode, TRUE);
+		sisfb_search_mode(mymode, true);
@@ -310 +310 @@
-	BOOLEAN found = FALSE;
+	bool found = false;
@@ -325 +325 @@
-				found = TRUE;
+				found = true;
@@ -356 +356 @@
-	BOOLEAN footprint;
+	bool footprint;
@@ -383 +383 @@
-			footprint = TRUE;
+			footprint = true;
@@ -389 +389 @@
-							footprint = FALSE;
+							footprint = false;
@@ -392 +392 @@
-						footprint = FALSE;
+						footprint = false;
@@ -409 +409 @@
-static BOOLEAN __devinit
+static bool __devinit
@@ -420 +420 @@
-		return FALSE;
+		return false;
@@ -426 +426 @@
-		return FALSE;
+		return false;
@@ -452 +452 @@
-		  monitor->datavalid = TRUE;
+		  monitor->datavalid = true;
@@ -504 +504 @@
-	      monitor->datavalid = TRUE;
+	      monitor->datavalid = true;
@@ -517 +517 @@
-	monitor->datavalid = FALSE;
+	monitor->datavalid = false;
@@ -566 +566 @@
-static BOOLEAN
+static bool
@@ -574 +574 @@
-		return TRUE;
+		return true;
@@ -577 +577 @@
-		return FALSE;
+		return false;
@@ -590 +590 @@
-		return TRUE;
+		return true;
@@ -594 +594 @@
-		if(ivideo->sisvga_engine == SIS_315_VGA) return TRUE;
+		if(ivideo->sisvga_engine == SIS_315_VGA) return true;
@@ -599 +599 @@
-		return FALSE;
+		return false;
@@ -601 +601 @@
-		return FALSE;
+		return false;
@@ -608 +608 @@
-			return FALSE;
+			return false;
@@ -611 +611 @@
-			return FALSE;
+			return false;
@@ -613 +613 @@
-			return FALSE;
+			return false;
@@ -615 +615 @@
-		return FALSE;
+		return false;
@@ -617 +617 @@
-	return TRUE;
+	return true;
@@ -735 +735 @@
-static BOOLEAN
+static bool
@@ -741 +741 @@
-		return FALSE;
+		return false;
@@ -746 +746 @@
-		return TRUE;
+		return true;
@@ -748 +748 @@
-		return FALSE;
+		return false;
@@ -752 +752 @@
-static BOOLEAN
+static bool
@@ -759 +759 @@
-		return FALSE;
+		return false;
@@ -763 +763 @@
-		return FALSE;
+		return false;
@@ -765 +765 @@
-	return TRUE;
+	return true;
@@ -768 +768 @@
-static BOOLEAN
+static bool
@@ -772 +772 @@
-		return FALSE;
+		return false;
@@ -775 +775 @@
-		return TRUE;
+		return true;
@@ -777 +777 @@
-		return FALSE;
+		return false;
@@ -794 +794 @@
-static BOOLEAN
+static bool
@@ -802 +802 @@
-	default:	  return FALSE;
+	default:	  return false;
@@ -807 +807 @@
-		return TRUE;
+		return true;
@@ -809 +809 @@
-		return FALSE;
+		return false;
@@ -812 +812 @@
-static BOOLEAN
+static bool
@@ -877 +877 @@
-	BOOLEAN backlight = TRUE;
+	bool backlight = true;
@@ -887 +887 @@
-			backlight = TRUE;
+			backlight = true;
@@ -896 +896 @@
-			backlight = TRUE;
+			backlight = true;
@@ -905 +905 @@
-			backlight = FALSE;
+			backlight = false;
@@ -914 +914 @@
-			backlight = FALSE;
+			backlight = false;
@@ -923 +923 @@
-			backlight = FALSE;
+			backlight = false;
@@ -1112 +1112 @@
-	BOOLEAN isslavemode = FALSE;
+	bool isslavemode = false;
@@ -1116 +1116 @@
-	if(sisfb_bridgeisslave(ivideo)) isslavemode = TRUE;
+	if(sisfb_bridgeisslave(ivideo)) isslavemode = true;
@@ -1181 +1181 @@
-	if(SiSSetMode(&ivideo->SiS_Pr, modeno) == 0) {
+	if(!SiSSetMode(&ivideo->SiS_Pr, modeno)) {
@@ -1449 +1449 @@
-	BOOLEAN recalc_clock = FALSE;
+	bool recalc_clock = false;
@@ -1527 +1527 @@
-		recalc_clock = TRUE;
+		recalc_clock = true;
@@ -1548 +1548 @@
-		recalc_clock = TRUE;
+		recalc_clock = true;
@@ -1555 +1555 @@
-		recalc_clock = TRUE;
+		recalc_clock = true;
@@ -1558 +1558 @@
-		recalc_clock = TRUE;
+		recalc_clock = true;
@@ -2184 +2184 @@
-static BOOLEAN __devinit
+static bool __devinit
@@ -2194 +2194 @@
-    return (count == -1) ? FALSE : TRUE;
+    return (count != -1);
@@ -2200 +2200 @@
-    BOOLEAN mustwait = FALSE;
+    bool mustwait = false;
@@ -2211 +2211 @@
-    if(sr1F & 0xc0) mustwait = TRUE;
+    if(sr1F & 0xc0) mustwait = true;
@@ -2225 +2225 @@
-       mustwait = TRUE;
+       mustwait = true;
@@ -2287 +2287 @@
-	ivideo->SiS_Pr.PanelSelfDetected = FALSE;
+	ivideo->SiS_Pr.PanelSelfDetected = false;
@@ -2364 +2364 @@
-	ivideo->SiS_Pr.PanelSelfDetected = TRUE;
+	ivideo->SiS_Pr.PanelSelfDetected = true;
@@ -3019 +3019 @@
-				ivideo->SiS_Pr.SiS_UseLCDA = TRUE;
+				ivideo->SiS_Pr.SiS_UseLCDA = true;
@@ -3074 +3074 @@
-				ivideo->SiS_Pr.HaveEMI = TRUE;
+				ivideo->SiS_Pr.HaveEMI = true;
@@ -3076 +3076 @@
-					ivideo->SiS_Pr.HaveEMILCD = TRUE;
+					ivideo->SiS_Pr.HaveEMILCD = true;
@@ -3561,2 +3561,2 @@
-	SiS_SetEnableDstn(&ivideo->SiS_Pr, FALSE);
-	SiS_SetEnableFstn(&ivideo->SiS_Pr, FALSE);
+	SiS_SetEnableDstn(&ivideo->SiS_Pr, false);
+	SiS_SetEnableFstn(&ivideo->SiS_Pr, false);
@@ -3817,2 +3817,2 @@
-	BOOLEAN crt1isoff = FALSE;
-	BOOLEAN doit = TRUE;
+	bool crt1isoff = false;
+	bool doit = true;
@@ -3837 +3837 @@
-		if(sisfb_bridgeisslave(ivideo)) doit = FALSE;
+		if(sisfb_bridgeisslave(ivideo)) doit = false;
@@ -3844 +3844 @@
-			crt1isoff = TRUE;
+			crt1isoff = true;
@@ -3847 +3847 @@
-			crt1isoff = FALSE;
+			crt1isoff = false;
@@ -3856 +3856 @@
-			crt1isoff = TRUE;
+			crt1isoff = true;
@@ -3860 +3860 @@
-			crt1isoff = FALSE;
+			crt1isoff = false;
@@ -4007 +4007 @@
-			sisfb_search_mode(this_opt + 5, FALSE);
+			sisfb_search_mode(this_opt + 5, false);
@@ -4009 +4009 @@
-			sisfb_search_vesamode(simple_strtoul(this_opt + 5, NULL, 0), FALSE);
+			sisfb_search_vesamode(simple_strtoul(this_opt + 5, NULL, 0), false);
@@ -4065 +4065 @@
-			sisfb_search_mode(this_opt, TRUE);
+			sisfb_search_mode(this_opt, true);
@@ -4567,3 +4567,3 @@
-	ivideo->SiS_Pr.SiS_UseOEM = FALSE;
-	SiS_SetEnableDstn(&ivideo->SiS_Pr, FALSE);
-	SiS_SetEnableFstn(&ivideo->SiS_Pr, FALSE);
+	ivideo->SiS_Pr.SiS_UseOEM = false;
+	SiS_SetEnableDstn(&ivideo->SiS_Pr, false);
+	SiS_SetEnableFstn(&ivideo->SiS_Pr, false);
@@ -5683,3 +5683,3 @@
-		ivideo->SiS_Pr.SiS_UseOEM = FALSE;
-		SiS_SetEnableDstn(&ivideo->SiS_Pr, FALSE);
-		SiS_SetEnableFstn(&ivideo->SiS_Pr, FALSE);
+		ivideo->SiS_Pr.SiS_UseOEM = false;
+		SiS_SetEnableDstn(&ivideo->SiS_Pr, false);
+		SiS_SetEnableFstn(&ivideo->SiS_Pr, false);
@@ -5726,3 +5726,3 @@
-	ivideo->SiS_Pr.SiS_UseOEM = FALSE;
-	SiS_SetEnableDstn(&ivideo->SiS_Pr, FALSE);
-	SiS_SetEnableFstn(&ivideo->SiS_Pr, FALSE);
+	ivideo->SiS_Pr.SiS_UseOEM = false;
+	SiS_SetEnableDstn(&ivideo->SiS_Pr, false);
+	SiS_SetEnableFstn(&ivideo->SiS_Pr, false);
@@ -5822 +5822 @@
-	ivideo->sisfb_thismonitor.datavalid = FALSE;
+	ivideo->sisfb_thismonitor.datavalid = false;
@@ -5874,6 +5874,6 @@
-	ivideo->SiS_Pr.SiS_ChSW = FALSE;
-	ivideo->SiS_Pr.SiS_UseLCDA = FALSE;
-	ivideo->SiS_Pr.HaveEMI = FALSE;
-	ivideo->SiS_Pr.HaveEMILCD = FALSE;
-	ivideo->SiS_Pr.OverruleEMI = FALSE;
-	ivideo->SiS_Pr.SiS_SensibleSR11 = FALSE;
+	ivideo->SiS_Pr.SiS_ChSW = false;
+	ivideo->SiS_Pr.SiS_UseLCDA = false;
+	ivideo->SiS_Pr.HaveEMI = false;
+	ivideo->SiS_Pr.HaveEMILCD = false;
+	ivideo->SiS_Pr.OverruleEMI = false;
+	ivideo->SiS_Pr.SiS_SensibleSR11 = false;
@@ -5883 +5883 @@
-	ivideo->SiS_Pr.DDCPortMixup = FALSE;
+	ivideo->SiS_Pr.DDCPortMixup = false;
@@ -5888 +5888 @@
-			ivideo->SiS_Pr.SiS_SensibleSR11 = TRUE;
+			ivideo->SiS_Pr.SiS_SensibleSR11 = true;
@@ -5972 +5972 @@
-				ivideo->SiS_Pr.SiS_ChSW = TRUE;
+				ivideo->SiS_Pr.SiS_ChSW = true;
@@ -6021,2 +6021,2 @@
-	ivideo->SiS_Pr.UseROM = FALSE;
-	ivideo->haveXGIROM = ivideo->SiS_Pr.SiS_XGIROM = FALSE;
+	ivideo->SiS_Pr.UseROM = false;
+	ivideo->haveXGIROM = ivideo->SiS_Pr.SiS_XGIROM = false;
@@ -6026 +6026 @@
-		ivideo->SiS_Pr.UseROM = (ivideo->SiS_Pr.VirtualRomBase) ? TRUE : FALSE;
+		ivideo->SiS_Pr.UseROM = (bool)(ivideo->SiS_Pr.VirtualRomBase);
@@ -6030,2 +6030,2 @@
-		   ivideo->SiS_Pr.UseROM = FALSE;
-		   ivideo->haveXGIROM = ivideo->SiS_Pr.SiS_XGIROM = TRUE;
+		   ivideo->SiS_Pr.UseROM = false;
+		   ivideo->haveXGIROM = ivideo->SiS_Pr.SiS_XGIROM = true;
@@ -6034 +6034 @@
-			ivideo->SiS_Pr.DDCPortMixup = TRUE;
+			ivideo->SiS_Pr.DDCPortMixup = true;
@@ -6680 +6680 @@
-		sisfb_search_mode(mode, FALSE);
+		sisfb_search_mode(mode, false);
@@ -6682 +6682 @@
-		sisfb_search_vesamode(vesa, FALSE);
+		sisfb_search_vesamode(vesa, false);
--- ./projects/linux/linux-2.6.21/drivers/video/sis/sis_main.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/drivers/video/sis/sis_main.c	2007-07-09 01:32:17.000000000 +0200
@@ -40 +39,0 @@
-#include <linux/smp_lock.h>
@@ -1951 +1950 @@
-		if((pdev = SIS_PCI_GET_DEVICE(PCI_VENDOR_ID_SI,
+		if((pdev = pci_get_device(PCI_VENDOR_ID_SI,
@@ -4616 +4615 @@
-	while((pdev = SIS_PCI_GET_CLASS(PCI_CLASS_BRIDGE_HOST, pdev))) {
+	while((pdev = pci_get_class(PCI_CLASS_BRIDGE_HOST, pdev))) {
@@ -4618 +4617 @@
-		SIS_PCI_PUT_DEVICE(pdev);
+		pci_dev_put(pdev);
@@ -5157,2 +5156,2 @@
-			if((mypdev = SIS_PCI_GET_DEVICE(PCI_VENDOR_ID_SI, 0x0730, NULL))) {
-				SIS_PCI_PUT_DEVICE(mypdev);
+			if((mypdev = pci_get_device(PCI_VENDOR_ID_SI, 0x0730, NULL))) {
+				pci_dev_put(mypdev);
@@ -5164 +5163 @@
-				mypdev = SIS_PCI_GET_DEVICE(PCI_VENDOR_ID_SI, 0x0735, NULL);
+				mypdev = pci_get_device(PCI_VENDOR_ID_SI, 0x0735, NULL);
@@ -5166 +5165 @@
-					mypdev = SIS_PCI_GET_DEVICE(PCI_VENDOR_ID_SI, 0x0645, NULL);
+					mypdev = pci_get_device(PCI_VENDOR_ID_SI, 0x0645, NULL);
@@ -5168 +5167 @@
-					mypdev = SIS_PCI_GET_DEVICE(PCI_VENDOR_ID_SI, 0x0650, NULL);
+					mypdev = pci_get_device(PCI_VENDOR_ID_SI, 0x0650, NULL);
@@ -5174 +5173 @@
-					SIS_PCI_PUT_DEVICE(mypdev);
+					pci_dev_put(mypdev);
@@ -5197 +5196 @@
-			if((mypdev = SIS_PCI_GET_DEVICE(0x10de, 0x01e0, NULL))) {
+			if((mypdev = pci_get_device(0x10de, 0x01e0, NULL))) {
@@ -5203 +5202 @@
-				SIS_PCI_PUT_DEVICE(mypdev);
+				pci_dev_put(mypdev);
@@ -5239 +5238 @@
-		if((mypdev = SIS_PCI_GET_DEVICE(0x8086, 0x2530, NULL))) {
+		if((mypdev = pci_get_device(0x8086, 0x2530, NULL))) {
@@ -5241 +5240 @@
-			SIS_PCI_PUT_DEVICE(mypdev);
+			pci_dev_put(mypdev);
@@ -5950 +5949 @@
-			if(ivideo->nbridge) SIS_PCI_PUT_DEVICE(ivideo->nbridge);
+			if(ivideo->nbridge) pci_dev_put(ivideo->nbridge);
@@ -5977 +5976 @@
-				ivideo->lpcdev = SIS_PCI_GET_DEVICE(PCI_VENDOR_ID_SI, 0x0008, NULL);
+				ivideo->lpcdev = pci_get_device(PCI_VENDOR_ID_SI, 0x0008, NULL);
@@ -5987 +5986 @@
-		ivideo->lpcdev = SIS_PCI_GET_SLOT(ivideo->nbridge->bus, (2 << 3));
+		ivideo->lpcdev = pci_get_slot(ivideo->nbridge->bus, (2 << 3));
@@ -6152 +6151 @@
-			SIS_PCI_PUT_DEVICE(ivideo->lpcdev);
+			pci_dev_put(ivideo->lpcdev);
@@ -6154 +6153 @@
-			SIS_PCI_PUT_DEVICE(ivideo->nbridge);
+			pci_dev_put(ivideo->nbridge);
@@ -6334,64 +6332,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,5,0)
-
-		/* ---------------- For 2.4: Now switch the mode ------------------ */
-
-		printk(KERN_INFO "sisfb: Setting mode %dx%dx%d (%dHz)\n",
-			ivideo->video_width, ivideo->video_height, ivideo->video_bpp,
-			ivideo->refresh_rate);
-
-		/* Determine whether or not acceleration is to be
-		 * used. Need to know before pre/post_set_mode()
-		 */
-		ivideo->accel = 0;
-		ivideo->default_var.accel_flags &= ~FB_ACCELF_TEXT;
-		if(ivideo->sisfb_accel) {
-			ivideo->accel = -1;
-			ivideo->default_var.accel_flags |= FB_ACCELF_TEXT;
-		}
-
-		/* Now switch the mode */
-		sisfb_pre_setmode(ivideo);
-
-		if(SiSSetMode(&ivideo->SiS_Pr, ivideo->mode_no) == 0) {
-			printk(KERN_ERR "sisfb: Fatal error: Setting mode[0x%x] failed\n",
-									ivideo->mode_no);
-			ret = -EINVAL;
-			iounmap(ivideo->mmio_vbase);
-			goto error_0;
-		}
-
-		outSISIDXREG(SISSR, IND_SIS_PASSWORD, SIS_PASSWORD);
-
-		sisfb_post_setmode(ivideo);
-
-		/* Maximize regardless of sisfb_max at startup */
-		ivideo->default_var.yres_virtual = 32767;
-
-		/* Force reset of x virtual in crtc_to_var */
-		ivideo->default_var.xres_virtual = 0;
-
-		/* Copy mode timing to var */
-		sisfb_crtc_to_var(ivideo, &ivideo->default_var);
-
-		/* Find out about screen pitch */
-		sisfb_calc_pitch(ivideo, &ivideo->default_var);
-		sisfb_set_pitch(ivideo);
-
-		/* Init the accelerator (does nothing currently) */
-		sisfb_initaccel(ivideo);
-
-		/* Init some fbinfo entries */
-		sis_fb_info->node  = -1;
-		sis_fb_info->flags = FBINFO_FLAG_DEFAULT;
-		sis_fb_info->fbops = &sisfb_ops;
-		sis_fb_info->disp  = &ivideo->sis_disp;
-		sis_fb_info->blank = &sisfb_blank;
-		sis_fb_info->switch_con = &sisfb_switch;
-		sis_fb_info->updatevar  = &sisfb_update_var;
-		sis_fb_info->changevar  = NULL;
-		strcpy(sis_fb_info->fontname, sisfb_fontname);
-
-		sisfb_set_disp(-1, &ivideo->default_var, sis_fb_info);
-
-#else		/* --------- For 2.6: Setup a somewhat sane default var ------------ */
-
@@ -6457 +6391,0 @@
-#endif		/* 2.6 */
@@ -6567 +6501 @@
-		SIS_PCI_PUT_DEVICE(ivideo->lpcdev);
+		pci_dev_put(ivideo->lpcdev);
@@ -6570 +6504 @@
-		SIS_PCI_PUT_DEVICE(ivideo->nbridge);
+		pci_dev_put(ivideo->nbridge);
--- ./projects/linux/linux-2.6.22/drivers/video/sis/sis_main.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/drivers/video/sis/sis_main.c	2007-10-09 22:31:38.000000000 +0200
@@ -1407,0 +1408,3 @@
+		if (regno >= 16)
+			break;
+
@@ -1413,0 +1417,3 @@
+		if (regno >= 16)
+			break;
+
@@ -5792 +5798 @@
-	pci_read_config_byte(pdev, PCI_REVISION_ID, &ivideo->revision_id);
+	ivideo->revision_id = pdev->revision;
--- ./projects/linux/linux-2.6.23/drivers/video/sis/sis_main.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/drivers/video/sis/sis_main.c	2008-01-24 23:58:37.000000000 +0100
@@ -61 +61 @@
-#include <asm/uaccess.h>
+#include <linux/uaccess.h>
@@ -1251 +1250,0 @@
-		ivideo->mode_no = sisbios_mode[ivideo->sisfb_mode_idx].mode_no[ivideo->mni];
@@ -1262,0 +1262,2 @@
+	ivideo->mode_no = sisbios_mode[ivideo->sisfb_mode_idx].mode_no[ivideo->mni];
+
--- ./projects/linux/linux-2.6.24/drivers/video/sis/sis_main.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/drivers/video/sis/sis_main.c	2008-04-17 04:49:44.000000000 +0200
@@ -430 +430 @@
-	if(!buffer[0x14] & 0x80) {
+	if(!(buffer[0x14] & 0x80)) {
@@ -4624 +4623,0 @@
-		pci_dev_put(pdev);
@@ -4626,0 +4626 @@
+			pci_dev_put(pdev);
@@ -5808,3 +5807,0 @@
-#ifdef SIS_OLD_CONFIG_COMPAT
-	ivideo->ioctl32registered = 0;
-#endif
@@ -6423,24 +6419,0 @@
-#ifdef SIS_OLD_CONFIG_COMPAT
-		{
-		int ret;
-		/* Our ioctls are all "32/64bit compatible" */
-		ret =  register_ioctl32_conversion(FBIO_ALLOC,             NULL);
-		ret |= register_ioctl32_conversion(FBIO_FREE,              NULL);
-		ret |= register_ioctl32_conversion(FBIOGET_VBLANK,         NULL);
-		ret |= register_ioctl32_conversion(SISFB_GET_INFO_SIZE,    NULL);
-		ret |= register_ioctl32_conversion(SISFB_GET_INFO,         NULL);
-		ret |= register_ioctl32_conversion(SISFB_GET_TVPOSOFFSET,  NULL);
-		ret |= register_ioctl32_conversion(SISFB_SET_TVPOSOFFSET,  NULL);
-		ret |= register_ioctl32_conversion(SISFB_SET_LOCK,         NULL);
-		ret |= register_ioctl32_conversion(SISFB_GET_VBRSTATUS,    NULL);
-		ret |= register_ioctl32_conversion(SISFB_GET_AUTOMAXIMIZE, NULL);
-		ret |= register_ioctl32_conversion(SISFB_SET_AUTOMAXIMIZE, NULL);
-		ret |= register_ioctl32_conversion(SISFB_COMMAND,          NULL);
-		if(ret)
-			printk(KERN_ERR
-				"sisfb: Error registering ioctl32 translations\n");
-		else
-			ivideo->ioctl32registered = 1;
-		}
-#endif
-
@@ -6476,21 +6448,0 @@
-#ifdef SIS_OLD_CONFIG_COMPAT
-	if(ivideo->ioctl32registered) {
-		int ret;
-		ret =  unregister_ioctl32_conversion(FBIO_ALLOC);
-		ret |= unregister_ioctl32_conversion(FBIO_FREE);
-		ret |= unregister_ioctl32_conversion(FBIOGET_VBLANK);
-		ret |= unregister_ioctl32_conversion(SISFB_GET_INFO_SIZE);
-		ret |= unregister_ioctl32_conversion(SISFB_GET_INFO);
-		ret |= unregister_ioctl32_conversion(SISFB_GET_TVPOSOFFSET);
-		ret |= unregister_ioctl32_conversion(SISFB_SET_TVPOSOFFSET);
-		ret |= unregister_ioctl32_conversion(SISFB_SET_LOCK);
-		ret |= unregister_ioctl32_conversion(SISFB_GET_VBRSTATUS);
-		ret |= unregister_ioctl32_conversion(SISFB_GET_AUTOMAXIMIZE);
-		ret |= unregister_ioctl32_conversion(SISFB_SET_AUTOMAXIMIZE);
-		ret |= unregister_ioctl32_conversion(SISFB_COMMAND);
-		if(ret)
-			printk(KERN_ERR
-			     "sisfb: Error unregistering ioctl32 translations\n");
-	}
-#endif
-
--- ./projects/linux/linux-2.6.25/drivers/video/sis/sis_main.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/drivers/video/sis/sis_main.c	2008-07-13 23:51:29.000000000 +0200
@@ -5790 +5790 @@
-		while((countvideo = countvideo->next) != 0)
+		while((countvideo = countvideo->next) != NULL)
--- ./projects/linux/linux-2.6.26/drivers/video/sis/sis_main.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/drivers/video/sis/sis_main.c	2008-10-10 00:13:53.000000000 +0200
@@ -36 +35,0 @@
-#include <linux/version.h>
@@ -44,4 +42,0 @@
-
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,17)
-#include <linux/tty.h>
-#else
@@ -49,2 +43,0 @@
-#endif
-
@@ -1170,3 +1162,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,12)
-	if(!clrscrn) modeno |= 0x80;
-#else
@@ -1174 +1163,0 @@
-#endif
@@ -1439,3 +1427,0 @@
-#if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,10)
-	sisfb_get_fix(&info->fix, info->currcon, info);
-#else
@@ -1443 +1429 @@
-#endif
+
@@ -1679 +1664,0 @@
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,15)
@@ -1682,5 +1666,0 @@
-#else
-static int	sisfb_ioctl(struct inode *inode, struct file *file,
-				unsigned int cmd, unsigned long arg,
-				struct fb_info *info)
-#endif
@@ -3989,2 +3969 @@
-SISINITSTATIC int __init
-sisfb_setup(char *options)
+static int __init sisfb_setup(char *options)
@@ -4089 +4068 @@
-sisfb_check_rom(SIS_IOTYPE1 *rom_base, struct sis_video_info *ivideo)
+sisfb_check_rom(void __iomem *rom_base, struct sis_video_info *ivideo)
@@ -4091 +4070 @@
-	SIS_IOTYPE1 *rom;
+	void __iomem *rom;
@@ -4120 +4099 @@
-	SIS_IOTYPE1 *rom_base;
+	void __iomem *rom_base;
@@ -4123 +4101,0 @@
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,11)
@@ -4154 +4131,0 @@
-#endif
@@ -4228 +4205 @@
-	SIS_IOTYPE1 *FBAddress = ivideo->video_vbase;
+	void __iomem *FBAddress = ivideo->video_vbase;
@@ -4276 +4253 @@
-	SIS_IOTYPE1 *FBAddr = ivideo->video_vbase;
+	void __iomem *FBAddr = ivideo->video_vbase;
@@ -5832 +5809 @@
-#if (LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,12))
+
@@ -5843 +5819,0 @@
-#endif
@@ -6013 +5989 @@
-		unsigned char SIS_IOTYPE2 *tt = ioremap(0x400, 0x100);
+		unsigned char __iomem *tt = ioremap(0x400, 0x100);
@@ -6506 +6482 @@
-SISINITSTATIC int __init sisfb_init(void)
+static int __init sisfb_init(void)
--- ./projects/linux/linux-2.6.29/drivers/video/sis/sis_main.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/drivers/video/sis/sis_main.c	2009-06-27 11:32:32.000000000 +0200
@@ -1132 +1132 @@
-		var->red.length = var->green.length = var->blue.length = 6;
+		var->red.length = var->green.length = var->blue.length = 8;
--- ./projects/linux/linux-2.6.16/fs/ocfs2/alloc.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/fs/ocfs2/alloc.c	2006-06-18 03:49:35.000000000 +0200
@@ -569,3 +569,2 @@
-					    "Dinode %"MLFu64" has a bad "
-					    "extent list",
-					    OCFS2_I(inode)->ip_blkno);
+					    "Dinode %llu has a bad extent list",
+					    (unsigned long long)OCFS2_I(inode)->ip_blkno);
@@ -614,3 +613,2 @@
-				    "Dinode %"MLFu64" has a bad "
-				    "extent list",
-				    OCFS2_I(inode)->ip_blkno);
+				    "Dinode %llu has a bad extent list",
+				    (unsigned long long)OCFS2_I(inode)->ip_blkno);
@@ -655 +653 @@
-				    "Dinode %"MLFu64" trailing extent is bad: "
+				    "Dinode %llu trailing extent is bad: "
@@ -656,0 +655 @@
+				    (unsigned long long)OCFS2_I(inode)->ip_blkno,
@@ -750 +749 @@
-			ocfs2_error(inode->i_sb, "Dinode %"MLFu64" has empty "
+			ocfs2_error(inode->i_sb, "Dinode %llu has empty "
@@ -752 +751 @@
-				    OCFS2_I(inode)->ip_blkno);
+				    (unsigned long long)OCFS2_I(inode)->ip_blkno);
@@ -759 +758 @@
-			ocfs2_error(inode->i_sb, "Dinode %"MLFu64" has extent "
+			ocfs2_error(inode->i_sb, "Dinode %llu has extent "
@@ -762 +761 @@
-				    OCFS2_I(inode)->ip_blkno, i);
+				    (unsigned long long)OCFS2_I(inode)->ip_blkno, i);
@@ -829,3 +828,3 @@
-	mlog(0, "add %u clusters starting at block %"MLFu64" to "
-		"inode %"MLFu64"\n",
-	     new_clusters, start_blk, OCFS2_I(inode)->ip_blkno);
+	mlog(0, "add %u clusters starting at block %llu to inode %llu\n",
+	     new_clusters, (unsigned long long)start_blk,
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno);
@@ -966,2 +965,2 @@
-	mlog_entry("start_blk = %"MLFu64", num_clusters = %u\n", start_blk,
-		   num_clusters);
+	mlog_entry("start_blk = %llu, num_clusters = %u\n",
+		   (unsigned long long)start_blk, num_clusters);
@@ -984,2 +983,3 @@
-			"Truncate record count on #%"MLFu64" invalid ("
-			"wanted %u, actual %u\n", OCFS2_I(tl_inode)->ip_blkno,
+			"Truncate record count on #%llu invalid "
+			"wanted %u, actual %u\n",
+			(unsigned long long)OCFS2_I(tl_inode)->ip_blkno,
@@ -1005,2 +1005,2 @@
-	     "%"MLFu64" (index = %d)\n", num_clusters, start_cluster,
-	     OCFS2_I(tl_inode)->ip_blkno, index);
+	     "%llu (index = %d)\n", num_clusters, start_cluster,
+	     (unsigned long long)OCFS2_I(tl_inode)->ip_blkno, index);
@@ -1137,2 +1137,2 @@
-	mlog(0, "Flush %u records from truncate log #%"MLFu64"\n",
-	     num_to_flush, OCFS2_I(tl_inode)->ip_blkno);
+	mlog(0, "Flush %u records from truncate log #%llu\n",
+	     num_to_flush, (unsigned long long)OCFS2_I(tl_inode)->ip_blkno);
@@ -1363,2 +1363,2 @@
-	mlog(0, "cleanup %u records from %"MLFu64"\n", num_recs,
-	     tl_copy->i_blkno);
+	mlog(0, "cleanup %u records from %llu\n", num_recs,
+	     (unsigned long long)tl_copy->i_blkno);
@@ -1532 +1532,2 @@
-	mlog(0, "returning block %"MLFu64"\n", le64_to_cpu(eb->h_blkno));
+	mlog(0, "returning block %llu\n",
+	     (unsigned long long)le64_to_cpu(eb->h_blkno));
@@ -1649,2 +1650,2 @@
-		mlog(0, "traveling tree (depth = %d, next_eb = %"MLFu64")\n",
-		     depth,  next_eb);
+		mlog(0, "traveling tree (depth = %d, next_eb = %llu)\n",
+		     depth,  (unsigned long long)next_eb);
@@ -1677,3 +1678,3 @@
-		mlog(0, "extent block %"MLFu64", before: record %d: "
-		     "(%u, %u, %"MLFu64"), next = %u\n",
-		     le64_to_cpu(eb->h_blkno), i,
+		mlog(0, "extent block %llu, before: record %d: "
+		     "(%u, %u, %llu), next = %u\n",
+		     (unsigned long long)le64_to_cpu(eb->h_blkno), i,
@@ -1682 +1683 @@
-		     le64_to_cpu(el->l_recs[i].e_blkno),
+		     (unsigned long long)le64_to_cpu(el->l_recs[i].e_blkno),
@@ -1700,3 +1701,3 @@
-		mlog(0, "extent block %"MLFu64", after: record %d: "
-		     "(%u, %u, %"MLFu64"), next = %u\n",
-		     le64_to_cpu(eb->h_blkno), i,
+		mlog(0, "extent block %llu, after: record %d: "
+		     "(%u, %u, %llu), next = %u\n",
+		     (unsigned long long)le64_to_cpu(eb->h_blkno), i,
@@ -1705 +1706 @@
-		     le64_to_cpu(el->l_recs[i].e_blkno),
+		     (unsigned long long)le64_to_cpu(el->l_recs[i].e_blkno),
@@ -1795 +1796 @@
-	     "last_eb = %"MLFu64", fe->i_last_eb_blk = %"MLFu64", "
+	     "last_eb = %llu, fe->i_last_eb_blk = %llu, "
@@ -1797,2 +1798,2 @@
-	     le32_to_cpu(fe->i_clusters), last_eb,
-	     le64_to_cpu(fe->i_last_eb_blk),
+	     le32_to_cpu(fe->i_clusters), (unsigned long long)last_eb,
+	     (unsigned long long)le64_to_cpu(fe->i_last_eb_blk),
@@ -1937 +1938,2 @@
-	     "%"MLFu64"\n", fe->i_clusters, new_i_clusters, fe->i_size);
+	     "%llu\n", fe->i_clusters, new_i_clusters,
+	     (unsigned long long)fe->i_size);
@@ -1940,2 +1942,2 @@
-		ocfs2_error(inode->i_sb, "Dinode %"MLFu64" has cluster count "
-			    "%u and size %"MLFu64" whereas struct inode has "
+		ocfs2_error(inode->i_sb, "Dinode %llu has cluster count "
+			    "%u and size %llu whereas struct inode has "
@@ -1944 +1946 @@
-			    le64_to_cpu(fe->i_blkno),
+			    (unsigned long long)le64_to_cpu(fe->i_blkno),
@@ -1946 +1948 @@
-			    le64_to_cpu(fe->i_size),
+			    (unsigned long long)le64_to_cpu(fe->i_size),
--- ./projects/linux/linux-2.6.18/fs/ocfs2/alloc.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/fs/ocfs2/alloc.c	2006-11-29 22:57:37.000000000 +0100
@@ -1720 +1719,0 @@
-			BUG_ON(eb->h_suballoc_slot);
@@ -1724,7 +1723,20 @@
-			status = ocfs2_free_extent_block(handle,
-							 tc->tc_ext_alloc_inode,
-							 tc->tc_ext_alloc_bh,
-							 eb);
-			if (status < 0) {
-				mlog_errno(status);
-				goto bail;
+			if (eb->h_suballoc_slot == 0) {
+				/*
+				 * This code only understands how to
+				 * lock the suballocator in slot 0,
+				 * which is fine because allocation is
+				 * only ever done out of that
+				 * suballocator too. A future version
+				 * might change that however, so avoid
+				 * a free if we don't know how to
+				 * handle it. This way an fs incompat
+				 * bit will not be necessary.
+				 */
+				status = ocfs2_free_extent_block(handle,
+								 tc->tc_ext_alloc_inode,
+								 tc->tc_ext_alloc_bh,
+								 eb);
+				if (status < 0) {
+					mlog_errno(status);
+					goto bail;
+				}
--- ./projects/linux/linux-2.6.19/fs/ocfs2/alloc.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/fs/ocfs2/alloc.c	2007-02-04 19:44:54.000000000 +0100
@@ -55 +55 @@
-				     struct ocfs2_journal_handle *handle,
+				     handle_t *handle,
@@ -62 +62 @@
-			    struct ocfs2_journal_handle *handle,
+			    handle_t *handle,
@@ -70 +70 @@
-				  struct ocfs2_journal_handle *handle,
+				  handle_t *handle,
@@ -77 +77 @@
-				  struct ocfs2_journal_handle *handle,
+				  handle_t *handle,
@@ -155 +155 @@
-				     struct ocfs2_journal_handle *handle,
+				     handle_t *handle,
@@ -256 +256 @@
-			    struct ocfs2_journal_handle *handle,
+			    handle_t *handle,
@@ -421 +421 @@
-				  struct ocfs2_journal_handle *handle,
+				  handle_t *handle,
@@ -523 +523 @@
-				  struct ocfs2_journal_handle *handle,
+				  handle_t *handle,
@@ -812 +812 @@
-			struct ocfs2_journal_handle *handle,
+			handle_t *handle,
@@ -954 +954 @@
-				     struct ocfs2_journal_handle *handle,
+				     handle_t *handle,
@@ -1037 +1037 @@
-					 struct ocfs2_journal_handle *handle,
+					 handle_t *handle,
@@ -1116 +1116 @@
-	struct ocfs2_journal_handle *handle = NULL;
+	handle_t *handle;
@@ -1133 +1133 @@
-		goto bail;
+		goto out;
@@ -1141,8 +1141 @@
-		goto bail;
-	}
-
-	handle = ocfs2_alloc_handle(osb);
-	if (!handle) {
-		status = -ENOMEM;
-		mlog_errno(status);
-		goto bail;
+		goto out;
@@ -1157 +1150 @@
-		goto bail;
+		goto out;
@@ -1160,2 +1153,3 @@
-	ocfs2_handle_add_inode(handle, data_alloc_inode);
-	status = ocfs2_meta_lock(data_alloc_inode, handle, &data_alloc_bh, 1);
+	mutex_lock(&data_alloc_inode->i_mutex);
+
+	status = ocfs2_meta_lock(data_alloc_inode, &data_alloc_bh, 1);
@@ -1164 +1158 @@
-		goto bail;
+		goto out_mutex;
@@ -1167 +1161 @@
-	handle = ocfs2_start_trans(osb, handle, OCFS2_TRUNCATE_LOG_UPDATE);
+	handle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);
@@ -1170 +1163,0 @@
-		handle = NULL;
@@ -1172 +1165 @@
-		goto bail;
+		goto out_unlock;
@@ -1177 +1170 @@
-	if (status < 0) {
+	if (status < 0)
@@ -1179,2 +1171,0 @@
-		goto bail;
-	}
@@ -1182,3 +1173 @@
-bail:
-	if (handle)
-		ocfs2_commit_trans(handle);
+	ocfs2_commit_trans(osb, handle);
@@ -1186,2 +1175,3 @@
-	if (data_alloc_inode)
-		iput(data_alloc_inode);
+out_unlock:
+	brelse(data_alloc_bh);
+	ocfs2_meta_unlock(data_alloc_inode, 1);
@@ -1189,2 +1179,3 @@
-	if (data_alloc_bh)
-		brelse(data_alloc_bh);
+out_mutex:
+	mutex_unlock(&data_alloc_inode->i_mutex);
+	iput(data_alloc_inode);
@@ -1191,0 +1183 @@
+out:
@@ -1208 +1200 @@
-static void ocfs2_truncate_log_worker(void *data)
+static void ocfs2_truncate_log_worker(struct work_struct *work)
@@ -1211 +1203,3 @@
-	struct ocfs2_super *osb = data;
+	struct ocfs2_super *osb =
+		container_of(work, struct ocfs2_super,
+			     osb_truncate_log_wq.work);
@@ -1350 +1344 @@
-	struct ocfs2_journal_handle *handle;
+	handle_t *handle;
@@ -1376,2 +1370 @@
-		handle = ocfs2_start_trans(osb, NULL,
-					   OCFS2_TRUNCATE_LOG_UPDATE);
+		handle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);
@@ -1390 +1383 @@
-		ocfs2_commit_trans(handle);
+		ocfs2_commit_trans(osb, handle);
@@ -1444 +1437,2 @@
-	INIT_WORK(&osb->osb_truncate_log_wq, ocfs2_truncate_log_worker, osb);
+	INIT_DELAYED_WORK(&osb->osb_truncate_log_wq,
+			  ocfs2_truncate_log_worker);
@@ -1546 +1540 @@
-			     struct ocfs2_journal_handle *handle,
+			     handle_t *handle,
@@ -1785 +1779 @@
-	struct ocfs2_journal_handle *handle = NULL;
+	handle_t *handle = NULL;
@@ -1871 +1865 @@
-	handle = ocfs2_start_trans(osb, NULL, credits);
+	handle = ocfs2_start_trans(osb, credits);
@@ -1894 +1888 @@
-	ocfs2_commit_trans(handle);
+	ocfs2_commit_trans(osb, handle);
@@ -1909 +1903 @@
-		ocfs2_commit_trans(handle);
+		ocfs2_commit_trans(osb, handle);
@@ -1968 +1962 @@
-	*tc = kcalloc(1, sizeof(struct ocfs2_truncate_context), GFP_KERNEL);
+	*tc = kzalloc(sizeof(struct ocfs2_truncate_context), GFP_KERNEL);
@@ -2014,4 +2008 @@
-		status = ocfs2_meta_lock(ext_alloc_inode,
-					 NULL,
-					 &ext_alloc_bh,
-					 1);
+		status = ocfs2_meta_lock(ext_alloc_inode, &ext_alloc_bh, 1);
--- ./projects/linux/linux-2.6.21/fs/ocfs2/alloc.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/fs/ocfs2/alloc.c	2007-07-09 01:32:17.000000000 +0200
@@ -29,0 +30 @@
+#include <linux/swap.h>
@@ -36,0 +38 @@
+#include "aops.h"
@@ -50,3 +52 @@
-static int ocfs2_extent_contig(struct inode *inode,
-			       struct ocfs2_extent_rec *ext,
-			       u64 blkno);
+static void ocfs2_free_truncate_context(struct ocfs2_truncate_context *tc);
@@ -54,6 +54,24 @@
-static int ocfs2_create_new_meta_bhs(struct ocfs2_super *osb,
-				     handle_t *handle,
-				     struct inode *inode,
-				     int wanted,
-				     struct ocfs2_alloc_context *meta_ac,
-				     struct buffer_head *bhs[]);
+/*
+ * Structures which describe a path through a btree, and functions to
+ * manipulate them.
+ *
+ * The idea here is to be as generic as possible with the tree
+ * manipulation code.
+ */
+struct ocfs2_path_item {
+	struct buffer_head		*bh;
+	struct ocfs2_extent_list	*el;
+};
+
+#define OCFS2_MAX_PATH_DEPTH	5
+
+struct ocfs2_path {
+	int			p_tree_depth;
+	struct ocfs2_path_item	p_node[OCFS2_MAX_PATH_DEPTH];
+};
+
+#define path_root_bh(_path) ((_path)->p_node[0].bh)
+#define path_root_el(_path) ((_path)->p_node[0].el)
+#define path_leaf_bh(_path) ((_path)->p_node[(_path)->p_tree_depth].bh)
+#define path_leaf_el(_path) ((_path)->p_node[(_path)->p_tree_depth].el)
+#define path_num_items(_path) ((_path)->p_tree_depth + 1)
@@ -61,7 +79,9 @@
-static int ocfs2_add_branch(struct ocfs2_super *osb,
-			    handle_t *handle,
-			    struct inode *inode,
-			    struct buffer_head *fe_bh,
-			    struct buffer_head *eb_bh,
-			    struct buffer_head *last_eb_bh,
-			    struct ocfs2_alloc_context *meta_ac);
+/*
+ * Reset the actual path elements so that we can re-use the structure
+ * to build another path. Generally, this involves freeing the buffer
+ * heads.
+ */
+static void ocfs2_reinit_path(struct ocfs2_path *path, int keep_root)
+{
+	int i, start = 0, depth = 0;
+	struct ocfs2_path_item *node;
@@ -69,6 +89,2 @@
-static int ocfs2_shift_tree_depth(struct ocfs2_super *osb,
-				  handle_t *handle,
-				  struct inode *inode,
-				  struct buffer_head *fe_bh,
-				  struct ocfs2_alloc_context *meta_ac,
-				  struct buffer_head **ret_new_eb_bh);
+	if (keep_root)
+		start = 1;
@@ -76,6 +92,2 @@
-static int ocfs2_do_insert_extent(struct ocfs2_super *osb,
-				  handle_t *handle,
-				  struct inode *inode,
-				  struct buffer_head *fe_bh,
-				  u64 blkno,
-				  u32 new_clusters);
+	for(i = start; i < path_num_items(path); i++) {
+		node = &path->p_node[i];
@@ -83,4 +95,12 @@
-static int ocfs2_find_branch_target(struct ocfs2_super *osb,
-				    struct inode *inode,
-				    struct buffer_head *fe_bh,
-				    struct buffer_head **target_bh);
+		brelse(node->bh);
+		node->bh = NULL;
+		node->el = NULL;
+	}
+
+	/*
+	 * Tree depth may change during truncate, or insert. If we're
+	 * keeping the root extent list, then make sure that our path
+	 * structure reflects the proper depth.
+	 */
+	if (keep_root)
+		depth = le16_to_cpu(path_root_el(path)->l_tree_depth);
@@ -88,6 +108,2 @@
-static int ocfs2_find_new_last_ext_blk(struct ocfs2_super *osb,
-				       struct inode *inode,
-				       struct ocfs2_dinode *fe,
-				       unsigned int new_i_clusters,
-				       struct buffer_head *old_last_eb,
-				       struct buffer_head **new_last_eb);
+	path->p_tree_depth = depth;
+}
@@ -95 +111,65 @@
-static void ocfs2_free_truncate_context(struct ocfs2_truncate_context *tc);
+static void ocfs2_free_path(struct ocfs2_path *path)
+{
+	if (path) {
+		ocfs2_reinit_path(path, 0);
+		kfree(path);
+	}
+}
+
+/*
+ * Make the *dest path the same as src and re-initialize src path to
+ * have a root only.
+ */
+static void ocfs2_mv_path(struct ocfs2_path *dest, struct ocfs2_path *src)
+{
+	int i;
+
+	BUG_ON(path_root_bh(dest) != path_root_bh(src));
+
+	for(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {
+		brelse(dest->p_node[i].bh);
+
+		dest->p_node[i].bh = src->p_node[i].bh;
+		dest->p_node[i].el = src->p_node[i].el;
+
+		src->p_node[i].bh = NULL;
+		src->p_node[i].el = NULL;
+	}
+}
+
+/*
+ * Insert an extent block at given index.
+ *
+ * This will not take an additional reference on eb_bh.
+ */
+static inline void ocfs2_path_insert_eb(struct ocfs2_path *path, int index,
+					struct buffer_head *eb_bh)
+{
+	struct ocfs2_extent_block *eb = (struct ocfs2_extent_block *)eb_bh->b_data;
+
+	/*
+	 * Right now, no root bh is an extent block, so this helps
+	 * catch code errors with dinode trees. The assertion can be
+	 * safely removed if we ever need to insert extent block
+	 * structures at the root.
+	 */
+	BUG_ON(index == 0);
+
+	path->p_node[index].bh = eb_bh;
+	path->p_node[index].el = &eb->h_list;
+}
+
+static struct ocfs2_path *ocfs2_new_path(struct buffer_head *root_bh,
+					 struct ocfs2_extent_list *root_el)
+{
+	struct ocfs2_path *path;
+
+	BUG_ON(le16_to_cpu(root_el->l_tree_depth) >= OCFS2_MAX_PATH_DEPTH);
+
+	path = kzalloc(sizeof(*path), GFP_NOFS);
+	if (path) {
+		path->p_tree_depth = le16_to_cpu(root_el->l_tree_depth);
+		get_bh(root_bh);
+		path_root_bh(path) = root_bh;
+		path_root_el(path) = root_el;
+	}
@@ -97,7 +177 @@
-static int ocfs2_extent_contig(struct inode *inode,
-			       struct ocfs2_extent_rec *ext,
-			       u64 blkno)
-{
-	return blkno == (le64_to_cpu(ext->e_blkno) +
-			 ocfs2_clusters_to_blocks(inode->i_sb,
-						  le32_to_cpu(ext->e_clusters)));
+	return path;
@@ -106,0 +181,108 @@
+ * Allocate and initialize a new path based on a disk inode tree.
+ */
+static struct ocfs2_path *ocfs2_new_inode_path(struct buffer_head *di_bh)
+{
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
+	struct ocfs2_extent_list *el = &di->id2.i_list;
+
+	return ocfs2_new_path(di_bh, el);
+}
+
+/*
+ * Convenience function to journal all components in a path.
+ */
+static int ocfs2_journal_access_path(struct inode *inode, handle_t *handle,
+				     struct ocfs2_path *path)
+{
+	int i, ret = 0;
+
+	if (!path)
+		goto out;
+
+	for(i = 0; i < path_num_items(path); i++) {
+		ret = ocfs2_journal_access(handle, inode, path->p_node[i].bh,
+					   OCFS2_JOURNAL_ACCESS_WRITE);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+out:
+	return ret;
+}
+
+enum ocfs2_contig_type {
+	CONTIG_NONE = 0,
+	CONTIG_LEFT,
+	CONTIG_RIGHT
+};
+
+
+/*
+ * NOTE: ocfs2_block_extent_contig(), ocfs2_extents_adjacent() and
+ * ocfs2_extent_contig only work properly against leaf nodes!
+ */
+static int ocfs2_block_extent_contig(struct super_block *sb,
+				     struct ocfs2_extent_rec *ext,
+				     u64 blkno)
+{
+	u64 blk_end = le64_to_cpu(ext->e_blkno);
+
+	blk_end += ocfs2_clusters_to_blocks(sb,
+				    le16_to_cpu(ext->e_leaf_clusters));
+
+	return blkno == blk_end;
+}
+
+static int ocfs2_extents_adjacent(struct ocfs2_extent_rec *left,
+				  struct ocfs2_extent_rec *right)
+{
+	u32 left_range;
+
+	left_range = le32_to_cpu(left->e_cpos) +
+		le16_to_cpu(left->e_leaf_clusters);
+
+	return (left_range == le32_to_cpu(right->e_cpos));
+}
+
+static enum ocfs2_contig_type
+	ocfs2_extent_contig(struct inode *inode,
+			    struct ocfs2_extent_rec *ext,
+			    struct ocfs2_extent_rec *insert_rec)
+{
+	u64 blkno = le64_to_cpu(insert_rec->e_blkno);
+
+	if (ocfs2_extents_adjacent(ext, insert_rec) &&
+	    ocfs2_block_extent_contig(inode->i_sb, ext, blkno))
+			return CONTIG_RIGHT;
+
+	blkno = le64_to_cpu(ext->e_blkno);
+	if (ocfs2_extents_adjacent(insert_rec, ext) &&
+	    ocfs2_block_extent_contig(inode->i_sb, insert_rec, blkno))
+		return CONTIG_LEFT;
+
+	return CONTIG_NONE;
+}
+
+/*
+ * NOTE: We can have pretty much any combination of contiguousness and
+ * appending.
+ *
+ * The usefulness of APPEND_TAIL is more in that it lets us know that
+ * we'll have to update the path to that leaf.
+ */
+enum ocfs2_append_type {
+	APPEND_NONE = 0,
+	APPEND_TAIL,
+};
+
+struct ocfs2_insert_type {
+	enum ocfs2_append_type	ins_appending;
+	enum ocfs2_contig_type	ins_contig;
+	int			ins_contig_index;
+	int			ins_free_records;
+	int			ins_tree_depth;
+};
+
+/*
@@ -244,0 +427,22 @@
+ * Helper function for ocfs2_add_branch() and ocfs2_shift_tree_depth().
+ *
+ * Returns the sum of the rightmost extent rec logical offset and
+ * cluster count.
+ *
+ * ocfs2_add_branch() uses this to determine what logical cluster
+ * value should be populated into the leftmost new branch records.
+ *
+ * ocfs2_shift_tree_depth() uses this to determine the # clusters
+ * value for the new topmost tree record.
+ */
+static inline u32 ocfs2_sum_rightmost_rec(struct ocfs2_extent_list  *el)
+{
+	int i;
+
+	i = le16_to_cpu(el->l_next_free_rec) - 1;
+
+	return le32_to_cpu(el->l_recs[i].e_cpos) +
+		ocfs2_rec_clusters(el, &el->l_recs[i]);
+}
+
+/*
@@ -253 +457 @@
- * contain a single record with e_clusters == 0.
+ * contain a single record with cluster count == 0.
@@ -270,0 +475 @@
+	u32 new_cpos;
@@ -304,0 +510,3 @@
+	eb = (struct ocfs2_extent_block *)last_eb_bh->b_data;
+	new_cpos = ocfs2_sum_rightmost_rec(&eb->h_list);
+
@@ -333 +541,5 @@
-		eb_el->l_recs[0].e_cpos = fe->i_clusters;
+		/*
+		 * This actually counts as an empty extent as
+		 * c_clusters == 0
+		 */
+		eb_el->l_recs[0].e_cpos = cpu_to_le32(new_cpos);
@@ -335 +547,6 @@
-		eb_el->l_recs[0].e_clusters = cpu_to_le32(0);
+		/*
+		 * eb_el isn't always an interior node, but even leaf
+		 * nodes want a zero'd flags and reserved field so
+		 * this gets the whole 32 bits regardless of use.
+		 */
+		eb_el->l_recs[0].e_int_clusters = cpu_to_le32(0);
@@ -379,2 +596,2 @@
-	el->l_recs[i].e_cpos = fe->i_clusters;
-	el->l_recs[i].e_clusters = 0;
+	el->l_recs[i].e_cpos = cpu_to_le32(new_cpos);
+	el->l_recs[i].e_int_clusters = 0;
@@ -427,0 +645 @@
+	u32 new_clusters;
@@ -464,5 +682,2 @@
-	for(i = 0; i < le16_to_cpu(fe_el->l_next_free_rec); i++) {
-		eb_el->l_recs[i].e_cpos = fe_el->l_recs[i].e_cpos;
-		eb_el->l_recs[i].e_clusters = fe_el->l_recs[i].e_clusters;
-		eb_el->l_recs[i].e_blkno = fe_el->l_recs[i].e_blkno;
-	}
+	for(i = 0; i < le16_to_cpu(fe_el->l_next_free_rec); i++)
+		eb_el->l_recs[i] = fe_el->l_recs[i];
@@ -482,0 +698,2 @@
+	new_clusters = ocfs2_sum_rightmost_rec(eb_el);
+
@@ -487,6 +704,3 @@
-	fe_el->l_recs[0].e_clusters = fe->i_clusters;
-	for(i = 1; i < le16_to_cpu(fe_el->l_next_free_rec); i++) {
-		fe_el->l_recs[i].e_cpos = 0;
-		fe_el->l_recs[i].e_clusters = 0;
-		fe_el->l_recs[i].e_blkno = 0;
-	}
+	fe_el->l_recs[0].e_int_clusters = cpu_to_le32(new_clusters);
+	for(i = 1; i < le16_to_cpu(fe_el->l_next_free_rec); i++)
+		memset(&fe_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));
@@ -518,193 +731,0 @@
- * Expects the tree to already have room in the rightmost leaf for the
- * extent.  Updates all the extent blocks (and the dinode) on the way
- * down.
- */
-static int ocfs2_do_insert_extent(struct ocfs2_super *osb,
-				  handle_t *handle,
-				  struct inode *inode,
-				  struct buffer_head *fe_bh,
-				  u64 start_blk,
-				  u32 new_clusters)
-{
-	int status, i, num_bhs = 0;
-	u64 next_blkno;
-	u16 next_free;
-	struct buffer_head **eb_bhs = NULL;
-	struct ocfs2_dinode *fe;
-	struct ocfs2_extent_block *eb;
-	struct ocfs2_extent_list  *el;
-
-	mlog_entry_void();
-
-	status = ocfs2_journal_access(handle, inode, fe_bh,
-				      OCFS2_JOURNAL_ACCESS_WRITE);
-	if (status < 0) {
-		mlog_errno(status);
-		goto bail;
-	}
-
-	fe = (struct ocfs2_dinode *) fe_bh->b_data;
-	el = &fe->id2.i_list;
-	if (el->l_tree_depth) {
-		/* This is another operation where we want to be
-		 * careful about our tree updates. An error here means
-		 * none of the previous changes we made should roll
-		 * forward. As a result, we have to record the buffers
-		 * for this part of the tree in an array and reserve a
-		 * journal write to them before making any changes. */
-		num_bhs = le16_to_cpu(fe->id2.i_list.l_tree_depth);
-		eb_bhs = kcalloc(num_bhs, sizeof(struct buffer_head *),
-				 GFP_KERNEL);
-		if (!eb_bhs) {
-			status = -ENOMEM;
-			mlog_errno(status);
-			goto bail;
-		}
-
-		i = 0;
-		while(el->l_tree_depth) {
-			next_free = le16_to_cpu(el->l_next_free_rec);
-			if (next_free == 0) {
-				ocfs2_error(inode->i_sb,
-					    "Dinode %llu has a bad extent list",
-					    (unsigned long long)OCFS2_I(inode)->ip_blkno);
-				status = -EIO;
-				goto bail;
-			}
-			next_blkno = le64_to_cpu(el->l_recs[next_free - 1].e_blkno);
-
-			BUG_ON(i >= num_bhs);
-			status = ocfs2_read_block(osb, next_blkno, &eb_bhs[i],
-						  OCFS2_BH_CACHED, inode);
-			if (status < 0) {
-				mlog_errno(status);
-				goto bail;
-			}
-			eb = (struct ocfs2_extent_block *) eb_bhs[i]->b_data;
-			if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
-				OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb,
-								 eb);
-				status = -EIO;
-				goto bail;
-			}
-
-			status = ocfs2_journal_access(handle, inode, eb_bhs[i],
-						      OCFS2_JOURNAL_ACCESS_WRITE);
-			if (status < 0) {
-				mlog_errno(status);
-				goto bail;
-			}
-
-			el = &eb->h_list;
-			i++;
-			/* When we leave this loop, eb_bhs[num_bhs - 1] will
-			 * hold the bottom-most leaf extent block. */
-		}
-		BUG_ON(el->l_tree_depth);
-
-		el = &fe->id2.i_list;
-		/* If we have tree depth, then the fe update is
-		 * trivial, and we want to switch el out for the
-		 * bottom-most leaf in order to update it with the
-		 * actual extent data below. */
-		next_free = le16_to_cpu(el->l_next_free_rec);
-		if (next_free == 0) {
-			ocfs2_error(inode->i_sb,
-				    "Dinode %llu has a bad extent list",
-				    (unsigned long long)OCFS2_I(inode)->ip_blkno);
-			status = -EIO;
-			goto bail;
-		}
-		le32_add_cpu(&el->l_recs[next_free - 1].e_clusters,
-			     new_clusters);
-		/* (num_bhs - 1) to avoid the leaf */
-		for(i = 0; i < (num_bhs - 1); i++) {
-			eb = (struct ocfs2_extent_block *) eb_bhs[i]->b_data;
-			el = &eb->h_list;
-
-			/* finally, make our actual change to the
-			 * intermediate extent blocks. */
-			next_free = le16_to_cpu(el->l_next_free_rec);
-			le32_add_cpu(&el->l_recs[next_free - 1].e_clusters,
-				     new_clusters);
-
-			status = ocfs2_journal_dirty(handle, eb_bhs[i]);
-			if (status < 0)
-				mlog_errno(status);
-		}
-		BUG_ON(i != (num_bhs - 1));
-		/* note that the leaf block wasn't touched in
-		 * the loop above */
-		eb = (struct ocfs2_extent_block *) eb_bhs[num_bhs - 1]->b_data;
-		el = &eb->h_list;
-		BUG_ON(el->l_tree_depth);
-	}
-
-	/* yay, we can finally add the actual extent now! */
-	i = le16_to_cpu(el->l_next_free_rec) - 1;
-	if (le16_to_cpu(el->l_next_free_rec) &&
-	    ocfs2_extent_contig(inode, &el->l_recs[i], start_blk)) {
-		le32_add_cpu(&el->l_recs[i].e_clusters, new_clusters);
-	} else if (le16_to_cpu(el->l_next_free_rec) &&
-		   (le32_to_cpu(el->l_recs[i].e_clusters) == 0)) {
-		/* having an empty extent at eof is legal. */
-		if (el->l_recs[i].e_cpos != fe->i_clusters) {
-			ocfs2_error(inode->i_sb,
-				    "Dinode %llu trailing extent is bad: "
-				    "cpos (%u) != number of clusters (%u)",
-				    (unsigned long long)OCFS2_I(inode)->ip_blkno,
-				    le32_to_cpu(el->l_recs[i].e_cpos),
-				    le32_to_cpu(fe->i_clusters));
-			status = -EIO;
-			goto bail;
-		}
-		el->l_recs[i].e_blkno = cpu_to_le64(start_blk);
-		el->l_recs[i].e_clusters = cpu_to_le32(new_clusters);
-	} else {
-		/* No contiguous record, or no empty record at eof, so
-		 * we add a new one. */
-
-		BUG_ON(le16_to_cpu(el->l_next_free_rec) >=
-		       le16_to_cpu(el->l_count));
-		i = le16_to_cpu(el->l_next_free_rec);
-
-		el->l_recs[i].e_blkno = cpu_to_le64(start_blk);
-		el->l_recs[i].e_clusters = cpu_to_le32(new_clusters);
-		el->l_recs[i].e_cpos = fe->i_clusters;
-		le16_add_cpu(&el->l_next_free_rec, 1);
-	}
-
-	/*
-	 * extent_map errors are not fatal, so they are ignored outside
-	 * of flushing the thing.
-	 */
-	status = ocfs2_extent_map_append(inode, &el->l_recs[i],
-					 new_clusters);
-	if (status) {
-		mlog_errno(status);
-		ocfs2_extent_map_drop(inode, le32_to_cpu(fe->i_clusters));
-	}
-
-	status = ocfs2_journal_dirty(handle, fe_bh);
-	if (status < 0)
-		mlog_errno(status);
-	if (fe->id2.i_list.l_tree_depth) {
-		status = ocfs2_journal_dirty(handle, eb_bhs[num_bhs - 1]);
-		if (status < 0)
-			mlog_errno(status);
-	}
-
-	status = 0;
-bail:
-	if (eb_bhs) {
-		for (i = 0; i < num_bhs; i++)
-			if (eb_bhs[i])
-				brelse(eb_bhs[i]);
-		kfree(eb_bhs);
-	}
-
-	mlog_exit(status);
-	return status;
-}
-
-/*
@@ -810,8 +831,5 @@
-/* the caller needs to update fe->i_clusters */
-int ocfs2_insert_extent(struct ocfs2_super *osb,
-			handle_t *handle,
-			struct inode *inode,
-			struct buffer_head *fe_bh,
-			u64 start_blk,
-			u32 new_clusters,
-			struct ocfs2_alloc_context *meta_ac)
+/*
+ * This is only valid for leaf nodes, which are the only ones that can
+ * have empty extents anyway.
+ */
+static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)
@@ -819,6 +837,2 @@
-	int status, i, shift;
-	struct buffer_head *last_eb_bh = NULL;
-	struct buffer_head *bh = NULL;
-	struct ocfs2_dinode *fe;
-	struct ocfs2_extent_block *eb;
-	struct ocfs2_extent_list  *el;
+	return !rec->e_leaf_clusters;
+}
@@ -826 +840,8 @@
-	mlog_entry_void();
+/*
+ * This function will discard the rightmost extent record.
+ */
+static void ocfs2_shift_records_right(struct ocfs2_extent_list *el)
+{
+	int next_free = le16_to_cpu(el->l_next_free_rec);
+	int count = le16_to_cpu(el->l_count);
+	unsigned int num_bytes;
@@ -828,3 +849,3 @@
-	mlog(0, "add %u clusters starting at block %llu to inode %llu\n",
-	     new_clusters, (unsigned long long)start_blk,
-	     (unsigned long long)OCFS2_I(inode)->ip_blkno);
+	BUG_ON(!next_free);
+	/* This will cause us to go off the end of our extent list. */
+	BUG_ON(next_free >= count);
@@ -832,2 +853 @@
-	fe = (struct ocfs2_dinode *) fe_bh->b_data;
-	el = &fe->id2.i_list;
+	num_bytes = sizeof(struct ocfs2_extent_rec) * next_free;
@@ -835,11 +855,2 @@
-	if (el->l_tree_depth) {
-		/* jump to end of tree */
-		status = ocfs2_read_block(osb, le64_to_cpu(fe->i_last_eb_blk),
-					  &last_eb_bh, OCFS2_BH_CACHED, inode);
-		if (status < 0) {
-			mlog_exit(status);
-			goto bail;
-		}
-		eb = (struct ocfs2_extent_block *) last_eb_bh->b_data;
-		el = &eb->h_list;
-	}
+	memmove(&el->l_recs[1], &el->l_recs[0], num_bytes);
+}
@@ -847,7 +858,6 @@
-	/* Can we allocate without adding/shifting tree bits? */
-	i = le16_to_cpu(el->l_next_free_rec) - 1;
-	if (le16_to_cpu(el->l_next_free_rec) == 0
-	    || (le16_to_cpu(el->l_next_free_rec) < le16_to_cpu(el->l_count))
-	    || le32_to_cpu(el->l_recs[i].e_clusters) == 0
-	    || ocfs2_extent_contig(inode, &el->l_recs[i], start_blk))
-		goto out_add;
+static void ocfs2_rotate_leaf(struct ocfs2_extent_list *el,
+			      struct ocfs2_extent_rec *insert_rec)
+{
+	int i, insert_index, next_free, has_empty, num_bytes;
+	u32 insert_cpos = le32_to_cpu(insert_rec->e_cpos);
+	struct ocfs2_extent_rec *rec;
@@ -855,2 +865,2 @@
-	mlog(0, "ocfs2_allocate_extent: couldn't do a simple add, traversing "
-	     "tree now.\n");
+	next_free = le16_to_cpu(el->l_next_free_rec);
+	has_empty = ocfs2_is_empty_extent(&el->l_recs[0]);
@@ -858,2 +868,1508 @@
-	shift = ocfs2_find_branch_target(osb, inode, fe_bh, &bh);
-	if (shift < 0) {
+	BUG_ON(!next_free);
+
+	/* The tree code before us didn't allow enough room in the leaf. */
+	if (el->l_next_free_rec == el->l_count && !has_empty)
+		BUG();
+
+	/*
+	 * The easiest way to approach this is to just remove the
+	 * empty extent and temporarily decrement next_free.
+	 */
+	if (has_empty) {
+		/*
+		 * If next_free was 1 (only an empty extent), this
+		 * loop won't execute, which is fine. We still want
+		 * the decrement above to happen.
+		 */
+		for(i = 0; i < (next_free - 1); i++)
+			el->l_recs[i] = el->l_recs[i+1];
+
+		next_free--;
+	}
+
+	/*
+	 * Figure out what the new record index should be.
+	 */
+	for(i = 0; i < next_free; i++) {
+		rec = &el->l_recs[i];
+
+		if (insert_cpos < le32_to_cpu(rec->e_cpos))
+			break;
+	}
+	insert_index = i;
+
+	mlog(0, "ins %u: index %d, has_empty %d, next_free %d, count %d\n",
+	     insert_cpos, insert_index, has_empty, next_free, le16_to_cpu(el->l_count));
+
+	BUG_ON(insert_index < 0);
+	BUG_ON(insert_index >= le16_to_cpu(el->l_count));
+	BUG_ON(insert_index > next_free);
+
+	/*
+	 * No need to memmove if we're just adding to the tail.
+	 */
+	if (insert_index != next_free) {
+		BUG_ON(next_free >= le16_to_cpu(el->l_count));
+
+		num_bytes = next_free - insert_index;
+		num_bytes *= sizeof(struct ocfs2_extent_rec);
+		memmove(&el->l_recs[insert_index + 1],
+			&el->l_recs[insert_index],
+			num_bytes);
+	}
+
+	/*
+	 * Either we had an empty extent, and need to re-increment or
+	 * there was no empty extent on a non full rightmost leaf node,
+	 * in which case we still need to increment.
+	 */
+	next_free++;
+	el->l_next_free_rec = cpu_to_le16(next_free);
+	/*
+	 * Make sure none of the math above just messed up our tree.
+	 */
+	BUG_ON(le16_to_cpu(el->l_next_free_rec) > le16_to_cpu(el->l_count));
+
+	el->l_recs[insert_index] = *insert_rec;
+
+}
+
+/*
+ * Create an empty extent record .
+ *
+ * l_next_free_rec may be updated.
+ *
+ * If an empty extent already exists do nothing.
+ */
+static void ocfs2_create_empty_extent(struct ocfs2_extent_list *el)
+{
+	int next_free = le16_to_cpu(el->l_next_free_rec);
+
+	BUG_ON(le16_to_cpu(el->l_tree_depth) != 0);
+
+	if (next_free == 0)
+		goto set_and_inc;
+
+	if (ocfs2_is_empty_extent(&el->l_recs[0]))
+		return;
+
+	mlog_bug_on_msg(el->l_count == el->l_next_free_rec,
+			"Asked to create an empty extent in a full list:\n"
+			"count = %u, tree depth = %u",
+			le16_to_cpu(el->l_count),
+			le16_to_cpu(el->l_tree_depth));
+
+	ocfs2_shift_records_right(el);
+
+set_and_inc:
+	le16_add_cpu(&el->l_next_free_rec, 1);
+	memset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));
+}
+
+/*
+ * For a rotation which involves two leaf nodes, the "root node" is
+ * the lowest level tree node which contains a path to both leafs. This
+ * resulting set of information can be used to form a complete "subtree"
+ *
+ * This function is passed two full paths from the dinode down to a
+ * pair of adjacent leaves. It's task is to figure out which path
+ * index contains the subtree root - this can be the root index itself
+ * in a worst-case rotation.
+ *
+ * The array index of the subtree root is passed back.
+ */
+static int ocfs2_find_subtree_root(struct inode *inode,
+				   struct ocfs2_path *left,
+				   struct ocfs2_path *right)
+{
+	int i = 0;
+
+	/*
+	 * Check that the caller passed in two paths from the same tree.
+	 */
+	BUG_ON(path_root_bh(left) != path_root_bh(right));
+
+	do {
+		i++;
+
+		/*
+		 * The caller didn't pass two adjacent paths.
+		 */
+		mlog_bug_on_msg(i > left->p_tree_depth,
+				"Inode %lu, left depth %u, right depth %u\n"
+				"left leaf blk %llu, right leaf blk %llu\n",
+				inode->i_ino, left->p_tree_depth,
+				right->p_tree_depth,
+				(unsigned long long)path_leaf_bh(left)->b_blocknr,
+				(unsigned long long)path_leaf_bh(right)->b_blocknr);
+	} while (left->p_node[i].bh->b_blocknr ==
+		 right->p_node[i].bh->b_blocknr);
+
+	return i - 1;
+}
+
+typedef void (path_insert_t)(void *, struct buffer_head *);
+
+/*
+ * Traverse a btree path in search of cpos, starting at root_el.
+ *
+ * This code can be called with a cpos larger than the tree, in which
+ * case it will return the rightmost path.
+ */
+static int __ocfs2_find_path(struct inode *inode,
+			     struct ocfs2_extent_list *root_el, u32 cpos,
+			     path_insert_t *func, void *data)
+{
+	int i, ret = 0;
+	u32 range;
+	u64 blkno;
+	struct buffer_head *bh = NULL;
+	struct ocfs2_extent_block *eb;
+	struct ocfs2_extent_list *el;
+	struct ocfs2_extent_rec *rec;
+	struct ocfs2_inode_info *oi = OCFS2_I(inode);
+
+	el = root_el;
+	while (el->l_tree_depth) {
+		if (le16_to_cpu(el->l_next_free_rec) == 0) {
+			ocfs2_error(inode->i_sb,
+				    "Inode %llu has empty extent list at "
+				    "depth %u\n",
+				    (unsigned long long)oi->ip_blkno,
+				    le16_to_cpu(el->l_tree_depth));
+			ret = -EROFS;
+			goto out;
+
+		}
+
+		for(i = 0; i < le16_to_cpu(el->l_next_free_rec) - 1; i++) {
+			rec = &el->l_recs[i];
+
+			/*
+			 * In the case that cpos is off the allocation
+			 * tree, this should just wind up returning the
+			 * rightmost record.
+			 */
+			range = le32_to_cpu(rec->e_cpos) +
+				ocfs2_rec_clusters(el, rec);
+			if (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)
+			    break;
+		}
+
+		blkno = le64_to_cpu(el->l_recs[i].e_blkno);
+		if (blkno == 0) {
+			ocfs2_error(inode->i_sb,
+				    "Inode %llu has bad blkno in extent list "
+				    "at depth %u (index %d)\n",
+				    (unsigned long long)oi->ip_blkno,
+				    le16_to_cpu(el->l_tree_depth), i);
+			ret = -EROFS;
+			goto out;
+		}
+
+		brelse(bh);
+		bh = NULL;
+		ret = ocfs2_read_block(OCFS2_SB(inode->i_sb), blkno,
+				       &bh, OCFS2_BH_CACHED, inode);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		eb = (struct ocfs2_extent_block *) bh->b_data;
+		el = &eb->h_list;
+		if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
+			OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
+			ret = -EIO;
+			goto out;
+		}
+
+		if (le16_to_cpu(el->l_next_free_rec) >
+		    le16_to_cpu(el->l_count)) {
+			ocfs2_error(inode->i_sb,
+				    "Inode %llu has bad count in extent list "
+				    "at block %llu (next free=%u, count=%u)\n",
+				    (unsigned long long)oi->ip_blkno,
+				    (unsigned long long)bh->b_blocknr,
+				    le16_to_cpu(el->l_next_free_rec),
+				    le16_to_cpu(el->l_count));
+			ret = -EROFS;
+			goto out;
+		}
+
+		if (func)
+			func(data, bh);
+	}
+
+out:
+	/*
+	 * Catch any trailing bh that the loop didn't handle.
+	 */
+	brelse(bh);
+
+	return ret;
+}
+
+/*
+ * Given an initialized path (that is, it has a valid root extent
+ * list), this function will traverse the btree in search of the path
+ * which would contain cpos.
+ *
+ * The path traveled is recorded in the path structure.
+ *
+ * Note that this will not do any comparisons on leaf node extent
+ * records, so it will work fine in the case that we just added a tree
+ * branch.
+ */
+struct find_path_data {
+	int index;
+	struct ocfs2_path *path;
+};
+static void find_path_ins(void *data, struct buffer_head *bh)
+{
+	struct find_path_data *fp = data;
+
+	get_bh(bh);
+	ocfs2_path_insert_eb(fp->path, fp->index, bh);
+	fp->index++;
+}
+static int ocfs2_find_path(struct inode *inode, struct ocfs2_path *path,
+			   u32 cpos)
+{
+	struct find_path_data data;
+
+	data.index = 1;
+	data.path = path;
+	return __ocfs2_find_path(inode, path_root_el(path), cpos,
+				 find_path_ins, &data);
+}
+
+static void find_leaf_ins(void *data, struct buffer_head *bh)
+{
+	struct ocfs2_extent_block *eb =(struct ocfs2_extent_block *)bh->b_data;
+	struct ocfs2_extent_list *el = &eb->h_list;
+	struct buffer_head **ret = data;
+
+	/* We want to retain only the leaf block. */
+	if (le16_to_cpu(el->l_tree_depth) == 0) {
+		get_bh(bh);
+		*ret = bh;
+	}
+}
+/*
+ * Find the leaf block in the tree which would contain cpos. No
+ * checking of the actual leaf is done.
+ *
+ * Some paths want to call this instead of allocating a path structure
+ * and calling ocfs2_find_path().
+ *
+ * This function doesn't handle non btree extent lists.
+ */
+int ocfs2_find_leaf(struct inode *inode, struct ocfs2_extent_list *root_el,
+		    u32 cpos, struct buffer_head **leaf_bh)
+{
+	int ret;
+	struct buffer_head *bh = NULL;
+
+	ret = __ocfs2_find_path(inode, root_el, cpos, find_leaf_ins, &bh);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	*leaf_bh = bh;
+out:
+	return ret;
+}
+
+/*
+ * Adjust the adjacent records (left_rec, right_rec) involved in a rotation.
+ *
+ * Basically, we've moved stuff around at the bottom of the tree and
+ * we need to fix up the extent records above the changes to reflect
+ * the new changes.
+ *
+ * left_rec: the record on the left.
+ * left_child_el: is the child list pointed to by left_rec
+ * right_rec: the record to the right of left_rec
+ * right_child_el: is the child list pointed to by right_rec
+ *
+ * By definition, this only works on interior nodes.
+ */
+static void ocfs2_adjust_adjacent_records(struct ocfs2_extent_rec *left_rec,
+				  struct ocfs2_extent_list *left_child_el,
+				  struct ocfs2_extent_rec *right_rec,
+				  struct ocfs2_extent_list *right_child_el)
+{
+	u32 left_clusters, right_end;
+
+	/*
+	 * Interior nodes never have holes. Their cpos is the cpos of
+	 * the leftmost record in their child list. Their cluster
+	 * count covers the full theoretical range of their child list
+	 * - the range between their cpos and the cpos of the record
+	 * immediately to their right.
+	 */
+	left_clusters = le32_to_cpu(right_child_el->l_recs[0].e_cpos);
+	left_clusters -= le32_to_cpu(left_rec->e_cpos);
+	left_rec->e_int_clusters = cpu_to_le32(left_clusters);
+
+	/*
+	 * Calculate the rightmost cluster count boundary before
+	 * moving cpos - we will need to adjust clusters after
+	 * updating e_cpos to keep the same highest cluster count.
+	 */
+	right_end = le32_to_cpu(right_rec->e_cpos);
+	right_end += le32_to_cpu(right_rec->e_int_clusters);
+
+	right_rec->e_cpos = left_rec->e_cpos;
+	le32_add_cpu(&right_rec->e_cpos, left_clusters);
+
+	right_end -= le32_to_cpu(right_rec->e_cpos);
+	right_rec->e_int_clusters = cpu_to_le32(right_end);
+}
+
+/*
+ * Adjust the adjacent root node records involved in a
+ * rotation. left_el_blkno is passed in as a key so that we can easily
+ * find it's index in the root list.
+ */
+static void ocfs2_adjust_root_records(struct ocfs2_extent_list *root_el,
+				      struct ocfs2_extent_list *left_el,
+				      struct ocfs2_extent_list *right_el,
+				      u64 left_el_blkno)
+{
+	int i;
+
+	BUG_ON(le16_to_cpu(root_el->l_tree_depth) <=
+	       le16_to_cpu(left_el->l_tree_depth));
+
+	for(i = 0; i < le16_to_cpu(root_el->l_next_free_rec) - 1; i++) {
+		if (le64_to_cpu(root_el->l_recs[i].e_blkno) == left_el_blkno)
+			break;
+	}
+
+	/*
+	 * The path walking code should have never returned a root and
+	 * two paths which are not adjacent.
+	 */
+	BUG_ON(i >= (le16_to_cpu(root_el->l_next_free_rec) - 1));
+
+	ocfs2_adjust_adjacent_records(&root_el->l_recs[i], left_el,
+				      &root_el->l_recs[i + 1], right_el);
+}
+
+/*
+ * We've changed a leaf block (in right_path) and need to reflect that
+ * change back up the subtree.
+ *
+ * This happens in multiple places:
+ *   - When we've moved an extent record from the left path leaf to the right
+ *     path leaf to make room for an empty extent in the left path leaf.
+ *   - When our insert into the right path leaf is at the leftmost edge
+ *     and requires an update of the path immediately to it's left. This
+ *     can occur at the end of some types of rotation and appending inserts.
+ */
+static void ocfs2_complete_edge_insert(struct inode *inode, handle_t *handle,
+				       struct ocfs2_path *left_path,
+				       struct ocfs2_path *right_path,
+				       int subtree_index)
+{
+	int ret, i, idx;
+	struct ocfs2_extent_list *el, *left_el, *right_el;
+	struct ocfs2_extent_rec *left_rec, *right_rec;
+	struct buffer_head *root_bh = left_path->p_node[subtree_index].bh;
+
+	/*
+	 * Update the counts and position values within all the
+	 * interior nodes to reflect the leaf rotation we just did.
+	 *
+	 * The root node is handled below the loop.
+	 *
+	 * We begin the loop with right_el and left_el pointing to the
+	 * leaf lists and work our way up.
+	 *
+	 * NOTE: within this loop, left_el and right_el always refer
+	 * to the *child* lists.
+	 */
+	left_el = path_leaf_el(left_path);
+	right_el = path_leaf_el(right_path);
+	for(i = left_path->p_tree_depth - 1; i > subtree_index; i--) {
+		mlog(0, "Adjust records at index %u\n", i);
+
+		/*
+		 * One nice property of knowing that all of these
+		 * nodes are below the root is that we only deal with
+		 * the leftmost right node record and the rightmost
+		 * left node record.
+		 */
+		el = left_path->p_node[i].el;
+		idx = le16_to_cpu(left_el->l_next_free_rec) - 1;
+		left_rec = &el->l_recs[idx];
+
+		el = right_path->p_node[i].el;
+		right_rec = &el->l_recs[0];
+
+		ocfs2_adjust_adjacent_records(left_rec, left_el, right_rec,
+					      right_el);
+
+		ret = ocfs2_journal_dirty(handle, left_path->p_node[i].bh);
+		if (ret)
+			mlog_errno(ret);
+
+		ret = ocfs2_journal_dirty(handle, right_path->p_node[i].bh);
+		if (ret)
+			mlog_errno(ret);
+
+		/*
+		 * Setup our list pointers now so that the current
+		 * parents become children in the next iteration.
+		 */
+		left_el = left_path->p_node[i].el;
+		right_el = right_path->p_node[i].el;
+	}
+
+	/*
+	 * At the root node, adjust the two adjacent records which
+	 * begin our path to the leaves.
+	 */
+
+	el = left_path->p_node[subtree_index].el;
+	left_el = left_path->p_node[subtree_index + 1].el;
+	right_el = right_path->p_node[subtree_index + 1].el;
+
+	ocfs2_adjust_root_records(el, left_el, right_el,
+				  left_path->p_node[subtree_index + 1].bh->b_blocknr);
+
+	root_bh = left_path->p_node[subtree_index].bh;
+
+	ret = ocfs2_journal_dirty(handle, root_bh);
+	if (ret)
+		mlog_errno(ret);
+}
+
+static int ocfs2_rotate_subtree_right(struct inode *inode,
+				      handle_t *handle,
+				      struct ocfs2_path *left_path,
+				      struct ocfs2_path *right_path,
+				      int subtree_index)
+{
+	int ret, i;
+	struct buffer_head *right_leaf_bh;
+	struct buffer_head *left_leaf_bh = NULL;
+	struct buffer_head *root_bh;
+	struct ocfs2_extent_list *right_el, *left_el;
+	struct ocfs2_extent_rec move_rec;
+
+	left_leaf_bh = path_leaf_bh(left_path);
+	left_el = path_leaf_el(left_path);
+
+	if (left_el->l_next_free_rec != left_el->l_count) {
+		ocfs2_error(inode->i_sb,
+			    "Inode %llu has non-full interior leaf node %llu"
+			    "(next free = %u)",
+			    (unsigned long long)OCFS2_I(inode)->ip_blkno,
+			    (unsigned long long)left_leaf_bh->b_blocknr,
+			    le16_to_cpu(left_el->l_next_free_rec));
+		return -EROFS;
+	}
+
+	/*
+	 * This extent block may already have an empty record, so we
+	 * return early if so.
+	 */
+	if (ocfs2_is_empty_extent(&left_el->l_recs[0]))
+		return 0;
+
+	root_bh = left_path->p_node[subtree_index].bh;
+	BUG_ON(root_bh != right_path->p_node[subtree_index].bh);
+
+	ret = ocfs2_journal_access(handle, inode, root_bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	for(i = subtree_index + 1; i < path_num_items(right_path); i++) {
+		ret = ocfs2_journal_access(handle, inode,
+					   right_path->p_node[i].bh,
+					   OCFS2_JOURNAL_ACCESS_WRITE);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		ret = ocfs2_journal_access(handle, inode,
+					   left_path->p_node[i].bh,
+					   OCFS2_JOURNAL_ACCESS_WRITE);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+	right_leaf_bh = path_leaf_bh(right_path);
+	right_el = path_leaf_el(right_path);
+
+	/* This is a code error, not a disk corruption. */
+	mlog_bug_on_msg(!right_el->l_next_free_rec, "Inode %llu: Rotate fails "
+			"because rightmost leaf block %llu is empty\n",
+			(unsigned long long)OCFS2_I(inode)->ip_blkno,
+			(unsigned long long)right_leaf_bh->b_blocknr);
+
+	ocfs2_create_empty_extent(right_el);
+
+	ret = ocfs2_journal_dirty(handle, right_leaf_bh);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	/* Do the copy now. */
+	i = le16_to_cpu(left_el->l_next_free_rec) - 1;
+	move_rec = left_el->l_recs[i];
+	right_el->l_recs[0] = move_rec;
+
+	/*
+	 * Clear out the record we just copied and shift everything
+	 * over, leaving an empty extent in the left leaf.
+	 *
+	 * We temporarily subtract from next_free_rec so that the
+	 * shift will lose the tail record (which is now defunct).
+	 */
+	le16_add_cpu(&left_el->l_next_free_rec, -1);
+	ocfs2_shift_records_right(left_el);
+	memset(&left_el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));
+	le16_add_cpu(&left_el->l_next_free_rec, 1);
+
+	ret = ocfs2_journal_dirty(handle, left_leaf_bh);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ocfs2_complete_edge_insert(inode, handle, left_path, right_path,
+				subtree_index);
+
+out:
+	return ret;
+}
+
+/*
+ * Given a full path, determine what cpos value would return us a path
+ * containing the leaf immediately to the left of the current one.
+ *
+ * Will return zero if the path passed in is already the leftmost path.
+ */
+static int ocfs2_find_cpos_for_left_leaf(struct super_block *sb,
+					 struct ocfs2_path *path, u32 *cpos)
+{
+	int i, j, ret = 0;
+	u64 blkno;
+	struct ocfs2_extent_list *el;
+
+	BUG_ON(path->p_tree_depth == 0);
+
+	*cpos = 0;
+
+	blkno = path_leaf_bh(path)->b_blocknr;
+
+	/* Start at the tree node just above the leaf and work our way up. */
+	i = path->p_tree_depth - 1;
+	while (i >= 0) {
+		el = path->p_node[i].el;
+
+		/*
+		 * Find the extent record just before the one in our
+		 * path.
+		 */
+		for(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {
+			if (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {
+				if (j == 0) {
+					if (i == 0) {
+						/*
+						 * We've determined that the
+						 * path specified is already
+						 * the leftmost one - return a
+						 * cpos of zero.
+						 */
+						goto out;
+					}
+					/*
+					 * The leftmost record points to our
+					 * leaf - we need to travel up the
+					 * tree one level.
+					 */
+					goto next_node;
+				}
+
+				*cpos = le32_to_cpu(el->l_recs[j - 1].e_cpos);
+				*cpos = *cpos + ocfs2_rec_clusters(el,
+							   &el->l_recs[j - 1]);
+				*cpos = *cpos - 1;
+				goto out;
+			}
+		}
+
+		/*
+		 * If we got here, we never found a valid node where
+		 * the tree indicated one should be.
+		 */
+		ocfs2_error(sb,
+			    "Invalid extent tree at extent block %llu\n",
+			    (unsigned long long)blkno);
+		ret = -EROFS;
+		goto out;
+
+next_node:
+		blkno = path->p_node[i].bh->b_blocknr;
+		i--;
+	}
+
+out:
+	return ret;
+}
+
+static int ocfs2_extend_rotate_transaction(handle_t *handle, int subtree_depth,
+					   struct ocfs2_path *path)
+{
+	int credits = (path->p_tree_depth - subtree_depth) * 2 + 1;
+
+	if (handle->h_buffer_credits < credits)
+		return ocfs2_extend_trans(handle, credits);
+
+	return 0;
+}
+
+/*
+ * Trap the case where we're inserting into the theoretical range past
+ * the _actual_ left leaf range. Otherwise, we'll rotate a record
+ * whose cpos is less than ours into the right leaf.
+ *
+ * It's only necessary to look at the rightmost record of the left
+ * leaf because the logic that calls us should ensure that the
+ * theoretical ranges in the path components above the leaves are
+ * correct.
+ */
+static int ocfs2_rotate_requires_path_adjustment(struct ocfs2_path *left_path,
+						 u32 insert_cpos)
+{
+	struct ocfs2_extent_list *left_el;
+	struct ocfs2_extent_rec *rec;
+	int next_free;
+
+	left_el = path_leaf_el(left_path);
+	next_free = le16_to_cpu(left_el->l_next_free_rec);
+	rec = &left_el->l_recs[next_free - 1];
+
+	if (insert_cpos > le32_to_cpu(rec->e_cpos))
+		return 1;
+	return 0;
+}
+
+/*
+ * Rotate all the records in a btree right one record, starting at insert_cpos.
+ *
+ * The path to the rightmost leaf should be passed in.
+ *
+ * The array is assumed to be large enough to hold an entire path (tree depth).
+ *
+ * Upon succesful return from this function:
+ *
+ * - The 'right_path' array will contain a path to the leaf block
+ *   whose range contains e_cpos.
+ * - That leaf block will have a single empty extent in list index 0.
+ * - In the case that the rotation requires a post-insert update,
+ *   *ret_left_path will contain a valid path which can be passed to
+ *   ocfs2_insert_path().
+ */
+static int ocfs2_rotate_tree_right(struct inode *inode,
+				   handle_t *handle,
+				   u32 insert_cpos,
+				   struct ocfs2_path *right_path,
+				   struct ocfs2_path **ret_left_path)
+{
+	int ret, start;
+	u32 cpos;
+	struct ocfs2_path *left_path = NULL;
+
+	*ret_left_path = NULL;
+
+	left_path = ocfs2_new_path(path_root_bh(right_path),
+				   path_root_el(right_path));
+	if (!left_path) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ret = ocfs2_find_cpos_for_left_leaf(inode->i_sb, right_path, &cpos);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	mlog(0, "Insert: %u, first left path cpos: %u\n", insert_cpos, cpos);
+
+	/*
+	 * What we want to do here is:
+	 *
+	 * 1) Start with the rightmost path.
+	 *
+	 * 2) Determine a path to the leaf block directly to the left
+	 *    of that leaf.
+	 *
+	 * 3) Determine the 'subtree root' - the lowest level tree node
+	 *    which contains a path to both leaves.
+	 *
+	 * 4) Rotate the subtree.
+	 *
+	 * 5) Find the next subtree by considering the left path to be
+	 *    the new right path.
+	 *
+	 * The check at the top of this while loop also accepts
+	 * insert_cpos == cpos because cpos is only a _theoretical_
+	 * value to get us the left path - insert_cpos might very well
+	 * be filling that hole.
+	 *
+	 * Stop at a cpos of '0' because we either started at the
+	 * leftmost branch (i.e., a tree with one branch and a
+	 * rotation inside of it), or we've gone as far as we can in
+	 * rotating subtrees.
+	 */
+	while (cpos && insert_cpos <= cpos) {
+		mlog(0, "Rotating a tree: ins. cpos: %u, left path cpos: %u\n",
+		     insert_cpos, cpos);
+
+		ret = ocfs2_find_path(inode, left_path, cpos);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		mlog_bug_on_msg(path_leaf_bh(left_path) ==
+				path_leaf_bh(right_path),
+				"Inode %lu: error during insert of %u "
+				"(left path cpos %u) results in two identical "
+				"paths ending at %llu\n",
+				inode->i_ino, insert_cpos, cpos,
+				(unsigned long long)
+				path_leaf_bh(left_path)->b_blocknr);
+
+		if (ocfs2_rotate_requires_path_adjustment(left_path,
+							  insert_cpos)) {
+			mlog(0, "Path adjustment required\n");
+
+			/*
+			 * We've rotated the tree as much as we
+			 * should. The rest is up to
+			 * ocfs2_insert_path() to complete, after the
+			 * record insertion. We indicate this
+			 * situation by returning the left path.
+			 *
+			 * The reason we don't adjust the records here
+			 * before the record insert is that an error
+			 * later might break the rule where a parent
+			 * record e_cpos will reflect the actual
+			 * e_cpos of the 1st nonempty record of the
+			 * child list.
+			 */
+			*ret_left_path = left_path;
+			goto out_ret_path;
+		}
+
+		start = ocfs2_find_subtree_root(inode, left_path, right_path);
+
+		mlog(0, "Subtree root at index %d (blk %llu, depth %d)\n",
+		     start,
+		     (unsigned long long) right_path->p_node[start].bh->b_blocknr,
+		     right_path->p_tree_depth);
+
+		ret = ocfs2_extend_rotate_transaction(handle, start,
+						      right_path);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		ret = ocfs2_rotate_subtree_right(inode, handle, left_path,
+						 right_path, start);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		/*
+		 * There is no need to re-read the next right path
+		 * as we know that it'll be our current left
+		 * path. Optimize by copying values instead.
+		 */
+		ocfs2_mv_path(right_path, left_path);
+
+		ret = ocfs2_find_cpos_for_left_leaf(inode->i_sb, right_path,
+						    &cpos);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+out:
+	ocfs2_free_path(left_path);
+
+out_ret_path:
+	return ret;
+}
+
+/*
+ * Do the final bits of extent record insertion at the target leaf
+ * list. If this leaf is part of an allocation tree, it is assumed
+ * that the tree above has been prepared.
+ */
+static void ocfs2_insert_at_leaf(struct ocfs2_extent_rec *insert_rec,
+				 struct ocfs2_extent_list *el,
+				 struct ocfs2_insert_type *insert,
+				 struct inode *inode)
+{
+	int i = insert->ins_contig_index;
+	unsigned int range;
+	struct ocfs2_extent_rec *rec;
+
+	BUG_ON(le16_to_cpu(el->l_tree_depth) != 0);
+
+	/*
+	 * Contiguous insert - either left or right.
+	 */
+	if (insert->ins_contig != CONTIG_NONE) {
+		rec = &el->l_recs[i];
+		if (insert->ins_contig == CONTIG_LEFT) {
+			rec->e_blkno = insert_rec->e_blkno;
+			rec->e_cpos = insert_rec->e_cpos;
+		}
+		le16_add_cpu(&rec->e_leaf_clusters,
+			     le16_to_cpu(insert_rec->e_leaf_clusters));
+		return;
+	}
+
+	/*
+	 * Handle insert into an empty leaf.
+	 */
+	if (le16_to_cpu(el->l_next_free_rec) == 0 ||
+	    ((le16_to_cpu(el->l_next_free_rec) == 1) &&
+	     ocfs2_is_empty_extent(&el->l_recs[0]))) {
+		el->l_recs[0] = *insert_rec;
+		el->l_next_free_rec = cpu_to_le16(1);
+		return;
+	}
+
+	/*
+	 * Appending insert.
+	 */
+	if (insert->ins_appending == APPEND_TAIL) {
+		i = le16_to_cpu(el->l_next_free_rec) - 1;
+		rec = &el->l_recs[i];
+		range = le32_to_cpu(rec->e_cpos)
+			+ le16_to_cpu(rec->e_leaf_clusters);
+		BUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);
+
+		mlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=
+				le16_to_cpu(el->l_count),
+				"inode %lu, depth %u, count %u, next free %u, "
+				"rec.cpos %u, rec.clusters %u, "
+				"insert.cpos %u, insert.clusters %u\n",
+				inode->i_ino,
+				le16_to_cpu(el->l_tree_depth),
+				le16_to_cpu(el->l_count),
+				le16_to_cpu(el->l_next_free_rec),
+				le32_to_cpu(el->l_recs[i].e_cpos),
+				le16_to_cpu(el->l_recs[i].e_leaf_clusters),
+				le32_to_cpu(insert_rec->e_cpos),
+				le16_to_cpu(insert_rec->e_leaf_clusters));
+		i++;
+		el->l_recs[i] = *insert_rec;
+		le16_add_cpu(&el->l_next_free_rec, 1);
+		return;
+	}
+
+	/*
+	 * Ok, we have to rotate.
+	 *
+	 * At this point, it is safe to assume that inserting into an
+	 * empty leaf and appending to a leaf have both been handled
+	 * above.
+	 *
+	 * This leaf needs to have space, either by the empty 1st
+	 * extent record, or by virtue of an l_next_rec < l_count.
+	 */
+	ocfs2_rotate_leaf(el, insert_rec);
+}
+
+static inline void ocfs2_update_dinode_clusters(struct inode *inode,
+						struct ocfs2_dinode *di,
+						u32 clusters)
+{
+	le32_add_cpu(&di->i_clusters, clusters);
+	spin_lock(&OCFS2_I(inode)->ip_lock);
+	OCFS2_I(inode)->ip_clusters = le32_to_cpu(di->i_clusters);
+	spin_unlock(&OCFS2_I(inode)->ip_lock);
+}
+
+static int ocfs2_append_rec_to_path(struct inode *inode, handle_t *handle,
+				    struct ocfs2_extent_rec *insert_rec,
+				    struct ocfs2_path *right_path,
+				    struct ocfs2_path **ret_left_path)
+{
+	int ret, i, next_free;
+	struct buffer_head *bh;
+	struct ocfs2_extent_list *el;
+	struct ocfs2_path *left_path = NULL;
+
+	*ret_left_path = NULL;
+
+	/*
+	 * This shouldn't happen for non-trees. The extent rec cluster
+	 * count manipulation below only works for interior nodes.
+	 */
+	BUG_ON(right_path->p_tree_depth == 0);
+
+	/*
+	 * If our appending insert is at the leftmost edge of a leaf,
+	 * then we might need to update the rightmost records of the
+	 * neighboring path.
+	 */
+	el = path_leaf_el(right_path);
+	next_free = le16_to_cpu(el->l_next_free_rec);
+	if (next_free == 0 ||
+	    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0]))) {
+		u32 left_cpos;
+
+		ret = ocfs2_find_cpos_for_left_leaf(inode->i_sb, right_path,
+						    &left_cpos);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		mlog(0, "Append may need a left path update. cpos: %u, "
+		     "left_cpos: %u\n", le32_to_cpu(insert_rec->e_cpos),
+		     left_cpos);
+
+		/*
+		 * No need to worry if the append is already in the
+		 * leftmost leaf.
+		 */
+		if (left_cpos) {
+			left_path = ocfs2_new_path(path_root_bh(right_path),
+						   path_root_el(right_path));
+			if (!left_path) {
+				ret = -ENOMEM;
+				mlog_errno(ret);
+				goto out;
+			}
+
+			ret = ocfs2_find_path(inode, left_path, left_cpos);
+			if (ret) {
+				mlog_errno(ret);
+				goto out;
+			}
+
+			/*
+			 * ocfs2_insert_path() will pass the left_path to the
+			 * journal for us.
+			 */
+		}
+	}
+
+	ret = ocfs2_journal_access_path(inode, handle, right_path);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	el = path_root_el(right_path);
+	bh = path_root_bh(right_path);
+	i = 0;
+	while (1) {
+		struct ocfs2_extent_rec *rec;
+
+		next_free = le16_to_cpu(el->l_next_free_rec);
+		if (next_free == 0) {
+			ocfs2_error(inode->i_sb,
+				    "Dinode %llu has a bad extent list",
+				    (unsigned long long)OCFS2_I(inode)->ip_blkno);
+			ret = -EIO;
+			goto out;
+		}
+
+		rec = &el->l_recs[next_free - 1];
+
+		rec->e_int_clusters = insert_rec->e_cpos;
+		le32_add_cpu(&rec->e_int_clusters,
+			     le16_to_cpu(insert_rec->e_leaf_clusters));
+		le32_add_cpu(&rec->e_int_clusters,
+			     -le32_to_cpu(rec->e_cpos));
+
+		ret = ocfs2_journal_dirty(handle, bh);
+		if (ret)
+			mlog_errno(ret);
+
+		/* Don't touch the leaf node */
+		if (++i >= right_path->p_tree_depth)
+			break;
+
+		bh = right_path->p_node[i].bh;
+		el = right_path->p_node[i].el;
+	}
+
+	*ret_left_path = left_path;
+	ret = 0;
+out:
+	if (ret != 0)
+		ocfs2_free_path(left_path);
+
+	return ret;
+}
+
+/*
+ * This function only does inserts on an allocation b-tree. For dinode
+ * lists, ocfs2_insert_at_leaf() is called directly.
+ *
+ * right_path is the path we want to do the actual insert
+ * in. left_path should only be passed in if we need to update that
+ * portion of the tree after an edge insert.
+ */
+static int ocfs2_insert_path(struct inode *inode,
+			     handle_t *handle,
+			     struct ocfs2_path *left_path,
+			     struct ocfs2_path *right_path,
+			     struct ocfs2_extent_rec *insert_rec,
+			     struct ocfs2_insert_type *insert)
+{
+	int ret, subtree_index;
+	struct buffer_head *leaf_bh = path_leaf_bh(right_path);
+	struct ocfs2_extent_list *el;
+
+	/*
+	 * Pass both paths to the journal. The majority of inserts
+	 * will be touching all components anyway.
+	 */
+	ret = ocfs2_journal_access_path(inode, handle, right_path);
+	if (ret < 0) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	if (left_path) {
+		int credits = handle->h_buffer_credits;
+
+		/*
+		 * There's a chance that left_path got passed back to
+		 * us without being accounted for in the
+		 * journal. Extend our transaction here to be sure we
+		 * can change those blocks.
+		 */
+		credits += left_path->p_tree_depth;
+
+		ret = ocfs2_extend_trans(handle, credits);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		ret = ocfs2_journal_access_path(inode, handle, left_path);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+	el = path_leaf_el(right_path);
+
+	ocfs2_insert_at_leaf(insert_rec, el, insert, inode);
+	ret = ocfs2_journal_dirty(handle, leaf_bh);
+	if (ret)
+		mlog_errno(ret);
+
+	if (left_path) {
+		/*
+		 * The rotate code has indicated that we need to fix
+		 * up portions of the tree after the insert.
+		 *
+		 * XXX: Should we extend the transaction here?
+		 */
+		subtree_index = ocfs2_find_subtree_root(inode, left_path,
+							right_path);
+		ocfs2_complete_edge_insert(inode, handle, left_path,
+					   right_path, subtree_index);
+	}
+
+	ret = 0;
+out:
+	return ret;
+}
+
+static int ocfs2_do_insert_extent(struct inode *inode,
+				  handle_t *handle,
+				  struct buffer_head *di_bh,
+				  struct ocfs2_extent_rec *insert_rec,
+				  struct ocfs2_insert_type *type)
+{
+	int ret, rotate = 0;
+	u32 cpos;
+	struct ocfs2_path *right_path = NULL;
+	struct ocfs2_path *left_path = NULL;
+	struct ocfs2_dinode *di;
+	struct ocfs2_extent_list *el;
+
+	di = (struct ocfs2_dinode *) di_bh->b_data;
+	el = &di->id2.i_list;
+
+	ret = ocfs2_journal_access(handle, inode, di_bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	if (le16_to_cpu(el->l_tree_depth) == 0) {
+		ocfs2_insert_at_leaf(insert_rec, el, type, inode);
+		goto out_update_clusters;
+	}
+
+	right_path = ocfs2_new_inode_path(di_bh);
+	if (!right_path) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	/*
+	 * Determine the path to start with. Rotations need the
+	 * rightmost path, everything else can go directly to the
+	 * target leaf.
+	 */
+	cpos = le32_to_cpu(insert_rec->e_cpos);
+	if (type->ins_appending == APPEND_NONE &&
+	    type->ins_contig == CONTIG_NONE) {
+		rotate = 1;
+		cpos = UINT_MAX;
+	}
+
+	ret = ocfs2_find_path(inode, right_path, cpos);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	/*
+	 * Rotations and appends need special treatment - they modify
+	 * parts of the tree's above them.
+	 *
+	 * Both might pass back a path immediate to the left of the
+	 * one being inserted to. This will be cause
+	 * ocfs2_insert_path() to modify the rightmost records of
+	 * left_path to account for an edge insert.
+	 *
+	 * XXX: When modifying this code, keep in mind that an insert
+	 * can wind up skipping both of these two special cases...
+	 */
+	if (rotate) {
+		ret = ocfs2_rotate_tree_right(inode, handle,
+					      le32_to_cpu(insert_rec->e_cpos),
+					      right_path, &left_path);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+	} else if (type->ins_appending == APPEND_TAIL
+		   && type->ins_contig != CONTIG_LEFT) {
+		ret = ocfs2_append_rec_to_path(inode, handle, insert_rec,
+					       right_path, &left_path);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+	ret = ocfs2_insert_path(inode, handle, left_path, right_path,
+				insert_rec, type);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+out_update_clusters:
+	ocfs2_update_dinode_clusters(inode, di,
+				     le16_to_cpu(insert_rec->e_leaf_clusters));
+
+	ret = ocfs2_journal_dirty(handle, di_bh);
+	if (ret)
+		mlog_errno(ret);
+
+out:
+	ocfs2_free_path(left_path);
+	ocfs2_free_path(right_path);
+
+	return ret;
+}
+
+static void ocfs2_figure_contig_type(struct inode *inode,
+				     struct ocfs2_insert_type *insert,
+				     struct ocfs2_extent_list *el,
+				     struct ocfs2_extent_rec *insert_rec)
+{
+	int i;
+	enum ocfs2_contig_type contig_type = CONTIG_NONE;
+
+	BUG_ON(le16_to_cpu(el->l_tree_depth) != 0);
+
+	for(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {
+		contig_type = ocfs2_extent_contig(inode, &el->l_recs[i],
+						  insert_rec);
+		if (contig_type != CONTIG_NONE) {
+			insert->ins_contig_index = i;
+			break;
+		}
+	}
+	insert->ins_contig = contig_type;
+}
+
+/*
+ * This should only be called against the righmost leaf extent list.
+ *
+ * ocfs2_figure_appending_type() will figure out whether we'll have to
+ * insert at the tail of the rightmost leaf.
+ *
+ * This should also work against the dinode list for tree's with 0
+ * depth. If we consider the dinode list to be the rightmost leaf node
+ * then the logic here makes sense.
+ */
+static void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,
+					struct ocfs2_extent_list *el,
+					struct ocfs2_extent_rec *insert_rec)
+{
+	int i;
+	u32 cpos = le32_to_cpu(insert_rec->e_cpos);
+	struct ocfs2_extent_rec *rec;
+
+	insert->ins_appending = APPEND_NONE;
+
+	BUG_ON(le16_to_cpu(el->l_tree_depth) != 0);
+
+	if (!el->l_next_free_rec)
+		goto set_tail_append;
+
+	if (ocfs2_is_empty_extent(&el->l_recs[0])) {
+		/* Were all records empty? */
+		if (le16_to_cpu(el->l_next_free_rec) == 1)
+			goto set_tail_append;
+	}
+
+	i = le16_to_cpu(el->l_next_free_rec) - 1;
+	rec = &el->l_recs[i];
+
+	if (cpos >=
+	    (le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)))
+		goto set_tail_append;
+
+	return;
+
+set_tail_append:
+	insert->ins_appending = APPEND_TAIL;
+}
+
+/*
+ * Helper function called at the begining of an insert.
+ *
+ * This computes a few things that are commonly used in the process of
+ * inserting into the btree:
+ *   - Whether the new extent is contiguous with an existing one.
+ *   - The current tree depth.
+ *   - Whether the insert is an appending one.
+ *   - The total # of free records in the tree.
+ *
+ * All of the information is stored on the ocfs2_insert_type
+ * structure.
+ */
+static int ocfs2_figure_insert_type(struct inode *inode,
+				    struct buffer_head *di_bh,
+				    struct buffer_head **last_eb_bh,
+				    struct ocfs2_extent_rec *insert_rec,
+				    struct ocfs2_insert_type *insert)
+{
+	int ret;
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
+	struct ocfs2_extent_block *eb;
+	struct ocfs2_extent_list *el;
+	struct ocfs2_path *path = NULL;
+	struct buffer_head *bh = NULL;
+
+	el = &di->id2.i_list;
+	insert->ins_tree_depth = le16_to_cpu(el->l_tree_depth);
+
+	if (el->l_tree_depth) {
+		/*
+		 * If we have tree depth, we read in the
+		 * rightmost extent block ahead of time as
+		 * ocfs2_figure_insert_type() and ocfs2_add_branch()
+		 * may want it later.
+		 */
+		ret = ocfs2_read_block(OCFS2_SB(inode->i_sb),
+				       le64_to_cpu(di->i_last_eb_blk), &bh,
+				       OCFS2_BH_CACHED, inode);
+		if (ret) {
+			mlog_exit(ret);
+			goto out;
+		}
+		eb = (struct ocfs2_extent_block *) bh->b_data;
+		el = &eb->h_list;
+	}
+
+	/*
+	 * Unless we have a contiguous insert, we'll need to know if
+	 * there is room left in our allocation tree for another
+	 * extent record.
+	 *
+	 * XXX: This test is simplistic, we can search for empty
+	 * extent records too.
+	 */
+	insert->ins_free_records = le16_to_cpu(el->l_count) -
+		le16_to_cpu(el->l_next_free_rec);
+
+	if (!insert->ins_tree_depth) {
+		ocfs2_figure_contig_type(inode, insert, el, insert_rec);
+		ocfs2_figure_appending_type(insert, el, insert_rec);
+		return 0;
+	}
+
+	path = ocfs2_new_inode_path(di_bh);
+	if (!path) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	/*
+	 * In the case that we're inserting past what the tree
+	 * currently accounts for, ocfs2_find_path() will return for
+	 * us the rightmost tree path. This is accounted for below in
+	 * the appending code.
+	 */
+	ret = ocfs2_find_path(inode, path, le32_to_cpu(insert_rec->e_cpos));
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	el = path_leaf_el(path);
+
+	/*
+	 * Now that we have the path, there's two things we want to determine:
+	 * 1) Contiguousness (also set contig_index if this is so)
+	 *
+	 * 2) Are we doing an append? We can trivially break this up
+         *     into two types of appends: simple record append, or a
+         *     rotate inside the tail leaf.
+	 */
+	ocfs2_figure_contig_type(inode, insert, el, insert_rec);
+
+	/*
+	 * The insert code isn't quite ready to deal with all cases of
+	 * left contiguousness. Specifically, if it's an insert into
+	 * the 1st record in a leaf, it will require the adjustment of
+	 * cluster count on the last record of the path directly to it's
+	 * left. For now, just catch that case and fool the layers
+	 * above us. This works just fine for tree_depth == 0, which
+	 * is why we allow that above.
+	 */
+	if (insert->ins_contig == CONTIG_LEFT &&
+	    insert->ins_contig_index == 0)
+		insert->ins_contig = CONTIG_NONE;
+
+	/*
+	 * Ok, so we can simply compare against last_eb to figure out
+	 * whether the path doesn't exist. This will only happen in
+	 * the case that we're doing a tail append, so maybe we can
+	 * take advantage of that information somehow.
+	 */
+	if (le64_to_cpu(di->i_last_eb_blk) == path_leaf_bh(path)->b_blocknr) {
+		/*
+		 * Ok, ocfs2_find_path() returned us the rightmost
+		 * tree path. This might be an appending insert. There are
+		 * two cases:
+		 *    1) We're doing a true append at the tail:
+		 *	-This might even be off the end of the leaf
+		 *    2) We're "appending" by rotating in the tail
+		 */
+		ocfs2_figure_appending_type(insert, el, insert_rec);
+	}
+
+out:
+	ocfs2_free_path(path);
+
+	if (ret == 0)
+		*last_eb_bh = bh;
+	else
+		brelse(bh);
+	return ret;
+}
+
+/*
+ * Insert an extent into an inode btree.
+ *
+ * The caller needs to update fe->i_clusters
+ */
+int ocfs2_insert_extent(struct ocfs2_super *osb,
+			handle_t *handle,
+			struct inode *inode,
+			struct buffer_head *fe_bh,
+			u32 cpos,
+			u64 start_blk,
+			u32 new_clusters,
+			struct ocfs2_alloc_context *meta_ac)
+{
+	int status, shift;
+	struct buffer_head *last_eb_bh = NULL;
+	struct buffer_head *bh = NULL;
+	struct ocfs2_insert_type insert = {0, };
+	struct ocfs2_extent_rec rec;
+
+	mlog(0, "add %u clusters at position %u to inode %llu\n",
+	     new_clusters, cpos, (unsigned long long)OCFS2_I(inode)->ip_blkno);
+
+	mlog_bug_on_msg(!ocfs2_sparse_alloc(osb) &&
+			(OCFS2_I(inode)->ip_clusters != cpos),
+			"Device %s, asking for sparse allocation: inode %llu, "
+			"cpos %u, clusters %u\n",
+			osb->dev_str,
+			(unsigned long long)OCFS2_I(inode)->ip_blkno, cpos,
+			OCFS2_I(inode)->ip_clusters);
+
+	memset(&rec, 0, sizeof(rec));
+	rec.e_cpos = cpu_to_le32(cpos);
+	rec.e_blkno = cpu_to_le64(start_blk);
+	rec.e_leaf_clusters = cpu_to_le16(new_clusters);
+
+	status = ocfs2_figure_insert_type(inode, fe_bh, &last_eb_bh, &rec,
+					  &insert);
+	if (status < 0) {
+		mlog_errno(status);
+		goto bail;
+	}
+
+	mlog(0, "Insert.appending: %u, Insert.Contig: %u, "
+	     "Insert.contig_index: %d, Insert.free_records: %d, "
+	     "Insert.tree_depth: %d\n",
+	     insert.ins_appending, insert.ins_contig, insert.ins_contig_index,
+	     insert.ins_free_records, insert.ins_tree_depth);
+
+	/*
+	 * Avoid growing the tree unless we're out of records and the
+	 * insert type requres one.
+	 */
+	if (insert.ins_contig != CONTIG_NONE || insert.ins_free_records)
+		goto out_add;
+
+	shift = ocfs2_find_branch_target(osb, inode, fe_bh, &bh);
+	if (shift < 0) {
@@ -869,3 +2384,0 @@
-		/* if we hit a leaf, we'd better be empty :) */
-		BUG_ON(le16_to_cpu(el->l_next_free_rec) !=
-		       le16_to_cpu(el->l_count));
@@ -873,3 +2386,2 @@
-		mlog(0, "ocfs2_allocate_extent: need to shift tree depth "
-		     "(current = %u)\n",
-		     le16_to_cpu(fe->id2.i_list.l_tree_depth));
+		mlog(0, "need to shift tree depth "
+		     "(current = %d)\n", insert.ins_tree_depth);
@@ -885,0 +2398 @@
+		insert.ins_tree_depth++;
@@ -888 +2401 @@
-		if (fe->id2.i_list.l_tree_depth == cpu_to_le16(1))
+		if (insert.ins_tree_depth == 1)
@@ -894 +2407 @@
-	mlog(0, "ocfs2_allocate_extent: add branch. bh = %p\n", bh);
+	mlog(0, "add branch. bh = %p\n", bh);
@@ -903,3 +2416,2 @@
-	/* Finally, we can add clusters. */
-	status = ocfs2_do_insert_extent(osb, handle, inode, fe_bh,
-					start_blk, new_clusters);
+	/* Finally, we can add clusters. This might rotate the tree for us. */
+	status = ocfs2_do_insert_extent(inode, handle, fe_bh, &rec, &insert);
@@ -907,0 +2420,2 @@
+	else
+		ocfs2_extent_map_insert_rec(inode, &rec);
@@ -1358 +2872 @@
-	     (unsigned long long)tl_copy->i_blkno);
+	     (unsigned long long)le64_to_cpu(tl_copy->i_blkno));
@@ -1450,5 +2964,3 @@
-static int ocfs2_find_new_last_ext_blk(struct ocfs2_super *osb,
-				       struct inode *inode,
-				       struct ocfs2_dinode *fe,
-				       u32 new_i_clusters,
-				       struct buffer_head *old_last_eb,
+static int ocfs2_find_new_last_ext_blk(struct inode *inode,
+				       unsigned int clusters_to_del,
+				       struct ocfs2_path *path,
@@ -1457,2 +2969,3 @@
-	int i, status = 0;
-	u64 block = 0;
+	int next_free, ret = 0;
+	u32 cpos;
+	struct ocfs2_extent_rec *rec;
@@ -1465,6 +2977,0 @@
-	if (!OCFS2_IS_VALID_DINODE(fe)) {
-		OCFS2_RO_ON_INVALID_DINODE(inode->i_sb, fe);
-		status = -EIO;
-		goto bail;
-	}
-
@@ -1472,2 +2979,2 @@
-	if (!fe->id2.i_list.l_tree_depth)
-		goto bail;
+	if (!path->p_tree_depth)
+		goto out;
@@ -1477,2 +2984,2 @@
-	if (!new_i_clusters)
-		goto bail;
+	if (OCFS2_I(inode)->ip_clusters == clusters_to_del)
+		goto out;
@@ -1480,2 +2987 @@
-	eb = (struct ocfs2_extent_block *) old_last_eb->b_data;
-	el = &(eb->h_list);
+	el = path_leaf_el(path);
@@ -1484,4 +2990,16 @@
-	/* Make sure that this guy will actually be empty after we
-	 * clear away the data. */
-	if (le32_to_cpu(el->l_recs[0].e_cpos) < new_i_clusters)
-		goto bail;
+	/*
+	 * Make sure that this extent list will actually be empty
+	 * after we clear away the data. We can shortcut out if
+	 * there's more than one non-empty extent in the
+	 * list. Otherwise, a check of the remaining extent is
+	 * necessary.
+	 */
+	next_free = le16_to_cpu(el->l_next_free_rec);
+	rec = NULL;
+	if (ocfs2_is_empty_extent(&el->l_recs[0])) {
+		if (next_free > 2)
+			goto out;
+
+		/* We may have a valid extent in index 1, check it. */
+		if (next_free == 2)
+			rec = &el->l_recs[1];
@@ -1489,12 +3007,88 @@
-	/* Ok, at this point, we know that last_eb will definitely
-	 * change, so lets traverse the tree and find the second to
-	 * last extent block. */
-	el = &(fe->id2.i_list);
-	/* go down the tree, */
-	do {
-		for(i = (le16_to_cpu(el->l_next_free_rec) - 1); i >= 0; i--) {
-			if (le32_to_cpu(el->l_recs[i].e_cpos) <
-			    new_i_clusters) {
-				block = le64_to_cpu(el->l_recs[i].e_blkno);
-				break;
-			}
+		/*
+		 * Fall through - no more nonempty extents, so we want
+		 * to delete this leaf.
+		 */
+	} else {
+		if (next_free > 1)
+			goto out;
+
+		rec = &el->l_recs[0];
+	}
+
+	if (rec) {
+		/*
+		 * Check it we'll only be trimming off the end of this
+		 * cluster.
+		 */
+		if (le16_to_cpu(rec->e_leaf_clusters) > clusters_to_del)
+			goto out;
+	}
+
+	ret = ocfs2_find_cpos_for_left_leaf(inode->i_sb, path, &cpos);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ret = ocfs2_find_leaf(inode, path_root_el(path), cpos, &bh);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	eb = (struct ocfs2_extent_block *) bh->b_data;
+	el = &eb->h_list;
+	if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
+		OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
+		ret = -EROFS;
+		goto out;
+	}
+
+	*new_last_eb = bh;
+	get_bh(*new_last_eb);
+	mlog(0, "returning block %llu, (cpos: %u)\n",
+	     (unsigned long long)le64_to_cpu(eb->h_blkno), cpos);
+out:
+	brelse(bh);
+
+	return ret;
+}
+
+/*
+ * Trim some clusters off the rightmost edge of a tree. Only called
+ * during truncate.
+ *
+ * The caller needs to:
+ *   - start journaling of each path component.
+ *   - compute and fully set up any new last ext block
+ */
+static int ocfs2_trim_tree(struct inode *inode, struct ocfs2_path *path,
+			   handle_t *handle, struct ocfs2_truncate_context *tc,
+			   u32 clusters_to_del, u64 *delete_start)
+{
+	int ret, i, index = path->p_tree_depth;
+	u32 new_edge = 0;
+	u64 deleted_eb = 0;
+	struct buffer_head *bh;
+	struct ocfs2_extent_list *el;
+	struct ocfs2_extent_rec *rec;
+
+	*delete_start = 0;
+
+	while (index >= 0) {
+		bh = path->p_node[index].bh;
+		el = path->p_node[index].el;
+
+		mlog(0, "traveling tree (index = %d, block = %llu)\n",
+		     index,  (unsigned long long)bh->b_blocknr);
+
+		BUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);
+
+		if (index !=
+		    (path->p_tree_depth - le16_to_cpu(el->l_tree_depth))) {
+			ocfs2_error(inode->i_sb,
+				    "Inode %lu has invalid ext. block %llu",
+				    inode->i_ino,
+				    (unsigned long long)bh->b_blocknr);
+			ret = -EROFS;
+			goto out;
@@ -1502 +3095,0 @@
-		BUG_ON(i < 0);
@@ -1504,4 +3097,139 @@
-		if (bh) {
-			brelse(bh);
-			bh = NULL;
-		}
+find_tail_record:
+		i = le16_to_cpu(el->l_next_free_rec) - 1;
+		rec = &el->l_recs[i];
+
+		mlog(0, "Extent list before: record %d: (%u, %u, %llu), "
+		     "next = %u\n", i, le32_to_cpu(rec->e_cpos),
+		     ocfs2_rec_clusters(el, rec),
+		     (unsigned long long)le64_to_cpu(rec->e_blkno),
+		     le16_to_cpu(el->l_next_free_rec));
+
+		BUG_ON(ocfs2_rec_clusters(el, rec) < clusters_to_del);
+
+		if (le16_to_cpu(el->l_tree_depth) == 0) {
+			/*
+			 * If the leaf block contains a single empty
+			 * extent and no records, we can just remove
+			 * the block.
+			 */
+			if (i == 0 && ocfs2_is_empty_extent(rec)) {
+				memset(rec, 0,
+				       sizeof(struct ocfs2_extent_rec));
+				el->l_next_free_rec = cpu_to_le16(0);
+
+				goto delete;
+			}
+
+			/*
+			 * Remove any empty extents by shifting things
+			 * left. That should make life much easier on
+			 * the code below. This condition is rare
+			 * enough that we shouldn't see a performance
+			 * hit.
+			 */
+			if (ocfs2_is_empty_extent(&el->l_recs[0])) {
+				le16_add_cpu(&el->l_next_free_rec, -1);
+
+				for(i = 0;
+				    i < le16_to_cpu(el->l_next_free_rec); i++)
+					el->l_recs[i] = el->l_recs[i + 1];
+
+				memset(&el->l_recs[i], 0,
+				       sizeof(struct ocfs2_extent_rec));
+
+				/*
+				 * We've modified our extent list. The
+				 * simplest way to handle this change
+				 * is to being the search from the
+				 * start again.
+				 */
+				goto find_tail_record;
+			}
+
+			le16_add_cpu(&rec->e_leaf_clusters, -clusters_to_del);
+
+			/*
+			 * We'll use "new_edge" on our way back up the
+			 * tree to know what our rightmost cpos is.
+			 */
+			new_edge = le16_to_cpu(rec->e_leaf_clusters);
+			new_edge += le32_to_cpu(rec->e_cpos);
+
+			/*
+			 * The caller will use this to delete data blocks.
+			 */
+			*delete_start = le64_to_cpu(rec->e_blkno)
+				+ ocfs2_clusters_to_blocks(inode->i_sb,
+					le16_to_cpu(rec->e_leaf_clusters));
+
+			/*
+			 * If it's now empty, remove this record.
+			 */
+			if (le16_to_cpu(rec->e_leaf_clusters) == 0) {
+				memset(rec, 0,
+				       sizeof(struct ocfs2_extent_rec));
+				le16_add_cpu(&el->l_next_free_rec, -1);
+			}
+		} else {
+			if (le64_to_cpu(rec->e_blkno) == deleted_eb) {
+				memset(rec, 0,
+				       sizeof(struct ocfs2_extent_rec));
+				le16_add_cpu(&el->l_next_free_rec, -1);
+
+				goto delete;
+			}
+
+			/* Can this actually happen? */
+			if (le16_to_cpu(el->l_next_free_rec) == 0)
+				goto delete;
+
+			/*
+			 * We never actually deleted any clusters
+			 * because our leaf was empty. There's no
+			 * reason to adjust the rightmost edge then.
+			 */
+			if (new_edge == 0)
+				goto delete;
+
+			rec->e_int_clusters = cpu_to_le32(new_edge);
+			le32_add_cpu(&rec->e_int_clusters,
+				     -le32_to_cpu(rec->e_cpos));
+
+			 /*
+			  * A deleted child record should have been
+			  * caught above.
+			  */
+			 BUG_ON(le32_to_cpu(rec->e_int_clusters) == 0);
+		}
+
+delete:
+		ret = ocfs2_journal_dirty(handle, bh);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		mlog(0, "extent list container %llu, after: record %d: "
+		     "(%u, %u, %llu), next = %u.\n",
+		     (unsigned long long)bh->b_blocknr, i,
+		     le32_to_cpu(rec->e_cpos), ocfs2_rec_clusters(el, rec),
+		     (unsigned long long)le64_to_cpu(rec->e_blkno),
+		     le16_to_cpu(el->l_next_free_rec));
+
+		/*
+		 * We must be careful to only attempt delete of an
+		 * extent block (and not the root inode block).
+		 */
+		if (index > 0 && le16_to_cpu(el->l_next_free_rec) == 0) {
+			struct ocfs2_extent_block *eb =
+				(struct ocfs2_extent_block *)bh->b_data;
+
+			/*
+			 * Save this for use when processing the
+			 * parent block.
+			 */
+			deleted_eb = le64_to_cpu(eb->h_blkno);
+
+			mlog(0, "deleting this extent block.\n");
+
+			ocfs2_remove_from_cache(inode, bh);
@@ -1509,12 +3237,27 @@
-		status = ocfs2_read_block(osb, block, &bh, OCFS2_BH_CACHED,
-					 inode);
-		if (status < 0) {
-			mlog_errno(status);
-			goto bail;
-		}
-		eb = (struct ocfs2_extent_block *) bh->b_data;
-		el = &eb->h_list;
-		if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
-			OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
-			status = -EIO;
-			goto bail;
+			BUG_ON(ocfs2_rec_clusters(el, &el->l_recs[0]));
+			BUG_ON(le32_to_cpu(el->l_recs[0].e_cpos));
+			BUG_ON(le64_to_cpu(el->l_recs[0].e_blkno));
+
+			if (le16_to_cpu(eb->h_suballoc_slot) == 0) {
+				/*
+				 * This code only understands how to
+				 * lock the suballocator in slot 0,
+				 * which is fine because allocation is
+				 * only ever done out of that
+				 * suballocator too. A future version
+				 * might change that however, so avoid
+				 * a free if we don't know how to
+				 * handle it. This way an fs incompat
+				 * bit will not be necessary.
+				 */
+				ret = ocfs2_free_extent_block(handle,
+							      tc->tc_ext_alloc_inode,
+							      tc->tc_ext_alloc_bh,
+							      eb);
+
+				/* An error here is not fatal. */
+				if (ret < 0)
+					mlog_errno(ret);
+			}
+		} else {
+			deleted_eb = 0;
@@ -1522 +3264,0 @@
-	} while (el->l_tree_depth);
@@ -1524,7 +3266,2 @@
-	*new_last_eb = bh;
-	get_bh(*new_last_eb);
-	mlog(0, "returning block %llu\n",
-	     (unsigned long long)le64_to_cpu(eb->h_blkno));
-bail:
-	if (bh)
-		brelse(bh);
+		index--;
+	}
@@ -1532 +3269,3 @@
-	return status;
+	ret = 0;
+out:
+	return ret;
@@ -1539 +3277,0 @@
-			     struct buffer_head *old_last_eb_bh,
@@ -1541 +3279,2 @@
-			     struct ocfs2_truncate_context *tc)
+			     struct ocfs2_truncate_context *tc,
+			     struct ocfs2_path *path)
@@ -1543 +3282 @@
-	int status, i, depth;
+	int status;
@@ -1545 +3283,0 @@
-	struct ocfs2_extent_block *eb;
@@ -1548 +3285,0 @@
-	struct buffer_head *eb_bh = NULL;
@@ -1550 +3286,0 @@
-	u64 next_eb = 0;
@@ -1555,7 +3291,2 @@
-	status = ocfs2_find_new_last_ext_blk(osb,
-					     inode,
-					     fe,
-					     le32_to_cpu(fe->i_clusters) -
-					     		clusters_to_del,
-					     old_last_eb_bh,
-					     &last_eb_bh);
+	status = ocfs2_find_new_last_ext_blk(inode, clusters_to_del,
+					     path, &last_eb_bh);
@@ -1566,2 +3296,0 @@
-	if (last_eb_bh)
-		last_eb = (struct ocfs2_extent_block *) last_eb_bh->b_data;
@@ -1569,2 +3298,5 @@
-	status = ocfs2_journal_access(handle, inode, fe_bh,
-				      OCFS2_JOURNAL_ACCESS_WRITE);
+	/*
+	 * Each component will be touched, so we might as well journal
+	 * here to avoid having to handle errors later.
+	 */
+	status = ocfs2_journal_access_path(inode, handle, path);
@@ -1574,0 +3307,12 @@
+
+	if (last_eb_bh) {
+		status = ocfs2_journal_access(handle, inode, last_eb_bh,
+					      OCFS2_JOURNAL_ACCESS_WRITE);
+		if (status < 0) {
+			mlog_errno(status);
+			goto bail;
+		}
+
+		last_eb = (struct ocfs2_extent_block *) last_eb_bh->b_data;
+	}
+
@@ -1576,0 +3321,12 @@
+	/*
+	 * Lower levels depend on this never happening, but it's best
+	 * to check it up here before changing the tree.
+	 */
+	if (el->l_tree_depth && el->l_recs[0].e_int_clusters == 0) {
+		ocfs2_error(inode->i_sb,
+			    "Inode %lu has an empty extent record, depth %u\n",
+			    inode->i_ino, le16_to_cpu(el->l_tree_depth));
+		status = -EROFS;
+		goto bail;
+	}
+
@@ -1582,4 +3337,0 @@
-	fe->i_mtime = cpu_to_le64(CURRENT_TIME.tv_sec);
-	fe->i_mtime_nsec = cpu_to_le32(CURRENT_TIME.tv_nsec);
-
-	i = le16_to_cpu(el->l_next_free_rec) - 1;
@@ -1587,21 +3339,5 @@
-	BUG_ON(le32_to_cpu(el->l_recs[i].e_clusters) < clusters_to_del);
-	le32_add_cpu(&el->l_recs[i].e_clusters, -clusters_to_del);
-	/* tree depth zero, we can just delete the clusters, otherwise
-	 * we need to record the offset of the next level extent block
-	 * as we may overwrite it. */
-	if (!el->l_tree_depth)
-		delete_blk = le64_to_cpu(el->l_recs[i].e_blkno)
-			+ ocfs2_clusters_to_blocks(osb->sb,
-					le32_to_cpu(el->l_recs[i].e_clusters));
-	else
-		next_eb = le64_to_cpu(el->l_recs[i].e_blkno);
-
-	if (!el->l_recs[i].e_clusters) {
-		/* if we deleted the whole extent record, then clear
-		 * out the other fields and update the extent
-		 * list. For depth > 0 trees, we've already recorded
-		 * the extent block in 'next_eb' */
-		el->l_recs[i].e_cpos = 0;
-		el->l_recs[i].e_blkno = 0;
-		BUG_ON(!el->l_next_free_rec);
-		le16_add_cpu(&el->l_next_free_rec, -1);
+	status = ocfs2_trim_tree(inode, path, handle, tc,
+				 clusters_to_del, &delete_blk);
+	if (status) {
+		mlog_errno(status);
+		goto bail;
@@ -1610,2 +3346 @@
-	depth = le16_to_cpu(el->l_tree_depth);
-	if (!fe->i_clusters) {
+	if (le32_to_cpu(fe->i_clusters) == 0) {
@@ -1628,6 +3362,0 @@
-		status = ocfs2_journal_access(handle, inode, last_eb_bh,
-					      OCFS2_JOURNAL_ACCESS_WRITE);
-		if (status < 0) {
-			mlog_errno(status);
-			goto bail;
-		}
@@ -1642,6 +3371,3 @@
-	/* if our tree depth > 0, update all the tree blocks below us. */
-	while (depth) {
-		mlog(0, "traveling tree (depth = %d, next_eb = %llu)\n",
-		     depth,  (unsigned long long)next_eb);
-		status = ocfs2_read_block(osb, next_eb, &eb_bh,
-					  OCFS2_BH_CACHED, inode);
+	if (delete_blk) {
+		status = ocfs2_truncate_log_append(osb, handle, delete_blk,
+						   clusters_to_del);
@@ -1652,5 +3378,86 @@
-		eb = (struct ocfs2_extent_block *)eb_bh->b_data;
-		if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
-			OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
-			status = -EIO;
-			goto bail;
+	}
+	status = 0;
+bail:
+
+	mlog_exit(status);
+	return status;
+}
+
+static int ocfs2_writeback_zero_func(handle_t *handle, struct buffer_head *bh)
+{
+	set_buffer_uptodate(bh);
+	mark_buffer_dirty(bh);
+	return 0;
+}
+
+static int ocfs2_ordered_zero_func(handle_t *handle, struct buffer_head *bh)
+{
+	set_buffer_uptodate(bh);
+	mark_buffer_dirty(bh);
+	return ocfs2_journal_dirty_data(handle, bh);
+}
+
+static void ocfs2_zero_cluster_pages(struct inode *inode, loff_t isize,
+				     struct page **pages, int numpages,
+				     u64 phys, handle_t *handle)
+{
+	int i, ret, partial = 0;
+	void *kaddr;
+	struct page *page;
+	unsigned int from, to = PAGE_CACHE_SIZE;
+	struct super_block *sb = inode->i_sb;
+
+	BUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(sb)));
+
+	if (numpages == 0)
+		goto out;
+
+	from = isize & (PAGE_CACHE_SIZE - 1); /* 1st page offset */
+	if (PAGE_CACHE_SHIFT > OCFS2_SB(sb)->s_clustersize_bits) {
+		/*
+		 * Since 'from' has been capped to a value below page
+		 * size, this calculation won't be able to overflow
+		 * 'to'
+		 */
+		to = ocfs2_align_bytes_to_clusters(sb, from);
+
+		/*
+		 * The truncate tail in this case should never contain
+		 * more than one page at maximum. The loop below also
+		 * assumes this.
+		 */
+		BUG_ON(numpages != 1);
+	}
+
+	for(i = 0; i < numpages; i++) {
+		page = pages[i];
+
+		BUG_ON(from > PAGE_CACHE_SIZE);
+		BUG_ON(to > PAGE_CACHE_SIZE);
+
+		ret = ocfs2_map_page_blocks(page, &phys, inode, from, to, 0);
+		if (ret)
+			mlog_errno(ret);
+
+		kaddr = kmap_atomic(page, KM_USER0);
+		memset(kaddr + from, 0, to - from);
+		kunmap_atomic(kaddr, KM_USER0);
+
+		/*
+		 * Need to set the buffers we zero'd into uptodate
+		 * here if they aren't - ocfs2_map_page_blocks()
+		 * might've skipped some
+		 */
+		if (ocfs2_should_order_data(inode)) {
+			ret = walk_page_buffers(handle,
+						page_buffers(page),
+						from, to, &partial,
+						ocfs2_ordered_zero_func);
+			if (ret < 0)
+				mlog_errno(ret);
+		} else {
+			ret = walk_page_buffers(handle, page_buffers(page),
+						from, to, &partial,
+						ocfs2_writeback_zero_func);
+			if (ret < 0)
+				mlog_errno(ret);
@@ -1658 +3464,0 @@
-		el = &(eb->h_list);
@@ -1660,5 +3466,17 @@
-		status = ocfs2_journal_access(handle, inode, eb_bh,
-					      OCFS2_JOURNAL_ACCESS_WRITE);
-		if (status < 0) {
-			mlog_errno(status);
-			goto bail;
+		if (!partial)
+			SetPageUptodate(page);
+
+		flush_dcache_page(page);
+
+		/*
+		 * Every page after the 1st one should be completely zero'd.
+		 */
+		from = 0;
+	}
+out:
+	if (pages) {
+		for (i = 0; i < numpages; i++) {
+			page = pages[i];
+			unlock_page(page);
+			mark_page_accessed(page);
+			page_cache_release(page);
@@ -1665,0 +3484,2 @@
+	}
+}
@@ -1667,2 +3487,10 @@
-		BUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);
-		BUG_ON(depth != (le16_to_cpu(el->l_tree_depth) + 1));
+static int ocfs2_grab_eof_pages(struct inode *inode, loff_t isize, struct page **pages,
+				int *num, u64 *phys)
+{
+	int i, numpages = 0, ret = 0;
+	unsigned int csize = OCFS2_SB(inode->i_sb)->s_clustersize;
+	unsigned int ext_flags;
+	struct super_block *sb = inode->i_sb;
+	struct address_space *mapping = inode->i_mapping;
+	unsigned long index;
+	u64 next_cluster_bytes;
@@ -1670 +3498 @@
-		i = le16_to_cpu(el->l_next_free_rec) - 1;
+	BUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(sb)));
@@ -1672,7 +3500,3 @@
-		mlog(0, "extent block %llu, before: record %d: "
-		     "(%u, %u, %llu), next = %u\n",
-		     (unsigned long long)le64_to_cpu(eb->h_blkno), i,
-		     le32_to_cpu(el->l_recs[i].e_cpos),
-		     le32_to_cpu(el->l_recs[i].e_clusters),
-		     (unsigned long long)le64_to_cpu(el->l_recs[i].e_blkno),
-		     le16_to_cpu(el->l_next_free_rec));
+	/* Cluster boundary, so we don't need to grab any pages. */
+	if ((isize & (csize - 1)) == 0)
+		goto out;
@@ -1680,2 +3504,6 @@
-		BUG_ON(le32_to_cpu(el->l_recs[i].e_clusters) < clusters_to_del);
-		le32_add_cpu(&el->l_recs[i].e_clusters, -clusters_to_del);
+	ret = ocfs2_extent_map_get_blocks(inode, isize >> sb->s_blocksize_bits,
+					  phys, NULL, &ext_flags);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
@@ -1683,19 +3511,3 @@
-		next_eb = le64_to_cpu(el->l_recs[i].e_blkno);
-		/* bottom-most block requires us to delete data.*/
-		if (!el->l_tree_depth)
-			delete_blk = le64_to_cpu(el->l_recs[i].e_blkno)
-				+ ocfs2_clusters_to_blocks(osb->sb,
-					le32_to_cpu(el->l_recs[i].e_clusters));
-		if (!el->l_recs[i].e_clusters) {
-			el->l_recs[i].e_cpos = 0;
-			el->l_recs[i].e_blkno = 0;
-			BUG_ON(!el->l_next_free_rec);
-			le16_add_cpu(&el->l_next_free_rec, -1);
-		}
-		mlog(0, "extent block %llu, after: record %d: "
-		     "(%u, %u, %llu), next = %u\n",
-		     (unsigned long long)le64_to_cpu(eb->h_blkno), i,
-		     le32_to_cpu(el->l_recs[i].e_cpos),
-		     le32_to_cpu(el->l_recs[i].e_clusters),
-		     (unsigned long long)le64_to_cpu(el->l_recs[i].e_blkno),
-		     le16_to_cpu(el->l_next_free_rec));
+	/* Tail is a hole. */
+	if (*phys == 0)
+		goto out;
@@ -1703,5 +3515,4 @@
-		status = ocfs2_journal_dirty(handle, eb_bh);
-		if (status < 0) {
-			mlog_errno(status);
-			goto bail;
-		}
+	/* Tail is marked as unwritten, we can count on write to zero
+	 * in that case. */
+	if (ext_flags & OCFS2_EXT_UNWRITTEN)
+		goto out;
@@ -1709,2 +3520,9 @@
-		if (!el->l_next_free_rec) {
-			mlog(0, "deleting this extent block.\n");
+	next_cluster_bytes = ocfs2_align_bytes_to_clusters(inode->i_sb, isize);
+	index = isize >> PAGE_CACHE_SHIFT;
+	do {
+		pages[numpages] = grab_cache_page(mapping, index);
+		if (!pages[numpages]) {
+			ret = -ENOMEM;
+			mlog_errno(ret);
+			goto out;
+		}
@@ -1712 +3530,3 @@
-			ocfs2_remove_from_cache(inode, eb_bh);
+		numpages++;
+		index++;
+	} while (index < (next_cluster_bytes >> PAGE_CACHE_SHIFT));
@@ -1714,22 +3534,7 @@
-			BUG_ON(el->l_recs[0].e_clusters);
-			BUG_ON(el->l_recs[0].e_cpos);
-			BUG_ON(el->l_recs[0].e_blkno);
-			if (eb->h_suballoc_slot == 0) {
-				/*
-				 * This code only understands how to
-				 * lock the suballocator in slot 0,
-				 * which is fine because allocation is
-				 * only ever done out of that
-				 * suballocator too. A future version
-				 * might change that however, so avoid
-				 * a free if we don't know how to
-				 * handle it. This way an fs incompat
-				 * bit will not be necessary.
-				 */
-				status = ocfs2_free_extent_block(handle,
-								 tc->tc_ext_alloc_inode,
-								 tc->tc_ext_alloc_bh,
-								 eb);
-				if (status < 0) {
-					mlog_errno(status);
-					goto bail;
+out:
+	if (ret != 0) {
+		if (pages) {
+			for (i = 0; i < numpages; i++) {
+				if (pages[i]) {
+					unlock_page(pages[i]);
+					page_cache_release(pages[i]);
@@ -1739,3 +3544 @@
-		brelse(eb_bh);
-		eb_bh = NULL;
-		depth--;
+		numpages = 0;
@@ -1744,6 +3547,35 @@
-	BUG_ON(!delete_blk);
-	status = ocfs2_truncate_log_append(osb, handle, delete_blk,
-					   clusters_to_del);
-	if (status < 0) {
-		mlog_errno(status);
-		goto bail;
+	*num = numpages;
+
+	return ret;
+}
+
+/*
+ * Zero the area past i_size but still within an allocated
+ * cluster. This avoids exposing nonzero data on subsequent file
+ * extends.
+ *
+ * We need to call this before i_size is updated on the inode because
+ * otherwise block_write_full_page() will skip writeout of pages past
+ * i_size. The new_i_size parameter is passed for this reason.
+ */
+int ocfs2_zero_tail_for_truncate(struct inode *inode, handle_t *handle,
+				 u64 new_i_size)
+{
+	int ret, numpages;
+	loff_t endbyte;
+	struct page **pages = NULL;
+	u64 phys;
+
+	/*
+	 * File systems which don't support sparse files zero on every
+	 * extend.
+	 */
+	if (!ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))
+		return 0;
+
+	pages = kcalloc(ocfs2_pages_per_cluster(inode->i_sb),
+			sizeof(struct page *), GFP_NOFS);
+	if (pages == NULL) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
@@ -1751,8 +3583,29 @@
-	status = 0;
-bail:
-	if (!status)
-		ocfs2_extent_map_trunc(inode, le32_to_cpu(fe->i_clusters));
-	else
-		ocfs2_extent_map_drop(inode, 0);
-	mlog_exit(status);
-	return status;
+
+	ret = ocfs2_grab_eof_pages(inode, new_i_size, pages, &numpages, &phys);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	if (numpages == 0)
+		goto out;
+
+	ocfs2_zero_cluster_pages(inode, new_i_size, pages, numpages, phys,
+				 handle);
+
+	/*
+	 * Initiate writeout of the pages we zero'd here. We don't
+	 * wait on them - the truncate_inode_pages() call later will
+	 * do that for us.
+	 */
+	endbyte = ocfs2_align_bytes_to_clusters(inode->i_sb, new_i_size);
+	ret = do_sync_mapping_range(inode->i_mapping, new_i_size,
+				    endbyte - 1, SYNC_FILE_RANGE_WRITE);
+	if (ret)
+		mlog_errno(ret);
+
+out:
+	if (pages)
+		kfree(pages);
+
+	return ret;
@@ -1773,4 +3626 @@
-	u32 clusters_to_del, target_i_clusters;
-	u64 last_eb = 0;
-	struct ocfs2_dinode *fe;
-	struct ocfs2_extent_block *eb;
+	u32 clusters_to_del, new_highest_cpos, range;
@@ -1778 +3627,0 @@
-	struct buffer_head *last_eb_bh;
@@ -1780,0 +3630 @@
+	struct ocfs2_path *path = NULL;
@@ -1786 +3636 @@
-	target_i_clusters = ocfs2_clusters_for_bytes(osb->sb,
+	new_highest_cpos = ocfs2_clusters_for_bytes(osb->sb,
@@ -1789,2 +3639,6 @@
-	last_eb_bh = tc->tc_last_eb_bh;
-	tc->tc_last_eb_bh = NULL;
+	path = ocfs2_new_inode_path(fe_bh);
+	if (!path) {
+		status = -ENOMEM;
+		mlog_errno(status);
+		goto bail;
+	}
@@ -1792 +3646 @@
-	fe = (struct ocfs2_dinode *) fe_bh->b_data;
+	ocfs2_extent_map_trunc(inode, new_highest_cpos);
@@ -1794,6 +3647,0 @@
-	if (fe->id2.i_list.l_tree_depth) {
-		eb = (struct ocfs2_extent_block *) last_eb_bh->b_data;
-		el = &eb->h_list;
-	} else
-		el = &fe->id2.i_list;
-	last_eb = le64_to_cpu(fe->i_last_eb_blk);
@@ -1801,20 +3649,7 @@
-	mlog(0, "ocfs2_commit_truncate: fe->i_clusters = %u, "
-	     "last_eb = %llu, fe->i_last_eb_blk = %llu, "
-	     "fe->id2.i_list.l_tree_depth = %u last_eb_bh = %p\n",
-	     le32_to_cpu(fe->i_clusters), (unsigned long long)last_eb,
-	     (unsigned long long)le64_to_cpu(fe->i_last_eb_blk),
-	     le16_to_cpu(fe->id2.i_list.l_tree_depth), last_eb_bh);
-
-	if (last_eb != le64_to_cpu(fe->i_last_eb_blk)) {
-		mlog(0, "last_eb changed!\n");
-		BUG_ON(!fe->id2.i_list.l_tree_depth);
-		last_eb = le64_to_cpu(fe->i_last_eb_blk);
-		/* i_last_eb_blk may have changed, read it if
-		 * necessary. We don't have to worry about the
-		 * truncate to zero case here (where there becomes no
-		 * last_eb) because we never loop back after our work
-		 * is done. */
-		if (last_eb_bh) {
-			brelse(last_eb_bh);
-			last_eb_bh = NULL;
-		}
+	/*
+	 * Check that we still have allocation to delete.
+	 */
+	if (OCFS2_I(inode)->ip_clusters == 0) {
+		status = 0;
+		goto bail;
+	}
@@ -1822,14 +3657,31 @@
-		status = ocfs2_read_block(osb, last_eb,
-					  &last_eb_bh, OCFS2_BH_CACHED,
-					  inode);
-		if (status < 0) {
-			mlog_errno(status);
-			goto bail;
-		}
-		eb = (struct ocfs2_extent_block *) last_eb_bh->b_data;
-		if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
-			OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
-			status = -EIO;
-			goto bail;
-		}
-		el = &(eb->h_list);
+	/*
+	 * Truncate always works against the rightmost tree branch.
+	 */
+	status = ocfs2_find_path(inode, path, UINT_MAX);
+	if (status) {
+		mlog_errno(status);
+		goto bail;
+	}
+
+	mlog(0, "inode->ip_clusters = %u, tree_depth = %u\n",
+	     OCFS2_I(inode)->ip_clusters, path->p_tree_depth);
+
+	/*
+	 * By now, el will point to the extent list on the bottom most
+	 * portion of this tree. Only the tail record is considered in
+	 * each pass.
+	 *
+	 * We handle the following cases, in order:
+	 * - empty extent: delete the remaining branch
+	 * - remove the entire record
+	 * - remove a partial record
+	 * - no record needs to be removed (truncate has completed)
+	 */
+	el = path_leaf_el(path);
+	if (le16_to_cpu(el->l_next_free_rec) == 0) {
+		ocfs2_error(inode->i_sb,
+			    "Inode %llu has empty extent block at %llu\n",
+			    (unsigned long long)OCFS2_I(inode)->ip_blkno,
+			    (unsigned long long)path_leaf_bh(path)->b_blocknr);
+		status = -EROFS;
+		goto bail;
@@ -1838,2 +3689,0 @@
-	/* by now, el will point to the extent list on the bottom most
-	 * portion of this tree. */
@@ -1841,4 +3691,8 @@
-	if (le32_to_cpu(el->l_recs[i].e_cpos) >= target_i_clusters)
-		clusters_to_del = le32_to_cpu(el->l_recs[i].e_clusters);
-	else
-		clusters_to_del = (le32_to_cpu(el->l_recs[i].e_clusters) +
+	range = le32_to_cpu(el->l_recs[i].e_cpos) +
+		ocfs2_rec_clusters(el, &el->l_recs[i]);
+	if (i == 0 && ocfs2_is_empty_extent(&el->l_recs[i])) {
+		clusters_to_del = 0;
+	} else if (le32_to_cpu(el->l_recs[i].e_cpos) >= new_highest_cpos) {
+		clusters_to_del = ocfs2_rec_clusters(el, &el->l_recs[i]);
+	} else if (range > new_highest_cpos) {
+		clusters_to_del = (ocfs2_rec_clusters(el, &el->l_recs[i]) +
@@ -1846 +3700,8 @@
-				  target_i_clusters;
+				  new_highest_cpos;
+	} else {
+		status = 0;
+		goto bail;
+	}
+
+	mlog(0, "clusters_to_del = %u in this pass, tail blk=%llu\n",
+	     clusters_to_del, (unsigned long long)path_leaf_bh(path)->b_blocknr);
@@ -1848 +3709 @@
-	mlog(0, "clusters_to_del = %u in this pass\n", clusters_to_del);
+	BUG_ON(clusters_to_del == 0);
@@ -1864 +3725,2 @@
-						fe, el);
+						(struct ocfs2_dinode *)fe_bh->b_data,
+						el);
@@ -1873,7 +3735,2 @@
-	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
-	status = ocfs2_mark_inode_dirty(handle, inode, fe_bh);
-	if (status < 0)
-		mlog_errno(status);
-
-	status = ocfs2_do_truncate(osb, clusters_to_del, inode, fe_bh,
-				   last_eb_bh, handle, tc);
+	status = ocfs2_do_truncate(osb, clusters_to_del, inode, fe_bh, handle,
+				   tc, path);
@@ -1891,3 +3748,8 @@
-	BUG_ON(le32_to_cpu(fe->i_clusters) < target_i_clusters);
-	if (le32_to_cpu(fe->i_clusters) > target_i_clusters)
-		goto start;
+	ocfs2_reinit_path(path, 1);
+
+	/*
+	 * The check above will catch the case where we've truncated
+	 * away all allocation.
+	 */
+	goto start;
+
@@ -1905,2 +3767 @@
-	if (last_eb_bh)
-		brelse(last_eb_bh);
+	ocfs2_free_path(path);
@@ -1915 +3775,0 @@
-
@@ -1926 +3786 @@
-	int status, metadata_delete;
+	int status, metadata_delete, i;
@@ -1944,17 +3804,2 @@
-	     "%llu\n", fe->i_clusters, new_i_clusters,
-	     (unsigned long long)fe->i_size);
-
-	if (le32_to_cpu(fe->i_clusters) <= new_i_clusters) {
-		ocfs2_error(inode->i_sb, "Dinode %llu has cluster count "
-			    "%u and size %llu whereas struct inode has "
-			    "cluster count %u and size %llu which caused an "
-			    "invalid truncate to %u clusters.",
-			    (unsigned long long)le64_to_cpu(fe->i_blkno),
-			    le32_to_cpu(fe->i_clusters),
-			    (unsigned long long)le64_to_cpu(fe->i_size),
-			    OCFS2_I(inode)->ip_clusters, i_size_read(inode),
-			    new_i_clusters);
-		mlog_meta_lvb(ML_ERROR, &OCFS2_I(inode)->ip_meta_lockres);
-		status = -EIO;
-		goto bail;
-	}
+	     "%llu\n", le32_to_cpu(fe->i_clusters), new_i_clusters,
+	     (unsigned long long)le64_to_cpu(fe->i_size));
@@ -1989 +3834,9 @@
-		if (le32_to_cpu(el->l_recs[0].e_cpos) >= new_i_clusters)
+
+		i = 0;
+		if (ocfs2_is_empty_extent(&el->l_recs[0]))
+			i = 1;
+		/*
+		 * XXX: Should we check that next_free_rec contains
+		 * the extent?
+		 */
+		if (le32_to_cpu(el->l_recs[i].e_cpos) >= new_i_clusters)
--- ./projects/linux/linux-2.6.22/fs/ocfs2/alloc.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/fs/ocfs2/alloc.c	2007-10-09 22:31:38.000000000 +0200
@@ -52,0 +53,2 @@
+static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,
+					 struct ocfs2_extent_block *eb);
@@ -119,0 +122,25 @@
+ * All the elements of src into dest. After this call, src could be freed
+ * without affecting dest.
+ *
+ * Both paths should have the same root. Any non-root elements of dest
+ * will be freed.
+ */
+static void ocfs2_cp_path(struct ocfs2_path *dest, struct ocfs2_path *src)
+{
+	int i;
+
+	BUG_ON(path_root_bh(dest) != path_root_bh(src));
+	BUG_ON(path_root_el(dest) != path_root_el(src));
+
+	ocfs2_reinit_path(dest, 1);
+
+	for(i = 1; i < OCFS2_MAX_PATH_DEPTH; i++) {
+		dest->p_node[i].bh = src->p_node[i].bh;
+		dest->p_node[i].el = src->p_node[i].el;
+
+		if (dest->p_node[i].bh)
+			get_bh(dest->p_node[i].bh);
+	}
+}
+
+/*
@@ -214,0 +242,30 @@
+/*
+ * Return the index of the extent record which contains cluster #v_cluster.
+ * -1 is returned if it was not found.
+ *
+ * Should work fine on interior and exterior nodes.
+ */
+int ocfs2_search_extent_list(struct ocfs2_extent_list *el, u32 v_cluster)
+{
+	int ret = -1;
+	int i;
+	struct ocfs2_extent_rec *rec;
+	u32 rec_end, rec_start, clusters;
+
+	for(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {
+		rec = &el->l_recs[i];
+
+		rec_start = le32_to_cpu(rec->e_cpos);
+		clusters = ocfs2_rec_clusters(el, rec);
+
+		rec_end = rec_start + clusters;
+
+		if (v_cluster >= rec_start && v_cluster < rec_end) {
+			ret = i;
+			break;
+		}
+	}
+
+	return ret;
+}
+
@@ -218 +275,2 @@
-	CONTIG_RIGHT
+	CONTIG_RIGHT,
+	CONTIG_LEFTRIGHT,
@@ -255,0 +314,8 @@
+	/*
+	 * Refuse to coalesce extent records with different flag
+	 * fields - we don't want to mix unwritten extents with user
+	 * data.
+	 */
+	if (ext->e_flags != insert_rec->e_flags)
+		return CONTIG_NONE;
+
@@ -279,0 +346,6 @@
+enum ocfs2_split_type {
+	SPLIT_NONE = 0,
+	SPLIT_LEFT,
+	SPLIT_RIGHT,
+};
+
@@ -280,0 +353 @@
+	enum ocfs2_split_type	ins_split;
@@ -287,0 +361,7 @@
+struct ocfs2_merge_ctxt {
+	enum ocfs2_contig_type	c_contig_type;
+	int			c_has_empty_extent;
+	int			c_split_covers_rec;
+	int			c_used_tail_recs;
+};
+
@@ -387,5 +466,0 @@
-
-#ifndef OCFS2_USE_ALL_METADATA_SUBALLOCATORS
-			/* we always use slot zero's suballocator */
-			eb->h_suballoc_slot = 0;
-#else
@@ -393 +467,0 @@
-#endif
@@ -464 +538 @@
-			    struct buffer_head *last_eb_bh,
+			    struct buffer_head **last_eb_bh,
@@ -479 +553 @@
-	BUG_ON(!last_eb_bh);
+	BUG_ON(!last_eb_bh || !*last_eb_bh);
@@ -510 +584 @@
-	eb = (struct ocfs2_extent_block *)last_eb_bh->b_data;
+	eb = (struct ocfs2_extent_block *)(*last_eb_bh)->b_data;
@@ -571 +645 @@
-	status = ocfs2_journal_access(handle, inode, last_eb_bh,
+	status = ocfs2_journal_access(handle, inode, *last_eb_bh,
@@ -604 +678 @@
-	eb = (struct ocfs2_extent_block *) last_eb_bh->b_data;
+	eb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;
@@ -607 +681 @@
-	status = ocfs2_journal_dirty(handle, last_eb_bh);
+	status = ocfs2_journal_dirty(handle, *last_eb_bh);
@@ -618,0 +693,8 @@
+	/*
+	 * Some callers want to track the rightmost leaf so pass it
+	 * back here.
+	 */
+	brelse(*last_eb_bh);
+	get_bh(new_eb_bhs[0]);
+	*last_eb_bh = new_eb_bhs[0];
+
@@ -831,0 +914,81 @@
+ * Grow a b-tree so that it has more records.
+ *
+ * We might shift the tree depth in which case existing paths should
+ * be considered invalid.
+ *
+ * Tree depth after the grow is returned via *final_depth.
+ *
+ * *last_eb_bh will be updated by ocfs2_add_branch().
+ */
+static int ocfs2_grow_tree(struct inode *inode, handle_t *handle,
+			   struct buffer_head *di_bh, int *final_depth,
+			   struct buffer_head **last_eb_bh,
+			   struct ocfs2_alloc_context *meta_ac)
+{
+	int ret, shift;
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
+	int depth = le16_to_cpu(di->id2.i_list.l_tree_depth);
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	struct buffer_head *bh = NULL;
+
+	BUG_ON(meta_ac == NULL);
+
+	shift = ocfs2_find_branch_target(osb, inode, di_bh, &bh);
+	if (shift < 0) {
+		ret = shift;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	/* We traveled all the way to the bottom of the allocation tree
+	 * and didn't find room for any more extents - we need to add
+	 * another tree level */
+	if (shift) {
+		BUG_ON(bh);
+		mlog(0, "need to shift tree depth (current = %d)\n", depth);
+
+		/* ocfs2_shift_tree_depth will return us a buffer with
+		 * the new extent block (so we can pass that to
+		 * ocfs2_add_branch). */
+		ret = ocfs2_shift_tree_depth(osb, handle, inode, di_bh,
+					     meta_ac, &bh);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+		depth++;
+		if (depth == 1) {
+			/*
+			 * Special case: we have room now if we shifted from
+			 * tree_depth 0, so no more work needs to be done.
+			 *
+			 * We won't be calling add_branch, so pass
+			 * back *last_eb_bh as the new leaf. At depth
+			 * zero, it should always be null so there's
+			 * no reason to brelse.
+			 */
+			BUG_ON(*last_eb_bh);
+			get_bh(bh);
+			*last_eb_bh = bh;
+			goto out;
+		}
+	}
+
+	/* call ocfs2_add_branch to add the final part of the tree with
+	 * the new data. */
+	mlog(0, "add branch. bh = %p\n", bh);
+	ret = ocfs2_add_branch(osb, handle, inode, di_bh, bh, last_eb_bh,
+			       meta_ac);
+	if (ret < 0) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+out:
+	if (final_depth)
+		*final_depth = depth;
+	brelse(bh);
+	return ret;
+}
+
+/*
@@ -936,0 +1100,16 @@
+static void ocfs2_remove_empty_extent(struct ocfs2_extent_list *el)
+{
+	int size, num_recs = le16_to_cpu(el->l_next_free_rec);
+
+	BUG_ON(num_recs == 0);
+
+	if (ocfs2_is_empty_extent(&el->l_recs[0])) {
+		num_recs--;
+		size = num_recs * sizeof(struct ocfs2_extent_rec);
+		memmove(&el->l_recs[0], &el->l_recs[1], size);
+		memset(&el->l_recs[num_recs], 0,
+		       sizeof(struct ocfs2_extent_rec));
+		el->l_next_free_rec = cpu_to_le16(num_recs);
+	}
+}
+
@@ -1213,0 +1393,4 @@
+	if (ocfs2_is_empty_extent(&right_child_el->l_recs[0])) {
+		BUG_ON(le16_to_cpu(right_child_el->l_next_free_rec) <= 1);
+		left_clusters = le32_to_cpu(right_child_el->l_recs[1].e_cpos);
+	}
@@ -1533,0 +1717,5 @@
+/*
+ * Extend the transaction by enough credits to complete the rotation,
+ * and still leave at least the original number of credits allocated
+ * to this transaction.
+ */
@@ -1534,0 +1723 @@
+					   int op_credits,
@@ -1537 +1726 @@
-	int credits = (path->p_tree_depth - subtree_depth) * 2 + 1;
+	int credits = (path->p_tree_depth - subtree_depth) * 2 + 1 + op_credits;
@@ -1570,0 +1760,23 @@
+static int ocfs2_leftmost_rec_contains(struct ocfs2_extent_list *el, u32 cpos)
+{
+	int next_free = le16_to_cpu(el->l_next_free_rec);
+	unsigned int range;
+	struct ocfs2_extent_rec *rec;
+
+	if (next_free == 0)
+		return 0;
+
+	rec = &el->l_recs[0];
+	if (ocfs2_is_empty_extent(rec)) {
+		/* Empty list. */
+		if (next_free == 1)
+			return 0;
+		rec = &el->l_recs[1];
+	}
+
+	range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);
+	if (cpos >= le32_to_cpu(rec->e_cpos) && cpos < range)
+		return 1;
+	return 0;
+}
+
@@ -1588,0 +1801 @@
+				   enum ocfs2_split_type split,
@@ -1593 +1806 @@
-	int ret, start;
+	int ret, start, orig_credits = handle->h_buffer_credits;
@@ -1660 +1873,2 @@
-		if (ocfs2_rotate_requires_path_adjustment(left_path,
+		if (split == SPLIT_NONE &&
+		    ocfs2_rotate_requires_path_adjustment(left_path,
@@ -1662 +1875,0 @@
-			mlog(0, "Path adjustment required\n");
@@ -1690 +1903 @@
-						      right_path);
+						      orig_credits, right_path);
@@ -1702,0 +1916,18 @@
+		if (split != SPLIT_NONE &&
+		    ocfs2_leftmost_rec_contains(path_leaf_el(right_path),
+						insert_cpos)) {
+			/*
+			 * A rotate moves the rightmost left leaf
+			 * record over to the leftmost right leaf
+			 * slot. If we're doing an extent split
+			 * instead of a real insert, then we have to
+			 * check that the extent to be split wasn't
+			 * just moved over. If it was, then we can
+			 * exit here, passing left_path back -
+			 * ocfs2_split_extent() is smart enough to
+			 * search both leaves.
+			 */
+			*ret_left_path = left_path;
+			goto out_ret_path;
+		}
+
@@ -1725,9 +1956,2 @@
-/*
- * Do the final bits of extent record insertion at the target leaf
- * list. If this leaf is part of an allocation tree, it is assumed
- * that the tree above has been prepared.
- */
-static void ocfs2_insert_at_leaf(struct ocfs2_extent_rec *insert_rec,
-				 struct ocfs2_extent_list *el,
-				 struct ocfs2_insert_type *insert,
-				 struct inode *inode)
+static void ocfs2_update_edge_lengths(struct inode *inode, handle_t *handle,
+				      struct ocfs2_path *path)
@@ -1735,2 +1959 @@
-	int i = insert->ins_contig_index;
-	unsigned int range;
+	int i, idx;
@@ -1737,0 +1961,3 @@
+	struct ocfs2_extent_list *el;
+	struct ocfs2_extent_block *eb;
+	u32 range;
@@ -1739 +1965,3 @@
-	BUG_ON(le16_to_cpu(el->l_tree_depth) != 0);
+	/* Path should always be rightmost. */
+	eb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;
+	BUG_ON(eb->h_next_leaf_blk != 0ULL);
@@ -1741,13 +1969,5 @@
-	/*
-	 * Contiguous insert - either left or right.
-	 */
-	if (insert->ins_contig != CONTIG_NONE) {
-		rec = &el->l_recs[i];
-		if (insert->ins_contig == CONTIG_LEFT) {
-			rec->e_blkno = insert_rec->e_blkno;
-			rec->e_cpos = insert_rec->e_cpos;
-		}
-		le16_add_cpu(&rec->e_leaf_clusters,
-			     le16_to_cpu(insert_rec->e_leaf_clusters));
-		return;
-	}
+	el = &eb->h_list;
+	BUG_ON(le16_to_cpu(el->l_next_free_rec) == 0);
+	idx = le16_to_cpu(el->l_next_free_rec) - 1;
+	rec = &el->l_recs[idx];
+	range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);
@@ -1755,10 +1975,4 @@
-	/*
-	 * Handle insert into an empty leaf.
-	 */
-	if (le16_to_cpu(el->l_next_free_rec) == 0 ||
-	    ((le16_to_cpu(el->l_next_free_rec) == 1) &&
-	     ocfs2_is_empty_extent(&el->l_recs[0]))) {
-		el->l_recs[0] = *insert_rec;
-		el->l_next_free_rec = cpu_to_le16(1);
-		return;
-	}
+	for (i = 0; i < path->p_tree_depth; i++) {
+		el = path->p_node[i].el;
+		idx = le16_to_cpu(el->l_next_free_rec) - 1;
+		rec = &el->l_recs[idx];
@@ -1766,9 +1980,2 @@
-	/*
-	 * Appending insert.
-	 */
-	if (insert->ins_appending == APPEND_TAIL) {
-		i = le16_to_cpu(el->l_next_free_rec) - 1;
-		rec = &el->l_recs[i];
-		range = le32_to_cpu(rec->e_cpos)
-			+ le16_to_cpu(rec->e_leaf_clusters);
-		BUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);
+		rec->e_int_clusters = cpu_to_le32(range);
+		le32_add_cpu(&rec->e_int_clusters, -le32_to_cpu(rec->e_cpos));
@@ -1776,17 +1983 @@
-		mlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=
-				le16_to_cpu(el->l_count),
-				"inode %lu, depth %u, count %u, next free %u, "
-				"rec.cpos %u, rec.clusters %u, "
-				"insert.cpos %u, insert.clusters %u\n",
-				inode->i_ino,
-				le16_to_cpu(el->l_tree_depth),
-				le16_to_cpu(el->l_count),
-				le16_to_cpu(el->l_next_free_rec),
-				le32_to_cpu(el->l_recs[i].e_cpos),
-				le16_to_cpu(el->l_recs[i].e_leaf_clusters),
-				le32_to_cpu(insert_rec->e_cpos),
-				le16_to_cpu(insert_rec->e_leaf_clusters));
-		i++;
-		el->l_recs[i] = *insert_rec;
-		le16_add_cpu(&el->l_next_free_rec, 1);
-		return;
+		ocfs2_journal_dirty(handle, path->p_node[i].bh);
@@ -1794,22 +1984,0 @@
-
-	/*
-	 * Ok, we have to rotate.
-	 *
-	 * At this point, it is safe to assume that inserting into an
-	 * empty leaf and appending to a leaf have both been handled
-	 * above.
-	 *
-	 * This leaf needs to have space, either by the empty 1st
-	 * extent record, or by virtue of an l_next_rec < l_count.
-	 */
-	ocfs2_rotate_leaf(el, insert_rec);
-}
-
-static inline void ocfs2_update_dinode_clusters(struct inode *inode,
-						struct ocfs2_dinode *di,
-						u32 clusters)
-{
-	le32_add_cpu(&di->i_clusters, clusters);
-	spin_lock(&OCFS2_I(inode)->ip_lock);
-	OCFS2_I(inode)->ip_clusters = le32_to_cpu(di->i_clusters);
-	spin_unlock(&OCFS2_I(inode)->ip_lock);
@@ -1818,4 +1987,3 @@
-static int ocfs2_append_rec_to_path(struct inode *inode, handle_t *handle,
-				    struct ocfs2_extent_rec *insert_rec,
-				    struct ocfs2_path *right_path,
-				    struct ocfs2_path **ret_left_path)
+static void ocfs2_unlink_path(struct inode *inode, handle_t *handle,
+			      struct ocfs2_cached_dealloc_ctxt *dealloc,
+			      struct ocfs2_path *path, int unlink_start)
@@ -1823,2 +1991,2 @@
-	int ret, i, next_free;
-	struct buffer_head *bh;
+	int ret, i;
+	struct ocfs2_extent_block *eb;
@@ -1826 +1994 @@
-	struct ocfs2_path *left_path = NULL;
+	struct buffer_head *bh;
@@ -1828 +1996,2 @@
-	*ret_left_path = NULL;
+	for(i = unlink_start; i < path_num_items(path); i++) {
+		bh = path->p_node[i].bh;
@@ -1830,5 +1999,13 @@
-	/*
-	 * This shouldn't happen for non-trees. The extent rec cluster
-	 * count manipulation below only works for interior nodes.
-	 */
-	BUG_ON(right_path->p_tree_depth == 0);
+		eb = (struct ocfs2_extent_block *)bh->b_data;
+		/*
+		 * Not all nodes might have had their final count
+		 * decremented by the caller - handle this here.
+		 */
+		el = &eb->h_list;
+		if (le16_to_cpu(el->l_next_free_rec) > 1) {
+			mlog(ML_ERROR,
+			     "Inode %llu, attempted to remove extent block "
+			     "%llu with %u records\n",
+			     (unsigned long long)OCFS2_I(inode)->ip_blkno,
+			     (unsigned long long)le64_to_cpu(eb->h_blkno),
+			     le16_to_cpu(el->l_next_free_rec));
@@ -1836,10 +2013,4 @@
-	/*
-	 * If our appending insert is at the leftmost edge of a leaf,
-	 * then we might need to update the rightmost records of the
-	 * neighboring path.
-	 */
-	el = path_leaf_el(right_path);
-	next_free = le16_to_cpu(el->l_next_free_rec);
-	if (next_free == 0 ||
-	    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0]))) {
-		u32 left_cpos;
+			ocfs2_journal_dirty(handle, bh);
+			ocfs2_remove_from_cache(inode, bh);
+			continue;
+		}
@@ -1847,3 +2018,7 @@
-		ret = ocfs2_find_cpos_for_left_leaf(inode->i_sb, right_path,
-						    &left_cpos);
-		if (ret) {
+		el->l_next_free_rec = 0;
+		memset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));
+
+		ocfs2_journal_dirty(handle, bh);
+
+		ret = ocfs2_cache_extent_block_free(dealloc, eb);
+		if (ret)
@@ -1851,2 +2025,0 @@
-			goto out;
-		}
@@ -1854,3 +2027,3 @@
-		mlog(0, "Append may need a left path update. cpos: %u, "
-		     "left_cpos: %u\n", le32_to_cpu(insert_rec->e_cpos),
-		     left_cpos);
+		ocfs2_remove_from_cache(inode, bh);
+	}
+}
@@ -1857,0 +2031,60 @@
+static void ocfs2_unlink_subtree(struct inode *inode, handle_t *handle,
+				 struct ocfs2_path *left_path,
+				 struct ocfs2_path *right_path,
+				 int subtree_index,
+				 struct ocfs2_cached_dealloc_ctxt *dealloc)
+{
+	int i;
+	struct buffer_head *root_bh = left_path->p_node[subtree_index].bh;
+	struct ocfs2_extent_list *root_el = left_path->p_node[subtree_index].el;
+	struct ocfs2_extent_list *el;
+	struct ocfs2_extent_block *eb;
+
+	el = path_leaf_el(left_path);
+
+	eb = (struct ocfs2_extent_block *)right_path->p_node[subtree_index + 1].bh->b_data;
+
+	for(i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)
+		if (root_el->l_recs[i].e_blkno == eb->h_blkno)
+			break;
+
+	BUG_ON(i >= le16_to_cpu(root_el->l_next_free_rec));
+
+	memset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));
+	le16_add_cpu(&root_el->l_next_free_rec, -1);
+
+	eb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;
+	eb->h_next_leaf_blk = 0;
+
+	ocfs2_journal_dirty(handle, root_bh);
+	ocfs2_journal_dirty(handle, path_leaf_bh(left_path));
+
+	ocfs2_unlink_path(inode, handle, dealloc, right_path,
+			  subtree_index + 1);
+}
+
+static int ocfs2_rotate_subtree_left(struct inode *inode, handle_t *handle,
+				     struct ocfs2_path *left_path,
+				     struct ocfs2_path *right_path,
+				     int subtree_index,
+				     struct ocfs2_cached_dealloc_ctxt *dealloc,
+				     int *deleted)
+{
+	int ret, i, del_right_subtree = 0, right_has_empty = 0;
+	struct buffer_head *root_bh, *di_bh = path_root_bh(right_path);
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
+	struct ocfs2_extent_list *right_leaf_el, *left_leaf_el;
+	struct ocfs2_extent_block *eb;
+
+	*deleted = 0;
+
+	right_leaf_el = path_leaf_el(right_path);
+	left_leaf_el = path_leaf_el(left_path);
+	root_bh = left_path->p_node[subtree_index].bh;
+	BUG_ON(root_bh != right_path->p_node[subtree_index].bh);
+
+	if (!ocfs2_is_empty_extent(&left_leaf_el->l_recs[0]))
+		return 0;
+
+	eb = (struct ocfs2_extent_block *)path_leaf_bh(right_path)->b_data;
+	if (ocfs2_is_empty_extent(&right_leaf_el->l_recs[0])) {
@@ -1859,2 +2092,10 @@
-		 * No need to worry if the append is already in the
-		 * leftmost leaf.
+		 * It's legal for us to proceed if the right leaf is
+		 * the rightmost one and it has an empty extent. There
+		 * are two cases to handle - whether the leaf will be
+		 * empty after removal or not. If the leaf isn't empty
+		 * then just remove the empty extent up front. The
+		 * next block will handle empty leaves by flagging
+		 * them for unlink.
+		 *
+		 * Non rightmost leaves will throw -EAGAIN and the
+		 * caller can manually move the subtree and retry.
@@ -1862,8 +2102,0 @@
-		if (left_cpos) {
-			left_path = ocfs2_new_path(path_root_bh(right_path),
-						   path_root_el(right_path));
-			if (!left_path) {
-				ret = -ENOMEM;
-				mlog_errno(ret);
-				goto out;
-			}
@@ -1871 +2104,7 @@
-			ret = ocfs2_find_path(inode, left_path, left_cpos);
+		if (eb->h_next_leaf_blk != 0ULL)
+			return -EAGAIN;
+
+		if (le16_to_cpu(right_leaf_el->l_next_free_rec) > 1) {
+			ret = ocfs2_journal_access(handle, inode,
+						   path_leaf_bh(right_path),
+						   OCFS2_JOURNAL_ACCESS_WRITE);
@@ -1877,4 +2116,16 @@
-			/*
-			 * ocfs2_insert_path() will pass the left_path to the
-			 * journal for us.
-			 */
+			ocfs2_remove_empty_extent(right_leaf_el);
+		} else
+			right_has_empty = 1;
+	}
+
+	if (eb->h_next_leaf_blk == 0ULL &&
+	    le16_to_cpu(right_leaf_el->l_next_free_rec) == 1) {
+		/*
+		 * We have to update i_last_eb_blk during the meta
+		 * data delete.
+		 */
+		ret = ocfs2_journal_access(handle, inode, di_bh,
+					   OCFS2_JOURNAL_ACCESS_WRITE);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
@@ -1881,0 +2133,2 @@
+
+		del_right_subtree = 1;
@@ -1884 +2137,8 @@
-	ret = ocfs2_journal_access_path(inode, handle, right_path);
+	/*
+	 * Getting here with an empty extent in the right path implies
+	 * that it's the rightmost path and will be deleted.
+	 */
+	BUG_ON(right_has_empty && !del_right_subtree);
+
+	ret = ocfs2_journal_access(handle, inode, root_bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
@@ -1890,5 +2150,8 @@
-	el = path_root_el(right_path);
-	bh = path_root_bh(right_path);
-	i = 0;
-	while (1) {
-		struct ocfs2_extent_rec *rec;
+	for(i = subtree_index + 1; i < path_num_items(right_path); i++) {
+		ret = ocfs2_journal_access(handle, inode,
+					   right_path->p_node[i].bh,
+					   OCFS2_JOURNAL_ACCESS_WRITE);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
@@ -1896,6 +2159,5 @@
-		next_free = le16_to_cpu(el->l_next_free_rec);
-		if (next_free == 0) {
-			ocfs2_error(inode->i_sb,
-				    "Dinode %llu has a bad extent list",
-				    (unsigned long long)OCFS2_I(inode)->ip_blkno);
-			ret = -EIO;
+		ret = ocfs2_journal_access(handle, inode,
+					   left_path->p_node[i].bh,
+					   OCFS2_JOURNAL_ACCESS_WRITE);
+		if (ret) {
+			mlog_errno(ret);
@@ -1903,0 +2166 @@
+	}
@@ -1905 +2168,20 @@
-		rec = &el->l_recs[next_free - 1];
+	if (!right_has_empty) {
+		/*
+		 * Only do this if we're moving a real
+		 * record. Otherwise, the action is delayed until
+		 * after removal of the right path in which case we
+		 * can do a simple shift to remove the empty extent.
+		 */
+		ocfs2_rotate_leaf(left_leaf_el, &right_leaf_el->l_recs[0]);
+		memset(&right_leaf_el->l_recs[0], 0,
+		       sizeof(struct ocfs2_extent_rec));
+	}
+	if (eb->h_next_leaf_blk == 0ULL) {
+		/*
+		 * Move recs over to get rid of empty extent, decrease
+		 * next_free. This is allowed to remove the last
+		 * extent in our leaf (setting l_next_free_rec to
+		 * zero) - the delete code below won't care.
+		 */
+		ocfs2_remove_empty_extent(right_leaf_el);
+	}
@@ -1907,5 +2189,6 @@
-		rec->e_int_clusters = insert_rec->e_cpos;
-		le32_add_cpu(&rec->e_int_clusters,
-			     le16_to_cpu(insert_rec->e_leaf_clusters));
-		le32_add_cpu(&rec->e_int_clusters,
-			     -le32_to_cpu(rec->e_cpos));
+	ret = ocfs2_journal_dirty(handle, path_leaf_bh(left_path));
+	if (ret)
+		mlog_errno(ret);
+	ret = ocfs2_journal_dirty(handle, path_leaf_bh(right_path));
+	if (ret)
+		mlog_errno(ret);
@@ -1913 +2196,17 @@
-		ret = ocfs2_journal_dirty(handle, bh);
+	if (del_right_subtree) {
+		ocfs2_unlink_subtree(inode, handle, left_path, right_path,
+				     subtree_index, dealloc);
+		ocfs2_update_edge_lengths(inode, handle, left_path);
+
+		eb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;
+		di->i_last_eb_blk = eb->h_blkno;
+
+		/*
+		 * Removal of the extent in the left leaf was skipped
+		 * above so we could delete the right path
+		 * 1st.
+		 */
+		if (right_has_empty)
+			ocfs2_remove_empty_extent(left_leaf_el);
+
+		ret = ocfs2_journal_dirty(handle, di_bh);
@@ -1917,7 +2216,4 @@
-		/* Don't touch the leaf node */
-		if (++i >= right_path->p_tree_depth)
-			break;
-
-		bh = right_path->p_node[i].bh;
-		el = right_path->p_node[i].el;
-	}
+		*deleted = 1;
+	} else
+		ocfs2_complete_edge_insert(inode, handle, left_path, right_path,
+					   subtree_index);
@@ -1925,2 +2220,0 @@
-	*ret_left_path = left_path;
-	ret = 0;
@@ -1928,3 +2221,0 @@
-	if (ret != 0)
-		ocfs2_free_path(left_path);
-
@@ -1935,2 +2226,2 @@
- * This function only does inserts on an allocation b-tree. For dinode
- * lists, ocfs2_insert_at_leaf() is called directly.
+ * Given a full path, determine what cpos value would return us a path
+ * containing the leaf immediately to the right of the current one.
@@ -1938,3 +2229,4 @@
- * right_path is the path we want to do the actual insert
- * in. left_path should only be passed in if we need to update that
- * portion of the tree after an edge insert.
+ * Will return zero if the path passed in is already the rightmost path.
+ *
+ * This looks similar, but is subtly different to
+ * ocfs2_find_cpos_for_left_leaf().
@@ -1942,6 +2234,2 @@
-static int ocfs2_insert_path(struct inode *inode,
-			     handle_t *handle,
-			     struct ocfs2_path *left_path,
-			     struct ocfs2_path *right_path,
-			     struct ocfs2_extent_rec *insert_rec,
-			     struct ocfs2_insert_type *insert)
+static int ocfs2_find_cpos_for_right_leaf(struct super_block *sb,
+					  struct ocfs2_path *path, u32 *cpos)
@@ -1949,2 +2237,2 @@
-	int ret, subtree_index;
-	struct buffer_head *leaf_bh = path_leaf_bh(right_path);
+	int i, j, ret = 0;
+	u64 blkno;
@@ -1953,9 +2241 @@
-	/*
-	 * Pass both paths to the journal. The majority of inserts
-	 * will be touching all components anyway.
-	 */
-	ret = ocfs2_journal_access_path(inode, handle, right_path);
-	if (ret < 0) {
-		mlog_errno(ret);
-		goto out;
-	}
+	*cpos = 0;
@@ -1963,2 +2243,11 @@
-	if (left_path) {
-		int credits = handle->h_buffer_credits;
+	if (path->p_tree_depth == 0)
+		return 0;
+
+	blkno = path_leaf_bh(path)->b_blocknr;
+
+	/* Start at the tree node just above the leaf and work our way up. */
+	i = path->p_tree_depth - 1;
+	while (i >= 0) {
+		int next_free;
+
+		el = path->p_node[i].el;
@@ -1967,4 +2256,2 @@
-		 * There's a chance that left_path got passed back to
-		 * us without being accounted for in the
-		 * journal. Extend our transaction here to be sure we
-		 * can change those blocks.
+		 * Find the extent record just after the one in our
+		 * path.
@@ -1972 +2259,20 @@
-		credits += left_path->p_tree_depth;
+		next_free = le16_to_cpu(el->l_next_free_rec);
+		for(j = 0; j < le16_to_cpu(el->l_next_free_rec); j++) {
+			if (le64_to_cpu(el->l_recs[j].e_blkno) == blkno) {
+				if (j == (next_free - 1)) {
+					if (i == 0) {
+						/*
+						 * We've determined that the
+						 * path specified is already
+						 * the rightmost one - return a
+						 * cpos of zero.
+						 */
+						goto out;
+					}
+					/*
+					 * The rightmost record points to our
+					 * leaf - we need to travel up the
+					 * tree one level.
+					 */
+					goto next_node;
+				}
@@ -1974,4 +2280,3 @@
-		ret = ocfs2_extend_trans(handle, credits);
-		if (ret < 0) {
-			mlog_errno(ret);
-			goto out;
+				*cpos = le32_to_cpu(el->l_recs[j + 1].e_cpos);
+				goto out;
+			}
@@ -1980,5 +2285,13 @@
-		ret = ocfs2_journal_access_path(inode, handle, left_path);
-		if (ret < 0) {
-			mlog_errno(ret);
-			goto out;
-		}
+		/*
+		 * If we got here, we never found a valid node where
+		 * the tree indicated one should be.
+		 */
+		ocfs2_error(sb,
+			    "Invalid extent tree at extent block %llu\n",
+			    (unsigned long long)blkno);
+		ret = -EROFS;
+		goto out;
+
+next_node:
+		blkno = path->p_node[i].bh->b_blocknr;
+		i--;
@@ -1987 +2300,3 @@
-	el = path_leaf_el(right_path);
+out:
+	return ret;
+}
@@ -1989,4 +2304,6 @@
-	ocfs2_insert_at_leaf(insert_rec, el, insert, inode);
-	ret = ocfs2_journal_dirty(handle, leaf_bh);
-	if (ret)
-		mlog_errno(ret);
+static int ocfs2_rotate_rightmost_leaf_left(struct inode *inode,
+					    handle_t *handle,
+					    struct buffer_head *bh,
+					    struct ocfs2_extent_list *el)
+{
+	int ret;
@@ -1994,11 +2311,8 @@
-	if (left_path) {
-		/*
-		 * The rotate code has indicated that we need to fix
-		 * up portions of the tree after the insert.
-		 *
-		 * XXX: Should we extend the transaction here?
-		 */
-		subtree_index = ocfs2_find_subtree_root(inode, left_path,
-							right_path);
-		ocfs2_complete_edge_insert(inode, handle, left_path,
-					   right_path, subtree_index);
+	if (!ocfs2_is_empty_extent(&el->l_recs[0]))
+		return 0;
+
+	ret = ocfs2_journal_access(handle, inode, bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
@@ -2007 +2321,6 @@
-	ret = 0;
+	ocfs2_remove_empty_extent(el);
+
+	ret = ocfs2_journal_dirty(handle, bh);
+	if (ret)
+		mlog_errno(ret);
+
@@ -2012,5 +2331,5 @@
-static int ocfs2_do_insert_extent(struct inode *inode,
-				  handle_t *handle,
-				  struct buffer_head *di_bh,
-				  struct ocfs2_extent_rec *insert_rec,
-				  struct ocfs2_insert_type *type)
+static int __ocfs2_rotate_tree_left(struct inode *inode,
+				    handle_t *handle, int orig_credits,
+				    struct ocfs2_path *path,
+				    struct ocfs2_cached_dealloc_ctxt *dealloc,
+				    struct ocfs2_path **empty_extent_path)
@@ -2018,3 +2337,2 @@
-	int ret, rotate = 0;
-	u32 cpos;
-	struct ocfs2_path *right_path = NULL;
+	int ret, subtree_root, deleted;
+	u32 right_cpos;
@@ -2022,2 +2340 @@
-	struct ocfs2_dinode *di;
-	struct ocfs2_extent_list *el;
+	struct ocfs2_path *right_path = NULL;
@@ -2025,2 +2342 @@
-	di = (struct ocfs2_dinode *) di_bh->b_data;
-	el = &di->id2.i_list;
+	BUG_ON(!ocfs2_is_empty_extent(&(path_leaf_el(path)->l_recs[0])));
@@ -2028,2 +2344,4 @@
-	ret = ocfs2_journal_access(handle, inode, di_bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
+	*empty_extent_path = NULL;
+
+	ret = ocfs2_find_cpos_for_right_leaf(inode->i_sb, path,
+					     &right_cpos);
@@ -2035,3 +2353,6 @@
-	if (le16_to_cpu(el->l_tree_depth) == 0) {
-		ocfs2_insert_at_leaf(insert_rec, el, type, inode);
-		goto out_update_clusters;
+	left_path = ocfs2_new_path(path_root_bh(path),
+				   path_root_el(path));
+	if (!left_path) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
@@ -2040 +2361,4 @@
-	right_path = ocfs2_new_inode_path(di_bh);
+	ocfs2_cp_path(left_path, path);
+
+	right_path = ocfs2_new_path(path_root_bh(path),
+				    path_root_el(path));
@@ -2047,11 +2371,6 @@
-	/*
-	 * Determine the path to start with. Rotations need the
-	 * rightmost path, everything else can go directly to the
-	 * target leaf.
-	 */
-	cpos = le32_to_cpu(insert_rec->e_cpos);
-	if (type->ins_appending == APPEND_NONE &&
-	    type->ins_contig == CONTIG_NONE) {
-		rotate = 1;
-		cpos = UINT_MAX;
-	}
+	while (right_cpos) {
+		ret = ocfs2_find_path(inode, right_path, right_cpos);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
@@ -2059,5 +2378,2 @@
-	ret = ocfs2_find_path(inode, right_path, cpos);
-	if (ret) {
-		mlog_errno(ret);
-		goto out;
-	}
+		subtree_root = ocfs2_find_subtree_root(inode, left_path,
+						       right_path);
@@ -2065,16 +2381,8 @@
-	/*
-	 * Rotations and appends need special treatment - they modify
-	 * parts of the tree's above them.
-	 *
-	 * Both might pass back a path immediate to the left of the
-	 * one being inserted to. This will be cause
-	 * ocfs2_insert_path() to modify the rightmost records of
-	 * left_path to account for an edge insert.
-	 *
-	 * XXX: When modifying this code, keep in mind that an insert
-	 * can wind up skipping both of these two special cases...
-	 */
-	if (rotate) {
-		ret = ocfs2_rotate_tree_right(inode, handle,
-					      le32_to_cpu(insert_rec->e_cpos),
-					      right_path, &left_path);
+		mlog(0, "Subtree root at index %d (blk %llu, depth %d)\n",
+		     subtree_root,
+		     (unsigned long long)
+		     right_path->p_node[subtree_root].bh->b_blocknr,
+		     right_path->p_tree_depth);
+
+		ret = ocfs2_extend_rotate_transaction(handle, subtree_root,
+						      orig_credits, left_path);
@@ -2085,4 +2393,15 @@
-	} else if (type->ins_appending == APPEND_TAIL
-		   && type->ins_contig != CONTIG_LEFT) {
-		ret = ocfs2_append_rec_to_path(inode, handle, insert_rec,
-					       right_path, &left_path);
+
+		ret = ocfs2_rotate_subtree_left(inode, handle, left_path,
+						right_path, subtree_root,
+						dealloc, &deleted);
+		if (ret == -EAGAIN) {
+			/*
+			 * The rotation has to temporarily stop due to
+			 * the right subtree having an empty
+			 * extent. Pass it back to the caller for a
+			 * fixup.
+			 */
+			*empty_extent_path = right_path;
+			right_path = NULL;
+			goto out;
+		}
@@ -2093 +2411,0 @@
-	}
@@ -2095,6 +2413,7 @@
-	ret = ocfs2_insert_path(inode, handle, left_path, right_path,
-				insert_rec, type);
-	if (ret) {
-		mlog_errno(ret);
-		goto out;
-	}
+		/*
+		 * The subtree rotate might have removed records on
+		 * the rightmost edge. If so, then rotation is
+		 * complete.
+		 */
+		if (deleted)
+			break;
@@ -2102,3 +2421 @@
-out_update_clusters:
-	ocfs2_update_dinode_clusters(inode, di,
-				     le16_to_cpu(insert_rec->e_leaf_clusters));
+		ocfs2_mv_path(left_path, right_path);
@@ -2106,3 +2423,7 @@
-	ret = ocfs2_journal_dirty(handle, di_bh);
-	if (ret)
-		mlog_errno(ret);
+		ret = ocfs2_find_cpos_for_right_leaf(inode->i_sb, left_path,
+						     &right_cpos);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
@@ -2111 +2431,0 @@
-	ocfs2_free_path(left_path);
@@ -2112,0 +2433 @@
+	ocfs2_free_path(left_path);
@@ -2117,4 +2438,3 @@
-static void ocfs2_figure_contig_type(struct inode *inode,
-				     struct ocfs2_insert_type *insert,
-				     struct ocfs2_extent_list *el,
-				     struct ocfs2_extent_rec *insert_rec)
+static int ocfs2_remove_rightmost_path(struct inode *inode, handle_t *handle,
+				       struct ocfs2_path *path,
+				       struct ocfs2_cached_dealloc_ctxt *dealloc)
@@ -2122,2 +2442,6 @@
-	int i;
-	enum ocfs2_contig_type contig_type = CONTIG_NONE;
+	int ret, subtree_index;
+	u32 cpos;
+	struct ocfs2_path *left_path = NULL;
+	struct ocfs2_dinode *di;
+	struct ocfs2_extent_block *eb;
+	struct ocfs2_extent_list *el;
@@ -2125 +2449,12 @@
-	BUG_ON(le16_to_cpu(el->l_tree_depth) != 0);
+	/*
+	 * XXX: This code assumes that the root is an inode, which is
+	 * true for now but may change as tree code gets generic.
+	 */
+	di = (struct ocfs2_dinode *)path_root_bh(path)->b_data;
+	if (!OCFS2_IS_VALID_DINODE(di)) {
+		ret = -EIO;
+		ocfs2_error(inode->i_sb,
+			    "Inode %llu has invalid path root",
+			    (unsigned long long)OCFS2_I(inode)->ip_blkno);
+		goto out;
+	}
@@ -2127,7 +2462,10 @@
-	for(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {
-		contig_type = ocfs2_extent_contig(inode, &el->l_recs[i],
-						  insert_rec);
-		if (contig_type != CONTIG_NONE) {
-			insert->ins_contig_index = i;
-			break;
-		}
+	/*
+	 * There's two ways we handle this depending on
+	 * whether path is the only existing one.
+	 */
+	ret = ocfs2_extend_rotate_transaction(handle, 0,
+					      handle->h_buffer_credits,
+					      path);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
@@ -2135,2 +2472,0 @@
-	insert->ins_contig = contig_type;
-}
@@ -2138,17 +2474,5 @@
-/*
- * This should only be called against the righmost leaf extent list.
- *
- * ocfs2_figure_appending_type() will figure out whether we'll have to
- * insert at the tail of the rightmost leaf.
- *
- * This should also work against the dinode list for tree's with 0
- * depth. If we consider the dinode list to be the rightmost leaf node
- * then the logic here makes sense.
- */
-static void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,
-					struct ocfs2_extent_list *el,
-					struct ocfs2_extent_rec *insert_rec)
-{
-	int i;
-	u32 cpos = le32_to_cpu(insert_rec->e_cpos);
-	struct ocfs2_extent_rec *rec;
+	ret = ocfs2_journal_access_path(inode, handle, path);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
@@ -2156 +2480,5 @@
-	insert->ins_appending = APPEND_NONE;
+	ret = ocfs2_find_cpos_for_left_leaf(inode->i_sb, path, &cpos);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
@@ -2158 +2486,12 @@
-	BUG_ON(le16_to_cpu(el->l_tree_depth) != 0);
+	if (cpos) {
+		/*
+		 * We have a path to the left of this one - it needs
+		 * an update too.
+		 */
+		left_path = ocfs2_new_path(path_root_bh(path),
+					   path_root_el(path));
+		if (!left_path) {
+			ret = -ENOMEM;
+			mlog_errno(ret);
+			goto out;
+		}
@@ -2160,2 +2499,5 @@
-	if (!el->l_next_free_rec)
-		goto set_tail_append;
+		ret = ocfs2_find_path(inode, left_path, cpos);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
@@ -2163,5 +2505,5 @@
-	if (ocfs2_is_empty_extent(&el->l_recs[0])) {
-		/* Were all records empty? */
-		if (le16_to_cpu(el->l_next_free_rec) == 1)
-			goto set_tail_append;
-	}
+		ret = ocfs2_journal_access_path(inode, handle, left_path);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
@@ -2169,2 +2511 @@
-	i = le16_to_cpu(el->l_next_free_rec) - 1;
-	rec = &el->l_recs[i];
+		subtree_index = ocfs2_find_subtree_root(inode, left_path, path);
@@ -2172,3 +2513,3 @@
-	if (cpos >=
-	    (le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)))
-		goto set_tail_append;
+		ocfs2_unlink_subtree(inode, handle, left_path, path,
+				     subtree_index, dealloc);
+		ocfs2_update_edge_lengths(inode, handle, left_path);
@@ -2176 +2517,11 @@
-	return;
+		eb = (struct ocfs2_extent_block *)path_leaf_bh(left_path)->b_data;
+		di->i_last_eb_blk = eb->h_blkno;
+	} else {
+		/*
+		 * 'path' is also the leftmost path which
+		 * means it must be the only one. This gets
+		 * handled differently because we want to
+		 * revert the inode back to having extents
+		 * in-line.
+		 */
+		ocfs2_unlink_path(inode, handle, dealloc, path, 1);
@@ -2178,2 +2529,13 @@
-set_tail_append:
-	insert->ins_appending = APPEND_TAIL;
+		el = &di->id2.i_list;
+		el->l_tree_depth = 0;
+		el->l_next_free_rec = 0;
+		memset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));
+
+		di->i_last_eb_blk = 0;
+	}
+
+	ocfs2_journal_dirty(handle, path_root_bh(path));
+
+out:
+	ocfs2_free_path(left_path);
+	return ret;
@@ -2183 +2545 @@
- * Helper function called at the begining of an insert.
+ * Left rotation of btree records.
@@ -2185,9 +2547,12 @@
- * This computes a few things that are commonly used in the process of
- * inserting into the btree:
- *   - Whether the new extent is contiguous with an existing one.
- *   - The current tree depth.
- *   - Whether the insert is an appending one.
- *   - The total # of free records in the tree.
- *
- * All of the information is stored on the ocfs2_insert_type
- * structure.
+ * In many ways, this is (unsurprisingly) the opposite of right
+ * rotation. We start at some non-rightmost path containing an empty
+ * extent in the leaf block. The code works its way to the rightmost
+ * path by rotating records to the left in every subtree.
+ *
+ * This is used by any code which reduces the number of extent records
+ * in a leaf. After removal, an empty record should be placed in the
+ * leftmost list position.
+ *
+ * This won't handle a length update of the rightmost path records if
+ * the rightmost tree leaf record is removed so the caller is
+ * responsible for detecting and correcting that.
@@ -2195,5 +2560,3 @@
-static int ocfs2_figure_insert_type(struct inode *inode,
-				    struct buffer_head *di_bh,
-				    struct buffer_head **last_eb_bh,
-				    struct ocfs2_extent_rec *insert_rec,
-				    struct ocfs2_insert_type *insert)
+static int ocfs2_rotate_tree_left(struct inode *inode, handle_t *handle,
+				  struct ocfs2_path *path,
+				  struct ocfs2_cached_dealloc_ctxt *dealloc)
@@ -2201,2 +2564,2 @@
-	int ret;
-	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
+	int ret, orig_credits = handle->h_buffer_credits;
+	struct ocfs2_path *tmp_path = NULL, *restart_path = NULL;
@@ -2205,2 +2567,0 @@
-	struct ocfs2_path *path = NULL;
-	struct buffer_head *bh = NULL;
@@ -2208,2 +2569,3 @@
-	el = &di->id2.i_list;
-	insert->ins_tree_depth = le16_to_cpu(el->l_tree_depth);
+	el = path_leaf_el(path);
+	if (!ocfs2_is_empty_extent(&el->l_recs[0]))
+		return 0;
@@ -2211 +2573,2 @@
-	if (el->l_tree_depth) {
+	if (path->p_tree_depth == 0) {
+rightmost_no_delete:
@@ -2213,4 +2576,2 @@
-		 * If we have tree depth, we read in the
-		 * rightmost extent block ahead of time as
-		 * ocfs2_figure_insert_type() and ocfs2_add_branch()
-		 * may want it later.
+		 * In-inode extents. This is trivially handled, so do
+		 * it up front.
@@ -2218,9 +2579,6 @@
-		ret = ocfs2_read_block(OCFS2_SB(inode->i_sb),
-				       le64_to_cpu(di->i_last_eb_blk), &bh,
-				       OCFS2_BH_CACHED, inode);
-		if (ret) {
-			mlog_exit(ret);
-			goto out;
-		}
-		eb = (struct ocfs2_extent_block *) bh->b_data;
-		el = &eb->h_list;
+		ret = ocfs2_rotate_rightmost_leaf_left(inode, handle,
+						       path_leaf_bh(path),
+						       path_leaf_el(path));
+		if (ret)
+			mlog_errno(ret);
+		goto out;
@@ -2230,3 +2588,6 @@
-	 * Unless we have a contiguous insert, we'll need to know if
-	 * there is room left in our allocation tree for another
-	 * extent record.
+	 * Handle rightmost branch now. There's several cases:
+	 *  1) simple rotation leaving records in there. That's trivial.
+	 *  2) rotation requiring a branch delete - there's no more
+	 *     records left. Two cases of this:
+	 *     a) There are branches to the left.
+	 *     b) This is also the leftmost (the only) branch.
@@ -2234,2 +2595,3 @@
-	 * XXX: This test is simplistic, we can search for empty
-	 * extent records too.
+	 *  1) is handled via ocfs2_rotate_rightmost_leaf_left()
+	 *  2a) we need the left branch so that we can update it with the unlink
+	 *  2b) we need to bring the inode back to inline extents.
@@ -2237,2 +2598,0 @@
-	insert->ins_free_records = le16_to_cpu(el->l_count) -
-		le16_to_cpu(el->l_next_free_rec);
@@ -2240,5 +2600,10 @@
-	if (!insert->ins_tree_depth) {
-		ocfs2_figure_contig_type(inode, insert, el, insert_rec);
-		ocfs2_figure_appending_type(insert, el, insert_rec);
-		return 0;
-	}
+	eb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;
+	el = &eb->h_list;
+	if (eb->h_next_leaf_blk == 0) {
+		/*
+		 * This gets a bit tricky if we're going to delete the
+		 * rightmost path. Get the other cases out of the way
+		 * 1st.
+		 */
+		if (le16_to_cpu(el->l_next_free_rec) > 1)
+			goto rightmost_no_delete;
@@ -2246,4 +2611,22 @@
-	path = ocfs2_new_inode_path(di_bh);
-	if (!path) {
-		ret = -ENOMEM;
-		mlog_errno(ret);
+		if (le16_to_cpu(el->l_next_free_rec) == 0) {
+			ret = -EIO;
+			ocfs2_error(inode->i_sb,
+				    "Inode %llu has empty extent block at %llu",
+				    (unsigned long long)OCFS2_I(inode)->ip_blkno,
+				    (unsigned long long)le64_to_cpu(eb->h_blkno));
+			goto out;
+		}
+
+		/*
+		 * XXX: The caller can not trust "path" any more after
+		 * this as it will have been deleted. What do we do?
+		 *
+		 * In theory the rotate-for-merge code will never get
+		 * here because it'll always ask for a rotate in a
+		 * nonempty list.
+		 */
+
+		ret = ocfs2_remove_rightmost_path(inode, handle, path,
+						  dealloc);
+		if (ret)
+			mlog_errno(ret);
@@ -2254,4 +2637,2 @@
-	 * In the case that we're inserting past what the tree
-	 * currently accounts for, ocfs2_find_path() will return for
-	 * us the rightmost tree path. This is accounted for below in
-	 * the appending code.
+	 * Now we can loop, remembering the path we get from -EAGAIN
+	 * and restarting from there.
@@ -2259,2 +2640,4 @@
-	ret = ocfs2_find_path(inode, path, le32_to_cpu(insert_rec->e_cpos));
-	if (ret) {
+try_rotate:
+	ret = __ocfs2_rotate_tree_left(inode, handle, orig_credits, path,
+				       dealloc, &restart_path);
+	if (ret && ret != -EAGAIN) {
@@ -2265 +2648,11 @@
-	el = path_leaf_el(path);
+	while (ret == -EAGAIN) {
+		tmp_path = restart_path;
+		restart_path = NULL;
+
+		ret = __ocfs2_rotate_tree_left(inode, handle, orig_credits,
+					       tmp_path, dealloc,
+					       &restart_path);
+		if (ret && ret != -EAGAIN) {
+			mlog_errno(ret);
+			goto out;
+		}
@@ -2267,8 +2660,1014 @@
-	/*
-	 * Now that we have the path, there's two things we want to determine:
-	 * 1) Contiguousness (also set contig_index if this is so)
-	 *
-	 * 2) Are we doing an append? We can trivially break this up
-         *     into two types of appends: simple record append, or a
-         *     rotate inside the tail leaf.
-	 */
+		ocfs2_free_path(tmp_path);
+		tmp_path = NULL;
+
+		if (ret == 0)
+			goto try_rotate;
+	}
+
+out:
+	ocfs2_free_path(tmp_path);
+	ocfs2_free_path(restart_path);
+	return ret;
+}
+
+static void ocfs2_cleanup_merge(struct ocfs2_extent_list *el,
+				int index)
+{
+	struct ocfs2_extent_rec *rec = &el->l_recs[index];
+	unsigned int size;
+
+	if (rec->e_leaf_clusters == 0) {
+		/*
+		 * We consumed all of the merged-from record. An empty
+		 * extent cannot exist anywhere but the 1st array
+		 * position, so move things over if the merged-from
+		 * record doesn't occupy that position.
+		 *
+		 * This creates a new empty extent so the caller
+		 * should be smart enough to have removed any existing
+		 * ones.
+		 */
+		if (index > 0) {
+			BUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));
+			size = index * sizeof(struct ocfs2_extent_rec);
+			memmove(&el->l_recs[1], &el->l_recs[0], size);
+		}
+
+		/*
+		 * Always memset - the caller doesn't check whether it
+		 * created an empty extent, so there could be junk in
+		 * the other fields.
+		 */
+		memset(&el->l_recs[0], 0, sizeof(struct ocfs2_extent_rec));
+	}
+}
+
+/*
+ * Remove split_rec clusters from the record at index and merge them
+ * onto the beginning of the record at index + 1.
+ */
+static int ocfs2_merge_rec_right(struct inode *inode, struct buffer_head *bh,
+				handle_t *handle,
+				struct ocfs2_extent_rec *split_rec,
+				struct ocfs2_extent_list *el, int index)
+{
+	int ret;
+	unsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);
+	struct ocfs2_extent_rec *left_rec;
+	struct ocfs2_extent_rec *right_rec;
+
+	BUG_ON(index >= le16_to_cpu(el->l_next_free_rec));
+
+	left_rec = &el->l_recs[index];
+	right_rec = &el->l_recs[index + 1];
+
+	ret = ocfs2_journal_access(handle, inode, bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	le16_add_cpu(&left_rec->e_leaf_clusters, -split_clusters);
+
+	le32_add_cpu(&right_rec->e_cpos, -split_clusters);
+	le64_add_cpu(&right_rec->e_blkno,
+		     -ocfs2_clusters_to_blocks(inode->i_sb, split_clusters));
+	le16_add_cpu(&right_rec->e_leaf_clusters, split_clusters);
+
+	ocfs2_cleanup_merge(el, index);
+
+	ret = ocfs2_journal_dirty(handle, bh);
+	if (ret)
+		mlog_errno(ret);
+
+out:
+	return ret;
+}
+
+/*
+ * Remove split_rec clusters from the record at index and merge them
+ * onto the tail of the record at index - 1.
+ */
+static int ocfs2_merge_rec_left(struct inode *inode, struct buffer_head *bh,
+				handle_t *handle,
+				struct ocfs2_extent_rec *split_rec,
+				struct ocfs2_extent_list *el, int index)
+{
+	int ret, has_empty_extent = 0;
+	unsigned int split_clusters = le16_to_cpu(split_rec->e_leaf_clusters);
+	struct ocfs2_extent_rec *left_rec;
+	struct ocfs2_extent_rec *right_rec;
+
+	BUG_ON(index <= 0);
+
+	left_rec = &el->l_recs[index - 1];
+	right_rec = &el->l_recs[index];
+	if (ocfs2_is_empty_extent(&el->l_recs[0]))
+		has_empty_extent = 1;
+
+	ret = ocfs2_journal_access(handle, inode, bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	if (has_empty_extent && index == 1) {
+		/*
+		 * The easy case - we can just plop the record right in.
+		 */
+		*left_rec = *split_rec;
+
+		has_empty_extent = 0;
+	} else {
+		le16_add_cpu(&left_rec->e_leaf_clusters, split_clusters);
+	}
+
+	le32_add_cpu(&right_rec->e_cpos, split_clusters);
+	le64_add_cpu(&right_rec->e_blkno,
+		     ocfs2_clusters_to_blocks(inode->i_sb, split_clusters));
+	le16_add_cpu(&right_rec->e_leaf_clusters, -split_clusters);
+
+	ocfs2_cleanup_merge(el, index);
+
+	ret = ocfs2_journal_dirty(handle, bh);
+	if (ret)
+		mlog_errno(ret);
+
+out:
+	return ret;
+}
+
+static int ocfs2_try_to_merge_extent(struct inode *inode,
+				     handle_t *handle,
+				     struct ocfs2_path *left_path,
+				     int split_index,
+				     struct ocfs2_extent_rec *split_rec,
+				     struct ocfs2_cached_dealloc_ctxt *dealloc,
+				     struct ocfs2_merge_ctxt *ctxt)
+
+{
+	int ret = 0, delete_tail_recs = 0;
+	struct ocfs2_extent_list *el = path_leaf_el(left_path);
+	struct ocfs2_extent_rec *rec = &el->l_recs[split_index];
+
+	BUG_ON(ctxt->c_contig_type == CONTIG_NONE);
+
+	if (ctxt->c_split_covers_rec) {
+		delete_tail_recs++;
+
+		if (ctxt->c_contig_type == CONTIG_LEFTRIGHT ||
+		    ctxt->c_has_empty_extent)
+			delete_tail_recs++;
+
+		if (ctxt->c_has_empty_extent) {
+			/*
+			 * The merge code will need to create an empty
+			 * extent to take the place of the newly
+			 * emptied slot. Remove any pre-existing empty
+			 * extents - having more than one in a leaf is
+			 * illegal.
+			 */
+			ret = ocfs2_rotate_tree_left(inode, handle, left_path,
+						     dealloc);
+			if (ret) {
+				mlog_errno(ret);
+				goto out;
+			}
+			split_index--;
+			rec = &el->l_recs[split_index];
+		}
+	}
+
+	if (ctxt->c_contig_type == CONTIG_LEFTRIGHT) {
+		/*
+		 * Left-right contig implies this.
+		 */
+		BUG_ON(!ctxt->c_split_covers_rec);
+		BUG_ON(split_index == 0);
+
+		/*
+		 * Since the leftright insert always covers the entire
+		 * extent, this call will delete the insert record
+		 * entirely, resulting in an empty extent record added to
+		 * the extent block.
+		 *
+		 * Since the adding of an empty extent shifts
+		 * everything back to the right, there's no need to
+		 * update split_index here.
+		 */
+		ret = ocfs2_merge_rec_left(inode, path_leaf_bh(left_path),
+					   handle, split_rec, el, split_index);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		/*
+		 * We can only get this from logic error above.
+		 */
+		BUG_ON(!ocfs2_is_empty_extent(&el->l_recs[0]));
+
+		/*
+		 * The left merge left us with an empty extent, remove
+		 * it.
+		 */
+		ret = ocfs2_rotate_tree_left(inode, handle, left_path, dealloc);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+		split_index--;
+		rec = &el->l_recs[split_index];
+
+		/*
+		 * Note that we don't pass split_rec here on purpose -
+		 * we've merged it into the left side.
+		 */
+		ret = ocfs2_merge_rec_right(inode, path_leaf_bh(left_path),
+					    handle, rec, el, split_index);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		BUG_ON(!ocfs2_is_empty_extent(&el->l_recs[0]));
+
+		ret = ocfs2_rotate_tree_left(inode, handle, left_path,
+					     dealloc);
+		/*
+		 * Error from this last rotate is not critical, so
+		 * print but don't bubble it up.
+		 */
+		if (ret)
+			mlog_errno(ret);
+		ret = 0;
+	} else {
+		/*
+		 * Merge a record to the left or right.
+		 *
+		 * 'contig_type' is relative to the existing record,
+		 * so for example, if we're "right contig", it's to
+		 * the record on the left (hence the left merge).
+		 */
+		if (ctxt->c_contig_type == CONTIG_RIGHT) {
+			ret = ocfs2_merge_rec_left(inode,
+						   path_leaf_bh(left_path),
+						   handle, split_rec, el,
+						   split_index);
+			if (ret) {
+				mlog_errno(ret);
+				goto out;
+			}
+		} else {
+			ret = ocfs2_merge_rec_right(inode,
+						    path_leaf_bh(left_path),
+						    handle, split_rec, el,
+						    split_index);
+			if (ret) {
+				mlog_errno(ret);
+				goto out;
+			}
+		}
+
+		if (ctxt->c_split_covers_rec) {
+			/*
+			 * The merge may have left an empty extent in
+			 * our leaf. Try to rotate it away.
+			 */
+			ret = ocfs2_rotate_tree_left(inode, handle, left_path,
+						     dealloc);
+			if (ret)
+				mlog_errno(ret);
+			ret = 0;
+		}
+	}
+
+out:
+	return ret;
+}
+
+static void ocfs2_subtract_from_rec(struct super_block *sb,
+				    enum ocfs2_split_type split,
+				    struct ocfs2_extent_rec *rec,
+				    struct ocfs2_extent_rec *split_rec)
+{
+	u64 len_blocks;
+
+	len_blocks = ocfs2_clusters_to_blocks(sb,
+				le16_to_cpu(split_rec->e_leaf_clusters));
+
+	if (split == SPLIT_LEFT) {
+		/*
+		 * Region is on the left edge of the existing
+		 * record.
+		 */
+		le32_add_cpu(&rec->e_cpos,
+			     le16_to_cpu(split_rec->e_leaf_clusters));
+		le64_add_cpu(&rec->e_blkno, len_blocks);
+		le16_add_cpu(&rec->e_leaf_clusters,
+			     -le16_to_cpu(split_rec->e_leaf_clusters));
+	} else {
+		/*
+		 * Region is on the right edge of the existing
+		 * record.
+		 */
+		le16_add_cpu(&rec->e_leaf_clusters,
+			     -le16_to_cpu(split_rec->e_leaf_clusters));
+	}
+}
+
+/*
+ * Do the final bits of extent record insertion at the target leaf
+ * list. If this leaf is part of an allocation tree, it is assumed
+ * that the tree above has been prepared.
+ */
+static void ocfs2_insert_at_leaf(struct ocfs2_extent_rec *insert_rec,
+				 struct ocfs2_extent_list *el,
+				 struct ocfs2_insert_type *insert,
+				 struct inode *inode)
+{
+	int i = insert->ins_contig_index;
+	unsigned int range;
+	struct ocfs2_extent_rec *rec;
+
+	BUG_ON(le16_to_cpu(el->l_tree_depth) != 0);
+
+	if (insert->ins_split != SPLIT_NONE) {
+		i = ocfs2_search_extent_list(el, le32_to_cpu(insert_rec->e_cpos));
+		BUG_ON(i == -1);
+		rec = &el->l_recs[i];
+		ocfs2_subtract_from_rec(inode->i_sb, insert->ins_split, rec,
+					insert_rec);
+		goto rotate;
+	}
+
+	/*
+	 * Contiguous insert - either left or right.
+	 */
+	if (insert->ins_contig != CONTIG_NONE) {
+		rec = &el->l_recs[i];
+		if (insert->ins_contig == CONTIG_LEFT) {
+			rec->e_blkno = insert_rec->e_blkno;
+			rec->e_cpos = insert_rec->e_cpos;
+		}
+		le16_add_cpu(&rec->e_leaf_clusters,
+			     le16_to_cpu(insert_rec->e_leaf_clusters));
+		return;
+	}
+
+	/*
+	 * Handle insert into an empty leaf.
+	 */
+	if (le16_to_cpu(el->l_next_free_rec) == 0 ||
+	    ((le16_to_cpu(el->l_next_free_rec) == 1) &&
+	     ocfs2_is_empty_extent(&el->l_recs[0]))) {
+		el->l_recs[0] = *insert_rec;
+		el->l_next_free_rec = cpu_to_le16(1);
+		return;
+	}
+
+	/*
+	 * Appending insert.
+	 */
+	if (insert->ins_appending == APPEND_TAIL) {
+		i = le16_to_cpu(el->l_next_free_rec) - 1;
+		rec = &el->l_recs[i];
+		range = le32_to_cpu(rec->e_cpos)
+			+ le16_to_cpu(rec->e_leaf_clusters);
+		BUG_ON(le32_to_cpu(insert_rec->e_cpos) < range);
+
+		mlog_bug_on_msg(le16_to_cpu(el->l_next_free_rec) >=
+				le16_to_cpu(el->l_count),
+				"inode %lu, depth %u, count %u, next free %u, "
+				"rec.cpos %u, rec.clusters %u, "
+				"insert.cpos %u, insert.clusters %u\n",
+				inode->i_ino,
+				le16_to_cpu(el->l_tree_depth),
+				le16_to_cpu(el->l_count),
+				le16_to_cpu(el->l_next_free_rec),
+				le32_to_cpu(el->l_recs[i].e_cpos),
+				le16_to_cpu(el->l_recs[i].e_leaf_clusters),
+				le32_to_cpu(insert_rec->e_cpos),
+				le16_to_cpu(insert_rec->e_leaf_clusters));
+		i++;
+		el->l_recs[i] = *insert_rec;
+		le16_add_cpu(&el->l_next_free_rec, 1);
+		return;
+	}
+
+rotate:
+	/*
+	 * Ok, we have to rotate.
+	 *
+	 * At this point, it is safe to assume that inserting into an
+	 * empty leaf and appending to a leaf have both been handled
+	 * above.
+	 *
+	 * This leaf needs to have space, either by the empty 1st
+	 * extent record, or by virtue of an l_next_rec < l_count.
+	 */
+	ocfs2_rotate_leaf(el, insert_rec);
+}
+
+static inline void ocfs2_update_dinode_clusters(struct inode *inode,
+						struct ocfs2_dinode *di,
+						u32 clusters)
+{
+	le32_add_cpu(&di->i_clusters, clusters);
+	spin_lock(&OCFS2_I(inode)->ip_lock);
+	OCFS2_I(inode)->ip_clusters = le32_to_cpu(di->i_clusters);
+	spin_unlock(&OCFS2_I(inode)->ip_lock);
+}
+
+static void ocfs2_adjust_rightmost_records(struct inode *inode,
+					   handle_t *handle,
+					   struct ocfs2_path *path,
+					   struct ocfs2_extent_rec *insert_rec)
+{
+	int ret, i, next_free;
+	struct buffer_head *bh;
+	struct ocfs2_extent_list *el;
+	struct ocfs2_extent_rec *rec;
+
+	/*
+	 * Update everything except the leaf block.
+	 */
+	for (i = 0; i < path->p_tree_depth; i++) {
+		bh = path->p_node[i].bh;
+		el = path->p_node[i].el;
+
+		next_free = le16_to_cpu(el->l_next_free_rec);
+		if (next_free == 0) {
+			ocfs2_error(inode->i_sb,
+				    "Dinode %llu has a bad extent list",
+				    (unsigned long long)OCFS2_I(inode)->ip_blkno);
+			ret = -EIO;
+			return;
+		}
+
+		rec = &el->l_recs[next_free - 1];
+
+		rec->e_int_clusters = insert_rec->e_cpos;
+		le32_add_cpu(&rec->e_int_clusters,
+			     le16_to_cpu(insert_rec->e_leaf_clusters));
+		le32_add_cpu(&rec->e_int_clusters,
+			     -le32_to_cpu(rec->e_cpos));
+
+		ret = ocfs2_journal_dirty(handle, bh);
+		if (ret)
+			mlog_errno(ret);
+
+	}
+}
+
+static int ocfs2_append_rec_to_path(struct inode *inode, handle_t *handle,
+				    struct ocfs2_extent_rec *insert_rec,
+				    struct ocfs2_path *right_path,
+				    struct ocfs2_path **ret_left_path)
+{
+	int ret, next_free;
+	struct ocfs2_extent_list *el;
+	struct ocfs2_path *left_path = NULL;
+
+	*ret_left_path = NULL;
+
+	/*
+	 * This shouldn't happen for non-trees. The extent rec cluster
+	 * count manipulation below only works for interior nodes.
+	 */
+	BUG_ON(right_path->p_tree_depth == 0);
+
+	/*
+	 * If our appending insert is at the leftmost edge of a leaf,
+	 * then we might need to update the rightmost records of the
+	 * neighboring path.
+	 */
+	el = path_leaf_el(right_path);
+	next_free = le16_to_cpu(el->l_next_free_rec);
+	if (next_free == 0 ||
+	    (next_free == 1 && ocfs2_is_empty_extent(&el->l_recs[0]))) {
+		u32 left_cpos;
+
+		ret = ocfs2_find_cpos_for_left_leaf(inode->i_sb, right_path,
+						    &left_cpos);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		mlog(0, "Append may need a left path update. cpos: %u, "
+		     "left_cpos: %u\n", le32_to_cpu(insert_rec->e_cpos),
+		     left_cpos);
+
+		/*
+		 * No need to worry if the append is already in the
+		 * leftmost leaf.
+		 */
+		if (left_cpos) {
+			left_path = ocfs2_new_path(path_root_bh(right_path),
+						   path_root_el(right_path));
+			if (!left_path) {
+				ret = -ENOMEM;
+				mlog_errno(ret);
+				goto out;
+			}
+
+			ret = ocfs2_find_path(inode, left_path, left_cpos);
+			if (ret) {
+				mlog_errno(ret);
+				goto out;
+			}
+
+			/*
+			 * ocfs2_insert_path() will pass the left_path to the
+			 * journal for us.
+			 */
+		}
+	}
+
+	ret = ocfs2_journal_access_path(inode, handle, right_path);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ocfs2_adjust_rightmost_records(inode, handle, right_path, insert_rec);
+
+	*ret_left_path = left_path;
+	ret = 0;
+out:
+	if (ret != 0)
+		ocfs2_free_path(left_path);
+
+	return ret;
+}
+
+static void ocfs2_split_record(struct inode *inode,
+			       struct ocfs2_path *left_path,
+			       struct ocfs2_path *right_path,
+			       struct ocfs2_extent_rec *split_rec,
+			       enum ocfs2_split_type split)
+{
+	int index;
+	u32 cpos = le32_to_cpu(split_rec->e_cpos);
+	struct ocfs2_extent_list *left_el = NULL, *right_el, *insert_el, *el;
+	struct ocfs2_extent_rec *rec, *tmprec;
+
+	right_el = path_leaf_el(right_path);;
+	if (left_path)
+		left_el = path_leaf_el(left_path);
+
+	el = right_el;
+	insert_el = right_el;
+	index = ocfs2_search_extent_list(el, cpos);
+	if (index != -1) {
+		if (index == 0 && left_path) {
+			BUG_ON(ocfs2_is_empty_extent(&el->l_recs[0]));
+
+			/*
+			 * This typically means that the record
+			 * started in the left path but moved to the
+			 * right as a result of rotation. We either
+			 * move the existing record to the left, or we
+			 * do the later insert there.
+			 *
+			 * In this case, the left path should always
+			 * exist as the rotate code will have passed
+			 * it back for a post-insert update.
+			 */
+
+			if (split == SPLIT_LEFT) {
+				/*
+				 * It's a left split. Since we know
+				 * that the rotate code gave us an
+				 * empty extent in the left path, we
+				 * can just do the insert there.
+				 */
+				insert_el = left_el;
+			} else {
+				/*
+				 * Right split - we have to move the
+				 * existing record over to the left
+				 * leaf. The insert will be into the
+				 * newly created empty extent in the
+				 * right leaf.
+				 */
+				tmprec = &right_el->l_recs[index];
+				ocfs2_rotate_leaf(left_el, tmprec);
+				el = left_el;
+
+				memset(tmprec, 0, sizeof(*tmprec));
+				index = ocfs2_search_extent_list(left_el, cpos);
+				BUG_ON(index == -1);
+			}
+		}
+	} else {
+		BUG_ON(!left_path);
+		BUG_ON(!ocfs2_is_empty_extent(&left_el->l_recs[0]));
+		/*
+		 * Left path is easy - we can just allow the insert to
+		 * happen.
+		 */
+		el = left_el;
+		insert_el = left_el;
+		index = ocfs2_search_extent_list(el, cpos);
+		BUG_ON(index == -1);
+	}
+
+	rec = &el->l_recs[index];
+	ocfs2_subtract_from_rec(inode->i_sb, split, rec, split_rec);
+	ocfs2_rotate_leaf(insert_el, split_rec);
+}
+
+/*
+ * This function only does inserts on an allocation b-tree. For dinode
+ * lists, ocfs2_insert_at_leaf() is called directly.
+ *
+ * right_path is the path we want to do the actual insert
+ * in. left_path should only be passed in if we need to update that
+ * portion of the tree after an edge insert.
+ */
+static int ocfs2_insert_path(struct inode *inode,
+			     handle_t *handle,
+			     struct ocfs2_path *left_path,
+			     struct ocfs2_path *right_path,
+			     struct ocfs2_extent_rec *insert_rec,
+			     struct ocfs2_insert_type *insert)
+{
+	int ret, subtree_index;
+	struct buffer_head *leaf_bh = path_leaf_bh(right_path);
+
+	/*
+	 * Pass both paths to the journal. The majority of inserts
+	 * will be touching all components anyway.
+	 */
+	ret = ocfs2_journal_access_path(inode, handle, right_path);
+	if (ret < 0) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	if (left_path) {
+		int credits = handle->h_buffer_credits;
+
+		/*
+		 * There's a chance that left_path got passed back to
+		 * us without being accounted for in the
+		 * journal. Extend our transaction here to be sure we
+		 * can change those blocks.
+		 */
+		credits += left_path->p_tree_depth;
+
+		ret = ocfs2_extend_trans(handle, credits);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		ret = ocfs2_journal_access_path(inode, handle, left_path);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+	if (insert->ins_split != SPLIT_NONE) {
+		/*
+		 * We could call ocfs2_insert_at_leaf() for some types
+		 * of splits, but it's easier to just let one seperate
+		 * function sort it all out.
+		 */
+		ocfs2_split_record(inode, left_path, right_path,
+				   insert_rec, insert->ins_split);
+	} else
+		ocfs2_insert_at_leaf(insert_rec, path_leaf_el(right_path),
+				     insert, inode);
+
+	ret = ocfs2_journal_dirty(handle, leaf_bh);
+	if (ret)
+		mlog_errno(ret);
+
+	if (left_path) {
+		/*
+		 * The rotate code has indicated that we need to fix
+		 * up portions of the tree after the insert.
+		 *
+		 * XXX: Should we extend the transaction here?
+		 */
+		subtree_index = ocfs2_find_subtree_root(inode, left_path,
+							right_path);
+		ocfs2_complete_edge_insert(inode, handle, left_path,
+					   right_path, subtree_index);
+	}
+
+	ret = 0;
+out:
+	return ret;
+}
+
+static int ocfs2_do_insert_extent(struct inode *inode,
+				  handle_t *handle,
+				  struct buffer_head *di_bh,
+				  struct ocfs2_extent_rec *insert_rec,
+				  struct ocfs2_insert_type *type)
+{
+	int ret, rotate = 0;
+	u32 cpos;
+	struct ocfs2_path *right_path = NULL;
+	struct ocfs2_path *left_path = NULL;
+	struct ocfs2_dinode *di;
+	struct ocfs2_extent_list *el;
+
+	di = (struct ocfs2_dinode *) di_bh->b_data;
+	el = &di->id2.i_list;
+
+	ret = ocfs2_journal_access(handle, inode, di_bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	if (le16_to_cpu(el->l_tree_depth) == 0) {
+		ocfs2_insert_at_leaf(insert_rec, el, type, inode);
+		goto out_update_clusters;
+	}
+
+	right_path = ocfs2_new_inode_path(di_bh);
+	if (!right_path) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	/*
+	 * Determine the path to start with. Rotations need the
+	 * rightmost path, everything else can go directly to the
+	 * target leaf.
+	 */
+	cpos = le32_to_cpu(insert_rec->e_cpos);
+	if (type->ins_appending == APPEND_NONE &&
+	    type->ins_contig == CONTIG_NONE) {
+		rotate = 1;
+		cpos = UINT_MAX;
+	}
+
+	ret = ocfs2_find_path(inode, right_path, cpos);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	/*
+	 * Rotations and appends need special treatment - they modify
+	 * parts of the tree's above them.
+	 *
+	 * Both might pass back a path immediate to the left of the
+	 * one being inserted to. This will be cause
+	 * ocfs2_insert_path() to modify the rightmost records of
+	 * left_path to account for an edge insert.
+	 *
+	 * XXX: When modifying this code, keep in mind that an insert
+	 * can wind up skipping both of these two special cases...
+	 */
+	if (rotate) {
+		ret = ocfs2_rotate_tree_right(inode, handle, type->ins_split,
+					      le32_to_cpu(insert_rec->e_cpos),
+					      right_path, &left_path);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+	} else if (type->ins_appending == APPEND_TAIL
+		   && type->ins_contig != CONTIG_LEFT) {
+		ret = ocfs2_append_rec_to_path(inode, handle, insert_rec,
+					       right_path, &left_path);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+	ret = ocfs2_insert_path(inode, handle, left_path, right_path,
+				insert_rec, type);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+out_update_clusters:
+	if (type->ins_split == SPLIT_NONE)
+		ocfs2_update_dinode_clusters(inode, di,
+					     le16_to_cpu(insert_rec->e_leaf_clusters));
+
+	ret = ocfs2_journal_dirty(handle, di_bh);
+	if (ret)
+		mlog_errno(ret);
+
+out:
+	ocfs2_free_path(left_path);
+	ocfs2_free_path(right_path);
+
+	return ret;
+}
+
+static enum ocfs2_contig_type
+ocfs2_figure_merge_contig_type(struct inode *inode,
+			       struct ocfs2_extent_list *el, int index,
+			       struct ocfs2_extent_rec *split_rec)
+{
+	struct ocfs2_extent_rec *rec;
+	enum ocfs2_contig_type ret = CONTIG_NONE;
+
+	/*
+	 * We're careful to check for an empty extent record here -
+	 * the merge code will know what to do if it sees one.
+	 */
+
+	if (index > 0) {
+		rec = &el->l_recs[index - 1];
+		if (index == 1 && ocfs2_is_empty_extent(rec)) {
+			if (split_rec->e_cpos == el->l_recs[index].e_cpos)
+				ret = CONTIG_RIGHT;
+		} else {
+			ret = ocfs2_extent_contig(inode, rec, split_rec);
+		}
+	}
+
+	if (index < (le16_to_cpu(el->l_next_free_rec) - 1)) {
+		enum ocfs2_contig_type contig_type;
+
+		rec = &el->l_recs[index + 1];
+		contig_type = ocfs2_extent_contig(inode, rec, split_rec);
+
+		if (contig_type == CONTIG_LEFT && ret == CONTIG_RIGHT)
+			ret = CONTIG_LEFTRIGHT;
+		else if (ret == CONTIG_NONE)
+			ret = contig_type;
+	}
+
+	return ret;
+}
+
+static void ocfs2_figure_contig_type(struct inode *inode,
+				     struct ocfs2_insert_type *insert,
+				     struct ocfs2_extent_list *el,
+				     struct ocfs2_extent_rec *insert_rec)
+{
+	int i;
+	enum ocfs2_contig_type contig_type = CONTIG_NONE;
+
+	BUG_ON(le16_to_cpu(el->l_tree_depth) != 0);
+
+	for(i = 0; i < le16_to_cpu(el->l_next_free_rec); i++) {
+		contig_type = ocfs2_extent_contig(inode, &el->l_recs[i],
+						  insert_rec);
+		if (contig_type != CONTIG_NONE) {
+			insert->ins_contig_index = i;
+			break;
+		}
+	}
+	insert->ins_contig = contig_type;
+}
+
+/*
+ * This should only be called against the righmost leaf extent list.
+ *
+ * ocfs2_figure_appending_type() will figure out whether we'll have to
+ * insert at the tail of the rightmost leaf.
+ *
+ * This should also work against the dinode list for tree's with 0
+ * depth. If we consider the dinode list to be the rightmost leaf node
+ * then the logic here makes sense.
+ */
+static void ocfs2_figure_appending_type(struct ocfs2_insert_type *insert,
+					struct ocfs2_extent_list *el,
+					struct ocfs2_extent_rec *insert_rec)
+{
+	int i;
+	u32 cpos = le32_to_cpu(insert_rec->e_cpos);
+	struct ocfs2_extent_rec *rec;
+
+	insert->ins_appending = APPEND_NONE;
+
+	BUG_ON(le16_to_cpu(el->l_tree_depth) != 0);
+
+	if (!el->l_next_free_rec)
+		goto set_tail_append;
+
+	if (ocfs2_is_empty_extent(&el->l_recs[0])) {
+		/* Were all records empty? */
+		if (le16_to_cpu(el->l_next_free_rec) == 1)
+			goto set_tail_append;
+	}
+
+	i = le16_to_cpu(el->l_next_free_rec) - 1;
+	rec = &el->l_recs[i];
+
+	if (cpos >=
+	    (le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)))
+		goto set_tail_append;
+
+	return;
+
+set_tail_append:
+	insert->ins_appending = APPEND_TAIL;
+}
+
+/*
+ * Helper function called at the begining of an insert.
+ *
+ * This computes a few things that are commonly used in the process of
+ * inserting into the btree:
+ *   - Whether the new extent is contiguous with an existing one.
+ *   - The current tree depth.
+ *   - Whether the insert is an appending one.
+ *   - The total # of free records in the tree.
+ *
+ * All of the information is stored on the ocfs2_insert_type
+ * structure.
+ */
+static int ocfs2_figure_insert_type(struct inode *inode,
+				    struct buffer_head *di_bh,
+				    struct buffer_head **last_eb_bh,
+				    struct ocfs2_extent_rec *insert_rec,
+				    struct ocfs2_insert_type *insert)
+{
+	int ret;
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
+	struct ocfs2_extent_block *eb;
+	struct ocfs2_extent_list *el;
+	struct ocfs2_path *path = NULL;
+	struct buffer_head *bh = NULL;
+
+	insert->ins_split = SPLIT_NONE;
+
+	el = &di->id2.i_list;
+	insert->ins_tree_depth = le16_to_cpu(el->l_tree_depth);
+
+	if (el->l_tree_depth) {
+		/*
+		 * If we have tree depth, we read in the
+		 * rightmost extent block ahead of time as
+		 * ocfs2_figure_insert_type() and ocfs2_add_branch()
+		 * may want it later.
+		 */
+		ret = ocfs2_read_block(OCFS2_SB(inode->i_sb),
+				       le64_to_cpu(di->i_last_eb_blk), &bh,
+				       OCFS2_BH_CACHED, inode);
+		if (ret) {
+			mlog_exit(ret);
+			goto out;
+		}
+		eb = (struct ocfs2_extent_block *) bh->b_data;
+		el = &eb->h_list;
+	}
+
+	/*
+	 * Unless we have a contiguous insert, we'll need to know if
+	 * there is room left in our allocation tree for another
+	 * extent record.
+	 *
+	 * XXX: This test is simplistic, we can search for empty
+	 * extent records too.
+	 */
+	insert->ins_free_records = le16_to_cpu(el->l_count) -
+		le16_to_cpu(el->l_next_free_rec);
+
+	if (!insert->ins_tree_depth) {
+		ocfs2_figure_contig_type(inode, insert, el, insert_rec);
+		ocfs2_figure_appending_type(insert, el, insert_rec);
+		return 0;
+	}
+
+	path = ocfs2_new_inode_path(di_bh);
+	if (!path) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	/*
+	 * In the case that we're inserting past what the tree
+	 * currently accounts for, ocfs2_find_path() will return for
+	 * us the rightmost tree path. This is accounted for below in
+	 * the appending code.
+	 */
+	ret = ocfs2_find_path(inode, path, le32_to_cpu(insert_rec->e_cpos));
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	el = path_leaf_el(path);
+
+	/*
+	 * Now that we have the path, there's two things we want to determine:
+	 * 1) Contiguousness (also set contig_index if this is so)
+	 *
+	 * 2) Are we doing an append? We can trivially break this up
+         *     into two types of appends: simple record append, or a
+         *     rotate inside the tail leaf.
+	 */
@@ -2290,7 +3689,193 @@
-	/*
-	 * Ok, so we can simply compare against last_eb to figure out
-	 * whether the path doesn't exist. This will only happen in
-	 * the case that we're doing a tail append, so maybe we can
-	 * take advantage of that information somehow.
-	 */
-	if (le64_to_cpu(di->i_last_eb_blk) == path_leaf_bh(path)->b_blocknr) {
+	/*
+	 * Ok, so we can simply compare against last_eb to figure out
+	 * whether the path doesn't exist. This will only happen in
+	 * the case that we're doing a tail append, so maybe we can
+	 * take advantage of that information somehow.
+	 */
+	if (le64_to_cpu(di->i_last_eb_blk) == path_leaf_bh(path)->b_blocknr) {
+		/*
+		 * Ok, ocfs2_find_path() returned us the rightmost
+		 * tree path. This might be an appending insert. There are
+		 * two cases:
+		 *    1) We're doing a true append at the tail:
+		 *	-This might even be off the end of the leaf
+		 *    2) We're "appending" by rotating in the tail
+		 */
+		ocfs2_figure_appending_type(insert, el, insert_rec);
+	}
+
+out:
+	ocfs2_free_path(path);
+
+	if (ret == 0)
+		*last_eb_bh = bh;
+	else
+		brelse(bh);
+	return ret;
+}
+
+/*
+ * Insert an extent into an inode btree.
+ *
+ * The caller needs to update fe->i_clusters
+ */
+int ocfs2_insert_extent(struct ocfs2_super *osb,
+			handle_t *handle,
+			struct inode *inode,
+			struct buffer_head *fe_bh,
+			u32 cpos,
+			u64 start_blk,
+			u32 new_clusters,
+			u8 flags,
+			struct ocfs2_alloc_context *meta_ac)
+{
+	int status;
+	struct buffer_head *last_eb_bh = NULL;
+	struct ocfs2_insert_type insert = {0, };
+	struct ocfs2_extent_rec rec;
+
+	mlog(0, "add %u clusters at position %u to inode %llu\n",
+	     new_clusters, cpos, (unsigned long long)OCFS2_I(inode)->ip_blkno);
+
+	mlog_bug_on_msg(!ocfs2_sparse_alloc(osb) &&
+			(OCFS2_I(inode)->ip_clusters != cpos),
+			"Device %s, asking for sparse allocation: inode %llu, "
+			"cpos %u, clusters %u\n",
+			osb->dev_str,
+			(unsigned long long)OCFS2_I(inode)->ip_blkno, cpos,
+			OCFS2_I(inode)->ip_clusters);
+
+	memset(&rec, 0, sizeof(rec));
+	rec.e_cpos = cpu_to_le32(cpos);
+	rec.e_blkno = cpu_to_le64(start_blk);
+	rec.e_leaf_clusters = cpu_to_le16(new_clusters);
+	rec.e_flags = flags;
+
+	status = ocfs2_figure_insert_type(inode, fe_bh, &last_eb_bh, &rec,
+					  &insert);
+	if (status < 0) {
+		mlog_errno(status);
+		goto bail;
+	}
+
+	mlog(0, "Insert.appending: %u, Insert.Contig: %u, "
+	     "Insert.contig_index: %d, Insert.free_records: %d, "
+	     "Insert.tree_depth: %d\n",
+	     insert.ins_appending, insert.ins_contig, insert.ins_contig_index,
+	     insert.ins_free_records, insert.ins_tree_depth);
+
+	if (insert.ins_contig == CONTIG_NONE && insert.ins_free_records == 0) {
+		status = ocfs2_grow_tree(inode, handle, fe_bh,
+					 &insert.ins_tree_depth, &last_eb_bh,
+					 meta_ac);
+		if (status) {
+			mlog_errno(status);
+			goto bail;
+		}
+	}
+
+	/* Finally, we can add clusters. This might rotate the tree for us. */
+	status = ocfs2_do_insert_extent(inode, handle, fe_bh, &rec, &insert);
+	if (status < 0)
+		mlog_errno(status);
+	else
+		ocfs2_extent_map_insert_rec(inode, &rec);
+
+bail:
+	if (last_eb_bh)
+		brelse(last_eb_bh);
+
+	mlog_exit(status);
+	return status;
+}
+
+static void ocfs2_make_right_split_rec(struct super_block *sb,
+				       struct ocfs2_extent_rec *split_rec,
+				       u32 cpos,
+				       struct ocfs2_extent_rec *rec)
+{
+	u32 rec_cpos = le32_to_cpu(rec->e_cpos);
+	u32 rec_range = rec_cpos + le16_to_cpu(rec->e_leaf_clusters);
+
+	memset(split_rec, 0, sizeof(struct ocfs2_extent_rec));
+
+	split_rec->e_cpos = cpu_to_le32(cpos);
+	split_rec->e_leaf_clusters = cpu_to_le16(rec_range - cpos);
+
+	split_rec->e_blkno = rec->e_blkno;
+	le64_add_cpu(&split_rec->e_blkno,
+		     ocfs2_clusters_to_blocks(sb, cpos - rec_cpos));
+
+	split_rec->e_flags = rec->e_flags;
+}
+
+static int ocfs2_split_and_insert(struct inode *inode,
+				  handle_t *handle,
+				  struct ocfs2_path *path,
+				  struct buffer_head *di_bh,
+				  struct buffer_head **last_eb_bh,
+				  int split_index,
+				  struct ocfs2_extent_rec *orig_split_rec,
+				  struct ocfs2_alloc_context *meta_ac)
+{
+	int ret = 0, depth;
+	unsigned int insert_range, rec_range, do_leftright = 0;
+	struct ocfs2_extent_rec tmprec;
+	struct ocfs2_extent_list *rightmost_el;
+	struct ocfs2_extent_rec rec;
+	struct ocfs2_extent_rec split_rec = *orig_split_rec;
+	struct ocfs2_insert_type insert;
+	struct ocfs2_extent_block *eb;
+	struct ocfs2_dinode *di;
+
+leftright:
+	/*
+	 * Store a copy of the record on the stack - it might move
+	 * around as the tree is manipulated below.
+	 */
+	rec = path_leaf_el(path)->l_recs[split_index];
+
+	di = (struct ocfs2_dinode *)di_bh->b_data;
+	rightmost_el = &di->id2.i_list;
+
+	depth = le16_to_cpu(rightmost_el->l_tree_depth);
+	if (depth) {
+		BUG_ON(!(*last_eb_bh));
+		eb = (struct ocfs2_extent_block *) (*last_eb_bh)->b_data;
+		rightmost_el = &eb->h_list;
+	}
+
+	if (le16_to_cpu(rightmost_el->l_next_free_rec) ==
+	    le16_to_cpu(rightmost_el->l_count)) {
+		int old_depth = depth;
+
+		ret = ocfs2_grow_tree(inode, handle, di_bh, &depth, last_eb_bh,
+				      meta_ac);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		if (old_depth != depth) {
+			eb = (struct ocfs2_extent_block *)(*last_eb_bh)->b_data;
+			rightmost_el = &eb->h_list;
+		}
+	}
+
+	memset(&insert, 0, sizeof(struct ocfs2_insert_type));
+	insert.ins_appending = APPEND_NONE;
+	insert.ins_contig = CONTIG_NONE;
+	insert.ins_free_records = le16_to_cpu(rightmost_el->l_count)
+		- le16_to_cpu(rightmost_el->l_next_free_rec);
+	insert.ins_tree_depth = depth;
+
+	insert_range = le32_to_cpu(split_rec.e_cpos) +
+		le16_to_cpu(split_rec.e_leaf_clusters);
+	rec_range = le32_to_cpu(rec.e_cpos) +
+		le16_to_cpu(rec.e_leaf_clusters);
+
+	if (split_rec.e_cpos == rec.e_cpos) {
+		insert.ins_split = SPLIT_LEFT;
+	} else if (insert_range == rec_range) {
+		insert.ins_split = SPLIT_RIGHT;
+	} else {
@@ -2298,6 +3883,2 @@
-		 * Ok, ocfs2_find_path() returned us the rightmost
-		 * tree path. This might be an appending insert. There are
-		 * two cases:
-		 *    1) We're doing a true append at the tail:
-		 *	-This might even be off the end of the leaf
-		 *    2) We're "appending" by rotating in the tail
+		 * Left/right split. We fake this as a right split
+		 * first and then make a second pass as a left split.
@@ -2305 +3886,16 @@
-		ocfs2_figure_appending_type(insert, el, insert_rec);
+		insert.ins_split = SPLIT_RIGHT;
+
+		ocfs2_make_right_split_rec(inode->i_sb, &tmprec, insert_range,
+					   &rec);
+
+		split_rec = tmprec;
+
+		BUG_ON(do_leftright);
+		do_leftright = 1;
+	}
+
+	ret = ocfs2_do_insert_extent(inode, handle, di_bh, &split_rec,
+				     &insert);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
@@ -2307,0 +3904,20 @@
+	if (do_leftright == 1) {
+		u32 cpos;
+		struct ocfs2_extent_list *el;
+
+		do_leftright++;
+		split_rec = *orig_split_rec;
+
+		ocfs2_reinit_path(path, 1);
+
+		cpos = le32_to_cpu(split_rec.e_cpos);
+		ret = ocfs2_find_path(inode, path, cpos);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		el = path_leaf_el(path);
+		split_index = ocfs2_search_extent_list(el, cpos);
+		goto leftright;
+	}
@@ -2309 +3924,0 @@
-	ocfs2_free_path(path);
@@ -2311,2 +3926,100 @@
-	if (ret == 0)
-		*last_eb_bh = bh;
+	return ret;
+}
+
+/*
+ * Mark part or all of the extent record at split_index in the leaf
+ * pointed to by path as written. This removes the unwritten
+ * extent flag.
+ *
+ * Care is taken to handle contiguousness so as to not grow the tree.
+ *
+ * meta_ac is not strictly necessary - we only truly need it if growth
+ * of the tree is required. All other cases will degrade into a less
+ * optimal tree layout.
+ *
+ * last_eb_bh should be the rightmost leaf block for any inode with a
+ * btree. Since a split may grow the tree or a merge might shrink it, the caller cannot trust the contents of that buffer after this call.
+ *
+ * This code is optimized for readability - several passes might be
+ * made over certain portions of the tree. All of those blocks will
+ * have been brought into cache (and pinned via the journal), so the
+ * extra overhead is not expressed in terms of disk reads.
+ */
+static int __ocfs2_mark_extent_written(struct inode *inode,
+				       struct buffer_head *di_bh,
+				       handle_t *handle,
+				       struct ocfs2_path *path,
+				       int split_index,
+				       struct ocfs2_extent_rec *split_rec,
+				       struct ocfs2_alloc_context *meta_ac,
+				       struct ocfs2_cached_dealloc_ctxt *dealloc)
+{
+	int ret = 0;
+	struct ocfs2_extent_list *el = path_leaf_el(path);
+	struct buffer_head *eb_bh, *last_eb_bh = NULL;
+	struct ocfs2_extent_rec *rec = &el->l_recs[split_index];
+	struct ocfs2_merge_ctxt ctxt;
+	struct ocfs2_extent_list *rightmost_el;
+
+	if (!rec->e_flags & OCFS2_EXT_UNWRITTEN) {
+		ret = -EIO;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	if (le32_to_cpu(rec->e_cpos) > le32_to_cpu(split_rec->e_cpos) ||
+	    ((le32_to_cpu(rec->e_cpos) + le16_to_cpu(rec->e_leaf_clusters)) <
+	     (le32_to_cpu(split_rec->e_cpos) + le16_to_cpu(split_rec->e_leaf_clusters)))) {
+		ret = -EIO;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	eb_bh = path_leaf_bh(path);
+	ret = ocfs2_journal_access(handle, inode, eb_bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ctxt.c_contig_type = ocfs2_figure_merge_contig_type(inode, el,
+							    split_index,
+							    split_rec);
+
+	/*
+	 * The core merge / split code wants to know how much room is
+	 * left in this inodes allocation tree, so we pass the
+	 * rightmost extent list.
+	 */
+	if (path->p_tree_depth) {
+		struct ocfs2_extent_block *eb;
+		struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
+
+		ret = ocfs2_read_block(OCFS2_SB(inode->i_sb),
+				       le64_to_cpu(di->i_last_eb_blk),
+				       &last_eb_bh, OCFS2_BH_CACHED, inode);
+		if (ret) {
+			mlog_exit(ret);
+			goto out;
+		}
+
+		eb = (struct ocfs2_extent_block *) last_eb_bh->b_data;
+		if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
+			OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
+			ret = -EROFS;
+			goto out;
+		}
+
+		rightmost_el = &eb->h_list;
+	} else
+		rightmost_el = path_root_el(path);
+
+	ctxt.c_used_tail_recs = le16_to_cpu(rightmost_el->l_next_free_rec);
+	if (ctxt.c_used_tail_recs > 0 &&
+	    ocfs2_is_empty_extent(&rightmost_el->l_recs[0]))
+		ctxt.c_used_tail_recs--;
+
+	if (rec->e_cpos == split_rec->e_cpos &&
+	    rec->e_leaf_clusters == split_rec->e_leaf_clusters)
+		ctxt.c_split_covers_rec = 1;
@@ -2314 +4027,30 @@
-		brelse(bh);
+		ctxt.c_split_covers_rec = 0;
+
+	ctxt.c_has_empty_extent = ocfs2_is_empty_extent(&el->l_recs[0]);
+
+	mlog(0, "index: %d, contig: %u, used_tail_recs: %u, "
+	     "has_empty: %u, split_covers: %u\n", split_index,
+	     ctxt.c_contig_type, ctxt.c_used_tail_recs,
+	     ctxt.c_has_empty_extent, ctxt.c_split_covers_rec);
+
+	if (ctxt.c_contig_type == CONTIG_NONE) {
+		if (ctxt.c_split_covers_rec)
+			el->l_recs[split_index] = *split_rec;
+		else
+			ret = ocfs2_split_and_insert(inode, handle, path, di_bh,
+						     &last_eb_bh, split_index,
+						     split_rec, meta_ac);
+		if (ret)
+			mlog_errno(ret);
+	} else {
+		ret = ocfs2_try_to_merge_extent(inode, handle, path,
+						split_index, split_rec,
+						dealloc, &ctxt);
+		if (ret)
+			mlog_errno(ret);
+	}
+
+	ocfs2_journal_dirty(handle, eb_bh);
+
+out:
+	brelse(last_eb_bh);
@@ -2319 +4061 @@
- * Insert an extent into an inode btree.
+ * Mark the already-existing extent at cpos as written for len clusters.
@@ -2321 +4063,4 @@
- * The caller needs to update fe->i_clusters
+ * If the existing extent is larger than the request, initiate a
+ * split. An attempt will be made at merging with adjacent extents.
+ *
+ * The caller is responsible for passing down meta_ac if we'll need it.
@@ -2323,8 +4068,74 @@
-int ocfs2_insert_extent(struct ocfs2_super *osb,
-			handle_t *handle,
-			struct inode *inode,
-			struct buffer_head *fe_bh,
-			u32 cpos,
-			u64 start_blk,
-			u32 new_clusters,
-			struct ocfs2_alloc_context *meta_ac)
+int ocfs2_mark_extent_written(struct inode *inode, struct buffer_head *di_bh,
+			      handle_t *handle, u32 cpos, u32 len, u32 phys,
+			      struct ocfs2_alloc_context *meta_ac,
+			      struct ocfs2_cached_dealloc_ctxt *dealloc)
+{
+	int ret, index;
+	u64 start_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys);
+	struct ocfs2_extent_rec split_rec;
+	struct ocfs2_path *left_path = NULL;
+	struct ocfs2_extent_list *el;
+
+	mlog(0, "Inode %lu cpos %u, len %u, phys %u (%llu)\n",
+	     inode->i_ino, cpos, len, phys, (unsigned long long)start_blkno);
+
+	if (!ocfs2_writes_unwritten_extents(OCFS2_SB(inode->i_sb))) {
+		ocfs2_error(inode->i_sb, "Inode %llu has unwritten extents "
+			    "that are being written to, but the feature bit "
+			    "is not set in the super block.",
+			    (unsigned long long)OCFS2_I(inode)->ip_blkno);
+		ret = -EROFS;
+		goto out;
+	}
+
+	/*
+	 * XXX: This should be fixed up so that we just re-insert the
+	 * next extent records.
+	 */
+	ocfs2_extent_map_trunc(inode, 0);
+
+	left_path = ocfs2_new_inode_path(di_bh);
+	if (!left_path) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ret = ocfs2_find_path(inode, left_path, cpos);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+	el = path_leaf_el(left_path);
+
+	index = ocfs2_search_extent_list(el, cpos);
+	if (index == -1 || index >= le16_to_cpu(el->l_next_free_rec)) {
+		ocfs2_error(inode->i_sb,
+			    "Inode %llu has an extent at cpos %u which can no "
+			    "longer be found.\n",
+			    (unsigned long long)OCFS2_I(inode)->ip_blkno, cpos);
+		ret = -EROFS;
+		goto out;
+	}
+
+	memset(&split_rec, 0, sizeof(struct ocfs2_extent_rec));
+	split_rec.e_cpos = cpu_to_le32(cpos);
+	split_rec.e_leaf_clusters = cpu_to_le16(len);
+	split_rec.e_blkno = cpu_to_le64(start_blkno);
+	split_rec.e_flags = path_leaf_el(left_path)->l_recs[index].e_flags;
+	split_rec.e_flags &= ~OCFS2_EXT_UNWRITTEN;
+
+	ret = __ocfs2_mark_extent_written(inode, di_bh, handle, left_path,
+					  index, &split_rec, meta_ac, dealloc);
+	if (ret)
+		mlog_errno(ret);
+
+out:
+	ocfs2_free_path(left_path);
+	return ret;
+}
+
+static int ocfs2_split_tree(struct inode *inode, struct buffer_head *di_bh,
+			    handle_t *handle, struct ocfs2_path *path,
+			    int index, u32 new_range,
+			    struct ocfs2_alloc_context *meta_ac)
@@ -2332 +4143,2 @@
-	int status, shift;
+	int ret, depth, credits = handle->h_buffer_credits;
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
@@ -2334,3 +4146,225 @@
-	struct buffer_head *bh = NULL;
-	struct ocfs2_insert_type insert = {0, };
-	struct ocfs2_extent_rec rec;
+	struct ocfs2_extent_block *eb;
+	struct ocfs2_extent_list *rightmost_el, *el;
+	struct ocfs2_extent_rec split_rec;
+	struct ocfs2_extent_rec *rec;
+	struct ocfs2_insert_type insert;
+
+	/*
+	 * Setup the record to split before we grow the tree.
+	 */
+	el = path_leaf_el(path);
+	rec = &el->l_recs[index];
+	ocfs2_make_right_split_rec(inode->i_sb, &split_rec, new_range, rec);
+
+	depth = path->p_tree_depth;
+	if (depth > 0) {
+		ret = ocfs2_read_block(OCFS2_SB(inode->i_sb),
+				       le64_to_cpu(di->i_last_eb_blk),
+				       &last_eb_bh, OCFS2_BH_CACHED, inode);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		eb = (struct ocfs2_extent_block *) last_eb_bh->b_data;
+		rightmost_el = &eb->h_list;
+	} else
+		rightmost_el = path_leaf_el(path);
+
+	credits += path->p_tree_depth + ocfs2_extend_meta_needed(di);
+	ret = ocfs2_extend_trans(handle, credits);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	if (le16_to_cpu(rightmost_el->l_next_free_rec) ==
+	    le16_to_cpu(rightmost_el->l_count)) {
+		int old_depth = depth;
+
+		ret = ocfs2_grow_tree(inode, handle, di_bh, &depth, &last_eb_bh,
+				      meta_ac);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		if (old_depth != depth) {
+			eb = (struct ocfs2_extent_block *)last_eb_bh->b_data;
+			rightmost_el = &eb->h_list;
+		}
+	}
+
+	memset(&insert, 0, sizeof(struct ocfs2_insert_type));
+	insert.ins_appending = APPEND_NONE;
+	insert.ins_contig = CONTIG_NONE;
+	insert.ins_split = SPLIT_RIGHT;
+	insert.ins_free_records = le16_to_cpu(rightmost_el->l_count)
+		- le16_to_cpu(rightmost_el->l_next_free_rec);
+	insert.ins_tree_depth = depth;
+
+	ret = ocfs2_do_insert_extent(inode, handle, di_bh, &split_rec, &insert);
+	if (ret)
+		mlog_errno(ret);
+
+out:
+	brelse(last_eb_bh);
+	return ret;
+}
+
+static int ocfs2_truncate_rec(struct inode *inode, handle_t *handle,
+			      struct ocfs2_path *path, int index,
+			      struct ocfs2_cached_dealloc_ctxt *dealloc,
+			      u32 cpos, u32 len)
+{
+	int ret;
+	u32 left_cpos, rec_range, trunc_range;
+	int wants_rotate = 0, is_rightmost_tree_rec = 0;
+	struct super_block *sb = inode->i_sb;
+	struct ocfs2_path *left_path = NULL;
+	struct ocfs2_extent_list *el = path_leaf_el(path);
+	struct ocfs2_extent_rec *rec;
+	struct ocfs2_extent_block *eb;
+
+	if (ocfs2_is_empty_extent(&el->l_recs[0]) && index > 0) {
+		ret = ocfs2_rotate_tree_left(inode, handle, path, dealloc);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		index--;
+	}
+
+	if (index == (le16_to_cpu(el->l_next_free_rec) - 1) &&
+	    path->p_tree_depth) {
+		/*
+		 * Check whether this is the rightmost tree record. If
+		 * we remove all of this record or part of its right
+		 * edge then an update of the record lengths above it
+		 * will be required.
+		 */
+		eb = (struct ocfs2_extent_block *)path_leaf_bh(path)->b_data;
+		if (eb->h_next_leaf_blk == 0)
+			is_rightmost_tree_rec = 1;
+	}
+
+	rec = &el->l_recs[index];
+	if (index == 0 && path->p_tree_depth &&
+	    le32_to_cpu(rec->e_cpos) == cpos) {
+		/*
+		 * Changing the leftmost offset (via partial or whole
+		 * record truncate) of an interior (or rightmost) path
+		 * means we have to update the subtree that is formed
+		 * by this leaf and the one to it's left.
+		 *
+		 * There are two cases we can skip:
+		 *   1) Path is the leftmost one in our inode tree.
+		 *   2) The leaf is rightmost and will be empty after
+		 *      we remove the extent record - the rotate code
+		 *      knows how to update the newly formed edge.
+		 */
+
+		ret = ocfs2_find_cpos_for_left_leaf(inode->i_sb, path,
+						    &left_cpos);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		if (left_cpos && le16_to_cpu(el->l_next_free_rec) > 1) {
+			left_path = ocfs2_new_path(path_root_bh(path),
+						   path_root_el(path));
+			if (!left_path) {
+				ret = -ENOMEM;
+				mlog_errno(ret);
+				goto out;
+			}
+
+			ret = ocfs2_find_path(inode, left_path, left_cpos);
+			if (ret) {
+				mlog_errno(ret);
+				goto out;
+			}
+		}
+	}
+
+	ret = ocfs2_extend_rotate_transaction(handle, 0,
+					      handle->h_buffer_credits,
+					      path);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ret = ocfs2_journal_access_path(inode, handle, path);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ret = ocfs2_journal_access_path(inode, handle, left_path);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	rec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);
+	trunc_range = cpos + len;
+
+	if (le32_to_cpu(rec->e_cpos) == cpos && rec_range == trunc_range) {
+		int next_free;
+
+		memset(rec, 0, sizeof(*rec));
+		ocfs2_cleanup_merge(el, index);
+		wants_rotate = 1;
+
+		next_free = le16_to_cpu(el->l_next_free_rec);
+		if (is_rightmost_tree_rec && next_free > 1) {
+			/*
+			 * We skip the edge update if this path will
+			 * be deleted by the rotate code.
+			 */
+			rec = &el->l_recs[next_free - 1];
+			ocfs2_adjust_rightmost_records(inode, handle, path,
+						       rec);
+		}
+	} else if (le32_to_cpu(rec->e_cpos) == cpos) {
+		/* Remove leftmost portion of the record. */
+		le32_add_cpu(&rec->e_cpos, len);
+		le64_add_cpu(&rec->e_blkno, ocfs2_clusters_to_blocks(sb, len));
+		le16_add_cpu(&rec->e_leaf_clusters, -len);
+	} else if (rec_range == trunc_range) {
+		/* Remove rightmost portion of the record */
+		le16_add_cpu(&rec->e_leaf_clusters, -len);
+		if (is_rightmost_tree_rec)
+			ocfs2_adjust_rightmost_records(inode, handle, path, rec);
+	} else {
+		/* Caller should have trapped this. */
+		mlog(ML_ERROR, "Inode %llu: Invalid record truncate: (%u, %u) "
+		     "(%u, %u)\n", (unsigned long long)OCFS2_I(inode)->ip_blkno,
+		     le32_to_cpu(rec->e_cpos),
+		     le16_to_cpu(rec->e_leaf_clusters), cpos, len);
+		BUG();
+	}
+
+	if (left_path) {
+		int subtree_index;
+
+		subtree_index = ocfs2_find_subtree_root(inode, left_path, path);
+		ocfs2_complete_edge_insert(inode, handle, left_path, path,
+					   subtree_index);
+	}
+
+	ocfs2_journal_dirty(handle, path_leaf_bh(path));
+
+	ret = ocfs2_rotate_tree_left(inode, handle, path, dealloc);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+out:
+	ocfs2_free_path(left_path);
+	return ret;
+}
@@ -2338,2 +4372,10 @@
-	mlog(0, "add %u clusters at position %u to inode %llu\n",
-	     new_clusters, cpos, (unsigned long long)OCFS2_I(inode)->ip_blkno);
+int ocfs2_remove_extent(struct inode *inode, struct buffer_head *di_bh,
+			u32 cpos, u32 len, handle_t *handle,
+			struct ocfs2_alloc_context *meta_ac,
+			struct ocfs2_cached_dealloc_ctxt *dealloc)
+{
+	int ret, index;
+	u32 rec_range, trunc_range;
+	struct ocfs2_extent_rec *rec;
+	struct ocfs2_extent_list *el;
+	struct ocfs2_path *path;
@@ -2341,7 +4383 @@
-	mlog_bug_on_msg(!ocfs2_sparse_alloc(osb) &&
-			(OCFS2_I(inode)->ip_clusters != cpos),
-			"Device %s, asking for sparse allocation: inode %llu, "
-			"cpos %u, clusters %u\n",
-			osb->dev_str,
-			(unsigned long long)OCFS2_I(inode)->ip_blkno, cpos,
-			OCFS2_I(inode)->ip_clusters);
+	ocfs2_extent_map_trunc(inode, 0);
@@ -2349,4 +4385,6 @@
-	memset(&rec, 0, sizeof(rec));
-	rec.e_cpos = cpu_to_le32(cpos);
-	rec.e_blkno = cpu_to_le64(start_blk);
-	rec.e_leaf_clusters = cpu_to_le16(new_clusters);
+	path = ocfs2_new_inode_path(di_bh);
+	if (!path) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
+	}
@@ -2354,5 +4392,4 @@
-	status = ocfs2_figure_insert_type(inode, fe_bh, &last_eb_bh, &rec,
-					  &insert);
-	if (status < 0) {
-		mlog_errno(status);
-		goto bail;
+	ret = ocfs2_find_path(inode, path, cpos);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
@@ -2361,5 +4398,10 @@
-	mlog(0, "Insert.appending: %u, Insert.Contig: %u, "
-	     "Insert.contig_index: %d, Insert.free_records: %d, "
-	     "Insert.tree_depth: %d\n",
-	     insert.ins_appending, insert.ins_contig, insert.ins_contig_index,
-	     insert.ins_free_records, insert.ins_tree_depth);
+	el = path_leaf_el(path);
+	index = ocfs2_search_extent_list(el, cpos);
+	if (index == -1 || index >= le16_to_cpu(el->l_next_free_rec)) {
+		ocfs2_error(inode->i_sb,
+			    "Inode %llu has an extent at cpos %u which can no "
+			    "longer be found.\n",
+			    (unsigned long long)OCFS2_I(inode)->ip_blkno, cpos);
+		ret = -EROFS;
+		goto out;
+	}
@@ -2368,2 +4410,14 @@
-	 * Avoid growing the tree unless we're out of records and the
-	 * insert type requres one.
+	 * We have 3 cases of extent removal:
+	 *   1) Range covers the entire extent rec
+	 *   2) Range begins or ends on one edge of the extent rec
+	 *   3) Range is in the middle of the extent rec (no shared edges)
+	 *
+	 * For case 1 we remove the extent rec and left rotate to
+	 * fill the hole.
+	 *
+	 * For case 2 we just shrink the existing extent rec, with a
+	 * tree update if the shrinking edge is also the edge of an
+	 * extent block.
+	 *
+	 * For case 3 we do a right split to turn the extent rec into
+	 * something case 2 can handle.
@@ -2371,9 +4425,25 @@
-	if (insert.ins_contig != CONTIG_NONE || insert.ins_free_records)
-		goto out_add;
-
-	shift = ocfs2_find_branch_target(osb, inode, fe_bh, &bh);
-	if (shift < 0) {
-		status = shift;
-		mlog_errno(status);
-		goto bail;
-	}
+	rec = &el->l_recs[index];
+	rec_range = le32_to_cpu(rec->e_cpos) + ocfs2_rec_clusters(el, rec);
+	trunc_range = cpos + len;
+
+	BUG_ON(cpos < le32_to_cpu(rec->e_cpos) || trunc_range > rec_range);
+
+	mlog(0, "Inode %llu, remove (cpos %u, len %u). Existing index %d "
+	     "(cpos %u, len %u)\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno, cpos, len, index,
+	     le32_to_cpu(rec->e_cpos), ocfs2_rec_clusters(el, rec));
+
+	if (le32_to_cpu(rec->e_cpos) == cpos || rec_range == trunc_range) {
+		ret = ocfs2_truncate_rec(inode, handle, path, index, dealloc,
+					 cpos, len);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+	} else {
+		ret = ocfs2_split_tree(inode, di_bh, handle, path, index,
+				       trunc_range, meta_ac);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
@@ -2381,7 +4451,5 @@
-	/* We traveled all the way to the bottom of the allocation tree
-	 * and didn't find room for any more extents - we need to add
-	 * another tree level */
-	if (shift) {
-		BUG_ON(bh);
-		mlog(0, "need to shift tree depth "
-		     "(current = %d)\n", insert.ins_tree_depth);
+		/*
+		 * The split could have manipulated the tree enough to
+		 * move the record location, so we have to look for it again.
+		 */
+		ocfs2_reinit_path(path, 1);
@@ -2389,8 +4457,4 @@
-		/* ocfs2_shift_tree_depth will return us a buffer with
-		 * the new extent block (so we can pass that to
-		 * ocfs2_add_branch). */
-		status = ocfs2_shift_tree_depth(osb, handle, inode, fe_bh,
-						meta_ac, &bh);
-		if (status < 0) {
-			mlog_errno(status);
-			goto bail;
+		ret = ocfs2_find_path(inode, path, cpos);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
@@ -2398,16 +4461,0 @@
-		insert.ins_tree_depth++;
-		/* Special case: we have room now if we shifted from
-		 * tree_depth 0 */
-		if (insert.ins_tree_depth == 1)
-			goto out_add;
-	}
-
-	/* call ocfs2_add_branch to add the final part of the tree with
-	 * the new data. */
-	mlog(0, "add branch. bh = %p\n", bh);
-	status = ocfs2_add_branch(osb, handle, inode, fe_bh, bh, last_eb_bh,
-				  meta_ac);
-	if (status < 0) {
-		mlog_errno(status);
-		goto bail;
-	}
@@ -2415,7 +4463,10 @@
-out_add:
-	/* Finally, we can add clusters. This might rotate the tree for us. */
-	status = ocfs2_do_insert_extent(inode, handle, fe_bh, &rec, &insert);
-	if (status < 0)
-		mlog_errno(status);
-	else
-		ocfs2_extent_map_insert_rec(inode, &rec);
+		el = path_leaf_el(path);
+		index = ocfs2_search_extent_list(el, cpos);
+		if (index == -1 || index >= le16_to_cpu(el->l_next_free_rec)) {
+			ocfs2_error(inode->i_sb,
+				    "Inode %llu: split at cpos %u lost record.",
+				    (unsigned long long)OCFS2_I(inode)->ip_blkno,
+				    cpos);
+			ret = -EROFS;
+			goto out;
+		}
@@ -2423,3 +4474,17 @@
-bail:
-	if (bh)
-		brelse(bh);
+		/*
+		 * Double check our values here. If anything is fishy,
+		 * it's easier to catch it at the top level.
+		 */
+		rec = &el->l_recs[index];
+		rec_range = le32_to_cpu(rec->e_cpos) +
+			ocfs2_rec_clusters(el, rec);
+		if (rec_range != trunc_range) {
+			ocfs2_error(inode->i_sb,
+				    "Inode %llu: error after split at cpos %u"
+				    "trunc len %u, existing record is (%u,%u)",
+				    (unsigned long long)OCFS2_I(inode)->ip_blkno,
+				    cpos, len, le32_to_cpu(rec->e_cpos),
+				    ocfs2_rec_clusters(el, rec));
+			ret = -EROFS;
+			goto out;
+		}
@@ -2427,2 +4492,7 @@
-	if (last_eb_bh)
-		brelse(last_eb_bh);
+		ret = ocfs2_truncate_rec(inode, handle, path, index, dealloc,
+					 cpos, len);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
@@ -2430,2 +4500,3 @@
-	mlog_exit(status);
-	return status;
+out:
+	ocfs2_free_path(path);
+	return ret;
@@ -2434 +4505 @@
-static inline int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)
+int ocfs2_truncate_log_needs_flush(struct ocfs2_super *osb)
@@ -2467,4 +4538,4 @@
-static int ocfs2_truncate_log_append(struct ocfs2_super *osb,
-				     handle_t *handle,
-				     u64 start_blk,
-				     unsigned int num_clusters)
+int ocfs2_truncate_log_append(struct ocfs2_super *osb,
+			      handle_t *handle,
+			      u64 start_blk,
+			      unsigned int num_clusters)
@@ -2626 +4697 @@
-static int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)
+int __ocfs2_flush_truncate_log(struct ocfs2_super *osb)
@@ -2959,0 +5031,213 @@
+/*
+ * Delayed de-allocation of suballocator blocks.
+ *
+ * Some sets of block de-allocations might involve multiple suballocator inodes.
+ *
+ * The locking for this can get extremely complicated, especially when
+ * the suballocator inodes to delete from aren't known until deep
+ * within an unrelated codepath.
+ *
+ * ocfs2_extent_block structures are a good example of this - an inode
+ * btree could have been grown by any number of nodes each allocating
+ * out of their own suballoc inode.
+ *
+ * These structures allow the delay of block de-allocation until a
+ * later time, when locking of multiple cluster inodes won't cause
+ * deadlock.
+ */
+
+/*
+ * Describes a single block free from a suballocator
+ */
+struct ocfs2_cached_block_free {
+	struct ocfs2_cached_block_free		*free_next;
+	u64					free_blk;
+	unsigned int				free_bit;
+};
+
+struct ocfs2_per_slot_free_list {
+	struct ocfs2_per_slot_free_list		*f_next_suballocator;
+	int					f_inode_type;
+	int					f_slot;
+	struct ocfs2_cached_block_free		*f_first;
+};
+
+static int ocfs2_free_cached_items(struct ocfs2_super *osb,
+				   int sysfile_type,
+				   int slot,
+				   struct ocfs2_cached_block_free *head)
+{
+	int ret;
+	u64 bg_blkno;
+	handle_t *handle;
+	struct inode *inode;
+	struct buffer_head *di_bh = NULL;
+	struct ocfs2_cached_block_free *tmp;
+
+	inode = ocfs2_get_system_file_inode(osb, sysfile_type, slot);
+	if (!inode) {
+		ret = -EINVAL;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	mutex_lock(&inode->i_mutex);
+
+	ret = ocfs2_meta_lock(inode, &di_bh, 1);
+	if (ret) {
+		mlog_errno(ret);
+		goto out_mutex;
+	}
+
+	handle = ocfs2_start_trans(osb, OCFS2_SUBALLOC_FREE);
+	if (IS_ERR(handle)) {
+		ret = PTR_ERR(handle);
+		mlog_errno(ret);
+		goto out_unlock;
+	}
+
+	while (head) {
+		bg_blkno = ocfs2_which_suballoc_group(head->free_blk,
+						      head->free_bit);
+		mlog(0, "Free bit: (bit %u, blkno %llu)\n",
+		     head->free_bit, (unsigned long long)head->free_blk);
+
+		ret = ocfs2_free_suballoc_bits(handle, inode, di_bh,
+					       head->free_bit, bg_blkno, 1);
+		if (ret) {
+			mlog_errno(ret);
+			goto out_journal;
+		}
+
+		ret = ocfs2_extend_trans(handle, OCFS2_SUBALLOC_FREE);
+		if (ret) {
+			mlog_errno(ret);
+			goto out_journal;
+		}
+
+		tmp = head;
+		head = head->free_next;
+		kfree(tmp);
+	}
+
+out_journal:
+	ocfs2_commit_trans(osb, handle);
+
+out_unlock:
+	ocfs2_meta_unlock(inode, 1);
+	brelse(di_bh);
+out_mutex:
+	mutex_unlock(&inode->i_mutex);
+	iput(inode);
+out:
+	while(head) {
+		/* Premature exit may have left some dangling items. */
+		tmp = head;
+		head = head->free_next;
+		kfree(tmp);
+	}
+
+	return ret;
+}
+
+int ocfs2_run_deallocs(struct ocfs2_super *osb,
+		       struct ocfs2_cached_dealloc_ctxt *ctxt)
+{
+	int ret = 0, ret2;
+	struct ocfs2_per_slot_free_list *fl;
+
+	if (!ctxt)
+		return 0;
+
+	while (ctxt->c_first_suballocator) {
+		fl = ctxt->c_first_suballocator;
+
+		if (fl->f_first) {
+			mlog(0, "Free items: (type %u, slot %d)\n",
+			     fl->f_inode_type, fl->f_slot);
+			ret2 = ocfs2_free_cached_items(osb, fl->f_inode_type,
+						       fl->f_slot, fl->f_first);
+			if (ret2)
+				mlog_errno(ret2);
+			if (!ret)
+				ret = ret2;
+		}
+
+		ctxt->c_first_suballocator = fl->f_next_suballocator;
+		kfree(fl);
+	}
+
+	return ret;
+}
+
+static struct ocfs2_per_slot_free_list *
+ocfs2_find_per_slot_free_list(int type,
+			      int slot,
+			      struct ocfs2_cached_dealloc_ctxt *ctxt)
+{
+	struct ocfs2_per_slot_free_list *fl = ctxt->c_first_suballocator;
+
+	while (fl) {
+		if (fl->f_inode_type == type && fl->f_slot == slot)
+			return fl;
+
+		fl = fl->f_next_suballocator;
+	}
+
+	fl = kmalloc(sizeof(*fl), GFP_NOFS);
+	if (fl) {
+		fl->f_inode_type = type;
+		fl->f_slot = slot;
+		fl->f_first = NULL;
+		fl->f_next_suballocator = ctxt->c_first_suballocator;
+
+		ctxt->c_first_suballocator = fl;
+	}
+	return fl;
+}
+
+static int ocfs2_cache_block_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,
+				     int type, int slot, u64 blkno,
+				     unsigned int bit)
+{
+	int ret;
+	struct ocfs2_per_slot_free_list *fl;
+	struct ocfs2_cached_block_free *item;
+
+	fl = ocfs2_find_per_slot_free_list(type, slot, ctxt);
+	if (fl == NULL) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	item = kmalloc(sizeof(*item), GFP_NOFS);
+	if (item == NULL) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	mlog(0, "Insert: (type %d, slot %u, bit %u, blk %llu)\n",
+	     type, slot, bit, (unsigned long long)blkno);
+
+	item->free_blk = blkno;
+	item->free_bit = bit;
+	item->free_next = fl->f_first;
+
+	fl->f_first = item;
+
+	ret = 0;
+out:
+	return ret;
+}
+
+static int ocfs2_cache_extent_block_free(struct ocfs2_cached_dealloc_ctxt *ctxt,
+					 struct ocfs2_extent_block *eb)
+{
+	return ocfs2_cache_block_dealloc(ctxt, EXTENT_ALLOC_SYSTEM_INODE,
+					 le16_to_cpu(eb->h_suballoc_slot),
+					 le64_to_cpu(eb->h_blkno),
+					 le16_to_cpu(eb->h_suballoc_bit));
+}
+
@@ -3241,21 +5525,4 @@
-			if (le16_to_cpu(eb->h_suballoc_slot) == 0) {
-				/*
-				 * This code only understands how to
-				 * lock the suballocator in slot 0,
-				 * which is fine because allocation is
-				 * only ever done out of that
-				 * suballocator too. A future version
-				 * might change that however, so avoid
-				 * a free if we don't know how to
-				 * handle it. This way an fs incompat
-				 * bit will not be necessary.
-				 */
-				ret = ocfs2_free_extent_block(handle,
-							      tc->tc_ext_alloc_inode,
-							      tc->tc_ext_alloc_bh,
-							      eb);
-
-				/* An error here is not fatal. */
-				if (ret < 0)
-					mlog_errno(ret);
-			}
+			ret = ocfs2_cache_extent_block_free(&tc->tc_dealloc, eb);
+			/* An error here is not fatal. */
+			if (ret < 0)
+				mlog_errno(ret);
@@ -3337,0 +5605 @@
+	inode->i_blocks = ocfs2_inode_sector_count(inode);
@@ -3400,3 +5668,3 @@
-static void ocfs2_zero_cluster_pages(struct inode *inode, loff_t isize,
-				     struct page **pages, int numpages,
-				     u64 phys, handle_t *handle)
+static void ocfs2_zero_cluster_pages(struct inode *inode, loff_t start,
+				     loff_t end, struct page **pages,
+				     int numpages, u64 phys, handle_t *handle)
@@ -3415,17 +5683 @@
-	from = isize & (PAGE_CACHE_SIZE - 1); /* 1st page offset */
-	if (PAGE_CACHE_SHIFT > OCFS2_SB(sb)->s_clustersize_bits) {
-		/*
-		 * Since 'from' has been capped to a value below page
-		 * size, this calculation won't be able to overflow
-		 * 'to'
-		 */
-		to = ocfs2_align_bytes_to_clusters(sb, from);
-
-		/*
-		 * The truncate tail in this case should never contain
-		 * more than one page at maximum. The loop below also
-		 * assumes this.
-		 */
-		BUG_ON(numpages != 1);
-	}
-
+	to = PAGE_CACHE_SIZE;
@@ -3434,0 +5687,4 @@
+		from = start & (PAGE_CACHE_SIZE - 1);
+		if ((end >> PAGE_CACHE_SHIFT) == page->index)
+			to = end & (PAGE_CACHE_SIZE - 1);
+
@@ -3471,4 +5727 @@
-		/*
-		 * Every page after the 1st one should be completely zero'd.
-		 */
-		from = 0;
+		start = (page->index + 1) << PAGE_CACHE_SHIFT;
@@ -3487,2 +5740,2 @@
-static int ocfs2_grab_eof_pages(struct inode *inode, loff_t isize, struct page **pages,
-				int *num, u64 *phys)
+static int ocfs2_grab_eof_pages(struct inode *inode, loff_t start, loff_t end,
+				struct page **pages, int *num, u64 *phys)
@@ -3491 +5743,0 @@
-	unsigned int csize = OCFS2_SB(inode->i_sb)->s_clustersize;
@@ -3496 +5748 @@
-	u64 next_cluster_bytes;
+	loff_t last_page_bytes;
@@ -3498,0 +5751 @@
+	BUG_ON(start > end);
@@ -3500,2 +5753 @@
-	/* Cluster boundary, so we don't need to grab any pages. */
-	if ((isize & (csize - 1)) == 0)
+	if (start == end)
@@ -3504 +5756,4 @@
-	ret = ocfs2_extent_map_get_blocks(inode, isize >> sb->s_blocksize_bits,
+	BUG_ON(start >> OCFS2_SB(sb)->s_clustersize_bits !=
+	       (end - 1) >> OCFS2_SB(sb)->s_clustersize_bits);
+
+	ret = ocfs2_extent_map_get_blocks(inode, start >> sb->s_blocksize_bits,
@@ -3520,2 +5775,2 @@
-	next_cluster_bytes = ocfs2_align_bytes_to_clusters(inode->i_sb, isize);
-	index = isize >> PAGE_CACHE_SHIFT;
+	last_page_bytes = PAGE_ALIGN(end);
+	index = start >> PAGE_CACHE_SHIFT;
@@ -3532 +5787 @@
-	} while (index < (next_cluster_bytes >> PAGE_CACHE_SHIFT));
+	} while (index < (last_page_bytes >> PAGE_CACHE_SHIFT));
@@ -3561,2 +5816,2 @@
-int ocfs2_zero_tail_for_truncate(struct inode *inode, handle_t *handle,
-				 u64 new_i_size)
+int ocfs2_zero_range_for_truncate(struct inode *inode, handle_t *handle,
+				  u64 range_start, u64 range_end)
@@ -3565 +5819,0 @@
-	loff_t endbyte;
@@ -3584 +5838,2 @@
-	ret = ocfs2_grab_eof_pages(inode, new_i_size, pages, &numpages, &phys);
+	ret = ocfs2_grab_eof_pages(inode, range_start, range_end, pages,
+				   &numpages, &phys);
@@ -3593,2 +5848,2 @@
-	ocfs2_zero_cluster_pages(inode, new_i_size, pages, numpages, phys,
-				 handle);
+	ocfs2_zero_cluster_pages(inode, range_start, range_end, pages,
+				 numpages, phys, handle);
@@ -3601,3 +5856,2 @@
-	endbyte = ocfs2_align_bytes_to_clusters(inode->i_sb, new_i_size);
-	ret = do_sync_mapping_range(inode->i_mapping, new_i_size,
-				    endbyte - 1, SYNC_FILE_RANGE_WRITE);
+	ret = do_sync_mapping_range(inode->i_mapping, range_start,
+				    range_end - 1, SYNC_FILE_RANGE_WRITE);
@@ -3634,2 +5887,0 @@
-	down_write(&OCFS2_I(inode)->ip_alloc_sem);
-
@@ -3757 +6008,0 @@
-	up_write(&OCFS2_I(inode)->ip_alloc_sem);
@@ -3766,0 +6018,2 @@
+	ocfs2_run_deallocs(osb, &tc->tc_dealloc);
+
@@ -3777,3 +6030 @@
- * Expects the inode to already be locked. This will figure out which
- * inodes need to be locked and will put them on the returned truncate
- * context.
+ * Expects the inode to already be locked.
@@ -3786 +6037 @@
-	int status, metadata_delete, i;
+	int status;
@@ -3790 +6040,0 @@
-	struct ocfs2_extent_list *el;
@@ -3792,2 +6041,0 @@
-	struct inode *ext_alloc_inode = NULL;
-	struct buffer_head *ext_alloc_bh = NULL;
@@ -3812,0 +6061 @@
+	ocfs2_init_dealloc_ctxt(&(*tc)->tc_dealloc);
@@ -3814 +6062,0 @@
-	metadata_delete = 0;
@@ -3816,3 +6063,0 @@
-		/* If we have a tree, then the truncate may result in
-		 * metadata deletes. Figure this out from the
-		 * rightmost leaf block.*/
@@ -3833,11 +6077,0 @@
-		el = &(eb->h_list);
-
-		i = 0;
-		if (ocfs2_is_empty_extent(&el->l_recs[0]))
-			i = 1;
-		/*
-		 * XXX: Should we check that next_free_rec contains
-		 * the extent?
-		 */
-		if (le32_to_cpu(el->l_recs[i].e_cpos) >= new_i_clusters)
-			metadata_delete = 1;
@@ -3848,22 +6081,0 @@
-	if (metadata_delete) {
-		mlog(0, "Will have to delete metadata for this trunc. "
-		     "locking allocator.\n");
-		ext_alloc_inode = ocfs2_get_system_file_inode(osb, EXTENT_ALLOC_SYSTEM_INODE, 0);
-		if (!ext_alloc_inode) {
-			status = -ENOMEM;
-			mlog_errno(status);
-			goto bail;
-		}
-
-		mutex_lock(&ext_alloc_inode->i_mutex);
-		(*tc)->tc_ext_alloc_inode = ext_alloc_inode;
-
-		status = ocfs2_meta_lock(ext_alloc_inode, &ext_alloc_bh, 1);
-		if (status < 0) {
-			mlog_errno(status);
-			goto bail;
-		}
-		(*tc)->tc_ext_alloc_bh = ext_alloc_bh;
-		(*tc)->tc_ext_alloc_locked = 1;
-	}
-
@@ -3883,10 +6095,7 @@
-	if (tc->tc_ext_alloc_inode) {
-		if (tc->tc_ext_alloc_locked)
-			ocfs2_meta_unlock(tc->tc_ext_alloc_inode, 1);
-
-		mutex_unlock(&tc->tc_ext_alloc_inode->i_mutex);
-		iput(tc->tc_ext_alloc_inode);
-	}
-
-	if (tc->tc_ext_alloc_bh)
-		brelse(tc->tc_ext_alloc_bh);
+	/*
+	 * The caller is responsible for completing deallocation
+	 * before freeing the context.
+	 */
+	if (tc->tc_dealloc.c_first_suballocator != NULL)
+		mlog(ML_NOTICE,
+		     "Truncate completion has non-empty dealloc context\n");
--- ./projects/linux/linux-2.6.23/fs/ocfs2/alloc.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/fs/ocfs2/alloc.c	2008-01-24 23:58:37.000000000 +0100
@@ -357 +356,0 @@
-	int			ins_free_records;
@@ -365 +363,0 @@
-	int			c_used_tail_recs;
@@ -2393,0 +2392,12 @@
+		/*
+		 * Caller might still want to make changes to the
+		 * tree root, so re-add it to the journal here.
+		 */
+		ret = ocfs2_journal_access(handle, inode,
+					   path_root_bh(left_path),
+					   OCFS2_JOURNAL_ACCESS_WRITE);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
@@ -2811 +2821 @@
-	int ret = 0, delete_tail_recs = 0;
+	int ret = 0;
@@ -2817,23 +2827,13 @@
-	if (ctxt->c_split_covers_rec) {
-		delete_tail_recs++;
-
-		if (ctxt->c_contig_type == CONTIG_LEFTRIGHT ||
-		    ctxt->c_has_empty_extent)
-			delete_tail_recs++;
-
-		if (ctxt->c_has_empty_extent) {
-			/*
-			 * The merge code will need to create an empty
-			 * extent to take the place of the newly
-			 * emptied slot. Remove any pre-existing empty
-			 * extents - having more than one in a leaf is
-			 * illegal.
-			 */
-			ret = ocfs2_rotate_tree_left(inode, handle, left_path,
-						     dealloc);
-			if (ret) {
-				mlog_errno(ret);
-				goto out;
-			}
-			split_index--;
-			rec = &el->l_recs[split_index];
+	if (ctxt->c_split_covers_rec && ctxt->c_has_empty_extent) {
+		/*
+		 * The merge code will need to create an empty
+		 * extent to take the place of the newly
+		 * emptied slot. Remove any pre-existing empty
+		 * extents - having more than one in a leaf is
+		 * illegal.
+		 */
+		ret = ocfs2_rotate_tree_left(inode, handle, left_path,
+					     dealloc);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
@@ -2840,0 +2841,2 @@
+		split_index--;
+		rec = &el->l_recs[split_index];
@@ -3302,10 +3303,0 @@
-	/*
-	 * Pass both paths to the journal. The majority of inserts
-	 * will be touching all components anyway.
-	 */
-	ret = ocfs2_journal_access_path(inode, handle, right_path);
-	if (ret < 0) {
-		mlog_errno(ret);
-		goto out;
-	}
-
@@ -3335,0 +3328,10 @@
+	/*
+	 * Pass both paths to the journal. The majority of inserts
+	 * will be touching all components anyway.
+	 */
+	ret = ocfs2_journal_access_path(inode, handle, right_path);
+	if (ret < 0) {
+		mlog_errno(ret);
+		goto out;
+	}
+
@@ -3343,0 +3346,11 @@
+
+		/*
+		 * Split might have modified either leaf and we don't
+		 * have a guarantee that the later edge insert will
+		 * dirty this for us.
+		 */
+		if (left_path)
+			ret = ocfs2_journal_dirty(handle,
+						  path_leaf_bh(left_path));
+			if (ret)
+				mlog_errno(ret);
@@ -3442,0 +3456,11 @@
+
+		/*
+		 * ocfs2_rotate_tree_right() might have extended the
+		 * transaction without re-journaling our tree root.
+		 */
+		ret = ocfs2_journal_access(handle, inode, di_bh,
+					   OCFS2_JOURNAL_ACCESS_WRITE);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
@@ -3595,0 +3620 @@
+				    int *free_records,
@@ -3636 +3661 @@
-	insert->ins_free_records = le16_to_cpu(el->l_count) -
+	*free_records = le16_to_cpu(el->l_count) -
@@ -3732,0 +3758 @@
+	int uninitialized_var(free_records);
@@ -3736,0 +3763,2 @@
+	BUG_ON(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL);
+
@@ -3755 +3783 @@
-					  &insert);
+					  &free_records, &insert);
@@ -3765 +3793 @@
-	     insert.ins_free_records, insert.ins_tree_depth);
+	     free_records, insert.ins_tree_depth);
@@ -3767 +3795 @@
-	if (insert.ins_contig == CONTIG_NONE && insert.ins_free_records == 0) {
+	if (insert.ins_contig == CONTIG_NONE && free_records == 0) {
@@ -3850,2 +3877,0 @@
-		int old_depth = depth;
-
@@ -3858,5 +3883,0 @@
-
-		if (old_depth != depth) {
-			eb = (struct ocfs2_extent_block *)(*last_eb_bh)->b_data;
-			rightmost_el = &eb->h_list;
-		}
@@ -3868,2 +3888,0 @@
-	insert.ins_free_records = le16_to_cpu(rightmost_el->l_count)
-		- le16_to_cpu(rightmost_el->l_next_free_rec);
@@ -3959 +3978 @@
-	struct buffer_head *eb_bh, *last_eb_bh = NULL;
+	struct buffer_head *last_eb_bh = NULL;
@@ -3964 +3983 @@
-	if (!rec->e_flags & OCFS2_EXT_UNWRITTEN) {
+	if (!(rec->e_flags & OCFS2_EXT_UNWRITTEN)) {
@@ -3978,8 +3996,0 @@
-	eb_bh = path_leaf_bh(path);
-	ret = ocfs2_journal_access(handle, inode, eb_bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
-	if (ret) {
-		mlog_errno(ret);
-		goto out;
-	}
-
@@ -4018,5 +4028,0 @@
-	ctxt.c_used_tail_recs = le16_to_cpu(rightmost_el->l_next_free_rec);
-	if (ctxt.c_used_tail_recs > 0 &&
-	    ocfs2_is_empty_extent(&rightmost_el->l_recs[0]))
-		ctxt.c_used_tail_recs--;
-
@@ -4031,4 +4037,3 @@
-	mlog(0, "index: %d, contig: %u, used_tail_recs: %u, "
-	     "has_empty: %u, split_covers: %u\n", split_index,
-	     ctxt.c_contig_type, ctxt.c_used_tail_recs,
-	     ctxt.c_has_empty_extent, ctxt.c_split_covers_rec);
+	mlog(0, "index: %d, contig: %u, has_empty: %u, split_covers: %u\n",
+	     split_index, ctxt.c_contig_type, ctxt.c_has_empty_extent,
+	     ctxt.c_split_covers_rec);
@@ -4053,2 +4057,0 @@
-	ocfs2_journal_dirty(handle, eb_bh);
-
@@ -4183,2 +4185,0 @@
-		int old_depth = depth;
-
@@ -4191,5 +4191,0 @@
-
-		if (old_depth != depth) {
-			eb = (struct ocfs2_extent_block *)last_eb_bh->b_data;
-			rightmost_el = &eb->h_list;
-		}
@@ -4202,2 +4197,0 @@
-	insert.ins_free_records = le16_to_cpu(rightmost_el->l_count)
-		- le16_to_cpu(rightmost_el->l_next_free_rec);
@@ -5667,0 +5662,39 @@
+static void ocfs2_map_and_dirty_page(struct inode *inode, handle_t *handle,
+				     unsigned int from, unsigned int to,
+				     struct page *page, int zero, u64 *phys)
+{
+	int ret, partial = 0;
+
+	ret = ocfs2_map_page_blocks(page, phys, inode, from, to, 0);
+	if (ret)
+		mlog_errno(ret);
+
+	if (zero)
+		zero_user_page(page, from, to - from, KM_USER0);
+
+	/*
+	 * Need to set the buffers we zero'd into uptodate
+	 * here if they aren't - ocfs2_map_page_blocks()
+	 * might've skipped some
+	 */
+	if (ocfs2_should_order_data(inode)) {
+		ret = walk_page_buffers(handle,
+					page_buffers(page),
+					from, to, &partial,
+					ocfs2_ordered_zero_func);
+		if (ret < 0)
+			mlog_errno(ret);
+	} else {
+		ret = walk_page_buffers(handle, page_buffers(page),
+					from, to, &partial,
+					ocfs2_writeback_zero_func);
+		if (ret < 0)
+			mlog_errno(ret);
+	}
+
+	if (!partial)
+		SetPageUptodate(page);
+
+	flush_dcache_page(page);
+}
+
@@ -5672,2 +5705 @@
-	int i, ret, partial = 0;
-	void *kaddr;
+	int i;
@@ -5694,32 +5726,2 @@
-		ret = ocfs2_map_page_blocks(page, &phys, inode, from, to, 0);
-		if (ret)
-			mlog_errno(ret);
-
-		kaddr = kmap_atomic(page, KM_USER0);
-		memset(kaddr + from, 0, to - from);
-		kunmap_atomic(kaddr, KM_USER0);
-
-		/*
-		 * Need to set the buffers we zero'd into uptodate
-		 * here if they aren't - ocfs2_map_page_blocks()
-		 * might've skipped some
-		 */
-		if (ocfs2_should_order_data(inode)) {
-			ret = walk_page_buffers(handle,
-						page_buffers(page),
-						from, to, &partial,
-						ocfs2_ordered_zero_func);
-			if (ret < 0)
-				mlog_errno(ret);
-		} else {
-			ret = walk_page_buffers(handle, page_buffers(page),
-						from, to, &partial,
-						ocfs2_writeback_zero_func);
-			if (ret < 0)
-				mlog_errno(ret);
-		}
-
-		if (!partial)
-			SetPageUptodate(page);
-
-		flush_dcache_page(page);
+		ocfs2_map_and_dirty_page(inode, handle, from, to, page, 1,
+					 &phys);
@@ -5730,8 +5732,2 @@
-	if (pages) {
-		for (i = 0; i < numpages; i++) {
-			page = pages[i];
-			unlock_page(page);
-			mark_page_accessed(page);
-			page_cache_release(page);
-		}
-	}
+	if (pages)
+		ocfs2_unlock_and_free_pages(pages, numpages);
@@ -5741 +5737 @@
-				struct page **pages, int *num, u64 *phys)
+				struct page **pages, int *num)
@@ -5743,2 +5739 @@
-	int i, numpages = 0, ret = 0;
-	unsigned int ext_flags;
+	int numpages, ret = 0;
@@ -5750 +5744,0 @@
-	BUG_ON(!ocfs2_sparse_alloc(OCFS2_SB(sb)));
@@ -5753,3 +5746,0 @@
-	if (start == end)
-		goto out;
-
@@ -5759,16 +5750 @@
-	ret = ocfs2_extent_map_get_blocks(inode, start >> sb->s_blocksize_bits,
-					  phys, NULL, &ext_flags);
-	if (ret) {
-		mlog_errno(ret);
-		goto out;
-	}
-
-	/* Tail is a hole. */
-	if (*phys == 0)
-		goto out;
-
-	/* Tail is marked as unwritten, we can count on write to zero
-	 * in that case. */
-	if (ext_flags & OCFS2_EXT_UNWRITTEN)
-		goto out;
-
+	numpages = 0;
@@ -5791,8 +5767,2 @@
-		if (pages) {
-			for (i = 0; i < numpages; i++) {
-				if (pages[i]) {
-					unlock_page(pages[i]);
-					page_cache_release(pages[i]);
-				}
-			}
-		}
+		if (pages)
+			ocfs2_unlock_and_free_pages(pages, numpages);
@@ -5819 +5789 @@
-	int ret, numpages;
+	int ret = 0, numpages;
@@ -5821,0 +5792,2 @@
+	unsigned int ext_flags;
+	struct super_block *sb = inode->i_sb;
@@ -5827 +5799 @@
-	if (!ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))
+	if (!ocfs2_sparse_alloc(OCFS2_SB(sb)))
@@ -5830 +5802 @@
-	pages = kcalloc(ocfs2_pages_per_cluster(inode->i_sb),
+	pages = kcalloc(ocfs2_pages_per_cluster(sb),
@@ -5838,2 +5810,6 @@
-	ret = ocfs2_grab_eof_pages(inode, range_start, range_end, pages,
-				   &numpages, &phys);
+	if (range_start == range_end)
+		goto out;
+
+	ret = ocfs2_extent_map_get_blocks(inode,
+					  range_start >> sb->s_blocksize_bits,
+					  &phys, NULL, &ext_flags);
@@ -5845 +5821,5 @@
-	if (numpages == 0)
+	/*
+	 * Tail is a hole, or is marked unwritten. In either case, we
+	 * can count on read and write to return/push zero's.
+	 */
+	if (phys == 0 || ext_flags & OCFS2_EXT_UNWRITTEN)
@@ -5847,0 +5828,7 @@
+	ret = ocfs2_grab_eof_pages(inode, range_start, range_end, pages,
+				   &numpages);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
@@ -5867,0 +5855,172 @@
+static void ocfs2_zero_dinode_id2(struct inode *inode, struct ocfs2_dinode *di)
+{
+	unsigned int blocksize = 1 << inode->i_sb->s_blocksize_bits;
+
+	memset(&di->id2, 0, blocksize - offsetof(struct ocfs2_dinode, id2));
+}
+
+void ocfs2_dinode_new_extent_list(struct inode *inode,
+				  struct ocfs2_dinode *di)
+{
+	ocfs2_zero_dinode_id2(inode, di);
+	di->id2.i_list.l_tree_depth = 0;
+	di->id2.i_list.l_next_free_rec = 0;
+	di->id2.i_list.l_count = cpu_to_le16(ocfs2_extent_recs_per_inode(inode->i_sb));
+}
+
+void ocfs2_set_inode_data_inline(struct inode *inode, struct ocfs2_dinode *di)
+{
+	struct ocfs2_inode_info *oi = OCFS2_I(inode);
+	struct ocfs2_inline_data *idata = &di->id2.i_data;
+
+	spin_lock(&oi->ip_lock);
+	oi->ip_dyn_features |= OCFS2_INLINE_DATA_FL;
+	di->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);
+	spin_unlock(&oi->ip_lock);
+
+	/*
+	 * We clear the entire i_data structure here so that all
+	 * fields can be properly initialized.
+	 */
+	ocfs2_zero_dinode_id2(inode, di);
+
+	idata->id_count = cpu_to_le16(ocfs2_max_inline_data(inode->i_sb));
+}
+
+int ocfs2_convert_inline_data_to_extents(struct inode *inode,
+					 struct buffer_head *di_bh)
+{
+	int ret, i, has_data, num_pages = 0;
+	handle_t *handle;
+	u64 uninitialized_var(block);
+	struct ocfs2_inode_info *oi = OCFS2_I(inode);
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
+	struct ocfs2_alloc_context *data_ac = NULL;
+	struct page **pages = NULL;
+	loff_t end = osb->s_clustersize;
+
+	has_data = i_size_read(inode) ? 1 : 0;
+
+	if (has_data) {
+		pages = kcalloc(ocfs2_pages_per_cluster(osb->sb),
+				sizeof(struct page *), GFP_NOFS);
+		if (pages == NULL) {
+			ret = -ENOMEM;
+			mlog_errno(ret);
+			goto out;
+		}
+
+		ret = ocfs2_reserve_clusters(osb, 1, &data_ac);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+	handle = ocfs2_start_trans(osb, OCFS2_INLINE_TO_EXTENTS_CREDITS);
+	if (IS_ERR(handle)) {
+		ret = PTR_ERR(handle);
+		mlog_errno(ret);
+		goto out_unlock;
+	}
+
+	ret = ocfs2_journal_access(handle, inode, di_bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
+		mlog_errno(ret);
+		goto out_commit;
+	}
+
+	if (has_data) {
+		u32 bit_off, num;
+		unsigned int page_end;
+		u64 phys;
+
+		ret = ocfs2_claim_clusters(osb, handle, data_ac, 1, &bit_off,
+					   &num);
+		if (ret) {
+			mlog_errno(ret);
+			goto out_commit;
+		}
+
+		/*
+		 * Save two copies, one for insert, and one that can
+		 * be changed by ocfs2_map_and_dirty_page() below.
+		 */
+		block = phys = ocfs2_clusters_to_blocks(inode->i_sb, bit_off);
+
+		/*
+		 * Non sparse file systems zero on extend, so no need
+		 * to do that now.
+		 */
+		if (!ocfs2_sparse_alloc(osb) &&
+		    PAGE_CACHE_SIZE < osb->s_clustersize)
+			end = PAGE_CACHE_SIZE;
+
+		ret = ocfs2_grab_eof_pages(inode, 0, end, pages, &num_pages);
+		if (ret) {
+			mlog_errno(ret);
+			goto out_commit;
+		}
+
+		/*
+		 * This should populate the 1st page for us and mark
+		 * it up to date.
+		 */
+		ret = ocfs2_read_inline_data(inode, pages[0], di_bh);
+		if (ret) {
+			mlog_errno(ret);
+			goto out_commit;
+		}
+
+		page_end = PAGE_CACHE_SIZE;
+		if (PAGE_CACHE_SIZE > osb->s_clustersize)
+			page_end = osb->s_clustersize;
+
+		for (i = 0; i < num_pages; i++)
+			ocfs2_map_and_dirty_page(inode, handle, 0, page_end,
+						 pages[i], i > 0, &phys);
+	}
+
+	spin_lock(&oi->ip_lock);
+	oi->ip_dyn_features &= ~OCFS2_INLINE_DATA_FL;
+	di->i_dyn_features = cpu_to_le16(oi->ip_dyn_features);
+	spin_unlock(&oi->ip_lock);
+
+	ocfs2_dinode_new_extent_list(inode, di);
+
+	ocfs2_journal_dirty(handle, di_bh);
+
+	if (has_data) {
+		/*
+		 * An error at this point should be extremely rare. If
+		 * this proves to be false, we could always re-build
+		 * the in-inode data from our pages.
+		 */
+		ret = ocfs2_insert_extent(osb, handle, inode, di_bh,
+					  0, block, 1, 0, NULL);
+		if (ret) {
+			mlog_errno(ret);
+			goto out_commit;
+		}
+
+		inode->i_blocks = ocfs2_inode_sector_count(inode);
+	}
+
+out_commit:
+	ocfs2_commit_trans(osb, handle);
+
+out_unlock:
+	if (data_ac)
+		ocfs2_free_alloc_context(data_ac);
+
+out:
+	if (pages) {
+		ocfs2_unlock_and_free_pages(pages, num_pages);
+		kfree(pages);
+	}
+
+	return ret;
+}
+
@@ -5961,2 +6119,0 @@
-	BUG_ON(clusters_to_del == 0);
-
@@ -6092,0 +6250,75 @@
+/*
+ * 'start' is inclusive, 'end' is not.
+ */
+int ocfs2_truncate_inline(struct inode *inode, struct buffer_head *di_bh,
+			  unsigned int start, unsigned int end, int trunc)
+{
+	int ret;
+	unsigned int numbytes;
+	handle_t *handle;
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
+	struct ocfs2_inline_data *idata = &di->id2.i_data;
+
+	if (end > i_size_read(inode))
+		end = i_size_read(inode);
+
+	BUG_ON(start >= end);
+
+	if (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) ||
+	    !(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL) ||
+	    !ocfs2_supports_inline_data(osb)) {
+		ocfs2_error(inode->i_sb,
+			    "Inline data flags for inode %llu don't agree! "
+			    "Disk: 0x%x, Memory: 0x%x, Superblock: 0x%x\n",
+			    (unsigned long long)OCFS2_I(inode)->ip_blkno,
+			    le16_to_cpu(di->i_dyn_features),
+			    OCFS2_I(inode)->ip_dyn_features,
+			    osb->s_feature_incompat);
+		ret = -EROFS;
+		goto out;
+	}
+
+	handle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);
+	if (IS_ERR(handle)) {
+		ret = PTR_ERR(handle);
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ret = ocfs2_journal_access(handle, inode, di_bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
+		mlog_errno(ret);
+		goto out_commit;
+	}
+
+	numbytes = end - start;
+	memset(idata->id_data + start, 0, numbytes);
+
+	/*
+	 * No need to worry about the data page here - it's been
+	 * truncated already and inline data doesn't need it for
+	 * pushing zero's to disk, so we'll let readpage pick it up
+	 * later.
+	 */
+	if (trunc) {
+		i_size_write(inode, start);
+		di->i_size = cpu_to_le64(start);
+	}
+
+	inode->i_blocks = ocfs2_inode_sector_count(inode);
+	inode->i_ctime = inode->i_mtime = CURRENT_TIME;
+
+	di->i_ctime = di->i_mtime = cpu_to_le64(inode->i_ctime.tv_sec);
+	di->i_ctime_nsec = di->i_mtime_nsec = cpu_to_le32(inode->i_ctime.tv_nsec);
+
+	ocfs2_journal_dirty(handle, di_bh);
+
+out_commit:
+	ocfs2_commit_trans(osb, handle);
+
+out:
+	return ret;
+}
+
--- ./projects/linux/linux-2.6.24/fs/ocfs2/alloc.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/fs/ocfs2/alloc.c	2008-04-17 04:49:44.000000000 +0200
@@ -3341 +3341 @@
-		 * of splits, but it's easier to just let one seperate
+		 * of splits, but it's easier to just let one separate
@@ -4734 +4734 @@
-	status = ocfs2_meta_lock(data_alloc_inode, &data_alloc_bh, 1);
+	status = ocfs2_inode_lock(data_alloc_inode, &data_alloc_bh, 1);
@@ -4756 +4756 @@
-	ocfs2_meta_unlock(data_alloc_inode, 1);
+	ocfs2_inode_unlock(data_alloc_inode, 1);
@@ -5080 +5080 @@
-	ret = ocfs2_meta_lock(inode, &di_bh, 1);
+	ret = ocfs2_inode_lock(inode, &di_bh, 1);
@@ -5121 +5121 @@
-	ocfs2_meta_unlock(inode, 1);
+	ocfs2_inode_unlock(inode, 1);
@@ -5673 +5673 @@
-		zero_user_page(page, from, to - from, KM_USER0);
+		zero_user_segment(page, from, to);
--- ./projects/linux/linux-2.6.25/fs/ocfs2/alloc.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/fs/ocfs2/alloc.c	2008-07-13 23:51:29.000000000 +0200
@@ -1032,2 +1032 @@
-	if (el->l_next_free_rec == el->l_count && !has_empty)
-		BUG();
+	BUG_ON(el->l_next_free_rec == el->l_count && !has_empty);
@@ -1452,0 +1452,2 @@
+ *   - When we've adjusted the last extent record in the left path leaf and the
+ *     1st extent record in the right path leaf during cross extent block merge.
@@ -2714,0 +2716,48 @@
+static int ocfs2_get_right_path(struct inode *inode,
+				struct ocfs2_path *left_path,
+				struct ocfs2_path **ret_right_path)
+{
+	int ret;
+	u32 right_cpos;
+	struct ocfs2_path *right_path = NULL;
+	struct ocfs2_extent_list *left_el;
+
+	*ret_right_path = NULL;
+
+	/* This function shouldn't be called for non-trees. */
+	BUG_ON(left_path->p_tree_depth == 0);
+
+	left_el = path_leaf_el(left_path);
+	BUG_ON(left_el->l_next_free_rec != left_el->l_count);
+
+	ret = ocfs2_find_cpos_for_right_leaf(inode->i_sb, left_path,
+					     &right_cpos);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	/* This function shouldn't be called for the rightmost leaf. */
+	BUG_ON(right_cpos == 0);
+
+	right_path = ocfs2_new_path(path_root_bh(left_path),
+				    path_root_el(left_path));
+	if (!right_path) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ret = ocfs2_find_path(inode, right_path, right_cpos);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	*ret_right_path = right_path;
+out:
+	if (ret)
+		ocfs2_free_path(right_path);
+	return ret;
+}
+
@@ -2717 +2766,4 @@
- * onto the beginning of the record at index + 1.
+ * onto the beginning of the record "next" to it.
+ * For index < l_count - 1, the next means the extent rec at index + 1.
+ * For index == l_count - 1, the "next" means the 1st extent rec of the
+ * next extent block.
@@ -2719,4 +2771,5 @@
-static int ocfs2_merge_rec_right(struct inode *inode, struct buffer_head *bh,
-				handle_t *handle,
-				struct ocfs2_extent_rec *split_rec,
-				struct ocfs2_extent_list *el, int index)
+static int ocfs2_merge_rec_right(struct inode *inode,
+				 struct ocfs2_path *left_path,
+				 handle_t *handle,
+				 struct ocfs2_extent_rec *split_rec,
+				 int index)
@@ -2724 +2777 @@
-	int ret;
+	int ret, next_free, i;
@@ -2727,0 +2781,6 @@
+	struct ocfs2_extent_list *right_el;
+	struct ocfs2_path *right_path = NULL;
+	int subtree_index = 0;
+	struct ocfs2_extent_list *el = path_leaf_el(left_path);
+	struct buffer_head *bh = path_leaf_bh(left_path);
+	struct buffer_head *root_bh = NULL;
@@ -2730 +2788,0 @@
-
@@ -2732 +2790,67 @@
-	right_rec = &el->l_recs[index + 1];
+
+	if (index == le16_to_cpu(el->l_next_free_rec) - 1 &&
+	    le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count)) {
+		/* we meet with a cross extent block merge. */
+		ret = ocfs2_get_right_path(inode, left_path, &right_path);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		right_el = path_leaf_el(right_path);
+		next_free = le16_to_cpu(right_el->l_next_free_rec);
+		BUG_ON(next_free <= 0);
+		right_rec = &right_el->l_recs[0];
+		if (ocfs2_is_empty_extent(right_rec)) {
+			BUG_ON(next_free <= 1);
+			right_rec = &right_el->l_recs[1];
+		}
+
+		BUG_ON(le32_to_cpu(left_rec->e_cpos) +
+		       le16_to_cpu(left_rec->e_leaf_clusters) !=
+		       le32_to_cpu(right_rec->e_cpos));
+
+		subtree_index = ocfs2_find_subtree_root(inode,
+							left_path, right_path);
+
+		ret = ocfs2_extend_rotate_transaction(handle, subtree_index,
+						      handle->h_buffer_credits,
+						      right_path);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		root_bh = left_path->p_node[subtree_index].bh;
+		BUG_ON(root_bh != right_path->p_node[subtree_index].bh);
+
+		ret = ocfs2_journal_access(handle, inode, root_bh,
+					   OCFS2_JOURNAL_ACCESS_WRITE);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		for (i = subtree_index + 1;
+		     i < path_num_items(right_path); i++) {
+			ret = ocfs2_journal_access(handle, inode,
+						   right_path->p_node[i].bh,
+						   OCFS2_JOURNAL_ACCESS_WRITE);
+			if (ret) {
+				mlog_errno(ret);
+				goto out;
+			}
+
+			ret = ocfs2_journal_access(handle, inode,
+						   left_path->p_node[i].bh,
+						   OCFS2_JOURNAL_ACCESS_WRITE);
+			if (ret) {
+				mlog_errno(ret);
+				goto out;
+			}
+		}
+
+	} else {
+		BUG_ON(index == le16_to_cpu(el->l_next_free_rec) - 1);
+		right_rec = &el->l_recs[index + 1];
+	}
@@ -2753,0 +2878,52 @@
+	if (right_path) {
+		ret = ocfs2_journal_dirty(handle, path_leaf_bh(right_path));
+		if (ret)
+			mlog_errno(ret);
+
+		ocfs2_complete_edge_insert(inode, handle, left_path,
+					   right_path, subtree_index);
+	}
+out:
+	if (right_path)
+		ocfs2_free_path(right_path);
+	return ret;
+}
+
+static int ocfs2_get_left_path(struct inode *inode,
+			       struct ocfs2_path *right_path,
+			       struct ocfs2_path **ret_left_path)
+{
+	int ret;
+	u32 left_cpos;
+	struct ocfs2_path *left_path = NULL;
+
+	*ret_left_path = NULL;
+
+	/* This function shouldn't be called for non-trees. */
+	BUG_ON(right_path->p_tree_depth == 0);
+
+	ret = ocfs2_find_cpos_for_left_leaf(inode->i_sb,
+					    right_path, &left_cpos);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	/* This function shouldn't be called for the leftmost leaf. */
+	BUG_ON(left_cpos == 0);
+
+	left_path = ocfs2_new_path(path_root_bh(right_path),
+				   path_root_el(right_path));
+	if (!left_path) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ret = ocfs2_find_path(inode, left_path, left_cpos);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	*ret_left_path = left_path;
@@ -2754,0 +2931,2 @@
+	if (ret)
+		ocfs2_free_path(left_path);
@@ -2760 +2938,7 @@
- * onto the tail of the record at index - 1.
+ * onto the tail of the record "before" it.
+ * For index > 0, the "before" means the extent rec at index - 1.
+ *
+ * For index == 0, the "before" means the last record of the previous
+ * extent block. And there is also a situation that we may need to
+ * remove the rightmost leaf extent block in the right_path and change
+ * the right path to indicate the new rightmost path.
@@ -2762 +2946,2 @@
-static int ocfs2_merge_rec_left(struct inode *inode, struct buffer_head *bh,
+static int ocfs2_merge_rec_left(struct inode *inode,
+				struct ocfs2_path *right_path,
@@ -2765 +2950,2 @@
-				struct ocfs2_extent_list *el, int index)
+				struct ocfs2_cached_dealloc_ctxt *dealloc,
+				int index)
@@ -2767 +2953 @@
-	int ret, has_empty_extent = 0;
+	int ret, i, subtree_index = 0, has_empty_extent = 0;
@@ -2770,0 +2957,5 @@
+	struct ocfs2_extent_list *el = path_leaf_el(right_path);
+	struct buffer_head *bh = path_leaf_bh(right_path);
+	struct buffer_head *root_bh = NULL;
+	struct ocfs2_path *left_path = NULL;
+	struct ocfs2_extent_list *left_el;
@@ -2772 +2963 @@
-	BUG_ON(index <= 0);
+	BUG_ON(index < 0);
@@ -2774 +2964,0 @@
-	left_rec = &el->l_recs[index - 1];
@@ -2776,2 +2966,62 @@
-	if (ocfs2_is_empty_extent(&el->l_recs[0]))
-		has_empty_extent = 1;
+	if (index == 0) {
+		/* we meet with a cross extent block merge. */
+		ret = ocfs2_get_left_path(inode, right_path, &left_path);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		left_el = path_leaf_el(left_path);
+		BUG_ON(le16_to_cpu(left_el->l_next_free_rec) !=
+		       le16_to_cpu(left_el->l_count));
+
+		left_rec = &left_el->l_recs[
+				le16_to_cpu(left_el->l_next_free_rec) - 1];
+		BUG_ON(le32_to_cpu(left_rec->e_cpos) +
+		       le16_to_cpu(left_rec->e_leaf_clusters) !=
+		       le32_to_cpu(split_rec->e_cpos));
+
+		subtree_index = ocfs2_find_subtree_root(inode,
+							left_path, right_path);
+
+		ret = ocfs2_extend_rotate_transaction(handle, subtree_index,
+						      handle->h_buffer_credits,
+						      left_path);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		root_bh = left_path->p_node[subtree_index].bh;
+		BUG_ON(root_bh != right_path->p_node[subtree_index].bh);
+
+		ret = ocfs2_journal_access(handle, inode, root_bh,
+					   OCFS2_JOURNAL_ACCESS_WRITE);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		for (i = subtree_index + 1;
+		     i < path_num_items(right_path); i++) {
+			ret = ocfs2_journal_access(handle, inode,
+						   right_path->p_node[i].bh,
+						   OCFS2_JOURNAL_ACCESS_WRITE);
+			if (ret) {
+				mlog_errno(ret);
+				goto out;
+			}
+
+			ret = ocfs2_journal_access(handle, inode,
+						   left_path->p_node[i].bh,
+						   OCFS2_JOURNAL_ACCESS_WRITE);
+			if (ret) {
+				mlog_errno(ret);
+				goto out;
+			}
+		}
+	} else {
+		left_rec = &el->l_recs[index - 1];
+		if (ocfs2_is_empty_extent(&el->l_recs[0]))
+			has_empty_extent = 1;
+	}
@@ -2793 +3043 @@
-	} else {
+	} else
@@ -2795 +3044,0 @@
-	}
@@ -2807,0 +3057,29 @@
+	if (left_path) {
+		ret = ocfs2_journal_dirty(handle, path_leaf_bh(left_path));
+		if (ret)
+			mlog_errno(ret);
+
+		/*
+		 * In the situation that the right_rec is empty and the extent
+		 * block is empty also,  ocfs2_complete_edge_insert can't handle
+		 * it and we need to delete the right extent block.
+		 */
+		if (le16_to_cpu(right_rec->e_leaf_clusters) == 0 &&
+		    le16_to_cpu(el->l_next_free_rec) == 1) {
+
+			ret = ocfs2_remove_rightmost_path(inode, handle,
+							  right_path, dealloc);
+			if (ret) {
+				mlog_errno(ret);
+				goto out;
+			}
+
+			/* Now the rightmost extent block has been deleted.
+			 * So we use the new rightmost path.
+			 */
+			ocfs2_mv_path(right_path, left_path);
+			left_path = NULL;
+		} else
+			ocfs2_complete_edge_insert(inode, handle, left_path,
+						   right_path, subtree_index);
+	}
@@ -2808,0 +3087,2 @@
+	if (left_path)
+		ocfs2_free_path(left_path);
@@ -2814 +3094 @@
-				     struct ocfs2_path *left_path,
+				     struct ocfs2_path *path,
@@ -2822 +3102 @@
-	struct ocfs2_extent_list *el = path_leaf_el(left_path);
+	struct ocfs2_extent_list *el = path_leaf_el(path);
@@ -2835 +3115 @@
-		ret = ocfs2_rotate_tree_left(inode, handle, left_path,
+		ret = ocfs2_rotate_tree_left(inode, handle, path,
@@ -2850 +3129,0 @@
-		BUG_ON(split_index == 0);
@@ -2861,3 +3140,8 @@
-		 */
-		ret = ocfs2_merge_rec_left(inode, path_leaf_bh(left_path),
-					   handle, split_rec, el, split_index);
+		 *
+		 * When the split_index is zero, we need to merge it to the
+		 * prevoius extent block. It is more efficient and easier
+		 * if we do merge_right first and merge_left later.
+		 */
+		ret = ocfs2_merge_rec_right(inode, path,
+					    handle, split_rec,
+					    split_index);
@@ -2874,5 +3158,2 @@
-		/*
-		 * The left merge left us with an empty extent, remove
-		 * it.
-		 */
-		ret = ocfs2_rotate_tree_left(inode, handle, left_path, dealloc);
+		/* The merge left us with an empty extent, remove it. */
+		ret = ocfs2_rotate_tree_left(inode, handle, path, dealloc);
@@ -2883 +3164 @@
-		split_index--;
+
@@ -2888 +3169 @@
-		 * we've merged it into the left side.
+		 * we've merged it into the rec already.
@@ -2890,2 +3171,5 @@
-		ret = ocfs2_merge_rec_right(inode, path_leaf_bh(left_path),
-					    handle, rec, el, split_index);
+		ret = ocfs2_merge_rec_left(inode, path,
+					   handle, rec,
+					   dealloc,
+					   split_index);
+
@@ -2897,3 +3181 @@
-		BUG_ON(!ocfs2_is_empty_extent(&el->l_recs[0]));
-
-		ret = ocfs2_rotate_tree_left(inode, handle, left_path,
+		ret = ocfs2_rotate_tree_left(inode, handle, path,
@@ -2918,2 +3200,3 @@
-						   path_leaf_bh(left_path),
-						   handle, split_rec, el,
+						   path,
+						   handle, split_rec,
+						   dealloc,
@@ -2927,2 +3210,2 @@
-						    path_leaf_bh(left_path),
-						    handle, split_rec, el,
+						    path,
+						    handle, split_rec,
@@ -2941 +3224 @@
-			ret = ocfs2_rotate_tree_left(inode, handle, left_path,
+			ret = ocfs2_rotate_tree_left(inode, handle, path,
@@ -3501 +3784 @@
-ocfs2_figure_merge_contig_type(struct inode *inode,
+ocfs2_figure_merge_contig_type(struct inode *inode, struct ocfs2_path *path,
@@ -3505 +3788 @@
-	struct ocfs2_extent_rec *rec;
+	int status;
@@ -3506,0 +3790,39 @@
+	u32 left_cpos, right_cpos;
+	struct ocfs2_extent_rec *rec = NULL;
+	struct ocfs2_extent_list *new_el;
+	struct ocfs2_path *left_path = NULL, *right_path = NULL;
+	struct buffer_head *bh;
+	struct ocfs2_extent_block *eb;
+
+	if (index > 0) {
+		rec = &el->l_recs[index - 1];
+	} else if (path->p_tree_depth > 0) {
+		status = ocfs2_find_cpos_for_left_leaf(inode->i_sb,
+						       path, &left_cpos);
+		if (status)
+			goto out;
+
+		if (left_cpos != 0) {
+			left_path = ocfs2_new_path(path_root_bh(path),
+						   path_root_el(path));
+			if (!left_path)
+				goto out;
+
+			status = ocfs2_find_path(inode, left_path, left_cpos);
+			if (status)
+				goto out;
+
+			new_el = path_leaf_el(left_path);
+
+			if (le16_to_cpu(new_el->l_next_free_rec) !=
+			    le16_to_cpu(new_el->l_count)) {
+				bh = path_leaf_bh(left_path);
+				eb = (struct ocfs2_extent_block *)bh->b_data;
+				OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb,
+								 eb);
+				goto out;
+			}
+			rec = &new_el->l_recs[
+				le16_to_cpu(new_el->l_next_free_rec) - 1];
+		}
+	}
@@ -3512,3 +3834 @@
-
-	if (index > 0) {
-		rec = &el->l_recs[index - 1];
+	if (rec) {
@@ -3523 +3843,37 @@
-	if (index < (le16_to_cpu(el->l_next_free_rec) - 1)) {
+	rec = NULL;
+	if (index < (le16_to_cpu(el->l_next_free_rec) - 1))
+		rec = &el->l_recs[index + 1];
+	else if (le16_to_cpu(el->l_next_free_rec) == le16_to_cpu(el->l_count) &&
+		 path->p_tree_depth > 0) {
+		status = ocfs2_find_cpos_for_right_leaf(inode->i_sb,
+							path, &right_cpos);
+		if (status)
+			goto out;
+
+		if (right_cpos == 0)
+			goto out;
+
+		right_path = ocfs2_new_path(path_root_bh(path),
+					    path_root_el(path));
+		if (!right_path)
+			goto out;
+
+		status = ocfs2_find_path(inode, right_path, right_cpos);
+		if (status)
+			goto out;
+
+		new_el = path_leaf_el(right_path);
+		rec = &new_el->l_recs[0];
+		if (ocfs2_is_empty_extent(rec)) {
+			if (le16_to_cpu(new_el->l_next_free_rec) <= 1) {
+				bh = path_leaf_bh(right_path);
+				eb = (struct ocfs2_extent_block *)bh->b_data;
+				OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb,
+								 eb);
+				goto out;
+			}
+			rec = &new_el->l_recs[1];
+		}
+	}
+
+	if (rec) {
@@ -3526 +3881,0 @@
-		rec = &el->l_recs[index + 1];
@@ -3534,0 +3890,6 @@
+out:
+	if (left_path)
+		ocfs2_free_path(left_path);
+	if (right_path)
+		ocfs2_free_path(right_path);
+
@@ -3997 +4358 @@
-	ctxt.c_contig_type = ocfs2_figure_merge_contig_type(inode, el,
+	ctxt.c_contig_type = ocfs2_figure_merge_contig_type(inode, path, el,
@@ -4790,0 +5152,2 @@
+	else
+		ocfs2_init_inode_steal_slot(osb);
--- ./projects/linux/linux-2.6.27/fs/ocfs2/alloc.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/fs/ocfs2/alloc.c	2008-12-25 00:26:37.000000000 +0100
@@ -51,0 +52,334 @@
+
+/*
+ * Operations for a specific extent tree type.
+ *
+ * To implement an on-disk btree (extent tree) type in ocfs2, add
+ * an ocfs2_extent_tree_operations structure and the matching
+ * ocfs2_init_<thingy>_extent_tree() function.  That's pretty much it
+ * for the allocation portion of the extent tree.
+ */
+struct ocfs2_extent_tree_operations {
+	/*
+	 * last_eb_blk is the block number of the right most leaf extent
+	 * block.  Most on-disk structures containing an extent tree store
+	 * this value for fast access.  The ->eo_set_last_eb_blk() and
+	 * ->eo_get_last_eb_blk() operations access this value.  They are
+	 *  both required.
+	 */
+	void (*eo_set_last_eb_blk)(struct ocfs2_extent_tree *et,
+				   u64 blkno);
+	u64 (*eo_get_last_eb_blk)(struct ocfs2_extent_tree *et);
+
+	/*
+	 * The on-disk structure usually keeps track of how many total
+	 * clusters are stored in this extent tree.  This function updates
+	 * that value.  new_clusters is the delta, and must be
+	 * added to the total.  Required.
+	 */
+	void (*eo_update_clusters)(struct inode *inode,
+				   struct ocfs2_extent_tree *et,
+				   u32 new_clusters);
+
+	/*
+	 * If ->eo_insert_check() exists, it is called before rec is
+	 * inserted into the extent tree.  It is optional.
+	 */
+	int (*eo_insert_check)(struct inode *inode,
+			       struct ocfs2_extent_tree *et,
+			       struct ocfs2_extent_rec *rec);
+	int (*eo_sanity_check)(struct inode *inode, struct ocfs2_extent_tree *et);
+
+	/*
+	 * --------------------------------------------------------------
+	 * The remaining are internal to ocfs2_extent_tree and don't have
+	 * accessor functions
+	 */
+
+	/*
+	 * ->eo_fill_root_el() takes et->et_object and sets et->et_root_el.
+	 * It is required.
+	 */
+	void (*eo_fill_root_el)(struct ocfs2_extent_tree *et);
+
+	/*
+	 * ->eo_fill_max_leaf_clusters sets et->et_max_leaf_clusters if
+	 * it exists.  If it does not, et->et_max_leaf_clusters is set
+	 * to 0 (unlimited).  Optional.
+	 */
+	void (*eo_fill_max_leaf_clusters)(struct inode *inode,
+					  struct ocfs2_extent_tree *et);
+};
+
+
+/*
+ * Pre-declare ocfs2_dinode_et_ops so we can use it as a sanity check
+ * in the methods.
+ */
+static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et);
+static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,
+					 u64 blkno);
+static void ocfs2_dinode_update_clusters(struct inode *inode,
+					 struct ocfs2_extent_tree *et,
+					 u32 clusters);
+static int ocfs2_dinode_insert_check(struct inode *inode,
+				     struct ocfs2_extent_tree *et,
+				     struct ocfs2_extent_rec *rec);
+static int ocfs2_dinode_sanity_check(struct inode *inode,
+				     struct ocfs2_extent_tree *et);
+static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et);
+static struct ocfs2_extent_tree_operations ocfs2_dinode_et_ops = {
+	.eo_set_last_eb_blk	= ocfs2_dinode_set_last_eb_blk,
+	.eo_get_last_eb_blk	= ocfs2_dinode_get_last_eb_blk,
+	.eo_update_clusters	= ocfs2_dinode_update_clusters,
+	.eo_insert_check	= ocfs2_dinode_insert_check,
+	.eo_sanity_check	= ocfs2_dinode_sanity_check,
+	.eo_fill_root_el	= ocfs2_dinode_fill_root_el,
+};
+
+static void ocfs2_dinode_set_last_eb_blk(struct ocfs2_extent_tree *et,
+					 u64 blkno)
+{
+	struct ocfs2_dinode *di = et->et_object;
+
+	BUG_ON(et->et_ops != &ocfs2_dinode_et_ops);
+	di->i_last_eb_blk = cpu_to_le64(blkno);
+}
+
+static u64 ocfs2_dinode_get_last_eb_blk(struct ocfs2_extent_tree *et)
+{
+	struct ocfs2_dinode *di = et->et_object;
+
+	BUG_ON(et->et_ops != &ocfs2_dinode_et_ops);
+	return le64_to_cpu(di->i_last_eb_blk);
+}
+
+static void ocfs2_dinode_update_clusters(struct inode *inode,
+					 struct ocfs2_extent_tree *et,
+					 u32 clusters)
+{
+	struct ocfs2_dinode *di = et->et_object;
+
+	le32_add_cpu(&di->i_clusters, clusters);
+	spin_lock(&OCFS2_I(inode)->ip_lock);
+	OCFS2_I(inode)->ip_clusters = le32_to_cpu(di->i_clusters);
+	spin_unlock(&OCFS2_I(inode)->ip_lock);
+}
+
+static int ocfs2_dinode_insert_check(struct inode *inode,
+				     struct ocfs2_extent_tree *et,
+				     struct ocfs2_extent_rec *rec)
+{
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+
+	BUG_ON(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL);
+	mlog_bug_on_msg(!ocfs2_sparse_alloc(osb) &&
+			(OCFS2_I(inode)->ip_clusters != rec->e_cpos),
+			"Device %s, asking for sparse allocation: inode %llu, "
+			"cpos %u, clusters %u\n",
+			osb->dev_str,
+			(unsigned long long)OCFS2_I(inode)->ip_blkno,
+			rec->e_cpos,
+			OCFS2_I(inode)->ip_clusters);
+
+	return 0;
+}
+
+static int ocfs2_dinode_sanity_check(struct inode *inode,
+				     struct ocfs2_extent_tree *et)
+{
+	int ret = 0;
+	struct ocfs2_dinode *di;
+
+	BUG_ON(et->et_ops != &ocfs2_dinode_et_ops);
+
+	di = et->et_object;
+	if (!OCFS2_IS_VALID_DINODE(di)) {
+		ret = -EIO;
+		ocfs2_error(inode->i_sb,
+			"Inode %llu has invalid path root",
+			(unsigned long long)OCFS2_I(inode)->ip_blkno);
+	}
+
+	return ret;
+}
+
+static void ocfs2_dinode_fill_root_el(struct ocfs2_extent_tree *et)
+{
+	struct ocfs2_dinode *di = et->et_object;
+
+	et->et_root_el = &di->id2.i_list;
+}
+
+
+static void ocfs2_xattr_value_fill_root_el(struct ocfs2_extent_tree *et)
+{
+	struct ocfs2_xattr_value_root *xv = et->et_object;
+
+	et->et_root_el = &xv->xr_list;
+}
+
+static void ocfs2_xattr_value_set_last_eb_blk(struct ocfs2_extent_tree *et,
+					      u64 blkno)
+{
+	struct ocfs2_xattr_value_root *xv =
+		(struct ocfs2_xattr_value_root *)et->et_object;
+
+	xv->xr_last_eb_blk = cpu_to_le64(blkno);
+}
+
+static u64 ocfs2_xattr_value_get_last_eb_blk(struct ocfs2_extent_tree *et)
+{
+	struct ocfs2_xattr_value_root *xv =
+		(struct ocfs2_xattr_value_root *) et->et_object;
+
+	return le64_to_cpu(xv->xr_last_eb_blk);
+}
+
+static void ocfs2_xattr_value_update_clusters(struct inode *inode,
+					      struct ocfs2_extent_tree *et,
+					      u32 clusters)
+{
+	struct ocfs2_xattr_value_root *xv =
+		(struct ocfs2_xattr_value_root *)et->et_object;
+
+	le32_add_cpu(&xv->xr_clusters, clusters);
+}
+
+static struct ocfs2_extent_tree_operations ocfs2_xattr_value_et_ops = {
+	.eo_set_last_eb_blk	= ocfs2_xattr_value_set_last_eb_blk,
+	.eo_get_last_eb_blk	= ocfs2_xattr_value_get_last_eb_blk,
+	.eo_update_clusters	= ocfs2_xattr_value_update_clusters,
+	.eo_fill_root_el	= ocfs2_xattr_value_fill_root_el,
+};
+
+static void ocfs2_xattr_tree_fill_root_el(struct ocfs2_extent_tree *et)
+{
+	struct ocfs2_xattr_block *xb = et->et_object;
+
+	et->et_root_el = &xb->xb_attrs.xb_root.xt_list;
+}
+
+static void ocfs2_xattr_tree_fill_max_leaf_clusters(struct inode *inode,
+						    struct ocfs2_extent_tree *et)
+{
+	et->et_max_leaf_clusters =
+		ocfs2_clusters_for_bytes(inode->i_sb,
+					 OCFS2_MAX_XATTR_TREE_LEAF_SIZE);
+}
+
+static void ocfs2_xattr_tree_set_last_eb_blk(struct ocfs2_extent_tree *et,
+					     u64 blkno)
+{
+	struct ocfs2_xattr_block *xb = et->et_object;
+	struct ocfs2_xattr_tree_root *xt = &xb->xb_attrs.xb_root;
+
+	xt->xt_last_eb_blk = cpu_to_le64(blkno);
+}
+
+static u64 ocfs2_xattr_tree_get_last_eb_blk(struct ocfs2_extent_tree *et)
+{
+	struct ocfs2_xattr_block *xb = et->et_object;
+	struct ocfs2_xattr_tree_root *xt = &xb->xb_attrs.xb_root;
+
+	return le64_to_cpu(xt->xt_last_eb_blk);
+}
+
+static void ocfs2_xattr_tree_update_clusters(struct inode *inode,
+					     struct ocfs2_extent_tree *et,
+					     u32 clusters)
+{
+	struct ocfs2_xattr_block *xb = et->et_object;
+
+	le32_add_cpu(&xb->xb_attrs.xb_root.xt_clusters, clusters);
+}
+
+static struct ocfs2_extent_tree_operations ocfs2_xattr_tree_et_ops = {
+	.eo_set_last_eb_blk	= ocfs2_xattr_tree_set_last_eb_blk,
+	.eo_get_last_eb_blk	= ocfs2_xattr_tree_get_last_eb_blk,
+	.eo_update_clusters	= ocfs2_xattr_tree_update_clusters,
+	.eo_fill_root_el	= ocfs2_xattr_tree_fill_root_el,
+	.eo_fill_max_leaf_clusters = ocfs2_xattr_tree_fill_max_leaf_clusters,
+};
+
+static void __ocfs2_init_extent_tree(struct ocfs2_extent_tree *et,
+				     struct inode *inode,
+				     struct buffer_head *bh,
+				     void *obj,
+				     struct ocfs2_extent_tree_operations *ops)
+{
+	et->et_ops = ops;
+	et->et_root_bh = bh;
+	if (!obj)
+		obj = (void *)bh->b_data;
+	et->et_object = obj;
+
+	et->et_ops->eo_fill_root_el(et);
+	if (!et->et_ops->eo_fill_max_leaf_clusters)
+		et->et_max_leaf_clusters = 0;
+	else
+		et->et_ops->eo_fill_max_leaf_clusters(inode, et);
+}
+
+void ocfs2_init_dinode_extent_tree(struct ocfs2_extent_tree *et,
+				   struct inode *inode,
+				   struct buffer_head *bh)
+{
+	__ocfs2_init_extent_tree(et, inode, bh, NULL, &ocfs2_dinode_et_ops);
+}
+
+void ocfs2_init_xattr_tree_extent_tree(struct ocfs2_extent_tree *et,
+				       struct inode *inode,
+				       struct buffer_head *bh)
+{
+	__ocfs2_init_extent_tree(et, inode, bh, NULL,
+				 &ocfs2_xattr_tree_et_ops);
+}
+
+void ocfs2_init_xattr_value_extent_tree(struct ocfs2_extent_tree *et,
+					struct inode *inode,
+					struct buffer_head *bh,
+					struct ocfs2_xattr_value_root *xv)
+{
+	__ocfs2_init_extent_tree(et, inode, bh, xv,
+				 &ocfs2_xattr_value_et_ops);
+}
+
+static inline void ocfs2_et_set_last_eb_blk(struct ocfs2_extent_tree *et,
+					    u64 new_last_eb_blk)
+{
+	et->et_ops->eo_set_last_eb_blk(et, new_last_eb_blk);
+}
+
+static inline u64 ocfs2_et_get_last_eb_blk(struct ocfs2_extent_tree *et)
+{
+	return et->et_ops->eo_get_last_eb_blk(et);
+}
+
+static inline void ocfs2_et_update_clusters(struct inode *inode,
+					    struct ocfs2_extent_tree *et,
+					    u32 clusters)
+{
+	et->et_ops->eo_update_clusters(inode, et, clusters);
+}
+
+static inline int ocfs2_et_insert_check(struct inode *inode,
+					struct ocfs2_extent_tree *et,
+					struct ocfs2_extent_rec *rec)
+{
+	int ret = 0;
+
+	if (et->et_ops->eo_insert_check)
+		ret = et->et_ops->eo_insert_check(inode, et, rec);
+	return ret;
+}
+
+static inline int ocfs2_et_sanity_check(struct inode *inode,
+					struct ocfs2_extent_tree *et)
+{
+	int ret = 0;
+
+	if (et->et_ops->eo_sanity_check)
+		ret = et->et_ops->eo_sanity_check(inode, et);
+	return ret;
+}
+
@@ -208,11 +541,0 @@
- * Allocate and initialize a new path based on a disk inode tree.
- */
-static struct ocfs2_path *ocfs2_new_inode_path(struct buffer_head *di_bh)
-{
-	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
-	struct ocfs2_extent_list *el = &di->id2.i_list;
-
-	return ocfs2_new_path(di_bh, el);
-}
-
-/*
@@ -371 +694 @@
-			   struct ocfs2_dinode *fe)
+			   struct ocfs2_extent_tree *et)
@@ -374 +697 @@
-	struct ocfs2_extent_list *el;
+	struct ocfs2_extent_list *el = NULL;
@@ -376,0 +700 @@
+	u64 last_eb_blk = 0;
@@ -380,5 +704,2 @@
-	if (!OCFS2_IS_VALID_DINODE(fe)) {
-		OCFS2_RO_ON_INVALID_DINODE(inode->i_sb, fe);
-		retval = -EIO;
-		goto bail;
-	}
+	el = et->et_root_el;
+	last_eb_blk = ocfs2_et_get_last_eb_blk(et);
@@ -386,3 +707,3 @@
-	if (fe->i_last_eb_blk) {
-		retval = ocfs2_read_block(osb, le64_to_cpu(fe->i_last_eb_blk),
-					  &eb_bh, OCFS2_BH_CACHED, inode);
+	if (last_eb_blk) {
+		retval = ocfs2_read_block(inode, last_eb_blk,
+					  &eb_bh);
@@ -395,2 +716 @@
-	} else
-		el = &fe->id2.i_list;
+	}
@@ -402,2 +722 @@
-	if (eb_bh)
-		brelse(eb_bh);
+	brelse(eb_bh);
@@ -489,2 +808 @@
-			if (bhs[i])
-				brelse(bhs[i]);
+			brelse(bhs[i]);
@@ -534 +852 @@
-			    struct buffer_head *fe_bh,
+			    struct ocfs2_extent_tree *et,
@@ -543 +860,0 @@
-	struct ocfs2_dinode *fe;
@@ -553,2 +869,0 @@
-	fe = (struct ocfs2_dinode *) fe_bh->b_data;
-
@@ -559 +874 @@
-		el = &fe->id2.i_list;
+		el = et->et_root_el;
@@ -649 +964 @@
-	status = ocfs2_journal_access(handle, inode, fe_bh,
+	status = ocfs2_journal_access(handle, inode, et->et_root_bh,
@@ -665 +980 @@
-	 * either be on the fe, or the extent block passed in. */
+	 * either be on the root_bh, or the extent block passed in. */
@@ -674 +989 @@
-	fe->i_last_eb_blk = cpu_to_le64(new_last_eb_blk);
+	ocfs2_et_set_last_eb_blk(et, new_last_eb_blk);
@@ -682 +997 @@
-	status = ocfs2_journal_dirty(handle, fe_bh);
+	status = ocfs2_journal_dirty(handle, et->et_root_bh);
@@ -703,2 +1018 @@
-			if (new_eb_bhs[i])
-				brelse(new_eb_bhs[i]);
+			brelse(new_eb_bhs[i]);
@@ -720 +1034 @@
-				  struct buffer_head *fe_bh,
+				  struct ocfs2_extent_tree *et,
@@ -727 +1040,0 @@
-	struct ocfs2_dinode *fe;
@@ -729 +1042 @@
-	struct ocfs2_extent_list  *fe_el;
+	struct ocfs2_extent_list  *root_el;
@@ -749,2 +1062 @@
-	fe = (struct ocfs2_dinode *) fe_bh->b_data;
-	fe_el = &fe->id2.i_list;
+	root_el = et->et_root_el;
@@ -759,5 +1071,5 @@
-	/* copy the fe data into the new extent block */
-	eb_el->l_tree_depth = fe_el->l_tree_depth;
-	eb_el->l_next_free_rec = fe_el->l_next_free_rec;
-	for(i = 0; i < le16_to_cpu(fe_el->l_next_free_rec); i++)
-		eb_el->l_recs[i] = fe_el->l_recs[i];
+	/* copy the root extent list data into the new extent block */
+	eb_el->l_tree_depth = root_el->l_tree_depth;
+	eb_el->l_next_free_rec = root_el->l_next_free_rec;
+	for (i = 0; i < le16_to_cpu(root_el->l_next_free_rec); i++)
+		eb_el->l_recs[i] = root_el->l_recs[i];
@@ -771 +1083 @@
-	status = ocfs2_journal_access(handle, inode, fe_bh,
+	status = ocfs2_journal_access(handle, inode, et->et_root_bh,
@@ -780,8 +1092,8 @@
-	/* update fe now */
-	le16_add_cpu(&fe_el->l_tree_depth, 1);
-	fe_el->l_recs[0].e_cpos = 0;
-	fe_el->l_recs[0].e_blkno = eb->h_blkno;
-	fe_el->l_recs[0].e_int_clusters = cpu_to_le32(new_clusters);
-	for(i = 1; i < le16_to_cpu(fe_el->l_next_free_rec); i++)
-		memset(&fe_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));
-	fe_el->l_next_free_rec = cpu_to_le16(1);
+	/* update root_bh now */
+	le16_add_cpu(&root_el->l_tree_depth, 1);
+	root_el->l_recs[0].e_cpos = 0;
+	root_el->l_recs[0].e_blkno = eb->h_blkno;
+	root_el->l_recs[0].e_int_clusters = cpu_to_le32(new_clusters);
+	for (i = 1; i < le16_to_cpu(root_el->l_next_free_rec); i++)
+		memset(&root_el->l_recs[i], 0, sizeof(struct ocfs2_extent_rec));
+	root_el->l_next_free_rec = cpu_to_le16(1);
@@ -791,2 +1103,2 @@
-	if (fe_el->l_tree_depth == cpu_to_le16(1))
-		fe->i_last_eb_blk = eb->h_blkno;
+	if (root_el->l_tree_depth == cpu_to_le16(1))
+		ocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));
@@ -794 +1106 @@
-	status = ocfs2_journal_dirty(handle, fe_bh);
+	status = ocfs2_journal_dirty(handle, et->et_root_bh);
@@ -804,2 +1116 @@
-	if (new_eb_bh)
-		brelse(new_eb_bh);
+	brelse(new_eb_bh);
@@ -820 +1131 @@
- * 2) the search fails to find anything, but the dinode has room. We
+ * 2) the search fails to find anything, but the root_el has room. We
@@ -823 +1134 @@
- * 3) the search fails to find anything AND the dinode is full, in
+ * 3) the search fails to find anything AND the root_el is full, in
@@ -830 +1141 @@
-				    struct buffer_head *fe_bh,
+				    struct ocfs2_extent_tree *et,
@@ -835 +1145,0 @@
-	struct ocfs2_dinode *fe;
@@ -845,2 +1155 @@
-	fe = (struct ocfs2_dinode *) fe_bh->b_data;
-	el = &fe->id2.i_list;
+	el = et->et_root_el;
@@ -867,4 +1176,2 @@
-		if (bh) {
-			brelse(bh);
-			bh = NULL;
-		}
+		brelse(bh);
+		bh = NULL;
@@ -872,2 +1179 @@
-		status = ocfs2_read_block(osb, blkno, &bh, OCFS2_BH_CACHED,
-					  inode);
+		status = ocfs2_read_block(inode, blkno, &bh);
@@ -889,2 +1195 @@
-			if (lowest_bh)
-				brelse(lowest_bh);
+			brelse(lowest_bh);
@@ -898,2 +1203,2 @@
-	if (!lowest_bh
-	    && (fe->id2.i_list.l_next_free_rec == fe->id2.i_list.l_count))
+	el = et->et_root_el;
+	if (!lowest_bh && (el->l_next_free_rec == el->l_count))
@@ -904,2 +1209 @@
-	if (bh)
-		brelse(bh);
+	brelse(bh);
@@ -922 +1226 @@
-			   struct buffer_head *di_bh, int *final_depth,
+			   struct ocfs2_extent_tree *et, int *final_depth,
@@ -927,2 +1231,2 @@
-	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
-	int depth = le16_to_cpu(di->id2.i_list.l_tree_depth);
+	struct ocfs2_extent_list *el = et->et_root_el;
+	int depth = le16_to_cpu(el->l_tree_depth);
@@ -934 +1238 @@
-	shift = ocfs2_find_branch_target(osb, inode, di_bh, &bh);
+	shift = ocfs2_find_branch_target(osb, inode, et, &bh);
@@ -951 +1255 @@
-		ret = ocfs2_shift_tree_depth(osb, handle, inode, di_bh,
+		ret = ocfs2_shift_tree_depth(osb, handle, inode, et,
@@ -978 +1282 @@
-	ret = ocfs2_add_branch(osb, handle, inode, di_bh, bh, last_eb_bh,
+	ret = ocfs2_add_branch(osb, handle, inode, et, bh, last_eb_bh,
@@ -993,9 +1296,0 @@
- * This is only valid for leaf nodes, which are the only ones that can
- * have empty extents anyway.
- */
-static inline int ocfs2_is_empty_extent(struct ocfs2_extent_rec *rec)
-{
-	return !rec->e_leaf_clusters;
-}
-
-/*
@@ -1248,2 +1543 @@
-		ret = ocfs2_read_block(OCFS2_SB(inode->i_sb), blkno,
-				       &bh, OCFS2_BH_CACHED, inode);
+		ret = ocfs2_read_block(inode, blkno, &bh);
@@ -2070 +2364,2 @@
-				     int *deleted)
+				     int *deleted,
+				     struct ocfs2_extent_tree *et)
@@ -2073,2 +2368 @@
-	struct buffer_head *root_bh, *di_bh = path_root_bh(right_path);
-	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
+	struct buffer_head *root_bh, *et_root_bh = path_root_bh(right_path);
@@ -2126 +2420 @@
-		ret = ocfs2_journal_access(handle, inode, di_bh,
+		ret = ocfs2_journal_access(handle, inode, et_root_bh,
@@ -2201 +2495 @@
-		di->i_last_eb_blk = eb->h_blkno;
+		ocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));
@@ -2211 +2505 @@
-		ret = ocfs2_journal_dirty(handle, di_bh);
+		ret = ocfs2_journal_dirty(handle, et_root_bh);
@@ -2334 +2628,2 @@
-				    struct ocfs2_path **empty_extent_path)
+				    struct ocfs2_path **empty_extent_path,
+				    struct ocfs2_extent_tree *et)
@@ -2407 +2702 @@
-						dealloc, &deleted);
+						dealloc, &deleted, et);
@@ -2450,2 +2745,3 @@
-				       struct ocfs2_path *path,
-				       struct ocfs2_cached_dealloc_ctxt *dealloc)
+				struct ocfs2_path *path,
+				struct ocfs2_cached_dealloc_ctxt *dealloc,
+				struct ocfs2_extent_tree *et)
@@ -2456 +2751,0 @@
-	struct ocfs2_dinode *di;
@@ -2460,12 +2754,0 @@
-	/*
-	 * XXX: This code assumes that the root is an inode, which is
-	 * true for now but may change as tree code gets generic.
-	 */
-	di = (struct ocfs2_dinode *)path_root_bh(path)->b_data;
-	if (!OCFS2_IS_VALID_DINODE(di)) {
-		ret = -EIO;
-		ocfs2_error(inode->i_sb,
-			    "Inode %llu has invalid path root",
-			    (unsigned long long)OCFS2_I(inode)->ip_blkno);
-		goto out;
-	}
@@ -2472,0 +2756,3 @@
+	ret = ocfs2_et_sanity_check(inode, et);
+	if (ret)
+		goto out;
@@ -2529 +2815 @@
-		di->i_last_eb_blk = eb->h_blkno;
+		ocfs2_et_set_last_eb_blk(et, le64_to_cpu(eb->h_blkno));
@@ -2540 +2826 @@
-		el = &di->id2.i_list;
+		el = et->et_root_el;
@@ -2545 +2831 @@
-		di->i_last_eb_blk = 0;
+		ocfs2_et_set_last_eb_blk(et, 0);
@@ -2573 +2859,2 @@
-				  struct ocfs2_cached_dealloc_ctxt *dealloc)
+				  struct ocfs2_cached_dealloc_ctxt *dealloc,
+				  struct ocfs2_extent_tree *et)
@@ -2587 +2874 @@
-		 * In-inode extents. This is trivially handled, so do
+		 * Inline extents. This is trivially handled, so do
@@ -2641 +2928 @@
-						  dealloc);
+						  dealloc, et);
@@ -2653 +2940 @@
-				       dealloc, &restart_path);
+				       dealloc, &restart_path, et);
@@ -2665 +2952 @@
-					       &restart_path);
+					       &restart_path, et);
@@ -2950,0 +3238 @@
+				struct ocfs2_extent_tree *et,
@@ -3071 +3359,2 @@
-							  right_path, dealloc);
+							  right_path,
+							  dealloc, et);
@@ -3098 +3387,2 @@
-				     struct ocfs2_merge_ctxt *ctxt)
+				     struct ocfs2_merge_ctxt *ctxt,
+				     struct ocfs2_extent_tree *et)
@@ -3116 +3406 @@
-					     dealloc);
+					     dealloc, et);
@@ -3159 +3449,2 @@
-		ret = ocfs2_rotate_tree_left(inode, handle, path, dealloc);
+		ret = ocfs2_rotate_tree_left(inode, handle, path,
+					     dealloc, et);
@@ -3173 +3464 @@
-					   dealloc,
+					   dealloc, et,
@@ -3182 +3473 @@
-					     dealloc);
+					     dealloc, et);
@@ -3202 +3493 @@
-						   dealloc,
+						   dealloc, et,
@@ -3225 +3516 @@
-						     dealloc);
+						     dealloc, et);
@@ -3359,10 +3649,0 @@
-static inline void ocfs2_update_dinode_clusters(struct inode *inode,
-						struct ocfs2_dinode *di,
-						u32 clusters)
-{
-	le32_add_cpu(&di->i_clusters, clusters);
-	spin_lock(&OCFS2_I(inode)->ip_lock);
-	OCFS2_I(inode)->ip_clusters = le32_to_cpu(di->i_clusters);
-	spin_unlock(&OCFS2_I(inode)->ip_lock);
-}
-
@@ -3570,2 +3851,2 @@
- * This function only does inserts on an allocation b-tree. For dinode
- * lists, ocfs2_insert_at_leaf() is called directly.
+ * This function only does inserts on an allocation b-tree. For tree
+ * depth = 0, ocfs2_insert_at_leaf() is called directly.
@@ -3668 +3949 @@
-				  struct buffer_head *di_bh,
+				  struct ocfs2_extent_tree *et,
@@ -3676 +3956,0 @@
-	struct ocfs2_dinode *di;
@@ -3679,2 +3959 @@
-	di = (struct ocfs2_dinode *) di_bh->b_data;
-	el = &di->id2.i_list;
+	el = et->et_root_el;
@@ -3682 +3961 @@
-	ret = ocfs2_journal_access(handle, inode, di_bh,
+	ret = ocfs2_journal_access(handle, inode, et->et_root_bh,
@@ -3694 +3973 @@
-	right_path = ocfs2_new_inode_path(di_bh);
+	right_path = ocfs2_new_path(et->et_root_bh, et->et_root_el);
@@ -3744 +4023 @@
-		ret = ocfs2_journal_access(handle, inode, di_bh,
+		ret = ocfs2_journal_access(handle, inode, et->et_root_bh,
@@ -3769,2 +4048,2 @@
-		ocfs2_update_dinode_clusters(inode, di,
-					     le16_to_cpu(insert_rec->e_leaf_clusters));
+		ocfs2_et_update_clusters(inode, et,
+					 le16_to_cpu(insert_rec->e_leaf_clusters));
@@ -3772 +4051 @@
-	ret = ocfs2_journal_dirty(handle, di_bh);
+	ret = ocfs2_journal_dirty(handle, et->et_root_bh);
@@ -3902 +4181,2 @@
-				     struct ocfs2_extent_rec *insert_rec)
+				     struct ocfs2_extent_rec *insert_rec,
+				     struct ocfs2_extent_tree *et)
@@ -3917,0 +4198,15 @@
+
+	if (insert->ins_contig != CONTIG_NONE) {
+		struct ocfs2_extent_rec *rec =
+				&el->l_recs[insert->ins_contig_index];
+		unsigned int len = le16_to_cpu(rec->e_leaf_clusters) +
+				   le16_to_cpu(insert_rec->e_leaf_clusters);
+
+		/*
+		 * Caller might want us to limit the size of extents, don't
+		 * calculate contiguousness if we might exceed that limit.
+		 */
+		if (et->et_max_leaf_clusters &&
+		    (len > et->et_max_leaf_clusters))
+			insert->ins_contig = CONTIG_NONE;
+	}
@@ -3926,2 +4221,2 @@
- * This should also work against the dinode list for tree's with 0
- * depth. If we consider the dinode list to be the rightmost leaf node
+ * This should also work against the root extent list for tree's with 0
+ * depth. If we consider the root extent list to be the rightmost leaf node
@@ -3978 +4273 @@
-				    struct buffer_head *di_bh,
+				    struct ocfs2_extent_tree *et,
@@ -3985 +4279,0 @@
-	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
@@ -3993 +4287 @@
-	el = &di->id2.i_list;
+	el = et->et_root_el;
@@ -4003,3 +4297 @@
-		ret = ocfs2_read_block(OCFS2_SB(inode->i_sb),
-				       le64_to_cpu(di->i_last_eb_blk), &bh,
-				       OCFS2_BH_CACHED, inode);
+		ret = ocfs2_read_block(inode, ocfs2_et_get_last_eb_blk(et), &bh);
@@ -4026 +4318 @@
-		ocfs2_figure_contig_type(inode, insert, el, insert_rec);
+		ocfs2_figure_contig_type(inode, insert, el, insert_rec, et);
@@ -4031 +4323 @@
-	path = ocfs2_new_inode_path(di_bh);
+	path = ocfs2_new_path(et->et_root_bh, et->et_root_el);
@@ -4060 +4352 @@
-	ocfs2_figure_contig_type(inode, insert, el, insert_rec);
+	ocfs2_figure_contig_type(inode, insert, el, insert_rec, et);
@@ -4081 +4373,2 @@
-	if (le64_to_cpu(di->i_last_eb_blk) == path_leaf_bh(path)->b_blocknr) {
+	if (ocfs2_et_get_last_eb_blk(et) ==
+	    path_leaf_bh(path)->b_blocknr) {
@@ -4111 +4404 @@
-			struct buffer_head *fe_bh,
+			struct ocfs2_extent_tree *et,
@@ -4124,2 +4416,0 @@
-	BUG_ON(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL);
-
@@ -4129,8 +4419,0 @@
-	mlog_bug_on_msg(!ocfs2_sparse_alloc(osb) &&
-			(OCFS2_I(inode)->ip_clusters != cpos),
-			"Device %s, asking for sparse allocation: inode %llu, "
-			"cpos %u, clusters %u\n",
-			osb->dev_str,
-			(unsigned long long)OCFS2_I(inode)->ip_blkno, cpos,
-			OCFS2_I(inode)->ip_clusters);
-
@@ -4141,0 +4425,5 @@
+	status = ocfs2_et_insert_check(inode, et, &rec);
+	if (status) {
+		mlog_errno(status);
+		goto bail;
+	}
@@ -4143 +4431 @@
-	status = ocfs2_figure_insert_type(inode, fe_bh, &last_eb_bh, &rec,
+	status = ocfs2_figure_insert_type(inode, et, &last_eb_bh, &rec,
@@ -4157 +4445 @@
-		status = ocfs2_grow_tree(inode, handle, fe_bh,
+		status = ocfs2_grow_tree(inode, handle, et,
@@ -4167 +4455 @@
-	status = ocfs2_do_insert_extent(inode, handle, fe_bh, &rec, &insert);
+	status = ocfs2_do_insert_extent(inode, handle, et, &rec, &insert);
@@ -4170 +4458 @@
-	else
+	else if (et->et_ops == &ocfs2_dinode_et_ops)
@@ -4174,2 +4462 @@
-	if (last_eb_bh)
-		brelse(last_eb_bh);
+	brelse(last_eb_bh);
@@ -4180,0 +4468,108 @@
+/*
+ * Allcate and add clusters into the extent b-tree.
+ * The new clusters(clusters_to_add) will be inserted at logical_offset.
+ * The extent b-tree's root is specified by et, and
+ * it is not limited to the file storage. Any extent tree can use this
+ * function if it implements the proper ocfs2_extent_tree.
+ */
+int ocfs2_add_clusters_in_btree(struct ocfs2_super *osb,
+				struct inode *inode,
+				u32 *logical_offset,
+				u32 clusters_to_add,
+				int mark_unwritten,
+				struct ocfs2_extent_tree *et,
+				handle_t *handle,
+				struct ocfs2_alloc_context *data_ac,
+				struct ocfs2_alloc_context *meta_ac,
+				enum ocfs2_alloc_restarted *reason_ret)
+{
+	int status = 0;
+	int free_extents;
+	enum ocfs2_alloc_restarted reason = RESTART_NONE;
+	u32 bit_off, num_bits;
+	u64 block;
+	u8 flags = 0;
+
+	BUG_ON(!clusters_to_add);
+
+	if (mark_unwritten)
+		flags = OCFS2_EXT_UNWRITTEN;
+
+	free_extents = ocfs2_num_free_extents(osb, inode, et);
+	if (free_extents < 0) {
+		status = free_extents;
+		mlog_errno(status);
+		goto leave;
+	}
+
+	/* there are two cases which could cause us to EAGAIN in the
+	 * we-need-more-metadata case:
+	 * 1) we haven't reserved *any*
+	 * 2) we are so fragmented, we've needed to add metadata too
+	 *    many times. */
+	if (!free_extents && !meta_ac) {
+		mlog(0, "we haven't reserved any metadata!\n");
+		status = -EAGAIN;
+		reason = RESTART_META;
+		goto leave;
+	} else if ((!free_extents)
+		   && (ocfs2_alloc_context_bits_left(meta_ac)
+		       < ocfs2_extend_meta_needed(et->et_root_el))) {
+		mlog(0, "filesystem is really fragmented...\n");
+		status = -EAGAIN;
+		reason = RESTART_META;
+		goto leave;
+	}
+
+	status = __ocfs2_claim_clusters(osb, handle, data_ac, 1,
+					clusters_to_add, &bit_off, &num_bits);
+	if (status < 0) {
+		if (status != -ENOSPC)
+			mlog_errno(status);
+		goto leave;
+	}
+
+	BUG_ON(num_bits > clusters_to_add);
+
+	/* reserve our write early -- insert_extent may update the inode */
+	status = ocfs2_journal_access(handle, inode, et->et_root_bh,
+				      OCFS2_JOURNAL_ACCESS_WRITE);
+	if (status < 0) {
+		mlog_errno(status);
+		goto leave;
+	}
+
+	block = ocfs2_clusters_to_blocks(osb->sb, bit_off);
+	mlog(0, "Allocating %u clusters at block %u for inode %llu\n",
+	     num_bits, bit_off, (unsigned long long)OCFS2_I(inode)->ip_blkno);
+	status = ocfs2_insert_extent(osb, handle, inode, et,
+				     *logical_offset, block,
+				     num_bits, flags, meta_ac);
+	if (status < 0) {
+		mlog_errno(status);
+		goto leave;
+	}
+
+	status = ocfs2_journal_dirty(handle, et->et_root_bh);
+	if (status < 0) {
+		mlog_errno(status);
+		goto leave;
+	}
+
+	clusters_to_add -= num_bits;
+	*logical_offset += num_bits;
+
+	if (clusters_to_add) {
+		mlog(0, "need to alloc once more, wanted = %u\n",
+		     clusters_to_add);
+		status = -EAGAIN;
+		reason = RESTART_TRANS;
+	}
+
+leave:
+	mlog_exit(status);
+	if (reason_ret)
+		*reason_ret = reason;
+	return status;
+}
+
@@ -4204 +4599 @@
-				  struct buffer_head *di_bh,
+				  struct ocfs2_extent_tree *et,
@@ -4218 +4612,0 @@
-	struct ocfs2_dinode *di;
@@ -4227,2 +4621 @@
-	di = (struct ocfs2_dinode *)di_bh->b_data;
-	rightmost_el = &di->id2.i_list;
+	rightmost_el = et->et_root_el;
@@ -4239,2 +4632,2 @@
-		ret = ocfs2_grow_tree(inode, handle, di_bh, &depth, last_eb_bh,
-				      meta_ac);
+		ret = ocfs2_grow_tree(inode, handle, et,
+				      &depth, last_eb_bh, meta_ac);
@@ -4277,2 +4670 @@
-	ret = ocfs2_do_insert_extent(inode, handle, di_bh, &split_rec,
-				     &insert);
+	ret = ocfs2_do_insert_extent(inode, handle, et, &split_rec, &insert);
@@ -4320,2 +4712,3 @@
- * last_eb_bh should be the rightmost leaf block for any inode with a
- * btree. Since a split may grow the tree or a merge might shrink it, the caller cannot trust the contents of that buffer after this call.
+ * last_eb_bh should be the rightmost leaf block for any extent
+ * btree. Since a split may grow the tree or a merge might shrink it,
+ * the caller cannot trust the contents of that buffer after this call.
@@ -4329 +4722 @@
-				       struct buffer_head *di_bh,
+				       struct ocfs2_extent_tree *et,
@@ -4369 +4761,0 @@
-		struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
@@ -4371,3 +4763,2 @@
-		ret = ocfs2_read_block(OCFS2_SB(inode->i_sb),
-				       le64_to_cpu(di->i_last_eb_blk),
-				       &last_eb_bh, OCFS2_BH_CACHED, inode);
+		ret = ocfs2_read_block(inode, ocfs2_et_get_last_eb_blk(et),
+				       &last_eb_bh);
@@ -4406 +4797 @@
-			ret = ocfs2_split_and_insert(inode, handle, path, di_bh,
+			ret = ocfs2_split_and_insert(inode, handle, path, et,
@@ -4414 +4805 @@
-						dealloc, &ctxt);
+						dealloc, &ctxt, et);
@@ -4432 +4823,2 @@
-int ocfs2_mark_extent_written(struct inode *inode, struct buffer_head *di_bh,
+int ocfs2_mark_extent_written(struct inode *inode,
+			      struct ocfs2_extent_tree *et,
@@ -4457,0 +4850,3 @@
+	 *
+	 * XXX: This is a hack on the extent tree, maybe it should be
+	 * an op?
@@ -4459 +4854,2 @@
-	ocfs2_extent_map_trunc(inode, 0);
+	if (et->et_ops == &ocfs2_dinode_et_ops)
+		ocfs2_extent_map_trunc(inode, 0);
@@ -4461 +4857 @@
-	left_path = ocfs2_new_inode_path(di_bh);
+	left_path = ocfs2_new_path(et->et_root_bh, et->et_root_el);
@@ -4492,2 +4888,3 @@
-	ret = __ocfs2_mark_extent_written(inode, di_bh, handle, left_path,
-					  index, &split_rec, meta_ac, dealloc);
+	ret = __ocfs2_mark_extent_written(inode, et, handle, left_path,
+					  index, &split_rec, meta_ac,
+					  dealloc);
@@ -4502 +4899 @@
-static int ocfs2_split_tree(struct inode *inode, struct buffer_head *di_bh,
+static int ocfs2_split_tree(struct inode *inode, struct ocfs2_extent_tree *et,
@@ -4508 +4904,0 @@
-	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
@@ -4525,3 +4921,2 @@
-		ret = ocfs2_read_block(OCFS2_SB(inode->i_sb),
-				       le64_to_cpu(di->i_last_eb_blk),
-				       &last_eb_bh, OCFS2_BH_CACHED, inode);
+		ret = ocfs2_read_block(inode, ocfs2_et_get_last_eb_blk(et),
+				       &last_eb_bh);
@@ -4538 +4933,2 @@
-	credits += path->p_tree_depth + ocfs2_extend_meta_needed(di);
+	credits += path->p_tree_depth +
+		   ocfs2_extend_meta_needed(et->et_root_el);
@@ -4547 +4943 @@
-		ret = ocfs2_grow_tree(inode, handle, di_bh, &depth, &last_eb_bh,
+		ret = ocfs2_grow_tree(inode, handle, et, &depth, &last_eb_bh,
@@ -4561 +4957 @@
-	ret = ocfs2_do_insert_extent(inode, handle, di_bh, &split_rec, &insert);
+	ret = ocfs2_do_insert_extent(inode, handle, et, &split_rec, &insert);
@@ -4573 +4969,2 @@
-			      u32 cpos, u32 len)
+			      u32 cpos, u32 len,
+			      struct ocfs2_extent_tree *et)
@@ -4585 +4982 @@
-		ret = ocfs2_rotate_tree_left(inode, handle, path, dealloc);
+		ret = ocfs2_rotate_tree_left(inode, handle, path, dealloc, et);
@@ -4716 +5113 @@
-	ret = ocfs2_rotate_tree_left(inode, handle, path, dealloc);
+	ret = ocfs2_rotate_tree_left(inode, handle, path, dealloc, et);
@@ -4727 +5124,2 @@
-int ocfs2_remove_extent(struct inode *inode, struct buffer_head *di_bh,
+int ocfs2_remove_extent(struct inode *inode,
+			struct ocfs2_extent_tree *et,
@@ -4736 +5134 @@
-	struct ocfs2_path *path;
+	struct ocfs2_path *path = NULL;
@@ -4740 +5138 @@
-	path = ocfs2_new_inode_path(di_bh);
+	path = ocfs2_new_path(et->et_root_bh, et->et_root_el);
@@ -4793 +5191 @@
-					 cpos, len);
+					 cpos, len, et);
@@ -4799 +5197 @@
-		ret = ocfs2_split_tree(inode, di_bh, handle, path, index,
+		ret = ocfs2_split_tree(inode, et, handle, path, index,
@@ -4848 +5246 @@
-					 cpos, len);
+					 cpos, len, et);
@@ -5191,2 +5589 @@
-	status = ocfs2_read_block(osb, OCFS2_I(inode)->ip_blkno, &bh,
-				  OCFS2_BH_CACHED, inode);
+	status = ocfs2_read_block(inode, OCFS2_I(inode)->ip_blkno, &bh);
@@ -5267,2 +5664 @@
-	if (tl_bh)
-		brelse(tl_bh);
+	brelse(tl_bh);
@@ -6011 +6407 @@
-static int ocfs2_writeback_zero_func(handle_t *handle, struct buffer_head *bh)
+static int ocfs2_zero_func(handle_t *handle, struct buffer_head *bh)
@@ -6018,7 +6413,0 @@
-static int ocfs2_ordered_zero_func(handle_t *handle, struct buffer_head *bh)
-{
-	set_buffer_uptodate(bh);
-	mark_buffer_dirty(bh);
-	return ocfs2_journal_dirty_data(handle, bh);
-}
-
@@ -6043,8 +6432,8 @@
-	if (ocfs2_should_order_data(inode)) {
-		ret = walk_page_buffers(handle,
-					page_buffers(page),
-					from, to, &partial,
-					ocfs2_ordered_zero_func);
-		if (ret < 0)
-			mlog_errno(ret);
-	} else {
+	ret = walk_page_buffers(handle, page_buffers(page),
+				from, to, &partial,
+				ocfs2_zero_func);
+	if (ret < 0)
+		mlog_errno(ret);
+	else if (ocfs2_should_order_data(inode)) {
+		ret = ocfs2_jbd2_file_inode(handle, inode);
+#ifdef CONFIG_OCFS2_COMPAT_JBD
@@ -6053 +6442,2 @@
-					ocfs2_writeback_zero_func);
+					ocfs2_journal_dirty_data);
+#endif
@@ -6218 +6608,2 @@
-static void ocfs2_zero_dinode_id2(struct inode *inode, struct ocfs2_dinode *di)
+static void ocfs2_zero_dinode_id2_with_xattr(struct inode *inode,
+					     struct ocfs2_dinode *di)
@@ -6220,0 +6612 @@
+	unsigned int xattrsize = le16_to_cpu(di->i_xattr_inline_size);
@@ -6222 +6614,7 @@
-	memset(&di->id2, 0, blocksize - offsetof(struct ocfs2_dinode, id2));
+	if (le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_XATTR_FL)
+		memset(&di->id2, 0, blocksize -
+				    offsetof(struct ocfs2_dinode, id2) -
+				    xattrsize);
+	else
+		memset(&di->id2, 0, blocksize -
+				    offsetof(struct ocfs2_dinode, id2));
@@ -6228 +6626 @@
-	ocfs2_zero_dinode_id2(inode, di);
+	ocfs2_zero_dinode_id2_with_xattr(inode, di);
@@ -6231 +6629,2 @@
-	di->id2.i_list.l_count = cpu_to_le16(ocfs2_extent_recs_per_inode(inode->i_sb));
+	di->id2.i_list.l_count = cpu_to_le16(
+		ocfs2_extent_recs_per_inode_with_xattr(inode->i_sb, di));
@@ -6248 +6647 @@
-	ocfs2_zero_dinode_id2(inode, di);
+	ocfs2_zero_dinode_id2_with_xattr(inode, di);
@@ -6250 +6649,2 @@
-	idata->id_count = cpu_to_le16(ocfs2_max_inline_data(inode->i_sb));
+	idata->id_count = cpu_to_le16(
+			ocfs2_max_inline_data_with_xattr(inode->i_sb, di));
@@ -6264,0 +6665 @@
+	struct ocfs2_extent_tree et;
@@ -6364 +6765,2 @@
-		ret = ocfs2_insert_extent(osb, handle, inode, di_bh,
+		ocfs2_init_dinode_extent_tree(&et, inode, di_bh);
+		ret = ocfs2_insert_extent(osb, handle, inode, &et,
@@ -6406,0 +6809 @@
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)fe_bh->b_data;
@@ -6413 +6816 @@
-	path = ocfs2_new_inode_path(fe_bh);
+	path = ocfs2_new_path(fe_bh, &di->id2.i_list);
@@ -6584,2 +6987,2 @@
-		status = ocfs2_read_block(osb, le64_to_cpu(fe->i_last_eb_blk),
-					  &last_eb_bh, OCFS2_BH_CACHED, inode);
+		status = ocfs2_read_block(inode, le64_to_cpu(fe->i_last_eb_blk),
+					  &last_eb_bh);
@@ -6698,2 +7101 @@
-	if (tc->tc_last_eb_bh)
-		brelse(tc->tc_last_eb_bh);
+	brelse(tc->tc_last_eb_bh);
--- ./projects/linux/linux-2.6.28/fs/ocfs2/alloc.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/fs/ocfs2/alloc.c	2009-03-24 00:12:14.000000000 +0100
@@ -30,0 +31 @@
+#include <linux/quotaops.h>
@@ -38,0 +40 @@
+#include "blockcheck.h"
@@ -48,0 +51 @@
+#include "xattr.h"
@@ -176 +179,2 @@
-			(OCFS2_I(inode)->ip_clusters != rec->e_cpos),
+			(OCFS2_I(inode)->ip_clusters !=
+			 le32_to_cpu(rec->e_cpos)),
@@ -190,2 +194 @@
-	int ret = 0;
-	struct ocfs2_dinode *di;
+	struct ocfs2_dinode *di = et->et_object;
@@ -193,0 +197 @@
+	BUG_ON(!OCFS2_IS_VALID_DINODE(di));
@@ -195,9 +199 @@
-	di = et->et_object;
-	if (!OCFS2_IS_VALID_DINODE(di)) {
-		ret = -EIO;
-		ocfs2_error(inode->i_sb,
-			"Inode %llu has invalid path root",
-			(unsigned long long)OCFS2_I(inode)->ip_blkno);
-	}
-
-	return ret;
+	return 0;
@@ -216 +212 @@
-	struct ocfs2_xattr_value_root *xv = et->et_object;
+	struct ocfs2_xattr_value_buf *vb = et->et_object;
@@ -218 +214 @@
-	et->et_root_el = &xv->xr_list;
+	et->et_root_el = &vb->vb_xv->xr_list;
@@ -224,2 +220 @@
-	struct ocfs2_xattr_value_root *xv =
-		(struct ocfs2_xattr_value_root *)et->et_object;
+	struct ocfs2_xattr_value_buf *vb = et->et_object;
@@ -227 +222 @@
-	xv->xr_last_eb_blk = cpu_to_le64(blkno);
+	vb->vb_xv->xr_last_eb_blk = cpu_to_le64(blkno);
@@ -232,2 +227 @@
-	struct ocfs2_xattr_value_root *xv =
-		(struct ocfs2_xattr_value_root *) et->et_object;
+	struct ocfs2_xattr_value_buf *vb = et->et_object;
@@ -235 +229 @@
-	return le64_to_cpu(xv->xr_last_eb_blk);
+	return le64_to_cpu(vb->vb_xv->xr_last_eb_blk);
@@ -242,2 +236 @@
-	struct ocfs2_xattr_value_root *xv =
-		(struct ocfs2_xattr_value_root *)et->et_object;
+	struct ocfs2_xattr_value_buf *vb = et->et_object;
@@ -245 +238 @@
-	le32_add_cpu(&xv->xr_clusters, clusters);
+	le32_add_cpu(&vb->vb_xv->xr_clusters, clusters);
@@ -306,0 +300 @@
+				     ocfs2_journal_access_func access,
@@ -311,0 +306 @@
+	et->et_root_journal_access = access;
@@ -327 +322,2 @@
-	__ocfs2_init_extent_tree(et, inode, bh, NULL, &ocfs2_dinode_et_ops);
+	__ocfs2_init_extent_tree(et, inode, bh, ocfs2_journal_access_di,
+				 NULL, &ocfs2_dinode_et_ops);
@@ -334,2 +330,2 @@
-	__ocfs2_init_extent_tree(et, inode, bh, NULL,
-				 &ocfs2_xattr_tree_et_ops);
+	__ocfs2_init_extent_tree(et, inode, bh, ocfs2_journal_access_xb,
+				 NULL, &ocfs2_xattr_tree_et_ops);
@@ -340,2 +336 @@
-					struct buffer_head *bh,
-					struct ocfs2_xattr_value_root *xv)
+					struct ocfs2_xattr_value_buf *vb)
@@ -343 +338 @@
-	__ocfs2_init_extent_tree(et, inode, bh, xv,
+	__ocfs2_init_extent_tree(et, inode, vb->vb_bh, vb->vb_access, vb,
@@ -364,0 +360,9 @@
+static inline int ocfs2_et_root_journal_access(handle_t *handle,
+					       struct inode *inode,
+					       struct ocfs2_extent_tree *et,
+					       int type)
+{
+	return et->et_root_journal_access(handle, inode, et->et_root_bh,
+					  type);
+}
+
@@ -405,2 +409,3 @@
-	int			p_tree_depth;
-	struct ocfs2_path_item	p_node[OCFS2_MAX_PATH_DEPTH];
+	int				p_tree_depth;
+	ocfs2_journal_access_func	p_root_access;
+	struct ocfs2_path_item		p_node[OCFS2_MAX_PATH_DEPTH];
@@ -410,0 +416 @@
+#define path_root_access(_path)((_path)->p_root_access)
@@ -442,0 +449,2 @@
+	else
+		path_root_access(path) = NULL;
@@ -467,0 +476 @@
+	BUG_ON(path_root_access(dest) != path_root_access(src));
@@ -488,0 +498 @@
+	BUG_ON(path_root_access(dest) != path_root_access(src));
@@ -524 +534,2 @@
-					 struct ocfs2_extent_list *root_el)
+					 struct ocfs2_extent_list *root_el,
+					 ocfs2_journal_access_func access)
@@ -535,0 +547 @@
+		path_root_access(path) = access;
@@ -540,0 +553,36 @@
+static struct ocfs2_path *ocfs2_new_path_from_path(struct ocfs2_path *path)
+{
+	return ocfs2_new_path(path_root_bh(path), path_root_el(path),
+			      path_root_access(path));
+}
+
+static struct ocfs2_path *ocfs2_new_path_from_et(struct ocfs2_extent_tree *et)
+{
+	return ocfs2_new_path(et->et_root_bh, et->et_root_el,
+			      et->et_root_journal_access);
+}
+
+/*
+ * Journal the buffer at depth idx.  All idx>0 are extent_blocks,
+ * otherwise it's the root_access function.
+ *
+ * I don't like the way this function's name looks next to
+ * ocfs2_journal_access_path(), but I don't have a better one.
+ */
+static int ocfs2_path_bh_journal_access(handle_t *handle,
+					struct inode *inode,
+					struct ocfs2_path *path,
+					int idx)
+{
+	ocfs2_journal_access_func access = path_root_access(path);
+
+	if (!access)
+		access = ocfs2_journal_access;
+
+	if (idx)
+		access = ocfs2_journal_access_eb;
+
+	return access(handle, inode, path->p_node[idx].bh,
+		      OCFS2_JOURNAL_ACCESS_WRITE);
+}
+
@@ -553,2 +601 @@
-		ret = ocfs2_journal_access(handle, inode, path->p_node[i].bh,
-					   OCFS2_JOURNAL_ACCESS_WRITE);
+		ret = ocfs2_path_bh_journal_access(handle, inode, path, i);
@@ -688,0 +736,74 @@
+static int ocfs2_validate_extent_block(struct super_block *sb,
+				       struct buffer_head *bh)
+{
+	int rc;
+	struct ocfs2_extent_block *eb =
+		(struct ocfs2_extent_block *)bh->b_data;
+
+	mlog(0, "Validating extent block %llu\n",
+	     (unsigned long long)bh->b_blocknr);
+
+	BUG_ON(!buffer_uptodate(bh));
+
+	/*
+	 * If the ecc fails, we return the error but otherwise
+	 * leave the filesystem running.  We know any error is
+	 * local to this block.
+	 */
+	rc = ocfs2_validate_meta_ecc(sb, bh->b_data, &eb->h_check);
+	if (rc) {
+		mlog(ML_ERROR, "Checksum failed for extent block %llu\n",
+		     (unsigned long long)bh->b_blocknr);
+		return rc;
+	}
+
+	/*
+	 * Errors after here are fatal.
+	 */
+
+	if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
+		ocfs2_error(sb,
+			    "Extent block #%llu has bad signature %.*s",
+			    (unsigned long long)bh->b_blocknr, 7,
+			    eb->h_signature);
+		return -EINVAL;
+	}
+
+	if (le64_to_cpu(eb->h_blkno) != bh->b_blocknr) {
+		ocfs2_error(sb,
+			    "Extent block #%llu has an invalid h_blkno "
+			    "of %llu",
+			    (unsigned long long)bh->b_blocknr,
+			    (unsigned long long)le64_to_cpu(eb->h_blkno));
+		return -EINVAL;
+	}
+
+	if (le32_to_cpu(eb->h_fs_generation) != OCFS2_SB(sb)->fs_generation) {
+		ocfs2_error(sb,
+			    "Extent block #%llu has an invalid "
+			    "h_fs_generation of #%u",
+			    (unsigned long long)bh->b_blocknr,
+			    le32_to_cpu(eb->h_fs_generation));
+		return -EINVAL;
+	}
+
+	return 0;
+}
+
+int ocfs2_read_extent_block(struct inode *inode, u64 eb_blkno,
+			    struct buffer_head **bh)
+{
+	int rc;
+	struct buffer_head *tmp = *bh;
+
+	rc = ocfs2_read_block(inode, eb_blkno, &tmp,
+			      ocfs2_validate_extent_block);
+
+	/* If ocfs2_read_block() got us a new bh, pass it up. */
+	if (!rc && !*bh)
+		*bh = tmp;
+
+	return rc;
+}
+
+
@@ -708,2 +829 @@
-		retval = ocfs2_read_block(inode, last_eb_blk,
-					  &eb_bh);
+		retval = ocfs2_read_extent_block(inode, last_eb_blk, &eb_bh);
@@ -771,2 +891,2 @@
-			status = ocfs2_journal_access(handle, inode, bhs[i],
-						      OCFS2_JOURNAL_ACCESS_CREATE);
+			status = ocfs2_journal_access_eb(handle, inode, bhs[i],
+							 OCFS2_JOURNAL_ACCESS_CREATE);
@@ -911,5 +1031,2 @@
-		if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
-			OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
-			status = -EIO;
-			goto bail;
-		}
+		/* ocfs2_create_new_meta_bhs() should create it right! */
+		BUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));
@@ -918,2 +1035,2 @@
-		status = ocfs2_journal_access(handle, inode, bh,
-					      OCFS2_JOURNAL_ACCESS_CREATE);
+		status = ocfs2_journal_access_eb(handle, inode, bh,
+						 OCFS2_JOURNAL_ACCESS_CREATE);
@@ -958,2 +1075,2 @@
-	status = ocfs2_journal_access(handle, inode, *last_eb_bh,
-				      OCFS2_JOURNAL_ACCESS_WRITE);
+	status = ocfs2_journal_access_eb(handle, inode, *last_eb_bh,
+					 OCFS2_JOURNAL_ACCESS_WRITE);
@@ -964,2 +1081,2 @@
-	status = ocfs2_journal_access(handle, inode, et->et_root_bh,
-				      OCFS2_JOURNAL_ACCESS_WRITE);
+	status = ocfs2_et_root_journal_access(handle, inode, et,
+					      OCFS2_JOURNAL_ACCESS_WRITE);
@@ -971,2 +1088,2 @@
-		status = ocfs2_journal_access(handle, inode, eb_bh,
-					      OCFS2_JOURNAL_ACCESS_WRITE);
+		status = ocfs2_journal_access_eb(handle, inode, eb_bh,
+						 OCFS2_JOURNAL_ACCESS_WRITE);
@@ -1055,5 +1172,2 @@
-	if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
-		OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
-		status = -EIO;
-		goto bail;
-	}
+	/* ocfs2_create_new_meta_bhs() should create it right! */
+	BUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));
@@ -1064,2 +1178,2 @@
-	status = ocfs2_journal_access(handle, inode, new_eb_bh,
-				      OCFS2_JOURNAL_ACCESS_CREATE);
+	status = ocfs2_journal_access_eb(handle, inode, new_eb_bh,
+					 OCFS2_JOURNAL_ACCESS_CREATE);
@@ -1083,2 +1197,2 @@
-	status = ocfs2_journal_access(handle, inode, et->et_root_bh,
-				      OCFS2_JOURNAL_ACCESS_WRITE);
+	status = ocfs2_et_root_journal_access(handle, inode, et,
+					      OCFS2_JOURNAL_ACCESS_WRITE);
@@ -1179 +1293 @@
-		status = ocfs2_read_block(inode, blkno, &bh);
+		status = ocfs2_read_extent_block(inode, blkno, &bh);
@@ -1186,5 +1299,0 @@
-		if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
-			OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
-			status = -EIO;
-			goto bail;
-		}
@@ -1543 +1652 @@
-		ret = ocfs2_read_block(inode, blkno, &bh);
+		ret = ocfs2_read_extent_block(inode, blkno, &bh);
@@ -1551,5 +1659,0 @@
-		if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
-			OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
-			ret = -EIO;
-			goto out;
-		}
@@ -1863,2 +1967,2 @@
-	ret = ocfs2_journal_access(handle, inode, root_bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
+	ret = ocfs2_path_bh_journal_access(handle, inode, right_path,
+					   subtree_index);
@@ -1871,3 +1975,2 @@
-		ret = ocfs2_journal_access(handle, inode,
-					   right_path->p_node[i].bh,
-					   OCFS2_JOURNAL_ACCESS_WRITE);
+		ret = ocfs2_path_bh_journal_access(handle, inode,
+						   right_path, i);
@@ -1879,3 +1982,2 @@
-		ret = ocfs2_journal_access(handle, inode,
-					   left_path->p_node[i].bh,
-					   OCFS2_JOURNAL_ACCESS_WRITE);
+		ret = ocfs2_path_bh_journal_access(handle, inode,
+						   left_path, i);
@@ -2105,2 +2207 @@
-	left_path = ocfs2_new_path(path_root_bh(right_path),
-				   path_root_el(right_path));
+	left_path = ocfs2_new_path_from_path(right_path);
@@ -2401,3 +2502,3 @@
-			ret = ocfs2_journal_access(handle, inode,
-						   path_leaf_bh(right_path),
-						   OCFS2_JOURNAL_ACCESS_WRITE);
+			ret = ocfs2_journal_access_eb(handle, inode,
+						      path_leaf_bh(right_path),
+						      OCFS2_JOURNAL_ACCESS_WRITE);
@@ -2420,2 +2521,2 @@
-		ret = ocfs2_journal_access(handle, inode, et_root_bh,
-					   OCFS2_JOURNAL_ACCESS_WRITE);
+		ret = ocfs2_et_root_journal_access(handle, inode, et,
+						   OCFS2_JOURNAL_ACCESS_WRITE);
@@ -2436,2 +2537,2 @@
-	ret = ocfs2_journal_access(handle, inode, root_bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
+	ret = ocfs2_path_bh_journal_access(handle, inode, right_path,
+					   subtree_index);
@@ -2444,3 +2545,2 @@
-		ret = ocfs2_journal_access(handle, inode,
-					   right_path->p_node[i].bh,
-					   OCFS2_JOURNAL_ACCESS_WRITE);
+		ret = ocfs2_path_bh_journal_access(handle, inode,
+						   right_path, i);
@@ -2452,3 +2552,2 @@
-		ret = ocfs2_journal_access(handle, inode,
-					   left_path->p_node[i].bh,
-					   OCFS2_JOURNAL_ACCESS_WRITE);
+		ret = ocfs2_path_bh_journal_access(handle, inode,
+						   left_path, i);
@@ -2599,2 +2698 @@
-					    struct buffer_head *bh,
-					    struct ocfs2_extent_list *el)
+					    struct ocfs2_path *path)
@@ -2602,0 +2701,2 @@
+	struct buffer_head *bh = path_leaf_bh(path);
+	struct ocfs2_extent_list *el = path_leaf_el(path);
@@ -2607,2 +2707,2 @@
-	ret = ocfs2_journal_access(handle, inode, bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
+	ret = ocfs2_path_bh_journal_access(handle, inode, path,
+					   path_num_items(path) - 1);
@@ -2647,2 +2747 @@
-	left_path = ocfs2_new_path(path_root_bh(path),
-				   path_root_el(path));
+	left_path = ocfs2_new_path_from_path(path);
@@ -2657,2 +2756 @@
-	right_path = ocfs2_new_path(path_root_bh(path),
-				    path_root_el(path));
+	right_path = ocfs2_new_path_from_path(path);
@@ -2692,3 +2790,2 @@
-		ret = ocfs2_journal_access(handle, inode,
-					   path_root_bh(left_path),
-					   OCFS2_JOURNAL_ACCESS_WRITE);
+		ret = ocfs2_path_bh_journal_access(handle, inode,
+						   left_path, 0);
@@ -2788,2 +2885 @@
-		left_path = ocfs2_new_path(path_root_bh(path),
-					   path_root_el(path));
+		left_path = ocfs2_new_path_from_path(path);
@@ -2878,2 +2974 @@
-						       path_leaf_bh(path),
-						       path_leaf_el(path));
+						       path);
@@ -3030,2 +3125 @@
-	right_path = ocfs2_new_path(path_root_bh(left_path),
-				    path_root_el(left_path));
+	right_path = ocfs2_new_path_from_path(left_path);
@@ -3114,2 +3208,2 @@
-		ret = ocfs2_journal_access(handle, inode, root_bh,
-					   OCFS2_JOURNAL_ACCESS_WRITE);
+		ret = ocfs2_path_bh_journal_access(handle, inode, right_path,
+						   subtree_index);
@@ -3123,3 +3217,2 @@
-			ret = ocfs2_journal_access(handle, inode,
-						   right_path->p_node[i].bh,
-						   OCFS2_JOURNAL_ACCESS_WRITE);
+			ret = ocfs2_path_bh_journal_access(handle, inode,
+							   right_path, i);
@@ -3131,3 +3224,2 @@
-			ret = ocfs2_journal_access(handle, inode,
-						   left_path->p_node[i].bh,
-						   OCFS2_JOURNAL_ACCESS_WRITE);
+			ret = ocfs2_path_bh_journal_access(handle, inode,
+							   left_path, i);
@@ -3145,2 +3237,2 @@
-	ret = ocfs2_journal_access(handle, inode, bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
+	ret = ocfs2_path_bh_journal_access(handle, inode, left_path,
+					   path_num_items(left_path) - 1);
@@ -3202,2 +3294 @@
-	left_path = ocfs2_new_path(path_root_bh(right_path),
-				   path_root_el(right_path));
+	left_path = ocfs2_new_path_from_path(right_path);
@@ -3286,2 +3377,2 @@
-		ret = ocfs2_journal_access(handle, inode, root_bh,
-					   OCFS2_JOURNAL_ACCESS_WRITE);
+		ret = ocfs2_path_bh_journal_access(handle, inode, right_path,
+						   subtree_index);
@@ -3295,3 +3386,2 @@
-			ret = ocfs2_journal_access(handle, inode,
-						   right_path->p_node[i].bh,
-						   OCFS2_JOURNAL_ACCESS_WRITE);
+			ret = ocfs2_path_bh_journal_access(handle, inode,
+							   right_path, i);
@@ -3303,3 +3393,2 @@
-			ret = ocfs2_journal_access(handle, inode,
-						   left_path->p_node[i].bh,
-						   OCFS2_JOURNAL_ACCESS_WRITE);
+			ret = ocfs2_path_bh_journal_access(handle, inode,
+							   left_path, i);
@@ -3317,2 +3406,2 @@
-	ret = ocfs2_journal_access(handle, inode, bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
+	ret = ocfs2_path_bh_journal_access(handle, inode, right_path,
+					   path_num_items(right_path) - 1);
@@ -3735,2 +3824 @@
-			left_path = ocfs2_new_path(path_root_bh(right_path),
-						   path_root_el(right_path));
+			left_path = ocfs2_new_path_from_path(right_path);
@@ -3784 +3872 @@
-	right_el = path_leaf_el(right_path);;
+	right_el = path_leaf_el(right_path);
@@ -3961,2 +4049,2 @@
-	ret = ocfs2_journal_access(handle, inode, et->et_root_bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
+	ret = ocfs2_et_root_journal_access(handle, inode, et,
+					   OCFS2_JOURNAL_ACCESS_WRITE);
@@ -3973 +4061 @@
-	right_path = ocfs2_new_path(et->et_root_bh, et->et_root_el);
+	right_path = ocfs2_new_path_from_et(et);
@@ -4023,2 +4111,2 @@
-		ret = ocfs2_journal_access(handle, inode, et->et_root_bh,
-					   OCFS2_JOURNAL_ACCESS_WRITE);
+		ret = ocfs2_et_root_journal_access(handle, inode, et,
+						   OCFS2_JOURNAL_ACCESS_WRITE);
@@ -4085,2 +4173 @@
-			left_path = ocfs2_new_path(path_root_bh(path),
-						   path_root_el(path));
+			left_path = ocfs2_new_path_from_path(path);
@@ -4100,2 +4187,9 @@
-				OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb,
-								 eb);
+				ocfs2_error(inode->i_sb,
+					    "Extent block #%llu has an "
+					    "invalid l_next_free_rec of "
+					    "%d.  It should have "
+					    "matched the l_count of %d",
+					    (unsigned long long)le64_to_cpu(eb->h_blkno),
+					    le16_to_cpu(new_el->l_next_free_rec),
+					    le16_to_cpu(new_el->l_count));
+				status = -EINVAL;
@@ -4135,2 +4229 @@
-		right_path = ocfs2_new_path(path_root_bh(path),
-					    path_root_el(path));
+		right_path = ocfs2_new_path_from_path(path);
@@ -4150,2 +4243,6 @@
-				OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb,
-								 eb);
+				ocfs2_error(inode->i_sb,
+					    "Extent block #%llu has an "
+					    "invalid l_next_free_rec of %d",
+					    (unsigned long long)le64_to_cpu(eb->h_blkno),
+					    le16_to_cpu(new_el->l_next_free_rec));
+				status = -EINVAL;
@@ -4297 +4394,3 @@
-		ret = ocfs2_read_block(inode, ocfs2_et_get_last_eb_blk(et), &bh);
+		ret = ocfs2_read_extent_block(inode,
+					      ocfs2_et_get_last_eb_blk(et),
+					      &bh);
@@ -4323 +4422 @@
-	path = ocfs2_new_path(et->et_root_bh, et->et_root_el);
+	path = ocfs2_new_path_from_et(et);
@@ -4534,3 +4633,3 @@
-	/* reserve our write early -- insert_extent may update the inode */
-	status = ocfs2_journal_access(handle, inode, et->et_root_bh,
-				      OCFS2_JOURNAL_ACCESS_WRITE);
+	/* reserve our write early -- insert_extent may update the tree root */
+	status = ocfs2_et_root_journal_access(handle, inode, et,
+					      OCFS2_JOURNAL_ACCESS_WRITE);
@@ -4700,0 +4800,23 @@
+static int ocfs2_replace_extent_rec(struct inode *inode,
+				    handle_t *handle,
+				    struct ocfs2_path *path,
+				    struct ocfs2_extent_list *el,
+				    int split_index,
+				    struct ocfs2_extent_rec *split_rec)
+{
+	int ret;
+
+	ret = ocfs2_path_bh_journal_access(handle, inode, path,
+					   path_num_items(path) - 1);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	el->l_recs[split_index] = *split_rec;
+
+	ocfs2_journal_dirty(handle, path_leaf_bh(path));
+out:
+	return ret;
+}
+
@@ -4763,2 +4885,3 @@
-		ret = ocfs2_read_block(inode, ocfs2_et_get_last_eb_blk(et),
-				       &last_eb_bh);
+		ret = ocfs2_read_extent_block(inode,
+					      ocfs2_et_get_last_eb_blk(et),
+					      &last_eb_bh);
@@ -4771,6 +4893,0 @@
-		if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
-			OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
-			ret = -EROFS;
-			goto out;
-		}
-
@@ -4795 +4912,3 @@
-			el->l_recs[split_index] = *split_rec;
+			ret = ocfs2_replace_extent_rec(inode, handle,
+						       path, el,
+						       split_index, split_rec);
@@ -4857 +4976 @@
-	left_path = ocfs2_new_path(et->et_root_bh, et->et_root_el);
+	left_path = ocfs2_new_path_from_et(et);
@@ -4921,2 +5040,3 @@
-		ret = ocfs2_read_block(inode, ocfs2_et_get_last_eb_blk(et),
-				       &last_eb_bh);
+		ret = ocfs2_read_extent_block(inode,
+					      ocfs2_et_get_last_eb_blk(et),
+					      &last_eb_bh);
@@ -5028,2 +5148 @@
-			left_path = ocfs2_new_path(path_root_bh(path),
-						   path_root_el(path));
+			left_path = ocfs2_new_path_from_path(path);
@@ -5138 +5257 @@
-	path = ocfs2_new_path(et->et_root_bh, et->et_root_el);
+	path = ocfs2_new_path_from_et(et);
@@ -5257,0 +5377,75 @@
+int ocfs2_remove_btree_range(struct inode *inode,
+			     struct ocfs2_extent_tree *et,
+			     u32 cpos, u32 phys_cpos, u32 len,
+			     struct ocfs2_cached_dealloc_ctxt *dealloc)
+{
+	int ret;
+	u64 phys_blkno = ocfs2_clusters_to_blocks(inode->i_sb, phys_cpos);
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	struct inode *tl_inode = osb->osb_tl_inode;
+	handle_t *handle;
+	struct ocfs2_alloc_context *meta_ac = NULL;
+
+	ret = ocfs2_lock_allocators(inode, et, 0, 1, NULL, &meta_ac);
+	if (ret) {
+		mlog_errno(ret);
+		return ret;
+	}
+
+	mutex_lock(&tl_inode->i_mutex);
+
+	if (ocfs2_truncate_log_needs_flush(osb)) {
+		ret = __ocfs2_flush_truncate_log(osb);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+	handle = ocfs2_start_trans(osb, ocfs2_remove_extent_credits(osb->sb));
+	if (IS_ERR(handle)) {
+		ret = PTR_ERR(handle);
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ret = ocfs2_et_root_journal_access(handle, inode, et,
+					   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	vfs_dq_free_space_nodirty(inode,
+				  ocfs2_clusters_to_bytes(inode->i_sb, len));
+
+	ret = ocfs2_remove_extent(inode, et, cpos, len, handle, meta_ac,
+				  dealloc);
+	if (ret) {
+		mlog_errno(ret);
+		goto out_commit;
+	}
+
+	ocfs2_et_update_clusters(inode, et, -len);
+
+	ret = ocfs2_journal_dirty(handle, et->et_root_bh);
+	if (ret) {
+		mlog_errno(ret);
+		goto out_commit;
+	}
+
+	ret = ocfs2_truncate_log_append(osb, handle, phys_blkno, len);
+	if (ret)
+		mlog_errno(ret);
+
+out_commit:
+	ocfs2_commit_trans(osb, handle);
+out:
+	mutex_unlock(&tl_inode->i_mutex);
+
+	if (meta_ac)
+		ocfs2_free_alloc_context(meta_ac);
+
+	return ret;
+}
+
@@ -5311,6 +5504,0 @@
-	tl = &di->id2.i_dealloc;
-	if (!OCFS2_IS_VALID_DINODE(di)) {
-		OCFS2_RO_ON_INVALID_DINODE(osb->sb, di);
-		status = -EIO;
-		goto bail;
-	}
@@ -5317,0 +5506,6 @@
+	/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated
+	 * by the underlying call to ocfs2_read_inode_block(), so any
+	 * corruption is a code bug */
+	BUG_ON(!OCFS2_IS_VALID_DINODE(di));
+
+	tl = &di->id2.i_dealloc;
@@ -5335,2 +5529,2 @@
-	status = ocfs2_journal_access(handle, tl_inode, tl_bh,
-				      OCFS2_JOURNAL_ACCESS_WRITE);
+	status = ocfs2_journal_access_di(handle, tl_inode, tl_bh,
+					 OCFS2_JOURNAL_ACCESS_WRITE);
@@ -5397,2 +5591,2 @@
-		status = ocfs2_journal_access(handle, tl_inode, tl_bh,
-					      OCFS2_JOURNAL_ACCESS_WRITE);
+		status = ocfs2_journal_access_di(handle, tl_inode, tl_bh,
+						 OCFS2_JOURNAL_ACCESS_WRITE);
@@ -5467,6 +5660,0 @@
-	tl = &di->id2.i_dealloc;
-	if (!OCFS2_IS_VALID_DINODE(di)) {
-		OCFS2_RO_ON_INVALID_DINODE(osb->sb, di);
-		status = -EIO;
-		goto out;
-	}
@@ -5473,0 +5662,6 @@
+	/* tl_bh is loaded from ocfs2_truncate_log_init().  It's validated
+	 * by the underlying call to ocfs2_read_inode_block(), so any
+	 * corruption is a code bug */
+	BUG_ON(!OCFS2_IS_VALID_DINODE(di));
+
+	tl = &di->id2.i_dealloc;
@@ -5589 +5783 @@
-	status = ocfs2_read_block(inode, OCFS2_I(inode)->ip_blkno, &bh);
+	status = ocfs2_read_inode_block(inode, &bh);
@@ -5628,6 +5821,0 @@
-	tl = &di->id2.i_dealloc;
-	if (!OCFS2_IS_VALID_DINODE(di)) {
-		OCFS2_RO_ON_INVALID_DINODE(tl_inode->i_sb, di);
-		status = -EIO;
-		goto bail;
-	}
@@ -5634,0 +5823,6 @@
+	/* tl_bh is loaded from ocfs2_get_truncate_log_info().  It's
+	 * validated by the underlying call to ocfs2_read_inode_block(),
+	 * so any corruption is a code bug */
+	BUG_ON(!OCFS2_IS_VALID_DINODE(di));
+
+	tl = &di->id2.i_dealloc;
@@ -5653,0 +5848 @@
+		ocfs2_compute_meta_ecc(osb->sb, tl_bh->b_data, &di->i_check);
@@ -5803 +5998,4 @@
- * Describes a single block free from a suballocator
+ * Describe a single bit freed from a suballocator.  For the block
+ * suballocators, it represents one block.  For the global cluster
+ * allocator, it represents some clusters and free_bit indicates
+ * clusters number.
@@ -5818,4 +6016,4 @@
-static int ocfs2_free_cached_items(struct ocfs2_super *osb,
-				   int sysfile_type,
-				   int slot,
-				   struct ocfs2_cached_block_free *head)
+static int ocfs2_free_cached_blocks(struct ocfs2_super *osb,
+				    int sysfile_type,
+				    int slot,
+				    struct ocfs2_cached_block_free *head)
@@ -5895,0 +6094,76 @@
+int ocfs2_cache_cluster_dealloc(struct ocfs2_cached_dealloc_ctxt *ctxt,
+				u64 blkno, unsigned int bit)
+{
+	int ret = 0;
+	struct ocfs2_cached_block_free *item;
+
+	item = kmalloc(sizeof(*item), GFP_NOFS);
+	if (item == NULL) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		return ret;
+	}
+
+	mlog(0, "Insert clusters: (bit %u, blk %llu)\n",
+	     bit, (unsigned long long)blkno);
+
+	item->free_blk = blkno;
+	item->free_bit = bit;
+	item->free_next = ctxt->c_global_allocator;
+
+	ctxt->c_global_allocator = item;
+	return ret;
+}
+
+static int ocfs2_free_cached_clusters(struct ocfs2_super *osb,
+				      struct ocfs2_cached_block_free *head)
+{
+	struct ocfs2_cached_block_free *tmp;
+	struct inode *tl_inode = osb->osb_tl_inode;
+	handle_t *handle;
+	int ret = 0;
+
+	mutex_lock(&tl_inode->i_mutex);
+
+	while (head) {
+		if (ocfs2_truncate_log_needs_flush(osb)) {
+			ret = __ocfs2_flush_truncate_log(osb);
+			if (ret < 0) {
+				mlog_errno(ret);
+				break;
+			}
+		}
+
+		handle = ocfs2_start_trans(osb, OCFS2_TRUNCATE_LOG_UPDATE);
+		if (IS_ERR(handle)) {
+			ret = PTR_ERR(handle);
+			mlog_errno(ret);
+			break;
+		}
+
+		ret = ocfs2_truncate_log_append(osb, handle, head->free_blk,
+						head->free_bit);
+
+		ocfs2_commit_trans(osb, handle);
+		tmp = head;
+		head = head->free_next;
+		kfree(tmp);
+
+		if (ret < 0) {
+			mlog_errno(ret);
+			break;
+		}
+	}
+
+	mutex_unlock(&tl_inode->i_mutex);
+
+	while (head) {
+		/* Premature exit may have left some dangling items. */
+		tmp = head;
+		head = head->free_next;
+		kfree(tmp);
+	}
+
+	return ret;
+}
+
@@ -5911,2 +6185,4 @@
-			ret2 = ocfs2_free_cached_items(osb, fl->f_inode_type,
-						       fl->f_slot, fl->f_first);
+			ret2 = ocfs2_free_cached_blocks(osb,
+							fl->f_inode_type,
+							fl->f_slot,
+							fl->f_first);
@@ -5922,0 +6199,11 @@
+	if (ctxt->c_global_allocator) {
+		ret2 = ocfs2_free_cached_clusters(osb,
+						  ctxt->c_global_allocator);
+		if (ret2)
+			mlog_errno(ret2);
+		if (!ret)
+			ret = ret2;
+
+		ctxt->c_global_allocator = NULL;
+	}
+
@@ -6078,5 +6365,4 @@
-	if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
-		OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
-		ret = -EROFS;
-		goto out;
-	}
+
+	/* ocfs2_find_leaf() gets the eb from ocfs2_read_extent_block().
+	 * Any corruption is a code bug. */
+	BUG_ON(!OCFS2_IS_VALID_EXTENT_BLOCK(eb));
@@ -6329,2 +6615,2 @@
-		status = ocfs2_journal_access(handle, inode, last_eb_bh,
-					      OCFS2_JOURNAL_ACCESS_WRITE);
+		status = ocfs2_journal_access_eb(handle, inode, last_eb_bh,
+						 OCFS2_JOURNAL_ACCESS_WRITE);
@@ -6352,0 +6639,2 @@
+	vfs_dq_free_space_nodirty(inode,
+			ocfs2_clusters_to_bytes(osb->sb, clusters_to_del));
@@ -6439,5 +6726,0 @@
-#ifdef CONFIG_OCFS2_COMPAT_JBD
-		ret = walk_page_buffers(handle, page_buffers(page),
-					from, to, &partial,
-					ocfs2_journal_dirty_data);
-#endif
@@ -6665,0 +6949 @@
+	int did_quota = 0;
@@ -6685 +6969,2 @@
-	handle = ocfs2_start_trans(osb, OCFS2_INLINE_TO_EXTENTS_CREDITS);
+	handle = ocfs2_start_trans(osb,
+				   ocfs2_inline_to_extents_credits(osb->sb));
@@ -6692,2 +6977,2 @@
-	ret = ocfs2_journal_access(handle, inode, di_bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
+	ret = ocfs2_journal_access_di(handle, inode, di_bh,
+				      OCFS2_JOURNAL_ACCESS_WRITE);
@@ -6703,0 +6989,7 @@
+		if (vfs_dq_alloc_space_nodirty(inode,
+				       ocfs2_clusters_to_bytes(osb->sb, 1))) {
+			ret = -EDQUOT;
+			goto out_commit;
+		}
+		did_quota = 1;
+
@@ -6776,0 +7069,4 @@
+	if (ret < 0 && did_quota)
+		vfs_dq_free_space_nodirty(inode,
+					  ocfs2_clusters_to_bytes(osb->sb, 1));
+
@@ -6816 +7112,2 @@
-	path = ocfs2_new_path(fe_bh, &di->id2.i_list);
+	path = ocfs2_new_path(fe_bh, &di->id2.i_list,
+			      ocfs2_journal_access_di);
@@ -6987,2 +7284,3 @@
-		status = ocfs2_read_block(inode, le64_to_cpu(fe->i_last_eb_blk),
-					  &last_eb_bh);
+		status = ocfs2_read_extent_block(inode,
+						 le64_to_cpu(fe->i_last_eb_blk),
+						 &last_eb_bh);
@@ -6994,7 +7291,0 @@
-		if (!OCFS2_IS_VALID_EXTENT_BLOCK(eb)) {
-			OCFS2_RO_ON_INVALID_EXTENT_BLOCK(inode->i_sb, eb);
-
-			brelse(last_eb_bh);
-			status = -EIO;
-			goto bail;
-		}
@@ -7055,2 +7346,2 @@
-	ret = ocfs2_journal_access(handle, inode, di_bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
+	ret = ocfs2_journal_access_di(handle, inode, di_bh,
+				      OCFS2_JOURNAL_ACCESS_WRITE);
--- ./projects/linux/linux-2.6.29/fs/ocfs2/alloc.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/fs/ocfs2/alloc.c	2009-06-27 11:32:32.000000000 +0200
@@ -296,0 +297,49 @@
+static void ocfs2_dx_root_set_last_eb_blk(struct ocfs2_extent_tree *et,
+					  u64 blkno)
+{
+	struct ocfs2_dx_root_block *dx_root = et->et_object;
+
+	dx_root->dr_last_eb_blk = cpu_to_le64(blkno);
+}
+
+static u64 ocfs2_dx_root_get_last_eb_blk(struct ocfs2_extent_tree *et)
+{
+	struct ocfs2_dx_root_block *dx_root = et->et_object;
+
+	return le64_to_cpu(dx_root->dr_last_eb_blk);
+}
+
+static void ocfs2_dx_root_update_clusters(struct inode *inode,
+					  struct ocfs2_extent_tree *et,
+					  u32 clusters)
+{
+	struct ocfs2_dx_root_block *dx_root = et->et_object;
+
+	le32_add_cpu(&dx_root->dr_clusters, clusters);
+}
+
+static int ocfs2_dx_root_sanity_check(struct inode *inode,
+				      struct ocfs2_extent_tree *et)
+{
+	struct ocfs2_dx_root_block *dx_root = et->et_object;
+
+	BUG_ON(!OCFS2_IS_VALID_DX_ROOT(dx_root));
+
+	return 0;
+}
+
+static void ocfs2_dx_root_fill_root_el(struct ocfs2_extent_tree *et)
+{
+	struct ocfs2_dx_root_block *dx_root = et->et_object;
+
+	et->et_root_el = &dx_root->dr_list;
+}
+
+static struct ocfs2_extent_tree_operations ocfs2_dx_root_et_ops = {
+	.eo_set_last_eb_blk	= ocfs2_dx_root_set_last_eb_blk,
+	.eo_get_last_eb_blk	= ocfs2_dx_root_get_last_eb_blk,
+	.eo_update_clusters	= ocfs2_dx_root_update_clusters,
+	.eo_sanity_check	= ocfs2_dx_root_sanity_check,
+	.eo_fill_root_el	= ocfs2_dx_root_fill_root_el,
+};
+
@@ -341,0 +391,8 @@
+void ocfs2_init_dx_root_extent_tree(struct ocfs2_extent_tree *et,
+				    struct inode *inode,
+				    struct buffer_head *bh)
+{
+	__ocfs2_init_extent_tree(et, inode, bh, ocfs2_journal_access_dr,
+				 NULL, &ocfs2_dx_root_et_ops);
+}
+
--- ./projects/linux/linux-2.6.16/fs/ocfs2/aops.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/fs/ocfs2/aops.c	2006-06-18 03:49:35.000000000 +0200
@@ -77,2 +77,2 @@
-		mlog(ML_ERROR, "Invalid dinode #%"MLFu64": signature = %.*s\n",
-		     fe->i_blkno, 7, fe->i_signature);
+		mlog(ML_ERROR, "Invalid dinode #%llu: signature = %.*s\n",
+		     (unsigned long long)fe->i_blkno, 7, fe->i_signature);
@@ -165,2 +165,2 @@
-		     "%"MLFu64", NULL)\n", err, inode,
-		     (unsigned long long)iblock, p_blkno);
+		     "%llu, NULL)\n", err, inode, (unsigned long long)iblock,
+		     (unsigned long long)p_blkno);
@@ -174,3 +174,4 @@
-		mlog(ML_ERROR, "iblock = %llu p_blkno = %"MLFu64" "
-		     "blkno=(%"MLFu64")\n", (unsigned long long)iblock,
-		     p_blkno, OCFS2_I(inode)->ip_blkno);
+		mlog(ML_ERROR, "iblock = %llu p_blkno = %llu blkno=(%llu)\n",
+		     (unsigned long long)iblock,
+		     (unsigned long long)p_blkno,
+		     (unsigned long long)OCFS2_I(inode)->ip_blkno);
@@ -180 +181,2 @@
-	mlog(0, "Inode %lu, past_eof = %"MLFu64"\n", inode->i_ino, past_eof);
+	mlog(0, "Inode %lu, past_eof = %llu\n", inode->i_ino,
+	     (unsigned long long)past_eof);
@@ -276,0 +279,16 @@
+/* This can also be called from ocfs2_write_zero_page() which has done
+ * it's own cluster locking. */
+int ocfs2_prepare_write_nolock(struct inode *inode, struct page *page,
+			       unsigned from, unsigned to)
+{
+	int ret;
+
+	down_read(&OCFS2_I(inode)->ip_alloc_sem);
+
+	ret = block_prepare_write(page, from, to, ocfs2_get_block);
+
+	up_read(&OCFS2_I(inode)->ip_alloc_sem);
+
+	return ret;
+}
+
@@ -282,2 +300,2 @@
-int ocfs2_prepare_write(struct file *file, struct page *page,
-			unsigned from, unsigned to)
+static int ocfs2_prepare_write(struct file *file, struct page *page,
+			       unsigned from, unsigned to)
@@ -296,5 +314 @@
-	down_read(&OCFS2_I(inode)->ip_alloc_sem);
-
-	ret = block_prepare_write(page, from, to, ocfs2_get_block);
-
-	up_read(&OCFS2_I(inode)->ip_alloc_sem);
+	ret = ocfs2_prepare_write_nolock(inode, page, from, to);
@@ -541 +554,0 @@
-				     unsigned long max_blocks,
@@ -548,0 +562 @@
+	unsigned long max_blocks = bh_result->b_size >> inode->i_blkbits;
@@ -625,0 +640,19 @@
+
+	/*
+	 * We get PR data locks even for O_DIRECT.  This allows
+	 * concurrent O_DIRECT I/O but doesn't let O_DIRECT with
+	 * extending and buffered zeroing writes race.  If they did
+	 * race then the buffered zeroing could be written back after
+	 * the O_DIRECT I/O.  It's one thing to tell people not to mix
+	 * buffered and O_DIRECT writes, but expecting them to
+	 * understand that file extension is also an implicit buffered
+	 * write is too much.  By getting the PR we force writeback of
+	 * the buffered zeroing before proceeding.
+	 */
+	ret = ocfs2_data_lock(inode, 0);
+	if (ret < 0) {
+		mlog_errno(ret);
+		goto out;
+	}
+	ocfs2_data_unlock(inode, 0);
+
@@ -630,0 +664 @@
+out:
--- ./projects/linux/linux-2.6.17/fs/ocfs2/aops.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/fs/ocfs2/aops.c	2006-09-20 05:42:06.000000000 +0200
@@ -561 +561 @@
-	unsigned char blocksize_bits;
+	unsigned char blocksize_bits = inode->i_sb->s_blocksize_bits;
@@ -564,7 +563,0 @@
-	if (!inode || !bh_result) {
-		mlog(ML_ERROR, "inode or bh_result is null\n");
-		return -EIO;
-	}
-
-	blocksize_bits = inode->i_sb->s_blocksize_bits;
-
@@ -669 +662 @@
-struct address_space_operations ocfs2_aops = {
+const struct address_space_operations ocfs2_aops = {
--- ./projects/linux/linux-2.6.18/fs/ocfs2/aops.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/fs/ocfs2/aops.c	2006-11-29 22:57:37.000000000 +0100
@@ -394,2 +394 @@
-	int ret, extending = 0, locklevel = 0;
-	loff_t new_i_size;
+	int ret;
@@ -398,0 +398 @@
+	struct ocfs2_dinode *di;
@@ -403 +403,2 @@
-	 * us to sample inode->i_size here without the metadata lock:
+	 * us to continue here without rechecking the I/O against
+	 * changed inode values.
@@ -409,2 +410,3 @@
-	 *    already to check for extending writes, hence insuring
-	 *    that our current copy is also up to date.
+	 *    already to check for extending writes, suid removal, etc.
+	 *    The meta data update code then ensures that we don't get a
+	 *    stale inode allocation image (i_size, i_clusters, etc).
@@ -412,5 +413,0 @@
-	new_i_size = ((loff_t)page->index << PAGE_CACHE_SHIFT) + to;
-	if (new_i_size > i_size_read(inode)) {
-		extending = 1;
-		locklevel = 1;
-	}
@@ -418 +415 @@
-	ret = ocfs2_meta_lock_with_page(inode, NULL, &di_bh, locklevel, page);
+	ret = ocfs2_meta_lock_with_page(inode, NULL, &di_bh, 1, page);
@@ -430,7 +427,5 @@
-	if (extending) {
-		handle = ocfs2_start_walk_page_trans(inode, page, from, to);
-		if (IS_ERR(handle)) {
-			ret = PTR_ERR(handle);
-			handle = NULL;
-			goto out_unlock_data;
-		}
+	handle = ocfs2_start_walk_page_trans(inode, page, from, to);
+	if (IS_ERR(handle)) {
+		ret = PTR_ERR(handle);
+		goto out_unlock_data;
+	}
@@ -438,9 +433,8 @@
-		/* Mark our buffer early. We'd rather catch this error up here
-		 * as opposed to after a successful commit_write which would
-		 * require us to set back inode->i_size. */
-		ret = ocfs2_journal_access(handle, inode, di_bh,
-					   OCFS2_JOURNAL_ACCESS_WRITE);
-		if (ret < 0) {
-			mlog_errno(ret);
-			goto out_commit;
-		}
+	/* Mark our buffer early. We'd rather catch this error up here
+	 * as opposed to after a successful commit_write which would
+	 * require us to set back inode->i_size. */
+	ret = ocfs2_journal_access(handle, inode, di_bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret < 0) {
+		mlog_errno(ret);
+		goto out_commit;
@@ -456,21 +450,9 @@
-	if (extending) {
-		loff_t size = (u64) i_size_read(inode);
-		struct ocfs2_dinode *di =
-			(struct ocfs2_dinode *)di_bh->b_data;
-
-		/* ocfs2_mark_inode_dirty is too heavy to use here. */
-		inode->i_blocks = ocfs2_align_bytes_to_sectors(size);
-		inode->i_ctime = inode->i_mtime = CURRENT_TIME;
-
-		di->i_size = cpu_to_le64(size);
-		di->i_ctime = di->i_mtime = 
-				cpu_to_le64(inode->i_mtime.tv_sec);
-		di->i_ctime_nsec = di->i_mtime_nsec = 
-				cpu_to_le32(inode->i_mtime.tv_nsec);
-
-		ret = ocfs2_journal_dirty(handle, di_bh);
-		if (ret < 0) {
-			mlog_errno(ret);
-			goto out_commit;
-		}
-	}
+	di = (struct ocfs2_dinode *)di_bh->b_data;
+
+	/* ocfs2_mark_inode_dirty() is too heavy to use here. */
+	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	di->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);
+	di->i_mtime_nsec = di->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);
+
+	inode->i_blocks = ocfs2_align_bytes_to_sectors((u64)(i_size_read(inode)));
+	di->i_size = cpu_to_le64((u64)i_size_read(inode));
@@ -478 +460,5 @@
-	BUG_ON(extending && (i_size_read(inode) != new_i_size));
+	ret = ocfs2_journal_dirty(handle, di_bh);
+	if (ret < 0) {
+		mlog_errno(ret);
+		goto out_commit;
+	}
@@ -481,2 +467 @@
-	if (handle)
-		ocfs2_commit_trans(handle);
+	ocfs2_commit_trans(handle);
@@ -486 +471 @@
-	ocfs2_meta_unlock(inode, locklevel);
+	ocfs2_meta_unlock(inode, 1);
--- ./projects/linux/linux-2.6.19/fs/ocfs2/aops.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/fs/ocfs2/aops.c	2007-02-04 19:44:54.000000000 +0100
@@ -203 +203 @@
-	ret = ocfs2_meta_lock_with_page(inode, NULL, NULL, 0, page);
+	ret = ocfs2_meta_lock_with_page(inode, NULL, 0, page);
@@ -308 +308 @@
-	ret = ocfs2_meta_lock_with_page(inode, NULL, NULL, 0, page);
+	ret = ocfs2_meta_lock_with_page(inode, NULL, 0, page);
@@ -358 +358 @@
-struct ocfs2_journal_handle *ocfs2_start_walk_page_trans(struct inode *inode,
+handle_t *ocfs2_start_walk_page_trans(struct inode *inode,
@@ -364 +364 @@
-	struct ocfs2_journal_handle *handle = NULL;
+	handle_t *handle = NULL;
@@ -367 +367 @@
-	handle = ocfs2_start_trans(osb, NULL, OCFS2_INODE_UPDATE_CREDITS);
+	handle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);
@@ -375 +375 @@
-		ret = walk_page_buffers(handle->k_handle,
+		ret = walk_page_buffers(handle,
@@ -385 +385 @@
-			ocfs2_commit_trans(handle);
+			ocfs2_commit_trans(osb, handle);
@@ -397 +397 @@
-	struct ocfs2_journal_handle *handle = NULL;
+	handle_t *handle = NULL;
@@ -415 +415 @@
-	ret = ocfs2_meta_lock_with_page(inode, NULL, &di_bh, 1, page);
+	ret = ocfs2_meta_lock_with_page(inode, &di_bh, 1, page);
@@ -467 +467 @@
-	ocfs2_commit_trans(handle);
+	ocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);
@@ -493 +493 @@
-		err = ocfs2_meta_lock(inode, NULL, NULL, 0);
+		err = ocfs2_meta_lock(inode, NULL, 0);
@@ -543,2 +543 @@
-	u64 vbo_max; /* file offset, max_blocks from iblock */
-	u64 p_blkno;
+	u64 p_blkno, inode_blocks;
@@ -553,2 +551,0 @@
-	vbo_max = ((u64)iblock + max_blocks) << blocksize_bits;
-
@@ -556,3 +553,16 @@
-	if ((iblock + max_blocks) >
-	    ocfs2_clusters_to_blocks(inode->i_sb,
-				     OCFS2_I(inode)->ip_clusters)) {
+	inode_blocks = ocfs2_clusters_to_blocks(inode->i_sb,
+						OCFS2_I(inode)->ip_clusters);
+
+	/*
+	 * For a read which begins past the end of file, we return a hole.
+	 */
+	if (!create && (iblock >= inode_blocks)) {
+		spin_unlock(&OCFS2_I(inode)->ip_lock);
+		ret = 0;
+		goto bail;
+	}
+
+	/*
+	 * Any write past EOF is not allowed because we'd be extending.
+	 */
+	if (create && (iblock + max_blocks) > inode_blocks) {
@@ -598 +608 @@
-	struct inode *inode = iocb->ki_filp->f_dentry->d_inode;
+	struct inode *inode = iocb->ki_filp->f_path.dentry->d_inode;
@@ -614 +624 @@
-	struct inode *inode = file->f_dentry->d_inode->i_mapping->host;
+	struct inode *inode = file->f_path.dentry->d_inode->i_mapping->host;
--- ./projects/linux/linux-2.6.20/fs/ocfs2/aops.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/fs/ocfs2/aops.c	2007-04-26 05:08:32.000000000 +0200
@@ -616,0 +617,21 @@
+/*
+ * ocfs2_invalidatepage() and ocfs2_releasepage() are shamelessly stolen
+ * from ext3.  PageChecked() bits have been removed as OCFS2 does not
+ * do journalled data.
+ */
+static void ocfs2_invalidatepage(struct page *page, unsigned long offset)
+{
+	journal_t *journal = OCFS2_SB(page->mapping->host->i_sb)->journal->j_journal;
+
+	journal_invalidatepage(journal, page, offset);
+}
+
+static int ocfs2_releasepage(struct page *page, gfp_t wait)
+{
+	journal_t *journal = OCFS2_SB(page->mapping->host->i_sb)->journal->j_journal;
+
+	if (!page_has_buffers(page))
+		return 0;
+	return journal_try_to_free_buffers(journal, page, wait);
+}
+
@@ -664 +685,4 @@
-	.direct_IO	= ocfs2_direct_IO
+	.direct_IO	= ocfs2_direct_IO,
+	.invalidatepage	= ocfs2_invalidatepage,
+	.releasepage	= ocfs2_releasepage,
+	.migratepage	= buffer_migrate_page,
--- ./projects/linux/linux-2.6.21/fs/ocfs2/aops.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/fs/ocfs2/aops.c	2007-07-09 01:32:17.000000000 +0200
@@ -26,0 +27,2 @@
+#include <linux/swap.h>
+#include <linux/pipe_fs_i.h>
@@ -39,0 +42 @@
+#include "suballoc.h"
@@ -78 +81,2 @@
-		     (unsigned long long)fe->i_blkno, 7, fe->i_signature);
+		     (unsigned long long)le64_to_cpu(fe->i_blkno), 7,
+		     fe->i_signature);
@@ -136,0 +141 @@
+	unsigned int ext_flags;
@@ -137,0 +143 @@
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
@@ -152,11 +158,2 @@
-	/* this can happen if another node truncs after our extend! */
-	spin_lock(&OCFS2_I(inode)->ip_lock);
-	if (iblock >= ocfs2_clusters_to_blocks(inode->i_sb,
-					       OCFS2_I(inode)->ip_clusters))
-		err = -EIO;
-	spin_unlock(&OCFS2_I(inode)->ip_lock);
-	if (err)
-		goto bail;
-
-	err = ocfs2_extent_map_get_blocks(inode, iblock, 1, &p_blkno,
-					  NULL);
+	err = ocfs2_extent_map_get_blocks(inode, iblock, &p_blkno, NULL,
+					  &ext_flags);
@@ -170,9 +167,25 @@
-	map_bh(bh_result, inode->i_sb, p_blkno);
-
-	if (bh_result->b_blocknr == 0) {
-		err = -EIO;
-		mlog(ML_ERROR, "iblock = %llu p_blkno = %llu blkno=(%llu)\n",
-		     (unsigned long long)iblock,
-		     (unsigned long long)p_blkno,
-		     (unsigned long long)OCFS2_I(inode)->ip_blkno);
-	}
+	/*
+	 * ocfs2 never allocates in this function - the only time we
+	 * need to use BH_New is when we're extending i_size on a file
+	 * system which doesn't support holes, in which case BH_New
+	 * allows block_prepare_write() to zero.
+	 */
+	mlog_bug_on_msg(create && p_blkno == 0 && ocfs2_sparse_alloc(osb),
+			"ino %lu, iblock %llu\n", inode->i_ino,
+			(unsigned long long)iblock);
+
+	/* Treat the unwritten extent as a hole for zeroing purposes. */
+	if (p_blkno && !(ext_flags & OCFS2_EXT_UNWRITTEN))
+		map_bh(bh_result, inode->i_sb, p_blkno);
+
+	if (!ocfs2_sparse_alloc(osb)) {
+		if (p_blkno == 0) {
+			err = -EIO;
+			mlog(ML_ERROR,
+			     "iblock = %llu p_blkno = %llu blkno=(%llu)\n",
+			     (unsigned long long)iblock,
+			     (unsigned long long)p_blkno,
+			     (unsigned long long)OCFS2_I(inode)->ip_blkno);
+			mlog(ML_ERROR, "Size %llu, clusters %u\n", (unsigned long long)i_size_read(inode), OCFS2_I(inode)->ip_clusters);
+			dump_stack();
+		}
@@ -180,3 +193,3 @@
-	past_eof = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));
-	mlog(0, "Inode %lu, past_eof = %llu\n", inode->i_ino,
-	     (unsigned long long)past_eof);
+		past_eof = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));
+		mlog(0, "Inode %lu, past_eof = %llu\n", inode->i_ino,
+		     (unsigned long long)past_eof);
@@ -184,2 +197,3 @@
-	if (create && (iblock >= past_eof))
-		set_buffer_new(bh_result);
+		if (create && (iblock >= past_eof))
+			set_buffer_new(bh_result);
+	}
@@ -211 +225,4 @@
-	down_read(&OCFS2_I(inode)->ip_alloc_sem);
+	if (down_read_trylock(&OCFS2_I(inode)->ip_alloc_sem) == 0) {
+		ret = AOP_TRUNCATED_PAGE;
+		goto out_meta_unlock;
+	}
@@ -224,4 +241 @@
-		char *addr = kmap(page);
-		memset(addr, 0, PAGE_SIZE);
-		flush_dcache_page(page);
-		kunmap(page);
+		zero_user_page(page, 0, PAGE_SIZE, KM_USER0);
@@ -246,0 +261 @@
+out_meta_unlock:
@@ -279,2 +294,5 @@
-/* This can also be called from ocfs2_write_zero_page() which has done
- * it's own cluster locking. */
+/*
+ * This is called from ocfs2_write_zero_page() which has handled it's
+ * own cluster locking and has ensured allocation exists for those
+ * blocks to be written.
+ */
@@ -295,27 +312,0 @@
-/*
- * ocfs2_prepare_write() can be an outer-most ocfs2 call when it is called
- * from loopback.  It must be able to perform its own locking around
- * ocfs2_get_block().
- */
-static int ocfs2_prepare_write(struct file *file, struct page *page,
-			       unsigned from, unsigned to)
-{
-	struct inode *inode = page->mapping->host;
-	int ret;
-
-	mlog_entry("(0x%p, 0x%p, %u, %u)\n", file, page, from, to);
-
-	ret = ocfs2_meta_lock_with_page(inode, NULL, 0, page);
-	if (ret != 0) {
-		mlog_errno(ret);
-		goto out;
-	}
-
-	ret = ocfs2_prepare_write_nolock(inode, page, from, to);
-
-	ocfs2_meta_unlock(inode, 0);
-out:
-	mlog_exit(ret);
-	return ret;
-}
-
@@ -326,7 +317,7 @@
-static int walk_page_buffers(	handle_t *handle,
-				struct buffer_head *head,
-				unsigned from,
-				unsigned to,
-				int *partial,
-				int (*fn)(	handle_t *handle,
-						struct buffer_head *bh))
+int walk_page_buffers(	handle_t *handle,
+			struct buffer_head *head,
+			unsigned from,
+			unsigned to,
+			int *partial,
+			int (*fn)(	handle_t *handle,
+					struct buffer_head *bh))
@@ -391,89 +381,0 @@
-static int ocfs2_commit_write(struct file *file, struct page *page,
-			      unsigned from, unsigned to)
-{
-	int ret;
-	struct buffer_head *di_bh = NULL;
-	struct inode *inode = page->mapping->host;
-	handle_t *handle = NULL;
-	struct ocfs2_dinode *di;
-
-	mlog_entry("(0x%p, 0x%p, %u, %u)\n", file, page, from, to);
-
-	/* NOTE: ocfs2_file_aio_write has ensured that it's safe for
-	 * us to continue here without rechecking the I/O against
-	 * changed inode values.
-	 *
-	 * 1) We're currently holding the inode alloc lock, so no
-	 *    nodes can change it underneath us.
-	 *
-	 * 2) We've had to take the metadata lock at least once
-	 *    already to check for extending writes, suid removal, etc.
-	 *    The meta data update code then ensures that we don't get a
-	 *    stale inode allocation image (i_size, i_clusters, etc).
-	 */
-
-	ret = ocfs2_meta_lock_with_page(inode, &di_bh, 1, page);
-	if (ret != 0) {
-		mlog_errno(ret);
-		goto out;
-	}
-
-	ret = ocfs2_data_lock_with_page(inode, 1, page);
-	if (ret != 0) {
-		mlog_errno(ret);
-		goto out_unlock_meta;
-	}
-
-	handle = ocfs2_start_walk_page_trans(inode, page, from, to);
-	if (IS_ERR(handle)) {
-		ret = PTR_ERR(handle);
-		goto out_unlock_data;
-	}
-
-	/* Mark our buffer early. We'd rather catch this error up here
-	 * as opposed to after a successful commit_write which would
-	 * require us to set back inode->i_size. */
-	ret = ocfs2_journal_access(handle, inode, di_bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
-	if (ret < 0) {
-		mlog_errno(ret);
-		goto out_commit;
-	}
-
-	/* might update i_size */
-	ret = generic_commit_write(file, page, from, to);
-	if (ret < 0) {
-		mlog_errno(ret);
-		goto out_commit;
-	}
-
-	di = (struct ocfs2_dinode *)di_bh->b_data;
-
-	/* ocfs2_mark_inode_dirty() is too heavy to use here. */
-	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
-	di->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);
-	di->i_mtime_nsec = di->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);
-
-	inode->i_blocks = ocfs2_align_bytes_to_sectors((u64)(i_size_read(inode)));
-	di->i_size = cpu_to_le64((u64)i_size_read(inode));
-
-	ret = ocfs2_journal_dirty(handle, di_bh);
-	if (ret < 0) {
-		mlog_errno(ret);
-		goto out_commit;
-	}
-
-out_commit:
-	ocfs2_commit_trans(OCFS2_SB(inode->i_sb), handle);
-out_unlock_data:
-	ocfs2_data_unlock(inode, 1);
-out_unlock_meta:
-	ocfs2_meta_unlock(inode, 1);
-out:
-	if (di_bh)
-		brelse(di_bh);
-
-	mlog_exit(ret);
-	return ret;
-}
-
@@ -502,2 +404 @@
-	err = ocfs2_extent_map_get_blocks(inode, block, 1, &p_blkno,
-					  NULL);
+	err = ocfs2_extent_map_get_blocks(inode, block, &p_blkno, NULL, NULL);
@@ -543,2 +444,2 @@
-	u64 p_blkno, inode_blocks;
-	int contig_blocks;
+	u64 p_blkno, inode_blocks, contig_blocks;
+	unsigned int ext_flags;
@@ -552,12 +453 @@
-	spin_lock(&OCFS2_I(inode)->ip_lock);
-	inode_blocks = ocfs2_clusters_to_blocks(inode->i_sb,
-						OCFS2_I(inode)->ip_clusters);
-
-	/*
-	 * For a read which begins past the end of file, we return a hole.
-	 */
-	if (!create && (iblock >= inode_blocks)) {
-		spin_unlock(&OCFS2_I(inode)->ip_lock);
-		ret = 0;
-		goto bail;
-	}
+	inode_blocks = ocfs2_blocks_for_bytes(inode->i_sb, i_size_read(inode));
@@ -569 +458,0 @@
-		spin_unlock(&OCFS2_I(inode)->ip_lock);
@@ -573 +461,0 @@
-	spin_unlock(&OCFS2_I(inode)->ip_lock);
@@ -577,2 +465,2 @@
-	ret = ocfs2_extent_map_get_blocks(inode, iblock, 1, &p_blkno,
-					  &contig_blocks);
+	ret = ocfs2_extent_map_get_blocks(inode, iblock, &p_blkno,
+					  &contig_blocks, &ext_flags);
@@ -586 +474,31 @@
-	map_bh(bh_result, inode->i_sb, p_blkno);
+	if (!ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)) && !p_blkno) {
+		ocfs2_error(inode->i_sb,
+			    "Inode %llu has a hole at block %llu\n",
+			    (unsigned long long)OCFS2_I(inode)->ip_blkno,
+			    (unsigned long long)iblock);
+		ret = -EROFS;
+		goto bail;
+	}
+
+	/*
+	 * get_more_blocks() expects us to describe a hole by clearing
+	 * the mapped bit on bh_result().
+	 *
+	 * Consider an unwritten extent as a hole.
+	 */
+	if (p_blkno && !(ext_flags & OCFS2_EXT_UNWRITTEN))
+		map_bh(bh_result, inode->i_sb, p_blkno);
+	else {
+		/*
+		 * ocfs2_prepare_inode_for_write() should have caught
+		 * the case where we'd be filling a hole and triggered
+		 * a buffered write instead.
+		 */
+		if (create) {
+			ret = -EIO;
+			mlog_errno(ret);
+			goto bail;
+		}
+
+		clear_buffer_mapped(bh_result);
+	}
@@ -608,0 +527 @@
+	int level;
@@ -611,0 +531 @@
+
@@ -613,2 +533,5 @@
-	up_read(&inode->i_alloc_sem);
-	ocfs2_rw_unlock(inode, 0);
+
+	level = ocfs2_iocb_rw_locked_level(iocb);
+	if (!level)
+		up_read(&inode->i_alloc_sem);
+	ocfs2_rw_unlock(inode, level);
@@ -650,15 +573,20 @@
-	/*
-	 * We get PR data locks even for O_DIRECT.  This allows
-	 * concurrent O_DIRECT I/O but doesn't let O_DIRECT with
-	 * extending and buffered zeroing writes race.  If they did
-	 * race then the buffered zeroing could be written back after
-	 * the O_DIRECT I/O.  It's one thing to tell people not to mix
-	 * buffered and O_DIRECT writes, but expecting them to
-	 * understand that file extension is also an implicit buffered
-	 * write is too much.  By getting the PR we force writeback of
-	 * the buffered zeroing before proceeding.
-	 */
-	ret = ocfs2_data_lock(inode, 0);
-	if (ret < 0) {
-		mlog_errno(ret);
-		goto out;
+	if (!ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb))) {
+		/*
+		 * We get PR data locks even for O_DIRECT.  This
+		 * allows concurrent O_DIRECT I/O but doesn't let
+		 * O_DIRECT with extending and buffered zeroing writes
+		 * race.  If they did race then the buffered zeroing
+		 * could be written back after the O_DIRECT I/O.  It's
+		 * one thing to tell people not to mix buffered and
+		 * O_DIRECT writes, but expecting them to understand
+		 * that file extension is also an implicit buffered
+		 * write is too much.  By getting the PR we force
+		 * writeback of the buffered zeroing before
+		 * proceeding.
+		 */
+		ret = ocfs2_data_lock(inode, 0);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+		ocfs2_data_unlock(inode, 0);
@@ -666 +593,0 @@
-	ocfs2_data_unlock(inode, 0);
@@ -677,0 +605,706 @@
+static void ocfs2_figure_cluster_boundaries(struct ocfs2_super *osb,
+					    u32 cpos,
+					    unsigned int *start,
+					    unsigned int *end)
+{
+	unsigned int cluster_start = 0, cluster_end = PAGE_CACHE_SIZE;
+
+	if (unlikely(PAGE_CACHE_SHIFT > osb->s_clustersize_bits)) {
+		unsigned int cpp;
+
+		cpp = 1 << (PAGE_CACHE_SHIFT - osb->s_clustersize_bits);
+
+		cluster_start = cpos % cpp;
+		cluster_start = cluster_start << osb->s_clustersize_bits;
+
+		cluster_end = cluster_start + osb->s_clustersize;
+	}
+
+	BUG_ON(cluster_start > PAGE_SIZE);
+	BUG_ON(cluster_end > PAGE_SIZE);
+
+	if (start)
+		*start = cluster_start;
+	if (end)
+		*end = cluster_end;
+}
+
+/*
+ * 'from' and 'to' are the region in the page to avoid zeroing.
+ *
+ * If pagesize > clustersize, this function will avoid zeroing outside
+ * of the cluster boundary.
+ *
+ * from == to == 0 is code for "zero the entire cluster region"
+ */
+static void ocfs2_clear_page_regions(struct page *page,
+				     struct ocfs2_super *osb, u32 cpos,
+				     unsigned from, unsigned to)
+{
+	void *kaddr;
+	unsigned int cluster_start, cluster_end;
+
+	ocfs2_figure_cluster_boundaries(osb, cpos, &cluster_start, &cluster_end);
+
+	kaddr = kmap_atomic(page, KM_USER0);
+
+	if (from || to) {
+		if (from > cluster_start)
+			memset(kaddr + cluster_start, 0, from - cluster_start);
+		if (to < cluster_end)
+			memset(kaddr + to, 0, cluster_end - to);
+	} else {
+		memset(kaddr + cluster_start, 0, cluster_end - cluster_start);
+	}
+
+	kunmap_atomic(kaddr, KM_USER0);
+}
+
+/*
+ * Some of this taken from block_prepare_write(). We already have our
+ * mapping by now though, and the entire write will be allocating or
+ * it won't, so not much need to use BH_New.
+ *
+ * This will also skip zeroing, which is handled externally.
+ */
+int ocfs2_map_page_blocks(struct page *page, u64 *p_blkno,
+			  struct inode *inode, unsigned int from,
+			  unsigned int to, int new)
+{
+	int ret = 0;
+	struct buffer_head *head, *bh, *wait[2], **wait_bh = wait;
+	unsigned int block_end, block_start;
+	unsigned int bsize = 1 << inode->i_blkbits;
+
+	if (!page_has_buffers(page))
+		create_empty_buffers(page, bsize, 0);
+
+	head = page_buffers(page);
+	for (bh = head, block_start = 0; bh != head || !block_start;
+	     bh = bh->b_this_page, block_start += bsize) {
+		block_end = block_start + bsize;
+
+		/*
+		 * Ignore blocks outside of our i/o range -
+		 * they may belong to unallocated clusters.
+		 */
+		if (block_start >= to || block_end <= from) {
+			if (PageUptodate(page))
+				set_buffer_uptodate(bh);
+			continue;
+		}
+
+		/*
+		 * For an allocating write with cluster size >= page
+		 * size, we always write the entire page.
+		 */
+
+		if (buffer_new(bh))
+			clear_buffer_new(bh);
+
+		if (!buffer_mapped(bh)) {
+			map_bh(bh, inode->i_sb, *p_blkno);
+			unmap_underlying_metadata(bh->b_bdev, bh->b_blocknr);
+		}
+
+		if (PageUptodate(page)) {
+			if (!buffer_uptodate(bh))
+				set_buffer_uptodate(bh);
+		} else if (!buffer_uptodate(bh) && !buffer_delay(bh) &&
+		     (block_start < from || block_end > to)) {
+			ll_rw_block(READ, 1, &bh);
+			*wait_bh++=bh;
+		}
+
+		*p_blkno = *p_blkno + 1;
+	}
+
+	/*
+	 * If we issued read requests - let them complete.
+	 */
+	while(wait_bh > wait) {
+		wait_on_buffer(*--wait_bh);
+		if (!buffer_uptodate(*wait_bh))
+			ret = -EIO;
+	}
+
+	if (ret == 0 || !new)
+		return ret;
+
+	/*
+	 * If we get -EIO above, zero out any newly allocated blocks
+	 * to avoid exposing stale data.
+	 */
+	bh = head;
+	block_start = 0;
+	do {
+		void *kaddr;
+
+		block_end = block_start + bsize;
+		if (block_end <= from)
+			goto next_bh;
+		if (block_start >= to)
+			break;
+
+		kaddr = kmap_atomic(page, KM_USER0);
+		memset(kaddr+block_start, 0, bh->b_size);
+		flush_dcache_page(page);
+		kunmap_atomic(kaddr, KM_USER0);
+		set_buffer_uptodate(bh);
+		mark_buffer_dirty(bh);
+
+next_bh:
+		block_start = block_end;
+		bh = bh->b_this_page;
+	} while (bh != head);
+
+	return ret;
+}
+
+/*
+ * This will copy user data from the buffer page in the splice
+ * context.
+ *
+ * For now, we ignore SPLICE_F_MOVE as that would require some extra
+ * communication out all the way to ocfs2_write().
+ */
+int ocfs2_map_and_write_splice_data(struct inode *inode,
+				  struct ocfs2_write_ctxt *wc, u64 *p_blkno,
+				  unsigned int *ret_from, unsigned int *ret_to)
+{
+	int ret;
+	unsigned int to, from, cluster_start, cluster_end;
+	char *src, *dst;
+	struct ocfs2_splice_write_priv *sp = wc->w_private;
+	struct pipe_buffer *buf = sp->s_buf;
+	unsigned long bytes, src_from;
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+
+	ocfs2_figure_cluster_boundaries(osb, wc->w_cpos, &cluster_start,
+					&cluster_end);
+
+	from = sp->s_offset;
+	src_from = sp->s_buf_offset;
+	bytes = wc->w_count;
+
+	if (wc->w_large_pages) {
+		/*
+		 * For cluster size < page size, we have to
+		 * calculate pos within the cluster and obey
+		 * the rightmost boundary.
+		 */
+		bytes = min(bytes, (unsigned long)(osb->s_clustersize
+				   - (wc->w_pos & (osb->s_clustersize - 1))));
+	}
+	to = from + bytes;
+
+	BUG_ON(from > PAGE_CACHE_SIZE);
+	BUG_ON(to > PAGE_CACHE_SIZE);
+	BUG_ON(from < cluster_start);
+	BUG_ON(to > cluster_end);
+
+	if (wc->w_this_page_new)
+		ret = ocfs2_map_page_blocks(wc->w_this_page, p_blkno, inode,
+					    cluster_start, cluster_end, 1);
+	else
+		ret = ocfs2_map_page_blocks(wc->w_this_page, p_blkno, inode,
+					    from, to, 0);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	src = buf->ops->map(sp->s_pipe, buf, 1);
+	dst = kmap_atomic(wc->w_this_page, KM_USER1);
+	memcpy(dst + from, src + src_from, bytes);
+	kunmap_atomic(wc->w_this_page, KM_USER1);
+	buf->ops->unmap(sp->s_pipe, buf, src);
+
+	wc->w_finished_copy = 1;
+
+	*ret_from = from;
+	*ret_to = to;
+out:
+
+	return bytes ? (unsigned int)bytes : ret;
+}
+
+/*
+ * This will copy user data from the iovec in the buffered write
+ * context.
+ */
+int ocfs2_map_and_write_user_data(struct inode *inode,
+				  struct ocfs2_write_ctxt *wc, u64 *p_blkno,
+				  unsigned int *ret_from, unsigned int *ret_to)
+{
+	int ret;
+	unsigned int to, from, cluster_start, cluster_end;
+	unsigned long bytes, src_from;
+	char *dst;
+	struct ocfs2_buffered_write_priv *bp = wc->w_private;
+	const struct iovec *cur_iov = bp->b_cur_iov;
+	char __user *buf;
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+
+	ocfs2_figure_cluster_boundaries(osb, wc->w_cpos, &cluster_start,
+					&cluster_end);
+
+	buf = cur_iov->iov_base + bp->b_cur_off;
+	src_from = (unsigned long)buf & ~PAGE_CACHE_MASK;
+
+	from = wc->w_pos & (PAGE_CACHE_SIZE - 1);
+
+	/*
+	 * This is a lot of comparisons, but it reads quite
+	 * easily, which is important here.
+	 */
+	/* Stay within the src page */
+	bytes = PAGE_SIZE - src_from;
+	/* Stay within the vector */
+	bytes = min(bytes,
+		    (unsigned long)(cur_iov->iov_len - bp->b_cur_off));
+	/* Stay within count */
+	bytes = min(bytes, (unsigned long)wc->w_count);
+	/*
+	 * For clustersize > page size, just stay within
+	 * target page, otherwise we have to calculate pos
+	 * within the cluster and obey the rightmost
+	 * boundary.
+	 */
+	if (wc->w_large_pages) {
+		/*
+		 * For cluster size < page size, we have to
+		 * calculate pos within the cluster and obey
+		 * the rightmost boundary.
+		 */
+		bytes = min(bytes, (unsigned long)(osb->s_clustersize
+				   - (wc->w_pos & (osb->s_clustersize - 1))));
+	} else {
+		/*
+		 * cluster size > page size is the most common
+		 * case - we just stay within the target page
+		 * boundary.
+		 */
+		bytes = min(bytes, PAGE_CACHE_SIZE - from);
+	}
+
+	to = from + bytes;
+
+	BUG_ON(from > PAGE_CACHE_SIZE);
+	BUG_ON(to > PAGE_CACHE_SIZE);
+	BUG_ON(from < cluster_start);
+	BUG_ON(to > cluster_end);
+
+	if (wc->w_this_page_new)
+		ret = ocfs2_map_page_blocks(wc->w_this_page, p_blkno, inode,
+					    cluster_start, cluster_end, 1);
+	else
+		ret = ocfs2_map_page_blocks(wc->w_this_page, p_blkno, inode,
+					    from, to, 0);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	dst = kmap(wc->w_this_page);
+	memcpy(dst + from, bp->b_src_buf + src_from, bytes);
+	kunmap(wc->w_this_page);
+
+	/*
+	 * XXX: This is slow, but simple. The caller of
+	 * ocfs2_buffered_write_cluster() is responsible for
+	 * passing through the iovecs, so it's difficult to
+	 * predict what our next step is in here after our
+	 * initial write. A future version should be pushing
+	 * that iovec manipulation further down.
+	 *
+	 * By setting this, we indicate that a copy from user
+	 * data was done, and subsequent calls for this
+	 * cluster will skip copying more data.
+	 */
+	wc->w_finished_copy = 1;
+
+	*ret_from = from;
+	*ret_to = to;
+out:
+
+	return bytes ? (unsigned int)bytes : ret;
+}
+
+/*
+ * Map, fill and write a page to disk.
+ *
+ * The work of copying data is done via callback.  Newly allocated
+ * pages which don't take user data will be zero'd (set 'new' to
+ * indicate an allocating write)
+ *
+ * Returns a negative error code or the number of bytes copied into
+ * the page.
+ */
+static int ocfs2_write_data_page(struct inode *inode, handle_t *handle,
+				 u64 *p_blkno, struct page *page,
+				 struct ocfs2_write_ctxt *wc, int new)
+{
+	int ret, copied = 0;
+	unsigned int from = 0, to = 0;
+	unsigned int cluster_start, cluster_end;
+	unsigned int zero_from = 0, zero_to = 0;
+
+	ocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), wc->w_cpos,
+					&cluster_start, &cluster_end);
+
+	if ((wc->w_pos >> PAGE_CACHE_SHIFT) == page->index
+	    && !wc->w_finished_copy) {
+
+		wc->w_this_page = page;
+		wc->w_this_page_new = new;
+		ret = wc->w_write_data_page(inode, wc, p_blkno, &from, &to);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		copied = ret;
+
+		zero_from = from;
+		zero_to = to;
+		if (new) {
+			from = cluster_start;
+			to = cluster_end;
+		}
+	} else {
+		/*
+		 * If we haven't allocated the new page yet, we
+		 * shouldn't be writing it out without copying user
+		 * data. This is likely a math error from the caller.
+		 */
+		BUG_ON(!new);
+
+		from = cluster_start;
+		to = cluster_end;
+
+		ret = ocfs2_map_page_blocks(page, p_blkno, inode,
+					    cluster_start, cluster_end, 1);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+	/*
+	 * Parts of newly allocated pages need to be zero'd.
+	 *
+	 * Above, we have also rewritten 'to' and 'from' - as far as
+	 * the rest of the function is concerned, the entire cluster
+	 * range inside of a page needs to be written.
+	 *
+	 * We can skip this if the page is up to date - it's already
+	 * been zero'd from being read in as a hole.
+	 */
+	if (new && !PageUptodate(page))
+		ocfs2_clear_page_regions(page, OCFS2_SB(inode->i_sb),
+					 wc->w_cpos, zero_from, zero_to);
+
+	flush_dcache_page(page);
+
+	if (ocfs2_should_order_data(inode)) {
+		ret = walk_page_buffers(handle,
+					page_buffers(page),
+					from, to, NULL,
+					ocfs2_journal_dirty_data);
+		if (ret < 0)
+			mlog_errno(ret);
+	}
+
+	/*
+	 * We don't use generic_commit_write() because we need to
+	 * handle our own i_size update.
+	 */
+	ret = block_commit_write(page, from, to);
+	if (ret)
+		mlog_errno(ret);
+out:
+
+	return copied ? copied : ret;
+}
+
+/*
+ * Do the actual write of some data into an inode. Optionally allocate
+ * in order to fulfill the write.
+ *
+ * cpos is the logical cluster offset within the file to write at
+ *
+ * 'phys' is the physical mapping of that offset. a 'phys' value of
+ * zero indicates that allocation is required. In this case, data_ac
+ * and meta_ac should be valid (meta_ac can be null if metadata
+ * allocation isn't required).
+ */
+static ssize_t ocfs2_write(struct file *file, u32 phys, handle_t *handle,
+			   struct buffer_head *di_bh,
+			   struct ocfs2_alloc_context *data_ac,
+			   struct ocfs2_alloc_context *meta_ac,
+			   struct ocfs2_write_ctxt *wc)
+{
+	int ret, i, numpages = 1, new;
+	unsigned int copied = 0;
+	u32 tmp_pos;
+	u64 v_blkno, p_blkno;
+	struct address_space *mapping = file->f_mapping;
+	struct inode *inode = mapping->host;
+	unsigned long index, start;
+	struct page **cpages;
+
+	new = phys == 0 ? 1 : 0;
+
+	/*
+	 * Figure out how many pages we'll be manipulating here. For
+	 * non allocating write, we just change the one
+	 * page. Otherwise, we'll need a whole clusters worth.
+	 */
+	if (new)
+		numpages = ocfs2_pages_per_cluster(inode->i_sb);
+
+	cpages = kzalloc(sizeof(*cpages) * numpages, GFP_NOFS);
+	if (!cpages) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		return ret;
+	}
+
+	/*
+	 * Fill our page array first. That way we've grabbed enough so
+	 * that we can zero and flush if we error after adding the
+	 * extent.
+	 */
+	if (new) {
+		start = ocfs2_align_clusters_to_page_index(inode->i_sb,
+							   wc->w_cpos);
+		v_blkno = ocfs2_clusters_to_blocks(inode->i_sb, wc->w_cpos);
+	} else {
+		start = wc->w_pos >> PAGE_CACHE_SHIFT;
+		v_blkno = wc->w_pos >> inode->i_sb->s_blocksize_bits;
+	}
+
+	for(i = 0; i < numpages; i++) {
+		index = start + i;
+
+		cpages[i] = find_or_create_page(mapping, index, GFP_NOFS);
+		if (!cpages[i]) {
+			ret = -ENOMEM;
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+	if (new) {
+		/*
+		 * This is safe to call with the page locks - it won't take
+		 * any additional semaphores or cluster locks.
+		 */
+		tmp_pos = wc->w_cpos;
+		ret = ocfs2_do_extend_allocation(OCFS2_SB(inode->i_sb), inode,
+						 &tmp_pos, 1, di_bh, handle,
+						 data_ac, meta_ac, NULL);
+		/*
+		 * This shouldn't happen because we must have already
+		 * calculated the correct meta data allocation required. The
+		 * internal tree allocation code should know how to increase
+		 * transaction credits itself.
+		 *
+		 * If need be, we could handle -EAGAIN for a
+		 * RESTART_TRANS here.
+		 */
+		mlog_bug_on_msg(ret == -EAGAIN,
+				"Inode %llu: EAGAIN return during allocation.\n",
+				(unsigned long long)OCFS2_I(inode)->ip_blkno);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+	ret = ocfs2_extent_map_get_blocks(inode, v_blkno, &p_blkno, NULL,
+					  NULL);
+	if (ret < 0) {
+
+		/*
+		 * XXX: Should we go readonly here?
+		 */
+
+		mlog_errno(ret);
+		goto out;
+	}
+
+	BUG_ON(p_blkno == 0);
+
+	for(i = 0; i < numpages; i++) {
+		ret = ocfs2_write_data_page(inode, handle, &p_blkno, cpages[i],
+					    wc, new);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+
+		copied += ret;
+	}
+
+out:
+	for(i = 0; i < numpages; i++) {
+		unlock_page(cpages[i]);
+		mark_page_accessed(cpages[i]);
+		page_cache_release(cpages[i]);
+	}
+	kfree(cpages);
+
+	return copied ? copied : ret;
+}
+
+static void ocfs2_write_ctxt_init(struct ocfs2_write_ctxt *wc,
+				  struct ocfs2_super *osb, loff_t pos,
+				  size_t count, ocfs2_page_writer *cb,
+				  void *cb_priv)
+{
+	wc->w_count = count;
+	wc->w_pos = pos;
+	wc->w_cpos = wc->w_pos >> osb->s_clustersize_bits;
+	wc->w_finished_copy = 0;
+
+	if (unlikely(PAGE_CACHE_SHIFT > osb->s_clustersize_bits))
+		wc->w_large_pages = 1;
+	else
+		wc->w_large_pages = 0;
+
+	wc->w_write_data_page = cb;
+	wc->w_private = cb_priv;
+}
+
+/*
+ * Write a cluster to an inode. The cluster may not be allocated yet,
+ * in which case it will be. This only exists for buffered writes -
+ * O_DIRECT takes a more "traditional" path through the kernel.
+ *
+ * The caller is responsible for incrementing pos, written counts, etc
+ *
+ * For file systems that don't support sparse files, pre-allocation
+ * and page zeroing up until cpos should be done prior to this
+ * function call.
+ *
+ * Callers should be holding i_sem, and the rw cluster lock.
+ *
+ * Returns the number of user bytes written, or less than zero for
+ * error.
+ */
+ssize_t ocfs2_buffered_write_cluster(struct file *file, loff_t pos,
+				     size_t count, ocfs2_page_writer *actor,
+				     void *priv)
+{
+	int ret, credits = OCFS2_INODE_UPDATE_CREDITS;
+	ssize_t written = 0;
+	u32 phys;
+	struct inode *inode = file->f_mapping->host;
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	struct buffer_head *di_bh = NULL;
+	struct ocfs2_dinode *di;
+	struct ocfs2_alloc_context *data_ac = NULL;
+	struct ocfs2_alloc_context *meta_ac = NULL;
+	handle_t *handle;
+	struct ocfs2_write_ctxt wc;
+
+	ocfs2_write_ctxt_init(&wc, osb, pos, count, actor, priv);
+
+	ret = ocfs2_meta_lock(inode, &di_bh, 1);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+	di = (struct ocfs2_dinode *)di_bh->b_data;
+
+	/*
+	 * Take alloc sem here to prevent concurrent lookups. That way
+	 * the mapping, zeroing and tree manipulation within
+	 * ocfs2_write() will be safe against ->readpage(). This
+	 * should also serve to lock out allocation from a shared
+	 * writeable region.
+	 */
+	down_write(&OCFS2_I(inode)->ip_alloc_sem);
+
+	ret = ocfs2_get_clusters(inode, wc.w_cpos, &phys, NULL, NULL);
+	if (ret) {
+		mlog_errno(ret);
+		goto out_meta;
+	}
+
+	/* phys == 0 means that allocation is required. */
+	if (phys == 0) {
+		ret = ocfs2_lock_allocators(inode, di, 1, &data_ac, &meta_ac);
+		if (ret) {
+			mlog_errno(ret);
+			goto out_meta;
+		}
+
+		credits = ocfs2_calc_extend_credits(inode->i_sb, di, 1);
+	}
+
+	ret = ocfs2_data_lock(inode, 1);
+	if (ret) {
+		mlog_errno(ret);
+		goto out_meta;
+	}
+
+	handle = ocfs2_start_trans(osb, credits);
+	if (IS_ERR(handle)) {
+		ret = PTR_ERR(handle);
+		mlog_errno(ret);
+		goto out_data;
+	}
+
+	written = ocfs2_write(file, phys, handle, di_bh, data_ac,
+			      meta_ac, &wc);
+	if (written < 0) {
+		ret = written;
+		mlog_errno(ret);
+		goto out_commit;
+	}
+
+	ret = ocfs2_journal_access(handle, inode, di_bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
+		mlog_errno(ret);
+		goto out_commit;
+	}
+
+	pos += written;
+	if (pos > inode->i_size) {
+		i_size_write(inode, pos);
+		mark_inode_dirty(inode);
+	}
+	inode->i_blocks = ocfs2_inode_sector_count(inode);
+	di->i_size = cpu_to_le64((u64)i_size_read(inode));
+	inode->i_mtime = inode->i_ctime = CURRENT_TIME;
+	di->i_mtime = di->i_ctime = cpu_to_le64(inode->i_mtime.tv_sec);
+	di->i_mtime_nsec = di->i_ctime_nsec = cpu_to_le32(inode->i_mtime.tv_nsec);
+
+	ret = ocfs2_journal_dirty(handle, di_bh);
+	if (ret)
+		mlog_errno(ret);
+
+out_commit:
+	ocfs2_commit_trans(osb, handle);
+
+out_data:
+	ocfs2_data_unlock(inode, 1);
+
+out_meta:
+	up_write(&OCFS2_I(inode)->ip_alloc_sem);
+	ocfs2_meta_unlock(inode, 1);
+
+out:
+	brelse(di_bh);
+	if (data_ac)
+		ocfs2_free_alloc_context(data_ac);
+	if (meta_ac)
+		ocfs2_free_alloc_context(meta_ac);
+
+	return written ? written : ret;
+}
+
@@ -681,2 +1313,0 @@
-	.prepare_write	= ocfs2_prepare_write,
-	.commit_write	= ocfs2_commit_write,
--- ./projects/linux/linux-2.6.22/fs/ocfs2/aops.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/fs/ocfs2/aops.c	2007-10-09 22:31:38.000000000 +0200
@@ -235 +235 @@
-	 * (generic_file_read, fault->nopage) are clever enough to check i_size
+	 * (generic_file_read, vm_ops->fault) are clever enough to check i_size
@@ -686,0 +687,2 @@
+		clear_buffer_new(bh);
+
@@ -701,3 +703,2 @@
-
-		if (buffer_new(bh))
-			clear_buffer_new(bh);
+		if (new)
+			set_buffer_new(bh);
@@ -714 +715,2 @@
-		     (block_start < from || block_end > to)) {
+			   !buffer_new(bh) &&
+			   (block_start < from || block_end > to)) {
@@ -741,2 +742,0 @@
-		void *kaddr;
-
@@ -749,4 +749 @@
-		kaddr = kmap_atomic(page, KM_USER0);
-		memset(kaddr+block_start, 0, bh->b_size);
-		flush_dcache_page(page);
-		kunmap_atomic(kaddr, KM_USER0);
+		zero_user_page(page, block_start, bh->b_size, KM_USER0);
@@ -763,0 +761,8 @@
+#if (PAGE_CACHE_SIZE >= OCFS2_MAX_CLUSTERSIZE)
+#define OCFS2_MAX_CTXT_PAGES	1
+#else
+#define OCFS2_MAX_CTXT_PAGES	(OCFS2_MAX_CLUSTERSIZE / PAGE_CACHE_SIZE)
+#endif
+
+#define OCFS2_MAX_CLUSTERS_PER_PAGE	(PAGE_CACHE_SIZE / OCFS2_MIN_CLUSTERSIZE)
+
@@ -765,5 +770 @@
- * This will copy user data from the buffer page in the splice
- * context.
- *
- * For now, we ignore SPLICE_F_MOVE as that would require some extra
- * communication out all the way to ocfs2_write().
+ * Describe the state of a single cluster to be written to.
@@ -771,3 +772,12 @@
-int ocfs2_map_and_write_splice_data(struct inode *inode,
-				  struct ocfs2_write_ctxt *wc, u64 *p_blkno,
-				  unsigned int *ret_from, unsigned int *ret_to)
+struct ocfs2_write_cluster_desc {
+	u32		c_cpos;
+	u32		c_phys;
+	/*
+	 * Give this a unique field because c_phys eventually gets
+	 * filled.
+	 */
+	unsigned	c_new;
+	unsigned	c_unwritten;
+};
+
+static inline int ocfs2_should_zero_cluster(struct ocfs2_write_cluster_desc *d)
@@ -775,7 +785,2 @@
-	int ret;
-	unsigned int to, from, cluster_start, cluster_end;
-	char *src, *dst;
-	struct ocfs2_splice_write_priv *sp = wc->w_private;
-	struct pipe_buffer *buf = sp->s_buf;
-	unsigned long bytes, src_from;
-	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	return d->c_new || d->c_unwritten;
+}
@@ -783,2 +788,4 @@
-	ocfs2_figure_cluster_boundaries(osb, wc->w_cpos, &cluster_start,
-					&cluster_end);
+struct ocfs2_write_ctxt {
+	/* Logical cluster position / len of write */
+	u32				w_cpos;
+	u32				w_clen;
@@ -786,3 +793 @@
-	from = sp->s_offset;
-	src_from = sp->s_buf_offset;
-	bytes = wc->w_count;
+	struct ocfs2_write_cluster_desc	w_desc[OCFS2_MAX_CLUSTERS_PER_PAGE];
@@ -790,10 +795,7 @@
-	if (wc->w_large_pages) {
-		/*
-		 * For cluster size < page size, we have to
-		 * calculate pos within the cluster and obey
-		 * the rightmost boundary.
-		 */
-		bytes = min(bytes, (unsigned long)(osb->s_clustersize
-				   - (wc->w_pos & (osb->s_clustersize - 1))));
-	}
-	to = from + bytes;
+	/*
+	 * This is true if page_size > cluster_size.
+	 *
+	 * It triggers a set of special cases during write which might
+	 * have to deal with allocating writes to partial pages.
+	 */
+	unsigned int			w_large_pages;
@@ -801,15 +803,15 @@
-	BUG_ON(from > PAGE_CACHE_SIZE);
-	BUG_ON(to > PAGE_CACHE_SIZE);
-	BUG_ON(from < cluster_start);
-	BUG_ON(to > cluster_end);
-
-	if (wc->w_this_page_new)
-		ret = ocfs2_map_page_blocks(wc->w_this_page, p_blkno, inode,
-					    cluster_start, cluster_end, 1);
-	else
-		ret = ocfs2_map_page_blocks(wc->w_this_page, p_blkno, inode,
-					    from, to, 0);
-	if (ret) {
-		mlog_errno(ret);
-		goto out;
-	}
+	/*
+	 * Pages involved in this write.
+	 *
+	 * w_target_page is the page being written to by the user.
+	 *
+	 * w_pages is an array of pages which always contains
+	 * w_target_page, and in the case of an allocating write with
+	 * page_size < cluster size, it will contain zero'd and mapped
+	 * pages adjacent to w_target_page which need to be written
+	 * out in so that future reads from that region will get
+	 * zero's.
+	 */
+	struct page			*w_pages[OCFS2_MAX_CTXT_PAGES];
+	unsigned int			w_num_pages;
+	struct page			*w_target_page;
@@ -817,5 +819,6 @@
-	src = buf->ops->map(sp->s_pipe, buf, 1);
-	dst = kmap_atomic(wc->w_this_page, KM_USER1);
-	memcpy(dst + from, src + src_from, bytes);
-	kunmap_atomic(wc->w_this_page, KM_USER1);
-	buf->ops->unmap(sp->s_pipe, buf, src);
+	/*
+	 * ocfs2_write_end() uses this to know what the real range to
+	 * write in the target should be.
+	 */
+	unsigned int			w_target_from;
+	unsigned int			w_target_to;
@@ -823 +826,5 @@
-	wc->w_finished_copy = 1;
+	/*
+	 * We could use journal_current_handle() but this is cleaner,
+	 * IMHO -Mark
+	 */
+	handle_t			*w_handle;
@@ -825,3 +832 @@
-	*ret_from = from;
-	*ret_to = to;
-out:
+	struct buffer_head		*w_di_bh;
@@ -829,2 +834,2 @@
-	return bytes ? (unsigned int)bytes : ret;
-}
+	struct ocfs2_cached_dealloc_ctxt w_dealloc;
+};
@@ -832,7 +837 @@
-/*
- * This will copy user data from the iovec in the buffered write
- * context.
- */
-int ocfs2_map_and_write_user_data(struct inode *inode,
-				  struct ocfs2_write_ctxt *wc, u64 *p_blkno,
-				  unsigned int *ret_from, unsigned int *ret_to)
+static void ocfs2_free_write_ctxt(struct ocfs2_write_ctxt *wc)
@@ -840,11 +839 @@
-	int ret;
-	unsigned int to, from, cluster_start, cluster_end;
-	unsigned long bytes, src_from;
-	char *dst;
-	struct ocfs2_buffered_write_priv *bp = wc->w_private;
-	const struct iovec *cur_iov = bp->b_cur_iov;
-	char __user *buf;
-	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
-
-	ocfs2_figure_cluster_boundaries(osb, wc->w_cpos, &cluster_start,
-					&cluster_end);
+	int i;
@@ -852,4 +841,3 @@
-	buf = cur_iov->iov_base + bp->b_cur_off;
-	src_from = (unsigned long)buf & ~PAGE_CACHE_MASK;
-
-	from = wc->w_pos & (PAGE_CACHE_SIZE - 1);
+	for(i = 0; i < wc->w_num_pages; i++) {
+		if (wc->w_pages[i] == NULL)
+			continue;
@@ -857,32 +845,3 @@
-	/*
-	 * This is a lot of comparisons, but it reads quite
-	 * easily, which is important here.
-	 */
-	/* Stay within the src page */
-	bytes = PAGE_SIZE - src_from;
-	/* Stay within the vector */
-	bytes = min(bytes,
-		    (unsigned long)(cur_iov->iov_len - bp->b_cur_off));
-	/* Stay within count */
-	bytes = min(bytes, (unsigned long)wc->w_count);
-	/*
-	 * For clustersize > page size, just stay within
-	 * target page, otherwise we have to calculate pos
-	 * within the cluster and obey the rightmost
-	 * boundary.
-	 */
-	if (wc->w_large_pages) {
-		/*
-		 * For cluster size < page size, we have to
-		 * calculate pos within the cluster and obey
-		 * the rightmost boundary.
-		 */
-		bytes = min(bytes, (unsigned long)(osb->s_clustersize
-				   - (wc->w_pos & (osb->s_clustersize - 1))));
-	} else {
-		/*
-		 * cluster size > page size is the most common
-		 * case - we just stay within the target page
-		 * boundary.
-		 */
-		bytes = min(bytes, PAGE_CACHE_SIZE - from);
+		unlock_page(wc->w_pages[i]);
+		mark_page_accessed(wc->w_pages[i]);
+		page_cache_release(wc->w_pages[i]);
@@ -891 +850,3 @@
-	to = from + bytes;
+	brelse(wc->w_di_bh);
+	kfree(wc);
+}
@@ -893,4 +854,16 @@
-	BUG_ON(from > PAGE_CACHE_SIZE);
-	BUG_ON(to > PAGE_CACHE_SIZE);
-	BUG_ON(from < cluster_start);
-	BUG_ON(to > cluster_end);
+static int ocfs2_alloc_write_ctxt(struct ocfs2_write_ctxt **wcp,
+				  struct ocfs2_super *osb, loff_t pos,
+				  unsigned len, struct buffer_head *di_bh)
+{
+	u32 cend;
+	struct ocfs2_write_ctxt *wc;
+
+	wc = kzalloc(sizeof(struct ocfs2_write_ctxt), GFP_NOFS);
+	if (!wc)
+		return -ENOMEM;
+
+	wc->w_cpos = pos >> osb->s_clustersize_bits;
+	cend = (pos + len - 1) >> osb->s_clustersize_bits;
+	wc->w_clen = cend - wc->w_cpos + 1;
+	get_bh(di_bh);
+	wc->w_di_bh = di_bh;
@@ -898,3 +871,2 @@
-	if (wc->w_this_page_new)
-		ret = ocfs2_map_page_blocks(wc->w_this_page, p_blkno, inode,
-					    cluster_start, cluster_end, 1);
+	if (unlikely(PAGE_CACHE_SHIFT > osb->s_clustersize_bits))
+		wc->w_large_pages = 1;
@@ -902,6 +874 @@
-		ret = ocfs2_map_page_blocks(wc->w_this_page, p_blkno, inode,
-					    from, to, 0);
-	if (ret) {
-		mlog_errno(ret);
-		goto out;
-	}
+		wc->w_large_pages = 0;
@@ -909,3 +876 @@
-	dst = kmap(wc->w_this_page);
-	memcpy(dst + from, bp->b_src_buf + src_from, bytes);
-	kunmap(wc->w_this_page);
+	ocfs2_init_dealloc_ctxt(&wc->w_dealloc);
@@ -913,13 +878 @@
-	/*
-	 * XXX: This is slow, but simple. The caller of
-	 * ocfs2_buffered_write_cluster() is responsible for
-	 * passing through the iovecs, so it's difficult to
-	 * predict what our next step is in here after our
-	 * initial write. A future version should be pushing
-	 * that iovec manipulation further down.
-	 *
-	 * By setting this, we indicate that a copy from user
-	 * data was done, and subsequent calls for this
-	 * cluster will skip copying more data.
-	 */
-	wc->w_finished_copy = 1;
+	*wcp = wc;
@@ -927,3 +880,16 @@
-	*ret_from = from;
-	*ret_to = to;
-out:
+	return 0;
+}
+
+/*
+ * If a page has any new buffers, zero them out here, and mark them uptodate
+ * and dirty so they'll be written out (in order to prevent uninitialised
+ * block data from leaking). And clear the new bit.
+ */
+static void ocfs2_zero_new_buffers(struct page *page, unsigned from, unsigned to)
+{
+	unsigned int block_start, block_end;
+	struct buffer_head *head, *bh;
+
+	BUG_ON(!PageLocked(page));
+	if (!page_has_buffers(page))
+		return;
@@ -931 +897,25 @@
-	return bytes ? (unsigned int)bytes : ret;
+	bh = head = page_buffers(page);
+	block_start = 0;
+	do {
+		block_end = block_start + bh->b_size;
+
+		if (buffer_new(bh)) {
+			if (block_end > from && block_start < to) {
+				if (!PageUptodate(page)) {
+					unsigned start, end;
+
+					start = max(from, block_start);
+					end = min(to, block_end);
+
+					zero_user_page(page, start, end - start, KM_USER0);
+					set_buffer_uptodate(bh);
+				}
+
+				clear_buffer_new(bh);
+				mark_buffer_dirty(bh);
+			}
+		}
+
+		block_start = block_end;
+		bh = bh->b_this_page;
+	} while (bh != head);
@@ -935,8 +925,2 @@
- * Map, fill and write a page to disk.
- *
- * The work of copying data is done via callback.  Newly allocated
- * pages which don't take user data will be zero'd (set 'new' to
- * indicate an allocating write)
- *
- * Returns a negative error code or the number of bytes copied into
- * the page.
+ * Only called when we have a failure during allocating write to write
+ * zero's to the newly allocated region.
@@ -944,3 +928,3 @@
-static int ocfs2_write_data_page(struct inode *inode, handle_t *handle,
-				 u64 *p_blkno, struct page *page,
-				 struct ocfs2_write_ctxt *wc, int new)
+static void ocfs2_write_failure(struct inode *inode,
+				struct ocfs2_write_ctxt *wc,
+				loff_t user_pos, unsigned user_len)
@@ -948,2 +932,27 @@
-	int ret, copied = 0;
-	unsigned int from = 0, to = 0;
+	int i;
+	unsigned from = user_pos & (PAGE_CACHE_SIZE - 1),
+		to = user_pos + user_len;
+	struct page *tmppage;
+
+	ocfs2_zero_new_buffers(wc->w_target_page, from, to);
+
+	for(i = 0; i < wc->w_num_pages; i++) {
+		tmppage = wc->w_pages[i];
+
+		if (ocfs2_should_order_data(inode))
+			walk_page_buffers(wc->w_handle, page_buffers(tmppage),
+					  from, to, NULL,
+					  ocfs2_journal_dirty_data);
+
+		block_commit_write(tmppage, from, to);
+	}
+}
+
+static int ocfs2_prepare_page_for_write(struct inode *inode, u64 *p_blkno,
+					struct ocfs2_write_ctxt *wc,
+					struct page *page, u32 cpos,
+					loff_t user_pos, unsigned user_len,
+					int new)
+{
+	int ret;
+	unsigned int map_from = 0, map_to = 0;
@@ -951 +960 @@
-	unsigned int zero_from = 0, zero_to = 0;
+	unsigned int user_data_from = 0, user_data_to = 0;
@@ -953 +962 @@
-	ocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), wc->w_cpos,
+	ocfs2_figure_cluster_boundaries(OCFS2_SB(inode->i_sb), cpos,
@@ -956,7 +965,12 @@
-	if ((wc->w_pos >> PAGE_CACHE_SHIFT) == page->index
-	    && !wc->w_finished_copy) {
-
-		wc->w_this_page = page;
-		wc->w_this_page_new = new;
-		ret = wc->w_write_data_page(inode, wc, p_blkno, &from, &to);
-		if (ret < 0) {
+	if (page == wc->w_target_page) {
+		map_from = user_pos & (PAGE_CACHE_SIZE - 1);
+		map_to = map_from + user_len;
+
+		if (new)
+			ret = ocfs2_map_page_blocks(page, p_blkno, inode,
+						    cluster_start, cluster_end,
+						    new);
+		else
+			ret = ocfs2_map_page_blocks(page, p_blkno, inode,
+						    map_from, map_to, new);
+		if (ret) {
@@ -967,4 +981,2 @@
-		copied = ret;
-
-		zero_from = from;
-		zero_to = to;
+		user_data_from = map_from;
+		user_data_to = map_to;
@@ -972,2 +984,2 @@
-			from = cluster_start;
-			to = cluster_end;
+			map_from = cluster_start;
+			map_to = cluster_end;
@@ -983,2 +995,2 @@
-		from = cluster_start;
-		to = cluster_end;
+		map_from = cluster_start;
+		map_to = cluster_end;
@@ -987 +999 @@
-					    cluster_start, cluster_end, 1);
+					    cluster_start, cluster_end, new);
@@ -1006 +1018 @@
-					 wc->w_cpos, zero_from, zero_to);
+					 cpos, user_data_from, user_data_to);
@@ -1010,16 +1021,0 @@
-	if (ocfs2_should_order_data(inode)) {
-		ret = walk_page_buffers(handle,
-					page_buffers(page),
-					from, to, NULL,
-					ocfs2_journal_dirty_data);
-		if (ret < 0)
-			mlog_errno(ret);
-	}
-
-	/*
-	 * We don't use generic_commit_write() because we need to
-	 * handle our own i_size update.
-	 */
-	ret = block_commit_write(page, from, to);
-	if (ret)
-		mlog_errno(ret);
@@ -1027,2 +1023 @@
-
-	return copied ? copied : ret;
+	return ret;
@@ -1032,9 +1027 @@
- * Do the actual write of some data into an inode. Optionally allocate
- * in order to fulfill the write.
- *
- * cpos is the logical cluster offset within the file to write at
- *
- * 'phys' is the physical mapping of that offset. a 'phys' value of
- * zero indicates that allocation is required. In this case, data_ac
- * and meta_ac should be valid (meta_ac can be null if metadata
- * allocation isn't required).
+ * This function will only grab one clusters worth of pages.
@@ -1042,11 +1029,7 @@
-static ssize_t ocfs2_write(struct file *file, u32 phys, handle_t *handle,
-			   struct buffer_head *di_bh,
-			   struct ocfs2_alloc_context *data_ac,
-			   struct ocfs2_alloc_context *meta_ac,
-			   struct ocfs2_write_ctxt *wc)
-{
-	int ret, i, numpages = 1, new;
-	unsigned int copied = 0;
-	u32 tmp_pos;
-	u64 v_blkno, p_blkno;
-	struct address_space *mapping = file->f_mapping;
+static int ocfs2_grab_pages_for_write(struct address_space *mapping,
+				      struct ocfs2_write_ctxt *wc,
+				      u32 cpos, loff_t user_pos, int new,
+				      struct page *mmap_page)
+{
+	int ret = 0, i;
+	unsigned long start, target_index, index;
@@ -1054,2 +1036,0 @@
-	unsigned long index, start;
-	struct page **cpages;
@@ -1057 +1038 @@
-	new = phys == 0 ? 1 : 0;
+	target_index = user_pos >> PAGE_CACHE_SHIFT;
@@ -1064,15 +1044,0 @@
-	if (new)
-		numpages = ocfs2_pages_per_cluster(inode->i_sb);
-
-	cpages = kzalloc(sizeof(*cpages) * numpages, GFP_NOFS);
-	if (!cpages) {
-		ret = -ENOMEM;
-		mlog_errno(ret);
-		return ret;
-	}
-
-	/*
-	 * Fill our page array first. That way we've grabbed enough so
-	 * that we can zero and flush if we error after adding the
-	 * extent.
-	 */
@@ -1080,3 +1046,2 @@
-		start = ocfs2_align_clusters_to_page_index(inode->i_sb,
-							   wc->w_cpos);
-		v_blkno = ocfs2_clusters_to_blocks(inode->i_sb, wc->w_cpos);
+		wc->w_num_pages = ocfs2_pages_per_cluster(inode->i_sb);
+		start = ocfs2_align_clusters_to_page_index(inode->i_sb, cpos);
@@ -1084,2 +1049,2 @@
-		start = wc->w_pos >> PAGE_CACHE_SHIFT;
-		v_blkno = wc->w_pos >> inode->i_sb->s_blocksize_bits;
+		wc->w_num_pages = 1;
+		start = target_index;
@@ -1088 +1053 @@
-	for(i = 0; i < numpages; i++) {
+	for(i = 0; i < wc->w_num_pages; i++) {
@@ -1091,5 +1056,30 @@
-		cpages[i] = find_or_create_page(mapping, index, GFP_NOFS);
-		if (!cpages[i]) {
-			ret = -ENOMEM;
-			mlog_errno(ret);
-			goto out;
+		if (index == target_index && mmap_page) {
+			/*
+			 * ocfs2_pagemkwrite() is a little different
+			 * and wants us to directly use the page
+			 * passed in.
+			 */
+			lock_page(mmap_page);
+
+			if (mmap_page->mapping != mapping) {
+				unlock_page(mmap_page);
+				/*
+				 * Sanity check - the locking in
+				 * ocfs2_pagemkwrite() should ensure
+				 * that this code doesn't trigger.
+				 */
+				ret = -EINVAL;
+				mlog_errno(ret);
+				goto out;
+			}
+
+			page_cache_get(mmap_page);
+			wc->w_pages[i] = mmap_page;
+		} else {
+			wc->w_pages[i] = find_or_create_page(mapping, index,
+							     GFP_NOFS);
+			if (!wc->w_pages[i]) {
+				ret = -ENOMEM;
+				mlog_errno(ret);
+				goto out;
+			}
@@ -1096,0 +1087,3 @@
+
+		if (index == target_index)
+			wc->w_target_page = wc->w_pages[i];
@@ -1097,0 +1091,21 @@
+out:
+	return ret;
+}
+
+/*
+ * Prepare a single cluster for write one cluster into the file.
+ */
+static int ocfs2_write_cluster(struct address_space *mapping,
+			       u32 phys, unsigned int unwritten,
+			       struct ocfs2_alloc_context *data_ac,
+			       struct ocfs2_alloc_context *meta_ac,
+			       struct ocfs2_write_ctxt *wc, u32 cpos,
+			       loff_t user_pos, unsigned user_len)
+{
+	int ret, i, new, should_zero = 0;
+	u64 v_blkno, p_blkno;
+	struct inode *inode = mapping->host;
+
+	new = phys == 0 ? 1 : 0;
+	if (new || unwritten)
+		should_zero = 1;
@@ -1099,0 +1114,2 @@
+		u32 tmp_pos;
+
@@ -1104 +1120 @@
-		tmp_pos = wc->w_cpos;
+		tmp_pos = cpos;
@@ -1106,2 +1122,3 @@
-						 &tmp_pos, 1, di_bh, handle,
-						 data_ac, meta_ac, NULL);
+						 &tmp_pos, 1, 0, wc->w_di_bh,
+						 wc->w_handle, data_ac,
+						 meta_ac, NULL);
@@ -1123,0 +1141,8 @@
+	} else if (unwritten) {
+		ret = ocfs2_mark_extent_written(inode, wc->w_di_bh,
+						wc->w_handle, cpos, 1, phys,
+						meta_ac, &wc->w_dealloc);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
@@ -1125,0 +1151,9 @@
+	if (should_zero)
+		v_blkno = ocfs2_clusters_to_blocks(inode->i_sb, cpos);
+	else
+		v_blkno = user_pos >> inode->i_sb->s_blocksize_bits;
+
+	/*
+	 * The only reason this should fail is due to an inability to
+	 * find the extent added.
+	 */
@@ -1129,6 +1163,4 @@
-
-		/*
-		 * XXX: Should we go readonly here?
-		 */
-
-		mlog_errno(ret);
+		ocfs2_error(inode->i_sb, "Corrupting extend for inode %llu, "
+			    "at logical block %llu",
+			    (unsigned long long)OCFS2_I(inode)->ip_blkno,
+			    (unsigned long long)v_blkno);
@@ -1140,4 +1172,53 @@
-	for(i = 0; i < numpages; i++) {
-		ret = ocfs2_write_data_page(inode, handle, &p_blkno, cpages[i],
-					    wc, new);
-		if (ret < 0) {
+	for(i = 0; i < wc->w_num_pages; i++) {
+		int tmpret;
+
+		tmpret = ocfs2_prepare_page_for_write(inode, &p_blkno, wc,
+						      wc->w_pages[i], cpos,
+						      user_pos, user_len,
+						      should_zero);
+		if (tmpret) {
+			mlog_errno(tmpret);
+			if (ret == 0)
+				tmpret = ret;
+		}
+	}
+
+	/*
+	 * We only have cleanup to do in case of allocating write.
+	 */
+	if (ret && new)
+		ocfs2_write_failure(inode, wc, user_pos, user_len);
+
+out:
+
+	return ret;
+}
+
+static int ocfs2_write_cluster_by_desc(struct address_space *mapping,
+				       struct ocfs2_alloc_context *data_ac,
+				       struct ocfs2_alloc_context *meta_ac,
+				       struct ocfs2_write_ctxt *wc,
+				       loff_t pos, unsigned len)
+{
+	int ret, i;
+	loff_t cluster_off;
+	unsigned int local_len = len;
+	struct ocfs2_write_cluster_desc *desc;
+	struct ocfs2_super *osb = OCFS2_SB(mapping->host->i_sb);
+
+	for (i = 0; i < wc->w_clen; i++) {
+		desc = &wc->w_desc[i];
+
+		/*
+		 * We have to make sure that the total write passed in
+		 * doesn't extend past a single cluster.
+		 */
+		local_len = len;
+		cluster_off = pos & (osb->s_clustersize - 1);
+		if ((cluster_off + local_len) > osb->s_clustersize)
+			local_len = osb->s_clustersize - cluster_off;
+
+		ret = ocfs2_write_cluster(mapping, desc->c_phys,
+					  desc->c_unwritten, data_ac, meta_ac,
+					  wc, desc->c_cpos, pos, local_len);
+		if (ret) {
@@ -1148 +1229,2 @@
-		copied += ret;
+		len -= local_len;
+		pos += local_len;
@@ -1150,0 +1233 @@
+	ret = 0;
@@ -1152,8 +1235 @@
-	for(i = 0; i < numpages; i++) {
-		unlock_page(cpages[i]);
-		mark_page_accessed(cpages[i]);
-		page_cache_release(cpages[i]);
-	}
-	kfree(cpages);
-
-	return copied ? copied : ret;
+	return ret;
@@ -1162,4 +1238,8 @@
-static void ocfs2_write_ctxt_init(struct ocfs2_write_ctxt *wc,
-				  struct ocfs2_super *osb, loff_t pos,
-				  size_t count, ocfs2_page_writer *cb,
-				  void *cb_priv)
+/*
+ * ocfs2_write_end() wants to know which parts of the target page it
+ * should complete the write on. It's easiest to compute them ahead of
+ * time when a more complete view of the write is available.
+ */
+static void ocfs2_set_target_boundaries(struct ocfs2_super *osb,
+					struct ocfs2_write_ctxt *wc,
+					loff_t pos, unsigned len, int alloc)
@@ -1167,4 +1247 @@
-	wc->w_count = count;
-	wc->w_pos = pos;
-	wc->w_cpos = wc->w_pos >> osb->s_clustersize_bits;
-	wc->w_finished_copy = 0;
+	struct ocfs2_write_cluster_desc *desc;
@@ -1172,4 +1249,5 @@
-	if (unlikely(PAGE_CACHE_SHIFT > osb->s_clustersize_bits))
-		wc->w_large_pages = 1;
-	else
-		wc->w_large_pages = 0;
+	wc->w_target_from = pos & (PAGE_CACHE_SIZE - 1);
+	wc->w_target_to = wc->w_target_from + len;
+
+	if (alloc == 0)
+		return;
@@ -1177,2 +1255,33 @@
-	wc->w_write_data_page = cb;
-	wc->w_private = cb_priv;
+	/*
+	 * Allocating write - we may have different boundaries based
+	 * on page size and cluster size.
+	 *
+	 * NOTE: We can no longer compute one value from the other as
+	 * the actual write length and user provided length may be
+	 * different.
+	 */
+
+	if (wc->w_large_pages) {
+		/*
+		 * We only care about the 1st and last cluster within
+		 * our range and whether they should be zero'd or not. Either
+		 * value may be extended out to the start/end of a
+		 * newly allocated cluster.
+		 */
+		desc = &wc->w_desc[0];
+		if (ocfs2_should_zero_cluster(desc))
+			ocfs2_figure_cluster_boundaries(osb,
+							desc->c_cpos,
+							&wc->w_target_from,
+							NULL);
+
+		desc = &wc->w_desc[wc->w_clen - 1];
+		if (ocfs2_should_zero_cluster(desc))
+			ocfs2_figure_cluster_boundaries(osb,
+							desc->c_cpos,
+							NULL,
+							&wc->w_target_to);
+	} else {
+		wc->w_target_from = 0;
+		wc->w_target_to = PAGE_CACHE_SIZE;
+	}
@@ -1182,9 +1291,2 @@
- * Write a cluster to an inode. The cluster may not be allocated yet,
- * in which case it will be. This only exists for buffered writes -
- * O_DIRECT takes a more "traditional" path through the kernel.
- *
- * The caller is responsible for incrementing pos, written counts, etc
- *
- * For file systems that don't support sparse files, pre-allocation
- * and page zeroing up until cpos should be done prior to this
- * function call.
+ * Populate each single-cluster write descriptor in the write context
+ * with information about the i/o to be done.
@@ -1192,4 +1294,3 @@
- * Callers should be holding i_sem, and the rw cluster lock.
- *
- * Returns the number of user bytes written, or less than zero for
- * error.
+ * Returns the number of clusters that will have to be allocated, as
+ * well as a worst case estimate of the number of extent records that
+ * would have to be created during a write to an unwritten region.
@@ -1197,3 +1298,69 @@
-ssize_t ocfs2_buffered_write_cluster(struct file *file, loff_t pos,
-				     size_t count, ocfs2_page_writer *actor,
-				     void *priv)
+static int ocfs2_populate_write_desc(struct inode *inode,
+				     struct ocfs2_write_ctxt *wc,
+				     unsigned int *clusters_to_alloc,
+				     unsigned int *extents_to_split)
+{
+	int ret;
+	struct ocfs2_write_cluster_desc *desc;
+	unsigned int num_clusters = 0;
+	unsigned int ext_flags = 0;
+	u32 phys = 0;
+	int i;
+
+	*clusters_to_alloc = 0;
+	*extents_to_split = 0;
+
+	for (i = 0; i < wc->w_clen; i++) {
+		desc = &wc->w_desc[i];
+		desc->c_cpos = wc->w_cpos + i;
+
+		if (num_clusters == 0) {
+			/*
+			 * Need to look up the next extent record.
+			 */
+			ret = ocfs2_get_clusters(inode, desc->c_cpos, &phys,
+						 &num_clusters, &ext_flags);
+			if (ret) {
+				mlog_errno(ret);
+				goto out;
+			}
+
+			/*
+			 * Assume worst case - that we're writing in
+			 * the middle of the extent.
+			 *
+			 * We can assume that the write proceeds from
+			 * left to right, in which case the extent
+			 * insert code is smart enough to coalesce the
+			 * next splits into the previous records created.
+			 */
+			if (ext_flags & OCFS2_EXT_UNWRITTEN)
+				*extents_to_split = *extents_to_split + 2;
+		} else if (phys) {
+			/*
+			 * Only increment phys if it doesn't describe
+			 * a hole.
+			 */
+			phys++;
+		}
+
+		desc->c_phys = phys;
+		if (phys == 0) {
+			desc->c_new = 1;
+			*clusters_to_alloc = *clusters_to_alloc + 1;
+		}
+		if (ext_flags & OCFS2_EXT_UNWRITTEN)
+			desc->c_unwritten = 1;
+
+		num_clusters--;
+	}
+
+	ret = 0;
+out:
+	return ret;
+}
+
+int ocfs2_write_begin_nolock(struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata,
+			     struct buffer_head *di_bh, struct page *mmap_page)
@@ -1202,3 +1369,3 @@
-	ssize_t written = 0;
-	u32 phys;
-	struct inode *inode = file->f_mapping->host;
+	unsigned int clusters_to_alloc, extents_to_split;
+	struct ocfs2_write_ctxt *wc;
+	struct inode *inode = mapping->host;
@@ -1206 +1372,0 @@
-	struct buffer_head *di_bh = NULL;
@@ -1211,3 +1376,0 @@
-	struct ocfs2_write_ctxt wc;
-
-	ocfs2_write_ctxt_init(&wc, osb, pos, count, actor, priv);
@@ -1215 +1378 @@
-	ret = ocfs2_meta_lock(inode, &di_bh, 1);
+	ret = ocfs2_alloc_write_ctxt(&wc, osb, pos, len, di_bh);
@@ -1218 +1381 @@
-		goto out;
+		return ret;
@@ -1220 +1382,0 @@
-	di = (struct ocfs2_dinode *)di_bh->b_data;
@@ -1222,10 +1384,2 @@
-	/*
-	 * Take alloc sem here to prevent concurrent lookups. That way
-	 * the mapping, zeroing and tree manipulation within
-	 * ocfs2_write() will be safe against ->readpage(). This
-	 * should also serve to lock out allocation from a shared
-	 * writeable region.
-	 */
-	down_write(&OCFS2_I(inode)->ip_alloc_sem);
-
-	ret = ocfs2_get_clusters(inode, wc.w_cpos, &phys, NULL, NULL);
+	ret = ocfs2_populate_write_desc(inode, wc, &clusters_to_alloc,
+					&extents_to_split);
@@ -1234 +1388 @@
-		goto out_meta;
+		goto out;
@@ -1237,3 +1391,16 @@
-	/* phys == 0 means that allocation is required. */
-	if (phys == 0) {
-		ret = ocfs2_lock_allocators(inode, di, 1, &data_ac, &meta_ac);
+	di = (struct ocfs2_dinode *)wc->w_di_bh->b_data;
+
+	/*
+	 * We set w_target_from, w_target_to here so that
+	 * ocfs2_write_end() knows which range in the target page to
+	 * write out. An allocation requires that we write the entire
+	 * cluster range.
+	 */
+	if (clusters_to_alloc || extents_to_split) {
+		/*
+		 * XXX: We are stretching the limits of
+		 * ocfs2_lock_allocators(). It greatly over-estimates
+		 * the work to be done.
+		 */
+		ret = ocfs2_lock_allocators(inode, di, clusters_to_alloc,
+					    extents_to_split, &data_ac, &meta_ac);
@@ -1242 +1409 @@
-			goto out_meta;
+			goto out;
@@ -1245,2 +1412,2 @@
-		credits = ocfs2_calc_extend_credits(inode->i_sb, di, 1);
-	}
+		credits = ocfs2_calc_extend_credits(inode->i_sb, di,
+						    clusters_to_alloc);
@@ -1248,4 +1414,0 @@
-	ret = ocfs2_data_lock(inode, 1);
-	if (ret) {
-		mlog_errno(ret);
-		goto out_meta;
@@ -1253,0 +1417,3 @@
+	ocfs2_set_target_boundaries(osb, wc, pos, len,
+				    clusters_to_alloc + extents_to_split);
+
@@ -1258 +1424 @@
-		goto out_data;
+		goto out;
@@ -1261,4 +1427,9 @@
-	written = ocfs2_write(file, phys, handle, di_bh, data_ac,
-			      meta_ac, &wc);
-	if (written < 0) {
-		ret = written;
+	wc->w_handle = handle;
+
+	/*
+	 * We don't want this to fail in ocfs2_write_end(), so do it
+	 * here.
+	 */
+	ret = ocfs2_journal_access(handle, inode, wc->w_di_bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
@@ -1269,2 +1440,15 @@
-	ret = ocfs2_journal_access(handle, inode, di_bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
+	/*
+	 * Fill our page array first. That way we've grabbed enough so
+	 * that we can zero and flush if we error after adding the
+	 * extent.
+	 */
+	ret = ocfs2_grab_pages_for_write(mapping, wc, wc->w_cpos, pos,
+					 clusters_to_alloc + extents_to_split,
+					 mmap_page);
+	if (ret) {
+		mlog_errno(ret);
+		goto out_commit;
+	}
+
+	ret = ocfs2_write_cluster_by_desc(mapping, data_ac, meta_ac, wc, pos,
+					  len);
@@ -1276 +1460,123 @@
-	pos += written;
+	if (data_ac)
+		ocfs2_free_alloc_context(data_ac);
+	if (meta_ac)
+		ocfs2_free_alloc_context(meta_ac);
+
+	*pagep = wc->w_target_page;
+	*fsdata = wc;
+	return 0;
+out_commit:
+	ocfs2_commit_trans(osb, handle);
+
+out:
+	ocfs2_free_write_ctxt(wc);
+
+	if (data_ac)
+		ocfs2_free_alloc_context(data_ac);
+	if (meta_ac)
+		ocfs2_free_alloc_context(meta_ac);
+	return ret;
+}
+
+int ocfs2_write_begin(struct file *file, struct address_space *mapping,
+		      loff_t pos, unsigned len, unsigned flags,
+		      struct page **pagep, void **fsdata)
+{
+	int ret;
+	struct buffer_head *di_bh = NULL;
+	struct inode *inode = mapping->host;
+
+	ret = ocfs2_meta_lock(inode, &di_bh, 1);
+	if (ret) {
+		mlog_errno(ret);
+		return ret;
+	}
+
+	/*
+	 * Take alloc sem here to prevent concurrent lookups. That way
+	 * the mapping, zeroing and tree manipulation within
+	 * ocfs2_write() will be safe against ->readpage(). This
+	 * should also serve to lock out allocation from a shared
+	 * writeable region.
+	 */
+	down_write(&OCFS2_I(inode)->ip_alloc_sem);
+
+	ret = ocfs2_data_lock(inode, 1);
+	if (ret) {
+		mlog_errno(ret);
+		goto out_fail;
+	}
+
+	ret = ocfs2_write_begin_nolock(mapping, pos, len, flags, pagep,
+				       fsdata, di_bh, NULL);
+	if (ret) {
+		mlog_errno(ret);
+		goto out_fail_data;
+	}
+
+	brelse(di_bh);
+
+	return 0;
+
+out_fail_data:
+	ocfs2_data_unlock(inode, 1);
+out_fail:
+	up_write(&OCFS2_I(inode)->ip_alloc_sem);
+
+	brelse(di_bh);
+	ocfs2_meta_unlock(inode, 1);
+
+	return ret;
+}
+
+int ocfs2_write_end_nolock(struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *page, void *fsdata)
+{
+	int i;
+	unsigned from, to, start = pos & (PAGE_CACHE_SIZE - 1);
+	struct inode *inode = mapping->host;
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	struct ocfs2_write_ctxt *wc = fsdata;
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)wc->w_di_bh->b_data;
+	handle_t *handle = wc->w_handle;
+	struct page *tmppage;
+
+	if (unlikely(copied < len)) {
+		if (!PageUptodate(wc->w_target_page))
+			copied = 0;
+
+		ocfs2_zero_new_buffers(wc->w_target_page, start+copied,
+				       start+len);
+	}
+	flush_dcache_page(wc->w_target_page);
+
+	for(i = 0; i < wc->w_num_pages; i++) {
+		tmppage = wc->w_pages[i];
+
+		if (tmppage == wc->w_target_page) {
+			from = wc->w_target_from;
+			to = wc->w_target_to;
+
+			BUG_ON(from > PAGE_CACHE_SIZE ||
+			       to > PAGE_CACHE_SIZE ||
+			       to < from);
+		} else {
+			/*
+			 * Pages adjacent to the target (if any) imply
+			 * a hole-filling write in which case we want
+			 * to flush their entire range.
+			 */
+			from = 0;
+			to = PAGE_CACHE_SIZE;
+		}
+
+		if (ocfs2_should_order_data(inode))
+			walk_page_buffers(wc->w_handle, page_buffers(tmppage),
+					  from, to, NULL,
+					  ocfs2_journal_dirty_data);
+
+		block_commit_write(tmppage, from, to);
+	}
+
+	pos += copied;
@@ -1285,0 +1592 @@
+	ocfs2_journal_dirty(handle, wc->w_di_bh);
@@ -1287,5 +1593,0 @@
-	ret = ocfs2_journal_dirty(handle, di_bh);
-	if (ret)
-		mlog_errno(ret);
-
-out_commit:
@@ -1294,2 +1596,13 @@
-out_data:
-	ocfs2_data_unlock(inode, 1);
+	ocfs2_run_deallocs(osb, &wc->w_dealloc);
+
+	ocfs2_free_write_ctxt(wc);
+
+	return copied;
+}
+
+int ocfs2_write_end(struct file *file, struct address_space *mapping,
+		    loff_t pos, unsigned len, unsigned copied,
+		    struct page *page, void *fsdata)
+{
+	int ret;
+	struct inode *inode = mapping->host;
@@ -1297 +1610,3 @@
-out_meta:
+	ret = ocfs2_write_end_nolock(mapping, pos, len, copied, page, fsdata);
+
+	ocfs2_data_unlock(inode, 1);
@@ -1301,8 +1616 @@
-out:
-	brelse(di_bh);
-	if (data_ac)
-		ocfs2_free_alloc_context(data_ac);
-	if (meta_ac)
-		ocfs2_free_alloc_context(meta_ac);
-
-	return written ? written : ret;
+	return ret;
--- ./projects/linux/linux-2.6.23/fs/ocfs2/aops.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/fs/ocfs2/aops.c	2008-01-24 23:58:37.000000000 +0100
@@ -208,0 +209,60 @@
+int ocfs2_read_inline_data(struct inode *inode, struct page *page,
+			   struct buffer_head *di_bh)
+{
+	void *kaddr;
+	unsigned int size;
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
+
+	if (!(le16_to_cpu(di->i_dyn_features) & OCFS2_INLINE_DATA_FL)) {
+		ocfs2_error(inode->i_sb, "Inode %llu lost inline data flag",
+			    (unsigned long long)OCFS2_I(inode)->ip_blkno);
+		return -EROFS;
+	}
+
+	size = i_size_read(inode);
+
+	if (size > PAGE_CACHE_SIZE ||
+	    size > ocfs2_max_inline_data(inode->i_sb)) {
+		ocfs2_error(inode->i_sb,
+			    "Inode %llu has with inline data has bad size: %u",
+			    (unsigned long long)OCFS2_I(inode)->ip_blkno, size);
+		return -EROFS;
+	}
+
+	kaddr = kmap_atomic(page, KM_USER0);
+	if (size)
+		memcpy(kaddr, di->id2.i_data.id_data, size);
+	/* Clear the remaining part of the page */
+	memset(kaddr + size, 0, PAGE_CACHE_SIZE - size);
+	flush_dcache_page(page);
+	kunmap_atomic(kaddr, KM_USER0);
+
+	SetPageUptodate(page);
+
+	return 0;
+}
+
+static int ocfs2_readpage_inline(struct inode *inode, struct page *page)
+{
+	int ret;
+	struct buffer_head *di_bh = NULL;
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+
+	BUG_ON(!PageLocked(page));
+	BUG_ON(!OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL);
+
+	ret = ocfs2_read_block(osb, OCFS2_I(inode)->ip_blkno, &di_bh,
+			       OCFS2_BH_CACHED, inode);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ret = ocfs2_read_inline_data(inode, page, di_bh);
+out:
+	unlock_page(page);
+
+	brelse(di_bh);
+	return ret;
+}
+
@@ -211,0 +272 @@
+	struct ocfs2_inode_info *oi = OCFS2_I(inode);
@@ -225 +286 @@
-	if (down_read_trylock(&OCFS2_I(inode)->ip_alloc_sem) == 0) {
+	if (down_read_trylock(&oi->ip_alloc_sem) == 0) {
@@ -255 +316,4 @@
-	ret = block_read_full_page(page, ocfs2_get_block);
+	if (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)
+		ret = ocfs2_readpage_inline(inode, page);
+	else
+		ret = block_read_full_page(page, ocfs2_get_block);
@@ -304,2 +367,0 @@
-	down_read(&OCFS2_I(inode)->ip_alloc_sem);
-
@@ -308,2 +369,0 @@
-	up_read(&OCFS2_I(inode)->ip_alloc_sem);
-
@@ -404 +464,3 @@
-	err = ocfs2_extent_map_get_blocks(inode, block, &p_blkno, NULL, NULL);
+	if (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL))
+		err = ocfs2_extent_map_get_blocks(inode, block, &p_blkno, NULL,
+						  NULL);
@@ -418 +479,0 @@
-
@@ -572,0 +634,7 @@
+	/*
+	 * Fallback to buffered I/O if we see an inode without
+	 * extents.
+	 */
+	if (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL)
+		return 0;
+
@@ -663,0 +732,21 @@
+ * Nonsparse file systems fully allocate before we get to the write
+ * code. This prevents ocfs2_write() from tagging the write as an
+ * allocating one, which means ocfs2_map_page_blocks() might try to
+ * read-in the blocks at the tail of our file. Avoid reading them by
+ * testing i_size against each block offset.
+ */
+static int ocfs2_should_read_blk(struct inode *inode, struct page *page,
+				 unsigned int block_start)
+{
+	u64 offset = page_offset(page) + block_start;
+
+	if (ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)))
+		return 1;
+
+	if (i_size_read(inode) > offset)
+		return 1;
+
+	return 0;
+}
+
+/*
@@ -715,0 +805 @@
+			   ocfs2_should_read_blk(inode, page, block_start) &&
@@ -837 +927 @@
-static void ocfs2_free_write_ctxt(struct ocfs2_write_ctxt *wc)
+void ocfs2_unlock_and_free_pages(struct page **pages, int num_pages)
@@ -841,7 +931,6 @@
-	for(i = 0; i < wc->w_num_pages; i++) {
-		if (wc->w_pages[i] == NULL)
-			continue;
-
-		unlock_page(wc->w_pages[i]);
-		mark_page_accessed(wc->w_pages[i]);
-		page_cache_release(wc->w_pages[i]);
+	for(i = 0; i < num_pages; i++) {
+		if (pages[i]) {
+			unlock_page(pages[i]);
+			mark_page_accessed(pages[i]);
+			page_cache_release(pages[i]);
+		}
@@ -848,0 +938,5 @@
+}
+
+static void ocfs2_free_write_ctxt(struct ocfs2_write_ctxt *wc)
+{
+	ocfs2_unlock_and_free_pages(wc->w_pages, wc->w_num_pages);
@@ -1362,0 +1457,154 @@
+static int ocfs2_write_begin_inline(struct address_space *mapping,
+				    struct inode *inode,
+				    struct ocfs2_write_ctxt *wc)
+{
+	int ret;
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	struct page *page;
+	handle_t *handle;
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)wc->w_di_bh->b_data;
+
+	page = find_or_create_page(mapping, 0, GFP_NOFS);
+	if (!page) {
+		ret = -ENOMEM;
+		mlog_errno(ret);
+		goto out;
+	}
+	/*
+	 * If we don't set w_num_pages then this page won't get unlocked
+	 * and freed on cleanup of the write context.
+	 */
+	wc->w_pages[0] = wc->w_target_page = page;
+	wc->w_num_pages = 1;
+
+	handle = ocfs2_start_trans(osb, OCFS2_INODE_UPDATE_CREDITS);
+	if (IS_ERR(handle)) {
+		ret = PTR_ERR(handle);
+		mlog_errno(ret);
+		goto out;
+	}
+
+	ret = ocfs2_journal_access(handle, inode, wc->w_di_bh,
+				   OCFS2_JOURNAL_ACCESS_WRITE);
+	if (ret) {
+		ocfs2_commit_trans(osb, handle);
+
+		mlog_errno(ret);
+		goto out;
+	}
+
+	if (!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL))
+		ocfs2_set_inode_data_inline(inode, di);
+
+	if (!PageUptodate(page)) {
+		ret = ocfs2_read_inline_data(inode, page, wc->w_di_bh);
+		if (ret) {
+			ocfs2_commit_trans(osb, handle);
+
+			goto out;
+		}
+	}
+
+	wc->w_handle = handle;
+out:
+	return ret;
+}
+
+int ocfs2_size_fits_inline_data(struct buffer_head *di_bh, u64 new_size)
+{
+	struct ocfs2_dinode *di = (struct ocfs2_dinode *)di_bh->b_data;
+
+	if (new_size <= le16_to_cpu(di->id2.i_data.id_count))
+		return 1;
+	return 0;
+}
+
+static int ocfs2_try_to_write_inline_data(struct address_space *mapping,
+					  struct inode *inode, loff_t pos,
+					  unsigned len, struct page *mmap_page,
+					  struct ocfs2_write_ctxt *wc)
+{
+	int ret, written = 0;
+	loff_t end = pos + len;
+	struct ocfs2_inode_info *oi = OCFS2_I(inode);
+
+	mlog(0, "Inode %llu, write of %u bytes at off %llu. features: 0x%x\n",
+	     (unsigned long long)oi->ip_blkno, len, (unsigned long long)pos,
+	     oi->ip_dyn_features);
+
+	/*
+	 * Handle inodes which already have inline data 1st.
+	 */
+	if (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL) {
+		if (mmap_page == NULL &&
+		    ocfs2_size_fits_inline_data(wc->w_di_bh, end))
+			goto do_inline_write;
+
+		/*
+		 * The write won't fit - we have to give this inode an
+		 * inline extent list now.
+		 */
+		ret = ocfs2_convert_inline_data_to_extents(inode, wc->w_di_bh);
+		if (ret)
+			mlog_errno(ret);
+		goto out;
+	}
+
+	/*
+	 * Check whether the inode can accept inline data.
+	 */
+	if (oi->ip_clusters != 0 || i_size_read(inode) != 0)
+		return 0;
+
+	/*
+	 * Check whether the write can fit.
+	 */
+	if (mmap_page || end > ocfs2_max_inline_data(inode->i_sb))
+		return 0;
+
+do_inline_write:
+	ret = ocfs2_write_begin_inline(mapping, inode, wc);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
+	/*
+	 * This signals to the caller that the data can be written
+	 * inline.
+	 */
+	written = 1;
+out:
+	return written ? written : ret;
+}
+
+/*
+ * This function only does anything for file systems which can't
+ * handle sparse files.
+ *
+ * What we want to do here is fill in any hole between the current end
+ * of allocation and the end of our write. That way the rest of the
+ * write path can treat it as an non-allocating write, which has no
+ * special case code for sparse/nonsparse files.
+ */
+static int ocfs2_expand_nonsparse_inode(struct inode *inode, loff_t pos,
+					unsigned len,
+					struct ocfs2_write_ctxt *wc)
+{
+	int ret;
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	loff_t newsize = pos + len;
+
+	if (ocfs2_sparse_alloc(osb))
+		return 0;
+
+	if (newsize <= i_size_read(inode))
+		return 0;
+
+	ret = ocfs2_extend_no_holes(inode, newsize, newsize - len);
+	if (ret)
+		mlog_errno(ret);
+
+	return ret;
+}
+
@@ -1383,0 +1632,19 @@
+	if (ocfs2_supports_inline_data(osb)) {
+		ret = ocfs2_try_to_write_inline_data(mapping, inode, pos, len,
+						     mmap_page, wc);
+		if (ret == 1) {
+			ret = 0;
+			goto success;
+		}
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
+		}
+	}
+
+	ret = ocfs2_expand_nonsparse_inode(inode, pos, len, wc);
+	if (ret) {
+		mlog_errno(ret);
+		goto out;
+	}
+
@@ -1464,0 +1732 @@
+success:
@@ -1481,3 +1749,3 @@
-int ocfs2_write_begin(struct file *file, struct address_space *mapping,
-		      loff_t pos, unsigned len, unsigned flags,
-		      struct page **pagep, void **fsdata)
+static int ocfs2_write_begin(struct file *file, struct address_space *mapping,
+			     loff_t pos, unsigned len, unsigned flags,
+			     struct page **pagep, void **fsdata)
@@ -1531,0 +1800,25 @@
+static void ocfs2_write_end_inline(struct inode *inode, loff_t pos,
+				   unsigned len, unsigned *copied,
+				   struct ocfs2_dinode *di,
+				   struct ocfs2_write_ctxt *wc)
+{
+	void *kaddr;
+
+	if (unlikely(*copied < len)) {
+		if (!PageUptodate(wc->w_target_page)) {
+			*copied = 0;
+			return;
+		}
+	}
+
+	kaddr = kmap_atomic(wc->w_target_page, KM_USER0);
+	memcpy(di->id2.i_data.id_data + pos, kaddr + pos, *copied);
+	kunmap_atomic(kaddr, KM_USER0);
+
+	mlog(0, "Data written to inode at offset %llu. "
+	     "id_count = %u, copied = %u, i_dyn_features = 0x%x\n",
+	     (unsigned long long)pos, *copied,
+	     le16_to_cpu(di->id2.i_data.id_count),
+	     le16_to_cpu(di->i_dyn_features));
+}
+
@@ -1544,0 +1838,5 @@
+	if (OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL) {
+		ocfs2_write_end_inline(inode, pos, len, &copied, di, wc);
+		goto out_write_size;
+	}
+
@@ -1581,0 +1880 @@
+out_write_size:
@@ -1603,3 +1902,3 @@
-int ocfs2_write_end(struct file *file, struct address_space *mapping,
-		    loff_t pos, unsigned len, unsigned copied,
-		    struct page *page, void *fsdata)
+static int ocfs2_write_end(struct file *file, struct address_space *mapping,
+			   loff_t pos, unsigned len, unsigned copied,
+			   struct page *page, void *fsdata)
@@ -1621,0 +1921,2 @@
+	.write_begin	= ocfs2_write_begin,
+	.write_end	= ocfs2_write_end,
--- ./projects/linux/linux-2.6.24/fs/ocfs2/aops.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/fs/ocfs2/aops.c	2008-04-17 04:49:44.000000000 +0200
@@ -28,0 +29 @@
+#include <linux/mpage.h>
@@ -142 +143,2 @@
-	u64 p_blkno, past_eof;
+	u64 max_blocks = bh_result->b_size >> inode->i_blkbits;
+	u64 p_blkno, count, past_eof;
@@ -158 +160 @@
-	err = ocfs2_extent_map_get_blocks(inode, iblock, &p_blkno, NULL,
+	err = ocfs2_extent_map_get_blocks(inode, iblock, &p_blkno, &count,
@@ -166,0 +169,3 @@
+	if (max_blocks < count)
+		count = max_blocks;
+
@@ -180,0 +186,2 @@
+	bh_result->b_size = count << inode->i_blkbits;
+
@@ -213 +220 @@
-	unsigned int size;
+	loff_t size;
@@ -227,2 +234,3 @@
-			    "Inode %llu has with inline data has bad size: %u",
-			    (unsigned long long)OCFS2_I(inode)->ip_blkno, size);
+			    "Inode %llu has with inline data has bad size: %Lu",
+			    (unsigned long long)OCFS2_I(inode)->ip_blkno,
+			    (unsigned long long)size);
@@ -252 +260 @@
-	BUG_ON(!OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL);
+	BUG_ON(!(OCFS2_I(inode)->ip_dyn_features & OCFS2_INLINE_DATA_FL));
@@ -278 +286 @@
-	ret = ocfs2_meta_lock_with_page(inode, NULL, 0, page);
+	ret = ocfs2_inode_lock_with_page(inode, NULL, 0, page);
@@ -288 +296 @@
-		goto out_meta_unlock;
+		goto out_inode_unlock;
@@ -302 +310 @@
-		zero_user_page(page, 0, PAGE_SIZE, KM_USER0);
+		zero_user(page, 0, PAGE_SIZE);
@@ -308,8 +315,0 @@
-	ret = ocfs2_data_lock_with_page(inode, 0, page);
-	if (ret != 0) {
-		if (ret == AOP_TRUNCATED_PAGE)
-			unlock = 0;
-		mlog_errno(ret);
-		goto out_alloc;
-	}
-
@@ -322 +321,0 @@
-	ocfs2_data_unlock(inode, 0);
@@ -325,2 +324,2 @@
-out_meta_unlock:
-	ocfs2_meta_unlock(inode, 0);
+out_inode_unlock:
+	ocfs2_inode_unlock(inode, 0);
@@ -333,0 +333,56 @@
+/*
+ * This is used only for read-ahead. Failures or difficult to handle
+ * situations are safe to ignore.
+ *
+ * Right now, we don't bother with BH_Boundary - in-inode extent lists
+ * are quite large (243 extents on 4k blocks), so most inodes don't
+ * grow out to a tree. If need be, detecting boundary extents could
+ * trivially be added in a future version of ocfs2_get_block().
+ */
+static int ocfs2_readpages(struct file *filp, struct address_space *mapping,
+			   struct list_head *pages, unsigned nr_pages)
+{
+	int ret, err = -EIO;
+	struct inode *inode = mapping->host;
+	struct ocfs2_inode_info *oi = OCFS2_I(inode);
+	loff_t start;
+	struct page *last;
+
+	/*
+	 * Use the nonblocking flag for the dlm code to avoid page
+	 * lock inversion, but don't bother with retrying.
+	 */
+	ret = ocfs2_inode_lock_full(inode, NULL, 0, OCFS2_LOCK_NONBLOCK);
+	if (ret)
+		return err;
+
+	if (down_read_trylock(&oi->ip_alloc_sem) == 0) {
+		ocfs2_inode_unlock(inode, 0);
+		return err;
+	}
+
+	/*
+	 * Don't bother with inline-data. There isn't anything
+	 * to read-ahead in that case anyway...
+	 */
+	if (oi->ip_dyn_features & OCFS2_INLINE_DATA_FL)
+		goto out_unlock;
+
+	/*
+	 * Check whether a remote node truncated this file - we just
+	 * drop out in that case as it's not worth handling here.
+	 */
+	last = list_entry(pages->prev, struct page, lru);
+	start = (loff_t)last->index << PAGE_CACHE_SHIFT;
+	if (start >= i_size_read(inode))
+		goto out_unlock;
+
+	err = mpage_readpages(mapping, pages, nr_pages, ocfs2_get_block);
+
+out_unlock:
+	up_read(&oi->ip_alloc_sem);
+	ocfs2_inode_unlock(inode, 0);
+
+	return err;
+}
+
@@ -455 +510 @@
-		err = ocfs2_meta_lock(inode, NULL, 0);
+		err = ocfs2_inode_lock(inode, NULL, 0);
@@ -470 +525 @@
-		ocfs2_meta_unlock(inode, 0);
+		ocfs2_inode_unlock(inode, 0);
@@ -641,22 +695,0 @@
-	if (!ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb))) {
-		/*
-		 * We get PR data locks even for O_DIRECT.  This
-		 * allows concurrent O_DIRECT I/O but doesn't let
-		 * O_DIRECT with extending and buffered zeroing writes
-		 * race.  If they did race then the buffered zeroing
-		 * could be written back after the O_DIRECT I/O.  It's
-		 * one thing to tell people not to mix buffered and
-		 * O_DIRECT writes, but expecting them to understand
-		 * that file extension is also an implicit buffered
-		 * write is too much.  By getting the PR we force
-		 * writeback of the buffered zeroing before
-		 * proceeding.
-		 */
-		ret = ocfs2_data_lock(inode, 0);
-		if (ret < 0) {
-			mlog_errno(ret);
-			goto out;
-		}
-		ocfs2_data_unlock(inode, 0);
-	}
-
@@ -668 +701 @@
-out:
+
@@ -839 +872 @@
-		zero_user_page(page, block_start, bh->b_size, KM_USER0);
+		zero_user(page, block_start, bh->b_size);
@@ -1004 +1037 @@
-					zero_user_page(page, start, end - start, KM_USER0);
+					zero_user_segment(page, start, end);
@@ -1757 +1790 @@
-	ret = ocfs2_meta_lock(inode, &di_bh, 1);
+	ret = ocfs2_inode_lock(inode, &di_bh, 1);
@@ -1772,6 +1804,0 @@
-	ret = ocfs2_data_lock(inode, 1);
-	if (ret) {
-		mlog_errno(ret);
-		goto out_fail;
-	}
-
@@ -1782 +1809 @@
-		goto out_fail_data;
+		goto out_fail;
@@ -1789,2 +1815,0 @@
-out_fail_data:
-	ocfs2_data_unlock(inode, 1);
@@ -1795 +1820 @@
-	ocfs2_meta_unlock(inode, 1);
+	ocfs2_inode_unlock(inode, 1);
@@ -1911 +1935,0 @@
-	ocfs2_data_unlock(inode, 1);
@@ -1913 +1937 @@
-	ocfs2_meta_unlock(inode, 1);
+	ocfs2_inode_unlock(inode, 1);
@@ -1919,0 +1944 @@
+	.readpages	= ocfs2_readpages,
--- ./projects/linux/linux-2.6.25/fs/ocfs2/aops.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/fs/ocfs2/aops.c	2008-07-13 23:51:29.000000000 +0200
@@ -470 +470 @@
-	handle_t *handle = NULL;
+	handle_t *handle;
@@ -474 +474 @@
-	if (!handle) {
+	if (IS_ERR(handle)) {
@@ -490 +490 @@
-		if (handle)
+		if (!IS_ERR(handle))
--- ./projects/linux/linux-2.6.26/fs/ocfs2/aops.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/fs/ocfs2/aops.c	2008-10-10 00:13:53.000000000 +0200
@@ -177,4 +177,11 @@
-	 */
-	mlog_bug_on_msg(create && p_blkno == 0 && ocfs2_sparse_alloc(osb),
-			"ino %lu, iblock %llu\n", inode->i_ino,
-			(unsigned long long)iblock);
+	 *
+	 * If we see this on a sparse file system, then a truncate has
+	 * raced us and removed the cluster. In this case, we clear
+	 * the buffers dirty and uptodate bits and let the buffer code
+	 * ignore it as a hole.
+	 */
+	if (create && p_blkno == 0 && ocfs2_sparse_alloc(osb)) {
+		clear_buffer_dirty(bh_result);
+		clear_buffer_uptodate(bh_result);
+		goto bail;
+	}
@@ -590 +597 @@
-	if (!ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)) && !p_blkno) {
+	if (!ocfs2_sparse_alloc(OCFS2_SB(inode->i_sb)) && !p_blkno && create) {
@@ -1069,4 +1076,6 @@
-		if (ocfs2_should_order_data(inode))
-			walk_page_buffers(wc->w_handle, page_buffers(tmppage),
-					  from, to, NULL,
-					  ocfs2_journal_dirty_data);
+		if (page_has_buffers(tmppage)) {
+			if (ocfs2_should_order_data(inode))
+				walk_page_buffers(wc->w_handle,
+						  page_buffers(tmppage),
+						  from, to, NULL,
+						  ocfs2_journal_dirty_data);
@@ -1074 +1083,2 @@
-		block_commit_write(tmppage, from, to);
+			block_commit_write(tmppage, from, to);
+		}
@@ -1897,6 +1907,8 @@
-		if (ocfs2_should_order_data(inode))
-			walk_page_buffers(wc->w_handle, page_buffers(tmppage),
-					  from, to, NULL,
-					  ocfs2_journal_dirty_data);
-
-		block_commit_write(tmppage, from, to);
+		if (page_has_buffers(tmppage)) {
+			if (ocfs2_should_order_data(inode))
+				walk_page_buffers(wc->w_handle,
+						  page_buffers(tmppage),
+						  from, to, NULL,
+						  ocfs2_journal_dirty_data);
+			block_commit_write(tmppage, from, to);
+		}
--- ./projects/linux/linux-2.6.27/fs/ocfs2/aops.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/fs/ocfs2/aops.c	2008-12-25 00:26:37.000000000 +0100
@@ -71,3 +71 @@
-	status = ocfs2_read_block(OCFS2_SB(inode->i_sb),
-				  OCFS2_I(inode)->ip_blkno,
-				  &bh, OCFS2_BH_CACHED, inode);
+	status = ocfs2_read_block(inode, OCFS2_I(inode)->ip_blkno, &bh);
@@ -131,2 +129 @@
-	if (bh)
-		brelse(bh);
+	brelse(bh);
@@ -264 +260,0 @@
-	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
@@ -269,2 +265 @@
-	ret = ocfs2_read_block(osb, OCFS2_I(inode)->ip_blkno, &di_bh,
-			       OCFS2_BH_CACHED, inode);
+	ret = ocfs2_read_block(inode, OCFS2_I(inode)->ip_blkno, &di_bh);
@@ -487,0 +483,2 @@
+		ret = ocfs2_jbd2_file_inode(handle, inode);
+#ifdef CONFIG_OCFS2_COMPAT_JBD
@@ -492 +489,2 @@
-		if (ret < 0) 
+#endif
+		if (ret < 0)
@@ -672 +670 @@
-	journal_invalidatepage(journal, page, offset);
+	jbd2_journal_invalidatepage(journal, page, offset);
@@ -681 +679 @@
-	return journal_try_to_free_buffers(journal, page, wait);
+	return jbd2_journal_try_to_free_buffers(journal, page, wait);
@@ -1077 +1075,3 @@
-			if (ocfs2_should_order_data(inode))
+			if (ocfs2_should_order_data(inode)) {
+				ocfs2_jbd2_file_inode(wc->w_handle, inode);
+#ifdef CONFIG_OCFS2_COMPAT_JBD
@@ -1081,0 +1082,2 @@
+#endif
+			}
@@ -1244,0 +1247 @@
+	struct ocfs2_extent_tree et;
@@ -1258,4 +1261,4 @@
-		ret = ocfs2_do_extend_allocation(OCFS2_SB(inode->i_sb), inode,
-						 &tmp_pos, 1, 0, wc->w_di_bh,
-						 wc->w_handle, data_ac,
-						 meta_ac, NULL);
+		ret = ocfs2_add_inode_data(OCFS2_SB(inode->i_sb), inode,
+					   &tmp_pos, 1, 0, wc->w_di_bh,
+					   wc->w_handle, data_ac,
+					   meta_ac, NULL);
@@ -1279 +1282,2 @@
-		ret = ocfs2_mark_extent_written(inode, wc->w_di_bh,
+		ocfs2_init_dinode_extent_tree(&et, inode, wc->w_di_bh);
+		ret = ocfs2_mark_extent_written(inode, &et,
@@ -1667,0 +1672 @@
+	struct ocfs2_extent_tree et;
@@ -1715,2 +1720,10 @@
-		ret = ocfs2_lock_allocators(inode, di, clusters_to_alloc,
-					    extents_to_split, &data_ac, &meta_ac);
+		mlog(0, "extend inode %llu, i_size = %lld, di->i_clusters = %u,"
+		     " clusters_to_add = %u, extents_to_split = %u\n",
+		     (unsigned long long)OCFS2_I(inode)->ip_blkno,
+		     (long long)i_size_read(inode), le32_to_cpu(di->i_clusters),
+		     clusters_to_alloc, extents_to_split);
+
+		ocfs2_init_dinode_extent_tree(&et, inode, wc->w_di_bh);
+		ret = ocfs2_lock_allocators(inode, &et,
+					    clusters_to_alloc, extents_to_split,
+					    &data_ac, &meta_ac);
@@ -1722 +1735,2 @@
-		credits = ocfs2_calc_extend_credits(inode->i_sb, di,
+		credits = ocfs2_calc_extend_credits(inode->i_sb,
+						    &di->id2.i_list,
@@ -1908 +1922,3 @@
-			if (ocfs2_should_order_data(inode))
+			if (ocfs2_should_order_data(inode)) {
+				ocfs2_jbd2_file_inode(wc->w_handle, inode);
+#ifdef CONFIG_OCFS2_COMPAT_JBD
@@ -1912,0 +1929,2 @@
+#endif
+			}
--- ./projects/linux/linux-2.6.28/fs/ocfs2/aops.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/fs/ocfs2/aops.c	2009-03-24 00:12:14.000000000 +0100
@@ -29,0 +30 @@
+#include <linux/quotaops.h>
@@ -71 +72 @@
-	status = ocfs2_read_block(inode, OCFS2_I(inode)->ip_blkno, &bh);
+	status = ocfs2_read_inode_block(inode, &bh);
@@ -78,7 +78,0 @@
-	if (!OCFS2_IS_VALID_DINODE(fe)) {
-		mlog(ML_ERROR, "Invalid dinode #%llu: signature = %.*s\n",
-		     (unsigned long long)le64_to_cpu(fe->i_blkno), 7,
-		     fe->i_signature);
-		goto bail;
-	}
-
@@ -236 +230 @@
-	    size > ocfs2_max_inline_data(inode->i_sb)) {
+	    size > ocfs2_max_inline_data_with_xattr(inode->i_sb, di)) {
@@ -265 +259 @@
-	ret = ocfs2_read_block(inode, OCFS2_I(inode)->ip_blkno, &di_bh);
+	ret = ocfs2_read_inode_block(inode, &di_bh);
@@ -484,6 +477,0 @@
-#ifdef CONFIG_OCFS2_COMPAT_JBD
-		ret = walk_page_buffers(handle,
-					page_buffers(page),
-					from, to, NULL,
-					ocfs2_journal_dirty_data);
-#endif
@@ -1075 +1063 @@
-			if (ocfs2_should_order_data(inode)) {
+			if (ocfs2_should_order_data(inode))
@@ -1077,7 +1064,0 @@
-#ifdef CONFIG_OCFS2_COMPAT_JBD
-				walk_page_buffers(wc->w_handle,
-						  page_buffers(tmppage),
-						  from, to, NULL,
-						  ocfs2_journal_dirty_data);
-#endif
-			}
@@ -1534,2 +1515,2 @@
-	ret = ocfs2_journal_access(handle, inode, wc->w_di_bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
+	ret = ocfs2_journal_access_di(handle, inode, wc->w_di_bh,
+				      OCFS2_JOURNAL_ACCESS_WRITE);
@@ -1576,0 +1558 @@
+	struct ocfs2_dinode *di = NULL;
@@ -1609 +1591,3 @@
-	if (mmap_page || end > ocfs2_max_inline_data(inode->i_sb))
+	di = (struct ocfs2_dinode *)wc->w_di_bh->b_data;
+	if (mmap_page ||
+	    end > ocfs2_max_inline_data_with_xattr(inode->i_sb, di))
@@ -1752,0 +1737,5 @@
+	if (clusters_to_alloc && vfs_dq_alloc_space_nodirty(inode,
+			ocfs2_clusters_to_bytes(osb->sb, clusters_to_alloc))) {
+		ret = -EDQUOT;
+		goto out_commit;
+	}
@@ -1757,2 +1746,2 @@
-	ret = ocfs2_journal_access(handle, inode, wc->w_di_bh,
-				   OCFS2_JOURNAL_ACCESS_WRITE);
+	ret = ocfs2_journal_access_di(handle, inode, wc->w_di_bh,
+				      OCFS2_JOURNAL_ACCESS_WRITE);
@@ -1761 +1750 @@
-		goto out_commit;
+		goto out_quota;
@@ -1774 +1763 @@
-		goto out_commit;
+		goto out_quota;
@@ -1781 +1770 @@
-		goto out_commit;
+		goto out_quota;
@@ -1792,0 +1782,4 @@
+out_quota:
+	if (clusters_to_alloc)
+		vfs_dq_free_space(inode,
+			  ocfs2_clusters_to_bytes(osb->sb, clusters_to_alloc));
@@ -1922 +1915 @@
-			if (ocfs2_should_order_data(inode)) {
+			if (ocfs2_should_order_data(inode))
@@ -1924,7 +1916,0 @@
-#ifdef CONFIG_OCFS2_COMPAT_JBD
-				walk_page_buffers(wc->w_handle,
-						  page_buffers(tmppage),
-						  from, to, NULL,
-						  ocfs2_journal_dirty_data);
-#endif
-			}
--- ./projects/linux/linux-2.6.29/fs/ocfs2/aops.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/fs/ocfs2/aops.c	2009-06-27 11:32:32.000000000 +0200
@@ -1959,11 +1959,12 @@
-	.readpage	= ocfs2_readpage,
-	.readpages	= ocfs2_readpages,
-	.writepage	= ocfs2_writepage,
-	.write_begin	= ocfs2_write_begin,
-	.write_end	= ocfs2_write_end,
-	.bmap		= ocfs2_bmap,
-	.sync_page	= block_sync_page,
-	.direct_IO	= ocfs2_direct_IO,
-	.invalidatepage	= ocfs2_invalidatepage,
-	.releasepage	= ocfs2_releasepage,
-	.migratepage	= buffer_migrate_page,
+	.readpage		= ocfs2_readpage,
+	.readpages		= ocfs2_readpages,
+	.writepage		= ocfs2_writepage,
+	.write_begin		= ocfs2_write_begin,
+	.write_end		= ocfs2_write_end,
+	.bmap			= ocfs2_bmap,
+	.sync_page		= block_sync_page,
+	.direct_IO		= ocfs2_direct_IO,
+	.invalidatepage		= ocfs2_invalidatepage,
+	.releasepage		= ocfs2_releasepage,
+	.migratepage		= buffer_migrate_page,
+	.is_partially_uptodate	= block_is_partially_uptodate,
--- ./projects/linux/linux-2.6.16/fs/ocfs2/dlmglue.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/fs/ocfs2/dlmglue.c	2006-06-18 03:49:35.000000000 +0200
@@ -234,3 +234,3 @@
-	len = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, "%c%s%016"MLFx64"%08x",
-		       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD, blkno,
-		       generation);
+	len = snprintf(name, OCFS2_LOCK_ID_MAX_LEN, "%c%s%016llx%08x",
+		       ocfs2_lock_type_char(type), OCFS2_LOCK_ID_PAD,
+		       (long long)blkno, generation);
@@ -536,2 +536,2 @@
-	mlog(0, "AST fired for inode %"MLFu64", l_action = %u, type = %s\n",
-	     OCFS2_I(inode)->ip_blkno, lockres->l_action,
+	mlog(0, "AST fired for inode %llu, l_action = %u, type = %s\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno, lockres->l_action,
@@ -547,2 +547,2 @@
-		     "on inode %"MLFu64"\n", lksb->status,
-		     OCFS2_I(inode)->ip_blkno);
+		     "on inode %llu\n", lksb->status,
+		     (unsigned long long)OCFS2_I(inode)->ip_blkno);
@@ -649,4 +649,3 @@
-	mlog(0, "BAST fired for inode %"MLFu64", blocking = %d, level = %d "
-	     "type = %s\n", OCFS2_I(inode)->ip_blkno, level,
-	     lockres->l_level,
-	     ocfs2_lock_type_string(lockres->l_type));
+	mlog(0, "BAST fired for inode %llu, blocking %d, level %d type %s\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno, level,
+	     lockres->l_level, ocfs2_lock_type_string(lockres->l_type));
@@ -1107 +1106 @@
-	mlog(0, "Inode %"MLFu64"\n", OCFS2_I(inode)->ip_blkno);
+	mlog(0, "Inode %llu\n", (unsigned long long)OCFS2_I(inode)->ip_blkno);
@@ -1152,2 +1151,2 @@
-	mlog(0, "inode %"MLFu64" take %s RW lock\n",
-	     OCFS2_I(inode)->ip_blkno,
+	mlog(0, "inode %llu take %s RW lock\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno,
@@ -1176,2 +1175,2 @@
-	mlog(0, "inode %"MLFu64" drop %s RW lock\n",
-	     OCFS2_I(inode)->ip_blkno,
+	mlog(0, "inode %llu drop %s RW lock\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno,
@@ -1196,2 +1195,2 @@
-	mlog(0, "inode %"MLFu64" take %s DATA lock\n",
-	     OCFS2_I(inode)->ip_blkno,
+	mlog(0, "inode %llu take %s DATA lock\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno,
@@ -1281,2 +1280,2 @@
-	mlog(0, "inode %"MLFu64" drop %s DATA lock\n",
-	     OCFS2_I(inode)->ip_blkno,
+	mlog(0, "inode %llu drop %s DATA lock\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno,
@@ -1465 +1464 @@
-		mlog(0, "Orphaned inode %"MLFu64" was deleted while we "
+		mlog(0, "Orphaned inode %llu was deleted while we "
@@ -1467 +1466 @@
-		     oi->ip_blkno, oi->ip_flags);
+		     (unsigned long long)oi->ip_blkno, oi->ip_flags);
@@ -1488,2 +1487,2 @@
-		mlog(0, "Trusting LVB on inode %"MLFu64"\n",
-		     oi->ip_blkno);
+		mlog(0, "Trusting LVB on inode %llu\n",
+		     (unsigned long long)oi->ip_blkno);
@@ -1517 +1516 @@
-				"Invalid dinode %"MLFu64" disk generation: %u "
+				"Invalid dinode %llu disk generation: %u "
@@ -1519 +1518,2 @@
-				oi->ip_blkno, le32_to_cpu(fe->i_generation),
+				(unsigned long long)oi->ip_blkno,
+				le32_to_cpu(fe->i_generation),
@@ -1523,3 +1523,3 @@
-				"Stale dinode %"MLFu64" dtime: %"MLFu64" "
-				"flags: 0x%x\n", oi->ip_blkno,
-				le64_to_cpu(fe->i_dtime),
+				"Stale dinode %llu dtime: %llu flags: 0x%x\n",
+				(unsigned long long)oi->ip_blkno,
+				(unsigned long long)le64_to_cpu(fe->i_dtime),
@@ -1584,2 +1584,2 @@
-	mlog(0, "inode %"MLFu64", take %s META lock\n",
-	     OCFS2_I(inode)->ip_blkno,
+	mlog(0, "inode %llu, take %s META lock\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno,
@@ -1719,2 +1719,2 @@
-	mlog(0, "inode %"MLFu64" drop %s META lock\n",
-	     OCFS2_I(inode)->ip_blkno,
+	mlog(0, "inode %llu drop %s META lock\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno,
@@ -2020 +2020 @@
-static struct file_operations ocfs2_dlm_debug_fops = {
+static const struct file_operations ocfs2_dlm_debug_fops = {
@@ -2689,2 +2689,2 @@
-		mlog(ML_ERROR, "Could not sync inode %"MLFu64" for downconvert!",
-		     OCFS2_I(inode)->ip_blkno);
+		mlog(ML_ERROR, "Could not sync inode %llu for downconvert!",
+		     (unsigned long long)OCFS2_I(inode)->ip_blkno);
@@ -2720 +2720,2 @@
-	mlog(0, "unblock inode %"MLFu64"\n", OCFS2_I(inode)->ip_blkno);
+	mlog(0, "unblock inode %llu\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno);
@@ -2729,2 +2730,2 @@
-	mlog(0, "inode %"MLFu64", requeue = %d\n",
-	     OCFS2_I(inode)->ip_blkno, *requeue);
+	mlog(0, "inode %llu, requeue = %d\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno, *requeue);
@@ -2770 +2771,2 @@
-	mlog(0, "unblock inode %"MLFu64"\n", OCFS2_I(inode)->ip_blkno);
+	mlog(0, "unblock inode %llu\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno);
@@ -2776,2 +2778,2 @@
-	mlog(0, "inode %"MLFu64", requeue = %d\n",
-	     OCFS2_I(inode)->ip_blkno, *requeue);
+	mlog(0, "inode %llu, requeue = %d\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno, *requeue);
@@ -2896,8 +2898,9 @@
-	mlog(level, "size: %"MLFu64", uid %u, gid %u, mode 0x%x\n",
-	     be64_to_cpu(lvb->lvb_isize), be32_to_cpu(lvb->lvb_iuid),
-	     be32_to_cpu(lvb->lvb_igid), be16_to_cpu(lvb->lvb_imode));
-	mlog(level, "nlink %u, atime_packed 0x%"MLFx64", "
-	     "ctime_packed 0x%"MLFx64", mtime_packed 0x%"MLFx64"\n",
-	     be16_to_cpu(lvb->lvb_inlink), be64_to_cpu(lvb->lvb_iatime_packed),
-	     be64_to_cpu(lvb->lvb_ictime_packed),
-	     be64_to_cpu(lvb->lvb_imtime_packed));
+	mlog(level, "size: %llu, uid %u, gid %u, mode 0x%x\n",
+	     (unsigned long long)be64_to_cpu(lvb->lvb_isize),
+	     be32_to_cpu(lvb->lvb_iuid), be32_to_cpu(lvb->lvb_igid),
+	     be16_to_cpu(lvb->lvb_imode));
+	mlog(level, "nlink %u, atime_packed 0x%llx, ctime_packed 0x%llx, "
+	     "mtime_packed 0x%llx\n", be16_to_cpu(lvb->lvb_inlink),
+	     (long long)be64_to_cpu(lvb->lvb_iatime_packed),
+	     (long long)be64_to_cpu(lvb->lvb_ictime_packed),
+	     (long long)be64_to_cpu(lvb->lvb_imtime_packed));
--- ./projects/linux/linux-2.6.17/fs/ocfs2/dlmglue.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/fs/ocfs2/dlmglue.c	2006-09-20 05:42:06.000000000 +0200
@@ -245 +245 @@
-static spinlock_t ocfs2_dlm_tracking_lock = SPIN_LOCK_UNLOCKED;
+static DEFINE_SPINLOCK(ocfs2_dlm_tracking_lock);
@@ -2074,2 +2074 @@
-	osb->vote_task = kthread_run(ocfs2_vote_thread, osb, "ocfs2vote-%d",
-				     osb->osb_id);
+	osb->vote_task = kthread_run(ocfs2_vote_thread, osb, "ocfs2vote");
--- ./projects/linux/linux-2.6.18/fs/ocfs2/dlmglue.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/fs/ocfs2/dlmglue.c	2006-11-29 22:57:37.000000000 +0100
@@ -48,0 +49 @@
+#include "dcache.h"
@@ -69,28 +70,2 @@
-static void ocfs2_inode_ast_func(void *opaque);
-static void ocfs2_inode_bast_func(void *opaque,
-				  int level);
-static void ocfs2_super_ast_func(void *opaque);
-static void ocfs2_super_bast_func(void *opaque,
-				  int level);
-static void ocfs2_rename_ast_func(void *opaque);
-static void ocfs2_rename_bast_func(void *opaque,
-				   int level);
-
-/* so far, all locks have gotten along with the same unlock ast */
-static void ocfs2_unlock_ast_func(void *opaque,
-				  enum dlm_status status);
-static int ocfs2_do_unblock_meta(struct inode *inode,
-				 int *requeue);
-static int ocfs2_unblock_meta(struct ocfs2_lock_res *lockres,
-			      int *requeue);
-static int ocfs2_unblock_data(struct ocfs2_lock_res *lockres,
-			      int *requeue);
-static int ocfs2_unblock_inode_lock(struct ocfs2_lock_res *lockres,
-			      int *requeue);
-static int ocfs2_unblock_osb_lock(struct ocfs2_lock_res *lockres,
-				  int *requeue);
-typedef void (ocfs2_convert_worker_t)(struct ocfs2_lock_res *, int);
-static int ocfs2_generic_unblock_lock(struct ocfs2_super *osb,
-				      struct ocfs2_lock_res *lockres,
-				      int *requeue,
-				      ocfs2_convert_worker_t *worker);
+static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres);
+static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres);
@@ -97,0 +73,46 @@
+/*
+ * Return value from ->downconvert_worker functions.
+ *
+ * These control the precise actions of ocfs2_unblock_lock()
+ * and ocfs2_process_blocked_lock()
+ *
+ */
+enum ocfs2_unblock_action {
+	UNBLOCK_CONTINUE	= 0, /* Continue downconvert */
+	UNBLOCK_CONTINUE_POST	= 1, /* Continue downconvert, fire
+				      * ->post_unlock callback */
+	UNBLOCK_STOP_POST	= 2, /* Do not downconvert, fire
+				      * ->post_unlock() callback. */
+};
+
+struct ocfs2_unblock_ctl {
+	int requeue;
+	enum ocfs2_unblock_action unblock_action;
+};
+
+static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,
+					int new_level);
+static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres);
+
+static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,
+				     int blocking);
+
+static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,
+				       int blocking);
+
+static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,
+				     struct ocfs2_lock_res *lockres);
+
+/*
+ * OCFS2 Lock Resource Operations
+ *
+ * These fine tune the behavior of the generic dlmglue locking infrastructure.
+ *
+ * The most basic of lock types can point ->l_priv to their respective
+ * struct ocfs2_super and allow the default actions to manage things.
+ *
+ * Right now, each lock type also needs to implement an init function,
+ * and trivial lock/unlock wrappers. ocfs2_simple_drop_lockres()
+ * should be called when the lock is no longer needed (i.e., object
+ * destruction time).
+ */
@@ -99,4 +120,56 @@
-	void (*ast)(void *);
-	void (*bast)(void *, int);
-	void (*unlock_ast)(void *, enum dlm_status);
-	int  (*unblock)(struct ocfs2_lock_res *, int *);
+	/*
+	 * Translate an ocfs2_lock_res * into an ocfs2_super *. Define
+	 * this callback if ->l_priv is not an ocfs2_super pointer
+	 */
+	struct ocfs2_super * (*get_osb)(struct ocfs2_lock_res *);
+
+	/*
+	 * Optionally called in the downconvert (or "vote") thread
+	 * after a successful downconvert. The lockres will not be
+	 * referenced after this callback is called, so it is safe to
+	 * free memory, etc.
+	 *
+	 * The exact semantics of when this is called are controlled
+	 * by ->downconvert_worker()
+	 */
+	void (*post_unlock)(struct ocfs2_super *, struct ocfs2_lock_res *);
+
+	/*
+	 * Allow a lock type to add checks to determine whether it is
+	 * safe to downconvert a lock. Return 0 to re-queue the
+	 * downconvert at a later time, nonzero to continue.
+	 *
+	 * For most locks, the default checks that there are no
+	 * incompatible holders are sufficient.
+	 *
+	 * Called with the lockres spinlock held.
+	 */
+	int (*check_downconvert)(struct ocfs2_lock_res *, int);
+
+	/*
+	 * Allows a lock type to populate the lock value block. This
+	 * is called on downconvert, and when we drop a lock.
+	 *
+	 * Locks that want to use this should set LOCK_TYPE_USES_LVB
+	 * in the flags field.
+	 *
+	 * Called with the lockres spinlock held.
+	 */
+	void (*set_lvb)(struct ocfs2_lock_res *);
+
+	/*
+	 * Called from the downconvert thread when it is determined
+	 * that a lock will be downconverted. This is called without
+	 * any locks held so the function can do work that might
+	 * schedule (syncing out data, etc).
+	 *
+	 * This should return any one of the ocfs2_unblock_action
+	 * values, depending on what it wants the thread to do.
+	 */
+	int (*downconvert_worker)(struct ocfs2_lock_res *, int);
+
+	/*
+	 * LOCK_TYPE_* flags which describe the specific requirements
+	 * of a lock type. Descriptions of each individual flag follow.
+	 */
+	int flags;
@@ -104,0 +178,16 @@
+/*
+ * Some locks want to "refresh" potentially stale data when a
+ * meaningful (PRMODE or EXMODE) lock level is first obtained. If this
+ * flag is set, the OCFS2_LOCK_NEEDS_REFRESH flag will be set on the
+ * individual lockres l_flags member from the ast function. It is
+ * expected that the locking wrapper will clear the
+ * OCFS2_LOCK_NEEDS_REFRESH flag when done.
+ */
+#define LOCK_TYPE_REQUIRES_REFRESH 0x1
+
+/*
+ * Indicate that a lock type makes use of the lock value block. The
+ * ->set_lvb lock type callback must be defined.
+ */
+#define LOCK_TYPE_USES_LVB		0x2
+
@@ -106,4 +195,2 @@
-	.ast		= ocfs2_inode_ast_func,
-	.bast		= ocfs2_inode_bast_func,
-	.unlock_ast	= ocfs2_unlock_ast_func,
-	.unblock	= ocfs2_unblock_inode_lock,
+	.get_osb	= ocfs2_get_inode_osb,
+	.flags		= 0,
@@ -113,4 +200,4 @@
-	.ast		= ocfs2_inode_ast_func,
-	.bast		= ocfs2_inode_bast_func,
-	.unlock_ast	= ocfs2_unlock_ast_func,
-	.unblock	= ocfs2_unblock_meta,
+	.get_osb	= ocfs2_get_inode_osb,
+	.check_downconvert = ocfs2_check_meta_downconvert,
+	.set_lvb	= ocfs2_set_meta_lvb,
+	.flags		= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,
@@ -119,3 +205,0 @@
-static void ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,
-				      int blocking);
-
@@ -123,4 +207,3 @@
-	.ast		= ocfs2_inode_ast_func,
-	.bast		= ocfs2_inode_bast_func,
-	.unlock_ast	= ocfs2_unlock_ast_func,
-	.unblock	= ocfs2_unblock_data,
+	.get_osb	= ocfs2_get_inode_osb,
+	.downconvert_worker = ocfs2_data_convert_worker,
+	.flags		= 0,
@@ -130,4 +213 @@
-	.ast		= ocfs2_super_ast_func,
-	.bast		= ocfs2_super_bast_func,
-	.unlock_ast	= ocfs2_unlock_ast_func,
-	.unblock	= ocfs2_unblock_osb_lock,
+	.flags		= LOCK_TYPE_REQUIRES_REFRESH,
@@ -137,4 +217,8 @@
-	.ast		= ocfs2_rename_ast_func,
-	.bast		= ocfs2_rename_bast_func,
-	.unlock_ast	= ocfs2_unlock_ast_func,
-	.unblock	= ocfs2_unblock_osb_lock,
+	.flags		= 0,
+};
+
+static struct ocfs2_lock_res_ops ocfs2_dentry_lops = {
+	.get_osb	= ocfs2_get_dentry_osb,
+	.post_unlock	= ocfs2_dentry_post_unlock,
+	.downconvert_worker = ocfs2_dentry_convert_worker,
+	.flags		= 0,
@@ -150 +234 @@
-static inline int ocfs2_is_super_lock(struct ocfs2_lock_res *lockres)
+static inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)
@@ -152,2 +236 @@
-	return lockres->l_type == OCFS2_LOCK_TYPE_SUPER;
-}
+	BUG_ON(!ocfs2_is_inode_lock(lockres));
@@ -155,3 +238 @@
-static inline int ocfs2_is_rename_lock(struct ocfs2_lock_res *lockres)
-{
-	return lockres->l_type == OCFS2_LOCK_TYPE_RENAME;
+	return (struct inode *) lockres->l_priv;
@@ -160 +241 @@
-static inline struct ocfs2_super *ocfs2_lock_res_super(struct ocfs2_lock_res *lockres)
+static inline struct ocfs2_dentry_lock *ocfs2_lock_res_dl(struct ocfs2_lock_res *lockres)
@@ -162,2 +243 @@
-	BUG_ON(!ocfs2_is_super_lock(lockres)
-	       && !ocfs2_is_rename_lock(lockres));
+	BUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_DENTRY);
@@ -165 +245 @@
-	return (struct ocfs2_super *) lockres->l_priv;
+	return (struct ocfs2_dentry_lock *)lockres->l_priv;
@@ -168 +248 @@
-static inline struct inode *ocfs2_lock_res_inode(struct ocfs2_lock_res *lockres)
+static inline struct ocfs2_super *ocfs2_get_lockres_osb(struct ocfs2_lock_res *lockres)
@@ -170 +250,2 @@
-	BUG_ON(!ocfs2_is_inode_lock(lockres));
+	if (lockres->l_ops->get_osb)
+		return lockres->l_ops->get_osb(lockres);
@@ -172 +253 @@
-	return (struct inode *) lockres->l_priv;
+	return (struct ocfs2_super *)lockres->l_priv;
@@ -203,19 +283,0 @@
-static inline int ocfs2_can_downconvert_meta_lock(struct inode *inode,
-						  struct ocfs2_lock_res *lockres,
-						  int new_level);
-
-static char *ocfs2_lock_type_strings[] = {
-	[OCFS2_LOCK_TYPE_META] = "Meta",
-	[OCFS2_LOCK_TYPE_DATA] = "Data",
-	[OCFS2_LOCK_TYPE_SUPER] = "Super",
-	[OCFS2_LOCK_TYPE_RENAME] = "Rename",
-	/* Need to differntiate from [R]ename.. serializing writes is the
-	 * important job it does, anyway. */
-	[OCFS2_LOCK_TYPE_RW] = "Write/Read",
-};
-
-static char *ocfs2_lock_type_string(enum ocfs2_lock_type type)
-{
-	mlog_bug_on_msg(type >= OCFS2_NUM_LOCK_TYPES, "%d\n", type);
-	return ocfs2_lock_type_strings[type];
-}
@@ -268,2 +329,0 @@
-				       u64 blkno,
-				       u32 generation,
@@ -273,2 +332,0 @@
-	ocfs2_build_lock_name(type, blkno, generation, res->l_name);
-
@@ -301,0 +360 @@
+			       unsigned int generation,
@@ -322,3 +381,67 @@
-	ocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), res, type,
-				   OCFS2_I(inode)->ip_blkno,
-				   inode->i_generation, ops, inode);
+	ocfs2_build_lock_name(type, OCFS2_I(inode)->ip_blkno,
+			      generation, res->l_name);
+	ocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), res, type, ops, inode);
+}
+
+static struct ocfs2_super *ocfs2_get_inode_osb(struct ocfs2_lock_res *lockres)
+{
+	struct inode *inode = ocfs2_lock_res_inode(lockres);
+
+	return OCFS2_SB(inode->i_sb);
+}
+
+static __u64 ocfs2_get_dentry_lock_ino(struct ocfs2_lock_res *lockres)
+{
+	__be64 inode_blkno_be;
+
+	memcpy(&inode_blkno_be, &lockres->l_name[OCFS2_DENTRY_LOCK_INO_START],
+	       sizeof(__be64));
+
+	return be64_to_cpu(inode_blkno_be);
+}
+
+static struct ocfs2_super *ocfs2_get_dentry_osb(struct ocfs2_lock_res *lockres)
+{
+	struct ocfs2_dentry_lock *dl = lockres->l_priv;
+
+	return OCFS2_SB(dl->dl_inode->i_sb);
+}
+
+void ocfs2_dentry_lock_res_init(struct ocfs2_dentry_lock *dl,
+				u64 parent, struct inode *inode)
+{
+	int len;
+	u64 inode_blkno = OCFS2_I(inode)->ip_blkno;
+	__be64 inode_blkno_be = cpu_to_be64(inode_blkno);
+	struct ocfs2_lock_res *lockres = &dl->dl_lockres;
+
+	ocfs2_lock_res_init_once(lockres);
+
+	/*
+	 * Unfortunately, the standard lock naming scheme won't work
+	 * here because we have two 16 byte values to use. Instead,
+	 * we'll stuff the inode number as a binary value. We still
+	 * want error prints to show something without garbling the
+	 * display, so drop a null byte in there before the inode
+	 * number. A future version of OCFS2 will likely use all
+	 * binary lock names. The stringified names have been a
+	 * tremendous aid in debugging, but now that the debugfs
+	 * interface exists, we can mangle things there if need be.
+	 *
+	 * NOTE: We also drop the standard "pad" value (the total lock
+	 * name size stays the same though - the last part is all
+	 * zeros due to the memset in ocfs2_lock_res_init_once()
+	 */
+	len = snprintf(lockres->l_name, OCFS2_DENTRY_LOCK_INO_START,
+		       "%c%016llx",
+		       ocfs2_lock_type_char(OCFS2_LOCK_TYPE_DENTRY),
+		       (long long)parent);
+
+	BUG_ON(len != (OCFS2_DENTRY_LOCK_INO_START - 1));
+
+	memcpy(&lockres->l_name[OCFS2_DENTRY_LOCK_INO_START], &inode_blkno_be,
+	       sizeof(__be64));
+
+	ocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,
+				   OCFS2_LOCK_TYPE_DENTRY, &ocfs2_dentry_lops,
+				   dl);
@@ -332,0 +456,2 @@
+	ocfs2_build_lock_name(OCFS2_LOCK_TYPE_SUPER, OCFS2_SUPER_BLOCK_BLKNO,
+			      0, res->l_name);
@@ -334 +458,0 @@
-				   OCFS2_SUPER_BLOCK_BLKNO, 0,
@@ -344 +468,2 @@
-	ocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_RENAME, 0, 0,
+	ocfs2_build_lock_name(OCFS2_LOCK_TYPE_RENAME, 0, 0, res->l_name);
+	ocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_RENAME,
@@ -498 +623,2 @@
-	if (lockres->l_level == LKM_NLMODE)
+	if (lockres->l_level == LKM_NLMODE &&
+	    lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)
@@ -515 +641,2 @@
-	    !(lockres->l_flags & OCFS2_LOCK_LOCAL))
+	    !(lockres->l_flags & OCFS2_LOCK_LOCAL) &&
+	    lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)
@@ -525,62 +651,0 @@
-static void ocfs2_inode_ast_func(void *opaque)
-{
-	struct ocfs2_lock_res *lockres = opaque;
-	struct inode *inode;
-	struct dlm_lockstatus *lksb;
-	unsigned long flags;
-
-	mlog_entry_void();
-
-	inode = ocfs2_lock_res_inode(lockres);
-
-	mlog(0, "AST fired for inode %llu, l_action = %u, type = %s\n",
-	     (unsigned long long)OCFS2_I(inode)->ip_blkno, lockres->l_action,
-	     ocfs2_lock_type_string(lockres->l_type));
-
-	BUG_ON(!ocfs2_is_inode_lock(lockres));
-
-	spin_lock_irqsave(&lockres->l_lock, flags);
-
-	lksb = &(lockres->l_lksb);
-	if (lksb->status != DLM_NORMAL) {
-		mlog(ML_ERROR, "ocfs2_inode_ast_func: lksb status value of %u "
-		     "on inode %llu\n", lksb->status,
-		     (unsigned long long)OCFS2_I(inode)->ip_blkno);
-		spin_unlock_irqrestore(&lockres->l_lock, flags);
-		mlog_exit_void();
-		return;
-	}
-
-	switch(lockres->l_action) {
-	case OCFS2_AST_ATTACH:
-		ocfs2_generic_handle_attach_action(lockres);
-		lockres_clear_flags(lockres, OCFS2_LOCK_LOCAL);
-		break;
-	case OCFS2_AST_CONVERT:
-		ocfs2_generic_handle_convert_action(lockres);
-		break;
-	case OCFS2_AST_DOWNCONVERT:
-		ocfs2_generic_handle_downconvert_action(lockres);
-		break;
-	default:
-		mlog(ML_ERROR, "lockres %s: ast fired with invalid action: %u "
-		     "lockres flags = 0x%lx, unlock action: %u\n",
-		     lockres->l_name, lockres->l_action, lockres->l_flags,
-		     lockres->l_unlock_action);
-
-		BUG();
-	}
-
-	/* data and rw locking ignores refresh flag for now. */
-	if (lockres->l_type != OCFS2_LOCK_TYPE_META)
-		lockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);
-
-	/* set it to something invalid so if we get called again we
-	 * can catch it. */
-	lockres->l_action = OCFS2_AST_INVALID;
-	spin_unlock_irqrestore(&lockres->l_lock, flags);
-	wake_up(&lockres->l_event);
-
-	mlog_exit_void();
-}
-
@@ -613,3 +678 @@
-static void ocfs2_generic_bast_func(struct ocfs2_super *osb,
-				    struct ocfs2_lock_res *lockres,
-				    int level)
+static void ocfs2_blocking_ast(void *opaque, int level)
@@ -616,0 +680,2 @@
+	struct ocfs2_lock_res *lockres = opaque;
+	struct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);
@@ -620,2 +684,0 @@
-	mlog_entry_void();
-
@@ -623,0 +687,4 @@
+	mlog(0, "BAST fired for lockres %s, blocking %d, level %d type %s\n",
+	     lockres->l_name, level, lockres->l_level,
+	     ocfs2_lock_type_string(lockres->l_type));
+
@@ -630,2 +696,0 @@
-	ocfs2_kick_vote_thread(osb);
-
@@ -633,15 +697,0 @@
-	mlog_exit_void();
-}
-
-static void ocfs2_inode_bast_func(void *opaque, int level)
-{
-	struct ocfs2_lock_res *lockres = opaque;
-	struct inode *inode;
-	struct ocfs2_super *osb;
-
-	mlog_entry_void();
-
-	BUG_ON(!ocfs2_is_inode_lock(lockres));
-
-	inode = ocfs2_lock_res_inode(lockres);
-	osb = OCFS2_SB(inode->i_sb);
@@ -649,7 +699 @@
-	mlog(0, "BAST fired for inode %llu, blocking %d, level %d type %s\n",
-	     (unsigned long long)OCFS2_I(inode)->ip_blkno, level,
-	     lockres->l_level, ocfs2_lock_type_string(lockres->l_type));
-
-	ocfs2_generic_bast_func(osb, lockres, level);
-
-	mlog_exit_void();
+	ocfs2_kick_vote_thread(osb);
@@ -658,2 +702 @@
-static void ocfs2_generic_ast_func(struct ocfs2_lock_res *lockres,
-				   int ignore_refresh)
+static void ocfs2_locking_ast(void *opaque)
@@ -660,0 +704 @@
+	struct ocfs2_lock_res *lockres = opaque;
@@ -675,0 +720 @@
+		lockres_clear_flags(lockres, OCFS2_LOCK_LOCAL);
@@ -683,0 +729,4 @@
+		mlog(ML_ERROR, "lockres %s: ast fired with invalid action: %u "
+		     "lockres flags = 0x%lx, unlock action: %u\n",
+		     lockres->l_name, lockres->l_action, lockres->l_flags,
+		     lockres->l_unlock_action);
@@ -687,3 +735,0 @@
-	if (ignore_refresh)
-		lockres_clear_flags(lockres, OCFS2_LOCK_NEEDS_REFRESH);
-
@@ -693 +738,0 @@
-	spin_unlock_irqrestore(&lockres->l_lock, flags);
@@ -696,62 +741 @@
-}
-
-static void ocfs2_super_ast_func(void *opaque)
-{
-	struct ocfs2_lock_res *lockres = opaque;
-
-	mlog_entry_void();
-	mlog(0, "Superblock AST fired\n");
-
-	BUG_ON(!ocfs2_is_super_lock(lockres));
-	ocfs2_generic_ast_func(lockres, 0);
-
-	mlog_exit_void();
-}
-
-static void ocfs2_super_bast_func(void *opaque,
-				  int level)
-{
-	struct ocfs2_lock_res *lockres = opaque;
-	struct ocfs2_super *osb;
-
-	mlog_entry_void();
-	mlog(0, "Superblock BAST fired\n");
-
-	BUG_ON(!ocfs2_is_super_lock(lockres));
-       	osb = ocfs2_lock_res_super(lockres);
-	ocfs2_generic_bast_func(osb, lockres, level);
-
-	mlog_exit_void();
-}
-
-static void ocfs2_rename_ast_func(void *opaque)
-{
-	struct ocfs2_lock_res *lockres = opaque;
-
-	mlog_entry_void();
-
-	mlog(0, "Rename AST fired\n");
-
-	BUG_ON(!ocfs2_is_rename_lock(lockres));
-
-	ocfs2_generic_ast_func(lockres, 1);
-
-	mlog_exit_void();
-}
-
-static void ocfs2_rename_bast_func(void *opaque,
-				   int level)
-{
-	struct ocfs2_lock_res *lockres = opaque;
-	struct ocfs2_super *osb;
-
-	mlog_entry_void();
-
-	mlog(0, "Rename BAST fired\n");
-
-	BUG_ON(!ocfs2_is_rename_lock(lockres));
-
-	osb = ocfs2_lock_res_super(lockres);
-	ocfs2_generic_bast_func(osb, lockres, level);
-
-	mlog_exit_void();
+	spin_unlock_irqrestore(&lockres->l_lock, flags);
@@ -813 +797,2 @@
-			 lockres->l_ops->ast,
+			 OCFS2_LOCK_ID_MAX_LEN - 1,
+			 ocfs2_locking_ast,
@@ -815 +800 @@
-			 lockres->l_ops->bast);
+			 ocfs2_blocking_ast);
@@ -932,0 +918,3 @@
+	if (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)
+		lkm_flags |= LKM_VALBLK;
+
@@ -1000 +988 @@
-				 lkm_flags|LKM_CONVERT|LKM_VALBLK,
+				 lkm_flags|LKM_CONVERT,
@@ -1002 +990,2 @@
-				 lockres->l_ops->ast,
+				 OCFS2_LOCK_ID_MAX_LEN - 1,
+				 ocfs2_locking_ast,
@@ -1004 +993 @@
-				 lockres->l_ops->bast);
+				 ocfs2_blocking_ast);
@@ -1077,2 +1066,4 @@
-static int ocfs2_create_new_inode_lock(struct inode *inode,
-				       struct ocfs2_lock_res *lockres)
+int ocfs2_create_new_lock(struct ocfs2_super *osb,
+			  struct ocfs2_lock_res *lockres,
+			  int ex,
+			  int local)
@@ -1080 +1071 @@
-	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	int level =  ex ? LKM_EXMODE : LKM_PRMODE;
@@ -1081,0 +1073 @@
+	int lkm_flags = local ? LKM_LOCAL : 0;
@@ -1088 +1080 @@
-	return ocfs2_lock_create(osb, lockres, LKM_EXMODE, LKM_LOCAL);
+	return ocfs2_lock_create(osb, lockres, level, lkm_flags);
@@ -1099,0 +1092 @@
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
@@ -1116,2 +1109 @@
-	ret = ocfs2_create_new_inode_lock(inode,
-					  &OCFS2_I(inode)->ip_rw_lockres);
+	ret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_rw_lockres, 1, 1);
@@ -1123,2 +1115,5 @@
-	ret = ocfs2_create_new_inode_lock(inode,
-					  &OCFS2_I(inode)->ip_meta_lockres);
+	/*
+	 * We don't want to use LKM_LOCAL on a meta data lock as they
+	 * don't use a generation in their lock names.
+	 */
+	ret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_meta_lockres, 1, 0);
@@ -1130,2 +1125 @@
-	ret = ocfs2_create_new_inode_lock(inode,
-					  &OCFS2_I(inode)->ip_data_lockres);
+	ret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_data_lockres, 1, 1);
@@ -1320 +1314,11 @@
-	lvb->lvb_version   = cpu_to_be32(OCFS2_LVB_VERSION);
+	/*
+	 * Invalidate the LVB of a deleted inode - this way other
+	 * nodes are forced to go to disk and discover the new inode
+	 * status.
+	 */
+	if (oi->ip_flags & OCFS2_INODE_DELETED) {
+		lvb->lvb_version = 0;
+		goto out;
+	}
+
+	lvb->lvb_version   = OCFS2_LVB_VERSION;
@@ -1332,0 +1337,2 @@
+	lvb->lvb_iattr    = cpu_to_be32(oi->ip_attr);
+	lvb->lvb_igeneration = cpu_to_be32(inode->i_generation);
@@ -1333,0 +1340 @@
+out:
@@ -1362,0 +1370,3 @@
+	oi->ip_attr = be32_to_cpu(lvb->lvb_iattr);
+	ocfs2_set_inode_flags(inode);
+
@@ -1385 +1395,2 @@
-static inline int ocfs2_meta_lvb_is_trustable(struct ocfs2_lock_res *lockres)
+static inline int ocfs2_meta_lvb_is_trustable(struct inode *inode,
+					      struct ocfs2_lock_res *lockres)
@@ -1389 +1400,2 @@
-	if (be32_to_cpu(lvb->lvb_version) == OCFS2_LVB_VERSION)
+	if (lvb->lvb_version == OCFS2_LVB_VERSION
+	    && be32_to_cpu(lvb->lvb_igeneration) == inode->i_generation)
@@ -1486 +1498 @@
-	if (ocfs2_meta_lvb_is_trustable(lockres)) {
+	if (ocfs2_meta_lvb_is_trustable(inode, lockres)) {
@@ -1626,0 +1639,12 @@
+	/*
+	 * We only see this flag if we're being called from
+	 * ocfs2_read_locked_inode(). It means we're locking an inode
+	 * which hasn't been populated yet, so clear the refresh flag
+	 * and let the caller handle it.
+	 */
+	if (inode->i_state & I_NEW) {
+		status = 0;
+		ocfs2_complete_lock_res_refresh(lockres, 0);
+		goto bail;
+	}
+
@@ -1805,0 +1830,28 @@
+int ocfs2_dentry_lock(struct dentry *dentry, int ex)
+{
+	int ret;
+	int level = ex ? LKM_EXMODE : LKM_PRMODE;
+	struct ocfs2_dentry_lock *dl = dentry->d_fsdata;
+	struct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);
+
+	BUG_ON(!dl);
+
+	if (ocfs2_is_hard_readonly(osb))
+		return -EROFS;
+
+	ret = ocfs2_cluster_lock(osb, &dl->dl_lockres, level, 0, 0);
+	if (ret < 0)
+		mlog_errno(ret);
+
+	return ret;
+}
+
+void ocfs2_dentry_unlock(struct dentry *dentry, int ex)
+{
+	int level = ex ? LKM_EXMODE : LKM_PRMODE;
+	struct ocfs2_dentry_lock *dl = dentry->d_fsdata;
+	struct ocfs2_super *osb = OCFS2_SB(dentry->d_sb);
+
+	ocfs2_cluster_unlock(osb, &dl->dl_lockres, level);
+}
+
@@ -1936,3 +1988,10 @@
-	seq_printf(m, "0x%x\t"
-		   "%.*s\t"
-		   "%d\t"
+	seq_printf(m, "0x%x\t", OCFS2_DLM_DEBUG_STR_VERSION);
+
+	if (lockres->l_type == OCFS2_LOCK_TYPE_DENTRY)
+		seq_printf(m, "%.*s%08x\t", OCFS2_DENTRY_LOCK_INO_START - 1,
+			   lockres->l_name,
+			   (unsigned int)ocfs2_get_dentry_lock_ino(lockres));
+	else
+		seq_printf(m, "%.*s\t", OCFS2_LOCK_ID_MAX_LEN, lockres->l_name);
+
+	seq_printf(m, "%d\t"
@@ -1946,2 +2004,0 @@
-		   OCFS2_DLM_DEBUG_STR_VERSION,
-		   OCFS2_LOCK_ID_MAX_LEN, lockres->l_name,
@@ -1998 +2055 @@
-	osb = (struct ocfs2_super *) inode->u.generic_ip;
+	osb = inode->i_private;
@@ -2137 +2194 @@
-static void ocfs2_unlock_ast_func(void *opaque, enum dlm_status status)
+static void ocfs2_unlock_ast(void *opaque, enum dlm_status status)
@@ -2193,7 +2249,0 @@
-typedef void (ocfs2_pre_drop_cb_t)(struct ocfs2_lock_res *, void *);
-
-struct drop_lock_cb {
-	ocfs2_pre_drop_cb_t	*drop_func;
-	void			*drop_data;
-};
-
@@ -2201,2 +2251 @@
-			   struct ocfs2_lock_res *lockres,
-			   struct drop_lock_cb *dcb)
+			   struct ocfs2_lock_res *lockres)
@@ -2205,0 +2255 @@
+	int lkm_flags = 0;
@@ -2210,0 +2261,3 @@
+	if (lockres->l_ops->flags & LOCK_TYPE_USES_LVB)
+		lkm_flags |= LKM_VALBLK;
+
@@ -2233,2 +2286,6 @@
-	if (dcb)
-		dcb->drop_func(lockres, dcb->drop_data);
+	if (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {
+		if (lockres->l_flags & OCFS2_LOCK_ATTACHED &&
+		    lockres->l_level == LKM_EXMODE &&
+		    !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))
+			lockres->l_ops->set_lvb(lockres);
+	}
@@ -2260,2 +2317,2 @@
-	status = dlmunlock(osb->dlm, &lockres->l_lksb, LKM_VALBLK,
-			   lockres->l_ops->unlock_ast, lockres);
+	status = dlmunlock(osb->dlm, &lockres->l_lksb, lkm_flags,
+			   ocfs2_unlock_ast, lockres);
@@ -2308 +2365,2 @@
-static void ocfs2_drop_osb_locks(struct ocfs2_super *osb)
+void ocfs2_simple_drop_lockres(struct ocfs2_super *osb,
+			       struct ocfs2_lock_res *lockres)
@@ -2310,15 +2368 @@
-	int status;
-
-	mlog_entry_void();
-
-	ocfs2_mark_lockres_freeing(&osb->osb_super_lockres);
-
-	status = ocfs2_drop_lock(osb, &osb->osb_super_lockres, NULL);
-	if (status < 0)
-		mlog_errno(status);
-
-	ocfs2_mark_lockres_freeing(&osb->osb_rename_lockres);
-
-	status = ocfs2_drop_lock(osb, &osb->osb_rename_lockres, NULL);
-	if (status < 0)
-		mlog_errno(status);
+	int ret;
@@ -2326 +2370,4 @@
-	mlog_exit(status);
+	ocfs2_mark_lockres_freeing(lockres);
+	ret = ocfs2_drop_lock(osb, lockres);
+	if (ret)
+		mlog_errno(ret);
@@ -2329 +2376 @@
-static void ocfs2_meta_pre_drop(struct ocfs2_lock_res *lockres, void *data)
+static void ocfs2_drop_osb_locks(struct ocfs2_super *osb)
@@ -2331,8 +2378,2 @@
-	struct inode *inode = data;
-
-	/* the metadata lock requires a bit more work as we have an
-	 * LVB to worry about. */
-	if (lockres->l_flags & OCFS2_LOCK_ATTACHED &&
-	    lockres->l_level == LKM_EXMODE &&
-	    !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))
-		__ocfs2_stuff_meta_lvb(inode);
+	ocfs2_simple_drop_lockres(osb, &osb->osb_super_lockres);
+	ocfs2_simple_drop_lockres(osb, &osb->osb_rename_lockres);
@@ -2344 +2384,0 @@
-	struct drop_lock_cb meta_dcb = { ocfs2_meta_pre_drop, inode, };
@@ -2352,2 +2392 @@
-			      &OCFS2_I(inode)->ip_data_lockres,
-			      NULL);
+			      &OCFS2_I(inode)->ip_data_lockres);
@@ -2360,2 +2399 @@
-			      &OCFS2_I(inode)->ip_meta_lockres,
-			      &meta_dcb);
+			      &OCFS2_I(inode)->ip_meta_lockres);
@@ -2368,2 +2406 @@
-			      &OCFS2_I(inode)->ip_rw_lockres,
-			      NULL);
+			      &OCFS2_I(inode)->ip_rw_lockres);
@@ -2418 +2455,2 @@
-			 lockres->l_ops->ast,
+			 OCFS2_LOCK_ID_MAX_LEN - 1,
+			 ocfs2_locking_ast,
@@ -2420 +2458 @@
-			 lockres->l_ops->bast);
+			 ocfs2_blocking_ast);
@@ -2479 +2517 @@
-			   lockres->l_ops->unlock_ast,
+			   ocfs2_unlock_ast,
@@ -2493,104 +2531,3 @@
-static inline int ocfs2_can_downconvert_meta_lock(struct inode *inode,
-						  struct ocfs2_lock_res *lockres,
-						  int new_level)
-{
-	int ret;
-
-	mlog_entry_void();
-
-	BUG_ON(new_level != LKM_NLMODE && new_level != LKM_PRMODE);
-
-	if (lockres->l_flags & OCFS2_LOCK_REFRESHING) {
-		ret = 0;
-		mlog(0, "lockres %s currently being refreshed -- backing "
-		     "off!\n", lockres->l_name);
-	} else if (new_level == LKM_PRMODE)
-		ret = !lockres->l_ex_holders &&
-			ocfs2_inode_fully_checkpointed(inode);
-	else /* Must be NLMODE we're converting to. */
-		ret = !lockres->l_ro_holders && !lockres->l_ex_holders &&
-			ocfs2_inode_fully_checkpointed(inode);
-
-	mlog_exit(ret);
-	return ret;
-}
-
-static int ocfs2_do_unblock_meta(struct inode *inode,
-				 int *requeue)
-{
-	int new_level;
-	int set_lvb = 0;
-	int ret = 0;
-	struct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_meta_lockres;
-	unsigned long flags;
-
-	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
-
-	mlog_entry_void();
-
-	spin_lock_irqsave(&lockres->l_lock, flags);
-
-	BUG_ON(!(lockres->l_flags & OCFS2_LOCK_BLOCKED));
-
-	mlog(0, "l_level=%d, l_blocking=%d\n", lockres->l_level,
-	     lockres->l_blocking);
-
-	BUG_ON(lockres->l_level != LKM_EXMODE &&
-	       lockres->l_level != LKM_PRMODE);
-
-	if (lockres->l_flags & OCFS2_LOCK_BUSY) {
-		*requeue = 1;
-		ret = ocfs2_prepare_cancel_convert(osb, lockres);
-		spin_unlock_irqrestore(&lockres->l_lock, flags);
-		if (ret) {
-			ret = ocfs2_cancel_convert(osb, lockres);
-			if (ret < 0)
-				mlog_errno(ret);
-		}
-		goto leave;
-	}
-
-	new_level = ocfs2_highest_compat_lock_level(lockres->l_blocking);
-
-	mlog(0, "l_level=%d, l_blocking=%d, new_level=%d\n",
-	     lockres->l_level, lockres->l_blocking, new_level);
-
-	if (ocfs2_can_downconvert_meta_lock(inode, lockres, new_level)) {
-		if (lockres->l_level == LKM_EXMODE)
-			set_lvb = 1;
-
-		/* If the lock hasn't been refreshed yet (rare), then
-		 * our memory inode values are old and we skip
-		 * stuffing the lvb. There's no need to actually clear
-		 * out the lvb here as it's value is still valid. */
-		if (!(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH)) {
-			if (set_lvb)
-				__ocfs2_stuff_meta_lvb(inode);
-		} else
-			mlog(0, "lockres %s: downconverting stale lock!\n",
-			     lockres->l_name);
-
-		mlog(0, "calling ocfs2_downconvert_lock with l_level=%d, "
-		     "l_blocking=%d, new_level=%d\n",
-		     lockres->l_level, lockres->l_blocking, new_level);
-
-		ocfs2_prepare_downconvert(lockres, new_level);
-		spin_unlock_irqrestore(&lockres->l_lock, flags);
-		ret = ocfs2_downconvert_lock(osb, lockres, new_level, set_lvb);
-		goto leave;
-	}
-	if (!ocfs2_inode_fully_checkpointed(inode))
-		ocfs2_start_checkpoint(osb);
-
-	*requeue = 1;
-	spin_unlock_irqrestore(&lockres->l_lock, flags);
-	ret = 0;
-leave:
-	mlog_exit(ret);
-	return ret;
-}
-
-static int ocfs2_generic_unblock_lock(struct ocfs2_super *osb,
-				      struct ocfs2_lock_res *lockres,
-				      int *requeue,
-				      ocfs2_convert_worker_t *worker)
+static int ocfs2_unblock_lock(struct ocfs2_super *osb,
+			      struct ocfs2_lock_res *lockres,
+			      struct ocfs2_unblock_ctl *ctl)
@@ -2601,0 +2539 @@
+	int set_lvb = 0;
@@ -2611 +2549 @@
-		*requeue = 1;
+		ctl->requeue = 1;
@@ -2625,6 +2563,2 @@
-	    && (lockres->l_ex_holders || lockres->l_ro_holders)) {
-		spin_unlock_irqrestore(&lockres->l_lock, flags);
-		*requeue = 1;
-		ret = 0;
-		goto leave;
-	}
+	    && (lockres->l_ex_holders || lockres->l_ro_holders))
+		goto leave_requeue;
@@ -2635,6 +2569,16 @@
-	    lockres->l_ex_holders) {
-		spin_unlock_irqrestore(&lockres->l_lock, flags);
-		*requeue = 1;
-		ret = 0;
-		goto leave;
-	}
+	    lockres->l_ex_holders)
+		goto leave_requeue;
+
+	/*
+	 * Can we get a lock in this state if the holder counts are
+	 * zero? The meta data unblock code used to check this.
+	 */
+	if ((lockres->l_ops->flags & LOCK_TYPE_REQUIRES_REFRESH)
+	    && (lockres->l_flags & OCFS2_LOCK_REFRESHING))
+		goto leave_requeue;
+
+	new_level = ocfs2_highest_compat_lock_level(lockres->l_blocking);
+
+	if (lockres->l_ops->check_downconvert
+	    && !lockres->l_ops->check_downconvert(lockres, new_level))
+		goto leave_requeue;
@@ -2645 +2589 @@
-	if (!worker)
+	if (!lockres->l_ops->downconvert_worker)
@@ -2655 +2599,4 @@
-	worker(lockres, blocking);
+	ctl->unblock_action = lockres->l_ops->downconvert_worker(lockres, blocking);
+
+	if (ctl->unblock_action == UNBLOCK_STOP_POST)
+		goto leave;
@@ -2665,2 +2612,15 @@
-	*requeue = 0;
-	new_level = ocfs2_highest_compat_lock_level(lockres->l_blocking);
+	ctl->requeue = 0;
+
+	if (lockres->l_ops->flags & LOCK_TYPE_USES_LVB) {
+		if (lockres->l_level == LKM_EXMODE)
+			set_lvb = 1;
+
+		/*
+		 * We only set the lvb if the lock has been fully
+		 * refreshed - otherwise we risk setting stale
+		 * data. Otherwise, there's no need to actually clear
+		 * out the lvb here as it's value is still valid.
+		 */
+		if (set_lvb && !(lockres->l_flags & OCFS2_LOCK_NEEDS_REFRESH))
+			lockres->l_ops->set_lvb(lockres);
+	}
@@ -2670 +2630 @@
-	ret = ocfs2_downconvert_lock(osb, lockres, new_level, 0);
+	ret = ocfs2_downconvert_lock(osb, lockres, new_level, set_lvb);
@@ -2673,0 +2634,7 @@
+
+leave_requeue:
+	spin_unlock_irqrestore(&lockres->l_lock, flags);
+	ctl->requeue = 1;
+
+	mlog_exit(0);
+	return 0;
@@ -2676,2 +2643,2 @@
-static void ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,
-				      int blocking)
+static int ocfs2_data_convert_worker(struct ocfs2_lock_res *lockres,
+				     int blocking)
@@ -2682,2 +2648,0 @@
-	mlog_entry_void();
-
@@ -2704 +2669 @@
-	mlog_exit_void();
+	return UNBLOCK_CONTINUE;
@@ -2707,2 +2672,2 @@
-int ocfs2_unblock_data(struct ocfs2_lock_res *lockres,
-		       int *requeue)
+static int ocfs2_check_meta_downconvert(struct ocfs2_lock_res *lockres,
+					int new_level)
@@ -2710,8 +2675,2 @@
-	int status;
-	struct inode *inode;
-	struct ocfs2_super *osb;
-
-	mlog_entry_void();
-
-	inode = ocfs2_lock_res_inode(lockres);
-	osb = OCFS2_SB(inode->i_sb);
+	struct inode *inode = ocfs2_lock_res_inode(lockres);
+	int checkpointed = ocfs2_inode_fully_checkpointed(inode);
@@ -2719,9 +2678,2 @@
-	mlog(0, "unblock inode %llu\n",
-	     (unsigned long long)OCFS2_I(inode)->ip_blkno);
-
-	status = ocfs2_generic_unblock_lock(osb,
-					    lockres,
-					    requeue,
-					    ocfs2_data_convert_worker);
-	if (status < 0)
-		mlog_errno(status);
+	BUG_ON(new_level != LKM_NLMODE && new_level != LKM_PRMODE);
+	BUG_ON(lockres->l_level != LKM_EXMODE && !checkpointed);
@@ -2729,2 +2681,2 @@
-	mlog(0, "inode %llu, requeue = %d\n",
-	     (unsigned long long)OCFS2_I(inode)->ip_blkno, *requeue);
+	if (checkpointed)
+		return 1;
@@ -2732,2 +2684,2 @@
-	mlog_exit(status);
-	return status;
+	ocfs2_start_checkpoint(OCFS2_SB(inode->i_sb));
+	return 0;
@@ -2736,2 +2688 @@
-static int ocfs2_unblock_inode_lock(struct ocfs2_lock_res *lockres,
-				    int *requeue)
+static void ocfs2_set_meta_lvb(struct ocfs2_lock_res *lockres)
@@ -2739,6 +2690 @@
-	int status;
-	struct inode *inode;
-
-	mlog_entry_void();
-
-	mlog(0, "Unblock lockres %s\n", lockres->l_name);
+	struct inode *inode = ocfs2_lock_res_inode(lockres);
@@ -2746,11 +2692 @@
-	inode  = ocfs2_lock_res_inode(lockres);
-
-	status = ocfs2_generic_unblock_lock(OCFS2_SB(inode->i_sb),
-					    lockres,
-					    requeue,
-					    NULL);
-	if (status < 0)
-		mlog_errno(status);
-
-	mlog_exit(status);
-	return status;
+	__ocfs2_stuff_meta_lvb(inode);
@@ -2759,3 +2695,7 @@
-
-int ocfs2_unblock_meta(struct ocfs2_lock_res *lockres,
-		       int *requeue)
+/*
+ * Does the final reference drop on our dentry lock. Right now this
+ * happens in the vote thread, but we could choose to simplify the
+ * dlmglue API and push these off to the ocfs2_wq in the future.
+ */
+static void ocfs2_dentry_post_unlock(struct ocfs2_super *osb,
+				     struct ocfs2_lock_res *lockres)
@@ -2763,2 +2703,3 @@
-	int status;
-	struct inode *inode;
+	struct ocfs2_dentry_lock *dl = ocfs2_lock_res_dl(lockres);
+	ocfs2_dentry_lock_put(osb, dl);
+}
@@ -2766 +2707,27 @@
-	mlog_entry_void();
+/*
+ * d_delete() matching dentries before the lock downconvert.
+ *
+ * At this point, any process waiting to destroy the
+ * dentry_lock due to last ref count is stopped by the
+ * OCFS2_LOCK_QUEUED flag.
+ *
+ * We have two potential problems
+ *
+ * 1) If we do the last reference drop on our dentry_lock (via dput)
+ *    we'll wind up in ocfs2_release_dentry_lock(), waiting on
+ *    the downconvert to finish. Instead we take an elevated
+ *    reference and push the drop until after we've completed our
+ *    unblock processing.
+ *
+ * 2) There might be another process with a final reference,
+ *    waiting on us to finish processing. If this is the case, we
+ *    detect it and exit out - there's no more dentries anyway.
+ */
+static int ocfs2_dentry_convert_worker(struct ocfs2_lock_res *lockres,
+				       int blocking)
+{
+	struct ocfs2_dentry_lock *dl = ocfs2_lock_res_dl(lockres);
+	struct ocfs2_inode_info *oi = OCFS2_I(dl->dl_inode);
+	struct dentry *dentry;
+	unsigned long flags;
+	int extra_ref = 0;
@@ -2768 +2735,10 @@
-       	inode = ocfs2_lock_res_inode(lockres);
+	/*
+	 * This node is blocking another node from getting a read
+	 * lock. This happens when we've renamed within a
+	 * directory. We've forced the other nodes to d_delete(), but
+	 * we never actually dropped our lock because it's still
+	 * valid. The downconvert code will retain a PR for this node,
+	 * so there's no further work to do.
+	 */
+	if (blocking == LKM_PRMODE)
+		return UNBLOCK_CONTINUE;
@@ -2770,2 +2746,8 @@
-	mlog(0, "unblock inode %llu\n",
-	     (unsigned long long)OCFS2_I(inode)->ip_blkno);
+	/*
+	 * Mark this inode as potentially orphaned. The code in
+	 * ocfs2_delete_inode() will figure out whether it actually
+	 * needs to be freed or not.
+	 */
+	spin_lock(&oi->ip_lock);
+	oi->ip_flags |= OCFS2_INODE_MAYBE_ORPHANED;
+	spin_unlock(&oi->ip_lock);
@@ -2773,3 +2755,15 @@
-	status = ocfs2_do_unblock_meta(inode, requeue);
-	if (status < 0)
-		mlog_errno(status);
+	/*
+	 * Yuck. We need to make sure however that the check of
+	 * OCFS2_LOCK_FREEING and the extra reference are atomic with
+	 * respect to a reference decrement or the setting of that
+	 * flag.
+	 */
+	spin_lock_irqsave(&lockres->l_lock, flags);
+	spin_lock(&dentry_attach_lock);
+	if (!(lockres->l_flags & OCFS2_LOCK_FREEING)
+	    && dl->dl_count) {
+		dl->dl_count++;
+		extra_ref = 1;
+	}
+	spin_unlock(&dentry_attach_lock);
+	spin_unlock_irqrestore(&lockres->l_lock, flags);
@@ -2777,2 +2771 @@
-	mlog(0, "inode %llu, requeue = %d\n",
-	     (unsigned long long)OCFS2_I(inode)->ip_blkno, *requeue);
+	mlog(0, "extra_ref = %d\n", extra_ref);
@@ -2780,3 +2773,7 @@
-	mlog_exit(status);
-	return status;
-}
+	/*
+	 * We have a process waiting on us in ocfs2_dentry_iput(),
+	 * which means we can't have any more outstanding
+	 * aliases. There's no need to do any more work.
+	 */
+	if (!extra_ref)
+		return UNBLOCK_CONTINUE;
@@ -2784,7 +2781,7 @@
-/* Generic unblock function for any lockres whose private data is an
- * ocfs2_super pointer. */
-static int ocfs2_unblock_osb_lock(struct ocfs2_lock_res *lockres,
-				  int *requeue)
-{
-	int status;
-	struct ocfs2_super *osb;
+	spin_lock(&dentry_attach_lock);
+	while (1) {
+		dentry = ocfs2_find_local_alias(dl->dl_inode,
+						dl->dl_parent_blkno, 1);
+		if (!dentry)
+			break;
+		spin_unlock(&dentry_attach_lock);
@@ -2792 +2789,2 @@
-	mlog_entry_void();
+		mlog(0, "d_delete(%.*s);\n", dentry->d_name.len,
+		     dentry->d_name.name);
@@ -2794 +2792,10 @@
-	mlog(0, "Unblock lockres %s\n", lockres->l_name);
+		/*
+		 * The following dcache calls may do an
+		 * iput(). Normally we don't want that from the
+		 * downconverting thread, but in this case it's ok
+		 * because the requesting node already has an
+		 * exclusive lock on the inode, so it can't be queued
+		 * for a downconvert.
+		 */
+		d_delete(dentry);
+		dput(dentry);
@@ -2796 +2803,3 @@
-	osb = ocfs2_lock_res_super(lockres);
+		spin_lock(&dentry_attach_lock);
+	}
+	spin_unlock(&dentry_attach_lock);
@@ -2798,6 +2807,6 @@
-	status = ocfs2_generic_unblock_lock(osb,
-					    lockres,
-					    requeue,
-					    NULL);
-	if (status < 0)
-		mlog_errno(status);
+	/*
+	 * If we are the last holder of this dentry lock, there is no
+	 * reason to downconvert so skip straight to the unlock.
+	 */
+	if (dl->dl_count == 1)
+		return UNBLOCK_STOP_POST;
@@ -2805,2 +2814 @@
-	mlog_exit(status);
-	return status;
+	return UNBLOCK_CONTINUE_POST;
@@ -2813 +2821 @@
-	int requeue = 0;
+	struct ocfs2_unblock_ctl ctl = {0, 0,};
@@ -2824 +2831,0 @@
-	BUG_ON(!lockres->l_ops->unblock);
@@ -2838 +2845 @@
-	status = lockres->l_ops->unblock(lockres, &requeue);
+	status = ocfs2_unblock_lock(osb, lockres, &ctl);
@@ -2844 +2851 @@
-	if (lockres->l_flags & OCFS2_LOCK_FREEING || !requeue) {
+	if (lockres->l_flags & OCFS2_LOCK_FREEING || !ctl.requeue) {
@@ -2850 +2857 @@
-	     requeue ? "yes" : "no");
+	     ctl.requeue ? "yes" : "no");
@@ -2852,0 +2860,4 @@
+	if (ctl.unblock_action != UNBLOCK_CONTINUE
+	    && lockres->l_ops->post_unlock)
+		lockres->l_ops->post_unlock(osb, lockres);
+
@@ -2895,2 +2906,3 @@
-	mlog(level, "version: %u, clusters: %u\n",
-	     be32_to_cpu(lvb->lvb_version), be32_to_cpu(lvb->lvb_iclusters));
+	mlog(level, "version: %u, clusters: %u, generation: 0x%x\n",
+	     lvb->lvb_version, be32_to_cpu(lvb->lvb_iclusters),
+	     be32_to_cpu(lvb->lvb_igeneration));
@@ -2902 +2914 @@
-	     "mtime_packed 0x%llx\n", be16_to_cpu(lvb->lvb_inlink),
+	     "mtime_packed 0x%llx iattr 0x%x\n", be16_to_cpu(lvb->lvb_inlink),
@@ -2905 +2917,2 @@
-	     (long long)be64_to_cpu(lvb->lvb_imtime_packed));
+	     (long long)be64_to_cpu(lvb->lvb_imtime_packed),
+	     be32_to_cpu(lvb->lvb_iattr));
--- ./projects/linux/linux-2.6.19/fs/ocfs2/dlmglue.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/fs/ocfs2/dlmglue.c	2007-02-04 19:44:54.000000000 +0100
@@ -51,0 +52 @@
+#include "file.h"
@@ -772 +773 @@
-	enum dlm_status status;
+	enum dlm_status status = DLM_NORMAL;
@@ -1066,4 +1067,4 @@
-int ocfs2_create_new_lock(struct ocfs2_super *osb,
-			  struct ocfs2_lock_res *lockres,
-			  int ex,
-			  int local)
+static int ocfs2_create_new_lock(struct ocfs2_super *osb,
+				 struct ocfs2_lock_res *lockres,
+				 int ex,
+				 int local)
@@ -1139,0 +1141 @@
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
@@ -1148,0 +1151,3 @@
+	if (ocfs2_mount_local(osb))
+		return 0;
+
@@ -1165,0 +1171 @@
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
@@ -1173 +1179,2 @@
-	ocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);
+	if (!ocfs2_mount_local(osb))
+		ocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);
@@ -1183,0 +1191 @@
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
@@ -1202,0 +1211,3 @@
+	if (ocfs2_mount_local(osb))
+		goto out;
+
@@ -1270,0 +1282 @@
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
@@ -1278 +1290,2 @@
-	if (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)))
+	if (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&
+	    !ocfs2_mount_local(osb))
@@ -1469 +1482 @@
-	struct ocfs2_lock_res *lockres;
+	struct ocfs2_lock_res *lockres = NULL;
@@ -1470,0 +1484 @@
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
@@ -1485 +1499,2 @@
-	lockres = &oi->ip_meta_lockres;
+	if (!ocfs2_mount_local(osb)) {
+		lockres = &oi->ip_meta_lockres;
@@ -1487,2 +1502,3 @@
-	if (!ocfs2_should_refresh_lock_res(lockres))
-		goto bail;
+		if (!ocfs2_should_refresh_lock_res(lockres))
+			goto bail;
+	}
@@ -1498 +1514 @@
-	if (ocfs2_meta_lvb_is_trustable(inode, lockres)) {
+	if (lockres && ocfs2_meta_lvb_is_trustable(inode, lockres)) {
@@ -1545 +1561,2 @@
-	ocfs2_complete_lock_res_refresh(lockres, status);
+	if (lockres)
+		ocfs2_complete_lock_res_refresh(lockres, status);
@@ -1582 +1598,0 @@
-			 struct ocfs2_journal_handle *handle,
@@ -1588 +1604 @@
-	struct ocfs2_lock_res *lockres;
+	struct ocfs2_lock_res *lockres = NULL;
@@ -1609,0 +1626,3 @@
+	if (ocfs2_mount_local(osb))
+		goto local;
+
@@ -1638,0 +1658 @@
+local:
@@ -1647 +1667,2 @@
-		ocfs2_complete_lock_res_refresh(lockres, 0);
+		if (lockres)
+			ocfs2_complete_lock_res_refresh(lockres, 0);
@@ -1671,6 +1691,0 @@
-	if (handle) {
-		status = ocfs2_handle_add_lock(handle, inode);
-		if (status < 0)
-			mlog_errno(status);
-	}
-
@@ -1716 +1730,0 @@
-			      struct ocfs2_journal_handle *handle,
@@ -1723,2 +1737 @@
-	ret = ocfs2_meta_lock_full(inode, handle, ret_bh, ex,
-				   OCFS2_LOCK_NONBLOCK);
+	ret = ocfs2_meta_lock_full(inode, ret_bh, ex, OCFS2_LOCK_NONBLOCK);
@@ -1727 +1740 @@
-		if (ocfs2_meta_lock(inode, handle, ret_bh, ex) == 0)
+		if (ocfs2_meta_lock(inode, ret_bh, ex) == 0)
@@ -1734,0 +1748,38 @@
+int ocfs2_meta_lock_atime(struct inode *inode,
+			  struct vfsmount *vfsmnt,
+			  int *level)
+{
+	int ret;
+
+	mlog_entry_void();
+	ret = ocfs2_meta_lock(inode, NULL, 0);
+	if (ret < 0) {
+		mlog_errno(ret);
+		return ret;
+	}
+
+	/*
+	 * If we should update atime, we will get EX lock,
+	 * otherwise we just get PR lock.
+	 */
+	if (ocfs2_should_update_atime(inode, vfsmnt)) {
+		struct buffer_head *bh = NULL;
+
+		ocfs2_meta_unlock(inode, 0);
+		ret = ocfs2_meta_lock(inode, &bh, 1);
+		if (ret < 0) {
+			mlog_errno(ret);
+			return ret;
+		}
+		*level = 1;
+		if (ocfs2_should_update_atime(inode, vfsmnt))
+			ocfs2_update_inode_atime(inode, bh);
+		if (bh)
+			brelse(bh);
+	} else
+		*level = 0;
+
+	mlog_exit(ret);
+	return ret;
+}
+
@@ -1739,0 +1791 @@
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
@@ -1747 +1799,2 @@
-	if (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)))
+	if (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&
+	    !ocfs2_mount_local(osb))
@@ -1756 +1809 @@
-	int status;
+	int status = 0;
@@ -1766,0 +1820,3 @@
+	if (ocfs2_mount_local(osb))
+		goto bail;
+
@@ -1805 +1861,2 @@
-	ocfs2_cluster_unlock(osb, lockres, level);
+	if (!ocfs2_mount_local(osb))
+		ocfs2_cluster_unlock(osb, lockres, level);
@@ -1815,0 +1873,3 @@
+	if (ocfs2_mount_local(osb))
+		return 0;
+
@@ -1827 +1887,2 @@
-	ocfs2_cluster_unlock(osb, lockres, LKM_EXMODE);
+	if (!ocfs2_mount_local(osb))
+		ocfs2_cluster_unlock(osb, lockres, LKM_EXMODE);
@@ -1841,0 +1903,3 @@
+	if (ocfs2_mount_local(osb))
+		return 0;
+
@@ -1855 +1919,2 @@
-	ocfs2_cluster_unlock(osb, &dl->dl_lockres, level);
+	if (!ocfs2_mount_local(osb))
+		ocfs2_cluster_unlock(osb, &dl->dl_lockres, level);
@@ -2118 +2183 @@
-	int status;
+	int status = 0;
@@ -2120 +2185 @@
-	struct dlm_ctxt *dlm;
+	struct dlm_ctxt *dlm = NULL;
@@ -2123,0 +2189,3 @@
+	if (ocfs2_mount_local(osb))
+		goto local;
+
@@ -2150,0 +2219,3 @@
+	dlm_register_eviction_cb(dlm, &osb->osb_eviction_cb);
+
+local:
@@ -2154,2 +2224,0 @@
-	dlm_register_eviction_cb(dlm, &osb->osb_eviction_cb);
-
@@ -2651,0 +2721,9 @@
+	/*
+	 * We need this before the filemap_fdatawrite() so that it can
+	 * transfer the dirty bit from the PTE to the
+	 * page. Unfortunately this means that even for EX->PR
+	 * downconverts, we'll lose our mappings and have to build
+	 * them up again.
+	 */
+	unmap_mapping_range(mapping, 0, 0, 0);
+
@@ -2659 +2736,0 @@
-		unmap_mapping_range(mapping, 0, 0, 0);
--- ./projects/linux/linux-2.6.21/fs/ocfs2/dlmglue.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/fs/ocfs2/dlmglue.c	2007-07-09 01:32:17.000000000 +0200
@@ -30 +29,0 @@
-#include <linux/smp_lock.h>
@@ -106,0 +106,29 @@
+
+#define mlog_meta_lvb(__level, __lockres) ocfs2_dump_meta_lvb_info(__level, __PRETTY_FUNCTION__, __LINE__, __lockres)
+
+/* This aids in debugging situations where a bad LVB might be involved. */
+static void ocfs2_dump_meta_lvb_info(u64 level,
+				     const char *function,
+				     unsigned int line,
+				     struct ocfs2_lock_res *lockres)
+{
+	struct ocfs2_meta_lvb *lvb = (struct ocfs2_meta_lvb *) lockres->l_lksb.lvb;
+
+	mlog(level, "LVB information for %s (called from %s:%u):\n",
+	     lockres->l_name, function, line);
+	mlog(level, "version: %u, clusters: %u, generation: 0x%x\n",
+	     lvb->lvb_version, be32_to_cpu(lvb->lvb_iclusters),
+	     be32_to_cpu(lvb->lvb_igeneration));
+	mlog(level, "size: %llu, uid %u, gid %u, mode 0x%x\n",
+	     (unsigned long long)be64_to_cpu(lvb->lvb_isize),
+	     be32_to_cpu(lvb->lvb_iuid), be32_to_cpu(lvb->lvb_igid),
+	     be16_to_cpu(lvb->lvb_imode));
+	mlog(level, "nlink %u, atime_packed 0x%llx, ctime_packed 0x%llx, "
+	     "mtime_packed 0x%llx iattr 0x%x\n", be16_to_cpu(lvb->lvb_inlink),
+	     (long long)be64_to_cpu(lvb->lvb_iatime_packed),
+	     (long long)be64_to_cpu(lvb->lvb_ictime_packed),
+	     (long long)be64_to_cpu(lvb->lvb_imtime_packed),
+	     be32_to_cpu(lvb->lvb_iattr));
+}
+
+
@@ -227,0 +256,5 @@
+static struct ocfs2_lock_res_ops ocfs2_inode_open_lops = {
+	.get_osb	= ocfs2_get_inode_osb,
+	.flags		= 0,
+};
+
@@ -232 +265,2 @@
-		lockres->l_type == OCFS2_LOCK_TYPE_RW;
+		lockres->l_type == OCFS2_LOCK_TYPE_RW ||
+		lockres->l_type == OCFS2_LOCK_TYPE_OPEN;
@@ -375,0 +410,3 @@
+		case OCFS2_LOCK_TYPE_OPEN:
+			ops = &ocfs2_inode_open_lops;
+			break;
@@ -1131,0 +1169,6 @@
+	ret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_open_lockres, 0, 0);
+	if (ret) {
+		mlog_errno(ret);
+		goto bail;
+	}
+
@@ -1184,0 +1228,93 @@
+/*
+ * ocfs2_open_lock always get PR mode lock.
+ */
+int ocfs2_open_lock(struct inode *inode)
+{
+	int status = 0;
+	struct ocfs2_lock_res *lockres;
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+
+	BUG_ON(!inode);
+
+	mlog_entry_void();
+
+	mlog(0, "inode %llu take PRMODE open lock\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno);
+
+	if (ocfs2_mount_local(osb))
+		goto out;
+
+	lockres = &OCFS2_I(inode)->ip_open_lockres;
+
+	status = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,
+				    LKM_PRMODE, 0, 0);
+	if (status < 0)
+		mlog_errno(status);
+
+out:
+	mlog_exit(status);
+	return status;
+}
+
+int ocfs2_try_open_lock(struct inode *inode, int write)
+{
+	int status = 0, level;
+	struct ocfs2_lock_res *lockres;
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+
+	BUG_ON(!inode);
+
+	mlog_entry_void();
+
+	mlog(0, "inode %llu try to take %s open lock\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno,
+	     write ? "EXMODE" : "PRMODE");
+
+	if (ocfs2_mount_local(osb))
+		goto out;
+
+	lockres = &OCFS2_I(inode)->ip_open_lockres;
+
+	level = write ? LKM_EXMODE : LKM_PRMODE;
+
+	/*
+	 * The file system may already holding a PRMODE/EXMODE open lock.
+	 * Since we pass LKM_NOQUEUE, the request won't block waiting on
+	 * other nodes and the -EAGAIN will indicate to the caller that
+	 * this inode is still in use.
+	 */
+	status = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres,
+				    level, LKM_NOQUEUE, 0);
+
+out:
+	mlog_exit(status);
+	return status;
+}
+
+/*
+ * ocfs2_open_unlock unlock PR and EX mode open locks.
+ */
+void ocfs2_open_unlock(struct inode *inode)
+{
+	struct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_open_lockres;
+	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+
+	mlog_entry_void();
+
+	mlog(0, "inode %llu drop open lock\n",
+	     (unsigned long long)OCFS2_I(inode)->ip_blkno);
+
+	if (ocfs2_mount_local(osb))
+		goto out;
+
+	if(lockres->l_ro_holders)
+		ocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,
+				     LKM_PRMODE);
+	if(lockres->l_ex_holders)
+		ocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres,
+				     LKM_EXMODE);
+
+out:
+	mlog_exit_void();
+}
+
@@ -1390,2 +1526 @@
-		inode->i_blocks =
-			ocfs2_align_bytes_to_sectors(i_size_read(inode));
+		inode->i_blocks = ocfs2_inode_sector_count(inode);
@@ -1482 +1617 @@
-	struct ocfs2_lock_res *lockres = NULL;
+	struct ocfs2_lock_res *lockres = &oi->ip_meta_lockres;
@@ -1487,0 +1623,3 @@
+	if (ocfs2_mount_local(osb))
+		goto bail;
+
@@ -1499,6 +1637,2 @@
-	if (!ocfs2_mount_local(osb)) {
-		lockres = &oi->ip_meta_lockres;
-
-		if (!ocfs2_should_refresh_lock_res(lockres))
-			goto bail;
-	}
+	if (!ocfs2_should_refresh_lock_res(lockres))
+		goto bail;
@@ -1510,2 +1643,0 @@
-	/* will do nothing for inode types that don't use the extent
-	 * map (directories, bitmap files, etc) */
@@ -1514 +1646 @@
-	if (lockres && ocfs2_meta_lvb_is_trustable(inode, lockres)) {
+	if (ocfs2_meta_lvb_is_trustable(inode, lockres)) {
@@ -1561,2 +1693 @@
-	if (lockres)
-		ocfs2_complete_lock_res_refresh(lockres, status);
+	ocfs2_complete_lock_res_refresh(lockres, status);
@@ -1633 +1763,0 @@
-	acquired = 0;
@@ -2461 +2591 @@
-			      &OCFS2_I(inode)->ip_data_lockres);
+			      &OCFS2_I(inode)->ip_open_lockres);
@@ -2467,0 +2598,7 @@
+			      &OCFS2_I(inode)->ip_data_lockres);
+	if (err < 0)
+		mlog_errno(err);
+	if (err < 0 && !status)
+		status = err;
+
+	err = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),
@@ -2972,25 +3108,0 @@
-
-/* This aids in debugging situations where a bad LVB might be involved. */
-void ocfs2_dump_meta_lvb_info(u64 level,
-			      const char *function,
-			      unsigned int line,
-			      struct ocfs2_lock_res *lockres)
-{
-	struct ocfs2_meta_lvb *lvb = (struct ocfs2_meta_lvb *) lockres->l_lksb.lvb;
-
-	mlog(level, "LVB information for %s (called from %s:%u):\n",
-	     lockres->l_name, function, line);
-	mlog(level, "version: %u, clusters: %u, generation: 0x%x\n",
-	     lvb->lvb_version, be32_to_cpu(lvb->lvb_iclusters),
-	     be32_to_cpu(lvb->lvb_igeneration));
-	mlog(level, "size: %llu, uid %u, gid %u, mode 0x%x\n",
-	     (unsigned long long)be64_to_cpu(lvb->lvb_isize),
-	     be32_to_cpu(lvb->lvb_iuid), be32_to_cpu(lvb->lvb_igid),
-	     be16_to_cpu(lvb->lvb_imode));
-	mlog(level, "nlink %u, atime_packed 0x%llx, ctime_packed 0x%llx, "
-	     "mtime_packed 0x%llx iattr 0x%x\n", be16_to_cpu(lvb->lvb_inlink),
-	     (long long)be64_to_cpu(lvb->lvb_iatime_packed),
-	     (long long)be64_to_cpu(lvb->lvb_ictime_packed),
-	     (long long)be64_to_cpu(lvb->lvb_imtime_packed),
-	     be32_to_cpu(lvb->lvb_iattr));
-}
--- ./projects/linux/linux-2.6.22/fs/ocfs2/dlmglue.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/fs/ocfs2/dlmglue.c	2007-10-09 22:31:38.000000000 +0200
@@ -603,2 +603 @@
-	struct list_head *pos, *tmp;
-	struct ocfs2_mask_waiter *mw;
+	struct ocfs2_mask_waiter *mw, *tmp;
@@ -610,2 +609 @@
-	list_for_each_safe(pos, tmp, &lockres->l_mask_waiters) {
-		mw = list_entry(pos, struct ocfs2_mask_waiter, mw_item);
+	list_for_each_entry_safe(mw, tmp, &lockres->l_mask_waiters, mw_item) {
--- ./projects/linux/linux-2.6.23/fs/ocfs2/dlmglue.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/fs/ocfs2/dlmglue.c	2008-01-24 23:58:37.000000000 +0100
@@ -673 +673 @@
-	BUG_ON((!lockres->l_flags & OCFS2_LOCK_BUSY));
+	BUG_ON((!(lockres->l_flags & OCFS2_LOCK_BUSY)));
@@ -983,12 +982,0 @@
-	if (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {
-		/* lock has not been created yet. */
-		spin_unlock_irqrestore(&lockres->l_lock, flags);
-
-		ret = ocfs2_lock_create(osb, lockres, LKM_NLMODE, 0);
-		if (ret < 0) {
-			mlog_errno(ret);
-			goto out;
-		}
-		goto again;
-	}
-
@@ -1009 +997,8 @@
-		lockres->l_action = OCFS2_AST_CONVERT;
+		if (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {
+			lockres->l_action = OCFS2_AST_ATTACH;
+			lkm_flags &= ~LKM_CONVERT;
+		} else {
+			lockres->l_action = OCFS2_AST_CONVERT;
+			lkm_flags |= LKM_CONVERT;
+		}
+
@@ -1024 +1019 @@
-				 lkm_flags|LKM_CONVERT,
+				 lkm_flags,
@@ -1484,0 +1480 @@
+	lvb->lvb_idynfeatures = cpu_to_be16(oi->ip_dyn_features);
@@ -1517,0 +1514 @@
+	oi->ip_dyn_features = be16_to_cpu(lvb->lvb_idynfeatures);
--- ./projects/linux/linux-2.6.24/fs/ocfs2/dlmglue.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/fs/ocfs2/dlmglue.c	2008-04-17 04:49:44.000000000 +0200
@@ -45,0 +46 @@
+#include "ocfs2_lockingver.h"
@@ -58 +58,0 @@
-#include "vote.h"
@@ -71,0 +72 @@
+static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres);
@@ -156,4 +157,4 @@
-	 * Optionally called in the downconvert (or "vote") thread
-	 * after a successful downconvert. The lockres will not be
-	 * referenced after this callback is called, so it is safe to
-	 * free memory, etc.
+	 * Optionally called in the downconvert thread after a
+	 * successful downconvert. The lockres will not be referenced
+	 * after this callback is called, so it is safe to free
+	 * memory, etc.
@@ -228 +229 @@
-static struct ocfs2_lock_res_ops ocfs2_inode_meta_lops = {
+static struct ocfs2_lock_res_ops ocfs2_inode_inode_lops = {
@@ -232,5 +232,0 @@
-	.flags		= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,
-};
-
-static struct ocfs2_lock_res_ops ocfs2_inode_data_lops = {
-	.get_osb	= ocfs2_get_inode_osb,
@@ -238 +234 @@
-	.flags		= 0,
+	.flags		= LOCK_TYPE_REQUIRES_REFRESH|LOCK_TYPE_USES_LVB,
@@ -260,0 +257,30 @@
+static struct ocfs2_lock_res_ops ocfs2_flock_lops = {
+	.get_osb	= ocfs2_get_file_osb,
+	.flags		= 0,
+};
+
+/*
+ * This is the filesystem locking protocol version.
+ *
+ * Whenever the filesystem does new things with locks (adds or removes a
+ * lock, orders them differently, does different things underneath a lock),
+ * the version must be changed.  The protocol is negotiated when joining
+ * the dlm domain.  A node may join the domain if its major version is
+ * identical to all other nodes and its minor version is greater than
+ * or equal to all other nodes.  When its minor version is greater than
+ * the other nodes, it will run at the minor version specified by the
+ * other nodes.
+ *
+ * If a locking change is made that will not be compatible with older
+ * versions, the major number must be increased and the minor version set
+ * to zero.  If a change merely adds a behavior that can be disabled when
+ * speaking to older versions, the minor version must be increased.  If a
+ * change adds a fully backwards compatible change (eg, LVB changes that
+ * are just ignored by older versions), the version does not need to be
+ * updated.
+ */
+const struct dlm_protocol_version ocfs2_locking_protocol = {
+	.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,
+	.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,
+};
+
@@ -264 +289,0 @@
-		lockres->l_type == OCFS2_LOCK_TYPE_DATA ||
@@ -313,3 +338,4 @@
-static void ocfs2_vote_on_unlock(struct ocfs2_super *osb,
-				 struct ocfs2_lock_res *lockres);
-static int ocfs2_meta_lock_update(struct inode *inode,
+static int ocfs2_downconvert_thread(void *arg);
+static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,
+					struct ocfs2_lock_res *lockres);
+static int ocfs2_inode_lock_update(struct inode *inode,
@@ -318,0 +345,11 @@
+static void ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,
+				      int new_level);
+static int ocfs2_downconvert_lock(struct ocfs2_super *osb,
+				  struct ocfs2_lock_res *lockres,
+				  int new_level,
+				  int lvb);
+static int ocfs2_prepare_cancel_convert(struct ocfs2_super *osb,
+				        struct ocfs2_lock_res *lockres);
+static int ocfs2_cancel_convert(struct ocfs2_super *osb,
+				struct ocfs2_lock_res *lockres);
+
@@ -405,4 +442 @@
-			ops = &ocfs2_inode_meta_lops;
-			break;
-		case OCFS2_LOCK_TYPE_DATA:
-			ops = &ocfs2_inode_data_lops;
+			ops = &ocfs2_inode_inode_lops;
@@ -430,0 +465,7 @@
+static struct ocfs2_super *ocfs2_get_file_osb(struct ocfs2_lock_res *lockres)
+{
+	struct ocfs2_file_private *fp = lockres->l_priv;
+
+	return OCFS2_SB(fp->fp_file->f_mapping->host->i_sb);
+}
+
@@ -510,0 +552,15 @@
+void ocfs2_file_lock_res_init(struct ocfs2_lock_res *lockres,
+			      struct ocfs2_file_private *fp)
+{
+	struct inode *inode = fp->fp_file->f_mapping->host;
+	struct ocfs2_inode_info *oi = OCFS2_I(inode);
+
+	ocfs2_lock_res_init_once(lockres);
+	ocfs2_build_lock_name(OCFS2_LOCK_TYPE_FLOCK, oi->ip_blkno,
+			      inode->i_generation, lockres->l_name);
+	ocfs2_lock_res_init_common(OCFS2_SB(inode->i_sb), lockres,
+				   OCFS2_LOCK_TYPE_FLOCK, &ocfs2_flock_lops,
+				   fp);
+	lockres->l_flags |= OCFS2_LOCK_NOCACHE;
+}
+
@@ -726,0 +783,7 @@
+	/*
+	 * We can skip the bast for locks which don't enable caching -
+	 * they'll be dropped at the earliest possible time anyway.
+	 */
+	if (lockres->l_flags & OCFS2_LOCK_NOCACHE)
+		return;
+
@@ -735 +798 @@
-	ocfs2_kick_vote_thread(osb);
+	ocfs2_wake_downconvert_thread(osb);
@@ -937,0 +1001,15 @@
+static int ocfs2_wait_for_mask_interruptible(struct ocfs2_mask_waiter *mw,
+					     struct ocfs2_lock_res *lockres)
+{
+	int ret;
+
+	ret = wait_for_completion_interruptible(&mw->mw_complete);
+	if (ret)
+		lockres_remove_mask_waiter(lockres, mw);
+	else
+		ret = mw->mw_status;
+	/* Re-arm the completion in case we want to wait on it again */
+	INIT_COMPLETION(mw->mw_complete);
+	return ret;
+}
+
@@ -1092 +1170 @@
-	ocfs2_vote_on_unlock(osb, lockres);
+	ocfs2_downconvert_on_unlock(osb, lockres);
@@ -1150,7 +1228 @@
-	ret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_meta_lockres, 1, 0);
-	if (ret) {
-		mlog_errno(ret);
-		goto bail;
-	}
-
-	ret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_data_lockres, 1, 1);
+	ret = ocfs2_create_new_lock(osb, &OCFS2_I(inode)->ip_inode_lockres, 1, 0);
@@ -1314,3 +1386,2 @@
-int ocfs2_data_lock_full(struct inode *inode,
-			 int write,
-			 int arg_flags)
+static int ocfs2_flock_handle_signal(struct ocfs2_lock_res *lockres,
+				     int level)
@@ -1318,3 +1389,4 @@
-	int status = 0, level;
-	struct ocfs2_lock_res *lockres;
-	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
+	int ret;
+	struct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);
+	unsigned long flags;
+	struct ocfs2_mask_waiter mw;
@@ -1322 +1394 @@
-	BUG_ON(!inode);
+	ocfs2_init_mask_waiter(&mw);
@@ -1324 +1396,15 @@
-	mlog_entry_void();
+retry_cancel:
+	spin_lock_irqsave(&lockres->l_lock, flags);
+	if (lockres->l_flags & OCFS2_LOCK_BUSY) {
+		ret = ocfs2_prepare_cancel_convert(osb, lockres);
+		if (ret) {
+			spin_unlock_irqrestore(&lockres->l_lock, flags);
+			ret = ocfs2_cancel_convert(osb, lockres);
+			if (ret < 0) {
+				mlog_errno(ret);
+				goto out;
+			}
+			goto retry_cancel;
+		}
+		lockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);
+		spin_unlock_irqrestore(&lockres->l_lock, flags);
@@ -1326,3 +1412,3 @@
-	mlog(0, "inode %llu take %s DATA lock\n",
-	     (unsigned long long)OCFS2_I(inode)->ip_blkno,
-	     write ? "EXMODE" : "PRMODE");
+		ocfs2_wait_for_mask(&mw);
+		goto retry_cancel;
+	}
@@ -1330,6 +1416,72 @@
-	/* We'll allow faking a readonly data lock for
-	 * rodevices. */
-	if (ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb))) {
-		if (write) {
-			status = -EROFS;
-			mlog_errno(status);
+	ret = -ERESTARTSYS;
+	/*
+	 * We may still have gotten the lock, in which case there's no
+	 * point to restarting the syscall.
+	 */
+	if (lockres->l_level == level)
+		ret = 0;
+
+	mlog(0, "Cancel returning %d. flags: 0x%lx, level: %d, act: %d\n", ret,
+	     lockres->l_flags, lockres->l_level, lockres->l_action);
+
+	spin_unlock_irqrestore(&lockres->l_lock, flags);
+
+out:
+	return ret;
+}
+
+/*
+ * ocfs2_file_lock() and ocfs2_file_unlock() map to a single pair of
+ * flock() calls. The locking approach this requires is sufficiently
+ * different from all other cluster lock types that we implement a
+ * seperate path to the "low-level" dlm calls. In particular:
+ *
+ * - No optimization of lock levels is done - we take at exactly
+ *   what's been requested.
+ *
+ * - No lock caching is employed. We immediately downconvert to
+ *   no-lock at unlock time. This also means flock locks never go on
+ *   the blocking list).
+ *
+ * - Since userspace can trivially deadlock itself with flock, we make
+ *   sure to allow cancellation of a misbehaving applications flock()
+ *   request.
+ *
+ * - Access to any flock lockres doesn't require concurrency, so we
+ *   can simplify the code by requiring the caller to guarantee
+ *   serialization of dlmglue flock calls.
+ */
+int ocfs2_file_lock(struct file *file, int ex, int trylock)
+{
+	int ret, level = ex ? LKM_EXMODE : LKM_PRMODE;
+	unsigned int lkm_flags = trylock ? LKM_NOQUEUE : 0;
+	unsigned long flags;
+	struct ocfs2_file_private *fp = file->private_data;
+	struct ocfs2_lock_res *lockres = &fp->fp_flock;
+	struct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);
+	struct ocfs2_mask_waiter mw;
+
+	ocfs2_init_mask_waiter(&mw);
+
+	if ((lockres->l_flags & OCFS2_LOCK_BUSY) ||
+	    (lockres->l_level > LKM_NLMODE)) {
+		mlog(ML_ERROR,
+		     "File lock \"%s\" has busy or locked state: flags: 0x%lx, "
+		     "level: %u\n", lockres->l_name, lockres->l_flags,
+		     lockres->l_level);
+		return -EINVAL;
+	}
+
+	spin_lock_irqsave(&lockres->l_lock, flags);
+	if (!(lockres->l_flags & OCFS2_LOCK_ATTACHED)) {
+		lockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);
+		spin_unlock_irqrestore(&lockres->l_lock, flags);
+
+		/*
+		 * Get the lock at NLMODE to start - that way we
+		 * can cancel the upconvert request if need be.
+		 */
+		ret = ocfs2_lock_create(osb, lockres, LKM_NLMODE, 0);
+		if (ret < 0) {
+			mlog_errno(ret);
+			goto out;
@@ -1337 +1489,7 @@
-		goto out;
+
+		ret = ocfs2_wait_for_mask(&mw);
+		if (ret) {
+			mlog_errno(ret);
+			goto out;
+		}
+		spin_lock_irqsave(&lockres->l_lock, flags);
@@ -1340,2 +1498,4 @@
-	if (ocfs2_mount_local(osb))
-		goto out;
+	lockres->l_action = OCFS2_AST_CONVERT;
+	lkm_flags |= LKM_CONVERT;
+	lockres->l_requested = level;
+	lockres_or_flags(lockres, OCFS2_LOCK_BUSY);
@@ -1343 +1503,2 @@
-	lockres = &OCFS2_I(inode)->ip_data_lockres;
+	lockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);
+	spin_unlock_irqrestore(&lockres->l_lock, flags);
@@ -1345 +1506,10 @@
-	level = write ? LKM_EXMODE : LKM_PRMODE;
+	ret = dlmlock(osb->dlm, level, &lockres->l_lksb, lkm_flags,
+		      lockres->l_name, OCFS2_LOCK_ID_MAX_LEN - 1,
+		      ocfs2_locking_ast, lockres, ocfs2_blocking_ast);
+	if (ret != DLM_NORMAL) {
+		if (trylock && ret == DLM_NOTQUEUED)
+			ret = -EAGAIN;
+		else {
+			ocfs2_log_dlm_error("dlmlock", ret, lockres);
+			ret = -EINVAL;
+		}
@@ -1347,4 +1517,24 @@
-	status = ocfs2_cluster_lock(OCFS2_SB(inode->i_sb), lockres, level,
-				    0, arg_flags);
-	if (status < 0 && status != -EAGAIN)
-		mlog_errno(status);
+		ocfs2_recover_from_dlm_error(lockres, 1);
+		lockres_remove_mask_waiter(lockres, &mw);
+		goto out;
+	}
+
+	ret = ocfs2_wait_for_mask_interruptible(&mw, lockres);
+	if (ret == -ERESTARTSYS) {
+		/*
+		 * Userspace can cause deadlock itself with
+		 * flock(). Current behavior locally is to allow the
+		 * deadlock, but abort the system call if a signal is
+		 * received. We follow this example, otherwise a
+		 * poorly written program could sit in kernel until
+		 * reboot.
+		 *
+		 * Handling this is a bit more complicated for Ocfs2
+		 * though. We can't exit this function with an
+		 * outstanding lock request, so a cancel convert is
+		 * required. We intentionally overwrite 'ret' - if the
+		 * cancel fails and the lock was granted, it's easier
+		 * to just bubble sucess back up to the user.
+		 */
+		ret = ocfs2_flock_handle_signal(lockres, level);
+	}
@@ -1353,2 +1543,4 @@
-	mlog_exit(status);
-	return status;
+
+	mlog(0, "Lock: \"%s\" ex: %d, trylock: %d, returns: %d\n",
+	     lockres->l_name, ex, trylock, ret);
+	return ret;
@@ -1357,4 +1549 @@
-/* see ocfs2_meta_lock_with_page() */
-int ocfs2_data_lock_with_page(struct inode *inode,
-			      int write,
-			      struct page *page)
+void ocfs2_file_unlock(struct file *file)
@@ -1362,0 +1552,5 @@
+	unsigned long flags;
+	struct ocfs2_file_private *fp = file->private_data;
+	struct ocfs2_lock_res *lockres = &fp->fp_flock;
+	struct ocfs2_super *osb = OCFS2_SB(file->f_mapping->host->i_sb);
+	struct ocfs2_mask_waiter mw;
@@ -1364,6 +1558,27 @@
-	ret = ocfs2_data_lock_full(inode, write, OCFS2_LOCK_NONBLOCK);
-	if (ret == -EAGAIN) {
-		unlock_page(page);
-		if (ocfs2_data_lock(inode, write) == 0)
-			ocfs2_data_unlock(inode, write);
-		ret = AOP_TRUNCATED_PAGE;
+	ocfs2_init_mask_waiter(&mw);
+
+	if (!(lockres->l_flags & OCFS2_LOCK_ATTACHED))
+		return;
+
+	if (lockres->l_level == LKM_NLMODE)
+		return;
+
+	mlog(0, "Unlock: \"%s\" flags: 0x%lx, level: %d, act: %d\n",
+	     lockres->l_name, lockres->l_flags, lockres->l_level,
+	     lockres->l_action);
+
+	spin_lock_irqsave(&lockres->l_lock, flags);
+	/*
+	 * Fake a blocking ast for the downconvert code.
+	 */
+	lockres_or_flags(lockres, OCFS2_LOCK_BLOCKED);
+	lockres->l_blocking = LKM_EXMODE;
+
+	ocfs2_prepare_downconvert(lockres, LKM_NLMODE);
+	lockres_add_mask_waiter(lockres, &mw, OCFS2_LOCK_BUSY, 0);
+	spin_unlock_irqrestore(&lockres->l_lock, flags);
+
+	ret = ocfs2_downconvert_lock(osb, lockres, LKM_NLMODE, 0);
+	if (ret) {
+		mlog_errno(ret);
+		return;
@@ -1372 +1587,3 @@
-	return ret;
+	ret = ocfs2_wait_for_mask(&mw);
+	if (ret)
+		mlog_errno(ret);
@@ -1375,2 +1592,2 @@
-static void ocfs2_vote_on_unlock(struct ocfs2_super *osb,
-				 struct ocfs2_lock_res *lockres)
+static void ocfs2_downconvert_on_unlock(struct ocfs2_super *osb,
+					struct ocfs2_lock_res *lockres)
@@ -1383 +1600 @@
-	 * the vote thread * pre-emptively when we reach a release
+	 * the downconvert thread * pre-emptively when we reach a release
@@ -1401,21 +1618 @@
-		ocfs2_kick_vote_thread(osb);
-
-	mlog_exit_void();
-}
-
-void ocfs2_data_unlock(struct inode *inode,
-		       int write)
-{
-	int level = write ? LKM_EXMODE : LKM_PRMODE;
-	struct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_data_lockres;
-	struct ocfs2_super *osb = OCFS2_SB(inode->i_sb);
-
-	mlog_entry_void();
-
-	mlog(0, "inode %llu drop %s DATA lock\n",
-	     (unsigned long long)OCFS2_I(inode)->ip_blkno,
-	     write ? "EXMODE" : "PRMODE");
-
-	if (!ocfs2_is_hard_readonly(OCFS2_SB(inode->i_sb)) &&
-	    !ocfs2_mount_local(osb))
-		ocfs2_cluster_unlock(OCFS2_SB(inode->i_sb), lockres, level);
+		ocfs2_wake_downconvert_thread(osb);
@@ -1445 +1642 @@
- * values is supposed to be blocked in ocfs2_meta_lock right now. */
+ * values is supposed to be blocked in ocfs2_inode_lock right now. */
@@ -1449 +1646 @@
-	struct ocfs2_lock_res *lockres = &oi->ip_meta_lockres;
+	struct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;
@@ -1499 +1696 @@
-	struct ocfs2_lock_res *lockres = &oi->ip_meta_lockres;
+	struct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;
@@ -1607 +1804 @@
-static int ocfs2_meta_lock_update(struct inode *inode,
+static int ocfs2_inode_lock_update(struct inode *inode,
@@ -1612 +1809 @@
-	struct ocfs2_lock_res *lockres = &oi->ip_meta_lockres;
+	struct ocfs2_lock_res *lockres = &oi->ip_inode_lockres;
@@ -1724 +1921 @@
-int ocfs2_meta_lock_full(struct inode *inode,
+int ocfs2_inode_lock_full(struct inode *inode,
@@ -1759 +1956 @@
-	lockres = &OCFS2_I(inode)->ip_meta_lockres;
+	lockres = &OCFS2_I(inode)->ip_inode_lockres;
@@ -1798 +1995 @@
-	 * not. ocfs2_meta_lock_update definitely wants one in, but
+	 * not. ocfs2_inode_lock_update definitely wants one in, but
@@ -1802 +1999 @@
-	status = ocfs2_meta_lock_update(inode, &local_bh);
+	status = ocfs2_inode_lock_update(inode, &local_bh);
@@ -1824 +2021 @@
-			ocfs2_meta_unlock(inode, ex);
+			ocfs2_inode_unlock(inode, ex);
@@ -1835,3 +2032,3 @@
- * This is working around a lock inversion between tasks acquiring DLM locks
- * while holding a page lock and the vote thread which blocks dlm lock acquiry
- * while acquiring page locks.
+ * This is working around a lock inversion between tasks acquiring DLM
+ * locks while holding a page lock and the downconvert thread which
+ * blocks dlm lock acquiry while acquiring page locks.
@@ -1843,5 +2040,6 @@
- * The DLM is called such that it returns -EAGAIN if it would have blocked
- * waiting for the vote thread.  In that case we unlock our page so the vote
- * thread can make progress.  Once we've done this we have to return
- * AOP_TRUNCATED_PAGE so the aop method that called us can bubble that back up
- * into the VFS who will then immediately retry the aop call.
+ * The DLM is called such that it returns -EAGAIN if it would have
+ * blocked waiting for the downconvert thread.  In that case we unlock
+ * our page so the downconvert thread can make progress.  Once we've
+ * done this we have to return AOP_TRUNCATED_PAGE so the aop method
+ * that called us can bubble that back up into the VFS who will then
+ * immediately retry the aop call.
@@ -1855 +2053 @@
-int ocfs2_meta_lock_with_page(struct inode *inode,
+int ocfs2_inode_lock_with_page(struct inode *inode,
@@ -1862 +2060 @@
-	ret = ocfs2_meta_lock_full(inode, ret_bh, ex, OCFS2_LOCK_NONBLOCK);
+	ret = ocfs2_inode_lock_full(inode, ret_bh, ex, OCFS2_LOCK_NONBLOCK);
@@ -1865,2 +2063,2 @@
-		if (ocfs2_meta_lock(inode, ret_bh, ex) == 0)
-			ocfs2_meta_unlock(inode, ex);
+		if (ocfs2_inode_lock(inode, ret_bh, ex) == 0)
+			ocfs2_inode_unlock(inode, ex);
@@ -1873 +2071 @@
-int ocfs2_meta_lock_atime(struct inode *inode,
+int ocfs2_inode_lock_atime(struct inode *inode,
@@ -1880 +2078 @@
-	ret = ocfs2_meta_lock(inode, NULL, 0);
+	ret = ocfs2_inode_lock(inode, NULL, 0);
@@ -1893,2 +2091,2 @@
-		ocfs2_meta_unlock(inode, 0);
-		ret = ocfs2_meta_lock(inode, &bh, 1);
+		ocfs2_inode_unlock(inode, 0);
+		ret = ocfs2_inode_lock(inode, &bh, 1);
@@ -1911 +2109 @@
-void ocfs2_meta_unlock(struct inode *inode,
+void ocfs2_inode_unlock(struct inode *inode,
@@ -1915 +2113 @@
-	struct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_meta_lockres;
+	struct ocfs2_lock_res *lockres = &OCFS2_I(inode)->ip_inode_lockres;
@@ -2214 +2412 @@
-static struct seq_operations ocfs2_dlm_seq_ops = {
+static const struct seq_operations ocfs2_dlm_seq_ops = {
@@ -2323,5 +2521,5 @@
-	/* launch vote thread */
-	osb->vote_task = kthread_run(ocfs2_vote_thread, osb, "ocfs2vote");
-	if (IS_ERR(osb->vote_task)) {
-		status = PTR_ERR(osb->vote_task);
-		osb->vote_task = NULL;
+	/* launch downconvert thread */
+	osb->dc_task = kthread_run(ocfs2_downconvert_thread, osb, "ocfs2dc");
+	if (IS_ERR(osb->dc_task)) {
+		status = PTR_ERR(osb->dc_task);
+		osb->dc_task = NULL;
@@ -2337 +2535,2 @@
-	dlm = dlm_register_domain(osb->uuid_str, dlm_key);
+	dlm = dlm_register_domain(osb->uuid_str, dlm_key,
+				  &osb->osb_locking_proto);
@@ -2356,2 +2555,2 @@
-		if (osb->vote_task)
-			kthread_stop(osb->vote_task);
+		if (osb->dc_task)
+			kthread_stop(osb->dc_task);
@@ -2372,3 +2571,3 @@
-	if (osb->vote_task) {
-		kthread_stop(osb->vote_task);
-		osb->vote_task = NULL;
+	if (osb->dc_task) {
+		kthread_stop(osb->dc_task);
+		osb->dc_task = NULL;
@@ -2530 +2729 @@
- * being dequeued from the vote thread before we can consider
+ * being dequeued from the downconvert thread before we can consider
@@ -2593,8 +2792 @@
-			      &OCFS2_I(inode)->ip_data_lockres);
-	if (err < 0)
-		mlog_errno(err);
-	if (err < 0 && !status)
-		status = err;
-
-	err = ocfs2_drop_lock(OCFS2_SB(inode->i_sb),
-			      &OCFS2_I(inode)->ip_meta_lockres);
+			      &OCFS2_I(inode)->ip_inode_lockres);
@@ -2852,0 +3045,3 @@
+	if (!S_ISREG(inode->i_mode))
+		goto out;
+
@@ -2877,0 +3073 @@
+out:
@@ -2906 +3102 @@
- * happens in the vote thread, but we could choose to simplify the
+ * happens in the downconvert thread, but we could choose to simplify the
@@ -3026,2 +3222,2 @@
-void ocfs2_process_blocked_lock(struct ocfs2_super *osb,
-				struct ocfs2_lock_res *lockres)
+static void ocfs2_process_blocked_lock(struct ocfs2_super *osb,
+				       struct ocfs2_lock_res *lockres)
@@ -3045 +3241 @@
-	 * the vote thread was processing other things. A lock can
+	 * the downconvert thread was processing other things. A lock can
@@ -3094 +3290 @@
-	spin_lock(&osb->vote_task_lock);
+	spin_lock(&osb->dc_task_lock);
@@ -3100 +3296 @@
-	spin_unlock(&osb->vote_task_lock);
+	spin_unlock(&osb->dc_task_lock);
@@ -3103,0 +3300,91 @@
+
+static void ocfs2_downconvert_thread_do_work(struct ocfs2_super *osb)
+{
+	unsigned long processed;
+	struct ocfs2_lock_res *lockres;
+
+	mlog_entry_void();
+
+	spin_lock(&osb->dc_task_lock);
+	/* grab this early so we know to try again if a state change and
+	 * wake happens part-way through our work  */
+	osb->dc_work_sequence = osb->dc_wake_sequence;
+
+	processed = osb->blocked_lock_count;
+	while (processed) {
+		BUG_ON(list_empty(&osb->blocked_lock_list));
+
+		lockres = list_entry(osb->blocked_lock_list.next,
+				     struct ocfs2_lock_res, l_blocked_list);
+		list_del_init(&lockres->l_blocked_list);
+		osb->blocked_lock_count--;
+		spin_unlock(&osb->dc_task_lock);
+
+		BUG_ON(!processed);
+		processed--;
+
+		ocfs2_process_blocked_lock(osb, lockres);
+
+		spin_lock(&osb->dc_task_lock);
+	}
+	spin_unlock(&osb->dc_task_lock);
+
+	mlog_exit_void();
+}
+
+static int ocfs2_downconvert_thread_lists_empty(struct ocfs2_super *osb)
+{
+	int empty = 0;
+
+	spin_lock(&osb->dc_task_lock);
+	if (list_empty(&osb->blocked_lock_list))
+		empty = 1;
+
+	spin_unlock(&osb->dc_task_lock);
+	return empty;
+}
+
+static int ocfs2_downconvert_thread_should_wake(struct ocfs2_super *osb)
+{
+	int should_wake = 0;
+
+	spin_lock(&osb->dc_task_lock);
+	if (osb->dc_work_sequence != osb->dc_wake_sequence)
+		should_wake = 1;
+	spin_unlock(&osb->dc_task_lock);
+
+	return should_wake;
+}
+
+static int ocfs2_downconvert_thread(void *arg)
+{
+	int status = 0;
+	struct ocfs2_super *osb = arg;
+
+	/* only quit once we've been asked to stop and there is no more
+	 * work available */
+	while (!(kthread_should_stop() &&
+		ocfs2_downconvert_thread_lists_empty(osb))) {
+
+		wait_event_interruptible(osb->dc_event,
+					 ocfs2_downconvert_thread_should_wake(osb) ||
+					 kthread_should_stop());
+
+		mlog(0, "downconvert_thread: awoken\n");
+
+		ocfs2_downconvert_thread_do_work(osb);
+	}
+
+	osb->dc_task = NULL;
+	return status;
+}
+
+void ocfs2_wake_downconvert_thread(struct ocfs2_super *osb)
+{
+	spin_lock(&osb->dc_task_lock);
+	/* make sure the voting thread gets a swipe at whatever changes
+	 * the caller may have made to the voting state */
+	osb->dc_wake_sequence++;
+	spin_unlock(&osb->dc_task_lock);
+	wake_up(&osb->dc_event);
+}
--- ./projects/linux/linux-2.6.25/fs/ocfs2/dlmglue.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/fs/ocfs2/dlmglue.c	2008-07-13 23:51:29.000000000 +0200
@@ -30 +29,0 @@
-#include <linux/crc32.h>
@@ -36,6 +34,0 @@
-#include <cluster/heartbeat.h>
-#include <cluster/nodemanager.h>
-#include <cluster/tcp.h>
-
-#include <dlm/dlmapi.h>
-
@@ -55,0 +49 @@
+#include "stackglue.h"
@@ -116 +110,2 @@
-	struct ocfs2_meta_lvb *lvb = (struct ocfs2_meta_lvb *) lockres->l_lksb.lvb;
+	struct ocfs2_meta_lvb *lvb =
+		(struct ocfs2_meta_lvb *)ocfs2_dlm_lvb(&lockres->l_lksb);
@@ -262,25 +256,0 @@
-/*
- * This is the filesystem locking protocol version.
- *
- * Whenever the filesystem does new things with locks (adds or removes a
- * lock, orders them differently, does different things underneath a lock),
- * the version must be changed.  The protocol is negotiated when joining
- * the dlm domain.  A node may join the domain if its major version is
- * identical to all other nodes and its minor version is greater than
- * or equal to all other nodes.  When its minor version is greater than
- * the other nodes, it will run at the minor version specified by the
- * other nodes.
- *
- * If a locking change is made that will not be compatible with older
- * versions, the major number must be increased and the minor version set
- * to zero.  If a change merely adds a behavior that can be disabled when
- * speaking to older versions, the minor version must be increased.  If a
- * change adds a fully backwards compatible change (eg, LVB changes that
- * are just ignored by older versions), the version does not need to be
- * updated.
- */
-const struct dlm_protocol_version ocfs2_locking_protocol = {
-	.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,
-	.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,
-};
-
@@ -319 +289 @@
-			     int dlm_flags);
+			     u32 dlm_flags);
@@ -333,4 +303,3 @@
-#define ocfs2_log_dlm_error(_func, _stat, _lockres) do {	\
-	mlog(ML_ERROR, "Dlm error \"%s\" while calling %s on "	\
-		"resource %s: %s\n", dlm_errname(_stat), _func,	\
-		_lockres->l_name, dlm_errmsg(_stat));		\
+#define ocfs2_log_dlm_error(_func, _err, _lockres) do {			\
+	mlog(ML_ERROR, "DLM error %d while calling %s on resource %s\n", \
+	     _err, _func, _lockres->l_name);				\
@@ -345,2 +314,2 @@
-static void ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,
-				      int new_level);
+static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,
+					      int new_level);
@@ -350 +319,2 @@
-				  int lvb);
+				  int lvb,
+				  unsigned int generation);
@@ -409,3 +379,3 @@
-	res->l_level         = LKM_IVMODE;
-	res->l_requested     = LKM_IVMODE;
-	res->l_blocking      = LKM_IVMODE;
+	res->l_level         = DLM_LOCK_IV;
+	res->l_requested     = DLM_LOCK_IV;
+	res->l_blocking      = DLM_LOCK_IV;
@@ -607 +577 @@
-	case LKM_EXMODE:
+	case DLM_LOCK_EX:
@@ -610 +580 @@
-	case LKM_PRMODE:
+	case DLM_LOCK_PR:
@@ -628 +598 @@
-	case LKM_EXMODE:
+	case DLM_LOCK_EX:
@@ -632 +602 @@
-	case LKM_PRMODE:
+	case DLM_LOCK_PR:
@@ -647 +617 @@
-	int new_level = LKM_EXMODE;
+	int new_level = DLM_LOCK_EX;
@@ -649,4 +619,4 @@
-	if (level == LKM_EXMODE)
-		new_level = LKM_NLMODE;
-	else if (level == LKM_PRMODE)
-		new_level = LKM_PRMODE;
+	if (level == DLM_LOCK_EX)
+		new_level = DLM_LOCK_NL;
+	else if (level == DLM_LOCK_PR)
+		new_level = DLM_LOCK_PR;
@@ -691 +661 @@
-	BUG_ON(lockres->l_blocking <= LKM_NLMODE);
+	BUG_ON(lockres->l_blocking <= DLM_LOCK_NL);
@@ -696 +666 @@
-		lockres->l_blocking = LKM_NLMODE;
+		lockres->l_blocking = DLM_LOCK_NL;
@@ -715 +685 @@
-	if (lockres->l_level == LKM_NLMODE &&
+	if (lockres->l_level == DLM_LOCK_NL &&
@@ -732 +702 @@
-	if (lockres->l_requested > LKM_NLMODE &&
+	if (lockres->l_requested > DLM_LOCK_NL &&
@@ -769,0 +740,107 @@
+/*
+ * OCFS2_LOCK_PENDING and l_pending_gen.
+ *
+ * Why does OCFS2_LOCK_PENDING exist?  To close a race between setting
+ * OCFS2_LOCK_BUSY and calling ocfs2_dlm_lock().  See ocfs2_unblock_lock()
+ * for more details on the race.
+ *
+ * OCFS2_LOCK_PENDING closes the race quite nicely.  However, it introduces
+ * a race on itself.  In o2dlm, we can get the ast before ocfs2_dlm_lock()
+ * returns.  The ast clears OCFS2_LOCK_BUSY, and must therefore clear
+ * OCFS2_LOCK_PENDING at the same time.  When ocfs2_dlm_lock() returns,
+ * the caller is going to try to clear PENDING again.  If nothing else is
+ * happening, __lockres_clear_pending() sees PENDING is unset and does
+ * nothing.
+ *
+ * But what if another path (eg downconvert thread) has just started a
+ * new locking action?  The other path has re-set PENDING.  Our path
+ * cannot clear PENDING, because that will re-open the original race
+ * window.
+ *
+ * [Example]
+ *
+ * ocfs2_meta_lock()
+ *  ocfs2_cluster_lock()
+ *   set BUSY
+ *   set PENDING
+ *   drop l_lock
+ *   ocfs2_dlm_lock()
+ *    ocfs2_locking_ast()		ocfs2_downconvert_thread()
+ *     clear PENDING			 ocfs2_unblock_lock()
+ *					  take_l_lock
+ *					  !BUSY
+ *					  ocfs2_prepare_downconvert()
+ *					   set BUSY
+ *					   set PENDING
+ *					  drop l_lock
+ *   take l_lock
+ *   clear PENDING
+ *   drop l_lock
+ *			<window>
+ *					  ocfs2_dlm_lock()
+ *
+ * So as you can see, we now have a window where l_lock is not held,
+ * PENDING is not set, and ocfs2_dlm_lock() has not been called.
+ *
+ * The core problem is that ocfs2_cluster_lock() has cleared the PENDING
+ * set by ocfs2_prepare_downconvert().  That wasn't nice.
+ *
+ * To solve this we introduce l_pending_gen.  A call to
+ * lockres_clear_pending() will only do so when it is passed a generation
+ * number that matches the lockres.  lockres_set_pending() will return the
+ * current generation number.  When ocfs2_cluster_lock() goes to clear
+ * PENDING, it passes the generation it got from set_pending().  In our
+ * example above, the generation numbers will *not* match.  Thus,
+ * ocfs2_cluster_lock() will not clear the PENDING set by
+ * ocfs2_prepare_downconvert().
+ */
+
+/* Unlocked version for ocfs2_locking_ast() */
+static void __lockres_clear_pending(struct ocfs2_lock_res *lockres,
+				    unsigned int generation,
+				    struct ocfs2_super *osb)
+{
+	assert_spin_locked(&lockres->l_lock);
+
+	/*
+	 * The ast and locking functions can race us here.  The winner
+	 * will clear pending, the loser will not.
+	 */
+	if (!(lockres->l_flags & OCFS2_LOCK_PENDING) ||
+	    (lockres->l_pending_gen != generation))
+		return;
+
+	lockres_clear_flags(lockres, OCFS2_LOCK_PENDING);
+	lockres->l_pending_gen++;
+
+	/*
+	 * The downconvert thread may have skipped us because we
+	 * were PENDING.  Wake it up.
+	 */
+	if (lockres->l_flags & OCFS2_LOCK_BLOCKED)
+		ocfs2_wake_downconvert_thread(osb);
+}
+
+/* Locked version for callers of ocfs2_dlm_lock() */
+static void lockres_clear_pending(struct ocfs2_lock_res *lockres,
+				  unsigned int generation,
+				  struct ocfs2_super *osb)
+{
+	unsigned long flags;
+
+	spin_lock_irqsave(&lockres->l_lock, flags);
+	__lockres_clear_pending(lockres, generation, osb);
+	spin_unlock_irqrestore(&lockres->l_lock, flags);
+}
+
+static unsigned int lockres_set_pending(struct ocfs2_lock_res *lockres)
+{
+	assert_spin_locked(&lockres->l_lock);
+	BUG_ON(!(lockres->l_flags & OCFS2_LOCK_BUSY));
+
+	lockres_or_flags(lockres, OCFS2_LOCK_PENDING);
+
+	return lockres->l_pending_gen;
+}
+
+
@@ -777 +854 @@
-	BUG_ON(level <= LKM_NLMODE);
+	BUG_ON(level <= DLM_LOCK_NL);
@@ -804 +881 @@
-	struct dlm_lockstatus *lksb = &lockres->l_lksb;
+	struct ocfs2_super *osb = ocfs2_get_lockres_osb(lockres);
@@ -805,0 +883 @@
+	int status;
@@ -809,3 +887,10 @@
-	if (lksb->status != DLM_NORMAL) {
-		mlog(ML_ERROR, "lockres %s: lksb status value of %u!\n",
-		     lockres->l_name, lksb->status);
+	status = ocfs2_dlm_lock_status(&lockres->l_lksb);
+
+	if (status == -EAGAIN) {
+		lockres_clear_flags(lockres, OCFS2_LOCK_BUSY);
+		goto out;
+	}
+
+	if (status) {
+		mlog(ML_ERROR, "lockres %s: lksb status value of %d!\n",
+		     lockres->l_name, status);
@@ -834 +919 @@
-
+out:
@@ -838,0 +924,12 @@
+	/* Did we try to cancel this lock?  Clear that state */
+	if (lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT)
+		lockres->l_unlock_action = OCFS2_UNLOCK_INVALID;
+
+	/*
+	 * We may have beaten the locking functions here.  We certainly
+	 * know that dlm_lock() has been called :-)
+	 * Because we can't have two lock calls in flight at once, we
+	 * can use lockres->l_pending_gen.
+	 */
+	__lockres_clear_pending(lockres, lockres->l_pending_gen,  osb);
+
@@ -868 +965 @@
-			     int dlm_flags)
+			     u32 dlm_flags)
@@ -871 +967,0 @@
-	enum dlm_status status = DLM_NORMAL;
@@ -872,0 +969 @@
+	unsigned int gen;
@@ -876 +973 @@
-	mlog(0, "lock %s, level = %d, flags = %d\n", lockres->l_name, level,
+	mlog(0, "lock %s, level = %d, flags = %u\n", lockres->l_name, level,
@@ -888,0 +986 @@
+	gen = lockres_set_pending(lockres);
@@ -891,12 +989,10 @@
-	status = dlmlock(osb->dlm,
-			 level,
-			 &lockres->l_lksb,
-			 dlm_flags,
-			 lockres->l_name,
-			 OCFS2_LOCK_ID_MAX_LEN - 1,
-			 ocfs2_locking_ast,
-			 lockres,
-			 ocfs2_blocking_ast);
-	if (status != DLM_NORMAL) {
-		ocfs2_log_dlm_error("dlmlock", status, lockres);
-		ret = -EINVAL;
+	ret = ocfs2_dlm_lock(osb->cconn,
+			     level,
+			     &lockres->l_lksb,
+			     dlm_flags,
+			     lockres->l_name,
+			     OCFS2_LOCK_ID_MAX_LEN - 1,
+			     lockres);
+	lockres_clear_pending(lockres, gen, osb);
+	if (ret) {
+		ocfs2_log_dlm_error("ocfs2_dlm_lock", ret, lockres);
@@ -906 +1002 @@
-	mlog(0, "lock %s, successfull return from dlmlock\n", lockres->l_name);
+	mlog(0, "lock %s, return from ocfs2_dlm_lock\n", lockres->l_name);
@@ -1019 +1115 @@
-			      int lkm_flags,
+			      u32 lkm_flags,
@@ -1023 +1118,0 @@
-	enum dlm_status status;
@@ -1026,0 +1122,2 @@
+	unsigned int gen;
+	int noqueue_attempted = 0;
@@ -1033 +1130 @@
-		lkm_flags |= LKM_VALBLK;
+		lkm_flags |= DLM_LKF_VALBLK;
@@ -1070,0 +1168,7 @@
+		if (noqueue_attempted > 0) {
+			ret = -EAGAIN;
+			goto unlock;
+		}
+		if (lkm_flags & DLM_LKF_NOQUEUE)
+			noqueue_attempted = 1;
+
@@ -1077 +1181 @@
-			lkm_flags &= ~LKM_CONVERT;
+			lkm_flags &= ~DLM_LKF_CONVERT;
@@ -1080 +1184 @@
-			lkm_flags |= LKM_CONVERT;
+			lkm_flags |= DLM_LKF_CONVERT;
@@ -1084,0 +1189 @@
+		gen = lockres_set_pending(lockres);
@@ -1087,2 +1192,2 @@
-		BUG_ON(level == LKM_IVMODE);
-		BUG_ON(level == LKM_NLMODE);
+		BUG_ON(level == DLM_LOCK_IV);
+		BUG_ON(level == DLM_LOCK_NL);
@@ -1094,17 +1199,13 @@
-		status = dlmlock(osb->dlm,
-				 level,
-				 &lockres->l_lksb,
-				 lkm_flags,
-				 lockres->l_name,
-				 OCFS2_LOCK_ID_MAX_LEN - 1,
-				 ocfs2_locking_ast,
-				 lockres,
-				 ocfs2_blocking_ast);
-		if (status != DLM_NORMAL) {
-			if ((lkm_flags & LKM_NOQUEUE) &&
-			    (status == DLM_NOTQUEUED))
-				ret = -EAGAIN;
-			else {
-				ocfs2_log_dlm_error("dlmlock", status,
-						    lockres);
-				ret = -EINVAL;
+		ret = ocfs2_dlm_lock(osb->cconn,
+				     level,
+				     &lockres->l_lksb,
+				     lkm_flags,
+				     lockres->l_name,
+				     OCFS2_LOCK_ID_MAX_LEN - 1,
+				     lockres);
+		lockres_clear_pending(lockres, gen, osb);
+		if (ret) {
+			if (!(lkm_flags & DLM_LKF_NOQUEUE) ||
+			    (ret != -EAGAIN)) {
+				ocfs2_log_dlm_error("ocfs2_dlm_lock",
+						    ret, lockres);
@@ -1116 +1217 @@
-		mlog(0, "lock %s, successfull return from dlmlock\n",
+		mlog(0, "lock %s, successfull return from ocfs2_dlm_lock\n",
@@ -1180 +1281 @@
-	int level =  ex ? LKM_EXMODE : LKM_PRMODE;
+	int level =  ex ? DLM_LOCK_EX : DLM_LOCK_PR;
@@ -1182 +1283 @@
-	int lkm_flags = local ? LKM_LOCAL : 0;
+	u32 lkm_flags = local ? DLM_LKF_LOCAL : 0;
@@ -1225 +1326 @@
-	 * We don't want to use LKM_LOCAL on a meta data lock as they
+	 * We don't want to use DLM_LKF_LOCAL on a meta data lock as they
@@ -1264 +1365 @@
-	level = write ? LKM_EXMODE : LKM_PRMODE;
+	level = write ? DLM_LOCK_EX : DLM_LOCK_PR;
@@ -1277 +1378 @@
-	int level = write ? LKM_EXMODE : LKM_PRMODE;
+	int level = write ? DLM_LOCK_EX : DLM_LOCK_PR;
@@ -1315 +1416 @@
-				    LKM_PRMODE, 0, 0);
+				    DLM_LOCK_PR, 0, 0);
@@ -1343 +1444 @@
-	level = write ? LKM_EXMODE : LKM_PRMODE;
+	level = write ? DLM_LOCK_EX : DLM_LOCK_PR;
@@ -1347 +1448 @@
-	 * Since we pass LKM_NOQUEUE, the request won't block waiting on
+	 * Since we pass DLM_LKF_NOQUEUE, the request won't block waiting on
@@ -1352 +1453 @@
-				    level, LKM_NOQUEUE, 0);
+				    level, DLM_LKF_NOQUEUE, 0);
@@ -1377 +1478 @@
-				     LKM_PRMODE);
+				     DLM_LOCK_PR);
@@ -1380 +1481 @@
-				     LKM_EXMODE);
+				     DLM_LOCK_EX);
@@ -1456,2 +1557,2 @@
-	int ret, level = ex ? LKM_EXMODE : LKM_PRMODE;
-	unsigned int lkm_flags = trylock ? LKM_NOQUEUE : 0;
+	int ret, level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;
+	unsigned int lkm_flags = trylock ? DLM_LKF_NOQUEUE : 0;
@@ -1467 +1568 @@
-	    (lockres->l_level > LKM_NLMODE)) {
+	    (lockres->l_level > DLM_LOCK_NL)) {
@@ -1484 +1585 @@
-		ret = ocfs2_lock_create(osb, lockres, LKM_NLMODE, 0);
+		ret = ocfs2_lock_create(osb, lockres, DLM_LOCK_NL, 0);
@@ -1499 +1600 @@
-	lkm_flags |= LKM_CONVERT;
+	lkm_flags |= DLM_LKF_CONVERT;
@@ -1506,8 +1607,6 @@
-	ret = dlmlock(osb->dlm, level, &lockres->l_lksb, lkm_flags,
-		      lockres->l_name, OCFS2_LOCK_ID_MAX_LEN - 1,
-		      ocfs2_locking_ast, lockres, ocfs2_blocking_ast);
-	if (ret != DLM_NORMAL) {
-		if (trylock && ret == DLM_NOTQUEUED)
-			ret = -EAGAIN;
-		else {
-			ocfs2_log_dlm_error("dlmlock", ret, lockres);
+	ret = ocfs2_dlm_lock(osb->cconn, level, &lockres->l_lksb, lkm_flags,
+			     lockres->l_name, OCFS2_LOCK_ID_MAX_LEN - 1,
+			     lockres);
+	if (ret) {
+		if (!trylock || (ret != -EAGAIN)) {
+			ocfs2_log_dlm_error("ocfs2_dlm_lock", ret, lockres);
@@ -1539,0 +1639,4 @@
+	} else if (!ret && (level > lockres->l_level)) {
+		/* Trylock failed asynchronously */
+		BUG_ON(!trylock);
+		ret = -EAGAIN;
@@ -1551,0 +1655 @@
+	unsigned int gen;
@@ -1563 +1667 @@
-	if (lockres->l_level == LKM_NLMODE)
+	if (lockres->l_level == DLM_LOCK_NL)
@@ -1575 +1679 @@
-	lockres->l_blocking = LKM_EXMODE;
+	lockres->l_blocking = DLM_LOCK_EX;
@@ -1577 +1681 @@
-	ocfs2_prepare_downconvert(lockres, LKM_NLMODE);
+	gen = ocfs2_prepare_downconvert(lockres, DLM_LOCK_NL);
@@ -1581 +1685 @@
-	ret = ocfs2_downconvert_lock(osb, lockres, LKM_NLMODE, 0);
+	ret = ocfs2_downconvert_lock(osb, lockres, DLM_LOCK_NL, 0, gen);
@@ -1604 +1708 @@
-		case LKM_EXMODE:
+		case DLM_LOCK_EX:
@@ -1608 +1712 @@
-		case LKM_PRMODE:
+		case DLM_LOCK_PR:
@@ -1651 +1755 @@
-	lvb = (struct ocfs2_meta_lvb *) lockres->l_lksb.lvb;
+	lvb = (struct ocfs2_meta_lvb *)ocfs2_dlm_lvb(&lockres->l_lksb);
@@ -1703 +1807 @@
-	lvb = (struct ocfs2_meta_lvb *) lockres->l_lksb.lvb;
+	lvb = (struct ocfs2_meta_lvb *)ocfs2_dlm_lvb(&lockres->l_lksb);
@@ -1738 +1842,2 @@
-	struct ocfs2_meta_lvb *lvb = (struct ocfs2_meta_lvb *) lockres->l_lksb.lvb;
+	struct ocfs2_meta_lvb *lvb =
+		(struct ocfs2_meta_lvb *)ocfs2_dlm_lvb(&lockres->l_lksb);
@@ -1926 +2031,2 @@
-	int status, level, dlm_flags, acquired;
+	int status, level, acquired;
+	u32 dlm_flags;
@@ -1953,2 +2059 @@
-		wait_event(osb->recovery_event,
-			   ocfs2_node_map_is_empty(osb, &osb->recovery_map));
+		ocfs2_wait_for_recovery(osb);
@@ -1957 +2062 @@
-	level = ex ? LKM_EXMODE : LKM_PRMODE;
+	level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;
@@ -1960 +2065 @@
-		dlm_flags |= LKM_NOQUEUE;
+		dlm_flags |= DLM_LKF_NOQUEUE;
@@ -1977,2 +2082 @@
-		wait_event(osb->recovery_event,
-			   ocfs2_node_map_is_empty(osb, &osb->recovery_map));
+		ocfs2_wait_for_recovery(osb);
@@ -2112 +2216 @@
-	int level = ex ? LKM_EXMODE : LKM_PRMODE;
+	int level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;
@@ -2133 +2237 @@
-	int level = ex ? LKM_EXMODE : LKM_PRMODE;
+	int level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;
@@ -2135,2 +2238,0 @@
-	struct buffer_head *bh;
-	struct ocfs2_slot_info *si = osb->slot_info;
@@ -2162,5 +2264 @@
-		bh = si->si_bh;
-		status = ocfs2_read_block(osb, bh->b_blocknr, &bh, 0,
-					  si->si_inode);
-		if (status == 0)
-			ocfs2_update_slot_info(si);
+		status = ocfs2_refresh_slot_info(osb);
@@ -2181 +2279 @@
-	int level = ex ? LKM_EXMODE : LKM_PRMODE;
+	int level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;
@@ -2199 +2297 @@
-	status = ocfs2_cluster_lock(osb, lockres, LKM_EXMODE, 0, 0);
+	status = ocfs2_cluster_lock(osb, lockres, DLM_LOCK_EX, 0, 0);
@@ -2211 +2309 @@
-		ocfs2_cluster_unlock(osb, lockres, LKM_EXMODE);
+		ocfs2_cluster_unlock(osb, lockres, DLM_LOCK_EX);
@@ -2217 +2315 @@
-	int level = ex ? LKM_EXMODE : LKM_PRMODE;
+	int level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;
@@ -2238 +2336 @@
-	int level = ex ? LKM_EXMODE : LKM_PRMODE;
+	int level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;
@@ -2403 +2501 @@
-	lvb = lockres->l_lksb.lvb;
+	lvb = ocfs2_dlm_lvb(&lockres->l_lksb);
@@ -2507,2 +2605 @@
-	u32 dlm_key;
-	struct dlm_ctxt *dlm = NULL;
+	struct ocfs2_cluster_connection *conn = NULL;
@@ -2512 +2609,2 @@
-	if (ocfs2_mount_local(osb))
+	if (ocfs2_mount_local(osb)) {
+		osb->node_num = 0;
@@ -2513,0 +2612 @@
+	}
@@ -2530,4 +2628,0 @@
-	/* used by the dlm code to make message headers unique, each
-	 * node in this domain must agree on this. */
-	dlm_key = crc32_le(0, osb->uuid_str, strlen(osb->uuid_str));
-
@@ -2535,4 +2630,6 @@
-	dlm = dlm_register_domain(osb->uuid_str, dlm_key,
-				  &osb->osb_locking_proto);
-	if (IS_ERR(dlm)) {
-		status = PTR_ERR(dlm);
+	status = ocfs2_cluster_connect(osb->osb_cluster_stack,
+				       osb->uuid_str,
+				       strlen(osb->uuid_str),
+				       ocfs2_do_node_down, osb,
+				       &conn);
+	if (status) {
@@ -2543 +2640,8 @@
-	dlm_register_eviction_cb(dlm, &osb->osb_eviction_cb);
+	status = ocfs2_cluster_this_node(&osb->node_num);
+	if (status < 0) {
+		mlog_errno(status);
+		mlog(ML_ERROR,
+		     "could not find this host's node number\n");
+		ocfs2_cluster_disconnect(conn, 0);
+		goto bail;
+	}
@@ -2549 +2653 @@
-	osb->dlm = dlm;
+	osb->cconn = conn;
@@ -2563 +2667,2 @@
-void ocfs2_dlm_shutdown(struct ocfs2_super *osb)
+void ocfs2_dlm_shutdown(struct ocfs2_super *osb,
+			int hangup_pending)
@@ -2567,2 +2671,0 @@
-	dlm_unregister_eviction_cb(&osb->osb_eviction_cb);
-
@@ -2570,0 +2674,6 @@
+	/*
+	 * Now that we have dropped all locks and ocfs2_dismount_volume()
+	 * has disabled recovery, the DLM won't be talking to us.  It's
+	 * safe to tear things down before disconnecting the cluster.
+	 */
+
@@ -2579,2 +2688,2 @@
-	dlm_unregister_domain(osb->dlm);
-	osb->dlm = NULL;
+	ocfs2_cluster_disconnect(osb->cconn, hangup_pending);
+	osb->cconn = NULL;
@@ -2587 +2696 @@
-static void ocfs2_unlock_ast(void *opaque, enum dlm_status status)
+static void ocfs2_unlock_ast(void *opaque, int error)
@@ -2598,18 +2707,3 @@
-	/* We tried to cancel a convert request, but it was already
-	 * granted. All we want to do here is clear our unlock
-	 * state. The wake_up call done at the bottom is redundant
-	 * (ocfs2_prepare_cancel_convert doesn't sleep on this) but doesn't
-	 * hurt anything anyway */
-	if (status == DLM_CANCELGRANT &&
-	    lockres->l_unlock_action == OCFS2_UNLOCK_CANCEL_CONVERT) {
-		mlog(0, "Got cancelgrant for %s\n", lockres->l_name);
-
-		/* We don't clear the busy flag in this case as it
-		 * should have been cleared by the ast which the dlm
-		 * has called. */
-		goto complete_unlock;
-	}
-
-	if (status != DLM_NORMAL) {
-		mlog(ML_ERROR, "Dlm passes status %d for lock %s, "
-		     "unlock_action %d\n", status, lockres->l_name,
+	if (error) {
+		mlog(ML_ERROR, "Dlm passes error %d for lock %s, "
+		     "unlock_action %d\n", error, lockres->l_name,
@@ -2627 +2721 @@
-		lockres->l_level = LKM_IVMODE;
+		lockres->l_level = DLM_LOCK_IV;
@@ -2634 +2727,0 @@
-complete_unlock:
@@ -2646 +2739 @@
-	enum dlm_status status;
+	int ret;
@@ -2648 +2741 @@
-	int lkm_flags = 0;
+	u32 lkm_flags = 0;
@@ -2655 +2748 @@
-		lkm_flags |= LKM_VALBLK;
+		lkm_flags |= DLM_LKF_VALBLK;
@@ -2681 +2774 @@
-		    lockres->l_level == LKM_EXMODE &&
+		    lockres->l_level == DLM_LOCK_EX &&
@@ -2710,4 +2803,4 @@
-	status = dlmunlock(osb->dlm, &lockres->l_lksb, lkm_flags,
-			   ocfs2_unlock_ast, lockres);
-	if (status != DLM_NORMAL) {
-		ocfs2_log_dlm_error("dlmunlock", status, lockres);
+	ret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb, lkm_flags,
+			       lockres);
+	if (ret) {
+		ocfs2_log_dlm_error("ocfs2_dlm_unlock", ret, lockres);
@@ -2715 +2808 @@
-		dlm_print_one_lock(lockres->l_lksb.lockid);
+		ocfs2_dlm_dump_lksb(&lockres->l_lksb);
@@ -2718 +2811 @@
-	mlog(0, "lock %s, successfull return from dlmunlock\n",
+	mlog(0, "lock %s, successfull return from ocfs2_dlm_unlock\n",
@@ -2809,2 +2902,2 @@
-static void ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,
-				      int new_level)
+static unsigned int ocfs2_prepare_downconvert(struct ocfs2_lock_res *lockres,
+					      int new_level)
@@ -2814 +2907 @@
-	BUG_ON(lockres->l_blocking <= LKM_NLMODE);
+	BUG_ON(lockres->l_blocking <= DLM_LOCK_NL);
@@ -2817 +2910 @@
-		mlog(ML_ERROR, "lockres->l_level (%u) <= new_level (%u)\n",
+		mlog(ML_ERROR, "lockres->l_level (%d) <= new_level (%d)\n",
@@ -2827,0 +2921 @@
+	return lockres_set_pending(lockres);
@@ -2833 +2927,2 @@
-				  int lvb)
+				  int lvb,
+				  unsigned int generation)
@@ -2835,2 +2930,2 @@
-	int ret, dlm_flags = LKM_CONVERT;
-	enum dlm_status status;
+	int ret;
+	u32 dlm_flags = DLM_LKF_CONVERT;
@@ -2841 +2936 @@
-		dlm_flags |= LKM_VALBLK;
+		dlm_flags |= DLM_LKF_VALBLK;
@@ -2843,12 +2938,10 @@
-	status = dlmlock(osb->dlm,
-			 new_level,
-			 &lockres->l_lksb,
-			 dlm_flags,
-			 lockres->l_name,
-			 OCFS2_LOCK_ID_MAX_LEN - 1,
-			 ocfs2_locking_ast,
-			 lockres,
-			 ocfs2_blocking_ast);
-	if (status != DLM_NORMAL) {
-		ocfs2_log_dlm_error("dlmlock", status, lockres);
-		ret = -EINVAL;
+	ret = ocfs2_dlm_lock(osb->cconn,
+			     new_level,
+			     &lockres->l_lksb,
+			     dlm_flags,
+			     lockres->l_name,
+			     OCFS2_LOCK_ID_MAX_LEN - 1,
+			     lockres);
+	lockres_clear_pending(lockres, generation, osb);
+	if (ret) {
+		ocfs2_log_dlm_error("ocfs2_dlm_lock", ret, lockres);
@@ -2865 +2958 @@
-/* returns 1 when the caller should unlock and call dlmunlock */
+/* returns 1 when the caller should unlock and call ocfs2_dlm_unlock */
@@ -2901 +2993,0 @@
-	enum dlm_status status;
@@ -2906,9 +2998,4 @@
-	ret = 0;
-	status = dlmunlock(osb->dlm,
-			   &lockres->l_lksb,
-			   LKM_CANCEL,
-			   ocfs2_unlock_ast,
-			   lockres);
-	if (status != DLM_NORMAL) {
-		ocfs2_log_dlm_error("dlmunlock", status, lockres);
-		ret = -EINVAL;
+	ret = ocfs2_dlm_unlock(osb->cconn, &lockres->l_lksb,
+			       DLM_LKF_CANCEL, lockres);
+	if (ret) {
+		ocfs2_log_dlm_error("ocfs2_dlm_unlock", ret, lockres);
@@ -2918 +3005 @@
-	mlog(0, "lock %s return from dlmunlock\n", lockres->l_name);
+	mlog(0, "lock %s return from ocfs2_dlm_unlock\n", lockres->l_name);
@@ -2932,0 +3020 @@
+	unsigned int gen;
@@ -2941,0 +3030,26 @@
+		/* XXX
+		 * This is a *big* race.  The OCFS2_LOCK_PENDING flag
+		 * exists entirely for one reason - another thread has set
+		 * OCFS2_LOCK_BUSY, but has *NOT* yet called dlm_lock().
+		 *
+		 * If we do ocfs2_cancel_convert() before the other thread
+		 * calls dlm_lock(), our cancel will do nothing.  We will
+		 * get no ast, and we will have no way of knowing the
+		 * cancel failed.  Meanwhile, the other thread will call
+		 * into dlm_lock() and wait...forever.
+		 *
+		 * Why forever?  Because another node has asked for the
+		 * lock first; that's why we're here in unblock_lock().
+		 *
+		 * The solution is OCFS2_LOCK_PENDING.  When PENDING is
+		 * set, we just requeue the unblock.  Only when the other
+		 * thread has called dlm_lock() and cleared PENDING will
+		 * we then cancel their request.
+		 *
+		 * All callers of dlm_lock() must set OCFS2_DLM_PENDING
+		 * at the same time they set OCFS2_DLM_BUSY.  They must
+		 * clear OCFS2_DLM_PENDING after dlm_lock() returns.
+		 */
+		if (lockres->l_flags & OCFS2_LOCK_PENDING)
+			goto leave_requeue;
+
@@ -2955 +3069 @@
-	if ((lockres->l_blocking == LKM_EXMODE)
+	if ((lockres->l_blocking == DLM_LOCK_EX)
@@ -2961 +3075 @@
-	if (lockres->l_blocking == LKM_PRMODE &&
+	if (lockres->l_blocking == DLM_LOCK_PR &&
@@ -3008 +3122 @@
-		if (lockres->l_level == LKM_EXMODE)
+		if (lockres->l_level == DLM_LOCK_EX)
@@ -3021 +3135 @@
-	ocfs2_prepare_downconvert(lockres, new_level);
+	gen = ocfs2_prepare_downconvert(lockres, new_level);
@@ -3023 +3137,3 @@
-	ret = ocfs2_downconvert_lock(osb, lockres, new_level, set_lvb);
+	ret = ocfs2_downconvert_lock(osb, lockres, new_level, set_lvb,
+				     gen);
+
@@ -3062 +3178 @@
-	if (blocking == LKM_EXMODE) {
+	if (blocking == DLM_LOCK_EX) {
@@ -3083,2 +3199,2 @@
-	BUG_ON(new_level != LKM_NLMODE && new_level != LKM_PRMODE);
-	BUG_ON(lockres->l_level != LKM_EXMODE && !checkpointed);
+	BUG_ON(new_level != DLM_LOCK_NL && new_level != DLM_LOCK_PR);
+	BUG_ON(lockres->l_level != DLM_LOCK_EX && !checkpointed);
@@ -3148 +3264 @@
-	if (blocking == LKM_PRMODE)
+	if (blocking == DLM_LOCK_PR)
@@ -3221,0 +3338,39 @@
+/*
+ * This is the filesystem locking protocol.  It provides the lock handling
+ * hooks for the underlying DLM.  It has a maximum version number.
+ * The version number allows interoperability with systems running at
+ * the same major number and an equal or smaller minor number.
+ *
+ * Whenever the filesystem does new things with locks (adds or removes a
+ * lock, orders them differently, does different things underneath a lock),
+ * the version must be changed.  The protocol is negotiated when joining
+ * the dlm domain.  A node may join the domain if its major version is
+ * identical to all other nodes and its minor version is greater than
+ * or equal to all other nodes.  When its minor version is greater than
+ * the other nodes, it will run at the minor version specified by the
+ * other nodes.
+ *
+ * If a locking change is made that will not be compatible with older
+ * versions, the major number must be increased and the minor version set
+ * to zero.  If a change merely adds a behavior that can be disabled when
+ * speaking to older versions, the minor version must be increased.  If a
+ * change adds a fully backwards compatible change (eg, LVB changes that
+ * are just ignored by older versions), the version does not need to be
+ * updated.
+ */
+static struct ocfs2_locking_protocol lproto = {
+	.lp_max_version = {
+		.pv_major = OCFS2_LOCKING_PROTOCOL_MAJOR,
+		.pv_minor = OCFS2_LOCKING_PROTOCOL_MINOR,
+	},
+	.lp_lock_ast		= ocfs2_locking_ast,
+	.lp_blocking_ast	= ocfs2_blocking_ast,
+	.lp_unlock_ast		= ocfs2_unlock_ast,
+};
+
+void ocfs2_set_locking_protocol(void)
+{
+	ocfs2_stack_glue_set_locking_protocol(&lproto);
+}
+
+
--- ./projects/linux/linux-2.6.26/fs/ocfs2/dlmglue.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/fs/ocfs2/dlmglue.c	2008-10-10 00:13:53.000000000 +0200
@@ -33,0 +34 @@
+#include <linux/time.h>
@@ -61,0 +63,3 @@
+#ifdef CONFIG_OCFS2_FS_STATS
+	unsigned long long 	mw_lock_start;
+#endif
@@ -368,0 +373,69 @@
+#ifdef CONFIG_OCFS2_FS_STATS
+static void ocfs2_init_lock_stats(struct ocfs2_lock_res *res)
+{
+	res->l_lock_num_prmode = 0;
+	res->l_lock_num_prmode_failed = 0;
+	res->l_lock_total_prmode = 0;
+	res->l_lock_max_prmode = 0;
+	res->l_lock_num_exmode = 0;
+	res->l_lock_num_exmode_failed = 0;
+	res->l_lock_total_exmode = 0;
+	res->l_lock_max_exmode = 0;
+	res->l_lock_refresh = 0;
+}
+
+static void ocfs2_update_lock_stats(struct ocfs2_lock_res *res, int level,
+				    struct ocfs2_mask_waiter *mw, int ret)
+{
+	unsigned long long *num, *sum;
+	unsigned int *max, *failed;
+	struct timespec ts = current_kernel_time();
+	unsigned long long time = timespec_to_ns(&ts) - mw->mw_lock_start;
+
+	if (level == LKM_PRMODE) {
+		num = &res->l_lock_num_prmode;
+		sum = &res->l_lock_total_prmode;
+		max = &res->l_lock_max_prmode;
+		failed = &res->l_lock_num_prmode_failed;
+	} else if (level == LKM_EXMODE) {
+		num = &res->l_lock_num_exmode;
+		sum = &res->l_lock_total_exmode;
+		max = &res->l_lock_max_exmode;
+		failed = &res->l_lock_num_exmode_failed;
+	} else
+		return;
+
+	(*num)++;
+	(*sum) += time;
+	if (time > *max)
+		*max = time;
+	if (ret)
+		(*failed)++;
+}
+
+static inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)
+{
+	lockres->l_lock_refresh++;
+}
+
+static inline void ocfs2_init_start_time(struct ocfs2_mask_waiter *mw)
+{
+	struct timespec ts = current_kernel_time();
+	mw->mw_lock_start = timespec_to_ns(&ts);
+}
+#else
+static inline void ocfs2_init_lock_stats(struct ocfs2_lock_res *res)
+{
+}
+static inline void ocfs2_update_lock_stats(struct ocfs2_lock_res *res,
+			   int level, struct ocfs2_mask_waiter *mw, int ret)
+{
+}
+static inline void ocfs2_track_lock_refresh(struct ocfs2_lock_res *lockres)
+{
+}
+static inline void ocfs2_init_start_time(struct ocfs2_mask_waiter *mw)
+{
+}
+#endif
+
@@ -387,0 +461,2 @@
+
+	ocfs2_init_lock_stats(res);
@@ -1050,0 +1126 @@
+	ocfs2_init_start_time(mw);
@@ -1256,0 +1333 @@
+	ocfs2_update_lock_stats(lockres, level, &mw, ret);
@@ -1985,0 +2063 @@
+		ocfs2_track_lock_refresh(lockres);
@@ -2269,0 +2348 @@
+		ocfs2_track_lock_refresh(lockres);
@@ -2464 +2543 @@
-#define OCFS2_DLM_DEBUG_STR_VERSION 1
+#define OCFS2_DLM_DEBUG_STR_VERSION 2
@@ -2504,0 +2584,41 @@
+#ifdef CONFIG_OCFS2_FS_STATS
+# define lock_num_prmode(_l)		(_l)->l_lock_num_prmode
+# define lock_num_exmode(_l)		(_l)->l_lock_num_exmode
+# define lock_num_prmode_failed(_l)	(_l)->l_lock_num_prmode_failed
+# define lock_num_exmode_failed(_l)	(_l)->l_lock_num_exmode_failed
+# define lock_total_prmode(_l)		(_l)->l_lock_total_prmode
+# define lock_total_exmode(_l)		(_l)->l_lock_total_exmode
+# define lock_max_prmode(_l)		(_l)->l_lock_max_prmode
+# define lock_max_exmode(_l)		(_l)->l_lock_max_exmode
+# define lock_refresh(_l)		(_l)->l_lock_refresh
+#else
+# define lock_num_prmode(_l)		(0ULL)
+# define lock_num_exmode(_l)		(0ULL)
+# define lock_num_prmode_failed(_l)	(0)
+# define lock_num_exmode_failed(_l)	(0)
+# define lock_total_prmode(_l)		(0ULL)
+# define lock_total_exmode(_l)		(0ULL)
+# define lock_max_prmode(_l)		(0)
+# define lock_max_exmode(_l)		(0)
+# define lock_refresh(_l)		(0)
+#endif
+	/* The following seq_print was added in version 2 of this output */
+	seq_printf(m, "%llu\t"
+		   "%llu\t"
+		   "%u\t"
+		   "%u\t"
+		   "%llu\t"
+		   "%llu\t"
+		   "%u\t"
+		   "%u\t"
+		   "%u\t",
+		   lock_num_prmode(lockres),
+		   lock_num_exmode(lockres),
+		   lock_num_prmode_failed(lockres),
+		   lock_num_exmode_failed(lockres),
+		   lock_total_prmode(lockres),
+		   lock_total_exmode(lockres),
+		   lock_max_prmode(lockres),
+		   lock_max_exmode(lockres),
+		   lock_refresh(lockres));
+
--- ./projects/linux/linux-2.6.27/fs/ocfs2/dlmglue.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/fs/ocfs2/dlmglue.c	2008-12-25 00:26:37.000000000 +0100
@@ -2027,2 +2027 @@
-		status = ocfs2_read_block(OCFS2_SB(inode->i_sb), oi->ip_blkno,
-					  bh, OCFS2_BH_CACHED, inode);
+		status = ocfs2_read_block(inode, oi->ip_blkno, bh);
@@ -2089,5 +2088 @@
-	status = ocfs2_read_block(OCFS2_SB(inode->i_sb),
-				  OCFS2_I(inode)->ip_blkno,
-				  ret_bh,
-				  OCFS2_BH_CACHED,
-				  inode);
+	status = ocfs2_read_block(inode, OCFS2_I(inode)->ip_blkno, ret_bh);
@@ -2849,2 +2843,0 @@
-	spin_unlock_irqrestore(&lockres->l_lock, flags);
-
@@ -2851,0 +2845 @@
+	spin_unlock_irqrestore(&lockres->l_lock, flags);
--- ./projects/linux/linux-2.6.28/fs/ocfs2/dlmglue.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/fs/ocfs2/dlmglue.c	2009-03-24 00:12:14.000000000 +0100
@@ -34,0 +35 @@
+#include <linux/quotaops.h>
@@ -53,0 +55 @@
+#include "quota.h"
@@ -70,0 +73 @@
+static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres);
@@ -104,0 +108 @@
+static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres);
@@ -114,2 +118 @@
-	struct ocfs2_meta_lvb *lvb =
-		(struct ocfs2_meta_lvb *)ocfs2_dlm_lvb(&lockres->l_lksb);
+	struct ocfs2_meta_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);
@@ -260,0 +264,6 @@
+static struct ocfs2_lock_res_ops ocfs2_qinfo_lops = {
+	.set_lvb	= ocfs2_set_qinfo_lvb,
+	.get_osb	= ocfs2_get_qinfo_osb,
+	.flags		= LOCK_TYPE_REQUIRES_REFRESH | LOCK_TYPE_USES_LVB,
+};
+
@@ -281,0 +291,7 @@
+static inline struct ocfs2_mem_dqinfo *ocfs2_lock_res_qinfo(struct ocfs2_lock_res *lockres)
+{
+	BUG_ON(lockres->l_type != OCFS2_LOCK_TYPE_QINFO);
+
+	return (struct ocfs2_mem_dqinfo *)lockres->l_priv;
+}
+
@@ -307,3 +323,8 @@
-#define ocfs2_log_dlm_error(_func, _err, _lockres) do {			\
-	mlog(ML_ERROR, "DLM error %d while calling %s on resource %s\n", \
-	     _err, _func, _lockres->l_name);				\
+#define ocfs2_log_dlm_error(_func, _err, _lockres) do {					\
+	if ((_lockres)->l_type != OCFS2_LOCK_TYPE_DENTRY)				\
+		mlog(ML_ERROR, "DLM error %d while calling %s on resource %s\n",	\
+		     _err, _func, _lockres->l_name);					\
+	else										\
+		mlog(ML_ERROR, "DLM error %d while calling %s on resource %.*s%08x\n",	\
+		     _err, _func, OCFS2_DENTRY_LOCK_INO_START - 1, (_lockres)->l_name,	\
+		     (unsigned int)ocfs2_get_dentry_lock_ino(_lockres));		\
@@ -509,0 +531,7 @@
+static struct ocfs2_super *ocfs2_get_qinfo_osb(struct ocfs2_lock_res *lockres)
+{
+	struct ocfs2_mem_dqinfo *info = lockres->l_priv;
+
+	return OCFS2_SB(info->dqi_gi.dqi_sb);
+}
+
@@ -611,0 +640,11 @@
+void ocfs2_qinfo_lock_res_init(struct ocfs2_lock_res *lockres,
+			       struct ocfs2_mem_dqinfo *info)
+{
+	ocfs2_lock_res_init_once(lockres);
+	ocfs2_build_lock_name(OCFS2_LOCK_TYPE_QINFO, info->dqi_gi.dqi_type,
+			      0, lockres->l_name);
+	ocfs2_lock_res_init_common(OCFS2_SB(info->dqi_gi.dqi_sb), lockres,
+				   OCFS2_LOCK_TYPE_QINFO, &ocfs2_qinfo_lops,
+				   info);
+}
+
@@ -1293 +1332 @@
-		mlog(0, "lock %s, successfull return from ocfs2_dlm_lock\n",
+		mlog(0, "lock %s, successful return from ocfs2_dlm_lock\n",
@@ -1832 +1871 @@
-	lvb = (struct ocfs2_meta_lvb *)ocfs2_dlm_lvb(&lockres->l_lksb);
+	lvb = ocfs2_dlm_lvb(&lockres->l_lksb);
@@ -1884 +1923 @@
-	lvb = (struct ocfs2_meta_lvb *)ocfs2_dlm_lvb(&lockres->l_lksb);
+	lvb = ocfs2_dlm_lvb(&lockres->l_lksb);
@@ -1919,2 +1958 @@
-	struct ocfs2_meta_lvb *lvb =
-		(struct ocfs2_meta_lvb *)ocfs2_dlm_lvb(&lockres->l_lksb);
+	struct ocfs2_meta_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);
@@ -2027 +2065 @@
-		status = ocfs2_read_block(inode, oi->ip_blkno, bh);
+		status = ocfs2_read_inode_block(inode, bh);
@@ -2035 +2073,2 @@
-		 * locking an invalid object.
+		 * locking an invalid object.  ocfs2_read_inode_block()
+		 * already checked that the inode block is sane.
@@ -2042,5 +2080,0 @@
-		if (!OCFS2_IS_VALID_DINODE(fe)) {
-			OCFS2_RO_ON_INVALID_DINODE(inode->i_sb, fe);
-			status = -EIO;
-			goto bail_refresh;
-		}
@@ -2088 +2122 @@
-	status = ocfs2_read_block(inode, OCFS2_I(inode)->ip_blkno, ret_bh);
+	status = ocfs2_read_inode_block(inode, ret_bh);
@@ -2833,0 +2868,4 @@
+		/* Downconvert thread may have requeued this lock, we
+		 * need to wake it. */
+		if (lockres->l_flags & OCFS2_LOCK_BLOCKED)
+			ocfs2_wake_downconvert_thread(ocfs2_get_lockres_osb(lockres));
@@ -2925 +2963 @@
-	mlog(0, "lock %s, successfull return from ocfs2_dlm_unlock\n",
+	mlog(0, "lock %s, successful return from ocfs2_dlm_unlock\n",
@@ -3451,0 +3490,111 @@
+static void ocfs2_set_qinfo_lvb(struct ocfs2_lock_res *lockres)
+{
+	struct ocfs2_qinfo_lvb *lvb;
+	struct ocfs2_mem_dqinfo *oinfo = ocfs2_lock_res_qinfo(lockres);
+	struct mem_dqinfo *info = sb_dqinfo(oinfo->dqi_gi.dqi_sb,
+					    oinfo->dqi_gi.dqi_type);
+
+	mlog_entry_void();
+
+	lvb = ocfs2_dlm_lvb(&lockres->l_lksb);
+	lvb->lvb_version = OCFS2_QINFO_LVB_VERSION;
+	lvb->lvb_bgrace = cpu_to_be32(info->dqi_bgrace);
+	lvb->lvb_igrace = cpu_to_be32(info->dqi_igrace);
+	lvb->lvb_syncms = cpu_to_be32(oinfo->dqi_syncms);
+	lvb->lvb_blocks = cpu_to_be32(oinfo->dqi_gi.dqi_blocks);
+	lvb->lvb_free_blk = cpu_to_be32(oinfo->dqi_gi.dqi_free_blk);
+	lvb->lvb_free_entry = cpu_to_be32(oinfo->dqi_gi.dqi_free_entry);
+
+	mlog_exit_void();
+}
+
+void ocfs2_qinfo_unlock(struct ocfs2_mem_dqinfo *oinfo, int ex)
+{
+	struct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;
+	struct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);
+	int level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;
+
+	mlog_entry_void();
+	if (!ocfs2_is_hard_readonly(osb) && !ocfs2_mount_local(osb))
+		ocfs2_cluster_unlock(osb, lockres, level);
+	mlog_exit_void();
+}
+
+static int ocfs2_refresh_qinfo(struct ocfs2_mem_dqinfo *oinfo)
+{
+	struct mem_dqinfo *info = sb_dqinfo(oinfo->dqi_gi.dqi_sb,
+					    oinfo->dqi_gi.dqi_type);
+	struct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;
+	struct ocfs2_qinfo_lvb *lvb = ocfs2_dlm_lvb(&lockres->l_lksb);
+	struct buffer_head *bh = NULL;
+	struct ocfs2_global_disk_dqinfo *gdinfo;
+	int status = 0;
+
+	if (lvb->lvb_version == OCFS2_QINFO_LVB_VERSION) {
+		info->dqi_bgrace = be32_to_cpu(lvb->lvb_bgrace);
+		info->dqi_igrace = be32_to_cpu(lvb->lvb_igrace);
+		oinfo->dqi_syncms = be32_to_cpu(lvb->lvb_syncms);
+		oinfo->dqi_gi.dqi_blocks = be32_to_cpu(lvb->lvb_blocks);
+		oinfo->dqi_gi.dqi_free_blk = be32_to_cpu(lvb->lvb_free_blk);
+		oinfo->dqi_gi.dqi_free_entry =
+					be32_to_cpu(lvb->lvb_free_entry);
+	} else {
+		status = ocfs2_read_quota_block(oinfo->dqi_gqinode, 0, &bh);
+		if (status) {
+			mlog_errno(status);
+			goto bail;
+		}
+		gdinfo = (struct ocfs2_global_disk_dqinfo *)
+					(bh->b_data + OCFS2_GLOBAL_INFO_OFF);
+		info->dqi_bgrace = le32_to_cpu(gdinfo->dqi_bgrace);
+		info->dqi_igrace = le32_to_cpu(gdinfo->dqi_igrace);
+		oinfo->dqi_syncms = le32_to_cpu(gdinfo->dqi_syncms);
+		oinfo->dqi_gi.dqi_blocks = le32_to_cpu(gdinfo->dqi_blocks);
+		oinfo->dqi_gi.dqi_free_blk = le32_to_cpu(gdinfo->dqi_free_blk);
+		oinfo->dqi_gi.dqi_free_entry =
+					le32_to_cpu(gdinfo->dqi_free_entry);
+		brelse(bh);
+		ocfs2_track_lock_refresh(lockres);
+	}
+
+bail:
+	return status;
+}
+
+/* Lock quota info, this function expects at least shared lock on the quota file
+ * so that we can safely refresh quota info from disk. */
+int ocfs2_qinfo_lock(struct ocfs2_mem_dqinfo *oinfo, int ex)
+{
+	struct ocfs2_lock_res *lockres = &oinfo->dqi_gqlock;
+	struct ocfs2_super *osb = OCFS2_SB(oinfo->dqi_gi.dqi_sb);
+	int level = ex ? DLM_LOCK_EX : DLM_LOCK_PR;
+	int status = 0;
+
+	mlog_entry_void();
+
+	/* On RO devices, locking really isn't needed... */
+	if (ocfs2_is_hard_readonly(osb)) {
+		if (ex)
+			status = -EROFS;
+		goto bail;
+	}
+	if (ocfs2_mount_local(osb))
+		goto bail;
+
+	status = ocfs2_cluster_lock(osb, lockres, level, 0, 0);
+	if (status < 0) {
+		mlog_errno(status);
+		goto bail;
+	}
+	if (!ocfs2_should_refresh_lock_res(lockres))
+		goto bail;
+	/* OK, we have the lock but we need to refresh the quota info */
+	status = ocfs2_refresh_qinfo(oinfo);
+	if (status)
+		ocfs2_qinfo_unlock(oinfo, ex);
+	ocfs2_complete_lock_res_refresh(lockres, status);
+bail:
+	mlog_exit(status);
+	return status;
+}
+
--- ./projects/linux/linux-2.6.29/fs/ocfs2/dlmglue.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/fs/ocfs2/dlmglue.c	2009-06-27 11:32:32.000000000 +0200
@@ -246,0 +247,4 @@
+static struct ocfs2_lock_res_ops ocfs2_nfs_sync_lops = {
+	.flags		= 0,
+};
+
@@ -624,0 +629,11 @@
+static void ocfs2_nfs_sync_lock_res_init(struct ocfs2_lock_res *res,
+					 struct ocfs2_super *osb)
+{
+	/* nfs_sync lockres doesn't come from a slab so we call init
+	 * once on it manually.  */
+	ocfs2_lock_res_init_once(res);
+	ocfs2_build_lock_name(OCFS2_LOCK_TYPE_NFS_SYNC, 0, 0, res->l_name);
+	ocfs2_lock_res_init_common(osb, res, OCFS2_LOCK_TYPE_NFS_SYNC,
+				   &ocfs2_nfs_sync_lops, osb);
+}
+
@@ -2419,0 +2435,28 @@
+int ocfs2_nfs_sync_lock(struct ocfs2_super *osb, int ex)
+{
+	int status;
+	struct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;
+
+	if (ocfs2_is_hard_readonly(osb))
+		return -EROFS;
+
+	if (ocfs2_mount_local(osb))
+		return 0;
+
+	status = ocfs2_cluster_lock(osb, lockres, ex ? LKM_EXMODE : LKM_PRMODE,
+				    0, 0);
+	if (status < 0)
+		mlog(ML_ERROR, "lock on nfs sync lock failed %d\n", status);
+
+	return status;
+}
+
+void ocfs2_nfs_sync_unlock(struct ocfs2_super *osb, int ex)
+{
+	struct ocfs2_lock_res *lockres = &osb->osb_nfs_sync_lockres;
+
+	if (!ocfs2_mount_local(osb))
+		ocfs2_cluster_unlock(osb, lockres,
+				     ex ? LKM_EXMODE : LKM_PRMODE);
+}
+
@@ -2800,0 +2844 @@
+	ocfs2_nfs_sync_lock_res_init(&osb->osb_nfs_sync_lockres, osb);
@@ -2835,0 +2880 @@
+	ocfs2_lock_res_free(&osb->osb_nfs_sync_lockres);
@@ -3017,0 +3063 @@
+	ocfs2_simple_drop_lockres(osb, &osb->osb_nfs_sync_lockres);
--- ./projects/linux/linux-2.6.14/net/ieee80211/ieee80211_wx.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/net/ieee80211/ieee80211_wx.c	2006-01-03 04:21:10.000000000 +0100
@@ -3 +3 @@
-  Copyright(c) 2004 Intel Corporation. All rights reserved.
+  Copyright(c) 2004-2005 Intel Corporation. All rights reserved.
@@ -34,0 +35 @@
+#include <linux/jiffies.h>
@@ -143 +143,0 @@
-	/* TODO: Fix these values... */
@@ -145,7 +145,31 @@
-	iwe.u.qual.qual = network->stats.signal;
-	iwe.u.qual.level = network->stats.rssi;
-	iwe.u.qual.noise = network->stats.noise;
-	iwe.u.qual.updated = network->stats.mask & IEEE80211_STATMASK_WEMASK;
-	if (!(network->stats.mask & IEEE80211_STATMASK_RSSI))
-		iwe.u.qual.updated |= IW_QUAL_LEVEL_INVALID;
-	if (!(network->stats.mask & IEEE80211_STATMASK_NOISE))
+	iwe.u.qual.updated = IW_QUAL_QUAL_UPDATED | IW_QUAL_LEVEL_UPDATED |
+	    IW_QUAL_NOISE_UPDATED;
+
+	if (!(network->stats.mask & IEEE80211_STATMASK_RSSI)) {
+		iwe.u.qual.updated |= IW_QUAL_QUAL_INVALID |
+		    IW_QUAL_LEVEL_INVALID;
+		iwe.u.qual.qual = 0;
+		iwe.u.qual.level = 0;
+	} else {
+		iwe.u.qual.level = network->stats.rssi;
+		if (ieee->perfect_rssi == ieee->worst_rssi)
+			iwe.u.qual.qual = 100;
+		else
+			iwe.u.qual.qual =
+			    (100 *
+			     (ieee->perfect_rssi - ieee->worst_rssi) *
+			     (ieee->perfect_rssi - ieee->worst_rssi) -
+			     (ieee->perfect_rssi - network->stats.rssi) *
+			     (15 * (ieee->perfect_rssi - ieee->worst_rssi) +
+			      62 * (ieee->perfect_rssi -
+				    network->stats.rssi))) /
+			    ((ieee->perfect_rssi -
+			      ieee->worst_rssi) * (ieee->perfect_rssi -
+						   ieee->worst_rssi));
+		if (iwe.u.qual.qual > 100)
+			iwe.u.qual.qual = 100;
+		else if (iwe.u.qual.qual < 1)
+			iwe.u.qual.qual = 0;
+	}
+
+	if (!(network->stats.mask & IEEE80211_STATMASK_NOISE)) {
@@ -153,2 +177,4 @@
-	if (!(network->stats.mask & IEEE80211_STATMASK_SIGNAL))
-		iwe.u.qual.updated |= IW_QUAL_QUAL_INVALID;
+		iwe.u.qual.noise = 0;
+	} else {
+		iwe.u.qual.noise = network->stats.noise;
+	}
@@ -165 +191 @@
-	if (ieee->wpa_enabled && network->wpa_ie_len) {
+	if (network->wpa_ie_len) {
@@ -180 +206 @@
-	if (ieee->wpa_enabled && network->rsn_ie_len) {
+	if (network->rsn_ie_len) {
@@ -200,2 +226,2 @@
-		      " Last beacon: %lums ago",
-		      (jiffies - network->last_scanned) / (HZ / 100));
+		      " Last beacon: %dms ago",
+		      jiffies_to_msecs(jiffies - network->last_scanned));
@@ -231 +257 @@
-					     MAC_FMT ")' due to age (%lums).\n",
+					     MAC_FMT ")' due to age (%dms).\n",
@@ -235,3 +261,3 @@
-					     (jiffies -
-					      network->last_scanned) / (HZ /
-									100));
+					     jiffies_to_msecs(jiffies -
+							      network->
+							      last_scanned));
@@ -260,0 +287 @@
+	int host_crypto = ieee->host_encrypt || ieee->host_decrypt;
@@ -300,0 +328 @@
+			sec.encrypt = 0;
@@ -302 +330 @@
-			sec.flags |= SEC_ENABLED | SEC_LEVEL;
+			sec.flags |= SEC_ENABLED | SEC_LEVEL | SEC_ENCRYPT;
@@ -309 +337,2 @@
-	sec.flags |= SEC_ENABLED;
+	sec.encrypt = 1;
+	sec.flags |= SEC_ENABLED | SEC_ENCRYPT;
@@ -318 +347 @@
-	if (*crypt == NULL) {
+	if (*crypt == NULL && host_crypto) {
@@ -358,2 +387,3 @@
-		(*crypt)->ops->set_key(sec.keys[key], len, NULL,
-				       (*crypt)->priv);
+		if (*crypt)
+			(*crypt)->ops->set_key(sec.keys[key], len, NULL,
+					       (*crypt)->priv);
@@ -364,0 +395 @@
+
@@ -366,11 +397,13 @@
-		len = (*crypt)->ops->get_key(sec.keys[key], WEP_KEY_LEN,
-					     NULL, (*crypt)->priv);
-		if (len == 0) {
-			/* Set a default key of all 0 */
-			IEEE80211_DEBUG_WX("Setting key %d to all zero.\n",
-					   key);
-			memset(sec.keys[key], 0, 13);
-			(*crypt)->ops->set_key(sec.keys[key], 13, NULL,
-					       (*crypt)->priv);
-			sec.key_sizes[key] = 13;
-			sec.flags |= (1 << key);
+		if (host_crypto) {
+			len = (*crypt)->ops->get_key(sec.keys[key], WEP_KEY_LEN,
+						     NULL, (*crypt)->priv);
+			if (len == 0) {
+				/* Set a default key of all 0 */
+				IEEE80211_DEBUG_WX("Setting key %d to all "
+						   "zero.\n", key);
+				memset(sec.keys[key], 0, 13);
+				(*crypt)->ops->set_key(sec.keys[key], 13, NULL,
+						       (*crypt)->priv);
+				sec.key_sizes[key] = 13;
+				sec.flags |= (1 << key);
+			}
@@ -378 +410,0 @@
-
@@ -381,2 +413,2 @@
-			IEEE80211_DEBUG_WX
-			    ("Setting key %d to default Tx key.\n", key);
+			IEEE80211_DEBUG_WX("Setting key %d to default Tx "
+					   "key.\n", key);
@@ -388,7 +420,9 @@
-
-      done:
-	ieee->open_wep = !(erq->flags & IW_ENCODE_RESTRICTED);
-	sec.auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN : WLAN_AUTH_SHARED_KEY;
-	sec.flags |= SEC_AUTH_MODE;
-	IEEE80211_DEBUG_WX("Auth: %s\n", sec.auth_mode == WLAN_AUTH_OPEN ?
-			   "OPEN" : "SHARED KEY");
+	if (erq->flags & (IW_ENCODE_OPEN | IW_ENCODE_RESTRICTED)) {
+		ieee->open_wep = !(erq->flags & IW_ENCODE_RESTRICTED);
+		sec.auth_mode = ieee->open_wep ? WLAN_AUTH_OPEN :
+		    WLAN_AUTH_SHARED_KEY;
+		sec.flags |= SEC_AUTH_MODE;
+		IEEE80211_DEBUG_WX("Auth: %s\n",
+				   sec.auth_mode == WLAN_AUTH_OPEN ?
+				   "OPEN" : "SHARED KEY");
+	}
@@ -399,0 +434 @@
+	sec.encode_alg[key] = SEC_ALG_WEP;
@@ -400,0 +436 @@
+      done:
@@ -424,0 +461 @@
+	struct ieee80211_security *sec = &ieee->sec;
@@ -439 +476 @@
-	if (crypt == NULL || crypt->ops == NULL) {
+	if (!sec->enabled) {
@@ -445,7 +482,2 @@
-	if (strcmp(crypt->ops->name, "WEP") != 0) {
-		/* only WEP is supported with wireless extensions, so just
-		 * report that encryption is used */
-		erq->length = 0;
-		erq->flags |= IW_ENCODE_ENABLED;
-		return 0;
-	}
+	len = sec->key_sizes[key];
+	memcpy(keybuf, sec->keys[key], len);
@@ -453 +484,0 @@
-	len = crypt->ops->get_key(keybuf, WEP_KEY_LEN, NULL, crypt->priv);
@@ -455 +485,0 @@
-
@@ -465,0 +496,236 @@
+int ieee80211_wx_set_encodeext(struct ieee80211_device *ieee,
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct net_device *dev = ieee->dev;
+	struct iw_point *encoding = &wrqu->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	int i, idx, ret = 0;
+	int group_key = 0;
+	const char *alg, *module;
+	struct ieee80211_crypto_ops *ops;
+	struct ieee80211_crypt_data **crypt;
+
+	struct ieee80211_security sec = {
+		.flags = 0,
+	};
+
+	idx = encoding->flags & IW_ENCODE_INDEX;
+	if (idx) {
+		if (idx < 1 || idx > WEP_KEYS)
+			return -EINVAL;
+		idx--;
+	} else
+		idx = ieee->tx_keyidx;
+
+	if (ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) {
+		crypt = &ieee->crypt[idx];
+		group_key = 1;
+	} else {
+		/* some Cisco APs use idx>0 for unicast in dynamic WEP */
+		if (idx != 0 && ext->alg != IW_ENCODE_ALG_WEP)
+			return -EINVAL;
+		if (ieee->iw_mode == IW_MODE_INFRA)
+			crypt = &ieee->crypt[idx];
+		else
+			return -EINVAL;
+	}
+
+	sec.flags |= SEC_ENABLED | SEC_ENCRYPT;
+	if ((encoding->flags & IW_ENCODE_DISABLED) ||
+	    ext->alg == IW_ENCODE_ALG_NONE) {
+		if (*crypt)
+			ieee80211_crypt_delayed_deinit(ieee, crypt);
+
+		for (i = 0; i < WEP_KEYS; i++)
+			if (ieee->crypt[i] != NULL)
+				break;
+
+		if (i == WEP_KEYS) {
+			sec.enabled = 0;
+			sec.encrypt = 0;
+			sec.level = SEC_LEVEL_0;
+			sec.flags |= SEC_LEVEL;
+		}
+		goto done;
+	}
+
+	sec.enabled = 1;
+	sec.encrypt = 1;
+
+	if (group_key ? !ieee->host_mc_decrypt :
+	    !(ieee->host_encrypt || ieee->host_decrypt ||
+	      ieee->host_encrypt_msdu))
+		goto skip_host_crypt;
+
+	switch (ext->alg) {
+	case IW_ENCODE_ALG_WEP:
+		alg = "WEP";
+		module = "ieee80211_crypt_wep";
+		break;
+	case IW_ENCODE_ALG_TKIP:
+		alg = "TKIP";
+		module = "ieee80211_crypt_tkip";
+		break;
+	case IW_ENCODE_ALG_CCMP:
+		alg = "CCMP";
+		module = "ieee80211_crypt_ccmp";
+		break;
+	default:
+		IEEE80211_DEBUG_WX("%s: unknown crypto alg %d\n",
+				   dev->name, ext->alg);
+		ret = -EINVAL;
+		goto done;
+	}
+
+	ops = ieee80211_get_crypto_ops(alg);
+	if (ops == NULL) {
+		request_module(module);
+		ops = ieee80211_get_crypto_ops(alg);
+	}
+	if (ops == NULL) {
+		IEEE80211_DEBUG_WX("%s: unknown crypto alg %d\n",
+				   dev->name, ext->alg);
+		ret = -EINVAL;
+		goto done;
+	}
+
+	if (*crypt == NULL || (*crypt)->ops != ops) {
+		struct ieee80211_crypt_data *new_crypt;
+
+		ieee80211_crypt_delayed_deinit(ieee, crypt);
+
+		new_crypt = (struct ieee80211_crypt_data *)
+		    kmalloc(sizeof(*new_crypt), GFP_KERNEL);
+		if (new_crypt == NULL) {
+			ret = -ENOMEM;
+			goto done;
+		}
+		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
+		new_crypt->ops = ops;
+		if (new_crypt->ops && try_module_get(new_crypt->ops->owner))
+			new_crypt->priv = new_crypt->ops->init(idx);
+		if (new_crypt->priv == NULL) {
+			kfree(new_crypt);
+			ret = -EINVAL;
+			goto done;
+		}
+		*crypt = new_crypt;
+	}
+
+	if (ext->key_len > 0 && (*crypt)->ops->set_key &&
+	    (*crypt)->ops->set_key(ext->key, ext->key_len, ext->rx_seq,
+				   (*crypt)->priv) < 0) {
+		IEEE80211_DEBUG_WX("%s: key setting failed\n", dev->name);
+		ret = -EINVAL;
+		goto done;
+	}
+
+      skip_host_crypt:
+	if (ext->ext_flags & IW_ENCODE_EXT_SET_TX_KEY) {
+		ieee->tx_keyidx = idx;
+		sec.active_key = idx;
+		sec.flags |= SEC_ACTIVE_KEY;
+	}
+
+	if (ext->alg != IW_ENCODE_ALG_NONE) {
+		memcpy(sec.keys[idx], ext->key, ext->key_len);
+		sec.key_sizes[idx] = ext->key_len;
+		sec.flags |= (1 << idx);
+		if (ext->alg == IW_ENCODE_ALG_WEP) {
+			sec.encode_alg[idx] = SEC_ALG_WEP;
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_1;
+		} else if (ext->alg == IW_ENCODE_ALG_TKIP) {
+			sec.encode_alg[idx] = SEC_ALG_TKIP;
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_2;
+		} else if (ext->alg == IW_ENCODE_ALG_CCMP) {
+			sec.encode_alg[idx] = SEC_ALG_CCMP;
+			sec.flags |= SEC_LEVEL;
+			sec.level = SEC_LEVEL_3;
+		}
+		/* Don't set sec level for group keys. */
+		if (group_key)
+			sec.flags &= ~SEC_LEVEL;
+	}
+      done:
+	if (ieee->set_security)
+		ieee->set_security(ieee->dev, &sec);
+
+	/*
+	 * Do not reset port if card is in Managed mode since resetting will
+	 * generate new IEEE 802.11 authentication which may end up in looping
+	 * with IEEE 802.1X. If your hardware requires a reset after WEP
+	 * configuration (for example... Prism2), implement the reset_port in
+	 * the callbacks structures used to initialize the 802.11 stack.
+	 */
+	if (ieee->reset_on_keychange &&
+	    ieee->iw_mode != IW_MODE_INFRA &&
+	    ieee->reset_port && ieee->reset_port(dev)) {
+		IEEE80211_DEBUG_WX("%s: reset_port failed\n", dev->name);
+		return -EINVAL;
+	}
+
+	return ret;
+}
+
+int ieee80211_wx_get_encodeext(struct ieee80211_device *ieee,
+			       struct iw_request_info *info,
+			       union iwreq_data *wrqu, char *extra)
+{
+	struct iw_point *encoding = &wrqu->encoding;
+	struct iw_encode_ext *ext = (struct iw_encode_ext *)extra;
+	struct ieee80211_security *sec = &ieee->sec;
+	int idx, max_key_len;
+
+	max_key_len = encoding->length - sizeof(*ext);
+	if (max_key_len < 0)
+		return -EINVAL;
+
+	idx = encoding->flags & IW_ENCODE_INDEX;
+	if (idx) {
+		if (idx < 1 || idx > WEP_KEYS)
+			return -EINVAL;
+		idx--;
+	} else
+		idx = ieee->tx_keyidx;
+
+	if (!ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY &&
+	    ext->alg != IW_ENCODE_ALG_WEP)
+		if (idx != 0 || ieee->iw_mode != IW_MODE_INFRA)
+			return -EINVAL;
+
+	encoding->flags = idx + 1;
+	memset(ext, 0, sizeof(*ext));
+
+	if (!sec->enabled) {
+		ext->alg = IW_ENCODE_ALG_NONE;
+		ext->key_len = 0;
+		encoding->flags |= IW_ENCODE_DISABLED;
+	} else {
+		if (sec->encode_alg[idx] == SEC_ALG_WEP)
+			ext->alg = IW_ENCODE_ALG_WEP;
+		else if (sec->encode_alg[idx] == SEC_ALG_TKIP)
+			ext->alg = IW_ENCODE_ALG_TKIP;
+		else if (sec->encode_alg[idx] == SEC_ALG_CCMP)
+			ext->alg = IW_ENCODE_ALG_CCMP;
+		else
+			return -EINVAL;
+
+		ext->key_len = sec->key_sizes[idx];
+		memcpy(ext->key, sec->keys[idx], ext->key_len);
+		encoding->flags |= IW_ENCODE_ENABLED;
+		if (ext->key_len &&
+		    (ext->alg == IW_ENCODE_ALG_TKIP ||
+		     ext->alg == IW_ENCODE_ALG_CCMP))
+			ext->ext_flags |= IW_ENCODE_EXT_TX_SEQ_VALID;
+
+	}
+
+	return 0;
+}
+
+EXPORT_SYMBOL(ieee80211_wx_set_encodeext);
+EXPORT_SYMBOL(ieee80211_wx_get_encodeext);
+
--- ./projects/linux/linux-2.6.15/net/ieee80211/ieee80211_wx.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/net/ieee80211/ieee80211_wx.c	2006-03-20 06:53:29.000000000 +0100
@@ -45 +45 @@
-static inline char *ipw2100_translate_scan(struct ieee80211_device *ieee,
+static char *ipw2100_translate_scan(struct ieee80211_device *ieee,
@@ -234,0 +235,2 @@
+#define SCAN_ITEM_SIZE 128
+
@@ -240,0 +243 @@
+	int err = 0;
@@ -243 +246 @@
-	char *stop = ev + IW_SCAN_MAX_DATA;
+	char *stop = ev + wrqu->data.length;
@@ -251,0 +255,5 @@
+		if (stop - ev < SCAN_ITEM_SIZE) {
+			err = -E2BIG;
+			break;
+		}
+
@@ -273 +281 @@
-	return 0;
+	return err;
@@ -287 +295 @@
-	int host_crypto = ieee->host_encrypt || ieee->host_decrypt;
+	int host_crypto = ieee->host_encrypt || ieee->host_decrypt || ieee->host_build_iv;
--- ./projects/linux/linux-2.6.16/net/ieee80211/ieee80211_wx.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/net/ieee80211/ieee80211_wx.c	2006-06-18 03:49:35.000000000 +0200
@@ -45 +45 @@
-static char *ipw2100_translate_scan(struct ieee80211_device *ieee,
+static char *ieee80211_translate_scan(struct ieee80211_device *ieee,
@@ -152 +151,0 @@
-		iwe.u.qual.level = 0;
@@ -154 +152,0 @@
-		iwe.u.qual.level = network->stats.rssi;
@@ -181,0 +180,7 @@
+	if (!(network->stats.mask & IEEE80211_STATMASK_SIGNAL)) {
+		iwe.u.qual.updated |= IW_QUAL_LEVEL_INVALID;
+		iwe.u.qual.level = 0;
+	} else {
+		iwe.u.qual.level = network->stats.signal;
+	}
+
@@ -190,0 +196 @@
+	memset(&iwe, 0, sizeof(iwe));
@@ -192,11 +198,4 @@
-		char buf[MAX_WPA_IE_LEN * 2 + 30];
-
-		u8 *p = buf;
-		p += sprintf(p, "wpa_ie=");
-		for (i = 0; i < network->wpa_ie_len; i++) {
-			p += sprintf(p, "%02x", network->wpa_ie[i]);
-		}
-
-		memset(&iwe, 0, sizeof(iwe));
-		iwe.cmd = IWEVCUSTOM;
-		iwe.u.data.length = strlen(buf);
+		char buf[MAX_WPA_IE_LEN];
+		memcpy(buf, network->wpa_ie, network->wpa_ie_len);
+		iwe.cmd = IWEVGENIE;
+		iwe.u.data.length = network->wpa_ie_len;
@@ -205,0 +205 @@
+	memset(&iwe, 0, sizeof(iwe));
@@ -207,11 +207,4 @@
-		char buf[MAX_WPA_IE_LEN * 2 + 30];
-
-		u8 *p = buf;
-		p += sprintf(p, "rsn_ie=");
-		for (i = 0; i < network->rsn_ie_len; i++) {
-			p += sprintf(p, "%02x", network->rsn_ie[i]);
-		}
-
-		memset(&iwe, 0, sizeof(iwe));
-		iwe.cmd = IWEVCUSTOM;
-		iwe.u.data.length = strlen(buf);
+		char buf[MAX_WPA_IE_LEN];
+		memcpy(buf, network->rsn_ie, network->rsn_ie_len);
+		iwe.cmd = IWEVGENIE;
+		iwe.u.data.length = network->rsn_ie_len;
@@ -231,0 +225,22 @@
+	/* Add spectrum management information */
+	iwe.cmd = -1;
+	p = custom;
+	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Channel flags: ");
+
+	if (ieee80211_get_channel_flags(ieee, network->channel) &
+	    IEEE80211_CH_INVALID) {
+		iwe.cmd = IWEVCUSTOM;
+		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), "INVALID ");
+	}
+
+	if (ieee80211_get_channel_flags(ieee, network->channel) &
+	    IEEE80211_CH_RADAR_DETECT) {
+		iwe.cmd = IWEVCUSTOM;
+		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), "DFS ");
+	}
+
+	if (iwe.cmd == IWEVCUSTOM) {
+		iwe.u.data.length = p - custom;
+		start = iwe_stream_add_point(start, stop, &iwe, custom);
+	}
+
@@ -262 +277 @@
-			ev = ipw2100_translate_scan(ieee, ev, stop, network);
+			ev = ieee80211_translate_scan(ieee, ev, stop, network);
@@ -736,0 +752,86 @@
+int ieee80211_wx_set_auth(struct net_device *dev,
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu,
+			  char *extra)
+{
+	struct ieee80211_device *ieee = netdev_priv(dev);
+	unsigned long flags;
+	int err = 0;
+
+	spin_lock_irqsave(&ieee->lock, flags);
+	
+	switch (wrqu->param.flags & IW_AUTH_INDEX) {
+	case IW_AUTH_WPA_VERSION:
+	case IW_AUTH_CIPHER_PAIRWISE:
+	case IW_AUTH_CIPHER_GROUP:
+	case IW_AUTH_KEY_MGMT:
+		/*
+		 * Host AP driver does not use these parameters and allows
+		 * wpa_supplicant to control them internally.
+		 */
+		break;
+	case IW_AUTH_TKIP_COUNTERMEASURES:
+		break;		/* FIXME */
+	case IW_AUTH_DROP_UNENCRYPTED:
+		ieee->drop_unencrypted = !!wrqu->param.value;
+		break;
+	case IW_AUTH_80211_AUTH_ALG:
+		break;		/* FIXME */
+	case IW_AUTH_WPA_ENABLED:
+		ieee->privacy_invoked = ieee->wpa_enabled = !!wrqu->param.value;
+		break;
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		ieee->ieee802_1x = !!wrqu->param.value;
+		break;
+	case IW_AUTH_PRIVACY_INVOKED:
+		ieee->privacy_invoked = !!wrqu->param.value;
+		break;
+	default:
+		err = -EOPNOTSUPP;
+		break;
+	}
+	spin_unlock_irqrestore(&ieee->lock, flags);
+	return err;
+}
+
+int ieee80211_wx_get_auth(struct net_device *dev,
+			  struct iw_request_info *info,
+			  union iwreq_data *wrqu,
+			  char *extra)
+{
+	struct ieee80211_device *ieee = netdev_priv(dev);
+	unsigned long flags;
+	int err = 0;
+
+	spin_lock_irqsave(&ieee->lock, flags);
+	
+	switch (wrqu->param.flags & IW_AUTH_INDEX) {
+	case IW_AUTH_WPA_VERSION:
+	case IW_AUTH_CIPHER_PAIRWISE:
+	case IW_AUTH_CIPHER_GROUP:
+	case IW_AUTH_KEY_MGMT:
+	case IW_AUTH_TKIP_COUNTERMEASURES:		/* FIXME */
+	case IW_AUTH_80211_AUTH_ALG:			/* FIXME */
+		/*
+		 * Host AP driver does not use these parameters and allows
+		 * wpa_supplicant to control them internally.
+		 */
+		err = -EOPNOTSUPP;
+		break;
+	case IW_AUTH_DROP_UNENCRYPTED:
+		wrqu->param.value = ieee->drop_unencrypted;
+		break;
+	case IW_AUTH_WPA_ENABLED:
+		wrqu->param.value = ieee->wpa_enabled;
+		break;
+	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
+		wrqu->param.value = ieee->ieee802_1x;
+		break;
+	default:
+		err = -EOPNOTSUPP;
+		break;
+	}
+	spin_unlock_irqrestore(&ieee->lock, flags);
+	return err;
+}
+
@@ -742,0 +844,3 @@
+
+EXPORT_SYMBOL_GPL(ieee80211_wx_set_auth);
+EXPORT_SYMBOL_GPL(ieee80211_wx_get_auth);
--- ./projects/linux/linux-2.6.17/net/ieee80211/ieee80211_wx.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/net/ieee80211/ieee80211_wx.c	2006-09-20 05:42:06.000000000 +0200
@@ -53 +53,2 @@
-	u8 max_rate, rate;
+	char *current_val;	/* For rates */
+	u8 rate;
@@ -110,3 +111,7 @@
-	max_rate = 0;
-	p = custom;
-	p += snprintf(p, MAX_CUSTOM_LEN - (p - custom), " Rates (Mb/s): ");
+	/* Rate : stuffing multiple values in a single event require a bit
+	 * more of magic - Jean II */
+	current_val = start + IW_EV_LCP_LEN;
+	iwe.cmd = SIOCGIWRATE;
+	/* Those two flags are ignored... */
+	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
+
@@ -120,4 +125,4 @@
-		if (rate > max_rate)
-			max_rate = rate;
-		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
-			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
+		/* Bit rate given in 500 kb/s units (+ 0x80) */
+		iwe.u.bitrate.value = ((rate & 0x7f) * 500000);
+		/* Add new value to event */
+		current_val = iwe_stream_add_value(start, current_val, stop, &iwe, IW_EV_PARAM_LEN);
@@ -127,15 +132,8 @@
-		p += snprintf(p, MAX_CUSTOM_LEN - (p - custom),
-			      "%d%s ", rate >> 1, (rate & 1) ? ".5" : "");
-		if (rate > max_rate)
-			max_rate = rate;
-	}
-
-	iwe.cmd = SIOCGIWRATE;
-	iwe.u.bitrate.fixed = iwe.u.bitrate.disabled = 0;
-	iwe.u.bitrate.value = max_rate * 500000;
-	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_PARAM_LEN);
-
-	iwe.cmd = IWEVCUSTOM;
-	iwe.u.data.length = p - custom;
-	if (iwe.u.data.length)
-		start = iwe_stream_add_point(start, stop, &iwe, custom);
+		/* Bit rate given in 500 kb/s units (+ 0x80) */
+		iwe.u.bitrate.value = ((rate & 0x7f) * 500000);
+		/* Add new value to event */
+		current_val = iwe_stream_add_value(start, current_val, stop, &iwe, IW_EV_PARAM_LEN);
+	}
+	/* Check if we added any rate */
+	if((current_val - start) > IW_EV_LCP_LEN)
+		start = current_val;
@@ -374 +372 @@
-		new_crypt = kmalloc(sizeof(struct ieee80211_crypt_data),
+		new_crypt = kzalloc(sizeof(struct ieee80211_crypt_data),
@@ -378 +375,0 @@
-		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
@@ -508 +505 @@
-	erq->length = (len >= 0 ? len : 0);
+	erq->length = len;
@@ -621,2 +618 @@
-		new_crypt = (struct ieee80211_crypt_data *)
-		    kmalloc(sizeof(*new_crypt), GFP_KERNEL);
+		new_crypt = kzalloc(sizeof(*new_crypt), GFP_KERNEL);
@@ -627 +622,0 @@
-		memset(new_crypt, 0, sizeof(struct ieee80211_crypt_data));
--- ./projects/linux/linux-2.6.20/net/ieee80211/ieee80211_wx.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/net/ieee80211/ieee80211_wx.c	2007-04-26 05:08:32.000000000 +0200
@@ -757 +757 @@
-	
+
@@ -802 +802 @@
-	
+
--- ./projects/linux/linux-2.6.21/net/ieee80211/ieee80211_wx.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/net/ieee80211/ieee80211_wx.c	2007-07-09 01:32:17.000000000 +0200
@@ -8,2 +8,2 @@
-  <jkmaline@cc.hut.fi>
-  Copyright (c) 2002-2003, Jouni Malinen <jkmaline@cc.hut.fi>
+  <j@w1.fi>
+  Copyright (c) 2002-2003, Jouni Malinen <j@w1.fi>
@@ -92 +92 @@
-	/* Add frequency/channel */
+	/* Add channel and frequency */
@@ -94,2 +93,0 @@
-/*	iwe.u.freq.m = ieee80211_frequency(network->channel, network->mode);
-	iwe.u.freq.e = 3; */
@@ -100,0 +99,4 @@
+	iwe.u.freq.m = ieee80211_channel_to_freq(ieee, network->channel);
+	iwe.u.freq.e = 6;
+	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_FREQ_LEN);
+
--- ./projects/linux/linux-2.6.22/net/ieee80211/ieee80211_wx.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/net/ieee80211/ieee80211_wx.c	2007-10-09 22:31:38.000000000 +0200
@@ -92,0 +93 @@
+	/* Note : userspace automatically computes channel using iwrange */
@@ -94,5 +94,0 @@
-	iwe.u.freq.m = network->channel;
-	iwe.u.freq.e = 0;
-	iwe.u.freq.i = 0;
-	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_FREQ_LEN);
-
@@ -100,0 +97 @@
+	iwe.u.freq.i = 0;
--- ./projects/linux/linux-2.6.23/net/ieee80211/ieee80211_wx.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/net/ieee80211/ieee80211_wx.c	2008-01-24 23:58:37.000000000 +0100
@@ -259,0 +260 @@
+	DECLARE_MAC_BUF(mac);
@@ -277 +278 @@
-					     MAC_FMT ")' due to age (%dms).\n",
+					     "%s)' due to age (%dms).\n",
@@ -280 +281 @@
-					     MAC_ARG(network->bssid),
+					     print_mac(mac, network->bssid),
@@ -411 +412 @@
-		 * explicitely set */
+		 * explicitly set */
--- ./projects/linux/linux-2.6.24/net/ieee80211/ieee80211_wx.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/net/ieee80211/ieee80211_wx.c	2008-04-17 04:49:44.000000000 +0200
@@ -712 +712 @@
-	if (!ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY &&
+	if (!(ext->ext_flags & IW_ENCODE_EXT_GROUP_KEY) &&
--- ./projects/linux/linux-2.6.26/net/ieee80211/ieee80211_wx.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/net/ieee80211/ieee80211_wx.c	2008-10-10 00:13:53.000000000 +0200
@@ -46,2 +46,3 @@
-					   char *start, char *stop,
-					   struct ieee80211_network *network)
+				      char *start, char *stop,
+				      struct ieee80211_network *network,
+				      struct iw_request_info *info)
@@ -60 +61 @@
-	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_ADDR_LEN);
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_ADDR_LEN);
@@ -69 +70,2 @@
-		start = iwe_stream_add_point(start, stop, &iwe, "<hidden>");
+		start = iwe_stream_add_point(info, start, stop,
+					     &iwe, "<hidden>");
@@ -72 +74,2 @@
-		start = iwe_stream_add_point(start, stop, &iwe, network->ssid);
+		start = iwe_stream_add_point(info, start, stop,
+					     &iwe, network->ssid);
@@ -79 +82 @@
-	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_CHAR_LEN);
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_CHAR_LEN);
@@ -89 +92,2 @@
-		start = iwe_stream_add_event(start, stop, &iwe, IW_EV_UINT_LEN);
+		start = iwe_stream_add_event(info, start, stop,
+					     &iwe, IW_EV_UINT_LEN);
@@ -98 +102 @@
-	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_FREQ_LEN);
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_FREQ_LEN);
@@ -107 +111,2 @@
-	start = iwe_stream_add_point(start, stop, &iwe, network->ssid);
+	start = iwe_stream_add_point(info, start, stop,
+				     &iwe, network->ssid);
@@ -112 +117 @@
-	current_val = start + IW_EV_LCP_LEN;
+	current_val = start + iwe_stream_lcp_len(info);
@@ -127 +132,2 @@
-		current_val = iwe_stream_add_value(start, current_val, stop, &iwe, IW_EV_PARAM_LEN);
+		current_val = iwe_stream_add_value(info, start, current_val,
+						   stop, &iwe, IW_EV_PARAM_LEN);
@@ -134 +140,2 @@
-		current_val = iwe_stream_add_value(start, current_val, stop, &iwe, IW_EV_PARAM_LEN);
+		current_val = iwe_stream_add_value(info, start, current_val,
+						   stop, &iwe, IW_EV_PARAM_LEN);
@@ -137 +144 @@
-	if((current_val - start) > IW_EV_LCP_LEN)
+	if ((current_val - start) > iwe_stream_lcp_len(info))
@@ -184 +191 @@
-	start = iwe_stream_add_event(start, stop, &iwe, IW_EV_QUAL_LEN);
+	start = iwe_stream_add_event(info, start, stop, &iwe, IW_EV_QUAL_LEN);
@@ -191 +198 @@
-		start = iwe_stream_add_point(start, stop, &iwe, custom);
+		start = iwe_stream_add_point(info, start, stop, &iwe, custom);
@@ -199 +206 @@
-		start = iwe_stream_add_point(start, stop, &iwe, buf);
+		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
@@ -208 +215 @@
-		start = iwe_stream_add_point(start, stop, &iwe, buf);
+		start = iwe_stream_add_point(info, start, stop, &iwe, buf);
@@ -220 +227 @@
-		start = iwe_stream_add_point(start, stop, &iwe, custom);
+		start = iwe_stream_add_point(info, start, stop, &iwe, custom);
@@ -241 +248 @@
-		start = iwe_stream_add_point(start, stop, &iwe, custom);
+		start = iwe_stream_add_point(info, start, stop, &iwe, custom);
@@ -275 +282,2 @@
-			ev = ieee80211_translate_scan(ieee, ev, stop, network);
+			ev = ieee80211_translate_scan(ieee, ev, stop, network,
+						      info);
@@ -747,86 +754,0 @@
-int ieee80211_wx_set_auth(struct net_device *dev,
-			  struct iw_request_info *info,
-			  union iwreq_data *wrqu,
-			  char *extra)
-{
-	struct ieee80211_device *ieee = netdev_priv(dev);
-	unsigned long flags;
-	int err = 0;
-
-	spin_lock_irqsave(&ieee->lock, flags);
-
-	switch (wrqu->param.flags & IW_AUTH_INDEX) {
-	case IW_AUTH_WPA_VERSION:
-	case IW_AUTH_CIPHER_PAIRWISE:
-	case IW_AUTH_CIPHER_GROUP:
-	case IW_AUTH_KEY_MGMT:
-		/*
-		 * Host AP driver does not use these parameters and allows
-		 * wpa_supplicant to control them internally.
-		 */
-		break;
-	case IW_AUTH_TKIP_COUNTERMEASURES:
-		break;		/* FIXME */
-	case IW_AUTH_DROP_UNENCRYPTED:
-		ieee->drop_unencrypted = !!wrqu->param.value;
-		break;
-	case IW_AUTH_80211_AUTH_ALG:
-		break;		/* FIXME */
-	case IW_AUTH_WPA_ENABLED:
-		ieee->privacy_invoked = ieee->wpa_enabled = !!wrqu->param.value;
-		break;
-	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
-		ieee->ieee802_1x = !!wrqu->param.value;
-		break;
-	case IW_AUTH_PRIVACY_INVOKED:
-		ieee->privacy_invoked = !!wrqu->param.value;
-		break;
-	default:
-		err = -EOPNOTSUPP;
-		break;
-	}
-	spin_unlock_irqrestore(&ieee->lock, flags);
-	return err;
-}
-
-int ieee80211_wx_get_auth(struct net_device *dev,
-			  struct iw_request_info *info,
-			  union iwreq_data *wrqu,
-			  char *extra)
-{
-	struct ieee80211_device *ieee = netdev_priv(dev);
-	unsigned long flags;
-	int err = 0;
-
-	spin_lock_irqsave(&ieee->lock, flags);
-
-	switch (wrqu->param.flags & IW_AUTH_INDEX) {
-	case IW_AUTH_WPA_VERSION:
-	case IW_AUTH_CIPHER_PAIRWISE:
-	case IW_AUTH_CIPHER_GROUP:
-	case IW_AUTH_KEY_MGMT:
-	case IW_AUTH_TKIP_COUNTERMEASURES:		/* FIXME */
-	case IW_AUTH_80211_AUTH_ALG:			/* FIXME */
-		/*
-		 * Host AP driver does not use these parameters and allows
-		 * wpa_supplicant to control them internally.
-		 */
-		err = -EOPNOTSUPP;
-		break;
-	case IW_AUTH_DROP_UNENCRYPTED:
-		wrqu->param.value = ieee->drop_unencrypted;
-		break;
-	case IW_AUTH_WPA_ENABLED:
-		wrqu->param.value = ieee->wpa_enabled;
-		break;
-	case IW_AUTH_RX_UNENCRYPTED_EAPOL:
-		wrqu->param.value = ieee->ieee802_1x;
-		break;
-	default:
-		err = -EOPNOTSUPP;
-		break;
-	}
-	spin_unlock_irqrestore(&ieee->lock, flags);
-	return err;
-}
-
@@ -839,3 +760,0 @@
-
-EXPORT_SYMBOL_GPL(ieee80211_wx_set_auth);
-EXPORT_SYMBOL_GPL(ieee80211_wx_get_auth);
--- ./projects/linux/linux-2.6.13/scripts/kallsyms.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/scripts/kallsyms.c	2005-10-28 02:02:08.000000000 +0200
@@ -26,0 +27,2 @@
+#define _GNU_SOURCE
+
@@ -32,3 +33,0 @@
-/* maximum token length used. It doesn't pay to increase it a lot, because
- * very long substrings probably don't repeat themselves too often. */
-#define MAX_TOK_SIZE		11
@@ -37,21 +35,0 @@
-/* we use only a subset of the complete symbol table to gather the token count,
- * to speed up compression, at the expense of a little compression ratio */
-#define WORKING_SET		1024
-
-/* first find the best token only on the list of tokens that would profit more
- * than GOOD_BAD_THRESHOLD. Only if this list is empty go to the "bad" list.
- * Increasing this value will put less tokens on the "good" list, so the search
- * is faster. However, if the good list runs out of tokens, we must painfully
- * search the bad list. */
-#define GOOD_BAD_THRESHOLD	10
-
-/* token hash parameters */
-#define HASH_BITS		18
-#define HASH_TABLE_SIZE		(1 << HASH_BITS)
-#define HASH_MASK		(HASH_TABLE_SIZE - 1)
-#define HASH_BASE_OFFSET	2166136261U
-#define HASH_FOLD(a)		((a)&(HASH_MASK))
-
-/* flags to mark symbols */
-#define SYM_FLAG_VALID		1
-#define SYM_FLAG_SAMPLED	2
@@ -61,3 +39 @@
-	char type;
-	unsigned char flags;
-	unsigned char len;
+	unsigned int len;
@@ -69 +45 @@
-static int size, cnt;
+static unsigned int table_size, table_cnt;
@@ -74,14 +50 @@
-struct token {
-	unsigned char data[MAX_TOK_SIZE];
-	unsigned char len;
-	/* profit: the number of bytes that could be saved by inserting this
-	 * token into the table */
-	int profit;
-	struct token *next;	/* next token on the hash list */
-	struct token *right;	/* next token on the good/bad list */
-	struct token *left;    /* previous token on the good/bad list */
-	struct token *smaller; /* token that is less one letter than this one */
-	};
-
-struct token bad_head, good_head;
-struct token *hash_table[HASH_TABLE_SIZE];
+int token_profit[0x10000];
@@ -90 +53 @@
-unsigned char best_table[256][MAX_TOK_SIZE+1];
+unsigned char best_table[256][2];
@@ -94,2 +57 @@
-static void
-usage(void)
+static void usage(void)
@@ -105,2 +67 @@
-static inline int
-is_arm_mapping_symbol(const char *str)
+static inline int is_arm_mapping_symbol(const char *str)
@@ -112,2 +73 @@
-static int
-read_symbol(FILE *in, struct sym_entry *s)
+static int read_symbol(FILE *in, struct sym_entry *s)
@@ -116 +76 @@
-	char *sym;
+	char *sym, stype;
@@ -119 +79 @@
-	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &s->type, str);
+	rc = fscanf(in, "%llx %c %499s\n", &s->addr, &stype, str);
@@ -146 +106 @@
-	else if (toupper(s->type) == 'A')
+	else if (toupper(stype) == 'A')
@@ -156 +116 @@
-	else if (toupper(s->type) == 'U' ||
+	else if (toupper(stype) == 'U' ||
@@ -158,0 +119,3 @@
+	/* exclude also MIPS ELF local symbols ($L123 instead of .L123) */
+	else if (str[0] == '$')
+		return -1;
@@ -163,3 +126,3 @@
-	s->sym = (char *) malloc(s->len + 1);
-	strcpy(s->sym + 1, str);
-	s->sym[0] = s->type;
+	s->sym = malloc(s->len + 1);
+	strcpy((char *)s->sym + 1, str);
+	s->sym[0] = stype;
@@ -170,2 +133 @@
-static int
-symbol_valid(struct sym_entry *s)
+static int symbol_valid(struct sym_entry *s)
@@ -210,3 +172,3 @@
-		if ((s->addr == _etext && strcmp(s->sym + offset, "_etext")) ||
-		    (s->addr == _einittext && strcmp(s->sym + offset, "_einittext")) ||
-		    (s->addr == _eextratext && strcmp(s->sym + offset, "_eextratext")))
+		if ((s->addr == _etext && strcmp((char*)s->sym + offset, "_etext")) ||
+		    (s->addr == _einittext && strcmp((char*)s->sym + offset, "_einittext")) ||
+		    (s->addr == _eextratext && strcmp((char*)s->sym + offset, "_eextratext")))
@@ -217 +179 @@
-	if (strstr(s->sym + offset, "_compiled."))
+	if (strstr((char *)s->sym + offset, "_compiled."))
@@ -221 +183 @@
-		if( strcmp(s->sym + offset, special_symbols[i]) == 0 )
+		if( strcmp((char *)s->sym + offset, special_symbols[i]) == 0 )
@@ -227,2 +189 @@
-static void
-read_map(FILE *in)
+static void read_map(FILE *in)
@@ -231,3 +192,3 @@
-		if (cnt >= size) {
-			size += 10000;
-			table = realloc(table, sizeof(*table) * size);
+		if (table_cnt >= table_size) {
+			table_size += 10000;
+			table = realloc(table, sizeof(*table) * table_size);
@@ -239,2 +200,2 @@
-		if (read_symbol(in, &table[cnt]) == 0)
-			cnt++;
+		if (read_symbol(in, &table[table_cnt]) == 0)
+			table_cnt++;
@@ -284,2 +245 @@
-static void
-write_src(void)
+static void write_src(void)
@@ -287 +247 @@
-	int i, k, off, valid;
+	unsigned int i, k, off;
@@ -304,6 +264,2 @@
-	valid = 0;
-	for (i = 0; i < cnt; i++) {
-		if (table[i].flags & SYM_FLAG_VALID) {
-			printf("\tPTR\t%#llx\n", table[i].addr);
-			valid++;
-		}
+	for (i = 0; i < table_cnt; i++) {
+		printf("\tPTR\t%#llx\n", table[i].addr);
@@ -314 +270 @@
-	printf("\tPTR\t%d\n", valid);
+	printf("\tPTR\t%d\n", table_cnt);
@@ -319 +275 @@
-	markers = (unsigned int *) malloc(sizeof(unsigned int)*((valid + 255) / 256));
+	markers = (unsigned int *) malloc(sizeof(unsigned int) * ((table_cnt + 255) / 256));
@@ -322 +277,0 @@
-	valid = 0;
@@ -324,7 +279,3 @@
-	for (i = 0; i < cnt; i++) {
-
-		if (!table[i].flags & SYM_FLAG_VALID)
-			continue;
-
-		if ((valid & 0xFF) == 0)
-			markers[valid >> 8] = off;
+	for (i = 0; i < table_cnt; i++) {
+		if ((i & 0xFF) == 0)
+			markers[i >> 8] = off;
@@ -338 +288,0 @@
-		valid++;
@@ -343 +293 @@
-	for (i = 0; i < ((valid + 255) >> 8); i++)
+	for (i = 0; i < ((table_cnt + 255) >> 8); i++)
@@ -353 +303 @@
-		expand_symbol(best_table[i],best_table_len[i],buf);
+		expand_symbol(best_table[i], best_table_len[i], buf);
@@ -368,140 +317,0 @@
-static inline unsigned int rehash_token(unsigned int hash, unsigned char data)
-{
-	return ((hash * 16777619) ^ data);
-}
-
-static unsigned int hash_token(unsigned char *data, int len)
-{
-	unsigned int hash=HASH_BASE_OFFSET;
-	int i;
-
-	for (i = 0; i < len; i++)
-		hash = rehash_token(hash, data[i]);
-
-	return HASH_FOLD(hash);
-}
-
-/* find a token given its data and hash value */
-static struct token *find_token_hash(unsigned char *data, int len, unsigned int hash)
-{
-	struct token *ptr;
-
-	ptr = hash_table[hash];
-
-	while (ptr) {
-		if ((ptr->len == len) && (memcmp(ptr->data, data, len) == 0))
-			return ptr;
-		ptr=ptr->next;
-	}
-
-	return NULL;
-}
-
-static inline void insert_token_in_group(struct token *head, struct token *ptr)
-{
-	ptr->right = head->right;
-	ptr->right->left = ptr;
-	head->right = ptr;
-	ptr->left = head;
-}
-
-static inline void remove_token_from_group(struct token *ptr)
-{
-	ptr->left->right = ptr->right;
-	ptr->right->left = ptr->left;
-}
-
-
-/* build the counts for all the tokens that start with "data", and have lenghts
- * from 2 to "len" */
-static void learn_token(unsigned char *data, int len)
-{
-	struct token *ptr,*last_ptr;
-	int i, newprofit;
-	unsigned int hash = HASH_BASE_OFFSET;
-	unsigned int hashes[MAX_TOK_SIZE + 1];
-
-	if (len > MAX_TOK_SIZE)
-		len = MAX_TOK_SIZE;
-
-	/* calculate and store the hash values for all the sub-tokens */
-	hash = rehash_token(hash, data[0]);
-	for (i = 2; i <= len; i++) {
-		hash = rehash_token(hash, data[i-1]);
-		hashes[i] = HASH_FOLD(hash);
-	}
-
-	last_ptr = NULL;
-	ptr = NULL;
-
-	for (i = len; i >= 2; i--) {
-		hash = hashes[i];
-
-		if (!ptr) ptr = find_token_hash(data, i, hash);
-
-		if (!ptr) {
-			/* create a new token entry */
-			ptr = (struct token *) malloc(sizeof(*ptr));
-
-			memcpy(ptr->data, data, i);
-			ptr->len = i;
-
-			/* when we create an entry, it's profit is 0 because
-			 * we also take into account the size of the token on
-			 * the compressed table. We then subtract GOOD_BAD_THRESHOLD
-			 * so that the test to see if this token belongs to
-			 * the good or bad list, is a comparison to zero */
-			ptr->profit = -GOOD_BAD_THRESHOLD;
-
-			ptr->next = hash_table[hash];
-			hash_table[hash] = ptr;
-
-			insert_token_in_group(&bad_head, ptr);
-
-			ptr->smaller = NULL;
-		} else {
-			newprofit = ptr->profit + (ptr->len - 1);
-			/* check to see if this token needs to be moved to a
-			 * different list */
-			if((ptr->profit < 0) && (newprofit >= 0)) {
-				remove_token_from_group(ptr);
-				insert_token_in_group(&good_head,ptr);
-			}
-			ptr->profit = newprofit;
-		}
-
-		if (last_ptr) last_ptr->smaller = ptr;
-		last_ptr = ptr;
-
-		ptr = ptr->smaller;
-	}
-}
-
-/* decrease the counts for all the tokens that start with "data", and have lenghts
- * from 2 to "len". This function is much simpler than learn_token because we have
- * more guarantees (tho tokens exist, the ->smaller pointer is set, etc.)
- * The two separate functions exist only because of compression performance */
-static void forget_token(unsigned char *data, int len)
-{
-	struct token *ptr;
-	int i, newprofit;
-	unsigned int hash=0;
-
-	if (len > MAX_TOK_SIZE) len = MAX_TOK_SIZE;
-
-	hash = hash_token(data, len);
-	ptr = find_token_hash(data, len, hash);
-
-	for (i = len; i >= 2; i--) {
-
-		newprofit = ptr->profit - (ptr->len - 1);
-		if ((ptr->profit >= 0) && (newprofit < 0)) {
-			remove_token_from_group(ptr);
-			insert_token_in_group(&bad_head, ptr);
-		}
-		ptr->profit=newprofit;
-
-		ptr=ptr->smaller;
-	}
-}
-
@@ -514 +324 @@
-		learn_token(symbol + i, len - i);
+		token_profit[ symbol[i] + (symbol[i + 1] << 8) ]++;
@@ -523 +333 @@
-		forget_token(symbol + i, len - i);
+		token_profit[ symbol[i] + (symbol[i + 1] << 8) ]--;
@@ -526 +336 @@
-/* set all the symbol flags and do the initial token count */
+/* remove all the invalid symbols from the table and do the initial token count */
@@ -529 +339 @@
-	int i, use_it, valid;
+	unsigned int i, pos;
@@ -531,3 +341,2 @@
-	valid = 0;
-	for (i = 0; i < cnt; i++) {
-		table[i].flags = 0;
+	pos = 0;
+	for (i = 0; i < table_cnt; i++) {
@@ -535,2 +344,4 @@
-			table[i].flags |= SYM_FLAG_VALID;
-			valid++;
+			if (pos != i)
+				table[pos] = table[i];
+			learn_symbol(table[pos].sym, table[pos].len);
+			pos++;
@@ -539,19 +350 @@
-
-	use_it = 0;
-	for (i = 0; i < cnt; i++) {
-
-		/* subsample the available symbols. This method is almost like
-		 * a Bresenham's algorithm to get uniformly distributed samples
-		 * across the symbol table */
-		if (table[i].flags & SYM_FLAG_VALID) {
-
-			use_it += WORKING_SET;
-
-			if (use_it >= valid) {
-				table[i].flags |= SYM_FLAG_SAMPLED;
-				use_it -= valid;
-			}
-		}
-		if (table[i].flags & SYM_FLAG_SAMPLED)
-			learn_symbol(table[i].sym, table[i].len);
-	}
+	table_cnt = pos;
@@ -562 +355 @@
-static void compress_symbols(unsigned char *str, int tlen, int idx)
+static void compress_symbols(unsigned char *str, int idx)
@@ -564,2 +357,2 @@
-	int i, len, learn, size;
-	unsigned char *p;
+	unsigned int i, len, size;
+	unsigned char *p1, *p2;
@@ -567,3 +360 @@
-	for (i = 0; i < cnt; i++) {
-
-		if (!(table[i].flags & SYM_FLAG_VALID)) continue;
+	for (i = 0; i < table_cnt; i++) {
@@ -572,2 +363,10 @@
-		learn = 0;
-		p = table[i].sym;
+		p1 = table[i].sym;
+
+		/* find the token on the symbol */
+		p2 = memmem(p1, len, str, 2);
+		if (!p2) continue;
+
+		/* decrease the counts for this symbol's tokens */
+		forget_symbol(table[i].sym, len);
+
+		size = len;
@@ -575,0 +375,9 @@
+			*p2 = idx;
+			p2++;
+			size -= (p2 - p1);
+			memmove(p2, p2 + 1, size);
+			p1 = p2;
+			len--;
+
+			if (size < 2) break;
+
@@ -577,2 +385 @@
-			p = (unsigned char *) strstr((char *) p, (char *) str);
-			if (!p) break;
+			p2 = memmem(p1, size, str, 2);
@@ -580,6 +387 @@
-			if (!learn) {
-				/* if this symbol was used to count, decrease it */
-				if (table[i].flags & SYM_FLAG_SAMPLED)
-					forget_symbol(table[i].sym, len);
-				learn = 1;
-			}
+		} while (p2);
@@ -587,14 +389,4 @@
-			*p = idx;
-			size = (len - (p - table[i].sym)) - tlen + 1;
-			memmove(p + 1, p + tlen, size);
-			p++;
-			len -= tlen - 1;
-
-		} while (size >= tlen);
-
-		if(learn) {
-			table[i].len = len;
-			/* if this symbol was used to count, learn it again */
-			if(table[i].flags & SYM_FLAG_SAMPLED)
-				learn_symbol(table[i].sym, len);
-		}
+		table[i].len = len;
+
+		/* increase the counts for this symbol's new tokens */
+		learn_symbol(table[i].sym, len);
@@ -605 +397 @@
-static struct token *find_best_token(void)
+static int find_best_token(void)
@@ -607,2 +399 @@
-	struct token *ptr,*best,*head;
-	int bestprofit;
+	int i, best, bestprofit;
@@ -610,0 +402 @@
+	best = 0;
@@ -612,10 +404,4 @@
-	/* failsafe: if the "good" list is empty search from the "bad" list */
-	if(good_head.right == &good_head) head = &bad_head;
-	else head = &good_head;
-
-	ptr = head->right;
-	best = NULL;
-	while (ptr != head) {
-		if (ptr->profit > bestprofit) {
-			bestprofit = ptr->profit;
-			best = ptr;
+	for (i = 0; i < 0x10000; i++) {
+		if (token_profit[i] > bestprofit) {
+			best = i;
+			bestprofit = token_profit[i];
@@ -623 +408,0 @@
-		ptr = ptr->right;
@@ -625 +409,0 @@
-
@@ -632,2 +416 @@
-	struct token *best;
-	int i;
+	int i, best;
@@ -647,5 +430,3 @@
-			best_table_len[i] = best->len;
-			memcpy(best_table[i], best->data, best_table_len[i]);
-			/* zero terminate the token so that we can use strstr
-			   in compress_symbols */
-			best_table[i][best_table_len[i]]='\0';
+			best_table_len[i] = 2;
+			best_table[i][0] = best & 0xFF;
+			best_table[i][1] = (best >> 8) & 0xFF;
@@ -654 +435 @@
-			compress_symbols(best_table[i], best_table_len[i], i);
+			compress_symbols(best_table[i], i);
@@ -662 +443 @@
-	int i, j, c;
+	unsigned int i, j, c;
@@ -667,7 +448,5 @@
-	for (i = 0; i < cnt; i++) {
-		if (table[i].flags & SYM_FLAG_VALID) {
-			for (j = 0; j < table[i].len; j++) {
-				c = table[i].sym[j];
-				best_table[c][0]=c;
-				best_table_len[c]=1;
-			}
+	for (i = 0; i < table_cnt; i++) {
+		for (j = 0; j < table[i].len; j++) {
+			c = table[i].sym[j];
+			best_table[c][0]=c;
+			best_table_len[c]=1;
@@ -680,8 +458,0 @@
-	memset(hash_table, 0, sizeof(hash_table));
-
-	good_head.left = &good_head;
-	good_head.right = &good_head;
-
-	bad_head.left = &bad_head;
-	bad_head.right = &bad_head;
-
@@ -693,2 +464 @@
-	if (good_head.left == good_head.right &&
-	    bad_head.left == bad_head.right) {
+	if (!table_cnt) {
@@ -703,2 +473 @@
-int
-main(int argc, char **argv)
+int main(int argc, char **argv)
--- ./projects/linux/linux-2.6.16/scripts/kallsyms.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/scripts/kallsyms.c	2006-06-18 03:49:35.000000000 +0200
@@ -126,0 +127,5 @@
+	if (!s->sym) {
+		fprintf(stderr, "kallsyms failure: "
+			"unable to allocate required amount of memory\n");
+		exit(EXIT_FAILURE);
+	}
@@ -275 +280,6 @@
-	markers = (unsigned int *) malloc(sizeof(unsigned int) * ((table_cnt + 255) / 256));
+	markers = malloc(sizeof(unsigned int) * ((table_cnt + 255) / 256));
+	if (!markers) {
+		fprintf(stderr, "kallsyms failure: "
+			"unable to allocate required memory\n");
+		exit(EXIT_FAILURE);
+	}
--- ./projects/linux/linux-2.6.19/scripts/kallsyms.c	2006-11-29 22:57:37.000000000 +0100
+++ ./projects/linux/linux-2.6.20/scripts/kallsyms.c	2007-02-04 19:44:54.000000000 +0100
@@ -46 +46 @@
-static unsigned long long _stext, _etext, _sinittext, _einittext, _sextratext, _eextratext;
+static unsigned long long _text, _stext, _etext, _sinittext, _einittext, _sextratext, _eextratext;
@@ -94 +94,3 @@
-	if (strcmp(sym, "_stext") == 0)
+	if (strcmp(sym, "_text") == 0)
+		_text = s->addr;
+	else if (strcmp(sym, "_stext") == 0)
@@ -266 +268 @@
-	printf(".data\n");
+	printf("\t.section .rodata, \"a\"\n");
@@ -267,0 +270,7 @@
+	/* Provide proper symbols relocatability by their '_text'
+	 * relativeness.  The symbol names cannot be used to construct
+	 * normal symbol references as the list of symbols contains
+	 * symbols that are declared static and are private to their
+	 * .o files.  This prevents .tmp_kallsyms.o or any other
+	 * object from referencing them.
+	 */
@@ -270 +279,10 @@
-		printf("\tPTR\t%#llx\n", table[i].addr);
+		if (toupper(table[i].sym[0]) != 'A') {
+			if (_text <= table[i].addr)
+				printf("\tPTR\t_text + %#llx\n",
+					table[i].addr - _text);
+			else
+				printf("\tPTR\t_text - %#llx\n",
+					_text - table[i].addr);
+		} else {
+			printf("\tPTR\t%#llx\n", table[i].addr);
+		}
--- ./projects/linux/linux-2.6.22/scripts/kallsyms.c	2007-07-09 01:32:17.000000000 +0200
+++ ./projects/linux/linux-2.6.23/scripts/kallsyms.c	2007-10-09 22:31:38.000000000 +0200
@@ -27,2 +26,0 @@
-#define _GNU_SOURCE
-
@@ -34 +32 @@
-#define KSYM_NAME_LEN		127
+#define KSYM_NAME_LEN		128
@@ -257 +255 @@
-	char buf[KSYM_NAME_LEN+1];
+	char buf[KSYM_NAME_LEN];
@@ -380,0 +379,11 @@
+static void *find_token(unsigned char *str, int len, unsigned char *token)
+{
+	int i;
+
+	for (i = 0; i < len - 1; i++) {
+		if (str[i] == token[0] && str[i+1] == token[1])
+			return &str[i];
+	}
+	return NULL;
+}
+
@@ -394 +403 @@
-		p2 = memmem(p1, len, str, 2);
+		p2 = find_token(p1, len, str);
@@ -413 +422 @@
-			p2 = memmem(p1, size, str, 2);
+			p2 = find_token(p1, size, str);
--- ./projects/linux/linux-2.6.24/scripts/kallsyms.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/scripts/kallsyms.c	2008-04-17 04:49:44.000000000 +0200
@@ -34 +33,0 @@
-
@@ -37,0 +37 @@
+	unsigned int start_pos;
@@ -41 +40,0 @@
-
@@ -44 +43 @@
-static unsigned long long _text, _stext, _etext, _sinittext, _einittext, _sextratext, _eextratext;
+static unsigned long long _text, _stext, _etext, _sinittext, _einittext;
@@ -102,4 +100,0 @@
-	else if (strcmp(sym, "_sextratext") == 0)
-		_sextratext = s->addr;
-	else if (strcmp(sym, "_eextratext") == 0)
-		_eextratext = s->addr;
@@ -168,2 +163 @@
-		    && (s->addr < _sinittext || s->addr > _einittext)
-		    && (s->addr < _sextratext || s->addr > _eextratext))
+		    && (s->addr < _sinittext || s->addr > _einittext))
@@ -172,4 +166,4 @@
-		 * _etext _einittext or _eextratext; they can move between pass
-		 * 1 and 2 when the kallsyms data are added.  If these symbols
-		 * move then they may get dropped in pass 2, which breaks the
-		 * kallsyms rules.
+		 * _etext _einittext; they can move between pass 1 and 2 when
+		 * the kallsyms data are added.  If these symbols move then
+		 * they may get dropped in pass 2, which breaks the kallsyms
+		 * rules.
@@ -177,3 +171,4 @@
-		if ((s->addr == _etext && strcmp((char*)s->sym + offset, "_etext")) ||
-		    (s->addr == _einittext && strcmp((char*)s->sym + offset, "_einittext")) ||
-		    (s->addr == _eextratext && strcmp((char*)s->sym + offset, "_eextratext")))
+		if ((s->addr == _etext &&
+				strcmp((char *)s->sym + offset, "_etext")) ||
+		    (s->addr == _einittext &&
+				strcmp((char *)s->sym + offset, "_einittext")))
@@ -205 +200,2 @@
-		if (read_symbol(in, &table[table_cnt]) == 0)
+		if (read_symbol(in, &table[table_cnt]) == 0) {
+			table[table_cnt].start_pos = table_cnt;
@@ -206,0 +203 @@
+		}
@@ -508,0 +506,29 @@
+static int compare_symbols(const void *a, const void *b)
+{
+	const struct sym_entry *sa;
+	const struct sym_entry *sb;
+	int wa, wb;
+
+	sa = a;
+	sb = b;
+
+	/* sort by address first */
+	if (sa->addr > sb->addr)
+		return 1;
+	if (sa->addr < sb->addr)
+		return -1;
+
+	/* sort by "weakness" type */
+	wa = (sa->sym[0] == 'w') || (sa->sym[0] == 'W');
+	wb = (sb->sym[0] == 'w') || (sb->sym[0] == 'W');
+	if (wa != wb)
+		return wa - wb;
+
+	/* sort by initial order, so that other symbols are left undisturbed */
+	return sa->start_pos - sb->start_pos;
+}
+
+static void sort_symbols(void)
+{
+	qsort(table, table_cnt, sizeof(struct sym_entry), compare_symbols);
+}
@@ -529,0 +556 @@
+	sort_symbols();
--- ./projects/linux/linux-2.6.25/scripts/kallsyms.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/scripts/kallsyms.c	2008-07-13 23:51:29.000000000 +0200
@@ -10,6 +9,0 @@
- * ChangeLog:
- *
- * (25/Aug/2004) Paulo Marques <pmarques@grupopie.com>
- *      Changed the compression method from stem compression to "table lookup"
- *      compression
- *
@@ -116,0 +111,3 @@
+	/* exclude debugging symbols */
+	else if (stype == 'N')
+		return -1;
--- ./projects/linux/linux-2.6.29/scripts/kallsyms.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/scripts/kallsyms.c	2009-06-27 11:32:33.000000000 +0200
@@ -502,0 +503,45 @@
+/* guess for "linker script provide" symbol */
+static int may_be_linker_script_provide_symbol(const struct sym_entry *se)
+{
+	const char *symbol = (char *)se->sym + 1;
+	int len = se->len - 1;
+
+	if (len < 8)
+		return 0;
+
+	if (symbol[0] != '_' || symbol[1] != '_')
+		return 0;
+
+	/* __start_XXXXX */
+	if (!memcmp(symbol + 2, "start_", 6))
+		return 1;
+
+	/* __stop_XXXXX */
+	if (!memcmp(symbol + 2, "stop_", 5))
+		return 1;
+
+	/* __end_XXXXX */
+	if (!memcmp(symbol + 2, "end_", 4))
+		return 1;
+
+	/* __XXXXX_start */
+	if (!memcmp(symbol + len - 6, "_start", 6))
+		return 1;
+
+	/* __XXXXX_end */
+	if (!memcmp(symbol + len - 4, "_end", 4))
+		return 1;
+
+	return 0;
+}
+
+static int prefix_underscores_count(const char *str)
+{
+	const char *tail = str;
+
+	while (*tail != '_')
+		tail++;
+
+	return tail - str;
+}
+
@@ -523,0 +569,12 @@
+	/* sort by "linker script provide" type */
+	wa = may_be_linker_script_provide_symbol(sa);
+	wb = may_be_linker_script_provide_symbol(sb);
+	if (wa != wb)
+		return wa - wb;
+
+	/* sort by the number of prefix underscores */
+	wa = prefix_underscores_count((const char *)sa->sym + 1);
+	wb = prefix_underscores_count((const char *)sb->sym + 1);
+	if (wa != wb)
+		return wa - wb;
+
--- ./projects/linux/linux-2.6.13/sound/arm/pxa2xx-ac97.c	2005-08-29 01:41:01.000000000 +0200
+++ ./projects/linux/linux-2.6.14/sound/arm/pxa2xx-ac97.c	2005-10-28 02:02:08.000000000 +0200
@@ -135 +135 @@
-		udelay(50);
+		udelay(500);
@@ -137 +137 @@
-		GCR |= GCR_WARM_RST|GCR_PRIRDY_IEN|GCR_SECRDY_IEN;;
+		GCR |= GCR_WARM_RST|GCR_PRIRDY_IEN|GCR_SECRDY_IEN;
@@ -248 +248 @@
-static int pxa2xx_ac97_do_suspend(snd_card_t *card, unsigned int state)
+static int pxa2xx_ac97_do_suspend(snd_card_t *card, pm_message_t state)
@@ -264 +264 @@
-static int pxa2xx_ac97_do_resume(snd_card_t *card, unsigned int state)
+static int pxa2xx_ac97_do_resume(snd_card_t *card)
@@ -278 +278 @@
-static int pxa2xx_ac97_suspend(struct device *_dev, u32 state, u32 level)
+static int pxa2xx_ac97_suspend(struct device *_dev, pm_message_t state, u32 level)
@@ -284 +284 @@
-		ret = pxa2xx_ac97_do_suspend(card, SNDRV_CTL_POWER_D3cold);
+		ret = pxa2xx_ac97_do_suspend(card, PMSG_SUSPEND);
@@ -295 +295 @@
-		ret = pxa2xx_ac97_do_resume(card, SNDRV_CTL_POWER_D0);
+		ret = pxa2xx_ac97_do_resume(card);
--- ./projects/linux/linux-2.6.14/sound/arm/pxa2xx-ac97.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/sound/arm/pxa2xx-ac97.c	2006-01-03 04:21:10.000000000 +0100
@@ -16 +16 @@
-#include <linux/device.h>
+#include <linux/platform_device.h>
@@ -278 +278 @@
-static int pxa2xx_ac97_suspend(struct device *_dev, pm_message_t state, u32 level)
+static int pxa2xx_ac97_suspend(struct platform_device *dev, pm_message_t state)
@@ -280 +280 @@
-	snd_card_t *card = dev_get_drvdata(_dev);
+	snd_card_t *card = platform_get_drvdata(dev);
@@ -283 +283 @@
-	if (card && level == SUSPEND_DISABLE)
+	if (card)
@@ -289 +289 @@
-static int pxa2xx_ac97_resume(struct device *_dev, u32 level)
+static int pxa2xx_ac97_resume(struct platform_device *dev)
@@ -291 +291 @@
-	snd_card_t *card = dev_get_drvdata(_dev);
+	snd_card_t *card = platform_get_drvdata(dev);
@@ -294 +294 @@
-	if (card && level == RESUME_ENABLE)
+	if (card)
@@ -305 +305 @@
-static int pxa2xx_ac97_probe(struct device *dev)
+static int pxa2xx_ac97_probe(struct platform_device *dev)
@@ -318,2 +318,2 @@
-	card->dev = dev;
-	strncpy(card->driver, dev->driver->name, sizeof(card->driver));
+	card->dev = &dev->dev;
+	strncpy(card->driver, dev->dev.driver->name, sizeof(card->driver));
@@ -350 +350 @@
-		 "%s (%s)", dev->driver->name, card->mixername);
+		 "%s (%s)", dev->dev.driver->name, card->mixername);
@@ -356 +356 @@
-		dev_set_drvdata(dev, card);
+		platform_set_drvdata(dev, card);
@@ -371 +371 @@
-static int pxa2xx_ac97_remove(struct device *dev)
+static int pxa2xx_ac97_remove(struct platform_device *dev)
@@ -373 +373 @@
-	snd_card_t *card = dev_get_drvdata(dev);
+	snd_card_t *card = platform_get_drvdata(dev);
@@ -377 +377 @@
-		dev_set_drvdata(dev, NULL);
+		platform_set_drvdata(dev, NULL);
@@ -386,3 +386 @@
-static struct device_driver pxa2xx_ac97_driver = {
-	.name		= "pxa2xx-ac97",
-	.bus		= &platform_bus_type,
+static struct platform_driver pxa2xx_ac97_driver = {
@@ -392,0 +391,3 @@
+	.driver		= {
+		.name	= "pxa2xx-ac97",
+	},
@@ -397 +398 @@
-	return driver_register(&pxa2xx_ac97_driver);
+	return platform_driver_register(&pxa2xx_ac97_driver);
@@ -402 +403 @@
-	driver_unregister(&pxa2xx_ac97_driver);
+	platform_driver_unregister(&pxa2xx_ac97_driver);
--- ./projects/linux/linux-2.6.15/sound/arm/pxa2xx-ac97.c	2006-01-03 04:21:10.000000000 +0100
+++ ./projects/linux/linux-2.6.16/sound/arm/pxa2xx-ac97.c	2006-03-20 06:53:29.000000000 +0100
@@ -40 +40,11 @@
-static unsigned short pxa2xx_ac97_read(ac97_t *ac97, unsigned short reg)
+/*
+ * Beware PXA27x bugs:
+ *
+ *   o Slot 12 read from modem space will hang controller.
+ *   o CDONE, SDONE interrupt fails after any slot 12 IO.
+ *
+ * We therefore have an hybrid approach for waiting on SDONE (interrupt or
+ * 1 jiffy timeout if interrupt never comes).
+ */ 
+
+static unsigned short pxa2xx_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
@@ -46,4 +55,0 @@
-	if (CAR & CAR_CAIP) {
-		printk(KERN_CRIT"%s: CAR_CAIP already set\n", __FUNCTION__);
-		goto out;
-	}
@@ -55,0 +62 @@
+	GSR = GSR_CDONE | GSR_SDONE;
@@ -60,2 +67,2 @@
-	wait_event_timeout(gsr_wq, gsr_bits & GSR_SDONE, 1);
-	if (!gsr_bits & GSR_SDONE) {
+	if (wait_event_timeout(gsr_wq, (GSR | gsr_bits) & GSR_SDONE, 1) <= 0 &&
+	    !((GSR | gsr_bits) & GSR_SDONE)) {
@@ -63 +70 @@
-				__FUNCTION__, reg, gsr_bits);
+				__FUNCTION__, reg, GSR | gsr_bits);
@@ -68,0 +76 @@
+	GSR = GSR_CDONE | GSR_SDONE;
@@ -72 +80 @@
-	wait_event_timeout(gsr_wq, gsr_bits & GSR_SDONE, 1);
+	wait_event_timeout(gsr_wq, (GSR | gsr_bits) & GSR_SDONE, 1);
@@ -78 +86 @@
-static void pxa2xx_ac97_write(ac97_t *ac97, unsigned short reg, unsigned short val)
+static void pxa2xx_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)
@@ -84,5 +91,0 @@
-	if (CAR & CAR_CAIP) {
-		printk(KERN_CRIT "%s: CAR_CAIP already set\n", __FUNCTION__);
-		goto out;
-	}
-
@@ -91,0 +95,2 @@
+
+	GSR = GSR_CDONE | GSR_SDONE;
@@ -94,2 +99,2 @@
-	wait_event_timeout(gsr_wq, gsr_bits & GSR_CDONE, 1);
-	if (!gsr_bits & GSR_SDONE)
+	if (wait_event_timeout(gsr_wq, (GSR | gsr_bits) & GSR_CDONE, 1) <= 0 &&
+	    !((GSR | gsr_bits) & GSR_CDONE))
@@ -97 +102 @@
-				__FUNCTION__, reg, gsr_bits);
+				__FUNCTION__, reg, GSR | gsr_bits);
@@ -99 +104 @@
-out:	up(&car_mutex);
+	up(&car_mutex);
@@ -102 +107 @@
-static void pxa2xx_ac97_reset(ac97_t *ac97)
+static void pxa2xx_ac97_reset(struct snd_ac97 *ac97)
@@ -175 +180 @@
-static ac97_bus_ops_t pxa2xx_ac97_ops = {
+static struct snd_ac97_bus_ops pxa2xx_ac97_ops = {
@@ -181 +186 @@
-static pxa2xx_pcm_dma_params_t pxa2xx_ac97_pcm_out = {
+static struct pxa2xx_pcm_dma_params pxa2xx_ac97_pcm_out = {
@@ -189 +194 @@
-static pxa2xx_pcm_dma_params_t pxa2xx_ac97_pcm_in = {
+static struct pxa2xx_pcm_dma_params pxa2xx_ac97_pcm_in = {
@@ -197,2 +202,2 @@
-static snd_pcm_t *pxa2xx_ac97_pcm;
-static ac97_t *pxa2xx_ac97_ac97;
+static struct snd_pcm *pxa2xx_ac97_pcm;
+static struct snd_ac97 *pxa2xx_ac97_ac97;
@@ -200 +205 @@
-static int pxa2xx_ac97_pcm_startup(snd_pcm_substream_t *substream)
+static int pxa2xx_ac97_pcm_startup(struct snd_pcm_substream *substream)
@@ -202 +207 @@
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -221 +226 @@
-static void pxa2xx_ac97_pcm_shutdown(snd_pcm_substream_t *substream)
+static void pxa2xx_ac97_pcm_shutdown(struct snd_pcm_substream *substream)
@@ -230 +235 @@
-static int pxa2xx_ac97_pcm_prepare(snd_pcm_substream_t *substream)
+static int pxa2xx_ac97_pcm_prepare(struct snd_pcm_substream *substream)
@@ -232 +237 @@
-	snd_pcm_runtime_t *runtime = substream->runtime;
+	struct snd_pcm_runtime *runtime = substream->runtime;
@@ -238 +243 @@
-static pxa2xx_pcm_client_t pxa2xx_ac97_pcm_client = {
+static struct pxa2xx_pcm_client pxa2xx_ac97_pcm_client = {
@@ -248 +253 @@
-static int pxa2xx_ac97_do_suspend(snd_card_t *card, pm_message_t state)
+static int pxa2xx_ac97_do_suspend(struct snd_card *card, pm_message_t state)
@@ -250,10 +255,9 @@
-	if (card->power_state != SNDRV_CTL_POWER_D3cold) {
-		pxa2xx_audio_ops_t *platform_ops = card->dev->platform_data;
-		snd_pcm_suspend_all(pxa2xx_ac97_pcm);
-		snd_ac97_suspend(pxa2xx_ac97_ac97);
-		snd_power_change_state(card, SNDRV_CTL_POWER_D3cold);
-		if (platform_ops && platform_ops->suspend)
-			platform_ops->suspend(platform_ops->priv);
-		GCR |= GCR_ACLINK_OFF;
-		pxa_set_cken(CKEN2_AC97, 0);
-	}
+	pxa2xx_audio_ops_t *platform_ops = card->dev->platform_data;
+
+	snd_power_change_state(card, SNDRV_CTL_POWER_D3cold);
+	snd_pcm_suspend_all(pxa2xx_ac97_pcm);
+	snd_ac97_suspend(pxa2xx_ac97_ac97);
+	if (platform_ops && platform_ops->suspend)
+		platform_ops->suspend(platform_ops->priv);
+	GCR |= GCR_ACLINK_OFF;
+	pxa_set_cken(CKEN2_AC97, 0);
@@ -264 +268 @@
-static int pxa2xx_ac97_do_resume(snd_card_t *card)
+static int pxa2xx_ac97_do_resume(struct snd_card *card)
@@ -266,8 +270,7 @@
-	if (card->power_state != SNDRV_CTL_POWER_D0) {
-		pxa2xx_audio_ops_t *platform_ops = card->dev->platform_data;
-		pxa_set_cken(CKEN2_AC97, 1);
-		if (platform_ops && platform_ops->resume)
-			platform_ops->resume(platform_ops->priv);
-		snd_ac97_resume(pxa2xx_ac97_ac97);
-		snd_power_change_state(card, SNDRV_CTL_POWER_D0);
-	}
+	pxa2xx_audio_ops_t *platform_ops = card->dev->platform_data;
+
+	pxa_set_cken(CKEN2_AC97, 1);
+	if (platform_ops && platform_ops->resume)
+		platform_ops->resume(platform_ops->priv);
+	snd_ac97_resume(pxa2xx_ac97_ac97);
+	snd_power_change_state(card, SNDRV_CTL_POWER_D0);
@@ -280 +283 @@
-	snd_card_t *card = platform_get_drvdata(dev);
+	struct snd_card *card = platform_get_drvdata(dev);
@@ -291 +294 @@
-	snd_card_t *card = platform_get_drvdata(dev);
+	struct snd_card *card = platform_get_drvdata(dev);
@@ -307,3 +310,3 @@
-	snd_card_t *card;
-	ac97_bus_t *ac97_bus;
-	ac97_template_t ac97_template;
+	struct snd_card *card;
+	struct snd_ac97_bus *ac97_bus;
+	struct snd_ac97_template ac97_template;
@@ -352,2 +354,0 @@
-	snd_card_set_pm_callback(card, pxa2xx_ac97_do_suspend,
-				 pxa2xx_ac97_do_resume, NULL);
@@ -373 +374 @@
-	snd_card_t *card = platform_get_drvdata(dev);
+	struct snd_card *card = platform_get_drvdata(dev);
--- ./projects/linux/linux-2.6.16/sound/arm/pxa2xx-ac97.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/sound/arm/pxa2xx-ac97.c	2006-06-18 03:49:35.000000000 +0200
@@ -28 +28 @@
-#include <asm/semaphore.h>
+#include <linux/mutex.h>
@@ -36 +36 @@
-static DECLARE_MUTEX(car_mutex);
+static DEFINE_MUTEX(car_mutex);
@@ -55 +55 @@
-	down(&car_mutex);
+	mutex_lock(&car_mutex);
@@ -82 +82 @@
-out:	up(&car_mutex);
+out:	mutex_unlock(&car_mutex);
@@ -90 +90 @@
-	down(&car_mutex);
+	mutex_lock(&car_mutex);
@@ -104 +104 @@
-	up(&car_mutex);
+	mutex_unlock(&car_mutex);
--- ./projects/linux/linux-2.6.18/sound/arm/pxa2xx-ac97.c	2006-09-20 05:42:06.000000000 +0200
+++ ./projects/linux/linux-2.6.19/sound/arm/pxa2xx-ac97.c	2006-11-29 22:57:37.000000000 +0100
@@ -155 +155 @@
-static irqreturn_t pxa2xx_ac97_irq(int irq, void *dev_id, struct pt_regs *regs)
+static irqreturn_t pxa2xx_ac97_irq(int irq, void *dev_id)
--- ./projects/linux/linux-2.6.20/sound/arm/pxa2xx-ac97.c	2007-02-04 19:44:54.000000000 +0100
+++ ./projects/linux/linux-2.6.21/sound/arm/pxa2xx-ac97.c	2007-04-26 05:08:32.000000000 +0200
@@ -308 +308 @@
-static int pxa2xx_ac97_probe(struct platform_device *dev)
+static int __devinit pxa2xx_ac97_probe(struct platform_device *dev)
@@ -372 +372 @@
-static int pxa2xx_ac97_remove(struct platform_device *dev)
+static int __devexit pxa2xx_ac97_remove(struct platform_device *dev)
@@ -389 +389 @@
-	.remove		= pxa2xx_ac97_remove,
+	.remove		= __devexit_p(pxa2xx_ac97_remove),
--- ./projects/linux/linux-2.6.21/sound/arm/pxa2xx-ac97.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/sound/arm/pxa2xx-ac97.c	2007-07-09 01:32:17.000000000 +0200
@@ -263 +263 @@
-	pxa_set_cken(CKEN2_AC97, 0);
+	pxa_set_cken(CKEN_AC97, 0);
@@ -272 +272 @@
-	pxa_set_cken(CKEN2_AC97, 1);
+	pxa_set_cken(CKEN_AC97, 1);
@@ -340 +340 @@
-	pxa_set_cken(CKEN2_AC97, 1);
+	pxa_set_cken(CKEN_AC97, 1);
@@ -364 +364 @@
-	if (CKEN & CKEN2_AC97) {
+	if (CKEN & (1 << CKEN_AC97)) {
@@ -367 +367 @@
-		pxa_set_cken(CKEN2_AC97, 0);
+		pxa_set_cken(CKEN_AC97, 0);
@@ -381 +381 @@
-		pxa_set_cken(CKEN2_AC97, 0);
+		pxa_set_cken(CKEN_AC97, 0);
--- ./projects/linux/linux-2.6.23/sound/arm/pxa2xx-ac97.c	2007-10-09 22:31:38.000000000 +0200
+++ ./projects/linux/linux-2.6.24/sound/arm/pxa2xx-ac97.c	2008-01-24 23:58:37.000000000 +0100
@@ -116 +116 @@
-	pxa_set_cken(1 << 31, 1);
+	pxa_set_cken(CKEN_AC97CONF, 1);
@@ -118 +118 @@
-	pxa_set_cken(1 << 31, 0);
+	pxa_set_cken(CKEN_AC97CONF, 0);
--- ./projects/linux/linux-2.6.24/sound/arm/pxa2xx-ac97.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/sound/arm/pxa2xx-ac97.c	2008-04-17 04:49:44.000000000 +0200
@@ -21 +20,0 @@
-#include <sound/driver.h>
@@ -354,0 +354 @@
+	snd_card_set_dev(card, &dev->dev);
--- ./projects/linux/linux-2.6.25/sound/arm/pxa2xx-ac97.c	2008-04-17 04:49:44.000000000 +0200
+++ ./projects/linux/linux-2.6.26/sound/arm/pxa2xx-ac97.c	2008-07-13 23:51:29.000000000 +0200
@@ -18,0 +19 @@
+#include <linux/clk.h>
@@ -29,0 +31 @@
+#include <asm/arch/pxa2xx-gpio.h>
@@ -37,0 +40,4 @@
+static struct clk *ac97_clk;
+#ifdef CONFIG_PXA27x
+static struct clk *ac97conf_clk;
+#endif
@@ -69 +75 @@
-				__FUNCTION__, reg, GSR | gsr_bits);
+				__func__, reg, GSR | gsr_bits);
@@ -101 +107 @@
-				__FUNCTION__, reg, GSR | gsr_bits);
+				__func__, reg, GSR | gsr_bits);
@@ -108,0 +115,10 @@
+#ifdef CONFIG_PXA3xx
+	int timeout;
+
+	/* Hold CLKBPB for 100us */
+	GCR = 0;
+	GCR = GCR_CLKBPB;
+	udelay(100);
+	GCR = 0;
+#endif
+
@@ -115 +131 @@
-	pxa_set_cken(CKEN_AC97CONF, 1);
+	clk_enable(ac97conf_clk);
@@ -117 +133 @@
-	pxa_set_cken(CKEN_AC97CONF, 0);
+	clk_disable(ac97conf_clk);
@@ -119,0 +136,8 @@
+#elif defined(CONFIG_PXA3xx)
+	timeout = 1000;
+	/* Can't use interrupts on PXA3xx */
+	GCR &= ~(GCR_PRIRDY_IEN|GCR_SECRDY_IEN);
+
+	GCR = GCR_WARM_RST | GCR_COLD_RST;
+	while (!(GSR & (GSR_PCR | GSR_SCR)) && timeout--)
+		mdelay(10);
@@ -128 +152 @@
-				 __FUNCTION__, gsr_bits);
+				 __func__, gsr_bits);
@@ -139,0 +164,6 @@
+#elif defined(CONFIG_PXA3xx)
+		timeout = 100;
+		/* Can't use interrupts */
+		GCR |= GCR_WARM_RST;
+		while (!((GSR | gsr_bits) & (GSR_PCR | GSR_SCR)) && timeout--)
+			mdelay(1);
@@ -147 +177 @@
-					 __FUNCTION__, gsr_bits);
+					 __func__, gsr_bits);
@@ -262 +292 @@
-	pxa_set_cken(CKEN_AC97, 0);
+	clk_disable(ac97_clk);
@@ -271 +301 @@
-	pxa_set_cken(CKEN_AC97, 1);
+	clk_enable(ac97_clk);
@@ -337,0 +368,6 @@
+	ac97conf_clk = clk_get(&dev->dev, "AC97CONFCLK");
+	if (IS_ERR(ac97conf_clk)) {
+		ret = PTR_ERR(ac97conf_clk);
+		ac97conf_clk = NULL;
+		goto err;
+	}
@@ -339 +375,8 @@
-	pxa_set_cken(CKEN_AC97, 1);
+
+	ac97_clk = clk_get(&dev->dev, "AC97CLK");
+	if (IS_ERR(ac97_clk)) {
+		ret = PTR_ERR(ac97_clk);
+		ac97_clk = NULL;
+		goto err;
+	}
+	clk_enable(ac97_clk);
@@ -364 +407 @@
-	if (CKEN & (1 << CKEN_AC97)) {
+	if (ac97_clk) {
@@ -367 +410,3 @@
-		pxa_set_cken(CKEN_AC97, 0);
+		clk_disable(ac97_clk);
+		clk_put(ac97_clk);
+		ac97_clk = NULL;
@@ -368,0 +414,6 @@
+#ifdef CONFIG_PXA27x
+	if (ac97conf_clk) {
+		clk_put(ac97conf_clk);
+		ac97conf_clk = NULL;
+	}
+#endif
@@ -381 +432,7 @@
-		pxa_set_cken(CKEN_AC97, 0);
+		clk_disable(ac97_clk);
+		clk_put(ac97_clk);
+		ac97_clk = NULL;
+#ifdef CONFIG_PXA27x
+		clk_put(ac97conf_clk);
+		ac97conf_clk = NULL;
+#endif
@@ -393,0 +451 @@
+		.owner	= THIS_MODULE,
@@ -412,0 +471 @@
+MODULE_ALIAS("platform:pxa2xx-ac97");
--- ./projects/linux/linux-2.6.26/sound/arm/pxa2xx-ac97.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/sound/arm/pxa2xx-ac97.c	2008-10-10 00:13:53.000000000 +0200
@@ -29,4 +29,4 @@
-#include <asm/hardware.h>
-#include <asm/arch/pxa-regs.h>
-#include <asm/arch/pxa2xx-gpio.h>
-#include <asm/arch/audio.h>
+#include <mach/hardware.h>
+#include <mach/pxa-regs.h>
+#include <mach/pxa2xx-gpio.h>
+#include <mach/audio.h>
--- ./projects/linux/linux-2.6.27/sound/arm/pxa2xx-ac97.c	2008-10-10 00:13:53.000000000 +0200
+++ ./projects/linux/linux-2.6.28/sound/arm/pxa2xx-ac97.c	2008-12-25 00:26:37.000000000 +0100
@@ -15 +14,0 @@
-#include <linux/kernel.h>
@@ -17,4 +15,0 @@
-#include <linux/interrupt.h>
-#include <linux/wait.h>
-#include <linux/clk.h>
-#include <linux/delay.h>
@@ -25,0 +21 @@
+#include <sound/pxa2xx-lib.h>
@@ -27,2 +22,0 @@
-#include <asm/irq.h>
-#include <linux/mutex.h>
@@ -31 +24,0 @@
-#include <mach/pxa2xx-gpio.h>
@@ -36,76 +28,0 @@
-
-static DEFINE_MUTEX(car_mutex);
-static DECLARE_WAIT_QUEUE_HEAD(gsr_wq);
-static volatile long gsr_bits;
-static struct clk *ac97_clk;
-#ifdef CONFIG_PXA27x
-static struct clk *ac97conf_clk;
-#endif
-
-/*
- * Beware PXA27x bugs:
- *
- *   o Slot 12 read from modem space will hang controller.
- *   o CDONE, SDONE interrupt fails after any slot 12 IO.
- *
- * We therefore have an hybrid approach for waiting on SDONE (interrupt or
- * 1 jiffy timeout if interrupt never comes).
- */ 
-
-static unsigned short pxa2xx_ac97_read(struct snd_ac97 *ac97, unsigned short reg)
-{
-	unsigned short val = -1;
-	volatile u32 *reg_addr;
-
-	mutex_lock(&car_mutex);
-
-	/* set up primary or secondary codec space */
-	reg_addr = (ac97->num & 1) ? &SAC_REG_BASE : &PAC_REG_BASE;
-	reg_addr += (reg >> 1);
-
-	/* start read access across the ac97 link */
-	GSR = GSR_CDONE | GSR_SDONE;
-	gsr_bits = 0;
-	val = *reg_addr;
-	if (reg == AC97_GPIO_STATUS)
-		goto out;
-	if (wait_event_timeout(gsr_wq, (GSR | gsr_bits) & GSR_SDONE, 1) <= 0 &&
-	    !((GSR | gsr_bits) & GSR_SDONE)) {
-		printk(KERN_ERR "%s: read error (ac97_reg=%d GSR=%#lx)\n",
-				__func__, reg, GSR | gsr_bits);
-		val = -1;
-		goto out;
-	}
-
-	/* valid data now */
-	GSR = GSR_CDONE | GSR_SDONE;
-	gsr_bits = 0;
-	val = *reg_addr;			
-	/* but we've just started another cycle... */
-	wait_event_timeout(gsr_wq, (GSR | gsr_bits) & GSR_SDONE, 1);
-
-out:	mutex_unlock(&car_mutex);
-	return val;
-}
-
-static void pxa2xx_ac97_write(struct snd_ac97 *ac97, unsigned short reg, unsigned short val)
-{
-	volatile u32 *reg_addr;
-
-	mutex_lock(&car_mutex);
-
-	/* set up primary or secondary codec space */
-	reg_addr = (ac97->num & 1) ? &SAC_REG_BASE : &PAC_REG_BASE;
-	reg_addr += (reg >> 1);
-
-	GSR = GSR_CDONE | GSR_SDONE;
-	gsr_bits = 0;
-	*reg_addr = val;
-	if (wait_event_timeout(gsr_wq, (GSR | gsr_bits) & GSR_CDONE, 1) <= 0 &&
-	    !((GSR | gsr_bits) & GSR_CDONE))
-		printk(KERN_ERR "%s: write error (ac97_reg=%d GSR=%#lx)\n",
-				__func__, reg, GSR | gsr_bits);
-
-	mutex_unlock(&car_mutex);
-}
-
@@ -114,90 +31,2 @@
-	/* First, try cold reset */
-#ifdef CONFIG_PXA3xx
-	int timeout;
-
-	/* Hold CLKBPB for 100us */
-	GCR = 0;
-	GCR = GCR_CLKBPB;
-	udelay(100);
-	GCR = 0;
-#endif
-
-	GCR &=  GCR_COLD_RST;  /* clear everything but nCRST */
-	GCR &= ~GCR_COLD_RST;  /* then assert nCRST */
-
-	gsr_bits = 0;
-#ifdef CONFIG_PXA27x
-	/* PXA27x Developers Manual section 13.5.2.2.1 */
-	clk_enable(ac97conf_clk);
-	udelay(5);
-	clk_disable(ac97conf_clk);
-	GCR = GCR_COLD_RST;
-	udelay(50);
-#elif defined(CONFIG_PXA3xx)
-	timeout = 1000;
-	/* Can't use interrupts on PXA3xx */
-	GCR &= ~(GCR_PRIRDY_IEN|GCR_SECRDY_IEN);
-
-	GCR = GCR_WARM_RST | GCR_COLD_RST;
-	while (!(GSR & (GSR_PCR | GSR_SCR)) && timeout--)
-		mdelay(10);
-#else
-	GCR = GCR_COLD_RST;
-	GCR |= GCR_CDONE_IE|GCR_SDONE_IE;
-	wait_event_timeout(gsr_wq, gsr_bits & (GSR_PCR | GSR_SCR), 1);
-#endif
-
-	if (!((GSR | gsr_bits) & (GSR_PCR | GSR_SCR))) {
-		printk(KERN_INFO "%s: cold reset timeout (GSR=%#lx)\n",
-				 __func__, gsr_bits);
-
-		/* let's try warm reset */
-		gsr_bits = 0;
-#ifdef CONFIG_PXA27x
-		/* warm reset broken on Bulverde,
-		   so manually keep AC97 reset high */
-		pxa_gpio_mode(113 | GPIO_OUT | GPIO_DFLT_HIGH); 
-		udelay(10);
-		GCR |= GCR_WARM_RST;
-		pxa_gpio_mode(113 | GPIO_ALT_FN_2_OUT);
-		udelay(500);
-#elif defined(CONFIG_PXA3xx)
-		timeout = 100;
-		/* Can't use interrupts */
-		GCR |= GCR_WARM_RST;
-		while (!((GSR | gsr_bits) & (GSR_PCR | GSR_SCR)) && timeout--)
-			mdelay(1);
-#else
-		GCR |= GCR_WARM_RST|GCR_PRIRDY_IEN|GCR_SECRDY_IEN;
-		wait_event_timeout(gsr_wq, gsr_bits & (GSR_PCR | GSR_SCR), 1);
-#endif			
-
-		if (!((GSR | gsr_bits) & (GSR_PCR | GSR_SCR)))
-			printk(KERN_INFO "%s: warm reset timeout (GSR=%#lx)\n",
-					 __func__, gsr_bits);
-	}
-
-	GCR &= ~(GCR_PRIRDY_IEN|GCR_SECRDY_IEN);
-	GCR |= GCR_SDONE_IE|GCR_CDONE_IE;
-}
-
-static irqreturn_t pxa2xx_ac97_irq(int irq, void *dev_id)
-{
-	long status;
-
-	status = GSR;
-	if (status) {
-		GSR = status;
-		gsr_bits |= status;
-		wake_up(&gsr_wq);
-
-#ifdef CONFIG_PXA27x
-		/* Although we don't use those we still need to clear them
-		   since they tend to spuriously trigger when MMC is used
-		   (hardware bug? go figure)... */
-		MISR = MISR_EOC;
-		PISR = PISR_EOC;
-		MCSR = MCSR_EOC;
-#endif
-
-		return IRQ_HANDLED;
+	if (!pxa2xx_ac97_try_cold_reset(ac97)) {
+		pxa2xx_ac97_try_warm_reset(ac97);
@@ -206 +35 @@
-	return IRQ_NONE;
+	pxa2xx_ac97_finish_reset(ac97);
@@ -218 +47 @@
-	.drcmr			= &DRCMRTXPCDR,
+	.drcmr			= &DRCMR(12),
@@ -226 +55 @@
-	.drcmr			= &DRCMRRXPCDR,
+	.drcmr			= &DRCMR(11),
@@ -291,2 +119,0 @@
-	GCR |= GCR_ACLINK_OFF;
-	clk_disable(ac97_clk);
@@ -294 +121 @@
-	return 0;
+	return pxa2xx_ac97_hw_suspend();
@@ -299,0 +127,5 @@
+	int rc;
+
+	rc = pxa2xx_ac97_hw_resume();
+	if (rc)
+		return rc;
@@ -301 +132,0 @@
-	clk_enable(ac97_clk);
@@ -357,23 +188,2 @@
-	ret = request_irq(IRQ_AC97, pxa2xx_ac97_irq, 0, "AC97", NULL);
-	if (ret < 0)
-		goto err;
-
-	pxa_gpio_mode(GPIO31_SYNC_AC97_MD);
-	pxa_gpio_mode(GPIO30_SDATA_OUT_AC97_MD);
-	pxa_gpio_mode(GPIO28_BITCLK_AC97_MD);
-	pxa_gpio_mode(GPIO29_SDATA_IN_AC97_MD);
-#ifdef CONFIG_PXA27x
-	/* Use GPIO 113 as AC97 Reset on Bulverde */
-	pxa_gpio_mode(113 | GPIO_ALT_FN_2_OUT);
-	ac97conf_clk = clk_get(&dev->dev, "AC97CONFCLK");
-	if (IS_ERR(ac97conf_clk)) {
-		ret = PTR_ERR(ac97conf_clk);
-		ac97conf_clk = NULL;
-		goto err;
-	}
-#endif
-
-	ac97_clk = clk_get(&dev->dev, "AC97CLK");
-	if (IS_ERR(ac97_clk)) {
-		ret = PTR_ERR(ac97_clk);
-		ac97_clk = NULL;
+	ret = pxa2xx_ac97_hw_probe(dev);
+	if (ret)
@@ -381,2 +190,0 @@
-	}
-	clk_enable(ac97_clk);
@@ -386 +194 @@
-		goto err;
+		goto err_remove;
@@ -390 +198 @@
-		goto err;
+		goto err_remove;
@@ -404 +212,3 @@
- err:
+err_remove:
+	pxa2xx_ac97_hw_remove(dev);
+err:
@@ -407,13 +216,0 @@
-	if (ac97_clk) {
-		GCR |= GCR_ACLINK_OFF;
-		free_irq(IRQ_AC97, NULL);
-		clk_disable(ac97_clk);
-		clk_put(ac97_clk);
-		ac97_clk = NULL;
-	}
-#ifdef CONFIG_PXA27x
-	if (ac97conf_clk) {
-		clk_put(ac97conf_clk);
-		ac97conf_clk = NULL;
-	}
-#endif
@@ -430,9 +227 @@
-		GCR |= GCR_ACLINK_OFF;
-		free_irq(IRQ_AC97, NULL);
-		clk_disable(ac97_clk);
-		clk_put(ac97_clk);
-		ac97_clk = NULL;
-#ifdef CONFIG_PXA27x
-		clk_put(ac97conf_clk);
-		ac97conf_clk = NULL;
-#endif
+		pxa2xx_ac97_hw_remove(dev);
--- ./projects/linux/linux-2.6.28/sound/arm/pxa2xx-ac97.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/sound/arm/pxa2xx-ac97.c	2009-03-24 00:12:14.000000000 +0100
@@ -24,0 +25 @@
+#include <mach/regs-ac97.h>
--- ./projects/linux/linux-2.6.29/sound/arm/pxa2xx-ac97.c	2009-03-24 00:12:14.000000000 +0100
+++ ./projects/linux/linux-2.6.30/sound/arm/pxa2xx-ac97.c	2009-06-27 11:32:33.000000000 +0200
@@ -23,2 +22,0 @@
-#include <mach/hardware.h>
-#include <mach/pxa-regs.h>
@@ -176,4 +174,3 @@
-	ret = -ENOMEM;
-	card = snd_card_new(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
-			    THIS_MODULE, 0);
-	if (!card)
+	ret = snd_card_create(SNDRV_DEFAULT_IDX1, SNDRV_DEFAULT_STR1,
+			      THIS_MODULE, 0, &card);
+	if (ret < 0)
--- ./projects/linux/linux-2.6.16/sound/oss/ali5455.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/sound/oss/ali5455.c	2006-06-18 03:49:35.000000000 +0200
@@ -66,0 +67,2 @@
+#include <linux/mutex.h>
+
@@ -237 +239 @@
-	struct semaphore open_sem;
+	struct mutex open_mutex;
@@ -2810 +2812 @@
-	init_MUTEX(&state->open_sem);
+	mutex_init(&state->open_mutex);
@@ -3362 +3364 @@
-		init_MUTEX(&state->open_sem);
+		mutex_init(&state->open_mutex);
--- ./projects/linux/linux-2.6.17/sound/oss/ali5455.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/sound/oss/ali5455.c	2006-09-20 05:42:06.000000000 +0200
@@ -3463 +3463 @@
-	if (request_irq(card->irq, &ali_interrupt, SA_SHIRQ,
+	if (request_irq(card->irq, &ali_interrupt, IRQF_SHARED,
