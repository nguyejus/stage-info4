--- ./projects/linux/linux-2.6.14/drivers/media/dvb/ttpci/fdump.c	2005-10-28 02:02:08.000000000 +0200
+++ ./projects/linux/linux-2.6.15/drivers/media/dvb/ttpci/fdump.c	2006-01-03 04:21:10.000000000 +0100
@@ -39 +39 @@
-    
+
--- ./projects/linux/linux-2.6.16/scripts/genksyms/genksyms.c	2006-03-20 06:53:29.000000000 +0100
+++ ./projects/linux/linux-2.6.17/scripts/genksyms/genksyms.c	2006-06-18 03:49:35.000000000 +0200
@@ -32 +32 @@
-#endif /* __GNU_LIBRARY__ */
+#endif				/* __GNU_LIBRARY__ */
@@ -35 +34,0 @@
-
@@ -41 +40 @@
-FILE *debugfile;
+static FILE *debugfile;
@@ -44 +43 @@
-char *cur_filename, *output_directory;
+char *cur_filename;
@@ -46 +45,3 @@
-int flag_debug, flag_dump_defs, flag_warnings;
+static int flag_debug, flag_dump_defs, flag_warnings;
+static const char *arch = "";
+static const char *mod_prefix = "";
@@ -53,2 +54,2 @@
-static const char * const symbol_type_name[] = {
-  "normal", "typedef", "enum", "struct", "union"
+static const char *const symbol_type_name[] = {
+	"normal", "typedef", "enum", "struct", "union"
@@ -56,0 +58,3 @@
+static int equal_list(struct string_list *a, struct string_list *b);
+static void print_list(FILE * f, struct string_list *list);
+
@@ -59,54 +63,53 @@
-static const unsigned int crctab32[] =
-{
-  0x00000000U, 0x77073096U, 0xee0e612cU, 0x990951baU, 0x076dc419U,
-  0x706af48fU, 0xe963a535U, 0x9e6495a3U, 0x0edb8832U, 0x79dcb8a4U,
-  0xe0d5e91eU, 0x97d2d988U, 0x09b64c2bU, 0x7eb17cbdU, 0xe7b82d07U,
-  0x90bf1d91U, 0x1db71064U, 0x6ab020f2U, 0xf3b97148U, 0x84be41deU,
-  0x1adad47dU, 0x6ddde4ebU, 0xf4d4b551U, 0x83d385c7U, 0x136c9856U,
-  0x646ba8c0U, 0xfd62f97aU, 0x8a65c9ecU, 0x14015c4fU, 0x63066cd9U,
-  0xfa0f3d63U, 0x8d080df5U, 0x3b6e20c8U, 0x4c69105eU, 0xd56041e4U,
-  0xa2677172U, 0x3c03e4d1U, 0x4b04d447U, 0xd20d85fdU, 0xa50ab56bU,
-  0x35b5a8faU, 0x42b2986cU, 0xdbbbc9d6U, 0xacbcf940U, 0x32d86ce3U,
-  0x45df5c75U, 0xdcd60dcfU, 0xabd13d59U, 0x26d930acU, 0x51de003aU,
-  0xc8d75180U, 0xbfd06116U, 0x21b4f4b5U, 0x56b3c423U, 0xcfba9599U,
-  0xb8bda50fU, 0x2802b89eU, 0x5f058808U, 0xc60cd9b2U, 0xb10be924U,
-  0x2f6f7c87U, 0x58684c11U, 0xc1611dabU, 0xb6662d3dU, 0x76dc4190U,
-  0x01db7106U, 0x98d220bcU, 0xefd5102aU, 0x71b18589U, 0x06b6b51fU,
-  0x9fbfe4a5U, 0xe8b8d433U, 0x7807c9a2U, 0x0f00f934U, 0x9609a88eU,
-  0xe10e9818U, 0x7f6a0dbbU, 0x086d3d2dU, 0x91646c97U, 0xe6635c01U,
-  0x6b6b51f4U, 0x1c6c6162U, 0x856530d8U, 0xf262004eU, 0x6c0695edU,
-  0x1b01a57bU, 0x8208f4c1U, 0xf50fc457U, 0x65b0d9c6U, 0x12b7e950U,
-  0x8bbeb8eaU, 0xfcb9887cU, 0x62dd1ddfU, 0x15da2d49U, 0x8cd37cf3U,
-  0xfbd44c65U, 0x4db26158U, 0x3ab551ceU, 0xa3bc0074U, 0xd4bb30e2U,
-  0x4adfa541U, 0x3dd895d7U, 0xa4d1c46dU, 0xd3d6f4fbU, 0x4369e96aU,
-  0x346ed9fcU, 0xad678846U, 0xda60b8d0U, 0x44042d73U, 0x33031de5U,
-  0xaa0a4c5fU, 0xdd0d7cc9U, 0x5005713cU, 0x270241aaU, 0xbe0b1010U,
-  0xc90c2086U, 0x5768b525U, 0x206f85b3U, 0xb966d409U, 0xce61e49fU,
-  0x5edef90eU, 0x29d9c998U, 0xb0d09822U, 0xc7d7a8b4U, 0x59b33d17U,
-  0x2eb40d81U, 0xb7bd5c3bU, 0xc0ba6cadU, 0xedb88320U, 0x9abfb3b6U,
-  0x03b6e20cU, 0x74b1d29aU, 0xead54739U, 0x9dd277afU, 0x04db2615U,
-  0x73dc1683U, 0xe3630b12U, 0x94643b84U, 0x0d6d6a3eU, 0x7a6a5aa8U,
-  0xe40ecf0bU, 0x9309ff9dU, 0x0a00ae27U, 0x7d079eb1U, 0xf00f9344U,
-  0x8708a3d2U, 0x1e01f268U, 0x6906c2feU, 0xf762575dU, 0x806567cbU,
-  0x196c3671U, 0x6e6b06e7U, 0xfed41b76U, 0x89d32be0U, 0x10da7a5aU,
-  0x67dd4accU, 0xf9b9df6fU, 0x8ebeeff9U, 0x17b7be43U, 0x60b08ed5U,
-  0xd6d6a3e8U, 0xa1d1937eU, 0x38d8c2c4U, 0x4fdff252U, 0xd1bb67f1U,
-  0xa6bc5767U, 0x3fb506ddU, 0x48b2364bU, 0xd80d2bdaU, 0xaf0a1b4cU,
-  0x36034af6U, 0x41047a60U, 0xdf60efc3U, 0xa867df55U, 0x316e8eefU,
-  0x4669be79U, 0xcb61b38cU, 0xbc66831aU, 0x256fd2a0U, 0x5268e236U,
-  0xcc0c7795U, 0xbb0b4703U, 0x220216b9U, 0x5505262fU, 0xc5ba3bbeU,
-  0xb2bd0b28U, 0x2bb45a92U, 0x5cb36a04U, 0xc2d7ffa7U, 0xb5d0cf31U,
-  0x2cd99e8bU, 0x5bdeae1dU, 0x9b64c2b0U, 0xec63f226U, 0x756aa39cU,
-  0x026d930aU, 0x9c0906a9U, 0xeb0e363fU, 0x72076785U, 0x05005713U,
-  0x95bf4a82U, 0xe2b87a14U, 0x7bb12baeU, 0x0cb61b38U, 0x92d28e9bU,
-  0xe5d5be0dU, 0x7cdcefb7U, 0x0bdbdf21U, 0x86d3d2d4U, 0xf1d4e242U,
-  0x68ddb3f8U, 0x1fda836eU, 0x81be16cdU, 0xf6b9265bU, 0x6fb077e1U,
-  0x18b74777U, 0x88085ae6U, 0xff0f6a70U, 0x66063bcaU, 0x11010b5cU,
-  0x8f659effU, 0xf862ae69U, 0x616bffd3U, 0x166ccf45U, 0xa00ae278U,
-  0xd70dd2eeU, 0x4e048354U, 0x3903b3c2U, 0xa7672661U, 0xd06016f7U,
-  0x4969474dU, 0x3e6e77dbU, 0xaed16a4aU, 0xd9d65adcU, 0x40df0b66U,
-  0x37d83bf0U, 0xa9bcae53U, 0xdebb9ec5U, 0x47b2cf7fU, 0x30b5ffe9U,
-  0xbdbdf21cU, 0xcabac28aU, 0x53b39330U, 0x24b4a3a6U, 0xbad03605U,
-  0xcdd70693U, 0x54de5729U, 0x23d967bfU, 0xb3667a2eU, 0xc4614ab8U,
-  0x5d681b02U, 0x2a6f2b94U, 0xb40bbe37U, 0xc30c8ea1U, 0x5a05df1bU,
-  0x2d02ef8dU
+static const unsigned int crctab32[] = {
+	0x00000000U, 0x77073096U, 0xee0e612cU, 0x990951baU, 0x076dc419U,
+	0x706af48fU, 0xe963a535U, 0x9e6495a3U, 0x0edb8832U, 0x79dcb8a4U,
+	0xe0d5e91eU, 0x97d2d988U, 0x09b64c2bU, 0x7eb17cbdU, 0xe7b82d07U,
+	0x90bf1d91U, 0x1db71064U, 0x6ab020f2U, 0xf3b97148U, 0x84be41deU,
+	0x1adad47dU, 0x6ddde4ebU, 0xf4d4b551U, 0x83d385c7U, 0x136c9856U,
+	0x646ba8c0U, 0xfd62f97aU, 0x8a65c9ecU, 0x14015c4fU, 0x63066cd9U,
+	0xfa0f3d63U, 0x8d080df5U, 0x3b6e20c8U, 0x4c69105eU, 0xd56041e4U,
+	0xa2677172U, 0x3c03e4d1U, 0x4b04d447U, 0xd20d85fdU, 0xa50ab56bU,
+	0x35b5a8faU, 0x42b2986cU, 0xdbbbc9d6U, 0xacbcf940U, 0x32d86ce3U,
+	0x45df5c75U, 0xdcd60dcfU, 0xabd13d59U, 0x26d930acU, 0x51de003aU,
+	0xc8d75180U, 0xbfd06116U, 0x21b4f4b5U, 0x56b3c423U, 0xcfba9599U,
+	0xb8bda50fU, 0x2802b89eU, 0x5f058808U, 0xc60cd9b2U, 0xb10be924U,
+	0x2f6f7c87U, 0x58684c11U, 0xc1611dabU, 0xb6662d3dU, 0x76dc4190U,
+	0x01db7106U, 0x98d220bcU, 0xefd5102aU, 0x71b18589U, 0x06b6b51fU,
+	0x9fbfe4a5U, 0xe8b8d433U, 0x7807c9a2U, 0x0f00f934U, 0x9609a88eU,
+	0xe10e9818U, 0x7f6a0dbbU, 0x086d3d2dU, 0x91646c97U, 0xe6635c01U,
+	0x6b6b51f4U, 0x1c6c6162U, 0x856530d8U, 0xf262004eU, 0x6c0695edU,
+	0x1b01a57bU, 0x8208f4c1U, 0xf50fc457U, 0x65b0d9c6U, 0x12b7e950U,
+	0x8bbeb8eaU, 0xfcb9887cU, 0x62dd1ddfU, 0x15da2d49U, 0x8cd37cf3U,
+	0xfbd44c65U, 0x4db26158U, 0x3ab551ceU, 0xa3bc0074U, 0xd4bb30e2U,
+	0x4adfa541U, 0x3dd895d7U, 0xa4d1c46dU, 0xd3d6f4fbU, 0x4369e96aU,
+	0x346ed9fcU, 0xad678846U, 0xda60b8d0U, 0x44042d73U, 0x33031de5U,
+	0xaa0a4c5fU, 0xdd0d7cc9U, 0x5005713cU, 0x270241aaU, 0xbe0b1010U,
+	0xc90c2086U, 0x5768b525U, 0x206f85b3U, 0xb966d409U, 0xce61e49fU,
+	0x5edef90eU, 0x29d9c998U, 0xb0d09822U, 0xc7d7a8b4U, 0x59b33d17U,
+	0x2eb40d81U, 0xb7bd5c3bU, 0xc0ba6cadU, 0xedb88320U, 0x9abfb3b6U,
+	0x03b6e20cU, 0x74b1d29aU, 0xead54739U, 0x9dd277afU, 0x04db2615U,
+	0x73dc1683U, 0xe3630b12U, 0x94643b84U, 0x0d6d6a3eU, 0x7a6a5aa8U,
+	0xe40ecf0bU, 0x9309ff9dU, 0x0a00ae27U, 0x7d079eb1U, 0xf00f9344U,
+	0x8708a3d2U, 0x1e01f268U, 0x6906c2feU, 0xf762575dU, 0x806567cbU,
+	0x196c3671U, 0x6e6b06e7U, 0xfed41b76U, 0x89d32be0U, 0x10da7a5aU,
+	0x67dd4accU, 0xf9b9df6fU, 0x8ebeeff9U, 0x17b7be43U, 0x60b08ed5U,
+	0xd6d6a3e8U, 0xa1d1937eU, 0x38d8c2c4U, 0x4fdff252U, 0xd1bb67f1U,
+	0xa6bc5767U, 0x3fb506ddU, 0x48b2364bU, 0xd80d2bdaU, 0xaf0a1b4cU,
+	0x36034af6U, 0x41047a60U, 0xdf60efc3U, 0xa867df55U, 0x316e8eefU,
+	0x4669be79U, 0xcb61b38cU, 0xbc66831aU, 0x256fd2a0U, 0x5268e236U,
+	0xcc0c7795U, 0xbb0b4703U, 0x220216b9U, 0x5505262fU, 0xc5ba3bbeU,
+	0xb2bd0b28U, 0x2bb45a92U, 0x5cb36a04U, 0xc2d7ffa7U, 0xb5d0cf31U,
+	0x2cd99e8bU, 0x5bdeae1dU, 0x9b64c2b0U, 0xec63f226U, 0x756aa39cU,
+	0x026d930aU, 0x9c0906a9U, 0xeb0e363fU, 0x72076785U, 0x05005713U,
+	0x95bf4a82U, 0xe2b87a14U, 0x7bb12baeU, 0x0cb61b38U, 0x92d28e9bU,
+	0xe5d5be0dU, 0x7cdcefb7U, 0x0bdbdf21U, 0x86d3d2d4U, 0xf1d4e242U,
+	0x68ddb3f8U, 0x1fda836eU, 0x81be16cdU, 0xf6b9265bU, 0x6fb077e1U,
+	0x18b74777U, 0x88085ae6U, 0xff0f6a70U, 0x66063bcaU, 0x11010b5cU,
+	0x8f659effU, 0xf862ae69U, 0x616bffd3U, 0x166ccf45U, 0xa00ae278U,
+	0xd70dd2eeU, 0x4e048354U, 0x3903b3c2U, 0xa7672661U, 0xd06016f7U,
+	0x4969474dU, 0x3e6e77dbU, 0xaed16a4aU, 0xd9d65adcU, 0x40df0b66U,
+	0x37d83bf0U, 0xa9bcae53U, 0xdebb9ec5U, 0x47b2cf7fU, 0x30b5ffe9U,
+	0xbdbdf21cU, 0xcabac28aU, 0x53b39330U, 0x24b4a3a6U, 0xbad03605U,
+	0xcdd70693U, 0x54de5729U, 0x23d967bfU, 0xb3667a2eU, 0xc4614ab8U,
+	0x5d681b02U, 0x2a6f2b94U, 0xb40bbe37U, 0xc30c8ea1U, 0x5a05df1bU,
+	0x2d02ef8dU
@@ -115,2 +118 @@
-static inline unsigned long
-partial_crc32_one(unsigned char c, unsigned long crc)
+static unsigned long partial_crc32_one(unsigned char c, unsigned long crc)
@@ -118 +120 @@
-  return crctab32[(crc ^ c) & 0xff] ^ (crc >> 8);
+	return crctab32[(crc ^ c) & 0xff] ^ (crc >> 8);
@@ -121,2 +123 @@
-static inline unsigned long
-partial_crc32(const char *s, unsigned long crc)
+static unsigned long partial_crc32(const char *s, unsigned long crc)
@@ -124,3 +125,3 @@
-  while (*s)
-    crc = partial_crc32_one(*s++, crc);
-  return crc;
+	while (*s)
+		crc = partial_crc32_one(*s++, crc);
+	return crc;
@@ -129,2 +130 @@
-static inline unsigned long
-crc32(const char *s)
+static unsigned long crc32(const char *s)
@@ -132 +132 @@
-  return partial_crc32(s, 0xffffffff) ^ 0xffffffff;
+	return partial_crc32(s, 0xffffffff) ^ 0xffffffff;
@@ -135 +134,0 @@
-
@@ -138,2 +137 @@
-static inline enum symbol_type
-map_to_ns(enum symbol_type t)
+static enum symbol_type map_to_ns(enum symbol_type t)
@@ -141,5 +139,5 @@
-  if (t == SYM_TYPEDEF)
-    t = SYM_NORMAL;
-  else if (t == SYM_UNION)
-    t = SYM_STRUCT;
-  return t;
+	if (t == SYM_TYPEDEF)
+		t = SYM_NORMAL;
+	else if (t == SYM_UNION)
+		t = SYM_STRUCT;
+	return t;
@@ -148,2 +146 @@
-struct symbol *
-find_symbol(const char *name, enum symbol_type ns)
+struct symbol *find_symbol(const char *name, enum symbol_type ns)
@@ -151,2 +148,2 @@
-  unsigned long h = crc32(name) % HASH_BUCKETS;
-  struct symbol *sym;
+	unsigned long h = crc32(name) % HASH_BUCKETS;
+	struct symbol *sym;
@@ -154,3 +151,4 @@
-  for (sym = symtab[h]; sym ; sym = sym->hash_next)
-    if (map_to_ns(sym->type) == map_to_ns(ns) && strcmp(name, sym->name) == 0)
-      break;
+	for (sym = symtab[h]; sym; sym = sym->hash_next)
+		if (map_to_ns(sym->type) == map_to_ns(ns) &&
+		    strcmp(name, sym->name) == 0)
+			break;
@@ -158 +156 @@
-  return sym;
+	return sym;
@@ -161,2 +159,2 @@
-struct symbol *
-add_symbol(const char *name, enum symbol_type type, struct string_list *defn, int is_extern)
+struct symbol *add_symbol(const char *name, enum symbol_type type,
+			  struct string_list *defn, int is_extern)
@@ -164,2 +162,2 @@
-  unsigned long h = crc32(name) % HASH_BUCKETS;
-  struct symbol *sym;
+	unsigned long h = crc32(name) % HASH_BUCKETS;
+	struct symbol *sym;
@@ -167,8 +165,8 @@
-  for (sym = symtab[h]; sym ; sym = sym->hash_next)
-    if (map_to_ns(sym->type) == map_to_ns(type)
-	&& strcmp(name, sym->name) == 0)
-      {
-	if (!equal_list(sym->defn, defn))
-	  error_with_pos("redefinition of %s", name);
-	return sym;
-      }
+	for (sym = symtab[h]; sym; sym = sym->hash_next) {
+		if (map_to_ns(sym->type) == map_to_ns(type)
+		    && strcmp(name, sym->name) == 0) {
+			if (!equal_list(sym->defn, defn))
+				error_with_pos("redefinition of %s", name);
+			return sym;
+		}
+	}
@@ -176,18 +174,18 @@
-  sym = xmalloc(sizeof(*sym));
-  sym->name = name;
-  sym->type = type;
-  sym->defn = defn;
-  sym->expansion_trail = NULL;
-  sym->is_extern = is_extern;
-
-  sym->hash_next = symtab[h];
-  symtab[h] = sym;
-
-  if (flag_debug)
-    {
-      fprintf(debugfile, "Defn for %s %s == <", symbol_type_name[type],  name);
-      if (is_extern)
-        fputs("extern ", debugfile);
-      print_list(debugfile, defn);
-      fputs(">\n", debugfile);
-    }
+	sym = xmalloc(sizeof(*sym));
+	sym->name = name;
+	sym->type = type;
+	sym->defn = defn;
+	sym->expansion_trail = NULL;
+	sym->is_extern = is_extern;
+
+	sym->hash_next = symtab[h];
+	symtab[h] = sym;
+
+	if (flag_debug) {
+		fprintf(debugfile, "Defn for %s %s == <",
+			symbol_type_name[type], name);
+		if (is_extern)
+			fputs("extern ", debugfile);
+		print_list(debugfile, defn);
+		fputs(">\n", debugfile);
+	}
@@ -195,2 +193,2 @@
-  ++nsyms;
-  return sym;
+	++nsyms;
+	return sym;
@@ -199 +196,0 @@
-
@@ -202,2 +199 @@
-inline void
-free_node(struct string_list *node)
+void free_node(struct string_list *node)
@@ -205,2 +201,2 @@
-  free(node->string);
-  free(node);
+	free(node->string);
+	free(node);
@@ -209,2 +205 @@
-void
-free_list(struct string_list *s, struct string_list *e)
+void free_list(struct string_list *s, struct string_list *e)
@@ -212,6 +207,5 @@
-  while (s != e)
-    {
-      struct string_list *next = s->next;
-      free_node(s);
-      s = next;
-    }
+	while (s != e) {
+		struct string_list *next = s->next;
+		free_node(s);
+		s = next;
+	}
@@ -220,2 +214 @@
-inline struct string_list *
-copy_node(struct string_list *node)
+struct string_list *copy_node(struct string_list *node)
@@ -223 +216 @@
-  struct string_list *newnode;
+	struct string_list *newnode;
@@ -225,3 +218,3 @@
-  newnode = xmalloc(sizeof(*newnode));
-  newnode->string = xstrdup(node->string);
-  newnode->tag = node->tag;
+	newnode = xmalloc(sizeof(*newnode));
+	newnode->string = xstrdup(node->string);
+	newnode->tag = node->tag;
@@ -229 +222 @@
-  return newnode;
+	return newnode;
@@ -232,2 +225 @@
-struct string_list *
-copy_list(struct string_list *s, struct string_list *e)
+static int equal_list(struct string_list *a, struct string_list *b)
@@ -235,23 +227,6 @@
-  struct string_list *h, *p;
-
-  if (s == e)
-    return NULL;
-
-  p = h = copy_node(s);
-  while ((s = s->next) != e)
-    p = p->next = copy_node(s);
-  p->next = NULL;
-
-  return h;
-}
-
-int
-equal_list(struct string_list *a, struct string_list *b)
-{
-  while (a && b)
-    {
-      if (a->tag != b->tag || strcmp(a->string, b->string))
-	return 0;
-      a = a->next;
-      b = b->next;
-    }
+	while (a && b) {
+		if (a->tag != b->tag || strcmp(a->string, b->string))
+			return 0;
+		a = a->next;
+		b = b->next;
+	}
@@ -259 +234 @@
-  return !a && !b;
+	return !a && !b;
@@ -262,2 +237 @@
-static inline void
-print_node(FILE *f, struct string_list *list)
+static void print_node(FILE * f, struct string_list *list)
@@ -265,14 +239,13 @@
-  switch (list->tag)
-    {
-    case SYM_STRUCT:
-      putc('s', f);
-      goto printit;
-    case SYM_UNION:
-      putc('u', f);
-      goto printit;
-    case SYM_ENUM:
-      putc('e', f);
-      goto printit;
-    case SYM_TYPEDEF:
-      putc('t', f);
-      goto printit;
+	switch (list->tag) {
+	case SYM_STRUCT:
+		putc('s', f);
+		goto printit;
+	case SYM_UNION:
+		putc('u', f);
+		goto printit;
+	case SYM_ENUM:
+		putc('e', f);
+		goto printit;
+	case SYM_TYPEDEF:
+		putc('t', f);
+		goto printit;
@@ -280,6 +253,6 @@
-    printit:
-      putc('#', f);
-    case SYM_NORMAL:
-      fputs(list->string, f);
-      break;
-    }
+	      printit:
+		putc('#', f);
+	case SYM_NORMAL:
+		fputs(list->string, f);
+		break;
+	}
@@ -288,2 +261 @@
-void
-print_list(FILE *f, struct string_list *list)
+static void print_list(FILE * f, struct string_list *list)
@@ -291,21 +263,8 @@
-  struct string_list **e, **b;
-  struct string_list *tmp, **tmp2;
-  int elem = 1;
-
-  if (list == NULL)
-    {
-      fputs("(nil)", f);
-      return;
-    }
-
-  tmp = list;
-  while((tmp = tmp->next) != NULL)
-	  elem++;
-
-  b = alloca(elem * sizeof(*e));
-  e = b + elem;
-  tmp2 = e - 1;
-
-  (*tmp2--) = list;
-  while((list = list->next) != NULL)
-	  *(tmp2--) = list;
+	struct string_list **e, **b;
+	struct string_list *tmp, **tmp2;
+	int elem = 1;
+
+	if (list == NULL) {
+		fputs("(nil)", f);
+		return;
+	}
@@ -313,5 +272,16 @@
-  while (b != e)
-    {
-      print_node(f, *b++);
-      putc(' ', f);
-    }
+	tmp = list;
+	while ((tmp = tmp->next) != NULL)
+		elem++;
+
+	b = alloca(elem * sizeof(*e));
+	e = b + elem;
+	tmp2 = e - 1;
+
+	(*tmp2--) = list;
+	while ((list = list->next) != NULL)
+		*(tmp2--) = list;
+
+	while (b != e) {
+		print_node(f, *b++);
+		putc(' ', f);
+	}
@@ -320,2 +290,2 @@
-static unsigned long
-expand_and_crc_list(struct string_list *list, unsigned long crc)
+static unsigned long expand_and_crc_list(struct string_list *list,
+					 unsigned long crc)
@@ -323,87 +293,95 @@
-  struct string_list **e, **b;
-  struct string_list *tmp, **tmp2;
-  int elem = 1;
-
-  if (!list)
-    return crc;
-
-  tmp = list;
-  while((tmp = tmp->next) != NULL)
-	  elem++;
-
-  b = alloca(elem * sizeof(*e));
-  e = b + elem;
-  tmp2 = e - 1;
-
-  *(tmp2--) = list;
-  while ((list = list->next) != NULL)
-    *(tmp2--) = list;
-
-  while (b != e)
-    {
-      struct string_list *cur;
-      struct symbol *subsym;
-
-      cur = *(b++);
-      switch (cur->tag)
-	{
-	case SYM_NORMAL:
-	  if (flag_dump_defs)
-	    fprintf(debugfile, "%s ", cur->string);
-	  crc = partial_crc32(cur->string, crc);
-	  crc = partial_crc32_one(' ', crc);
-	  break;
-
-	case SYM_TYPEDEF:
-	  subsym = find_symbol(cur->string, cur->tag);
-	  if (subsym->expansion_trail)
-	    {
-	      if (flag_dump_defs)
-		fprintf(debugfile, "%s ", cur->string);
-	      crc = partial_crc32(cur->string, crc);
-	      crc = partial_crc32_one(' ', crc);
-	    }
-	  else
-	    {
-	      subsym->expansion_trail = expansion_trail;
-	      expansion_trail = subsym;
-	      crc = expand_and_crc_list(subsym->defn, crc);
-	    }
-	  break;
-
-	case SYM_STRUCT:
-	case SYM_UNION:
-	case SYM_ENUM:
-	  subsym = find_symbol(cur->string, cur->tag);
-	  if (!subsym)
-	    {
-	      struct string_list *n, *t = NULL;
-
-	      error_with_pos("expand undefined %s %s",
-			     symbol_type_name[cur->tag], cur->string);
-
-	      n = xmalloc(sizeof(*n));
-	      n->string = xstrdup(symbol_type_name[cur->tag]);
-	      n->tag = SYM_NORMAL;
-	      n->next = t;
-	      t = n;
-
-	      n = xmalloc(sizeof(*n));
-	      n->string = xstrdup(cur->string);
-	      n->tag = SYM_NORMAL;
-	      n->next = t;
-	      t = n;
-
-	      n = xmalloc(sizeof(*n));
-	      n->string = xstrdup("{ UNKNOWN }");
-	      n->tag = SYM_NORMAL;
-	      n->next = t;
-
-	      subsym = add_symbol(cur->string, cur->tag, n, 0);
-	    }
-	  if (subsym->expansion_trail)
-	    {
-	      if (flag_dump_defs)
-		{
-		  fprintf(debugfile, "%s %s ", symbol_type_name[cur->tag],
-			  cur->string);
+	struct string_list **e, **b;
+	struct string_list *tmp, **tmp2;
+	int elem = 1;
+
+	if (!list)
+		return crc;
+
+	tmp = list;
+	while ((tmp = tmp->next) != NULL)
+		elem++;
+
+	b = alloca(elem * sizeof(*e));
+	e = b + elem;
+	tmp2 = e - 1;
+
+	*(tmp2--) = list;
+	while ((list = list->next) != NULL)
+		*(tmp2--) = list;
+
+	while (b != e) {
+		struct string_list *cur;
+		struct symbol *subsym;
+
+		cur = *(b++);
+		switch (cur->tag) {
+		case SYM_NORMAL:
+			if (flag_dump_defs)
+				fprintf(debugfile, "%s ", cur->string);
+			crc = partial_crc32(cur->string, crc);
+			crc = partial_crc32_one(' ', crc);
+			break;
+
+		case SYM_TYPEDEF:
+			subsym = find_symbol(cur->string, cur->tag);
+			if (subsym->expansion_trail) {
+				if (flag_dump_defs)
+					fprintf(debugfile, "%s ", cur->string);
+				crc = partial_crc32(cur->string, crc);
+				crc = partial_crc32_one(' ', crc);
+			} else {
+				subsym->expansion_trail = expansion_trail;
+				expansion_trail = subsym;
+				crc = expand_and_crc_list(subsym->defn, crc);
+			}
+			break;
+
+		case SYM_STRUCT:
+		case SYM_UNION:
+		case SYM_ENUM:
+			subsym = find_symbol(cur->string, cur->tag);
+			if (!subsym) {
+				struct string_list *n, *t = NULL;
+
+				error_with_pos("expand undefined %s %s",
+					       symbol_type_name[cur->tag],
+					       cur->string);
+
+				n = xmalloc(sizeof(*n));
+				n->string = xstrdup(symbol_type_name[cur->tag]);
+				n->tag = SYM_NORMAL;
+				n->next = t;
+				t = n;
+
+				n = xmalloc(sizeof(*n));
+				n->string = xstrdup(cur->string);
+				n->tag = SYM_NORMAL;
+				n->next = t;
+				t = n;
+
+				n = xmalloc(sizeof(*n));
+				n->string = xstrdup("{ UNKNOWN }");
+				n->tag = SYM_NORMAL;
+				n->next = t;
+
+				subsym =
+				    add_symbol(cur->string, cur->tag, n, 0);
+			}
+			if (subsym->expansion_trail) {
+				if (flag_dump_defs) {
+					fprintf(debugfile, "%s %s ",
+						symbol_type_name[cur->tag],
+						cur->string);
+				}
+
+				crc = partial_crc32(symbol_type_name[cur->tag],
+						    crc);
+				crc = partial_crc32_one(' ', crc);
+				crc = partial_crc32(cur->string, crc);
+				crc = partial_crc32_one(' ', crc);
+			} else {
+				subsym->expansion_trail = expansion_trail;
+				expansion_trail = subsym;
+				crc = expand_and_crc_list(subsym->defn, crc);
+			}
+			break;
@@ -411,13 +388,0 @@
-
-	      crc = partial_crc32(symbol_type_name[cur->tag], crc);
-	      crc = partial_crc32_one(' ', crc);
-	      crc = partial_crc32(cur->string, crc);
-	      crc = partial_crc32_one(' ', crc);
-	    }
-	  else
-	    {
-	      subsym->expansion_trail = expansion_trail;
-	      expansion_trail = subsym;
-	      crc = expand_and_crc_list(subsym->defn, crc);
-	    }
-	  break;
@@ -425 +389,0 @@
-    }
@@ -427 +391 @@
-  return crc;
+	return crc;
@@ -430,2 +394 @@
-void
-export_symbol(const char *name)
+void export_symbol(const char *name)
@@ -433 +396 @@
-  struct symbol *sym;
+	struct symbol *sym;
@@ -435,6 +398,5 @@
-  sym = find_symbol(name, SYM_NORMAL);
-  if (!sym)
-    error_with_pos("export undefined symbol %s", name);
-  else
-    {
-      unsigned long crc;
+	sym = find_symbol(name, SYM_NORMAL);
+	if (!sym)
+		error_with_pos("export undefined symbol %s", name);
+	else {
+		unsigned long crc;
@@ -442,2 +404,2 @@
-      if (flag_dump_defs)
-	fprintf(debugfile, "Export %s == <", name);
+		if (flag_dump_defs)
+			fprintf(debugfile, "Export %s == <", name);
@@ -445 +407 @@
-      expansion_trail = (struct symbol *)-1L;
+		expansion_trail = (struct symbol *)-1L;
@@ -447 +409 @@
-      crc = expand_and_crc_list(sym->defn, 0xffffffff) ^ 0xffffffff;
+		crc = expand_and_crc_list(sym->defn, 0xffffffff) ^ 0xffffffff;
@@ -449,7 +411,6 @@
-      sym = expansion_trail;
-      while (sym != (struct symbol *)-1L)
-	{
-	  struct symbol *n = sym->expansion_trail;
-	  sym->expansion_trail = 0;
-	  sym = n;
-	}
+		sym = expansion_trail;
+		while (sym != (struct symbol *)-1L) {
+			struct symbol *n = sym->expansion_trail;
+			sym->expansion_trail = 0;
+			sym = n;
+		}
@@ -457,2 +418,2 @@
-      if (flag_dump_defs)
-	fputs(">\n", debugfile);
+		if (flag_dump_defs)
+			fputs(">\n", debugfile);
@@ -460,3 +421,3 @@
-      /* Used as a linker script. */
-      printf("__crc_%s = 0x%08lx ;\n", name, crc);
-    }
+		/* Used as a linker script. */
+		printf("%s__crc_%s = 0x%08lx ;\n", mod_prefix, name, crc);
+	}
@@ -466,19 +427 @@
-
-void
-error(const char *fmt, ...)
-{
-  va_list args;
-
-  if (flag_warnings)
-    {
-      va_start(args, fmt);
-      vfprintf(stderr, fmt, args);
-      va_end(args);
-      putc('\n', stderr);
-
-      errors++;
-    }
-}
-
-void
-error_with_pos(const char *fmt, ...)
+void error_with_pos(const char *fmt, ...)
@@ -486 +429 @@
-  va_list args;
+	va_list args;
@@ -488,3 +431,3 @@
-  if (flag_warnings)
-    {
-      fprintf(stderr, "%s:%d: ", cur_filename ? : "<stdin>", cur_line);
+	if (flag_warnings) {
+		fprintf(stderr, "%s:%d: ", cur_filename ? : "<stdin>",
+			cur_line);
@@ -492,4 +435,4 @@
-      va_start(args, fmt);
-      vfprintf(stderr, fmt, args);
-      va_end(args);
-      putc('\n', stderr);
+		va_start(args, fmt);
+		vfprintf(stderr, fmt, args);
+		va_end(args);
+		putc('\n', stderr);
@@ -497,2 +440,2 @@
-      errors++;
-    }
+		errors++;
+	}
@@ -501,2 +444 @@
-
-void genksyms_usage(void)
+static void genksyms_usage(void)
@@ -504,3 +446 @@
-	fputs("Usage:\n"
-	      "genksyms [-dDwqhV] > /path/to/.tmp_obj.ver\n"
-	      "\n"
+	fputs("Usage:\n" "genksyms [-dDwqhV] > /path/to/.tmp_obj.ver\n" "\n"
@@ -514,8 +454,8 @@
-#else  /* __GNU_LIBRARY__ */
-             "  -d                    Increment the debug level (repeatable)\n"
-             "  -D                    Dump expanded symbol defs (for debugging only)\n"
-             "  -w                    Enable warnings\n"
-             "  -q                    Disable warnings (default)\n"
-             "  -h                    Print this message\n"
-             "  -V                    Print the release version\n"
-#endif /* __GNU_LIBRARY__ */
+#else				/* __GNU_LIBRARY__ */
+	      "  -d                    Increment the debug level (repeatable)\n"
+	      "  -D                    Dump expanded symbol defs (for debugging only)\n"
+	      "  -w                    Enable warnings\n"
+	      "  -q                    Disable warnings (default)\n"
+	      "  -h                    Print this message\n"
+	      "  -V                    Print the release version\n"
+#endif				/* __GNU_LIBRARY__ */
@@ -525,2 +465 @@
-int
-main(int argc, char **argv)
+int main(int argc, char **argv)
@@ -528 +467 @@
-  int o;
+	int o;
@@ -531,58 +470,62 @@
-  struct option long_opts[] = {
-    {"debug", 0, 0, 'd'},
-    {"warnings", 0, 0, 'w'},
-    {"quiet", 0, 0, 'q'},
-    {"dump", 0, 0, 'D'},
-    {"version", 0, 0, 'V'},
-    {"help", 0, 0, 'h'},
-    {0, 0, 0, 0}
-  };
-
-  while ((o = getopt_long(argc, argv, "dwqVDk:p:",
-			  &long_opts[0], NULL)) != EOF)
-#else  /* __GNU_LIBRARY__ */
-  while ((o = getopt(argc, argv, "dwqVDk:p:")) != EOF)
-#endif /* __GNU_LIBRARY__ */
-    switch (o)
-      {
-      case 'd':
-	flag_debug++;
-	break;
-      case 'w':
-	flag_warnings = 1;
-	break;
-      case 'q':
-	flag_warnings = 0;
-	break;
-      case 'V':
-	fputs("genksyms version 2.5.60\n", stderr);
-	break;
-      case 'D':
-	flag_dump_defs = 1;
-	break;
-      case 'h':
-	genksyms_usage();
-	return 0;
-      default:
-	genksyms_usage();
-	return 1;
-      }
-
-    {
-      extern int yydebug;
-      extern int yy_flex_debug;
-
-      yydebug = (flag_debug > 1);
-      yy_flex_debug = (flag_debug > 2);
-
-      debugfile = stderr;
-      /* setlinebuf(debugfile); */
-    }
-
-  yyparse();
-
-  if (flag_debug)
-    {
-      fprintf(debugfile, "Hash table occupancy %d/%d = %g\n",
-	      nsyms, HASH_BUCKETS, (double)nsyms / (double)HASH_BUCKETS);
-    }
+	struct option long_opts[] = {
+		{"arch", 1, 0, 'a'},
+		{"debug", 0, 0, 'd'},
+		{"warnings", 0, 0, 'w'},
+		{"quiet", 0, 0, 'q'},
+		{"dump", 0, 0, 'D'},
+		{"version", 0, 0, 'V'},
+		{"help", 0, 0, 'h'},
+		{0, 0, 0, 0}
+	};
+
+	while ((o = getopt_long(argc, argv, "a:dwqVDk:p:",
+				&long_opts[0], NULL)) != EOF)
+#else				/* __GNU_LIBRARY__ */
+	while ((o = getopt(argc, argv, "a:dwqVDk:p:")) != EOF)
+#endif				/* __GNU_LIBRARY__ */
+		switch (o) {
+		case 'a':
+			arch = optarg;
+			break;
+		case 'd':
+			flag_debug++;
+			break;
+		case 'w':
+			flag_warnings = 1;
+			break;
+		case 'q':
+			flag_warnings = 0;
+			break;
+		case 'V':
+			fputs("genksyms version 2.5.60\n", stderr);
+			break;
+		case 'D':
+			flag_dump_defs = 1;
+			break;
+		case 'h':
+			genksyms_usage();
+			return 0;
+		default:
+			genksyms_usage();
+			return 1;
+		}
+	if ((strcmp(arch, "v850") == 0) || (strcmp(arch, "h8300") == 0))
+		mod_prefix = "_";
+	{
+		extern int yydebug;
+		extern int yy_flex_debug;
+
+		yydebug = (flag_debug > 1);
+		yy_flex_debug = (flag_debug > 2);
+
+		debugfile = stderr;
+		/* setlinebuf(debugfile); */
+	}
+
+	yyparse();
+
+	if (flag_debug) {
+		fprintf(debugfile, "Hash table occupancy %d/%d = %g\n",
+			nsyms, HASH_BUCKETS,
+			(double)nsyms / (double)HASH_BUCKETS);
+	}
@@ -590 +533 @@
-  return errors != 0;
+	return errors != 0;
--- ./projects/linux/linux-2.6.17/scripts/genksyms/genksyms.c	2006-06-18 03:49:35.000000000 +0200
+++ ./projects/linux/linux-2.6.18/scripts/genksyms/genksyms.c	2006-09-20 05:42:06.000000000 +0200
@@ -45 +45 @@
-static int flag_debug, flag_dump_defs, flag_warnings;
+static int flag_debug, flag_dump_defs, flag_dump_types, flag_warnings;
@@ -52,0 +53 @@
+static struct symbol *visited_symbols;
@@ -178,0 +180 @@
+	sym->visited = NULL;
@@ -239,15 +241,2 @@
-	switch (list->tag) {
-	case SYM_STRUCT:
-		putc('s', f);
-		goto printit;
-	case SYM_UNION:
-		putc('u', f);
-		goto printit;
-	case SYM_ENUM:
-		putc('e', f);
-		goto printit;
-	case SYM_TYPEDEF:
-		putc('t', f);
-		goto printit;
-
-	      printit:
+	if (list->tag != SYM_NORMAL) {
+		putc(symbol_type_name[list->tag][0], f);
@@ -255,3 +243,0 @@
-	case SYM_NORMAL:
-		fputs(list->string, f);
-		break;
@@ -258,0 +245 @@
+	fputs(list->string, f);
@@ -290,2 +277 @@
-static unsigned long expand_and_crc_list(struct string_list *list,
-					 unsigned long crc)
+static unsigned long expand_and_crc_sym(struct symbol *sym, unsigned long crc)
@@ -292,0 +279 @@
+	struct string_list *list = sym->defn;
@@ -335 +322 @@
-				crc = expand_and_crc_list(subsym->defn, crc);
+				crc = expand_and_crc_sym(subsym, crc);
@@ -385 +372 @@
-				crc = expand_and_crc_list(subsym->defn, crc);
+				crc = expand_and_crc_sym(subsym, crc);
@@ -390,0 +378,10 @@
+	{
+		static struct symbol **end = &visited_symbols;
+
+		if (!sym->visited) {
+			*end = sym;
+			end = &sym->visited;
+			sym->visited = (struct symbol *)-1L;
+		}
+	}
+
@@ -409 +406 @@
-		crc = expand_and_crc_list(sym->defn, 0xffffffff) ^ 0xffffffff;
+		crc = expand_and_crc_sym(sym, 0xffffffff) ^ 0xffffffff;
@@ -466,0 +464 @@
+	FILE *dumpfile = NULL;
@@ -475,0 +474 @@
+		{"dump-types", 1, 0, 'T'},
@@ -481 +480 @@
-	while ((o = getopt_long(argc, argv, "a:dwqVDk:p:",
+	while ((o = getopt_long(argc, argv, "a:dwqVDT:k:p:",
@@ -484 +483 @@
-	while ((o = getopt(argc, argv, "a:dwqVDk:p:")) != EOF)
+	while ((o = getopt(argc, argv, "a:dwqVDT:k:p:")) != EOF)
@@ -504,0 +504,8 @@
+		case 'T':
+			flag_dump_types = 1;
+			dumpfile = fopen(optarg, "w");
+			if (!dumpfile) {
+				perror(optarg);
+				return 1;
+			}
+			break;
@@ -526,0 +534,18 @@
+	if (flag_dump_types && visited_symbols) {
+		while (visited_symbols != (struct symbol *)-1L) {
+			struct symbol *sym = visited_symbols;
+
+			if (sym->type != SYM_NORMAL) {
+				putc(symbol_type_name[sym->type][0], dumpfile);
+				putc('#', dumpfile);
+			}
+			fputs(sym->name, dumpfile);
+			putc(' ', dumpfile);
+			print_list(dumpfile, sym->defn);
+			putc('\n', dumpfile);
+
+			visited_symbols = sym->visited;
+			sym->visited = NULL;
+		}
+	}
+
--- ./projects/linux/linux-2.6.21/scripts/genksyms/genksyms.c	2007-04-26 05:08:32.000000000 +0200
+++ ./projects/linux/linux-2.6.22/scripts/genksyms/genksyms.c	2007-07-09 01:32:17.000000000 +0200
@@ -519 +519,2 @@
-	if ((strcmp(arch, "v850") == 0) || (strcmp(arch, "h8300") == 0))
+	if ((strcmp(arch, "v850") == 0) || (strcmp(arch, "h8300") == 0)
+	    || (strcmp(arch, "blackfin") == 0))
--- ./projects/linux/linux-2.6.24/scripts/genksyms/genksyms.c	2008-01-24 23:58:37.000000000 +0100
+++ ./projects/linux/linux-2.6.25/scripts/genksyms/genksyms.c	2008-04-17 04:49:44.000000000 +0200
@@ -443 +443 @@
-	fputs("Usage:\n" "genksyms [-dDwqhV] > /path/to/.tmp_obj.ver\n" "\n"
+	fputs("Usage:\n" "genksyms [-adDTwqhV] > /path/to/.tmp_obj.ver\n" "\n"
@@ -444,0 +445 @@
+	      "  -a, --arch            Select architecture\n"
@@ -446,0 +448 @@
+	      "  -T, --dump-types file Dump expanded types into file (for debugging only)\n"
@@ -451,0 +454 @@
+	      "  -a                    Select architecture\n"
@@ -453,0 +457 @@
+	      "  -T file               Dump expanded types into file (for debugging only)\n"
@@ -480 +484 @@
-	while ((o = getopt_long(argc, argv, "a:dwqVDT:k:p:",
+	while ((o = getopt_long(argc, argv, "a:dwqVDT:h",
@@ -483 +487 @@
-	while ((o = getopt(argc, argv, "a:dwqVDT:k:p:")) != EOF)
+	while ((o = getopt(argc, argv, "a:dwqVDT:h")) != EOF)
--- ./projects/linux/linux-2.6.26/scripts/genksyms/genksyms.c	2008-07-13 23:51:29.000000000 +0200
+++ ./projects/linux/linux-2.6.27/scripts/genksyms/genksyms.c	2008-10-10 00:13:53.000000000 +0200
@@ -523,2 +523 @@
-	if ((strcmp(arch, "v850") == 0) || (strcmp(arch, "h8300") == 0)
-	    || (strcmp(arch, "blackfin") == 0))
+	if ((strcmp(arch, "h8300") == 0) || (strcmp(arch, "blackfin") == 0))
@@ -548,0 +548,2 @@
+			if (sym->is_extern)
+				fputs("extern ", dumpfile);
--- ./projects/linux/linux-2.6.28/scripts/genksyms/genksyms.c	2008-12-25 00:26:37.000000000 +0100
+++ ./projects/linux/linux-2.6.29/scripts/genksyms/genksyms.c	2009-03-24 00:12:14.000000000 +0100
@@ -45 +45,2 @@
-static int flag_debug, flag_dump_defs, flag_dump_types, flag_warnings;
+static int flag_debug, flag_dump_defs, flag_reference, flag_dump_types,
+	   flag_preserve, flag_warnings;
@@ -60,0 +62,2 @@
+static void print_location(void);
+static void print_type_name(enum symbol_type type, const char *name);
@@ -154 +157,2 @@
-		    strcmp(name, sym->name) == 0)
+		    strcmp(name, sym->name) == 0 &&
+		    sym->is_declared)
@@ -160,2 +164,18 @@
-struct symbol *add_symbol(const char *name, enum symbol_type type,
-			  struct string_list *defn, int is_extern)
+static int is_unknown_symbol(struct symbol *sym)
+{
+	struct string_list *defn;
+
+	return ((sym->type == SYM_STRUCT ||
+		 sym->type == SYM_UNION ||
+		 sym->type == SYM_ENUM) &&
+		(defn = sym->defn)  && defn->tag == SYM_NORMAL &&
+			strcmp(defn->string, "}") == 0 &&
+		(defn = defn->next) && defn->tag == SYM_NORMAL &&
+			strcmp(defn->string, "UNKNOWN") == 0 &&
+		(defn = defn->next) && defn->tag == SYM_NORMAL &&
+			strcmp(defn->string, "{") == 0);
+}
+
+struct symbol *__add_symbol(const char *name, enum symbol_type type,
+			    struct string_list *defn, int is_extern,
+			    int is_reference)
@@ -164,0 +185 @@
+	enum symbol_status status = STATUS_UNCHANGED;
@@ -167,3 +188,27 @@
-		if (map_to_ns(sym->type) == map_to_ns(type)
-		    && strcmp(name, sym->name) == 0) {
-			if (!equal_list(sym->defn, defn))
+		if (map_to_ns(sym->type) == map_to_ns(type) &&
+		    strcmp(name, sym->name) == 0) {
+			if (is_reference)
+				/* fall through */ ;
+			else if (sym->type == type &&
+				 equal_list(sym->defn, defn)) {
+				if (!sym->is_declared && sym->is_override) {
+					print_location();
+					print_type_name(type, name);
+					fprintf(stderr, " modversion is "
+						"unchanged\n");
+				}
+				sym->is_declared = 1;
+				return sym;
+			} else if (!sym->is_declared) {
+				if (sym->is_override && flag_preserve) {
+					print_location();
+					fprintf(stderr, "ignoring ");
+					print_type_name(type, name);
+					fprintf(stderr, " modversion change\n");
+					sym->is_declared = 1;
+					return sym;
+				} else {
+					status = is_unknown_symbol(sym) ?
+						STATUS_DEFINED : STATUS_MODIFIED;
+				}
+			} else {
@@ -171 +216,3 @@
-			return sym;
+				return sym;
+			}
+			break;
@@ -174,0 +222,12 @@
+	if (sym) {
+		struct symbol **psym;
+
+		for (psym = &symtab[h]; *psym; psym = &(*psym)->hash_next) {
+			if (*psym == sym) {
+				*psym = sym->hash_next;
+				break;
+			}
+		}
+		--nsyms;
+	}
+
@@ -185,0 +245,4 @@
+	sym->is_declared = !is_reference;
+	sym->status = status;
+	sym->is_override = 0;
+
@@ -198,0 +262,12 @@
+struct symbol *add_symbol(const char *name, enum symbol_type type,
+			  struct string_list *defn, int is_extern)
+{
+	return __add_symbol(name, type, defn, is_extern, 0);
+}
+
+struct symbol *add_reference_symbol(const char *name, enum symbol_type type,
+				    struct string_list *defn, int is_extern)
+{
+	return __add_symbol(name, type, defn, is_extern, 1);
+}
+
@@ -238,0 +314,84 @@
+#define ARRAY_SIZE(arr) (sizeof(arr) / sizeof((arr)[0]))
+
+struct string_list *read_node(FILE *f)
+{
+	char buffer[256];
+	struct string_list node = {
+		.string = buffer,
+		.tag = SYM_NORMAL };
+	int c;
+
+	while ((c = fgetc(f)) != EOF) {
+		if (c == ' ') {
+			if (node.string == buffer)
+				continue;
+			break;
+		} else if (c == '\n') {
+			if (node.string == buffer)
+				return NULL;
+			ungetc(c, f);
+			break;
+		}
+		if (node.string >= buffer + sizeof(buffer) - 1) {
+			fprintf(stderr, "Token too long\n");
+			exit(1);
+		}
+		*node.string++ = c;
+	}
+	if (node.string == buffer)
+		return NULL;
+	*node.string = 0;
+	node.string = buffer;
+
+	if (node.string[1] == '#') {
+		int n;
+
+		for (n = 0; n < ARRAY_SIZE(symbol_type_name); n++) {
+			if (node.string[0] == symbol_type_name[n][0]) {
+				node.tag = n;
+				node.string += 2;
+				return copy_node(&node);
+			}
+		}
+		fprintf(stderr, "Unknown type %c\n", node.string[0]);
+		exit(1);
+	}
+	return copy_node(&node);
+}
+
+static void read_reference(FILE *f)
+{
+	while (!feof(f)) {
+		struct string_list *defn = NULL;
+		struct string_list *sym, *def;
+		int is_extern = 0, is_override = 0;
+		struct symbol *subsym;
+
+		sym = read_node(f);
+		if (sym && sym->tag == SYM_NORMAL &&
+		    !strcmp(sym->string, "override")) {
+			is_override = 1;
+			free_node(sym);
+			sym = read_node(f);
+		}
+		if (!sym)
+			continue;
+		def = read_node(f);
+		if (def && def->tag == SYM_NORMAL &&
+		    !strcmp(def->string, "extern")) {
+			is_extern = 1;
+			free_node(def);
+			def = read_node(f);
+		}
+		while (def) {
+			def->next = defn;
+			defn = def;
+			def = read_node(f);
+		}
+		subsym = add_reference_symbol(xstrdup(sym->string), sym->tag,
+					      defn, is_extern);
+		subsym->is_override = is_override;
+		free_node(sym);
+	}
+}
+
@@ -313,0 +473 @@
+			/* FIXME: Bad reference files can segfault here. */
@@ -350 +510,13 @@
-				n->string = xstrdup("{ UNKNOWN }");
+				n->string = xstrdup("{");
+				n->tag = SYM_NORMAL;
+				n->next = t;
+				t = n;
+
+				n = xmalloc(sizeof(*n));
+				n->string = xstrdup("UNKNOWN");
+				n->tag = SYM_NORMAL;
+				n->next = t;
+				t = n;
+
+				n = xmalloc(sizeof(*n));
+				n->string = xstrdup("}");
@@ -352,0 +525 @@
+				t = n;
@@ -399,0 +573 @@
+		int has_changed = 0;
@@ -405,0 +580,2 @@
+		sym->expansion_trail = expansion_trail;
+		expansion_trail = sym;
@@ -410,0 +587,17 @@
+
+			if (sym->status != STATUS_UNCHANGED) {
+				if (!has_changed) {
+					print_location();
+					fprintf(stderr, "%s: %s: modversion "
+						"changed because of changes "
+						"in ", flag_preserve ? "error" :
+						       "warning", name);
+				} else
+					fprintf(stderr, ", ");
+				print_type_name(sym->type, sym->name);
+				if (sym->status == STATUS_DEFINED)
+					fprintf(stderr, " (became defined)");
+				has_changed = 1;
+				if (flag_preserve)
+					errors++;
+			}
@@ -413,0 +607,2 @@
+		if (has_changed)
+			fprintf(stderr, "\n");
@@ -423,0 +619,14 @@
+
+static void print_location(void)
+{
+	fprintf(stderr, "%s:%d: ", cur_filename ? : "<stdin>", cur_line);
+}
+
+static void print_type_name(enum symbol_type type, const char *name)
+{
+	if (type != SYM_NORMAL)
+		fprintf(stderr, "%s %s", symbol_type_name[type], name);
+	else
+		fprintf(stderr, "%s", name);
+}
+
@@ -429,2 +638 @@
-		fprintf(stderr, "%s:%d: ", cur_filename ? : "<stdin>",
-			cur_line);
+		print_location();
@@ -448 +656,3 @@
-	      "  -T, --dump-types file Dump expanded types into file (for debugging only)\n"
+	      "  -r, --reference file  Read reference symbols from a file\n"
+	      "  -T, --dump-types file Dump expanded types into file\n"
+	      "  -p, --preserve        Preserve reference modversions or fail\n"
@@ -457 +667,3 @@
-	      "  -T file               Dump expanded types into file (for debugging only)\n"
+	      "  -r file               Read reference symbols from a file\n"
+	      "  -T file               Dump expanded types into file\n"
+	      "  -p                    Preserve reference modversions or fail\n"
@@ -468 +680 @@
-	FILE *dumpfile = NULL;
+	FILE *dumpfile = NULL, *ref_file = NULL;
@@ -477,0 +690 @@
+		{"reference", 1, 0, 'r'},
@@ -478,0 +692 @@
+		{"preserve", 0, 0, 'p'},
@@ -484 +698 @@
-	while ((o = getopt_long(argc, argv, "a:dwqVDT:h",
+	while ((o = getopt_long(argc, argv, "a:dwqVDr:T:ph",
@@ -487 +701 @@
-	while ((o = getopt(argc, argv, "a:dwqVDT:h")) != EOF)
+	while ((o = getopt(argc, argv, "a:dwqVDr:T:ph")) != EOF)
@@ -507,0 +722,8 @@
+		case 'r':
+			flag_reference = 1;
+			ref_file = fopen(optarg, "r");
+			if (!ref_file) {
+				perror(optarg);
+				return 1;
+			}
+			break;
@@ -515,0 +738,3 @@
+		case 'p':
+			flag_preserve = 1;
+			break;
@@ -535,0 +761,3 @@
+	if (flag_reference)
+		read_reference(ref_file);
+
@@ -541,0 +770,2 @@
+			if (sym->is_override)
+				fputs("override ", dumpfile);
